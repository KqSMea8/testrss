<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ELK系列~nxlog实现多位置文件的收集 - 张占岭</title>
<link>http://www.cnblogs.com/lori/p/7732926.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lori/p/7732926.html</guid>
<description>&lt;p&gt;&lt;span&gt;前几天我写了几篇关于ELK日志收集，存储和分析的文章：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/lori/p/7716093.html&quot;&gt;ELK系列~NLog.Targets.Fluentd到达如何通过tcp发到fluentd&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/lori/p/7723243.html&quot;&gt;ELK系列~Nxlog日志收集加转发(解决log4日志换行导致json转换失败问题)&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/lori/p/7727375.html&quot;&gt;ELK系列~log4-nxlog-Fluentd-elasticsearch写json数据需要注意的几点&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今天主要说一个日志收集里的多输入端（收集多个网站的日志）的实现方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于日志的收集与转发来说，nxlog可以说很不错，异步将本地日志上传到对象的服务端，而且支持的服务端也很多，在nxlog里这些服务端都叫“输出端”，在nxlog.conf里使用output表示，而我们的日志是输入端，用input表示，下面来讲一下如何实现多输入端的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实很简单，只要在nxlog.conf里配置一下就可以了，具体代码如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;Input &lt;span&gt;in1&lt;/span&gt;&amp;gt;&lt;span&gt;
    Module    im_file
    File    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c:\dotnet\20*.log&lt;/span&gt;&lt;span&gt;&quot;&lt;br/&gt;&lt;/span&gt;&amp;lt;/Input&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&amp;lt;Input &lt;span&gt;in2&amp;gt;&lt;span&gt;
    Module    im_file
    File    &lt;span&gt;&quot;&lt;span&gt;c:\dotnet\20*.log&lt;span&gt;&quot;&lt;span&gt;
&lt;span&gt; &amp;lt;/Input&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&amp;lt;Output &lt;span&gt;out&lt;/span&gt;&amp;gt;&lt;span&gt; &lt;br/&gt;Module om_tcp &lt;br/&gt;Host &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;200.214&lt;/span&gt;&lt;span&gt; &lt;br/&gt;Port &lt;/span&gt;&lt;span&gt;24224&lt;/span&gt;&lt;span&gt; &lt;br/&gt;Exec $raw_event &lt;/span&gt;=$raw_event + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;; &lt;br/&gt;&lt;/span&gt;&amp;lt;/Output&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&amp;lt;Route &lt;span&gt;1&amp;gt;&lt;span&gt; 
    Path        &lt;span&gt;in1,in2 =&amp;gt; &lt;span&gt;out
&amp;lt;/Route&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的route节点，将in1和in2两个输入端指向了一个out输出端，咱们的输出端实现fluentd来实现的！&lt;/p&gt;
&lt;p&gt;感谢各位阅读！&lt;/p&gt;
&lt;p&gt;晚安！&lt;/p&gt;
</description>
<pubDate>Wed, 25 Oct 2017 14:53:00 +0000</pubDate>
<dc:creator>张占岭</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lori/p/7732926.html</dc:identifier>
</item>
<item>
<title>2018秋招前端总结 - Wayne-Zhu</title>
<link>http://www.cnblogs.com/zhuzhenwei918/p/7732819.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuzhenwei918/p/7732819.html</guid>
<description>&lt;p&gt;&lt;br/&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从8月中旬实习结束就开始找工作了，一直到十一，终于尘埃落定，在博客园写文章也有一年了，写博客也真的可以获得很多，这里做一个总结。 &lt;/p&gt;
&lt;p&gt; 非科班，但自己比较喜欢前端，所以最后虽然没有拿到bat的offer，但最后也收到了自己满意的。&lt;/p&gt;
&lt;p&gt;比较后悔的时内推比较晚了，之前实习一直没有在意，实习回来内推已经不多了，我笔试也比较菜，所以前期挂到绝望。。。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;笔试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;笔试没有太多的方法，主要就是刷题，牛客网上的题、剑指offer等等，由于自身不是科班，秋招之前准备的也不是很充分，自学了计算机网络、操作系统、数据结构课程，但是算法一直都是弱项，只是把剑指offer刷了好几遍，才能勉强过一些公司的笔试。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;面试技巧&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、多看面经。多看，多总结，很多知识点都是常考的，提前看看没有坏处。&lt;/p&gt;
&lt;p&gt;2、多面。对于水平一般的同学，可以在前期多投一些公司，不管大的小的。小的公司可以帮助你积累面试经验，这样，在后面面试大公司的时候心里也就有底了。&lt;/p&gt;
&lt;p&gt;3、尽量去表现自己，表现的自信一些。 在后面的面试中，如果你都会，你就可以很自信的去回答，去拓展，这样和面试官交流起来也是非常愉快的。&lt;/p&gt;
&lt;p&gt;4、往自己擅长的方向引导。我们不可能对于所有的知识点都掌握的很好，但是可以主动说出自己的想法，主动往自己擅长的方向去引导。不会就是不会，不要说可能之类的不确定的话。 如果是‘可能’，那么就表现的对知识点的不深入，这是面试官所不希望的。我觉得比较好的方法就是直接说不会，然后可以给出自己的思路，即把你思考的过程表达出来； 也可以是我没有看XXX，是因为我觉得YYY更加更重要，优先级更高一些，但计划后期回去看XXX。&lt;/p&gt;

&lt;p&gt;之前也记了一些公司的面试，但很多都记不全了，只是把印象比较深刻的列出来。&lt;br/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;蘑菇街 （内推一面挂）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、蘑菇街是内推的，但刚刚实习回来，很多都没有复习，所以一面就挂了。&lt;/p&gt;
&lt;p&gt;2、自我介绍&lt;/p&gt;
&lt;p&gt;3、如何实现一个倒计时功能，类似于蘑菇街中的秒杀。&lt;/p&gt;
&lt;p&gt;4、怎么理解es6箭头函数中的this，它和一般函数的this指向有什么区别呢？&lt;/p&gt;
&lt;p&gt;5、一个矩形，里面一个樱桃，过樱桃做一条直线， 并且没有数据和测量工具，如果做到评分矩形呢？&lt;/p&gt;
&lt;p&gt;6、说一下同源策略&lt;/p&gt;
&lt;p&gt;7、vue中的路由时如何管理的？ 你知道他的实现方式吗？&lt;/p&gt;
&lt;p&gt;8、提到了我的博客，问我的博客相关问题。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;猎豹（内推一面挂）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、猎豹应该是第二个面试的，当时回答的还可以，整体问的也不深，但莫名其妙的就挂了。。&lt;/p&gt;
&lt;p&gt;2、retina屏幕的了解&lt;/p&gt;
&lt;p&gt;3、说一说移动端的布局。 flexible。&lt;/p&gt;
&lt;p&gt;4、知道原理吗，怎么自己去实现一个flexible。 rem布局的实现原理。移动端的点透是什么，有没有了解&lt;/p&gt;
&lt;p&gt;5、说一说异步编程的方式有哪些。&lt;/p&gt;
&lt;p&gt;6、项目中的设计是怎么回事，说说设计方面。&lt;/p&gt;
&lt;p&gt;7、你博客里的轮播图，如果还要优化，你会怎么去优化。&lt;/p&gt;
&lt;p&gt;8、你最喜欢的es6中的特性是什么，为什么。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;商汤科技（内推一面挂）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;商汤面试还是有一定难度的，之前准备的也不太好，卒。&lt;/p&gt;
&lt;p&gt;1、为什么选择前端（不是科班，这个问题经常被问。。。）&lt;/p&gt;
&lt;p&gt;2、css布局的属性有哪些。&lt;/p&gt;
&lt;p&gt;3、有没有遇到过这样的问题： 一个有border的div，里面有一个图片，发现图片和下面的border有一定的空隙（baseline）。&lt;/p&gt;
&lt;p&gt;4、函数调用的方式有哪些。他们的区别是什么。&lt;/p&gt;
&lt;p&gt;5、说一说原型链（这个要非常清楚）。&lt;/p&gt;
&lt;p&gt;6、用过什么框架。jquery用过吗？&lt;/p&gt;
&lt;p&gt;7、你实习公司的前端leader是谁。&lt;/p&gt;
&lt;p&gt;8、给你一个项目，你使用jquery还是vue、react。为什么。（这个问题也是会被经常问到的）&lt;/p&gt;
&lt;p&gt;9、说一说异步编程。&lt;/p&gt;
&lt;p&gt;10、说一说回调地狱是什么，有什么问题。异常捕获怎么做。&lt;/p&gt;
&lt;p&gt;11、说一说promise。 一个promise有多个then，如果第一个then出错，后面的还会执行吗，如何捕获异常。 如果第一个then出错了，我还想要后面的继续执行，应该怎么做。&lt;/p&gt;
&lt;p&gt;12、你在学习js的时候，遇到过哪些js方面的坑、 你觉得js哪些知识会难一些。&lt;/p&gt;
&lt;p&gt;其实到这里就可以看出来很多问题都是重复的了。。。&lt;/p&gt;


&lt;p&gt;&lt;br/&gt;&lt;strong&gt;TP-LINK&lt;/strong&gt; &lt;strong&gt;（走完流程，莫名挂）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;tplink整体面的还是比较水的，但最后走完流程就没有消息了，应该是挂了。大概只记得下面这些了。&lt;/p&gt;
&lt;p&gt;1、你的成绩怎么样？ 为什么不学习原专业？&lt;/p&gt;
&lt;p&gt;2、登录状态怎么保持？&lt;/p&gt;
&lt;p&gt;3、为什么用本地存储，而不用session，session更加简单啊！&lt;/p&gt;
&lt;p&gt;4、http和https的区别是什么？ （http、https、http2这些都是经常被问到的）&lt;/p&gt;
&lt;p&gt;5、post和get的区别是什么？&lt;/p&gt;
&lt;p&gt;6、你会的技术有哪些？&lt;/p&gt;
&lt;p&gt;7、你在学校社团是做什么的，你是做什么的？&lt;/p&gt;
&lt;p&gt;8、为什么不愿意留在暑期实习的公司？&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;北京绿盟科技（走完流程，挂）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;绿盟是在西安分公司面的，但是投递的北京的岗位，几次面试聊的都很好，问的很多，但也都比较基础，答得不错，最后估计也是挂了。&lt;/p&gt;
&lt;p&gt;1、vue和react有什么区别？&lt;/p&gt;
&lt;p&gt;2、angular用过吗？&lt;/p&gt;
&lt;p&gt;3、说一下同源策略？ 说一个JSONP？  （同源策略和跨域的多种方式还是要很熟练的）&lt;/p&gt;
&lt;p&gt;4、304和200的区别是什么。 （状态码也是必须要掌握的，包括各种区别）&lt;/p&gt;
&lt;p&gt;5、你所知道的前端优化有哪些内容？ （常考的问题，多多总结就好了）&lt;/p&gt;
&lt;p&gt;6、linux知道吗？ 你所知道的linux命令有哪些？&lt;/p&gt;
&lt;p&gt;7、vue中v-if和v-show的区别是什么？ （这个实在是记不住了，但是说明了vue不好就是因为api太多）&lt;/p&gt;
&lt;p&gt;8、你看过哪些书? （比如计算机的几门专业课、JavaScript高级程序设计、css揭秘、你不知道的JavaScript、深入react技术栈、图解http等等）&lt;/p&gt;
&lt;p&gt;9、你会的技术包括哪些&lt;/p&gt;
&lt;p&gt;10、为什么不学习原专业，而是要转行。&lt;/p&gt;
&lt;p&gt;11、为什么选择了北京而不是西安。&lt;/p&gt;
&lt;p&gt;12、项目问题。&lt;/p&gt;




&lt;p&gt;&lt;strong&gt;有赞 （走完流程等结果）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还是比较喜欢杭州这个城市的，但阿里、网易笔试就挂了，所以最后投了有赞，目前在等结果。&lt;/p&gt;
&lt;p&gt;有赞的前端技术应该还是不错的，问的基础和项目都不错，能学到不少知识。&lt;/p&gt;
&lt;p&gt;1、一个DOM树，其中有两个节点，找出这两个节点公共的父节点？ （视频面试）&lt;/p&gt;
&lt;p&gt;2、说一下二叉树？&lt;/p&gt;
&lt;p&gt;3、如果反转二叉树？&lt;/p&gt;
&lt;p&gt;5、简洁、对于不同的类型，如何做出对比？&lt;/p&gt;
&lt;p&gt;6、说一下vue和react中的路由实现方式？&lt;/p&gt;
&lt;p&gt;7、说一下强缓存和协商缓存？ （浏览器的缓存机制也需要很清楚）&lt;/p&gt;
&lt;p&gt;8、跨域？&lt;/p&gt;
&lt;p&gt;9、说一下设计模式？&lt;/p&gt;
&lt;p&gt;10、其中的一个项目，你究竟做了哪些优化？&lt;/p&gt;
&lt;p&gt;11、websocket聊天室如果发送失败了，你怎么解决这个问题？如何做到发送图片？ 有了文字、图片等不同的数据类型之后，你如何实现数据的存储，如何设计，前端如何获取？&lt;/p&gt;
&lt;p&gt;12、websocket聊天室有输入框，那么怎么获取的，对于使用div来模仿textarea，我说使用正则去掉div，那么用户输入的也是div呢？   如果发送失败了呢？  究竟应该是先发送，还是应该先存储到redux中，考虑用户体验（仿照微信）。&lt;/p&gt;
&lt;p&gt;13、为什么数据库使用的是mongodb而不是mysql。&lt;/p&gt;
&lt;p&gt;14、什么是xss，如何防止xss？&lt;/p&gt;
&lt;p&gt;15、边边购项目说一下？登录的整个过程是什么？ 购物车是怎么存储设计的？ 如果LocalStorage中数据的值超过了范围，你该如何去处理这个问题？ 如果商品下架了，那么你如何显示这个商品？ 登录的过程中，一个用户退出登录，另一个用户登录，那么这个购物车是否还是存在的。 说一下边边购项目的多个不同的模块。&lt;/p&gt;
&lt;p&gt;16、说一下你说的项目中遇到的问题，然后你是如何解决这个问题的？ （这个可以好好准备一下~）&lt;/p&gt;
&lt;p&gt;17、websocket的使用，底层是如何处理的。（类似于xhr的。）、&lt;/p&gt;
&lt;p&gt;18、websocket在连接的过程中， 会有新包。。balabala 一堆听不懂的词，非常尴尬，，， 我就直接说的不会。&lt;/p&gt;
&lt;div readability=&quot;36&quot;&gt;
&lt;p&gt;最后三面就简单的问了一些问题，然后就hr面了。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;腾讯（霸面挂）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还是非常喜欢腾讯的，无奈第一次霸面就挂了。。虽然面试官全程黑着脸，但是还是可以感觉出技术实力很强。&lt;/p&gt;
&lt;p&gt;1、手写代码 判断是否是浏览器环境。&lt;/p&gt;
&lt;p&gt;2、http和https https的整个过程画一下&lt;/p&gt;
&lt;p&gt;3、httPS需要多少时间 比http慢多少 怎么优化&lt;/p&gt;
&lt;p&gt;4、https有什么缺点&lt;/p&gt;
&lt;p&gt;5、手写快速排序 复杂度 最慢是多少 为什么取第一个值作为中间值 如果这个值是最大的或者最小的怎么办&lt;/p&gt;
&lt;p&gt;6、http2有哪些特性 头部压缩怎么回事&lt;/p&gt;
&lt;p&gt;7、100层 1个花瓶仍 找到n层不碎 n + 1层碎了的情况 2个花瓶呢&lt;/p&gt;
&lt;p&gt;8、node了解多少 全局对象是什么&lt;/p&gt;
&lt;p&gt;9、事件机制说一下 事件绑定说一下 手写如何把div中的a放在平级其中的事件会怎么样 冒泡会到document还是window&lt;/p&gt;
&lt;p&gt;10、推荐一下身边厉害的人，你觉得你比他厉害吗。为什么&lt;/p&gt;
&lt;p&gt;11、xss怎么防范 尖括号应该怎么过滤，一直问确定吗，最后也没说清楚&lt;/p&gt;
&lt;p&gt;12、用过哪些框架&lt;/p&gt;
&lt;p&gt;13、移动端如何真机调试&lt;/p&gt;
&lt;p&gt;14、tap是怎么回事、和click的区别。。。&lt;/p&gt;
&lt;br/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;网宿（ offer&lt;/strong&gt; &lt;strong&gt; ）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网宿面试不难，只有一面，问的恰好都会，给了sp。 但大部分都记不清了。。&lt;/p&gt;
&lt;p&gt;1、cookie和session有什么区别&lt;/p&gt;
&lt;p&gt;2、说一下浏览器缓存问题&lt;/p&gt;
&lt;p&gt;3、动态规划是怎么回事&lt;/p&gt;
&lt;p&gt;4、进程和线程的区别是什么&lt;/p&gt;
&lt;p&gt;5、说一下restful api吧，&lt;/p&gt;
&lt;p&gt;6、说一说post和get的区别，&lt;/p&gt;
&lt;p&gt;7、说一下状态码吧&lt;/p&gt;
&lt;p&gt;8、你觉得什么样的代码是好的代码 （这个其实还挺考验实力的）&lt;/p&gt;
&lt;p&gt;9、说一下position的几个属性吧。&lt;/p&gt;
&lt;p&gt;10、typescript你用过吗？&lt;/p&gt;
&lt;p&gt;最后又聊了一下部门的情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;乐信（二面结束，进行中）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、说一下你做过的几个项目吧。&lt;/p&gt;
&lt;p&gt;2、框架对比一下&lt;/p&gt;
&lt;p&gt;3、cookie和session有什么区别，cookie的大小是多少。&lt;/p&gt;
&lt;p&gt;4、css3了解多少，说到了渐进增强和优雅降级&lt;/p&gt;
&lt;p&gt;5、vue接触过多长时间、react接触过多长时间、&lt;/p&gt;
&lt;p&gt;6、你对互联网公司怎么看，你想要什么样的公司、未来是怎么样的。&lt;/p&gt;
&lt;p&gt;7、乐信你了解多少，你对来深圳工作怎么看。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;美团（offer ）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;美团面试还是有深度的。&lt;/p&gt;
&lt;p&gt;1、你还转载过美团的文章？嗯 （很多面试官还是会看博客的，谢谢博客总是好的）&lt;/p&gt;
&lt;p&gt;2、cookie和localStorage区别，如何把cookie写在一个对象中，其属性就是键值对&lt;/p&gt;
&lt;p&gt;3、实现水平竖直居中的几中方法（高度和宽度不确定）&lt;/p&gt;
&lt;p&gt;4、flex是什么&lt;/p&gt;
&lt;p&gt;5、深拷贝和浅拷贝的区别，手写深拷贝 （博客里总结过，遂让手撕）&lt;/p&gt;
&lt;p&gt;6、Oject的几中方式，如何区分 （这个也是常考的）&lt;/p&gt;
&lt;p&gt;7、兼容性说一说，你做的PC端兼容性是到哪的&lt;/p&gt;
&lt;p&gt;8、如何看待最近react事件 （百度、wordpress弃用事件。可以多关注前端的一些动态）&lt;/p&gt;
&lt;p&gt;9、JQuery和三大框架的区别，react和vue的区别&lt;/p&gt;
&lt;p&gt;10、说一说CSS3中的动画，animation中可以取哪些值 （css3动画也很重要）&lt;/p&gt;
&lt;p&gt;11、flex布局是什么，默认的方向是什么，如何改变方向&lt;/p&gt;
&lt;p&gt;12、你的博客都是自己写的吗？ 你所有所学都会写成博客吗？&lt;/p&gt;
&lt;p&gt;13、说一说原型和原型链，object是最上面的吗？&lt;/p&gt;
&lt;p&gt;14、vue中的数据双向绑定是如何实现的、&lt;/p&gt;
&lt;p&gt;15、display有哪些，回答了7 8个，还是不满意&lt;/p&gt;
&lt;p&gt;16、你的node项目中有几个线程，有几个进程，如果node进程崩溃了，如何知道&lt;/p&gt;
&lt;p&gt;17、node中的process是什么&lt;/p&gt;
&lt;p&gt;18、node中如何创建子进程/19讲一讲你遇到的比较困难的事情，问了两个，最后是怎么解决的&lt;/p&gt;
&lt;p&gt;19、CSS中的单位有哪些分别说一说 （提到了ex）&lt;/p&gt;
&lt;p&gt;20、你未来的发展规划是怎么样的&lt;/p&gt;
&lt;p&gt;21、跨域，举一个例子，安全性问题到底在哪里&lt;/p&gt;
&lt;p&gt;22、100万个数据中，找出前10大数据，最快的方法是什么，堆排序怎么写&lt;/p&gt;
&lt;p&gt;23、登录状态怎么使用cookie保持，最好的方法是什么&lt;/p&gt;
&lt;p&gt;24、页面中一个video，可能格式不支持，那么前端如何判断并给出提示？&lt;/p&gt;
&lt;p&gt;25、通过比较img的onerror是一种方法， 通过服务器端也可以保存一些属性来标识哪些浏览器支持，哪些不支持&lt;/p&gt;
&lt;p&gt;26、为什么要用vue和react，而不用JQuery，给你一个项目，什么情况下使用单页面应用，什么情况下使用多页面应用。&lt;/p&gt;
&lt;p&gt;27、你所知道的前端大会有哪些，比如腾讯web前端大会，CSS conf大会，js conf大会。&lt;/p&gt;
&lt;p&gt;28、你学习的前端号有哪些，比如前端早读课，那么维护者是谁。&lt;/p&gt;
&lt;p&gt;29、前端的表单中如何设置表单的方式，如multipart, www等，对于multipart具体是如何区分其中的不同的格式的&lt;/p&gt;
&lt;p&gt;30、http2的所有特性。&lt;/p&gt;
&lt;p&gt;31、http2中的头部压缩和多路复用。&lt;/p&gt;
&lt;p&gt;三面主要是拓展，会比较难。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;迅雷（offer）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、迅雷一面比较基础，二面会根据项目扩展，体验还是不错的，和面试官聊得很开心。&lt;/p&gt;
&lt;p&gt;2、post、put和get的区别什么&lt;/p&gt;
&lt;p&gt;3、localStorage和sessionstorage的区别是什么&lt;/p&gt;
&lt;p&gt;4、页面加载速度很慢，如何加速页面的渲染&lt;/p&gt;
&lt;p&gt;5、输入了一个URL之后发生了什么&lt;/p&gt;
&lt;p&gt;6、图片很大，如何进行优化&lt;/p&gt;
&lt;p&gt;7、手写二分查找&lt;/p&gt;
&lt;p&gt;8、画出TCP三次握手的过程&lt;/p&gt;
&lt;p&gt;9、websocket是如何实现服务器端推送的&lt;/p&gt;
&lt;p&gt;10、你对迅雷了解多少？&lt;/p&gt;
&lt;p&gt;11、websocket和http的区别是什么？websocket的优点是什么？&lt;/p&gt;
&lt;p&gt;12、为什么使用websocket？ websocket是怎么连接的，一定需要通过http协议吗？ 短轮询、commet、长轮训都介绍一下。各有什么优缺点。&lt;/p&gt;
&lt;p&gt;13、聊天室如何兼容IE8&lt;/p&gt;
&lt;p&gt;14、http1.1中的keep-alive是怎么理解的？&lt;/p&gt;
&lt;p&gt;15、setTimeout和setInterval&lt;/p&gt;
&lt;p&gt;16、原型、原型链、继承等。&lt;/p&gt;
&lt;p&gt;17、http1.0、http1.1、http2  （这三者还是要会区分的，也会经常被问到）&lt;/p&gt;
&lt;p&gt;18、css3动画相关&lt;/p&gt;
&lt;p&gt;19、html、css、js分别实现一个动画效果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;华为（走完流程，备胎）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;华为面试比较简单，就是一些开放性的问题，还有快速排序等等。&lt;br/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;CVTE（offer）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;cvte是实习转正的。&lt;/p&gt;
&lt;p&gt;其实在cvte实习的一段时间里，也是学到了很多东西的，吃住也都非常棒，办公室的环境也都很好，大家都很单纯，加班情况也并不严重，部门也会经常聚餐，至少从一个实习生的角度来说，还是非常推荐的。&lt;br/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;今日头条（offer）&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;今日头条的面试记不清了，整体是技术三面，一个上午就面完了，难度是递增的，最后还是幸运的拿到了offer。 &lt;/p&gt;



&lt;p&gt;后面还有一些面试也都拒了，秋招到此正式结束。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;最后的话&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不抛弃，不放弃，足矣。 &lt;/p&gt;
</description>
<pubDate>Wed, 25 Oct 2017 14:27:00 +0000</pubDate>
<dc:creator>Wayne-Zhu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuzhenwei918/p/7732819.html</dc:identifier>
</item>
<item>
<title>Nginx配置详解 - Eric zhou</title>
<link>http://www.cnblogs.com/tianqing/p/7732640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianqing/p/7732640.html</guid>
<description>&lt;p&gt;前两篇文章介绍了Nginx反向代理和动态路由：&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_1&quot; class=&quot;postTitle1&quot; href=&quot;http://www.cnblogs.com/tianqing/p/7616735.html&quot;&gt;Ngnix技术研究系列1-通过应用场景看Nginx的反向代理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0&quot; class=&quot;postTitle1&quot; href=&quot;http://www.cnblogs.com/tianqing/p/7617358.html&quot;&gt;Ngnix技术研究系列2-基于Redis实现动态路由&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;随着研究的深入，很重要的一点就是了解Nginx各个配置和作用。整理一下分享给大家。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、先说Nginx配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Nginx的配置文件是一个普通的纯文本文件，使用了Nginx自定义的一套配置语法，更接近于脚本语言，混合了Shell、Perl和C的部分特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用#开始一个注释行&lt;/li&gt;
&lt;li&gt;配置指令以分号结束，可以接受多个参数，用空白字符分隔&lt;/li&gt;
&lt;li&gt;可以使用单引号或者双引号来定义字符串，允许用“\”转义字符&lt;/li&gt;
&lt;li&gt;配置指令和参数也可以使用引号来指定，特别是当它含有空格的时候&lt;/li&gt;
&lt;li&gt;配置块（block）的特殊的配置指令，它有一个{…}参数且无须分号结束，｛…｝里面可以包含多个配置指令，相当于C语言里的复合语句&lt;/li&gt;
&lt;li&gt;有的配置指令只能出现在指定的配置块中（即语境Context）&lt;/li&gt;
&lt;li&gt;配置块里可以再包含配置块，嵌套层次没有限制，但需符合配置块的语义&lt;/li&gt;
&lt;li&gt;可以使用include指令包含其他配置文件，支持“*”通配符，类似C语言&lt;/li&gt;
&lt;li&gt;使用$var可以引用预定义的一些变量，增加配置的灵活性&lt;/li&gt;
&lt;li&gt;不能识别或错误的配置指令会导致Nginx解析失败，无法启动&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Ngnix配置文件的默认位置在：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/usr/local/openresty/nginx/conf/nginx.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以复制新建一个配置文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 二、进程配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程配置指令不属于任何配置块，只能在全局域（&lt;strong&gt;main&lt;/strong&gt;）配置&lt;br/&gt;&lt;strong&gt;worker_processes number | auto;&lt;/strong&gt;&lt;br/&gt;设置Nginx能够启动的worker进程的数量，它直接影响Nginx的性能。通常当worker的数量与服务器的CPU核心数相等时，可以获取最佳的性能，这时每一个worker都会工作在一个独立的CPU核心上，完全消除CPU调度的成本。（需配合worker_cpu_affinity指令）&lt;br/&gt;Worker_processes的默认值是1. 如果不清楚服务器CPU核心数量，那么可以设置为auto参数，Nginx会尝试探测数量并设置。cat /proc/cpuinfo | grep processor&lt;br/&gt;&lt;strong&gt;master_process on | off;&lt;/strong&gt;&lt;br/&gt;决定是否启用Nginx的进程池机制，默认值是on，如果设置为off，那么Nginx不会建立master进程，只会用一个worker进程处理请求，worker_processes指令也会失效，并发处理能力大大下降。&lt;br/&gt;&lt;strong&gt;worker_cpu_affinity auto [cpumask];&lt;/strong&gt;&lt;br/&gt;指定worker进程运行在某个CPU核心上，即CPU绑定，对于多核心的CPU来说可以减少CPU切换，提高Cache命中率，让Nginx更充分地利用CPU资源&lt;br/&gt;Worker_processes 4;&lt;br/&gt;Worker_cpu_affinity 0001 0010 0100 1000;&lt;br/&gt;1.9.10之前，只能使用掩码的方式手工绑定，现在则可以用auto参数让Nginx自动绑定CPU。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;worker_directory path;&lt;/strong&gt;&lt;br/&gt;配置Nginx的工作目录，实际上仅用来存放coredump文件，在Nginx发生意外崩溃时可以用gdb调试查找原因。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、运行日志配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Nginx中运行日志分为两种，记录TCP/HTTP访问请求的access_log和记录服务器错误信息的error_log&lt;br/&gt;&lt;strong&gt;error_log file|stderr level ;&lt;/strong&gt;&lt;br/&gt;指定Nginx的运行错误日志，默认是安装目录下的logs/error.log 支持设置其他路径，或者使用标准错误输出stderr。第二个参数level是日志允许输出级别，取值是debug|info|notice|warn|error|crit|alert|emerg, 只有高于这个级别的日志才会记录下来，默认值是error&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、Events配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Nginx采用事件驱动，利用操作系统内核提供的epoll、kqueue等系统调用来高效地处理网络连接，events配置块就是用来配置Nginx的事件机制。Events配置指令不多，默认配置就饿可以工作的很好&lt;br/&gt;&lt;strong&gt;worker_connections number;&lt;/strong&gt;&lt;br/&gt;设置每个worker进程可以处理的最大连接数量，它决定了Nginx的并发能力。这个指令决定了单个进程的处理能力。Nginx的整体最大可处理的连接数再乘上worker_processes的数量。&lt;br/&gt;worker_connections的默认值是1024，可根据实际情况适当增大。&lt;/p&gt;
&lt;p&gt;五、Http配置&lt;/p&gt;
&lt;p&gt;Nginx使用http块配置HTTP相关的所有功能，包括cache、fastcgi、gzip、server、location、proxy、upsteam等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;http {
    include       mime.types;
    default_type  application&lt;/span&gt;/octet-&lt;span&gt;stream;

    #log_format  main  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    #                  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$status $body_bytes_sent &quot;$http_referer&quot; &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    #                  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

    #access_log  logs&lt;/span&gt;/&lt;span&gt;access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    keepalive_timeout  &lt;/span&gt;&lt;span&gt;65&lt;/span&gt;&lt;span&gt;;

    #&lt;/span&gt;&lt;span&gt;gzip&lt;/span&gt;&lt;span&gt;  on;

    server {
        listen       &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
        server_name  localhost;

        #charset koi8&lt;/span&gt;-&lt;span&gt;r;

        #access_log  logs&lt;/span&gt;/&lt;span&gt;host.access.log  main;

        location &lt;/span&gt;/&lt;span&gt; {
            root   html;
            index  index.html index.htm;
        }

        #error_page  &lt;/span&gt;&lt;span&gt;404&lt;/span&gt;              /&lt;span&gt;404&lt;/span&gt;&lt;span&gt;.html;

        # redirect server error pages to the static page &lt;/span&gt;/&lt;span&gt;50x.html
        #
        error_page   &lt;/span&gt;&lt;span&gt;500&lt;/span&gt; &lt;span&gt;502&lt;/span&gt; &lt;span&gt;503&lt;/span&gt; &lt;span&gt;504&lt;/span&gt;  /&lt;span&gt;50x.html;
        location &lt;/span&gt;= /&lt;span&gt;50x.html {
            root   html;
        }

        # proxy the PHP scripts to Apache listening on &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&lt;span&gt;
        #
        #location &lt;/span&gt;~&lt;span&gt; \.php$ {
        #    proxy_pass   http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1;&lt;/span&gt;
&lt;span&gt;        #}

        # pass the PHP scripts to FastCGI server listening on &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;9000&lt;/span&gt;&lt;span&gt;
        #
        #location &lt;/span&gt;~&lt;span&gt; \.php$ {
        #    root           html;
        #    fastcgi_pass   &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;9000&lt;/span&gt;&lt;span&gt;;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  &lt;/span&gt;/&lt;span&gt;scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}

        # deny access to .htaccess files, &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; Apache&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s document root&lt;/span&gt;
        # concurs with nginx&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s one&lt;/span&gt;
&lt;span&gt;        #
        #location &lt;/span&gt;~ /&lt;span&gt;\.ht {
        #    deny  all;
        #}
    }


    # another virtual host using mix of IP&lt;/span&gt;-, name-, and port-&lt;span&gt;based configuration
    #
    #server {
    #    listen       &lt;/span&gt;&lt;span&gt;8000&lt;/span&gt;&lt;span&gt;;
    #    listen       somename:&lt;/span&gt;&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;;
    #    server_name  somename  alias  another.alias;

    #    location &lt;/span&gt;/&lt;span&gt; {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}


    # HTTPS server
    #
    #server {
    #    listen       &lt;/span&gt;&lt;span&gt;443&lt;/span&gt;&lt;span&gt; ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:&lt;/span&gt;!aNULL:!&lt;span&gt;MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location &lt;/span&gt;/&lt;span&gt; {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;resolver address … [valid=time] [ipv6=on|off]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;配置域名解析服务器，否则Nginx将无法正确解析域名的地址，无法访问后端的Web服务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;keepalive_timeout timeout;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设置keepalive的超时时间，默认75s，主要用于客户端复用Http长连接，提高服务器的性能，如果希望服务器发送数据后能主动断开连接，可以设置为0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;access_log path[format [buffer=size][flush=time][if=condition]];&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;access_log指令用于配置http的访问日志，日志的格式由log_format决定，为了优化磁盘读写，可以设置buffer和flush选项，指定写磁盘的缓冲区大小和刷新时间。 access_log /var/logs/nginx/access.log buffer=8k flush=1s;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;六、Proxy配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;proxy_connect_timeout time;&lt;/strong&gt;&lt;br/&gt;与Nginx服务器建立连接的超时时间，一般不超过75s，示例：proxy_connect_timeout 60s;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;proxy_cookie_domain off;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;proxy_cookie_domain domain replacement;&lt;/strong&gt;&lt;br/&gt;HttpHeader中，重写Set-Cookie中domain的配置，例如: proxy_cookie_domain localhost example.org;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;proxy_read_timeout time;&lt;/strong&gt;&lt;br/&gt;该指令设置与代理服务器的读超时时间。它决定了nginx会等待多长时间来获得请求的响应。这个时间不是获得整个response的时间，而是两次reading操作的时间。&lt;br/&gt;这个超时时间很重要，取决与调用方的超时配置，&lt;strong&gt;Nginx要小于等于调用方的超时配置&lt;/strong&gt;&lt;br/&gt;有个有价值的参考连接：&lt;a href=&quot;http://yunjianfei.iteye.com/blog/2265918&quot; target=&quot;_blank&quot;&gt;http://yunjianfei.iteye.com/blog/2265918&lt;/a&gt;&lt;br/&gt;当Nginx遇到报表查询、导出功能？&lt;br/&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-182114-id-4700107.html&quot; target=&quot;_blank&quot;&gt;http://blog.chinaunix.net/uid-182114-id-4700107.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;proxy_send_timeout time&lt;/strong&gt;&lt;br/&gt;该指令设置了发送请求给upstream服务器的超时时间。超时设置不是为了整个发送期间，而是在两次write操作期间。如果超时后，upstream没有收到新的数据，nginx会关闭连接。默认60s。&lt;/p&gt;

&lt;p&gt;周国庆&lt;/p&gt;
&lt;p&gt;2017/10/25&lt;/p&gt;
</description>
<pubDate>Wed, 25 Oct 2017 14:17:00 +0000</pubDate>
<dc:creator>Eric zhou</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tianqing/p/7732640.html</dc:identifier>
</item>
<item>
<title>Java集合框架体系详细梳理，含面试知识点。 - Kkky</title>
<link>http://www.cnblogs.com/kkkky/p/7732680.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kkkky/p/7732680.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;集合的由来：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　面向对象语言对事物都是以对象的形式来体现，为了方便对多个对象的操作，就需要将对象进行存储，集合就是&lt;strong&gt;存储对象&lt;/strong&gt;最常用的一种方式。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;集合特点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1，用于存储对象的容器。（容器本身就是一个对象，存在于堆内存中，&lt;span&gt;里面存的是对象的地址&lt;/span&gt;）&lt;br/&gt;2，集合的长度是可变的。&lt;br/&gt;3，集合中不可以存储基本数据类型值。 （只能存对象）&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;小问题：&lt;/strong&gt;想用集合存基本数据类型怎么办？　　&lt;/p&gt;
&lt;p&gt;　　　　&lt;em&gt;装箱、拆箱。　　例：al.add(5);　// 相当于al.add(new Integer(5));=&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;集合和数组的区别：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　数组虽然也可以存储对象，但长度是固定的，集合长度是可变的。&lt;/p&gt;
&lt;p&gt;　　数组中可以存储基本数据类型，集合只能存储对象。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;集合框架的构成及分类：（虚线为接口）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1041239/201709/1041239-20170910202212538-895040687.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Collection子接口以及常用实现类：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Collection接口&lt;br/&gt;　　|--List接口：&lt;span&gt;有序&lt;/span&gt;(存入和取出的顺序一致),元素都有&lt;span&gt;索引(角标)&lt;/span&gt;，元素&lt;span&gt;可以重复&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　|--Vector:内部是 &lt;em&gt;&lt;strong&gt;数&lt;/strong&gt;&lt;strong&gt;组 &lt;/strong&gt;&lt;/em&gt;数据结构，是同步的。增删，查询都很慢！100%延长（几乎不用了）  &lt;br/&gt;　　　　|--ArrayList:内部是 &lt;em&gt;&lt;strong&gt;数组 &lt;/strong&gt;&lt;/em&gt;数据结构，是不同步的。&lt;span&gt;替代了Vector，查询的速度快，增删速度慢。&lt;/span&gt;50%延长。&lt;em&gt;（查询时是从容器的第一个元素往后找，由于数组的内存空间是连续的，所以查询快；增删的话所有元素内存地址都要改变，所以增删慢。）&lt;/em&gt;&lt;br/&gt;　　　　|--LinkedList:内部是 &lt;em&gt;&lt;strong&gt;链表 &lt;/strong&gt;&lt;/em&gt;数据结构，是不同步的。&lt;span&gt;增删元素的速度很快。&lt;/span&gt;&lt;em&gt;（同理，链表的内存空间是不连续的，所以查询慢；增删时只需改变单个指针的指向，所以快；）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　|--Set接口：&lt;span&gt;无序&lt;/span&gt;，元素&lt;span&gt;不能重复&lt;/span&gt;。Set接口中的方法和Collection一致。&lt;/p&gt;
&lt;p&gt;　　　　|--HashSet: 内部数据结构是&lt;em&gt;&lt;strong&gt;哈希表&lt;/strong&gt;&lt;/em&gt; ，是不同步的。&lt;br/&gt;　　　　　　|--LinkedHashSet：内部数据结构是哈希表和链表，是有顺序的HashSet。&lt;/p&gt;
&lt;p&gt;　　　　|--TreeSet：内部数据结构是有序的&lt;em&gt;&lt;strong&gt;二叉树，&lt;/strong&gt;&lt;/em&gt;它的作用是提供有序的Set集合，是不同步的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;List接口：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　有一个最大的共性特点就是都可以操作角标，所以LinkedList也是有索引的。list集合可以完成对元素的增删改查。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Set和List的区别：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1. Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素 &lt;span&gt;&lt;strong&gt;&amp;lt;最本质区别&amp;gt;&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　2. Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 。&lt;/p&gt;
&lt;p&gt;　　3. List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变  。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;ArryList和Vector可变长度数组的原理：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当默认长度的数组不够存储时，会建立一个新数组。将原来数组的内容拷贝到新的数组当中，并将新增加的元素追加到拷贝完的数组尾，如果仍然不够重复上述动作。其中,ArryList的增加是以原来50%长度进行增加，而Vector是按照100%延长。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;ArryList是线程不安全的，Vector是安全的：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由于是否有锁的判断将影响效率，故Arrylist效率远远高于Vector。&lt;span&gt;而且只要是常用的容器就不是同步的，因为同步效率比较低。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;ArryList存取对象的一个小例子：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
        Person p1 = new Person(&quot;lisi1&quot;,21);
         
        ArrayList al = new ArrayList();
        al.add(p1);
        al.add(new Person(&quot;lisi2&quot;,22));
        al.add(new Person(&quot;lisi3&quot;,23));
        al.add(new Person(&quot;lisi4&quot;,24));
         
        Iterator it = al.iterator();
        while(it.hasNext()){
//          System.out.println(((Person) it.next()).getName()+&quot;::&quot;+((Person) it.next()).getAge());
　　　　　　　　　　　　//错误方式：不能这样取，next()一次指针会移动一次，会输出“lisi1::22 lisi3::24”
            // 正确方式：拿到一个Person对象，然后取属性。
            Person p = (Person) it.next();
            System.out.println(p.getName()+&quot;--&quot;+p.getAge());
        }　　
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;如何保证HashSet的元素唯一性呢？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　是通过对象的hashCode和equals方法来完成对象唯一性的：&lt;br/&gt;　　　　-&amp;gt;如果对象的hashCode值不同，那么不用判断equals方法，就直接存储到哈希表中。 &lt;br/&gt;　　　　-&amp;gt;如果对象的hashCode值相同，那么要再次判断对象的equals方法是否为true:&lt;br/&gt;　　　　　　如果为true，视为相同元素，不存；如果为false，那么视为不同元素，就进行存储。&lt;/p&gt;&lt;p&gt;　　&lt;strong&gt;记住：如果对象要存储到HashSet集合中，该对象必须覆盖hashCode方法和equals方法。&lt;/strong&gt;&lt;br/&gt;　　一般情况下，如果定义的类会产生很多对象，比如人，学生，书，通常都需要覆盖equals，hashCode方法，以建立对象判断是否相同的依据。&lt;/p&gt;

&lt;p&gt;例：往HashSet集合中存储Person对象。如果姓名和年龄相同，视为同一个人，视为相同元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
import java.util.HashSet;
import java.util.Iterator;

class Person {

        private String name;
        private int age;

        public Person(String name, int age) {
                this.name = name;
                this.age = age;
        }

        @Override
        public int hashCode() {
                // System.out.println(this+&quot;.......hashCode&quot;);
                return name.hashCode() + age * 27; // 乘以一个任意数，防止加了年龄以后HashCode仍相同
        }

        @Override
        public boolean equals(Object obj) {
                // 健壮性判断
                if (this == obj)
                        return true;
                if (!(obj instanceof Person))
                        throw new ClassCastException(&quot;类型错误&quot;);
                // System.out.println(this+&quot;....equals.....&quot;+obj);

                Person p = (Person) obj;
                return this.name.equals(p.name) &amp;amp;&amp;amp; this.age == p.age;
        }

        public String getName() {
                return name;
        }

        public void setName(String name) {
                this.name = name;
        }

        public int getAge() {
                return age;
        }

        public void setAge(int age) {
                this.age = age;
        }

        public String toString() {
                return name + &quot;:&quot; + age;
        }
}

public class HashSetTest {

        public static void main(String[] args) {
                HashSet hs = new HashSet();
                /*
                 * HashSet集合数据结构是哈希表，所以存储元素的时候，
                 * 使用的元素的hashCode方法来确定位置，如果位置相同，在通过元素的equals来确定是否相同。
                 *
                 */
                hs.add(new Person(&quot;lisi4&quot;, 24));
                hs.add(new Person(&quot;lisi7&quot;, 27));
                hs.add(new Person(&quot;lisi1&quot;, 21));
                hs.add(new Person(&quot;lisi9&quot;, 29));
                hs.add(new Person(&quot;lisi7&quot;, 27));

                Iterator it = hs.iterator();
                while (it.hasNext()) {
                        Person p = (Person) it.next();
                        System.out.println(p);
                }
        }
}　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
lisi1:21
lisi9:29
lisi4:24
lisi7:27
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;TreeSet默认判断元素唯一性的方式：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　根据Conpare接口的比较方法conpareTo的返回结果是否是0，是0，就是相同元素，不存。 &lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;下面，我们给出两种自定义判断元素唯一性的方式：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式一：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　让元素自身具备比较功能，即根据元素中的属性来比较。采用这种方式需要元素&lt;em&gt;&lt;strong&gt;实现Comparable接口&lt;/strong&gt;&lt;/em&gt;，&lt;em&gt;&lt;strong&gt;覆盖compareTo方法&lt;/strong&gt;&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;　　例：往TreeSet集合中存储Person对象。如果姓名和年龄相同，视为同一个人，视为相同元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
import java.util.Iterator;
import java.util.TreeSet;

class Person implements Comparable {

        public String name;
        public int age;

        public Person() {
                super();

        }

        public Person(String name, int age) {
                super();
                this.name = name;
                this.age = age;
        }

        public String toString() {
                return name + &quot;:&quot; + age;
        }

        @Override
        public int compareTo(Object o) {
                Person p = (Person) o;

                /* 敲黑板划重点，代码简洁方式 */
                int temp = this.age - p.age;
                return temp == 0 ? this.name.compareTo(p.name) : temp;

                // 上面这两句相当于底下这一段的简洁形式
                // if (this.age &amp;gt; p.age)
                // return 1;
                // if (this.age &amp;lt; p.age)
                // return -1;
                // else {
                // return this.name.compareTo(p.name);
                // }
        }

        public static void main(String[] args) {
                TreeSet&amp;lt;Person&amp;gt; ts = new TreeSet&amp;lt;Person&amp;gt;();
                ts.add(new Person(&quot;zhangsan&quot;, 22));
                ts.add(new Person(&quot;lisi&quot;, 27));
                ts.add(new Person(&quot;wangermazi&quot;, 21));
                ts.add(new Person(&quot;zhaosi&quot;, 25));

                Iterator it = ts.iterator();
                while (it.hasNext()) {
                        Person person = (Person) it.next();
                        System.out.println(person.toString());
                }
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
wangermazi:21
zhangsan:22
zhaosi:25
lisi:27
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，复写compareTo方法后，元素根据age这个属性进行了排序。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt; 方式二：&lt;span&gt;（开发用这个，掌握比较器的用法）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　让集合自身具备比较功能。自己写一个&lt;em&gt;&lt;strong&gt;比较器&lt;/strong&gt;&lt;/em&gt;，先定义一个类实现Comparator接口，覆盖compare方法。然后将该类对象作为参数传递给TreeSet集合的构造函数。&lt;/p&gt;
&lt;p&gt;　　不再需要元素实现Conparable接口。&lt;/p&gt;

&lt;p&gt;step1-新建比较器类ComparedByName.java，覆盖compare方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
import java.util.Comparator;

public class ComparedByName implements Comparator {

        @Override
        public int compare(Object o1, Object o2) {
                // TODO Auto-generated method stub
                Person p1 = (Person) o1;
                Person p2 = (Person) o2;
                int temp = p1.name.compareTo(p2.name);
                return temp == 0 ? p1.age - p2.age : temp;
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;step2-将比较器类类对象作为参数传递给TreeSet集合的构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
import java.util.Iterator;
import java.util.TreeSet;

class Person implements Comparable {

        public String name;
        public int age;

        public Person() {
                super();

        }

        public Person(String name, int age) {
                super();
                this.name = name;
                this.age = age;
        }

        public String toString() {
                return name + &quot;:&quot; + age;
        }

        @Override
        public int compareTo(Object o) {
                Person p = (Person) o;

                /* 敲黑板划重点，代码简洁方式 */
                int temp = this.age - p.age;
                return temp == 0 ? this.name.compareTo(p.name) : temp;

                // 上面这两句相当于底下这一段的简洁形式
                // if (this.age &amp;gt; p.age)
                // return 1;
                // if (this.age &amp;lt; p.age)
                // return -1;
                // else {
                // return this.name.compareTo(p.name);
                // }
        }

        public static void main(String[] args) {
                TreeSet&amp;lt;Person&amp;gt; ts = new TreeSet&amp;lt;Person&amp;gt;(new ComparedByName());
                ts.add(new Person(&quot;zhangsan&quot;, 22));
                ts.add(new Person(&quot;lisi&quot;, 27));
                ts.add(new Person(&quot;wangermazi&quot;, 21));
                ts.add(new Person(&quot;zhaosi&quot;, 25));

                Iterator it = ts.iterator();
                while (it.hasNext()) {
                        Person person = (Person) it.next();
                        System.out.println(person.toString());
                }
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
lisi:27
wangermazi:21
zhangsan:22
zhaosi:25
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这次我们的比较器是根据元素属性name进行排序的，复写的compareTo方法是根据age进行排序的。&lt;/p&gt;
&lt;p&gt;　　可以看到，当两种方法同时存在时，是按照比较器的方法来排序的。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;思考：&lt;/strong&gt;&lt;em&gt;如何通过这种方式实现先进先出和先进后出？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　让比较器直接返回1或-1即可。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　对 Collection 进行迭代的迭代器，即对所有的Collection容器进行元素取出的公共接口。&lt;/p&gt;
&lt;p&gt;　　该迭代器对象依赖于具体容器，因为每一个容器的数据结构都不同，所以该迭代器对象是在具体容器中进行内部实现的。（内部类，可以看具体容器的源码）&lt;/p&gt;
&lt;p&gt;　　对于使用容器者而言，具体的实现方法不重要，只要通过具体容器获取到该实现的迭代器的对象即可，也就是iterator()方法，而不用new。（Iterator&amp;lt;String&amp;gt; ite=list.iterator();）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1041239/201708/1041239-20170806204537709-423270612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;小知识点：使用迭代器过程中while和for的区别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 1 &lt;span&gt;第一种
 2 Iterator&amp;lt;String&amp;gt; ite=&lt;span&gt;list.iterator();
 3      while(ite.hasNext())//判断下一个元素之后有值
 4 &lt;span&gt;     {
 5 &lt;span&gt;         System.out.println(ite.next());
 6 &lt;span&gt;     }
 7 &lt;span&gt;第二种
 8 Iterator&amp;lt;String&amp;gt; ite=&lt;span&gt;list.iterator();
 9 for(Iterator it =&lt;span&gt; coll.iterator(); it.hasNext(); ){
10 &lt;span&gt;            System.out.println(it.next());
11         }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第一种方法while循环结束后迭代器对象还在内存中存在，还能继续使用迭代器对象。&lt;/p&gt;
&lt;p&gt;　　第二种方法for循环结束后迭代器对象就消失了，清理了内存，开发中第二种常用。&lt;/p&gt;
&lt;hr/&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;h2&gt; Iterator的一个子接口&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;|--ListIterator接口（列表迭代器）&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;应用场景：&lt;/p&gt;
&lt;p&gt;　　顾名思义，只能用于List的迭代器。&lt;/p&gt;
&lt;p&gt;　　在使用迭代器迭代的过程中需要使用集合中的方法操作元素，出现ConcurrentModificationException异常时，具体看下面的例子。&lt;/p&gt;
&lt;p&gt;出现异常情况代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
Iterator it = list.iterator();
        while(it.hasNext()){
            
            Object obj = it.next();//java.util.ConcurrentModificationException
                            //在使用迭代器的过程中使用集合中的方法add()操作元素，出现异常。
                        //可以使用Iterator接口的子接口ListIterator来完成在迭代中对元素进行更多的操作。 
            　　　　　　　　
            if(obj.equals(&quot;abc2&quot;)){
                list.add(&quot;abc9&quot;);
            }
            else
                System.out.println(&quot;next:&quot;+obj);
        }
        System.out.println(list);　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解决办法代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
public static void main(String[] args) {

        List list = new ArrayList();        
        list.add(&quot;abc1&quot;);
        list.add(&quot;abc2&quot;);
        list.add(&quot;abc3&quot;);
        
        System.out.println(&quot;list:&quot;+list);
        ListIterator it = list.listIterator();//获取列表迭代器对象
        //它可以实现在迭代过程中完成对元素的增删改查。
        //注意：只有list集合具备该迭代功能.
                
        while(it.hasNext()){            
            Object obj = it.next();            
            if(obj.equals(&quot;abc2&quot;)){
                it.add(&quot;abc9&quot;); //ListIterator提供了add方法
            }
        }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Map接口与Set类似，可以对照着来学，比如比较器在TreeMap中也适用。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Map：&lt;/strong&gt;&lt;/span&gt;    一次添加一对元素，Collection 一次添加一个元素。&lt;/p&gt;
&lt;p&gt;　　　　Map也称为双列集合，Collection集合也称为单列集合。&lt;/p&gt;
&lt;p&gt;　　　　其实map集合中存储的就是键值对，map集合中必须保证键的唯一性。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;常用方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1，添加&lt;br/&gt;value put(key,value):返回前一个和key关联的值，如果没有返回null.&lt;/p&gt;
&lt;p&gt;2，删除&lt;br/&gt;void clear():清空map集合。&lt;br/&gt;value remove(key):根据指定的key翻出这个键值对。&lt;/p&gt;
&lt;p&gt;3，判断&lt;br/&gt;boolean containsKey(key):是否包含该key&lt;br/&gt;boolean containsValue(value):是否包含该value&lt;br/&gt;boolean isEmpty();是否为空&lt;/p&gt;
&lt;p&gt;4，获取&lt;/p&gt;
&lt;p&gt;value get(key):通过键获取值，如果没有该键返回null。当然，可以通过是否返回null，来判断是否包含指定键。&lt;/p&gt;
&lt;p&gt;int size(): 获取键值对的个数。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Map常用的子类：&lt;span&gt;（*HashMap与Hashtable的区别，面试常问*,&lt;a href=&quot;http://www.cnblogs.com/lchzls/p/6714335.html&quot; target=&quot;_blank&quot;&gt;详见这个博客。&lt;/a&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　|--Hashtable :内部结构是哈希表，是同步的。不允许null作为键，null作为值。&lt;br/&gt;　　　　|--Properties：用来存储键值对型的配置文件的信息，可以和IO技术相结合。 &lt;br/&gt;　　|--HashMap : 内部结构是哈希表，不是同步的。允许null作为键，null作为值。&lt;br/&gt;　　|--TreeMap : 内部结构是二叉树，不是同步的。可以对Map集合中的键进行排序。&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt; &lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Map的迭代方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;Map本身没有迭代器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　方法一：利用Map接口的values()方法,返回此映射中包含的值的 &lt;span&gt;&lt;a title=&quot;java.util 中的接口&quot;&gt;&lt;span&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/span&gt;&lt;/a&gt; &lt;/span&gt;（值不唯一），&lt;/p&gt;
&lt;p&gt;　　　　　　然后通过Collecion的迭代器进行迭代。（只需要Value，不需要Key的时候）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
public class MapDemo {

        public static void main(String[] args) {
                
                Map&amp;lt;Integer,String&amp;gt; map = new HashMap&amp;lt;Integer,String&amp;gt;();
                method_2(map);
        }
        
        public static void method_2(Map&amp;lt;Integer,String&amp;gt; map){
                
                map.put(8,&quot;zhaoliu&quot;);
                map.put(2,&quot;zhaoliu&quot;);
                map.put(7,&quot;xiaoqiang&quot;);
                map.put(6,&quot;wangcai&quot;);
                                
                Collection&amp;lt;String&amp;gt; values = map.values();
                
                Iterator&amp;lt;String&amp;gt; it2 = values.iterator();
                while(it2.hasNext()){
                        System.out.println(it2.next());
                }
        }
}　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　方法二：通过keySet方法获取map中所有的键所在的&lt;span&gt;Set集合&lt;/span&gt;（Key和Set的都具有唯一性），&lt;/p&gt;
&lt;p&gt;　　　　　　再通过Set的迭代器获取到每一个键，再对每一个键通过Map集合的get方法获取其对应的值即可。&lt;span&gt;&lt;strong&gt;（好用）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
            Set&amp;lt;Integer&amp;gt; keySet = map.keySet();
                Iterator&amp;lt;Integer&amp;gt; it = keySet.iterator();
                
                while(it.hasNext()){
                        Integer key = it.next();
                        String value = map.get(key);
                        System.out.println(key+&quot;:&quot;+value);              
                }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　方法三：利用Map的&lt;span&gt;内部接口Map.Entry&amp;lt;K,V&amp;gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　　　通过Map的entrySet()方法，将键和值的映射关系作为对象存储到Set集合中&lt;/p&gt;
&lt;p&gt;　　　　　　这个映射关系的类型就是Map.Entry类型(结婚证)。&lt;/p&gt;
&lt;p&gt;　　　　　　再通过Map.Entry对象的getKey和getValue获取其中的键和值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
            Set&amp;lt;Map.Entry&amp;lt;Integer, String&amp;gt;&amp;gt; entrySet = map.entrySet();
                
                Iterator&amp;lt;Map.Entry&amp;lt;Integer, String&amp;gt;&amp;gt; it = entrySet.iterator();
                
                while(it.hasNext()){
                        Map.Entry&amp;lt;Integer, String&amp;gt; me = it.next();
                        Integer key = me.getKey();
                        String value = me.getValue();
                        System.out.println(key+&quot;:&quot;+value);                      
                }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Collections是集合框架的工具类，里面的方法都是静态的。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt; 例1：根据字符串长度的正序和倒序排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　用到比较器的地方都可以用Collections.reverseOrder()。&lt;/p&gt;
&lt;table summary=&quot;&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;&lt;tbody readability=&quot;5.0625&quot;&gt;&lt;tr class=&quot;TableRowColor&quot; bgcolor=&quot;white&quot; readability=&quot;1.7731958762887&quot;&gt;&lt;td align=&quot;right&quot; valign=&quot;top&quot; width=&quot;1%&quot;&gt;&lt;code&gt;static void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;strong&gt;&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Collections.html#reverse(java.util.List)&quot;&gt;reverse&lt;/a&gt;&lt;/strong&gt;(&lt;a title=&quot;java.util 中的接口&quot; href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/List.html&quot;&gt;List&lt;/a&gt;&amp;lt;?&amp;gt; list)&lt;/code&gt; &lt;br/&gt;          反转指定列表中元素的顺序。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;TableRowColor&quot; bgcolor=&quot;white&quot; readability=&quot;4.3529411764706&quot;&gt;&lt;td align=&quot;right&quot; valign=&quot;top&quot; width=&quot;1%&quot;&gt;&lt;code&gt;static&lt;/code&gt;
&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;strong&gt;&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Collections.html#reverseOrder()&quot;&gt;reverseOrder&lt;/a&gt;&lt;/strong&gt;()&lt;/code&gt; &lt;br/&gt;          返回一个比较器，它强行逆转实现了 &lt;tt&gt;Comparable&lt;/tt&gt; 接口的对象 collection 的&lt;em&gt;自然顺序&lt;/em&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;TableRowColor&quot; bgcolor=&quot;white&quot; readability=&quot;3.9115646258503&quot;&gt;&lt;td align=&quot;right&quot; valign=&quot;top&quot; width=&quot;1%&quot;&gt;&lt;code&gt;static&lt;/code&gt;
&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;strong&gt;&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Collections.html#reverseOrder(java.util.Comparator)&quot;&gt;reverseOrder&lt;/a&gt;&lt;/strong&gt;(&lt;a title=&quot;java.util 中的接口&quot; href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Comparator.html&quot;&gt;Comparator&lt;/a&gt;&amp;lt;T&amp;gt; cmp)&lt;/code&gt; &lt;br/&gt;          返回一个比较器，它强行逆转指定比较器的顺序。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;比较器ComparatorByLength.java：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
import java.util.Comparator;

public class ComparatorByLength implements Comparator&amp;lt;String&amp;gt; {

        @Override
        public int compare(String o1, String o2) {

                int temp = o1.length() - o2.length();
                
                return temp==0?o1.compareTo(o2): temp;
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Demo：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
public static void demo_3() {

                // reverse实现原理
                /*
                 * TreeSet&amp;lt;String&amp;gt; ts = new TreeSet&amp;lt;String&amp;gt;(new Comparator&amp;lt;String&amp;gt;() {

                        @Override
                        public int compare(String o1, String o2) {

                                int temp = o2.compareTo(o1);
                                return temp;
                        }
                });
                */

                TreeSet&amp;lt;String&amp;gt; treeset = new TreeSet&amp;lt;String&amp;gt;(new ComparatorByLength());
                treeset.add(&quot;abc&quot;);
                treeset.add(&quot;hahaha&quot;);
                treeset.add(&quot;zzz&quot;);
                treeset.add(&quot;aa&quot;);
                treeset.add(&quot;cba&quot;);
                System.out.println(treeset);

                TreeSet&amp;lt;String&amp;gt; ts = new TreeSet&amp;lt;String&amp;gt;(Collections.reverseOrder(new ComparatorByLength()));//都是静态方法，直接类名调用

                ts.add(&quot;abc&quot;);
                ts.add(&quot;hahaha&quot;);
                ts.add(&quot;zzz&quot;);
                ts.add(&quot;aa&quot;);
                ts.add(&quot;cba&quot;);

                System.out.println(&quot;after reverse:\t&quot; + ts);

        }
public static void main(String[] args) {
　　　    　demo_3();
　　}&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_66e47136-1442-4be0-a3ff-bb2387f2437f&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_66e47136-1442-4be0-a3ff-bb2387f2437f&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_66e47136-1442-4be0-a3ff-bb2387f2437f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[aa, abc, cba, zzz, hahaha]
after reverse:    [hahaha, zzz, cba, abc, aa]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;运行结果&lt;/span&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;例2：用工具类Collections.sort()进行排序：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
public static void demo_2() {
                List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();

                list.add(&quot;abcde&quot;);
                list.add(&quot;cba&quot;);
                list.add(&quot;aa&quot;);
                list.add(&quot;zzz&quot;);
                list.add(&quot;cba&quot;);
                list.add(&quot;nbaa&quot;);
                System.out.println(list);

                Collections.sort(list);
                System.out.println(&quot;after sort:\n&quot; + list);

                Collections.sort(list, Collections.reverseOrder());
                System.out.println(&quot;after reverse sort:\n&quot; + list);

                int index = Collections.binarySearch(list, &quot;cba&quot;);
                System.out.println(&quot;index=&quot; + index);

                // 获取最大值。
                String max = Collections.max(list, new ComparatorByLength());
                System.out.println(&quot;maxLength=&quot; + max);
        }
        public static void main(String[] args) {

                demo_2();
        }　　
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_b0cfc210-1a08-4e97-bca0-9535e87d18a0&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b0cfc210-1a08-4e97-bca0-9535e87d18a0&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b0cfc210-1a08-4e97-bca0-9535e87d18a0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[abcde, cba, aa, zzz, cba, nbaa]
after sort:
[aa, abcde, cba, cba, nbaa, zzz]
after reverse sort:
[zzz, nbaa, cba, cba, abcde, aa]
index&lt;/span&gt;=2&lt;span&gt;
maxLength&lt;/span&gt;=abcde
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;运行结果&lt;/span&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;例3：给非同步的集合加锁，方法太多就不一一列举了，自己查看API。&lt;span&gt;（掌握，面试会问到）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table summary=&quot;&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;&lt;tbody readability=&quot;6.0764499121265&quot;&gt;&lt;tr class=&quot;TableRowColor&quot; bgcolor=&quot;white&quot; readability=&quot;3.7037037037037&quot;&gt;&lt;td align=&quot;right&quot; valign=&quot;top&quot; width=&quot;1%&quot;&gt;&lt;code&gt;static&lt;/code&gt;
&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;strong&gt;&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Collections.html#synchronizedCollection(java.util.Collection)&quot;&gt;synchronizedCollection&lt;/a&gt;&lt;/strong&gt;(&lt;a title=&quot;java.util 中的接口&quot; href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Collection.html&quot;&gt;Collection&lt;/a&gt;&amp;lt;T&amp;gt; c)&lt;/code&gt; &lt;br/&gt;          返回指定 collection 支持的同步（线程安全的）collection。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;TableRowColor&quot; bgcolor=&quot;white&quot; readability=&quot;2.4744525547445&quot;&gt;&lt;td align=&quot;right&quot; valign=&quot;top&quot; width=&quot;1%&quot;&gt;&lt;code&gt;static&lt;/code&gt;
&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;strong&gt;&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Collections.html#synchronizedList(java.util.List)&quot;&gt;synchronizedList&lt;/a&gt;&lt;/strong&gt;(&lt;a title=&quot;java.util 中的接口&quot; href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/List.html&quot;&gt;List&lt;/a&gt;&amp;lt;T&amp;gt; list)&lt;/code&gt; &lt;br/&gt;          返回指定列表支持的同步（线程安全的）列表。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;TableRowColor&quot; bgcolor=&quot;white&quot; readability=&quot;3.4&quot;&gt;&lt;td align=&quot;right&quot; valign=&quot;top&quot; width=&quot;1%&quot;&gt;&lt;code&gt;static&lt;/code&gt;
&lt;table summary=&quot;&quot; border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr align=&quot;right&quot; valign=&quot;&quot;&gt;&lt;td nowrap=&quot;nowrap&quot;&gt;&lt;code&gt;&amp;lt;K,V&amp;gt; &lt;a title=&quot;java.util 中的接口&quot; href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Map.html&quot;&gt;Map&lt;/a&gt;&amp;lt;K,V&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;strong&gt;&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Collections.html#synchronizedMap(java.util.Map)&quot;&gt;synchronizedMap&lt;/a&gt;&lt;/strong&gt;(&lt;a title=&quot;java.util 中的接口&quot; href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Map.html&quot;&gt;Map&lt;/a&gt;&amp;lt;K,V&amp;gt; m)&lt;/code&gt; &lt;br/&gt;          返回由指定映射支持的同步（线程安全的）映射。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;TableRowColor&quot; bgcolor=&quot;white&quot; readability=&quot;2.503937007874&quot;&gt;&lt;td align=&quot;right&quot; valign=&quot;top&quot; width=&quot;1%&quot;&gt;&lt;code&gt;static&lt;/code&gt;
&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;strong&gt;&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Collections.html#synchronizedSet(java.util.Set)&quot;&gt;synchronizedSet&lt;/a&gt;&lt;/strong&gt;(&lt;a title=&quot;java.util 中的接口&quot; href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Set.html&quot;&gt;Set&lt;/a&gt;&amp;lt;T&amp;gt; s)&lt;/code&gt; &lt;br/&gt;          返回指定 set 支持的同步（线程安全的）set。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt; 简单说一下给集合加锁的思想。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
List list = new ArrayList();// 非同步的list。

        list=MyCollections.synList(list);// 返回一个同步的list.

class MyCollections{
                 /**
                 * 返回一个加锁的List
                 * */
                public static  List synList(List list){         
                        return new MyList(list);
                }
                // 内部类
                private class MyList implements List{
                
                private List list;
                
                private static final Object lock = new Object();
                
                MyList(List list){      
                        this.list = list;       
                }
                
                public boolean add(Object obj){
                        synchronized(lock)
                        {
                                return list.add(obj);
                        }
                }
                
                public boolean remove(Object obj){
                        synchronized(lock)
                        {
                                return list.remove(obj);
                        }
                }
        
        }
}              
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;例4：将集合转成数组，Arrays.asList()方法 &lt;span&gt;（掌握）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用场景：数组方法有限，需要使用集合中的方法操作数组元素时。&lt;/p&gt;
&lt;p&gt;注意1：&lt;/p&gt;
&lt;p&gt;　　数组的长度是固定的，所以对于集合的增删方法（add()和remove()）是不能使用的。&lt;/p&gt;
&lt;p&gt;Demo：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
    public static void demo_1() {

                String[] arr = { &quot;abc&quot;, &quot;haha&quot;, &quot;xixi&quot; };

                List&amp;lt;String&amp;gt; list = Arrays.asList(arr);
                boolean b1 = list.contains(&quot;xixi&quot;);
                System.out.println(&quot;list contains:&quot; + b1);
                // list.add(&quot;hiahia&quot;);//引发UnsupportedOperationException

                System.out.println(list);
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_0fb9dc43-4f13-47db-b9c3-be4ae2f410f5&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;运行结果&lt;img id=&quot;code_img_opened_0fb9dc43-4f13-47db-b9c3-be4ae2f410f5&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0fb9dc43-4f13-47db-b9c3-be4ae2f410f5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
list contains:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
[abc, haha, xixi]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;注意2：&lt;/p&gt;
&lt;p&gt;　　如果数组中的元素是对象（包装器类型），那么转成集合时，直接将数组中的元素作为集合中的元素进行集合存储。（比如上面那个Demo）&lt;/p&gt;
&lt;p&gt;　　如果数组中的元素是基本数据类型，那么会将该*数组*作为集合中的元素进行存储。（比如下面这个Demo）&lt;/p&gt;
&lt;p&gt;Demo：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
    public static void demo_2() {
                /*
                 * 如果数组中的元素是对象，那么转成集合时，直接将数组中的元素作为集合中的元素进行集合存储。
                 * 
                 * 如果数组中的元素是基本类型数值，那么会将该数组作为集合中的元素进行存储。
                 * 
                 */
                int[] arr = { 31, 11, 51, 61 };

                List&amp;lt;int[]&amp;gt; list = Arrays.asList(arr);

                System.out.println(list);
                System.out.println(&quot;数组的长度为：&quot; + list.size());
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_61ade2ac-2489-46d6-921e-15657f0a3f6e&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;运行结果&lt;img id=&quot;code_img_opened_61ade2ac-2489-46d6-921e-15657f0a3f6e&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_61ade2ac-2489-46d6-921e-15657f0a3f6e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[[I@659e0bfd]
数组的长度为：&lt;/span&gt;1
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;由结果可以看出，当数组中的元素时int类型时，集合中存的元素是整个数组，集合的长度为1而不是4。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt; 例5：将数组转成集合，List.toArray()方法&lt;/strong&gt;&lt;/p&gt;
&lt;table class=&quot;overviewSummary&quot; summary=&quot;Method Summary table, listing methods, and an explanation&quot; border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;&lt;tbody readability=&quot;2.8203592814371&quot;&gt;&lt;tr class=&quot;rowColor&quot; readability=&quot;4.04296875&quot;&gt;&lt;td class=&quot;colFirst&quot;&gt;&lt;code&gt;&lt;a title=&quot;class in java.lang&quot; href=&quot;http://tool.oschina.net/uploads/apidocs/jdk_7u4/java/lang/Object.html&quot;&gt;Object&lt;/a&gt;[]&lt;/code&gt;&lt;/td&gt;
&lt;td class=&quot;colLast&quot; readability=&quot;5.6470588235294&quot;&gt;&lt;code&gt;&lt;strong&gt;&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/jdk_7u4/java/util/List.html#toArray()&quot;&gt;toArray&lt;/a&gt;&lt;/strong&gt;()&lt;/code&gt;
&lt;p&gt;Returns an array containing all of the elements in this list in proper sequence (from first to last element).&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;altColor&quot; readability=&quot;4.3463414634146&quot;&gt;&lt;td class=&quot;colFirst&quot;&gt;&lt;code&gt;&amp;lt;T&amp;gt; T[]&lt;/code&gt;&lt;/td&gt;
&lt;td class=&quot;colLast&quot; readability=&quot;5.7857142857143&quot;&gt;&lt;code&gt;&lt;strong&gt;&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/jdk_7u4/java/util/List.html#toArray(T[])&quot;&gt;toArray&lt;/a&gt;&lt;/strong&gt;(T[] a)&lt;/code&gt;
&lt;p&gt;Returns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt; 应用场景：对集合中的元素操作的方法进行限定，不允许对其进行增删时。&lt;/p&gt;

&lt;p&gt; 注意：toArray方法需要传入一个指定类型的数组，数组的长度如何定义呢？&lt;/p&gt;
&lt;p&gt;　　如果定义的数组长度小于集合的size，那么该方法会创建一个同类型并和集合相同size的数组。&lt;/p&gt;
&lt;p&gt;　　如果定义的数组长度大于集合的size，那么该方法就会使用指定的数组，存储集合中的元素，其他位置默认为null。&lt;/p&gt;
&lt;p&gt;　　所以，一般将数组的长度定义为集合的size。&lt;/p&gt;
&lt;p&gt;Demo：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
public class ToArray {
        public static void main(String[] args) {

                List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
                list.add(&quot;abc1&quot;);
                list.add(&quot;abc2&quot;);
                list.add(&quot;abc3&quot;);
                
                String[] arr = list.toArray(new String[list.size()]);           
                System.out.println(Arrays.toString(arr));                               
        }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;例6：foreach语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用场景：遍历数组或Collection单列集合。&lt;/p&gt;
&lt;p&gt;　　　　　对数组的遍历如果仅仅是获取数组中的元素用foreach可以简化代码，如果要对数组的角标进行操作建议使用传统for循环。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　&lt;em id=&quot;__mceDel&quot;&gt;格式：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;for(类型 变量 ：Collection集合&lt;/em&gt;&lt;em&gt;|数组)&lt;br/&gt; {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;}&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Demo：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
public class ForEachDemo {

        public static void main(String[] args) {
                
                // 遍历数组
                int[] arr = { 3, 1, 5, 7, 4 };
                
                for (int i : arr) {
                        System.out.println(i);
                }
                
                //遍历List
                List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
                list.add(&quot;abc1&quot;);
                list.add(&quot;abc2&quot;);
                list.add(&quot;abc3&quot;);

                for (String s : list) {
                        System.out.println(s);
                }

                // 遍历map 
                // 可以使用高级for遍历map集合吗？不能直接用，但是将map转成单列的set，就可以用了。
                Map&amp;lt;Integer, String&amp;gt; map = new HashMap&amp;lt;Integer, String&amp;gt;();
                map.put(3, &quot;zhagsan&quot;);
                map.put(1, &quot;wangyi&quot;);
                map.put(7, &quot;wagnwu&quot;);
                map.put(4, &quot;zhagsansan&quot;);

                for (Integer key : map.keySet()) {
                        String value = map.get(key);
                        System.out.println(key + &quot;::&quot; + value);
                }

                for (Map.Entry&amp;lt;Integer, String&amp;gt; me : map.entrySet()) {
                        Integer key = me.getKey();
                        String value = me.getValue();

                        System.out.println(key + &quot;:&quot; + value);
                }

                // 老式的迭代器写法
                Iterator&amp;lt;String&amp;gt; it = list.iterator();
                while (it.hasNext()) {
                        System.out.println(it.next());
                }
        }
}
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 25 Oct 2017 14:02:00 +0000</pubDate>
<dc:creator>Kkky</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kkkky/p/7732680.html</dc:identifier>
</item>
<item>
<title>javascript入门知识点总结(一) - 天宇之游</title>
<link>http://www.cnblogs.com/cwp-bg/p/7732486.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cwp-bg/p/7732486.html</guid>
<description>&lt;p&gt;&lt;strong&gt;学了几天javascript，现总结一下原生javascript的基本知识点。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;一javascript基本知识&quot;&gt;一、javascript基本知识&lt;/h2&gt;
&lt;h3 id=&quot;变量&quot;&gt;变量&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;var a = 123;
var b = 'abc';
//连写
var a = 123,b=456;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：js为弱类型的解释型脚本语言，使用var关键字定义一个变量，数据类型自动判断。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：每句代码后可以不写分号，换行即可，习惯上最好加上，增强可读性。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;变量类型：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;number：数字类型&lt;/li&gt;
&lt;li&gt;string：字符串类型&lt;/li&gt;
&lt;li&gt;boolean：布尔类型&lt;/li&gt;
&lt;li&gt;undefined：未定义类型&lt;/li&gt;
&lt;li&gt;null：空类型&lt;/li&gt;
&lt;li&gt;object：复合类型，一般用来接收标签。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;命名规则：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;区分大小写；&lt;/li&gt;
&lt;li&gt;第一个字符必须是字母、下划线（_）或者美元符号（$），不能输数字；&lt;/li&gt;
&lt;li&gt;其他字符可以是字母、下划线、美元符或数字；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不能使用js的关键字或保留字。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多个单词变量的命名使用小驼峰或单词加下划线。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对于object对象一般使用匈牙利命名风格。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//小驼峰命名法
var getMyClass = &quot;abc&quot;;
//字母加下划线
var get_my_name = &quot;abc&quot;;
//匈牙利命名风格
object: oDiv = document.getElementById('div1');
string: sMyName = &quot;abc&quot;  //根据数据类型的第一个字母为开头的小驼峰命名法。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取属性&quot;&gt;获取属性&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script&amp;gt;
window.onload = function(){
    //获取标签，通过id
    var oDiv = document.getElementById('div');
    //获取标签，通过class属性
    var oDiv = document.getElementByClassName('div');
    // 获取标签,写法和css一样
    var oDiv = document.querySlector(&quot;#id&quot;);//如果有多个，获取到第一个
    var oDiv = document.querySlectorAll()//获取所有，得到选择集
    // 读取属性值
    var name =oDiv.className;
    var oId = oDiv.id;
    // 写(设置)属性
    oDiv.style.color = 'red';
    oDiv.style.fontSize = &quot;20px&quot;;
    // 写属性值第二种
    var cor = oDiv.style.color;
    var oDiv.style[cor] = &quot;red&quot;;//自己命名的属性需要通过[]方式
    var oDiv.style.cor = &quot;&quot;; //这种是无效的
    }
    &amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意1：代码需要写在window.onload =function(){}；中，使得html和css加载完毕后才执行，防止报错。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意2：如果style中的属性不是行内式，而是由css设置的，那么js第一次是获取不到的，但可以直接设置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意3：js代码需要用script标签包裹，可以放置在html代码的任何位置，但css嵌入式只能放在头部。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;书写方法&quot;&gt;书写方法：&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;一般行内的属性写法一样；&lt;/li&gt;
&lt;li&gt;“class” 属性写成 “className”；&lt;/li&gt;
&lt;li&gt;“style” 属性里面的属性，有横杠的改成驼峰式，如：“font-size”，改成”style.fontSize”；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;获取标签包裹的内容&quot;&gt;获取标签包裹的内容&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    //读取
    var txt = oDiv.innerHTML;
    //写入
    oDiv.innerHTML = '&amp;lt;a href=&quot;&quot;&amp;gt;哈哈哈哈哈&amp;lt;a/&amp;gt;';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明：写入的标签会被解析，从而可以动态添加标签；标签的属性可以在css中写，有效。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;运算符&quot;&gt;运算符&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;算术运算符： +(加)、 -(减)、 *(乘)、 /(除)、 %(求余);;&lt;/li&gt;
&lt;li&gt;赋值运算符：=、 +=、 -=、 *=、 /=、 %=;&lt;/li&gt;
&lt;li&gt;条件运算符：= =、===、&amp;gt;、&amp;gt;=、&amp;lt;、&amp;lt;=、!=、&amp;amp;&amp;amp;(而且)、||(或者)、!(否);&lt;/li&gt;
&lt;li&gt;自加、自减：i++, i--;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;==和===的区别：==不会判断数据的类型，直接比较值；=== 会先判断数据的类型，不是同一种类型则不相等。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if(3==&quot;3&quot;){
    alert(&quot;true&quot;)//判断为真
}
if(3===&quot;3&quot;){
    alert(&quot;true&quot;)//判断为假
}
    &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;条件语句&quot;&gt;条件语句&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;if; if else; if else if else; 和java的写法一样；&lt;/li&gt;
&lt;li&gt;switch：选择语句,和java写法一样。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;var a = 2;
switch (a){
    case 1:
        alert('1');
        break;
    case 2:
        alert('2');
        break;
    default:
        alert(&quot;else&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数组和操作数组&quot;&gt;数组和操作数组&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;定义方法：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//实例创建，和java相似
var aList = new Array(1,2,3);

//直接创建，内部数据可以是不同的类型；
var aList2 = [1,2,3,'asd'，true，null];

// 多维数组
var aList = [[1,2,3],['a','b','c']];&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;操作方法：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;var aList = [1,2,3,4];
var n1 = aList.length;  //获取数组的长度，n1=4；
var n2 = aList[0]； // 下标获取数据，n2 = 1;
var n3 = (aList.join('-')) // 数组成员通过分隔符拼接成字符串，n3=&quot;1-2-3-4&quot;;
var n4 = aList.push(5); //数组后面追加成员
var n5 = aList.pop();  //数组后删除成员
var n6 = aList.unshift(5); //数组前面增加成员
var n7 = aList.shift();; //数组前面面删除成员
var n8 = aList.reverse();//数组翻转
var n9 = aList.indexOf(1);//返回元素1在数组中第一次出现的索引，没有则返回-1；
var n10 = aList.splice(2,1,7,8,9);//从第2个元素开始，删除1个元素，然后在此位置增加'7,8,9'三个元素&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意点：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aList.join(&quot;&quot;) // 快速拼接成字符串；

aList.push(5,6,9); // 一次性添加多个成员
aList.pop(2);  // 2是没有作用的，里面的任何参数都不会起作用，但不会报错；

aList.unshift(5,8,9);// 在前面一次性增加多个数据 
aList.shift(5); //没有效果，这里没有参数，但不会报错。

aList.splice(2); //一个参数时，删除角标2后面的所有元素，包括角标2的元素；
aList.splice(2,1);  //两个参数代表从角标2后（包括角标）删除1个元素;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字符串处理&quot;&gt;字符串处理&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;相关方法：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;var sName = &quot;abcdfg&quot;;
var iNmr = &quot;123456&quot;;
var s1 = sName + &quot;dfgh&quot;; //字符串合并操作：“ + ”
var sx = sName[0];//获取字符串角标为0的字符
var s2 = parseInt(iNmr) //将数字字符串转化为整数,得到新的数据
var s3 = parseFloat(iNmr) //将数字字符串转化为小数
var s4 = sName.split() //把一个字符串分隔成字符串组成的数组
var s5 = sName.charAt(3) //获取字符串中角标为3的字符
var s6 = sName.indexOf(&quot;g&quot;) //查找字符串是否含有某字符,如果没有就返回-1，有返回第一次出现的角标
var s7 = sName.substring() //截取字符串 
var s8 = sName.toUpperCase() // 字符串转大写
var s9 = sName.toLowerCase() // 字符串转小写
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;方法扩展：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;var sName = &quot;abcdfg&quot;;

var s4 = sName.split() //参数为空时返回数组[&quot;abcdfg&quot;]
var s4 = sName.split(&quot;&quot;) //参数为空字符返回数组[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;f&quot;,&quot;g&quot;];

var s3 = parseFloat(&quot;5.6&quot;) // s3=5.59999999995,该方法转换数据时存在一定的精度问题
var s3 = parseFloat(&quot;5.6&quot;)*100/100; // s3 = 5.6

var s7 = sName.substring(start,end)// start为开始的字符串下标，end为结束下标，新的字符串包含start不包含end。
var s7 = sName.substring(start,)
var s7 = sName.substring(start)  //以上两种写法可获取从start角标到最后的所有字符；
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;重要应用：字符串翻转&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;var str = 'abcdefg';
//先切割成数组，翻转后拼接成字符串。
var str2 = str.split('').reverse().join('');&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;循环&quot;&gt;循环&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;for循环:和java一样的使用方式&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;for(var i=0;i&amp;lt;length;i++)
{
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;while循环：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;while(i&amp;lt;length){
    ......
    i++;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个扩展应用：&lt;strong&gt;数组去重&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var aList = [1,2,3,4,4,3,2,1,2,3,4,5,6,5,5,3,3,4,2,1];

var aList2 = [];

for(var i=0;i&amp;lt;aList.length;i++)
{
    if (aList2.indexOf(aList[i]) == -1) {
        aList2.push(aList[i]);
    }
}//对数组进行遍历，如果数据在新的数组中不存在就加入。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数据类型转换&quot;&gt;数据类型转换&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;直接转换&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;alert('12'+7); //将7转换成&quot;7&quot;,弹出127
alert(parseInt('1') + 7 );  //转换后，弹出8 
alert(parseInt(5.6));  // 去掉小数部分，不是四舍五入，弹出5
alert('5.6'+2.3);  // 2.3转换成&quot;2.3&quot;，弹出5.62.3
alert(0.1+0.2); //弹出 0.3000000000000004，精度有问题
alert((0.1*100+0.2*100)/100); //弹出0.3，需要计算处理一下
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;隐式转换&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&quot;4&quot; == 4; //判断为真，==将&quot;4&quot;转换成4；

&quot;3&quot;-2;  //结果1；

var s1 = parseInt('123abc') //结果为123
alert( parseInt('abc123') );  // 弹出NaN
//说明:以数字开头的字符串通过函数可以转换其中的数字为整形，如果不是开头 则转换失败

alert(isNaN(123abc)) //弹出true
//isNAN（string）：判断是否是纯数字，是返回false,不是返回true

null==undefined:涉及隐式转换，null和undefind都被当做false处理，判断为真
null===undefined:判断为flase，null为Object类型，undefined类型是其本身

!(null):判断为真
!(undefined):判断为真

typeof（）：查看数据类型&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;程序调试方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;alert(&quot;xxxx&quot;)//输出弹窗，但是阻止程序继续运行
console.log()//在控制台输出内容
document.title == &quot;xxxx&quot;//覆盖网页的标题，很少使用
document.write(&quot;xxxx&quot;)//覆盖body的内容，很少使用
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定时器&quot;&gt;定时器&lt;/h3&gt;
&lt;p&gt;作用：制作动画和异步操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var time1 = setTimeout(function,1000)  //只执行一次的定时器,第一个参数为函数，第二个参数为定时时间，单位ms 
clearTimeout(time1) //关闭只执行一次的定时器
var time2 = setInterval(function,1000) // 反复执行的定时器
clearInterval(time2) //关闭反复执行的定时器
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：反复执行的定时器一旦开启就不会停止，相当于启动了一个线程，会一直消耗cup资源，所有很多时候需要手动关闭。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var timer1 = setInterval(func1,2000);

function funnc1(){
    console.log(&quot;hhhh&quot;);
    
    clearInterval(timer1); //关闭定时器在函数内部
}

//clearInterval(timer1);在外部是无效的&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：关闭定时器的操作需要在定时器函数的内部执行，否则不会成功。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;函数&quot;&gt;函数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;命名函数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;function myalert(){
        alert('ok!');//弹出OK的窗口
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：用function定义，其他的写法和java一样。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;匿名函数：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;// 匿名函数赋值给绑定的事件

oBtn.onclick = function (){
    alert('ok!');
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：匿名函数不能单独存在，必须用一个变量将其引用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;封闭函数：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;定义：一个打开网页就立即执行的函数 。&lt;/p&gt;
&lt;p&gt;作用：当需要在原来的代码基础上增加新的函数时，如果函数名相同，新的函数会覆盖原来的函数，为了避免覆盖，将后一个函数写成封闭函数，一开始就运行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//写法一
(function(){
......
})();

//写法二
!function(){
    .....
}()

//写法三
~function(){
    .....
}()&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;传参和返回值：和java一样。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;function myalert(a,b){
        //return a+b;
        return [a,b]
    }
    myalert(1,2);
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明：返回多个参数时需要使用一个数组，不可以直接写return a，b；否则报错！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：return关键字可以结束函数运行、阻止程序的默认行为。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;闭包&quot;&gt;&lt;strong&gt;闭包&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;定义：函数嵌套函数，内部函数可以引用外部函数的参数和变量，参数和变量不会被垃圾回收机制收回&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;function func1(i){      
    var a = 1;      
    function func2(j){
        i += a;
        j += a;
        console.log(i);
        console.log(j);
    }
    return func2;
  }

 var func2 = func1(2);//将闭包函数提取出来
 func2(3);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;用法：私有变量计数器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;function func1(i){      
    var a = 0;      
    function func2(j){
        a++;
        i++;
        j++;
        console.log(a);
        console.log(i);
        console.log(j);
    }
    return func2;
  }
  
var func2 = func1(0);

for(var i,i&amp;lt;10,i++){
    func2(0);
} 

//a和i都可以作为变量计数器，使得全局变量与闭包函数计数变量分开
&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;box&quot;&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;作者：天宇之游&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/cwp-bg/&quot;&gt;http://www.cnblogs.com/cwp-bg/&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;本文版权归作者和博客园共有，欢迎转载、交流，但未经作者同意必须保留此段声明，且在文章明显位置给出原文链接。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 25 Oct 2017 13:41:00 +0000</pubDate>
<dc:creator>天宇之游</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cwp-bg/p/7732486.html</dc:identifier>
</item>
<item>
<title>Hadoop（十四）MapReduce原理分析 - 苦水润喉</title>
<link>http://www.cnblogs.com/zhangyinhua/p/7729878.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyinhua/p/7729878.html</guid>
<description>&lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;　　上一篇我们分析了一个MapReduce在执行中的一些细节问题，这一篇分享的是MapReduce并行处理的基本过程和原理。&lt;/p&gt;
&lt;p&gt;　　Mapreduce是一个&lt;span&gt;分布式运算程序的编程框架&lt;/span&gt;，是&lt;span&gt;用户开发“基于hadoop的数据分析应用”的核心框架。&lt;/span&gt;&lt;br/&gt;　　Mapreduce核心功能是&lt;span&gt;将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个hadoop集群上&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;　　首先要说明的是Hadoop2.0之前和Hadoop2.0之后的区别：　&lt;/p&gt;
&lt;p&gt;　　  2.0之前只有MapReduce的运行框架，那么它里面有只有两种节点，&lt;span&gt;一个是master，一个是worker。master既做资源调度又做程序调度，worker只是用来参与计算的&lt;/span&gt;。&lt;br/&gt;　　  但是在&lt;span&gt;2.0之后加入了YARN集群，Yarn集群的主节点承担了资源调度，Yarn集群的从节点中会选出一个节点（这个由redourcemanager决定）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　  用作类似于2.0之前的master的工作，来进行应用程序的调度&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　  资源调度： &lt;span&gt;处理程序所需要的cpu、内存资源，以及存储数据所需要的硬盘资源都是resourcemanager去分配的&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171025154045379-132040912.png&quot; alt=&quot;&quot; width=&quot;673&quot; height=&quot;434&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　一切都是从&lt;span&gt;最上方的user program开始的，user program链接了MapReduce库，实现了最基本的Map函数和Reduce函数&lt;/span&gt;。&lt;br/&gt;　　图中执行的顺序都用数字标记了。&lt;br/&gt;　　1）MapReduce库先把user program的输入文件划分为M份（M为用户定义），如图左方所示分成了split0~4；然后使用fork将用户进程拷贝到集群内其它机器上。&lt;/p&gt;
&lt;p&gt;　　2）user program的副本中有一个称为master，其余称为worker，master是负责调度的，为空闲worker分配作业（Map作业或者Reduce作业），worker的数量也是&lt;/p&gt;
&lt;p&gt;　　　　可以由用户指定的。&lt;/p&gt;
&lt;p&gt;　　3）被分配了Map作业的worker，开始读取对应分片的输入数据，Map作业数量是由M决定的，和split一一对应；Map作业从输入数据中抽取出键值对，每一个键值对&lt;/p&gt;
&lt;p&gt;　　　　都作为参数传递给map函数，map函数产生的中间键值对被缓存在内存中。&lt;/p&gt;
&lt;p&gt;　　4）缓存的中间键值对会被定期写入本地磁盘，而且被分为R个区，R的大小是由用户定义的，将来每个区会对应一个Reduce作业；这些中间键值对的位置会被通报&lt;/p&gt;
&lt;p&gt;　　　　给master，master负责将信息转发给Reduce worker。&lt;/p&gt;
&lt;p&gt;　　5）master通知分配了Reduce作业的worker它负责的分区在什么位置（肯定不止一个地方，每个Map作业产生的中间键值对都可能映射到所有R个不同分区），当&lt;/p&gt;
&lt;p&gt;　　　　Reduce worker把所有它负责的中间键值对都读过来后，先对它们进行排序，使得相同键的键值对聚集在一起。因为不同的键可能会映射到同一个分区也就是&lt;/p&gt;
&lt;p&gt;　　　　同一个Reduce作业（谁让分区少呢），所以排序是必须的。&lt;/p&gt;
&lt;p&gt;　　6）reduce worker遍历排序后的中间键值对，对于每个唯一的键，都将键与关联的值传递给reduce函数，reduce函数产生的输出会添加到这个分区的输出文件中。&lt;/p&gt;
&lt;p&gt;　　7）当所有的Map和Reduce作业都完成了，master唤醒正版的user program，MapReduce函数调用返回user program的代码。&lt;/p&gt;
&lt;p&gt;　　8）所有执行完毕后，MapReduce输出放在了R个分区的输出文件中（分别对应一个Reduce作业）。用户通常并不需要合并这R个文件，而是将其作为输入交给另一&lt;/p&gt;
&lt;p&gt;　　　　个MapReduce程序处理。整个过程中，输入数据是来自底层分布式文件系统（GFS）的，中间数据是放在本地文件系统的，最终输出数据是写入底层分布式文件&lt;/p&gt;
&lt;p&gt;　　　　系统（GFFS）的。而且我们要注意Map/Reduce作业和map/reduce函数的区别：Map作业处理一个输入数据的分片，可能需要调用多次map函数来处理每个输入&lt;/p&gt;
&lt;p&gt;　　　　键值对；Reduce作业处理一个分区的中间键值对，期间要对每个不同的键调用一次reduce函数，Reduce作业最终也对应一个输出文件。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171025155203410-1631103331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　Map/Reduce框架&lt;span&gt;运转在&amp;lt;key, value&amp;gt;键值对&lt;/span&gt;上，也就是说，&lt;span&gt;框架把作业的输入看为是一组&amp;lt;key, value&amp;gt;键值对&lt;/span&gt;，同样也&lt;span&gt;产出一组 &amp;lt;key, value&amp;gt;键值对做为作业的输出&lt;/span&gt;，这两组键&lt;/p&gt;
&lt;p&gt;　　　　值对的类型可能不同。&lt;br/&gt;　　框架需要对&lt;span&gt;key和value的类(classes)进行序列化操作，因此，这些类需要实现Writable接口&lt;/span&gt;。另外，&lt;span&gt;为了方便框架执行排序操作，key类必须实现 WritableComparable接口&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　注意：不管是哪里的序列化，最主要的作用就是&lt;span&gt;持久化存储或者是用于网络传输&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　一个Map/Reduce作业的输入和输出类型如下所示：&lt;br/&gt;　　(input) &amp;lt;k1, v1&amp;gt; -&amp;gt; map -&amp;gt; &amp;lt;k2, v2&amp;gt;-&amp;gt; combine -&amp;gt; &amp;lt;k2, v2&amp;gt; -&amp;gt; reduce -&amp;gt; &amp;lt;k3, v3&amp;gt; (output)。&lt;/p&gt;
&lt;p&gt;　　其实在前面讲解Hadoop  IO的时候已经知道了解了Writale接口：　　&lt;/p&gt;
&lt;p&gt;　　　　Writable接口是一个实现了序列化协议的序列化对象。&lt;br/&gt;　　　　在Hadoop中定义一个结构化对象都要实现Writable接口，使得该结构化对象可以序列化为字节流，字节流也可以反序列化为结构化对象。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171025160423144-220278928.png&quot; alt=&quot;&quot; width=&quot;629&quot; height=&quot;188&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　mapreduce 其实是&lt;span&gt;分治算法&lt;/span&gt;的一种现，所谓&lt;span&gt;分治算法就是“就是分而治之 ，将大的问题分解为相同类型的子问题（最好具有相同的规模），对子问题进行求解，然后合并成大问题的解&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　mapreduce就是&lt;span&gt;分治法的一种，将输入进行分片，然后交给不同的task进行处理，然后合并成最终的解&lt;/span&gt;。 &lt;br/&gt;　　mapreduce实际的处理过程可以理解为&lt;strong&gt;Input-&amp;gt;Map-&amp;gt;Sort-&amp;gt;Combine-&amp;gt;Partition-&amp;gt;Reduce-&amp;gt;Output&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　1）Input阶段&lt;/p&gt;
&lt;p&gt;　　　　数据以&lt;span&gt;一定的格式传递给Mapper&lt;/span&gt;，有TextInputFormat，DBInputFormat，SequenceFileFormat等可以使用，在Job.setInputFormat可以设置，也可以自定义分片函数。&lt;/p&gt;
&lt;p&gt;　　2）map阶段&lt;/p&gt;
&lt;p&gt;　　　　对输入的(key，value)进行处理，即map(k1,v1)-&amp;gt;list(k2,v2),使用Job.setMapperClass进行设置。&lt;/p&gt;
&lt;p&gt;　　3）Sort阶段&lt;/p&gt;
&lt;p&gt;　　　　对&lt;span&gt;于Mapper的输出进行排序，使用Job.setOutputKeyComparatorClass进行设置，然后定义排序规则&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　4）Combine阶段&lt;/p&gt;
&lt;p&gt;　　　　这个阶段对于Sort之后又相同key的结果进行合并，使用Job.setCombinerClass进行设置，也可以自定义Combine Class类。&lt;/p&gt;
&lt;p&gt;　　5）Partition阶段&lt;/p&gt;
&lt;p&gt;　　　　将Mapper的中间结果&lt;span&gt;按照key的范围划分为R份（Reduce作业的个数），默认使用HashPartioner（key.hashCode()&amp;amp;Integer.MAX_VALUE%numPartitions），也可以自定义划分&lt;/span&gt;的函数。&lt;/p&gt;
&lt;p&gt;　　　　使用Job.setPartitionClass设置。&lt;/p&gt;
&lt;p&gt;　　6）Reduce阶段&lt;/p&gt;
&lt;p&gt;　　　　对于Mapper阶段的结果进行进一步处理，Job.setReducerClass进行设置自定义的Reduce类。&lt;/p&gt;
&lt;p&gt;　　7）Output阶段&lt;/p&gt;
&lt;p&gt;　　　　Reducer输出数据的格式。&lt;/p&gt;

&lt;p&gt;　　一个mapreduce作业的执行流程是：&lt;span&gt;作业提交-&amp;gt;作业初始化-&amp;gt;任务分配-&amp;gt;任务执行-&amp;gt;更新任务执行进度和状态-&amp;gt;作业完成&lt;/span&gt;。 &lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171025164459238-1429314889.png&quot; alt=&quot;&quot; width=&quot;589&quot; height=&quot;491&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　一个完整的mapreduce作业流程，包括4个独立的实体：&lt;br/&gt;　　　　客户端：client，编写mapreduce程序，配置作业，提交作业。&lt;br/&gt;　　　　JobTracker：&lt;span&gt;协调这个作业的运行，分配作业，初始化作业，与TaskTracker进行通信&lt;/span&gt;。&lt;br/&gt;　　　　TaskTracker：&lt;span&gt;负责运行作业，保持与JobTracker进行通信&lt;/span&gt;。&lt;br/&gt;　　　　HDFS：分布式文件系统，保持作业的数据和结果。&lt;/p&gt;
&lt;h2&gt;4.1、提交作业&lt;/h2&gt;
&lt;p&gt;　　JobClient使用runjob方法创建一个JobClient实例，然后调用submitJob()方法进行作业的提交，提交作业的具体过程如下：&lt;/p&gt;
&lt;p&gt;　　　　1）通过&lt;span&gt;调用JobTracker对象的getNewJobId()方法从JobTracker处获得一个作业I&lt;/span&gt;D。&lt;br/&gt;　　　　2）检查作业的相关路径。如果输出路径存在，作业将不会被提交（保护上一个作业运行结果）。&lt;br/&gt;　　　　3）计算作业的输入分片，如果无法计算，例如输入路径不存在，作业将不被提交，错误返回给mapreduce程序。&lt;br/&gt;　　　　4）将运行作业所需资源(作业jar文件，配置文件和计算得到的分片)复制到HDFS上。&lt;br/&gt;　　　　5）告知JobTracker作业准备执行（使用JobTracker对象的submitJob()方法来真正提交作业）。&lt;/p&gt;
&lt;h2&gt;4.2、作业初始化&lt;/h2&gt;
&lt;p&gt;　　当JobTracker收到Job提交的请求后，将Job保存在一个内部队列，并让Job Scheduler（作业调度器）处理并初始化。初始化涉及到创建一个封装了其tasks的job对象，&lt;/p&gt;
&lt;p&gt;　　并保持对task的状态和进度的跟踪(step 5)。当创建要运行的一系列task对象后，Job Scheduler首先开始从文件系统中获取由JobClient计算的input splits(step 6)，然后&lt;/p&gt;
&lt;p&gt;　　再为每个split创建map task。&lt;/p&gt;
&lt;h2&gt;4.3、任务的分配&lt;/h2&gt;
&lt;p&gt;　　TaskTracker和JobTracker之间的通信和任务分配是通过心跳机制完成的。TaskTracker作为一个单独的JVM，它执行一个简单的循环，主要实现每隔一段时间向JobTracker&lt;/p&gt;
&lt;p&gt;　　发送心跳，告诉JobTracker此TaskTracker是否存活，是否准备执行新的任务。如果有待分配的任务，它就会为TaskTracker分配一个任务。&lt;/p&gt;
&lt;h2&gt;4.4、任务的执行&lt;/h2&gt;
&lt;p&gt;　　TaskTracker申请到新的任务之后，就要在本地运行了。首先，是将任务本地化（包括运行任务所需的数据、配置信息、代码等），即从HDFS复制到本地。调用localizeJob()完成的。&lt;/p&gt;
&lt;p&gt;　　对于使用Streaming和Pipes创建Map或者Reduce程序的任务，Java会把key/value传递给外部进程，然后通过用户自定义的Map或者Reduce进行处理，然后把key/value传回到java中。&lt;/p&gt;
&lt;p&gt;　　其中就好像是TaskTracker的子进程在处理Map和Reduce代码一样。&lt;/p&gt;
&lt;h2&gt;4.5、更新任务的执行进度和状态&lt;/h2&gt;
&lt;p&gt;　　进度和状态是通过heartbeat(心跳机制)来更新和维护的。对于Map Task，进度就是已处理数据和所有输入数据的比例。对于Reduce Task，情况就邮电复杂，包括3部分，&lt;/p&gt;
&lt;p&gt;　　拷贝中间结果文件、排序、reduce调用，每部分占1/3。&lt;/p&gt;
&lt;h2&gt;4.6、任务完成&lt;/h2&gt;
&lt;p&gt;　　当Job完成后，JobTracker会收一个Job Complete的通知，并将当前的Job状态更新为successful，同时JobClient也会轮循获知提交的Job已经完成，将信息显示给用户。&lt;/p&gt;
&lt;p&gt;　　最后，JobTracker会清理和回收该Job的相关资源，并通知TaskTracker进行相同的操作（比如删除中间结果文件）&lt;/p&gt;

&lt;h2&gt;5.1、结构&lt;/h2&gt;
&lt;p&gt;　　一个完整的mapreduce程序在&lt;span&gt;分布式运行时有三类实例进程&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;　　　　MRAppMaster：负责整个程序的过程调度及状态协调（Hadoop2.0之后就不一样了）&lt;br/&gt;　　　　mapTask：负责map阶段的整个数据处理流程&lt;br/&gt;　　　　ReduceTask：负责reduce阶段的整个数据处理流程&lt;/p&gt;
&lt;h2&gt;5.2、MapReduce运行流程解析&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171025170710113-1941956719.png&quot; alt=&quot;&quot; width=&quot;1017&quot; height=&quot;615&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　流程分析：&lt;/p&gt;
&lt;p&gt;　　1） 一个mr程序启动的时候，最先启动的是MRAppMaster，MRAppMaster启动后根据本次job的描述信息，计算出需要的maptask实例数量，然后向集群申请机器启动&lt;/p&gt;
&lt;p&gt;　　　　相应数量的maptask进程。&lt;/p&gt;
&lt;p&gt;　　2）maptask进程启动之后，根据给定的数据切片范围进行数据处理，主体流程为：&lt;br/&gt;　　　　利用客户指定的inputformat来获取RecordReader读取数据，形成输入KV对&lt;br/&gt;　　　　将输入KV对传递给客户定义的map()方法，做逻辑运算，并将map()方法输出的KV对收集到缓存&lt;br/&gt;　　　　将缓存中的KV对按照K分区排序后不断溢写到磁盘文件&lt;/p&gt;
&lt;p&gt;　　3） MRAppMaster监控到所有maptask进程任务完成之后，会根据客户指定的参数启动相应数量的reducetask进程，并告知reducetask进程要处理的数据范围（数据分区）&lt;/p&gt;
&lt;p&gt;　　4）Reducetask进程启动之后，根据MRAppMaster告知的待处理数据所在位置，从若干台maptask运行所在机器上获取到若干个maptask输出结果文件，并在本地进行重新归并排序，&lt;/p&gt;
&lt;p&gt;　　　　然后按照相同key的KV为一个组，调用客户定义的reduce()方法进行逻辑运算，并收集运算输出的结果KV，然后调用客户指定的outputformat将结果数据输出到外部存储。&lt;/p&gt;
&lt;h2&gt;5.3、MapTask并行度决定机制&lt;/h2&gt;
&lt;p&gt;　　maptask的并行度&lt;span&gt;决定map阶段的任务处理并发度，进而影响到整个job的处理速度&lt;/span&gt; &lt;br/&gt;　　那么，mapTask并行实例是否越多越好呢？其并行度又是如何决定呢？&lt;/p&gt;
&lt;h3&gt;5.3.1、mapTask并行度的决定机制&lt;/h3&gt;
&lt;p&gt;　　一个job的map阶段并行度&lt;span&gt;由客户端在提交job时决定而客户端对map阶段并行度的规划&lt;/span&gt;的基本逻辑为： &lt;br/&gt;&lt;code&gt;　　　　将待&lt;span&gt;处理数据执行逻辑切片（即按照一个特定切片大小，将待处理数据划分成逻辑上的多个split），然后每一个split分配一个mapTask并行实例处理&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;span&gt;　　　　这段逻辑及形成的切片规划描述文件，由FileInputFormat实现类的getSplits()方法完成&lt;/span&gt;，其过程如下图： &lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171025171312488-1207292021.png&quot; alt=&quot;&quot; width=&quot;906&quot; height=&quot;534&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5.3.2、FileInputFormat切片机制&lt;/h3&gt;
&lt;p&gt;　　1）FileInputFormat切片机制切片定义在InputFormat类中的getSplit()方法&lt;br/&gt;　　2）FileInputFormat中默认的切片机制：&lt;br/&gt;　　　　简单地按照文件的内容长度进行切片&lt;br/&gt;　　　　切片大小，默认等于block大小&lt;br/&gt;　　　    切片时不考虑数据集整体，而是逐个针对每一个文件单独切片&lt;br/&gt;　　比如待处理数据有两个文件：&lt;/p&gt;
&lt;p&gt;　　　　file1.txt 320M&lt;br/&gt;　　　　file2.txt 10M&lt;/p&gt;
&lt;p&gt;　　经过FileInputFormat的切片机制运算后，形成的切片信息如下：&lt;/p&gt;
&lt;p&gt;　　　　file1.txt.split1-- 0~128&lt;br/&gt;　　　　file1.txt.split2-- 128~256&lt;br/&gt;　　　　file1.txt.split3-- 256~320&lt;br/&gt;　　　　file2.txt.split1-- 0~10M&lt;br/&gt;　　3）FileInputFormat中切片的大小的参数配置&lt;br/&gt;　　　　通过分析源码，在FileInputFormat中，计算切片大小的逻辑：Math.max(minSize, Math.min(maxSize, blockSize)); 切片主要由这几个值来运算决定&lt;/p&gt;
&lt;p&gt;　　　　minsize：默认值：1&lt;br/&gt;　　　　配置参数： mapreduce.input.fileinputformat.split.minsize&lt;br/&gt;　　　　maxsize：默认值：Long.MAXValue&lt;br/&gt;　　　　配置参数：mapreduce.input.fileinputformat.split.maxsize&lt;br/&gt;　　　　blocksize&lt;/p&gt;
&lt;p&gt;　　因此，默认情况下，切片大小=blocksize&lt;br/&gt;　　maxsize（切片最大值）：&lt;br/&gt;　　参数如果调得比blocksize小，则会让切片变小，而且就等于配置的这个参数的值&lt;br/&gt;　　minsize （切片最小值）：&lt;br/&gt;　　参数调的比blockSize大，则可以让切片变得比blocksize还大&lt;/p&gt;

&lt;p&gt;　　选择并发数的影响因素：&lt;/p&gt;
&lt;p&gt;　　　　运算节点的硬件配置&lt;br/&gt;　　　　运算任务的类型：CPU密集型还是IO密集型&lt;br/&gt;　　　　运算任务的数据量&lt;/p&gt;
&lt;h3&gt;5.3.3、ReduceTask并行度的决定&lt;/h3&gt;
&lt;p&gt;　　reducetask的并行度同样影响整个job的执行并发度和执行效率，但与maptask的并发数由切片数决定不同，Reducetask数量的决定是可以直接手动设置：&lt;/p&gt;
&lt;p&gt;　　//默认值是1，手动设置为4&lt;br/&gt;　　job.setNumReduceTasks(4);&lt;/p&gt;
&lt;p&gt;　　如果数据分布不均匀，就有可能在reduce阶段产生数据倾斜&lt;br/&gt;　　注意： reducetask数量并不是任意设置，还要考虑业务逻辑需求，有些情况下，需要计算全局汇总结果，就只能有1个reducetask&lt;br/&gt;　　尽量不要运行太多的reduce task。对大多数job来说，最好rduce的个数最多和集群中的reduce持平，或者比集群的 reduce slots小。这个对于小集群而言，尤其重要。&lt;/p&gt;
&lt;h2&gt;5.4、mapreduce的shuffle机制&lt;/h2&gt;
&lt;p&gt;　　1）概述&lt;/p&gt;
&lt;p&gt;　　　　mapreduce中，&lt;span&gt;map阶段处理的数据如何传递给reduce阶段，是mapreduce框架中最关键的一个流程，这个流程就叫shuffle&lt;/span&gt;。&lt;br/&gt;　　　　shuffle: 洗牌、发牌——（核心机制：数据分区，排序，缓存）。&lt;br/&gt;　　　　具体来说：就是&lt;span&gt;将maptask输出的处理结果数据，分发给reducetask，并在分发的过程中，对数据按key进行了分区和排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171025175753082-153977787.png&quot; alt=&quot;&quot; width=&quot;1307&quot; height=&quot;529&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　分区partition（确定哪个数据进入哪个reduce）&lt;br/&gt;　　　　Sort根据key排序&lt;br/&gt;　　　　Combiner进行局部value的合并&lt;/p&gt;
&lt;p&gt;　　2）详细流程　　&lt;/p&gt;
&lt;p&gt;　　　　1、 maptask收集我们的map()方法输出的kv对，放到内存缓冲区中 &lt;br/&gt;　　　　2、 从内存缓冲区不断溢出本地磁盘文件，可能会溢出多个文件 &lt;br/&gt;　　　　3、 多个溢出文件会被合并成大的溢出文件 &lt;br/&gt;　　　　4、 在溢出过程中，及合并的过程中，都要调用partitoner进行分组和针对key进行排序 &lt;br/&gt;　　　　5、 reducetask根据自己的分区号，去各个maptask机器上取相应的结果分区数据 &lt;br/&gt;　　　　6、 reducetask会取到同一个分区的来自不同maptask的结果文件，reducetask会将这些文件再进行合并（归并排序） &lt;br/&gt;　　　　7、 合并成大文件后，shuffle的过程也就结束了，后面进入reducetask的逻辑运算过程（从文件中取出一个一个的键值对group，调用用户自定义的reduce()方法）&lt;/p&gt;
&lt;p&gt;　　Shuffle中的缓冲区大小会影响到mapreduce程序的执行效率，原则上说，缓冲区越大，磁盘io的次数越少，执行速度就越快 &lt;br/&gt;　　缓冲区的大小可以通过参数调整, 参数：io.sort.mb 默认100M&lt;/p&gt;

&lt;h2&gt;6.1、YARN概述&lt;/h2&gt;
&lt;p&gt;　　Yarn是一个&lt;span&gt;资源调度平台&lt;/span&gt;，&lt;span&gt;负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台&lt;/span&gt;，而&lt;span&gt;mapreduce等运算程序则相当于运行于操作系统之上的应用程序&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;6.2、YARN中的重要概念&lt;/h2&gt;
&lt;p&gt;　　1） yarn并&lt;span&gt;不清楚用户提交的程序的运行机制&lt;/span&gt; &lt;br/&gt;　　2） yarn&lt;span&gt;只提供运算资源的调度&lt;/span&gt;（用户程序向yarn申请资源，yarn就负责分配资源） &lt;br/&gt;　　3） yarn中的&lt;span&gt;主管角色叫ResourceManager&lt;/span&gt; &lt;br/&gt;　　4） yarn中具体&lt;span&gt;提供运算资源的角色叫NodeManager &lt;/span&gt;&lt;br/&gt;　　5） 这样一来，yarn其实就与运行的用户程序完全解耦，就意味着&lt;span&gt;yarn上可以运行各种类型的分布式运算程序（mapreduce只是其中的一种）&lt;/span&gt;，比如mapreduce、storm程序，spark程序，tez …… &lt;br/&gt;　　6） 所以，&lt;span&gt;spark、storm等运算框架都可以整合在yarn上运行，只要他们各自的框架中有符合yarn规范的资源请求机制即可&lt;/span&gt; &lt;br/&gt;　　7） Yarn就成为一个通用的资源调度平台，从此，企业中以前存在的各种运算集群都可以整合在一个物理集群上，提高资源利用率，方便数据共享&lt;/p&gt;
&lt;p&gt;6.3、YARN中运行运算程序实例&lt;/p&gt;
&lt;p&gt;　　mapreduce程序的调度过程，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171025180626691-1672483744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;喜欢就点个“推荐”！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 25 Oct 2017 13:39:00 +0000</pubDate>
<dc:creator>苦水润喉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyinhua/p/7729878.html</dc:identifier>
</item>
<item>
<title>【开源】博客园文章编辑器4.0版发布 - liulun</title>
<link>http://www.cnblogs.com/liulun/p/7732415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liulun/p/7732415.html</guid>
<description>&lt;p&gt;最近个人时间多起来了；&lt;/p&gt;
&lt;p&gt;于是打算持续写一点东西；&lt;/p&gt;
&lt;p&gt;前面写了两篇关于&lt;a href=&quot;http://www.cnblogs.com/liulun/p/7681073.html&quot; target=&quot;_self&quot;&gt;riot.js&lt;/a&gt;的东西；&lt;/p&gt;
&lt;p&gt;被博客园的领导移出首页了；&lt;/p&gt;
&lt;p&gt;原因之一是排版不整齐；&lt;/p&gt;
&lt;p&gt;确实是不整齐，这我认，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.baidu.com/hi/tsj/t_0017.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然而，我自己可是博客园文章编辑器的作者啊，&lt;/p&gt;
&lt;p&gt;而且持续写了三版了，&lt;a href=&quot;http://www.cnblogs.com/liulun/p/5265636.html&quot; target=&quot;_self&quot;&gt;从1.0.0写到3.0.0&lt;/a&gt;；&lt;/p&gt;
&lt;p&gt;而且有很多园友也在用我的编辑器写博客；&lt;/p&gt;
&lt;p&gt;（陆续也有人在问我这个工具的下载地址，源码的问题；）&lt;/p&gt;
&lt;p&gt;我自己咋就排班不好文章了呢？&lt;/p&gt;
&lt;p&gt;于是翻出以前的工具代码，&lt;/p&gt;
&lt;p&gt;回顾了一下，发现各个版本都还有很多问题没解决掉；&lt;/p&gt;
&lt;p&gt;于是决定大规模重构一遍；&lt;/p&gt;
&lt;p&gt;说白了就是重写一遍啦；&lt;/p&gt;
&lt;p&gt;大概一个星期的功夫，于是就有了这个工具；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.baidu.com/hi/tsj/t_0003.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;博客登录（引入博客园的登录画面，使用官方提供的登录机制）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;检索历史文章（可以检索到你博客园内所有的随笔文章，支持分页）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;修改文章（你博客园内所有的历史随笔文章，都可以用此工具编辑修改）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;新增文章（从无到有撰写一篇新的随笔文章）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;QQ截图直接黏贴&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;纯客户端，不需要网络服务器支持，直接与博客园服务端通信&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;纯绿色版，不需要安装，没有额外的服务，体积更小；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;自动升级功能（我发布新版本之后，会提示您升级）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;引入百度ueditor编辑器&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;7个大类的表情，随意挑选&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;24种语言的代码着色方案&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多种表格控制工具&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;修复了很多ueditor尚未修复的BUG&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;最最关键的还是开源！（照着这个代码写个淘宝下单器之类的东西，简直易如反掌）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;功能上比上三个版本提升了不少，有质的飞跃！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.baidu.com/hi/tsj/t_0019.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;文章撰写界面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/other/28932/201710/28932-20171025213514926-1536322927.png&quot; alt=&quot;&quot; width=&quot;50%&quot; height=&quot;50%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;右侧快捷菜单：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/other/28932/201710/28932-20171025213746269-1286218664.png&quot; alt=&quot;&quot; width=&quot;50%&quot; height=&quot;50%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;历史文章列表：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/other/28932/201710/28932-20171025213924473-2055797651.png&quot; alt=&quot;&quot; width=&quot;50%&quot; height=&quot;50%&quot;/&gt; &lt;/p&gt;
&lt;p&gt;这知识几个关键界面&lt;/p&gt;
&lt;p&gt;里面还有一些细小的提示画面&lt;/p&gt;
&lt;p&gt;就不在一一截图了&lt;/p&gt;

&lt;p&gt;开源地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/xland/cnblogs&quot;&gt;https://gitee.com/xland/cnblogs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（这次开源到码云上，速度确实比github快不少，原来再github上的项目我以后会废弃掉）&lt;/p&gt;
&lt;p&gt;大家发现什么问题可以直接提issue &lt;/p&gt;
&lt;p&gt;如果大家期待什么新功能，也可以提issue；&lt;/p&gt;
&lt;p&gt;下载地址：&lt;/p&gt;
&lt;p&gt;（码云开源项目-&amp;gt;发行版页面下载） &lt;/p&gt;

&lt;p&gt;强烈希望大家能给个star；&lt;/p&gt;
&lt;p&gt;这让我知道你在用；&lt;/p&gt;
&lt;p&gt;这让我有动力继续做一些对大家有用的东西；&lt;/p&gt;
&lt;p&gt;最后插一段关键代码：&lt;/p&gt;
&lt;pre class=&quot;brush:js;toolbar:false&quot;&gt;
bky.uploadImg = function(event,cb){
    var items = event.clipboardData.items;
    if(items[0].type.indexOf(&quot;image&quot;) &amp;lt; 0){
        return;
    }
    var file = items[0].getAsFile();
    var formData = new FormData();
    formData.append('imageFile', file);
    formData.append(&quot;mimeType&quot;, file.type);
    var frame = document.getElementById('articleFrame').contentWindow
    frame.$.ajax({
        type: 'POST',
        url:bky.imgUploadUrl,
        data: formData,
        processData: false, 
        contentType: false, 
        dataType: 'json',
        xhrFields: {
            withCredentials: true
        },
        success: function(result) {
            if(result.success){
                var img = '&amp;lt;img src=&quot;' + result.message + '&quot; /&amp;gt;';
                cb(img);
            }
        }
    });    
}
&lt;/pre&gt;






</description>
<pubDate>Wed, 25 Oct 2017 13:15:00 +0000</pubDate>
<dc:creator>liulun</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liulun/p/7732415.html</dc:identifier>
</item>
<item>
<title>Java设计模式之工厂模式 - WhiteBlackCat</title>
<link>http://www.cnblogs.com/FZfangzheng/p/7732381.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FZfangzheng/p/7732381.html</guid>
<description>&lt;h2 id=&quot;java设计模式工厂factory模式&quot;&gt;Java设计模式：工厂（Factory）模式&lt;/h2&gt;
&lt;h3 id=&quot;问题分析&quot;&gt;1.问题分析&lt;/h3&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;首先，给出一个不够合理的披萨店设计&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class OldStore {
    Pizza orderPizza(){
        Pizza pizza = new Pizza();
        pizza.prepare(); 
        pizza.bake(); 
        pizza.cut();
        pizza.box(); 
        return pizza; 
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;如果我们需要更多不同种类的pizza，那么我们就要增加代码来确定pizza的类型，然后才能制造pizza，那么，披萨店的设计代码就可能变成下面这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class OldStore {
    Pizza orderPizza(String type){
        Pizza pizza = new Pizza();
        //-----不停变化的部分-----
        if(type.equals(&quot;cheese&quot;)){
            pizza = new ChessePizza();
        } else if (type.equals(”greek”)) { 
            pizza = new GreekPizza(); 
        } else if (type.equals(”other”)) { 
            //other type
        }
        //----------------------
        pizza.prepare(); 
        pizza.bake(); 
        pizza.cut();
        pizza.box(); 
        return pizza; 
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们可以发现，如果要增加不同的种类，那么，我们就必须去修改oderPizza()方法里的代码，这样，oderPizza()无法对修改关闭，所以我们需要进一步使用封装。下面给出三种类型的工厂模式。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;简单工厂&quot;&gt;2.简单工厂&lt;/h3&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;如果需要让&lt;strong&gt;oderPizza()方法对修改关闭&lt;/strong&gt;，我们应该如何设计呢？那便是将不停变化的部分，即确定披萨类型的部分抽离出来，放到另一个类里，如SimplePizzaFactory，OldStore类只需要负责从SimplePizzaFactory里获取披萨，然后进行后续操作即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class SimplePizzaFactroy {
    public Pizza createPizza(String type) { 
        Pizza pizza = null;
        if (type.equals(”cheese”)) { 
            pizza = new CheesePizza();
        } else if (type.equals(”greek”)) { 
            pizza = new GreekPizza();
        } else if (type.equals(”other”)) { 
            // other type. 
        }
        return pizza;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;对应的，&lt;strong&gt;将OldStore重做为PizzaStore类&lt;/strong&gt;，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PizzaStore { 
    SimplePizzaFactory factory; //加入一个对SimplePizzaFactory的引用
    //构造需要一个工厂作为参数 
    public PizzaStore(SimplePizzaFactory factory) { 
        this.factory = factory; 
    }
    public Pizza orderPizza(String type) { 
        Pizza pizza;
        //该方法通过简单传入订单类型来使用工厂创建披萨
        pizza = factory.createPizza(type); // new操作符被换为工厂对象创建方法
        pizza.prepare(); 
        pizza.bake(); 
        pizza.cut();
        pizza.box(); 
        return pizza; 
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;工厂方法&quot;&gt;3.工厂方法&lt;/h3&gt;
&lt;ul readability=&quot;11&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;加盟披萨店&lt;/strong&gt; 要求披萨店的各个加盟店能够提供不同风味的披萨，并复用代码，以使得披萨的 流程能够一致不变。利用 SimplePizzaFactory 的一般实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;NYPizzaFactory nyFactory = new NYPizzaFactory();
PizzaStore nyStore = new PizzaStore(nyFactory);
nyStore.orderPizza(”Veggie”) ;
ChicagoPizzaFactory chicagoFactory = new ChicagoPizzaFactory(); 
PizzaStore nyStore = new PizzaStore(chicagoFactory); 
nyStore.orderPizza(”Veggie”) ;&lt;/code&gt;
&lt;/pre&gt;
即以SimplePizzaFactory为父类，派生不同的工厂类。当我们希望能够建立一个框架，把加盟店和创建披萨捆绑在一起，保持披萨的质量控制，同时使得代码具有一定的弹性。我们应该怎么做呢？&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;strong&gt;给披萨店使用的框架&lt;/strong&gt;采用如下框架可以使得披萨制作活动局限于 PizzaStore 类，而同时又能 让这些加盟店依然可以自由的制作该区域的风味。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class PizzaStore {
    public Pizza OrderPizza(String type) { 
        Pizza pizza;
        // createPizza()方法从工厂对象中回到PizzaStore
        pizza = createPizza(type);
        pizza.prepare(); 
        pizza.bake(); 
        pizza.cut();
        pizza.box(); 
        return pizza; 
    }       
    // PizzaStore里的工厂方法是抽象的 
    abstract Pizza createPizza(String type); 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，我们将原本放在工厂中实现的创建pizza操作，放回到了PizzaStore里，我们现在只需要以PizzaStore为父类，让每个区域的不同pizza店继承，各自实现createPizza()方法就行。createPizza() 方法是个抽象方法，所有任何具体的加盟店必须实现这个方法，从而个性化加盟 店的披萨风味。例如，NYPPizzaStore的实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class NYPizzaStore extends PizzaStore {
    @Override 
    Pizza createPizza(String type) {
        if (type.equals(”cheese”)) {
            return new NYStyleCheesePizza(); 
        } else if (type.equals(”veggie”)) {
            return new NYStyleVeggiePizza(); 
        } else if (type.equals(”other”)) { 
            // other type. 
        } else 
            return null; 
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;原来是在简单工厂中是由一个对象负责所有具体类的实例化，现在通过对 PizzaStore 作改变，使得由一群子类来负责实例化。 工厂方法用来处理对象的创建，并将这样的行为封装在子类中，这样客户程序中关于超类的 代码就和子类对象创建代码解耦。&lt;/li&gt;
&lt;li&gt;工厂方法是抽象&lt;/li&gt;
&lt;li&gt;工厂方法必须返回一个产品，超类中定义的方法，通常会用到工厂方法的返回值&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;工厂方法将客户（即超类中的代码，如 orderPizza()）和实际创建具体产品的代码分隔开。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;抽象工厂&quot;&gt;4.抽象工厂&lt;/h3&gt;
&lt;ul readability=&quot;14.5&quot;&gt;&lt;li readability=&quot;32&quot;&gt;
&lt;p&gt;工厂方法模式从设计角度考虑存在一定的问题：类的创建依赖工厂类。也就是说，如果想要 拓展程序，必须对工厂类进行修改，这违背了闭包原则。 所以，可以使用抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的 工厂类就可以了，不需要修改之前的代码。参考示例的4.3类图，该示例包含一个消息发送者接口 (Sender) 和一个抽象工厂接口（Provider）。&lt;/p&gt;
&lt;p&gt;相关代码如下：&lt;/p&gt;
&lt;p&gt;File: Sender.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package ouc.cs.course.java.test.abstractfactory;
public interface Sender { 
    public void Send(); 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;File: Provider.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package ouc.cs.course.java.test.abstractfactory;
public interface Provider { 
    public Sender produce(); 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;File: MailSender.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package ouc.cs.course.java.test.abstractfactory;
public class MailSender implements Sender {
    public void Send() {
        System.out.println(”this is mailsender!”); 
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;File: SmsSender.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package ouc.cs.course.java.test.abstractfactory;
public class SmsSender implements Sender {
    public void Send() {
        System.out.println(”this is smssender!”); 
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;File: SendMailFactory.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package ouc.cs.course.java.test.abstractfactory;
public class SendMailFactory implements Provider {
    @Override
    public Sender produce() { 
        return new MailSender(); 
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;File: SendSmsFactory.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package ouc.cs.course.java.test.abstractfactory;
public class SendSmsFactory implements Provider {
    @Override
    public Sender produce() { 
        return new SmsSender(); 
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;File: Test.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package test.abstractfactory;
import ouc.cs.course.java.test.abstractfactory.Provider; 
import ouc.cs.course.java.test.abstractfactory.SendMailFactory; 
import ouc.cs.course.java.test.abstractfactory.Sender;

public class Test { 
    public static void main(String[] args) { 
        Provider provider = new SendMailFactory(); 
        Sender sender = provider.produce(); 
        sender.Send(); 
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你想要扩展产品种类时，只需要增加对应的工厂类和产品类即可，比如我要增加一个QQSender类，只需要新建一个QQSender类实现Sender接口和SendQQFactory类实现Provider接口即可扩展产品种类。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 25 Oct 2017 13:07:00 +0000</pubDate>
<dc:creator>WhiteBlackCat</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FZfangzheng/p/7732381.html</dc:identifier>
</item>
<item>
<title>洗礼灵魂，修炼python（41）--巩固篇—从游戏《绝地求生-大逃杀》中回顾面向对象编程 - yangva</title>
<link>http://www.cnblogs.com/yangva/p/7719456.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangva/p/7719456.html</guid>
<description>&lt;p&gt;&amp;#13;
                                    &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;×&lt;/span&gt;&lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt;&lt;/button&gt;&amp;#13;
                                    &lt;h4 class=&quot;modal-title&quot;&gt;&amp;#13;
                                        请完成人机识别验证&amp;#13;
                                    &lt;/h4&gt;&amp;#13;
                                &lt;/p&gt;
                                &lt;div class=&quot;modal-body&quot; readability=&quot;33&quot;&gt;
                                    
                                    &lt;p&gt;&amp;#13;
                                        &lt;span id=&quot;geetestLoading&quot;&gt; 验证码组件加载中,请稍后...&lt;/span&gt;&amp;#13;
                                    &lt;/p&gt;
                                &lt;/div&gt;
                            </description>
<pubDate>Wed, 25 Oct 2017 13:01:00 +0000</pubDate>
<dc:creator>yangva</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://passport.cnblogs.com/user/signin?ReturnUrl=http%3A%2F%2Fwww.cnblogs.com%2Fyangva%2Fp%2F7719456.html&amp;AspxAutoDetectCookieSupport=1</dc:identifier>
</item>
<item>
<title>【Spring】构建Spring Web应用 - leesf</title>
<link>http://www.cnblogs.com/leesf456/p/7732327.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leesf456/p/7732327.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;学习了&lt;code&gt;Spring&lt;/code&gt;的注解、&lt;code&gt;AOP&lt;/code&gt;后，接着学习&lt;code&gt;Spring Web&lt;/code&gt;，对于&lt;code&gt;Web&lt;/code&gt;应用开发，&lt;code&gt;Spring&lt;/code&gt;提供了&lt;code&gt;Web&lt;/code&gt;框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;web应用&quot;&gt;Web应用&lt;/h2&gt;
&lt;h3 id=&quot;spring-mvc初探&quot;&gt;Spring MVC初探&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;MVC&lt;/code&gt;为(&lt;code&gt;Model-View-Control&lt;/code&gt;)，当用户在浏览器中点击链接或提交表单时，请求经历的流程大致如下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/leesf/blogPhotos/master/request-routine.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Spring MVC&lt;/code&gt;所有的请求都会通过一个前端控制器(front controller servlet)，也即是&lt;code&gt;DispatcherServlet&lt;/code&gt;，&lt;code&gt;DispatcherServlet&lt;/code&gt;用于将请求发送给&lt;code&gt;Spring MVC&lt;/code&gt;控制器，而&lt;code&gt;处理器映射&lt;/code&gt;会根据&lt;code&gt;url&lt;/code&gt;信息确定将请求发送给哪个控制器。&lt;/li&gt;
&lt;li&gt;当请求发送给控制器后，请求会等待控制器处理信息，更好的设计是控制器将请求交给服务对象处理。&lt;/li&gt;
&lt;li&gt;控制器处理完后，会产生信息，该信息需要返回给用户并在浏览器上显示，这些信息称为&lt;code&gt;模型(Model)&lt;/code&gt;。同时，这些信息需要以用户友好的方式进行格式化，此时需要将信息发送给一个&lt;code&gt;视图(View)&lt;/code&gt;进行处理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt;拿到模型及逻辑视图名后会使用视图解析器进行解析，将其转化为特定视图实现。&lt;/li&gt;
&lt;li&gt;指定视图实现后，需要将模型数据数据交付，视图将使用模型数据渲染输出。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;配置dispatcherservlet&quot;&gt;配置DispatcherServlet&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt;是&lt;code&gt;Spring MVC&lt;/code&gt;的核心，其负责将请求路由到其他组件中。可通过将&lt;code&gt;Servlet&lt;/code&gt;配置在&lt;code&gt;web.xml&lt;/code&gt;中或者使用&lt;code&gt;Java&lt;/code&gt;显示编码方式将&lt;code&gt;DispatcherServlet&lt;/code&gt;配置在&lt;code&gt;Servlet&lt;/code&gt;容器中，本例中设置的&lt;code&gt;SpittrWebAppInitializer&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package ch5;&lt;/span&gt;


&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SpitterWebInitializer &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; AbstractAnnotationConfigDispatcherServletInitializer {

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt;[] &lt;span class=&quot;fu&quot;&gt;getRootConfigClasses&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Class&amp;lt;?&amp;gt;[] { RootConfig.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt; };
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt;[] &lt;span class=&quot;fu&quot;&gt;getServletConfigClasses&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Class&amp;lt;?&amp;gt;[] { WebConfig.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt; };
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; String[] &lt;span class=&quot;fu&quot;&gt;getServletMappings&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String[] { &lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt; };
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;其中&lt;code&gt;getServletMappings&lt;/code&gt;方法会将一个或多个路径映射到&lt;code&gt;DispatcherServlet&lt;/code&gt;上，&lt;code&gt;/&lt;/code&gt;表示它是默认的&lt;code&gt;Servlet&lt;/code&gt;，将会处理所有进入应用的请求。&lt;br/&gt;当&lt;code&gt;DispatcherServlet&lt;/code&gt;启动时，会创建&lt;code&gt;Spring&lt;/code&gt;应用上下文，并加载配置文件或配置类中所声明的&lt;code&gt;bean&lt;/code&gt;，如上述&lt;code&gt;getServletConfigClasses&lt;/code&gt;方法中返回的带有&lt;code&gt;@Configuration&lt;/code&gt;注解的所有定义在&lt;code&gt;WebConfig&lt;/code&gt;中的&lt;code&gt;bean&lt;/code&gt;。与此同时，在&lt;code&gt;Spring Web&lt;/code&gt;应用中，还会有另一个由&lt;code&gt;ContextLoaderListener&lt;/code&gt;创建的应用上下文，如&lt;code&gt;getRootConfigClasses&lt;/code&gt;方法中返回的带有&lt;code&gt;@Configuration&lt;/code&gt;注解的所有定义在&lt;code&gt;RootConfig&lt;/code&gt;中的&lt;code&gt;bean&lt;/code&gt;。&lt;code&gt;AbstractAnnotationConfigDispatcherServletInitializer&lt;/code&gt;会同时创建&lt;code&gt;DispatcherServlet&lt;/code&gt;和&lt;code&gt;ContextLoaderListener&lt;/code&gt;两个应用上下文，&lt;code&gt;DispatcherServlet&lt;/code&gt;应用上下文加载&lt;code&gt;Web&lt;/code&gt;组件的&lt;code&gt;bean&lt;/code&gt;，如&lt;code&gt;控制器&lt;/code&gt;、&lt;code&gt;视图解析器&lt;/code&gt;、&lt;code&gt;处理映射器&lt;/code&gt;；&lt;code&gt;ContextLoaderListener&lt;/code&gt;应用上下文加载其他&lt;code&gt;bean&lt;/code&gt;，如&lt;code&gt;驱动应用后端的中间层&lt;/code&gt;和&lt;code&gt;数据层组件&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;配置web组件并启动spring-mvc&quot;&gt;配置Web组件并启动Spring MVC&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可使用&lt;code&gt;&amp;lt;mvc:annotation-driven&amp;gt;&lt;/code&gt;启动注解启动的&lt;code&gt;Spring MVC&lt;/code&gt;，也可使用&lt;code&gt;@EnableWebMvc&lt;/code&gt;注解启动。&lt;code&gt;WebConfig&lt;/code&gt;对应&lt;code&gt;Web&lt;/code&gt;组件配置，其代码如下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package ch5;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Bean;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.ComponentScan;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Configuration;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.servlet.ViewResolver;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.servlet.config.annotation.EnableWebMvc;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.servlet.view.InternalResourceViewResolver;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@EnableWebMvc&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@ComponentScan&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;ch5&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; WebConfig &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; WebMvcConfigurerAdapter {

    &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ViewResolver &lt;span class=&quot;fu&quot;&gt;viewResolver&lt;/span&gt;() {
        InternalResourceViewResolver resolver = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;InternalResourceViewResolver&lt;/span&gt;();
        resolver.&lt;span class=&quot;fu&quot;&gt;setPrefix&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/WEB-INF/views/&quot;&lt;/span&gt;);
        resolver.&lt;span class=&quot;fu&quot;&gt;setSuffix&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;.jsp&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; resolver;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;configureDefaultServletHandling&lt;/span&gt;(DefaultServletHandlerConfigurer configurer) {
        configurer.&lt;span class=&quot;fu&quot;&gt;enable&lt;/span&gt;();
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addResourceHandlers&lt;/span&gt;(ResourceHandlerRegistry registry) {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;addResourceHandlers&lt;/span&gt;(registry);
    }

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;其中配置了&lt;code&gt;JSP视图解析器&lt;/code&gt;，也配置&lt;code&gt;静态资源处理器&lt;/code&gt;(对静态资源的请求转发到&lt;code&gt;Servlet&lt;/code&gt;容器中默认的&lt;code&gt;Servlet&lt;/code&gt;，而不是使用&lt;code&gt;DispatcherServlet&lt;/code&gt;处理)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;配置非web组件&quot;&gt;配置非Web组件&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;RootConfig&lt;/code&gt;对应非&lt;code&gt;Web&lt;/code&gt;组件配置，其源码如下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package ch5;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.ComponentScan;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.ComponentScan.Filter;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Configuration;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.FilterType;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.servlet.config.annotation.EnableWebMvc;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@ComponentScan&lt;/span&gt;(basePackages = {&lt;span class=&quot;st&quot;&gt;&quot;ch5&quot;&lt;/span&gt;},
        excludeFilters = {
                &lt;span class=&quot;fu&quot;&gt;@Filter&lt;/span&gt;(type = FilterType.&lt;span class=&quot;fu&quot;&gt;ANNOTATION&lt;/span&gt;, value = EnableWebMvc.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;)
        })
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RootConfig {

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;通过&lt;code&gt;RootConfig&lt;/code&gt;的&lt;code&gt;ComponentScan&lt;/code&gt;注解可以添加很多非&lt;code&gt;Web&lt;/code&gt;组件，如&lt;code&gt;驱动应用后端的中间层&lt;/code&gt;和&lt;code&gt;数据层组件&lt;/code&gt;等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;控制器&quot;&gt;控制器&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;控制器只是在方法上添加了&lt;code&gt;@RequestMapping&lt;/code&gt;注解的类，该注解声明了它们所要处理的请求，如&lt;code&gt;HomeController&lt;/code&gt;用来处理对&lt;code&gt;/&lt;/code&gt;的请求，其源码如下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package ch5;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import static org.springframework.web.bind.annotation.RequestMethod.*;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.springframework.stereotype.Controller;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.bind.annotation.RequestMapping;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@Controller&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; HomeController {

  &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(value = &lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt;, method = GET)
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;home&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;home&quot;&lt;/span&gt;;
  }

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;至此，已经完成所有编码，可以启动该项目，可正确在浏览器中显示页面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;测试控制器&quot;&gt;测试控制器&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;Spring&lt;/code&gt;提供了&lt;code&gt;mock Spring MVC&lt;/code&gt;来测试控制器&lt;code&gt;HTTP&lt;/code&gt;请求，这样测试时就不用启动浏览器了。&lt;code&gt;HomeControllerTest&lt;/code&gt;源码如下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package ch5;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.junit.Test;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.test.web.servlet.MockMvc;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.view;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import static org.springframework.test.web.servlet.setup.MockMvcBuilders.standaloneSetup;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; HomeControllerTest {
    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;testHomePage&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        HomeController controller = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;HomeController&lt;/span&gt;();
        MockMvc mockMvc = &lt;span class=&quot;fu&quot;&gt;standaloneSetup&lt;/span&gt;(controller).&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;();

        mockMvc.&lt;span class=&quot;fu&quot;&gt;perform&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt;)).&lt;span class=&quot;fu&quot;&gt;andExpect&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;view&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;name&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;home&quot;&lt;/span&gt;));
    }

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;运行可顺利通过测试。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;定义类级别的请求处理&quot;&gt;定义类级别的请求处理&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在前面的&lt;code&gt;HomeController&lt;/code&gt;中，对于处理的请求路径是直接配置在方法上的，更好的处理是将其配置在类上，如下所示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package ch5;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import static org.springframework.web.bind.annotation.RequestMethod.*;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.springframework.stereotype.Controller;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.bind.annotation.RequestMapping;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@Controller&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; HomeController {

  &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(method = GET)
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;home&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;home&quot;&lt;/span&gt;;
  }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;上述配置在类上与前面配置在方法上的效果相同，还可配置多个路径，如下所示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package ch5;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import static org.springframework.web.bind.annotation.RequestMethod.*;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.springframework.stereotype.Controller;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.bind.annotation.RequestMapping;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@Controller&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;({&lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;/homepage&quot;&lt;/span&gt;})
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; HomeController {

  &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(method = GET)
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;home&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;home&quot;&lt;/span&gt;;
  }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;上述代码中除了配置处理路径&lt;code&gt;/&lt;/code&gt;外，还可处理&lt;code&gt;/homepage&lt;/code&gt;路径。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;传递模型数据至视图&quot;&gt;传递模型数据至视图&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一般情况下，需要传递模型数据至视图中进行渲染，此时，定义接口&lt;code&gt;SpittleRepository&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package ch5;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; SpittleRepository {
    List&amp;lt;Spittle&amp;gt; &lt;span class=&quot;fu&quot;&gt;findSpittles&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; max, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; count);
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;定义接口&lt;code&gt;SpittleRepository&lt;/code&gt;的实现子类&lt;code&gt;SpittoleRepositoryImp&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package ch5;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.springframework.stereotype.Component;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.util.ArrayList;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Date;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SpittleRepositoryImp &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; SpittleRepository {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; List&amp;lt;Spittle&amp;gt; &lt;span class=&quot;fu&quot;&gt;findSpittles&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; max, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; count) {
        List&amp;lt;Spittle&amp;gt; spittles = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Spittle&amp;gt;();
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; count; i++) {
            spittles.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Spittle&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Spittle &quot;&lt;/span&gt; + i, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Date()));
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; spittles;
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;定义&lt;code&gt;POJO&lt;/code&gt;类&lt;code&gt;Spittle&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;24&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package ch5;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.util.Date;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.apache.commons.lang3.builder.EqualsBuilder;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.commons.lang3.builder.HashCodeBuilder;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Spittle {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Long id;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String message;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Date time;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Double latitude;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Double longitude;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Spittle&lt;/span&gt;(String message, Date time) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, message, time, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Spittle&lt;/span&gt;(Long id, String message, Date time, Double longitude, Double latitude) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt; = id;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;message&lt;/span&gt; = message;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;time&lt;/span&gt; = time;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;longitude&lt;/span&gt; = longitude;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;latitude&lt;/span&gt; = latitude;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; id;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getMessage&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; message;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Date &lt;span class=&quot;fu&quot;&gt;getTime&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; time;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Double &lt;span class=&quot;fu&quot;&gt;getLongitude&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; longitude;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Double &lt;span class=&quot;fu&quot;&gt;getLatitude&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; latitude;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(Object that) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; EqualsBuilder.&lt;span class=&quot;fu&quot;&gt;reflectionEquals&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, that, &lt;span class=&quot;st&quot;&gt;&quot;id&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;time&quot;&lt;/span&gt;);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hashCode&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; HashCodeBuilder.&lt;span class=&quot;fu&quot;&gt;reflectionHashCode&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;id&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;time&quot;&lt;/span&gt;);
    }

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在&lt;code&gt;/WEB-INF/views&lt;/code&gt;目录下创建&lt;code&gt;spittles.jsp&lt;/code&gt;文件，内容如下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode jsp&quot;&gt;
&lt;code class=&quot;sourceCode jsp&quot;&gt;
&amp;lt;%@ taglib&lt;span class=&quot;ot&quot;&gt; prefix&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; uri&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;http://java.sun.com/jsp/jstl/core&quot;&lt;/span&gt;%&amp;gt;
&amp;lt;%@ taglib&lt;span class=&quot;ot&quot;&gt; prefix&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;s&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; uri&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/tags&quot;&lt;/span&gt;%&amp;gt;
&amp;lt;%@ taglib&lt;span class=&quot;ot&quot;&gt; prefix&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;fn&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; uri&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;http://java.sun.com/jsp/jstl/functions&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;%&amp;gt;
&amp;lt;%@ page&lt;span class=&quot;ot&quot;&gt; isELIgnored&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;%&amp;gt;

&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Spitter&amp;lt;/title&amp;gt;
    &amp;lt;link&lt;span class=&quot;ot&quot;&gt; rel&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;text/css&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;c:url&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;/resources/style.css&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div&lt;span class=&quot;ot&quot;&gt; class&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;listTitle&quot;&lt;/span&gt;&amp;gt;
      &amp;lt;h1&amp;gt;Recent Spittles&amp;lt;/h1&amp;gt;
      &amp;lt;ul&lt;span class=&quot;ot&quot;&gt; class&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;spittleList&quot;&lt;/span&gt;&amp;gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;c:forEach&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; items&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;${spittleList}&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; var&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;spittle&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
          &amp;lt;li&lt;span class=&quot;ot&quot;&gt; id&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;spittle_&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;c:out&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;spittle.id&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;div&lt;span class=&quot;ot&quot;&gt; class&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;spittleMessage&quot;&lt;/span&gt;&amp;gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;c:out&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;${spittle.message}&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&amp;lt;/div&amp;gt;
            &amp;lt;div&amp;gt;
              &amp;lt;span&lt;span class=&quot;ot&quot;&gt; class&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;spittleTime&quot;&lt;/span&gt;&amp;gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;c:out&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;${spittle.time}&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&amp;lt;/span&amp;gt;
              &amp;lt;span&lt;span class=&quot;ot&quot;&gt; class&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;spittleLocation&quot;&lt;/span&gt;&amp;gt;(&lt;span class=&quot;kw&quot;&gt;&amp;lt;c:out&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;${spittle.latitude}&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;&amp;lt;c:out&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;${spittle.longitude}&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;)&amp;lt;/span&amp;gt;
            &amp;lt;/div&amp;gt;
          &amp;lt;/li&amp;gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/c:forEach&amp;gt;&lt;/span&gt;
      &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;添加&lt;code&gt;SpittleController&lt;/code&gt;控制器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package ch5;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.annotation.Autowired;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.stereotype.Controller;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.ui.Model;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.bind.annotation.RequestMapping;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.bind.annotation.RequestMethod;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@Controller&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/spittles&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SpittleController {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; SpittleRepository spittleRepository;

    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SpittleController&lt;/span&gt;(SpittleRepository spittleRepository) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;spittleRepository&lt;/span&gt; = spittleRepository;
    }

    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(method = RequestMethod.&lt;span class=&quot;fu&quot;&gt;GET&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;spittles&lt;/span&gt;(Model model) {
        model.&lt;span class=&quot;fu&quot;&gt;addAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;spittleList&quot;&lt;/span&gt;, spittleRepository.&lt;span class=&quot;fu&quot;&gt;findSpittles&lt;/span&gt;(Long.&lt;span class=&quot;fu&quot;&gt;MAX_VALUE&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;));
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;spittles&quot;&lt;/span&gt;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;运行，可正确显示20个&lt;code&gt;Spittle&lt;/code&gt;实例信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;接受请求的参数&quot;&gt;接受请求的参数&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;Spring MVC&lt;/code&gt;允许以多种方式将客户端的数据传送到控制器的处理器方法中，包括&lt;code&gt;查询参数&lt;/code&gt;、&lt;code&gt;表单参数&lt;/code&gt;、&lt;code&gt;路径变量&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;处理查询参数&quot;&gt;处理查询参数&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可让用户指定&lt;code&gt;findSpittles&lt;/code&gt;方法中的&lt;code&gt;max&lt;/code&gt;和&lt;code&gt;count&lt;/code&gt;两个参数，并且在未指定时使用缺省值，修改&lt;code&gt;SpittleController&lt;/code&gt;如下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package ch5;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.annotation.Autowired;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.stereotype.Controller;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.bind.annotation.RequestMapping;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.bind.annotation.RequestMethod;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.bind.annotation.RequestParam;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@Controller&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/spittles&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SpittleController {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String MAX_LONG_AS_STRING = &lt;span class=&quot;st&quot;&gt;&quot;9223372036854775807&quot;&lt;/span&gt;;
    
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; SpittleRepository spittleRepository;

    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SpittleController&lt;/span&gt;(SpittleRepository spittleRepository) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;spittleRepository&lt;/span&gt; = spittleRepository;
    }

    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(method = RequestMethod.&lt;span class=&quot;fu&quot;&gt;GET&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; List&amp;lt;Spittle&amp;gt; &lt;span class=&quot;fu&quot;&gt;spittles&lt;/span&gt;(
            &lt;span class=&quot;fu&quot;&gt;@RequestParam&lt;/span&gt;(value = &lt;span class=&quot;st&quot;&gt;&quot;max&quot;&lt;/span&gt;, defaultValue = MAX_LONG_AS_STRING) &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; max,
            &lt;span class=&quot;fu&quot;&gt;@RequestParam&lt;/span&gt;(value = &lt;span class=&quot;st&quot;&gt;&quot;count&quot;&lt;/span&gt;, defaultValue = &lt;span class=&quot;st&quot;&gt;&quot;20&quot;&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; count) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; spittleRepository.&lt;span class=&quot;fu&quot;&gt;findSpittles&lt;/span&gt;(max, count);
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;值得注意的是，此时并没有指定视图，但是启动后仍然可以正确显示结果，这是由于视图未指定情况下与&lt;code&gt;@RequestMapping(&quot;/spittles&quot;)&lt;/code&gt;的&lt;code&gt;spittles&lt;/code&gt;相同，若换成其他路径，如&lt;code&gt;/spittles_test&lt;/code&gt;则报无法找到&lt;code&gt;**/spittles_test.jsp&lt;/code&gt;的错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;处理路径参数&quot;&gt;处理路径参数&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用&lt;code&gt;/spittles?show?spittle_id=123&lt;/code&gt;的方式可以传递参数，但是更好的一种方法是使用&lt;code&gt;/spittles/123&lt;/code&gt;方式请求，该方式优于前种方式。修改&lt;code&gt;SpittleController&lt;/code&gt;如下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package ch5;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.annotation.Autowired;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.stereotype.Controller;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.ui.Model;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.bind.annotation.PathVariable;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.bind.annotation.RequestMapping;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.bind.annotation.RequestMethod;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@Controller&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/spittles&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SpittleController {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; SpittleRepository spittleRepository;

    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SpittleController&lt;/span&gt;(SpittleRepository spittleRepository) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;spittleRepository&lt;/span&gt; = spittleRepository;
    }

    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(value = &lt;span class=&quot;st&quot;&gt;&quot;/{spittleId}&quot;&lt;/span&gt;, method = RequestMethod.&lt;span class=&quot;fu&quot;&gt;GET&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;spittles&lt;/span&gt;(
            &lt;span class=&quot;fu&quot;&gt;@PathVariable&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;spittleId&quot;&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; spittleId, Model model) {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;spittleId = &quot;&lt;/span&gt; + spittleId);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(spittleRepository.&lt;span class=&quot;fu&quot;&gt;findOne&lt;/span&gt;(spittleId).&lt;span class=&quot;fu&quot;&gt;getMessage&lt;/span&gt;());
        model.&lt;span class=&quot;fu&quot;&gt;addAttribute&lt;/span&gt;(spittleRepository.&lt;span class=&quot;fu&quot;&gt;findOne&lt;/span&gt;(spittleId));
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;spittle&quot;&lt;/span&gt;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;再添加&lt;code&gt;spittle.jsp&lt;/code&gt;页面，其源码如下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode jsp&quot;&gt;
&lt;code class=&quot;sourceCode jsp&quot;&gt;
&amp;lt;%@ taglib&lt;span class=&quot;ot&quot;&gt; prefix&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; uri&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;http://java.sun.com/jsp/jstl/core&quot;&lt;/span&gt;%&amp;gt;
&amp;lt;%@ taglib&lt;span class=&quot;ot&quot;&gt; prefix&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;s&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; uri&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/tags&quot;&lt;/span&gt;%&amp;gt;
&amp;lt;%@ taglib&lt;span class=&quot;ot&quot;&gt; prefix&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;fn&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; uri&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;http://java.sun.com/jsp/jstl/functions&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;%&amp;gt;
&amp;lt;%@ page&lt;span class=&quot;ot&quot;&gt; isELIgnored&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;%&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Spitter&amp;lt;/title&amp;gt;
    &amp;lt;link&lt;span class=&quot;ot&quot;&gt; rel&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;          type&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;text/css&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;          href&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;c:url&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;/resources/style.css&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div&lt;span class=&quot;ot&quot;&gt; class&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;spittleView&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;div&lt;span class=&quot;ot&quot;&gt; class&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;spittleMessage&quot;&lt;/span&gt;&amp;gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;c:out&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;${spittle.message}&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;span&lt;span class=&quot;ot&quot;&gt; class&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;spittleTime&quot;&lt;/span&gt;&amp;gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;c:out&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;${spittle.time}&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;运行即可得到正确结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;处理表单&quot;&gt;处理表单&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;Web&lt;/code&gt;应用需要通过表单与用户进行交互，需要展示表单数据和处理用户通过表单提交的数据。对于表单的展示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;添加&lt;code&gt;SpitterController&lt;/code&gt;如下&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package ch5;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import static org.springframework.web.bind.annotation.RequestMethod.*;&lt;/span&gt;


&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.annotation.Autowired;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.stereotype.Controller;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.ui.Model;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.bind.annotation.PathVariable;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.bind.annotation.RequestMapping;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@Controller&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/spitter&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SpitterController {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; SpitterRepository spitterRepository;

    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SpitterController&lt;/span&gt;(SpitterRepository spitterRepository) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;spitterRepository&lt;/span&gt; = spitterRepository;
    }

    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(value = &lt;span class=&quot;st&quot;&gt;&quot;/register&quot;&lt;/span&gt;, method = GET)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;showRegistrationForm&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;registerForm&quot;&lt;/span&gt;;
    }

    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(value = &lt;span class=&quot;st&quot;&gt;&quot;/register&quot;&lt;/span&gt;, method = POST)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;processRegistration&lt;/span&gt;(Spitter spitter) {
        spitterRepository.&lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;(spitter);

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;redirect:/spitter/&quot;&lt;/span&gt; + spitter.&lt;span class=&quot;fu&quot;&gt;getUsername&lt;/span&gt;();
    }

    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(value = &lt;span class=&quot;st&quot;&gt;&quot;/{username}&quot;&lt;/span&gt;, method = GET)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;showSpitterProfile&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;@PathVariable&lt;/span&gt; String username, Model model) {
        Spitter spitter = spitterRepository.&lt;span class=&quot;fu&quot;&gt;findByUsername&lt;/span&gt;(username);
        model.&lt;span class=&quot;fu&quot;&gt;addAttribute&lt;/span&gt;(spitter);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;profile&quot;&lt;/span&gt;;
    }
}

&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;添加&lt;code&gt;SpitterRepository&lt;/code&gt;如下&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package ch5;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; SpitterRepository {
    Spitter &lt;span class=&quot;fu&quot;&gt;findByUsername&lt;/span&gt;(String username);
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;(Spitter spitter);
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;添加&lt;code&gt;SpitterRepositoryImp&lt;/code&gt;，源码如下。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package ch5;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.springframework.stereotype.Component;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.util.*;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SpitterRepositoryImp &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; SpitterRepository {

    Map&amp;lt;String, Spitter&amp;gt; spitters = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;String, Spitter&amp;gt;();

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;(Spitter spitter) {
        spitters.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(spitter.&lt;span class=&quot;fu&quot;&gt;getUsername&lt;/span&gt;(), spitter);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Spitter &lt;span class=&quot;fu&quot;&gt;findByUsername&lt;/span&gt;(String username) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; spitters.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(username);
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;添加&lt;code&gt;registerForm.jsp&lt;/code&gt;文件，内容如下。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode jsp&quot;&gt;
&lt;code class=&quot;sourceCode jsp&quot;&gt;
&amp;lt;%@ taglib&lt;span class=&quot;ot&quot;&gt; uri&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;http://java.sun.com/jsp/jstl/core&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; prefix&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;%&amp;gt;
&amp;lt;%@ page&lt;span class=&quot;ot&quot;&gt; isELIgnored&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;%&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Spitter&amp;lt;/title&amp;gt;
    &amp;lt;link&lt;span class=&quot;ot&quot;&gt; rel&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;text/css&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;          href&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;c:url&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;/resources/style.css&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;Register&amp;lt;/h1&amp;gt;

    &amp;lt;form&lt;span class=&quot;ot&quot;&gt; method&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;POST&quot;&lt;/span&gt;&amp;gt;
      First Name: &amp;lt;input&lt;span class=&quot;ot&quot;&gt; type&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;firstName&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;/&amp;gt;&amp;lt;br/&amp;gt;
      Last Name: &amp;lt;input&lt;span class=&quot;ot&quot;&gt; type&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;lastName&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;/&amp;gt;&amp;lt;br/&amp;gt;
      Email: &amp;lt;input&lt;span class=&quot;ot&quot;&gt; type&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;email&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;email&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;/&amp;gt;&amp;lt;br/&amp;gt;
      Username: &amp;lt;input&lt;span class=&quot;ot&quot;&gt; type&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;username&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;/&amp;gt;&amp;lt;br/&amp;gt;
      Password: &amp;lt;input&lt;span class=&quot;ot&quot;&gt; type&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;/&amp;gt;&amp;lt;br/&amp;gt;
      &amp;lt;input&lt;span class=&quot;ot&quot;&gt; type&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;submit&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;Register&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;/&amp;gt;
    &amp;lt;/form&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;运行后，访问&lt;code&gt;http://localhost:8080/spitter/register&lt;/code&gt;即可正常显示表单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;处理表单控制器&quot;&gt;处理表单控制器&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;当成注册表单的&lt;code&gt;POST&lt;/code&gt;请求时，控制器需要接受表单数据并将表单数据保存为&lt;code&gt;Spitter&lt;/code&gt;对象，在注册完成后重定向至用户的基本信息页面，修改&lt;code&gt;SpitterController&lt;/code&gt;如下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package ch5;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import static org.springframework.web.bind.annotation.RequestMethod.*;&lt;/span&gt;


&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.annotation.Autowired;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.stereotype.Controller;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.ui.Model;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.bind.annotation.PathVariable;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.bind.annotation.RequestMapping;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@Controller&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/spitter&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SpitterController {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; SpitterRepository spitterRepository;

    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SpitterController&lt;/span&gt;(SpitterRepository spitterRepository) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;spitterRepository&lt;/span&gt; = spitterRepository;
    }

    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(value = &lt;span class=&quot;st&quot;&gt;&quot;/register&quot;&lt;/span&gt;, method = GET)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;showRegistrationForm&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;registerForm&quot;&lt;/span&gt;;
    }

    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(value = &lt;span class=&quot;st&quot;&gt;&quot;/register&quot;&lt;/span&gt;, method = POST)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;processRegistration&lt;/span&gt;(Spitter spitter) {
        spitterRepository.&lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;(spitter);

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;redirect:/spitter/&quot;&lt;/span&gt; + spitter.&lt;span class=&quot;fu&quot;&gt;getUsername&lt;/span&gt;();
    }

    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(value = &lt;span class=&quot;st&quot;&gt;&quot;/{username}&quot;&lt;/span&gt;, method = GET)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;showSpitterProfile&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;@PathVariable&lt;/span&gt; String username, Model model) {
        Spitter spitter = spitterRepository.&lt;span class=&quot;fu&quot;&gt;findByUsername&lt;/span&gt;(username);
        model.&lt;span class=&quot;fu&quot;&gt;addAttribute&lt;/span&gt;(spitter);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;profile&quot;&lt;/span&gt;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;添加&lt;code&gt;profile.jsp&lt;/code&gt;文件，内容如下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode jsp&quot;&gt;
&lt;code class=&quot;sourceCode jsp&quot;&gt;
&amp;lt;%@ taglib&lt;span class=&quot;ot&quot;&gt; uri&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;http://java.sun.com/jsp/jstl/core&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; prefix&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;%&amp;gt;
&amp;lt;%@ page&lt;span class=&quot;ot&quot;&gt; isELIgnored&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;%&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Spitter&amp;lt;/title&amp;gt;
    &amp;lt;link&lt;span class=&quot;ot&quot;&gt; rel&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;text/css&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;c:url&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;/resources/style.css&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Your Profile&amp;lt;/h1&amp;gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;c:out&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;${spitter.username}&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&amp;lt;br/&amp;gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;c:out&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;${spitter.firstName}&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;c:out&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;${spitter.lastName}&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&amp;lt;br/&amp;gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;c:out&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;${spitter.email}&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;运行后，访问&lt;code&gt;http://localhost:8080/spitter/register&lt;/code&gt;完成注册后会成功返回到用户信息页面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本篇博文讲解了&lt;code&gt;Spring Web&lt;/code&gt;相关的知识点，其核心是&lt;code&gt;DispatcherServlet&lt;/code&gt;来派发请求，借助框架，可以快速开发&lt;code&gt;Web&lt;/code&gt;应用。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 25 Oct 2017 12:56:00 +0000</pubDate>
<dc:creator>leesf</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leesf456/p/7732327.html</dc:identifier>
</item>
</channel>
</rss>