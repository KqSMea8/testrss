<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Mysql查询性能优化 - 将来-小志</title>
<link>http://www.cnblogs.com/will-xz/p/9972286.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/will-xz/p/9972286.html</guid>
<description>&lt;h3 id=&quot;慢查询优化基础优化数据访问&quot; data-source-line=&quot;4&quot;&gt;慢查询优化基础：优化数据访问&lt;/h3&gt;
&lt;ul data-source-line=&quot;6&quot;&gt;&lt;li&gt;查询需要的记录。查询100条，应用层仅需要10条。&lt;/li&gt;
&lt;li&gt;多表关联时返回全部列。*，多表关联，字段查询要加前缀。&lt;/li&gt;
&lt;li&gt;总是取出全部列。*&lt;/li&gt;
&lt;li&gt;重复查询相同的数据。例如：在用户评论的地方需要查询用户头像URL，那么用户多次评论的时候，可能就会反复查询这个数据。比较好的方案，当初次查询的时候将这个数据缓存起来，需要的时候从缓存中取出，这样性能显然会更好。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;重构查询方式&quot; data-source-line=&quot;12&quot;&gt;重构查询方式&lt;/h3&gt;
&lt;h4 id=&quot;切分查询&quot; data-source-line=&quot;14&quot;&gt;切分查询&lt;/h4&gt;
&lt;ul data-source-line=&quot;15&quot;&gt;&lt;li&gt;将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。如果一次性完成的话，则可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;分解关联查询&quot; data-source-line=&quot;17&quot;&gt;分解关联查询&lt;/h4&gt;
&lt;ul data-source-line=&quot;18&quot;&gt;&lt;li&gt;很多高性能的应用都会对关联查询进行分解。&lt;/li&gt;
&lt;li&gt;简单地，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。&lt;/li&gt;
&lt;/ul&gt;&lt;pre data-source-line=&quot;20&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from tag &lt;span class=&quot;hljs-keyword&quot;&gt;join tag_post &lt;span class=&quot;hljs-keyword&quot;&gt;on tag_post.id = tag.id &lt;span class=&quot;hljs-keyword&quot;&gt;join post &lt;span class=&quot;hljs-keyword&quot;&gt;on post.id = tag_post.id
&lt;span class=&quot;hljs-keyword&quot;&gt;where tag.tag = &lt;span class=&quot;hljs-string&quot;&gt;'msyql';

&lt;span class=&quot;zh-hans&quot;&gt;分解为：

&lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from tag &lt;span class=&quot;hljs-keyword&quot;&gt;from &lt;span class=&quot;hljs-keyword&quot;&gt;where tag = &lt;span class=&quot;hljs-string&quot;&gt;'msyql';
&lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from tag_post &lt;span class=&quot;hljs-keyword&quot;&gt;where &lt;span class=&quot;hljs-keyword&quot;&gt;id = &lt;span class=&quot;hljs-number&quot;&gt;1234;
&lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from post &lt;span class=&quot;hljs-keyword&quot;&gt;where &lt;span class=&quot;hljs-keyword&quot;&gt;id &lt;span class=&quot;hljs-keyword&quot;&gt;in (&lt;span class=&quot;hljs-number&quot;&gt;1,&lt;span class=&quot;hljs-number&quot;&gt;2,&lt;span class=&quot;hljs-number&quot;&gt;3);

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;优势&quot; data-source-line=&quot;31&quot;&gt;优势&lt;/h6&gt;
&lt;ul data-source-line=&quot;32&quot;&gt;&lt;li&gt;让缓存的效率更高。许多应用程序可以方便地缓存单表查询对应的结果对象。例如：上面查询中的tag已经被缓存了，那么应用就可以跳过第一个查询。再例如，应用中已经缓存了ID为1，2的内容，那么第三个查询的in（）中就可以少了几个ID，对MYSQL的查询缓存来说，如果关联中的某个表发生了变化，那么久无法使用查询缓存了，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了。&lt;/li&gt;
&lt;li&gt;将查询分解后，执行单个查询就可以减少锁的竞争。&lt;/li&gt;
&lt;li&gt;在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和高扩展。&lt;/li&gt;
&lt;li&gt;查询本身效率也可能会有所提升。使用IN（）代替关联查询，可以让MYSQL按照ID顺序进行查询，这可能比随机的关联要更搞笑。&lt;/li&gt;
&lt;li&gt;可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。从这点看，这样的重构还可能会减少网络和内存的消耗。&lt;/li&gt;
&lt;li&gt;更进一步，这样做相当于在应用中实现了哈希关联，而不是使用MYSQL的潜逃循环关联。某些场景哈希关联的效率要高很多。&lt;/li&gt;
&lt;li&gt;在很多场景下，通过重构查询将关联放到应用程序中将会更加高效，这样的场景有很多，比如：当应用能够方便地缓存单个查询的结果的时候，当可以将数据分布到不同的MYSQL服务器上的时候，当能够使用IN的方式代替关联查询的时候、当查询中使用同一个数据表的时候。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;查询执行基础&quot; data-source-line=&quot;41&quot;&gt;查询执行基础&lt;/h3&gt;
&lt;h3 id=&quot;mysql接收到请求都做了什么&quot; data-source-line=&quot;43&quot;&gt;MYSQL接收到请求都做了什么？&lt;/h3&gt;
&lt;ol data-source-line=&quot;44&quot;&gt;&lt;li&gt;客户端发送一条查询给服务器。&lt;/li&gt;
&lt;li&gt;服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。&lt;/li&gt;
&lt;li&gt;服务器进行SQL解析、预处理，再由优化器生成对应的执行计划。&lt;/li&gt;
&lt;li&gt;MYSQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。&lt;/li&gt;
&lt;li&gt;将结果返回给客户端。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;MYSQLk客户端/服务端通信协议&lt;/p&gt;
&lt;h5 id=&quot;mysql客户端和服务端之间的通信协议是半双工的这意味着在任何一个时刻要么是由服务器向客户端发送数据要么是由客户端向服务器发送数据这两个动作不能同时发生-一旦一端开始发送消息另一端要接收完整个消息才能响应它-这就像来回抛球的游戏在任何时刻只能一个人控制球而且只能空值求得人才能将球抛回去&quot; data-source-line=&quot;53&quot;&gt;MYSQL客户端和服务端之间的通信协议是“半双工”的，这意味着，在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。一旦一端开始发送消息，另一端要接收完整个消息才能响应它。这就像来回抛球的游戏：在任何时刻，只能一个人控制球，而且只能空值求得人才能将球抛回去。&lt;/h5&gt;
&lt;h5 id=&quot;客户端用一个单独的数据包将数据传给服务器这也是为什么当查询的语句很长的时候参数mac_allow_package就特别重要了-一旦客户端发送了请求它能做的事情就只能是等待结果了&quot; data-source-line=&quot;55&quot;&gt;客户端用一个单独的数据包将数据传给服务器，这也是为什么当查询的语句很长的时候，参数mac_allow_package就特别重要了。一旦客户端发送了请求，它能做的事情就只能是等待结果了。&lt;/h5&gt;
&lt;h5 id=&quot;相反的一般服务器响应给用户的数据通常很多由多个数据包组成-当服务器开始响应客户端请求时客户端必须完整地接收整个返回结果而不能简单地只取前面几条结果然后让服务器停止发送数据-这种情况下客户端若接收完成的结果然后取前面几条需要的结果或者接完几条结果后就粗暴地断开连接都不是好主意-这也是在必要的时候一定要在查询中加上limit限制的原因&quot; data-source-line=&quot;57&quot;&gt;相反的，一般服务器响应给用户的数据通常很多，由多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整地接收整个返回结果，而不能简单地只取前面几条结果，然后让服务器停止发送数据。这种情况下，客户端若接收完成的结果，然后取前面几条需要的结果，或者接完几条结果后就“粗暴”地断开连接，都不是好主意。这也是在必要的时候一定要在查询中加上LIMIT限制的原因。&lt;/h5&gt;
&lt;h4 id=&quot;查询状态&quot; data-source-line=&quot;59&quot;&gt;查询状态&lt;/h4&gt;
&lt;h6 id=&quot;对于一个mysql连接或者说一个线程任何时刻都有一个状态该状态表示了mysql当前正在做什么-有很多方式能查询当前状态最简单的是使用show-full-processlist命令-一个查询的生命周期中状态会变化很多次&quot; data-source-line=&quot;61&quot;&gt;对于一个MYSQL连接，或者说一个线程，任何时刻都有一个状态，该状态表示了MYSQL当前正在做什么。有很多方式能查询当前状态，最简单的是使用show full processlist命令。一个查询的生命周期中，状态会变化很多次。&lt;/h6&gt;
&lt;ul data-source-line=&quot;63&quot;&gt;&lt;li&gt;Sleep&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;线程正在等待客户端发送新的请求。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Query&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;线程正在执行查询或者正在将结果发送给客户端。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Locked&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;在MYSQL服务器层，该线程正在等待表锁。在存储引擎级别实现的锁。例如：Innodb的行锁，并不会体现在线程状态中。对于MyISAM来说这是一个比较典型的状态，但在其他没有行锁的引擎中也经常出现。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Analyzing and statistics&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;线程正在收集存储引擎的统计信息，并生成查询执行计划。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Copying to tmp table [on disk]&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;线程正在执行查询，并且将其结果集都复制到一个临时表中，这种状态一般要么在做Group By操作，要么是文件排序操作，或者是UNION操作。如果这个状态后面还有“on disk”标记，那表示MYSQL正在讲一个内存临时表放到磁盘上。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Sorting result&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;线程正在对结果集进行排序。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Sending data&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;这表示多种情况：线程可能在多个状态之间传送数据，或者在生成结果集，或者在客户端返回数据。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote data-source-line=&quot;78&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;了解这些状态的基本含义非常有用，这可以让你很好地了解当前“谁正在持球”。在一个繁忙的服务器上，可能会看到大量的不正常状态，例如statistics正占用大量的时间。这通常表示，某个地方有异常了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;查询优化&quot; data-source-line=&quot;81&quot;&gt;查询优化&lt;/h3&gt;
&lt;h4 id=&quot;mysql如何执行关联查询&quot; data-source-line=&quot;83&quot;&gt;MYSQL如何执行关联查询&lt;/h4&gt;
&lt;h5 id=&quot;对于union查询mysql先将一系列的单个查询结果放到一个临时表中然后再重新读取临时表数据来完成union查询&quot; data-source-line=&quot;85&quot;&gt;对于UNION查询，MYSQL先将一系列的单个查询结果放到一个临时表中，然后再重新读取临时表数据来完成UNION查询。&lt;/h5&gt;
&lt;blockquote data-source-line=&quot;87&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;在MYSQL的概念中，每个查询都是一次关联，所以读取结果临时表也是一次关联。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote data-source-line=&quot;89&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;当前MYSQL关联执行的策略很简单：MYSQL对任何关联都执行嵌套循环关联操作，即MYSQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，知道找到所有表中匹配的行为止。然后根据各个表匹配的行，返回查询中需要的各个列。MYSQL会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行以后，MYSQL返回到上一层次关联表，看是否能够找到更多匹配记录，一次类推迭代执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre data-source-line=&quot;91&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;zh-hans&quot;&gt;简单的内连接查询：

&lt;span class=&quot;hljs-keyword&quot;&gt;select tab1.col1, tab2.col2 &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 inner &lt;span class=&quot;hljs-keyword&quot;&gt;join tab2 &lt;span class=&quot;hljs-keyword&quot;&gt;using(col3) &lt;span class=&quot;hljs-keyword&quot;&gt;where tab1.col1 &lt;span class=&quot;hljs-keyword&quot;&gt;in (&lt;span class=&quot;hljs-number&quot;&gt;1,&lt;span class=&quot;hljs-number&quot;&gt;2);

&lt;span class=&quot;zh-hans&quot;&gt;实际执行的伪代码表示：

outer_iter = iterator over tabl1 &lt;span class=&quot;hljs-keyword&quot;&gt;where col1 &lt;span class=&quot;hljs-keyword&quot;&gt;in (&lt;span class=&quot;hljs-number&quot;&gt;1,&lt;span class=&quot;hljs-number&quot;&gt;2)
outer_row = outer_iter.&lt;span class=&quot;hljs-keyword&quot;&gt;next
&lt;span class=&quot;hljs-keyword&quot;&gt;while outer_row
    inner_iter = iterator over tab2 &lt;span class=&quot;hljs-keyword&quot;&gt;where col3 = outer_row.col3
    inner_row = inner_iter.&lt;span class=&quot;hljs-keyword&quot;&gt;next
    &lt;span class=&quot;hljs-keyword&quot;&gt;while inner_row
        output [ outer_row.col1, inner_row.col2]
        inner_row = inner_iter.&lt;span class=&quot;hljs-keyword&quot;&gt;next
    &lt;span class=&quot;hljs-keyword&quot;&gt;end
    outer_row = outer_iter.&lt;span class=&quot;hljs-keyword&quot;&gt;next
&lt;span class=&quot;hljs-keyword&quot;&gt;end

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre data-source-line=&quot;114&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;zh-hans&quot;&gt;简单的外连接查询：

&lt;span class=&quot;hljs-keyword&quot;&gt;select tab1.col1, tab2.col2 &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 outer &lt;span class=&quot;hljs-keyword&quot;&gt;join tab2 &lt;span class=&quot;hljs-keyword&quot;&gt;using(col3) &lt;span class=&quot;hljs-keyword&quot;&gt;where tab1.col1 &lt;span class=&quot;hljs-keyword&quot;&gt;in (&lt;span class=&quot;hljs-number&quot;&gt;1,&lt;span class=&quot;hljs-number&quot;&gt;2);

&lt;span class=&quot;zh-hans&quot;&gt;实际执行的伪代码表示：

outer_iter = iterator over tabl1 &lt;span class=&quot;hljs-keyword&quot;&gt;where col1 &lt;span class=&quot;hljs-keyword&quot;&gt;in (&lt;span class=&quot;hljs-number&quot;&gt;1,&lt;span class=&quot;hljs-number&quot;&gt;2)
outer_row = outer_iter.&lt;span class=&quot;hljs-keyword&quot;&gt;next
&lt;span class=&quot;hljs-keyword&quot;&gt;while outer_row
    inner_iter = iterator over tab2 &lt;span class=&quot;hljs-keyword&quot;&gt;where col3 = outer_row.col3
    inner_row = inner_iter.&lt;span class=&quot;hljs-keyword&quot;&gt;next
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;if inner_row
    
        &lt;span class=&quot;hljs-keyword&quot;&gt;while inner_row
            output [ outer_row.col1, inner_row.col2]
            inner_row = inner_iter.&lt;span class=&quot;hljs-keyword&quot;&gt;next
        &lt;span class=&quot;hljs-keyword&quot;&gt;end
        
    &lt;span class=&quot;hljs-keyword&quot;&gt;else
        
        output [ outer_row.col, null ]
    &lt;span class=&quot;hljs-keyword&quot;&gt;end
    outer_row = outer_iter.&lt;span class=&quot;hljs-keyword&quot;&gt;next
&lt;span class=&quot;hljs-keyword&quot;&gt;end

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote data-source-line=&quot;144&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;MYSQL的临时表是没有任何索引的，在编写复杂的子查询和关联查询的时候需要注意这一点。这一点对UNION查询也是一样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;关联子查询&quot; data-source-line=&quot;146&quot;&gt;关联子查询&lt;/h3&gt;
&lt;h5 id=&quot;mysql的子查询实现得非常糟糕-最糟糕的一类查询是where条件中包含in的子查询语句&quot; data-source-line=&quot;148&quot;&gt;MYSQL的子查询实现得非常糟糕。最糟糕的一类查询是where条件中包含IN（）的子查询语句。&lt;/h5&gt;
&lt;pre data-source-line=&quot;150&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 &lt;span class=&quot;hljs-keyword&quot;&gt;where col1 &lt;span class=&quot;hljs-keyword&quot;&gt;in (
    &lt;span class=&quot;hljs-keyword&quot;&gt;select col2 &lt;span class=&quot;hljs-keyword&quot;&gt;from tab2 &lt;span class=&quot;hljs-keyword&quot;&gt;where col3 = &lt;span class=&quot;hljs-number&quot;&gt;1;
)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;mysql对in列表中的-选项有专门的优化策略一般会认为mysql会先执行子查询返回所有包含col3为1的col2-一般来说in列查询速度很快所以我们会认为上面的查询会这样执行&quot; data-source-line=&quot;159&quot;&gt;MYSQL对IN（）列表中的 选项有专门的优化策略，一般会认为MYSQL会先执行子查询返回所有包含col3为1的col2。一般来说，IN（）列查询速度很快，所以我们会认为上面的查询会这样执行：&lt;/h5&gt;
&lt;pre data-source-line=&quot;161&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;- &lt;span class=&quot;hljs-keyword&quot;&gt;SELECT &lt;span class=&quot;hljs-keyword&quot;&gt;GROUP_CONCAT(col2) &lt;span class=&quot;hljs-keyword&quot;&gt;from tab2 &lt;span class=&quot;hljs-keyword&quot;&gt;where col3 = &lt;span class=&quot;hljs-number&quot;&gt;1;
- Reuslt : 1,2,3,4,

&lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from tabl1 &lt;span class=&quot;hljs-keyword&quot;&gt;where col1 &lt;span class=&quot;hljs-keyword&quot;&gt;in (&lt;span class=&quot;hljs-number&quot;&gt;1,&lt;span class=&quot;hljs-number&quot;&gt;2,&lt;span class=&quot;hljs-number&quot;&gt;3,&lt;span class=&quot;hljs-number&quot;&gt;4);

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;很不幸mysql不是这样做的-mysql会将相关的外层表压到子查询中它认为这样可以更高效率地查找到数据行-也就是说mysql会将查询改成下面的这样&quot; data-source-line=&quot;169&quot;&gt;很不幸，MYSQL不是这样做的。MYSQL会将相关的外层表压到子查询中，它认为这样可以更高效率地查找到数据行。也就是说，MYSQL会将查询改成下面的这样：&lt;/h5&gt;
&lt;pre data-source-line=&quot;171&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 
&lt;span class=&quot;hljs-keyword&quot;&gt;where &lt;span class=&quot;hljs-keyword&quot;&gt;exists (
    &lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from tab2 &lt;span class=&quot;hljs-keyword&quot;&gt;where col3 = &lt;span class=&quot;hljs-number&quot;&gt;1
    &lt;span class=&quot;hljs-keyword&quot;&gt;and tab1.col1 = tab2.col1
);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;这时子查询需要根据col1来关联外部表的film因为需要到col1字段所以mysql认为无法先执行这个子查询&quot; data-source-line=&quot;181&quot;&gt;这时，子查询需要根据col1来关联外部表的film，因为需要到col1字段，所以MYSQL认为无法先执行这个子查询。&lt;/h5&gt;
&lt;h5 id=&quot;如果tab1表数据量小性能还不是很糟糕如果是一个非常大的表那这个查询性能会非常糟糕-改写这个子查询&quot; data-source-line=&quot;183&quot;&gt;如果tab1表数据量小，性能还不是很糟糕，如果是一个非常大的表，那这个查询性能会非常糟糕。改写这个子查询&lt;/h5&gt;
&lt;pre data-source-line=&quot;185&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 &lt;span class=&quot;hljs-keyword&quot;&gt;inner &lt;span class=&quot;hljs-keyword&quot;&gt;join tab2 &lt;span class=&quot;hljs-keyword&quot;&gt;using(col1) &lt;span class=&quot;hljs-keyword&quot;&gt;where col3 = &lt;span class=&quot;hljs-number&quot;&gt;1;

&amp;amp;&amp;amp;

&lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 
&lt;span class=&quot;hljs-keyword&quot;&gt;where &lt;span class=&quot;hljs-keyword&quot;&gt;exists (
    &lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from tab2 &lt;span class=&quot;hljs-keyword&quot;&gt;where col3 = &lt;span class=&quot;hljs-number&quot;&gt;1 
    &lt;span class=&quot;hljs-keyword&quot;&gt;and tab1.col1 = tab2.col1
);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;一旦使用了distinct和group-by在查询执行的过程中通常产生临时中间表-可以使用exists子查询优化&quot; data-source-line=&quot;199&quot;&gt;一旦使用了DISTINCT和GROUP by，在查询执行的过程中，通常产生临时中间表。可以使用EXISTS子查询优化&lt;/h5&gt;
&lt;h4 id=&quot;union的限制&quot; data-source-line=&quot;201&quot;&gt;UNION的限制&lt;/h4&gt;
&lt;h5 id=&quot;通过将两个表查询结果集合并取前20条&quot; data-source-line=&quot;203&quot;&gt;通过将两个表查询结果集合并取前20条&lt;/h5&gt;
&lt;pre data-source-line=&quot;205&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;select *from tab1 order by col1) &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;union &lt;span class=&quot;hljs-title&quot;&gt;all (&lt;span class=&quot;hljs-title&quot;&gt;select * &lt;span class=&quot;hljs-title&quot;&gt;from &lt;span class=&quot;hljs-title&quot;&gt;tab2 &lt;span class=&quot;hljs-title&quot;&gt;order &lt;span class=&quot;hljs-title&quot;&gt;by &lt;span class=&quot;hljs-title&quot;&gt;col2) &lt;span class=&quot;hljs-title&quot;&gt;limit 20;

&lt;span class=&quot;zh-hans&quot;&gt;优化为:

(&lt;span class=&quot;hljs-keyword&quot;&gt;select *from tab1 order by col1 limit &lt;span class=&quot;hljs-number&quot;&gt;20) &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;union &lt;span class=&quot;hljs-title&quot;&gt;all (&lt;span class=&quot;hljs-title&quot;&gt;select * &lt;span class=&quot;hljs-title&quot;&gt;from &lt;span class=&quot;hljs-title&quot;&gt;tab2 &lt;span class=&quot;hljs-title&quot;&gt;order &lt;span class=&quot;hljs-title&quot;&gt;by &lt;span class=&quot;hljs-title&quot;&gt;limit 20)

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote data-source-line=&quot;214&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;UNION 临时表的数据会大大减少&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 data-source-line=&quot;217&quot;&gt; &lt;/h3&gt;
&lt;h3 data-source-line=&quot;217&quot;&gt;优化COUNT()查询&lt;/h3&gt;
&lt;h5 id=&quot;count是一个特殊的函数有两种非常不同的作用它可以统计某个列的数量也可以统计行数-在统计列值时要求列值是非空的不统计null-如果在count的括号中指定了列或者列的表达式则统计的就是这个表达式有值的结果数&quot; data-source-line=&quot;219&quot;&gt;Count()是一个特殊的函数，有两种非常不同的作用：它可以统计某个列的数量，也可以统计行数。在统计列值时要求列值是非空的（不统计NULL）。如果在COUNT()的括号中指定了列或者列的表达式，则统计的就是这个表达式有值的结果数。&lt;/h5&gt;
&lt;h5 id=&quot;count的另外一个作用是统计结果集的行数-当mysql确定括号内的表达式值不可能为空时实际上就是在统计行数-最简单的就是count&quot; data-source-line=&quot;221&quot;&gt;Count()的另外一个作用是统计结果集的行数。当MYSQL确定括号内的表达式值不可能为空时，实际上就是在统计行数。最简单的就是COUNT(*)。&lt;/h5&gt;
&lt;h5 id=&quot;简单的优化&quot; data-source-line=&quot;223&quot;&gt;简单的优化&lt;/h5&gt;
&lt;pre data-source-line=&quot;225&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select &lt;span class=&quot;hljs-keyword&quot;&gt;count(*) &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 &lt;span class=&quot;hljs-keyword&quot;&gt;where &lt;span class=&quot;hljs-keyword&quot;&gt;col &amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;5;

&lt;span class=&quot;zh-hans&quot;&gt;优化为:

&lt;span class=&quot;hljs-keyword&quot;&gt;select (&lt;span class=&quot;hljs-keyword&quot;&gt;select &lt;span class=&quot;hljs-keyword&quot;&gt;count(*) &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 ) - &lt;span class=&quot;hljs-keyword&quot;&gt;count(*) &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 &lt;span class=&quot;hljs-keyword&quot;&gt;where &lt;span class=&quot;hljs-keyword&quot;&gt;col &amp;lt;&lt;span class=&quot;hljs-number&quot;&gt;5;

&lt;span class=&quot;zh-hans&quot;&gt;扫描的数量会减少很多

&lt;span class=&quot;zh-hans&quot;&gt;子查询也会当成常数，使用expand&lt;span class=&quot;zh-hans&quot;&gt;可知

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;情景在同一个查询中统计一个列的不同值的数量以减少查询的语句量&quot; data-source-line=&quot;239&quot;&gt;情景：在同一个查询中统计一个列的不同值的数量，以减少查询的语句量&lt;/h5&gt;
&lt;pre data-source-line=&quot;241&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;select &lt;span class=&quot;hljs-built_in&quot;&gt;sum(&lt;span class=&quot;hljs-keyword&quot;&gt;if(color = blue), &lt;span class=&quot;hljs-number&quot;&gt;1, &lt;span class=&quot;hljs-number&quot;&gt;0) &lt;span class=&quot;hljs-keyword&quot;&gt;as blue , &lt;span class=&quot;hljs-built_in&quot;&gt;sum(&lt;span class=&quot;hljs-keyword&quot;&gt;if(color = red), &lt;span class=&quot;hljs-number&quot;&gt;1, &lt;span class=&quot;hljs-number&quot;&gt;0) &lt;span class=&quot;hljs-keyword&quot;&gt;as red &lt;span class=&quot;hljs-keyword&quot;&gt;from items ;

&lt;span class=&quot;zh-hans&quot;&gt;同样也可以使用Count

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;优化关联查询&quot; data-source-line=&quot;249&quot;&gt;优化关联查询&lt;/h3&gt;
&lt;ul data-source-line=&quot;251&quot;&gt;&lt;li&gt;确保ON或者USING子句中的列有索引。&lt;/li&gt;
&lt;li&gt;确保任何group by和order by只涉及到一个表中的列。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;优化limit分页&quot; data-source-line=&quot;254&quot;&gt;优化LIMIT分页&lt;/h3&gt;
&lt;pre data-source-line=&quot;256&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select col1, col2 &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 &lt;span class=&quot;hljs-keyword&quot;&gt;order &lt;span class=&quot;hljs-keyword&quot;&gt;by col3 &lt;span class=&quot;hljs-keyword&quot;&gt;limit &lt;span class=&quot;hljs-number&quot;&gt;50,&lt;span class=&quot;hljs-number&quot;&gt;5;

&lt;span class=&quot;zh-hans&quot;&gt;改写成：

&lt;span class=&quot;hljs-keyword&quot;&gt;select col1, col2 &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 &lt;span class=&quot;hljs-keyword&quot;&gt;inner &lt;span class=&quot;hljs-keyword&quot;&gt;join (
    &lt;span class=&quot;hljs-keyword&quot;&gt;select col1 &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 &lt;span class=&quot;hljs-keyword&quot;&gt;order &lt;span class=&quot;hljs-keyword&quot;&gt;by col3 &lt;span class=&quot;hljs-keyword&quot;&gt;limit &lt;span class=&quot;hljs-number&quot;&gt;50,&lt;span class=&quot;hljs-number&quot;&gt;5
) &lt;span class=&quot;hljs-keyword&quot;&gt;as lim &lt;span class=&quot;hljs-keyword&quot;&gt;using(col1);

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul data-source-line=&quot;267&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;这里的“延迟关联”将大大提升查询效率，它让MYSQL扫描尽可能少的页面，获取需要访问的记录后再根据关联列回原表查询需要的所有列。这个技术可以优化LIMIT查询。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;有时候也可以将LIMIT查询转换为已知位置的查询，让MYSQL通过范围扫描获得到对应的结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre data-source-line=&quot;271&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;select col1, col2 &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 &lt;span class=&quot;hljs-keyword&quot;&gt;where col1 &lt;span class=&quot;hljs-keyword&quot;&gt;between &lt;span class=&quot;hljs-number&quot;&gt;30 &lt;span class=&quot;hljs-keyword&quot;&gt;and &lt;span class=&quot;hljs-number&quot;&gt;50;

&lt;span class=&quot;hljs-keyword&quot;&gt;select col1, col2 &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 &lt;span class=&quot;hljs-keyword&quot;&gt;where col1 &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;500 &lt;span class=&quot;hljs-keyword&quot;&gt;order &lt;span class=&quot;hljs-keyword&quot;&gt;by col1 &lt;span class=&quot;hljs-keyword&quot;&gt;limit &lt;span class=&quot;hljs-number&quot;&gt;20;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;hljs&quot;&gt; &lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 16 Nov 2018 15:20:00 +0000</pubDate>
<dc:creator>将来-小志</dc:creator>
<og:description>Mysql查询性能优化 慢查询优化基础：优化数据访问 查询需要的记录。查询100条，应用层仅需要10条。 多表关联时返回全部列。*，多表关联，字段查询要加前缀。 总是取出全部列。* 重复查询相同的数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/will-xz/p/9972286.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core中使用GraphQL - 最终章  Data Loader - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/9972233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/9972233.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201811/65831-20181116225913505-148847985.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core中使用GraphQL - 目录&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;在之前的几章中，我们的&lt;code&gt;GraphQL&lt;/code&gt;查询是没有优化过的。下面我们以&lt;code&gt;CustomerType&lt;/code&gt;中的&lt;code&gt;orders&lt;/code&gt;查询为例&lt;/p&gt;
&lt;h5 id=&quot;customertype.cs&quot;&gt;&lt;em&gt;CustomerType.cs&lt;/em&gt;&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Field&amp;lt;ListGraphType&amp;lt;OrderType&amp;gt;, IEnumerable&amp;lt;Order&amp;gt;&amp;gt;()  
    .Name(&quot;Orders&quot;)
    .ResolveAsync(ctx =&amp;gt;
    {
        return dataStore.GetOrdersAsync();
    }); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个查询中，我们获取了某个顾客中所有的订单， 这里如果你只是获取一些标量字段，那很简单。&lt;/p&gt;
&lt;p&gt;但是如果需要获取一些关联属性呢？例如查询系统中的所有订单，在订单信息中附带顾客信息。&lt;/p&gt;
&lt;h5 id=&quot;ordertype&quot;&gt;&lt;em&gt;OrderType&lt;/em&gt;&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public OrderType(IDataStore dataStore, IDataLoaderContextAccessor accessor)  
{
    Field(o =&amp;gt; o.Tag);
    Field(o =&amp;gt; o.CreatedAt);
    Field&amp;lt;CustomerType, Customer&amp;gt;()
        .Name(&quot;Customer&quot;)
        .ResolveAsync(ctx =&amp;gt;
        {            
            return dataStore.GetCustomerByIdAsync(ctx.Source.CustomerId);  
        });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里当获取&lt;code&gt;customer&lt;/code&gt;信息的时候，系统会另外初始化一个请求，以便从数据仓储中查询订单相关的顾客信息。&lt;/p&gt;
&lt;p&gt;如果你了解&lt;code&gt;dotnet cli&lt;/code&gt;, 你可以针对以下查询，在控制台输出所有的EF查询日志&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  orders{
    tag
    createdAt
    customer{
      name
      billingAddress
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询结果：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;data&quot;: {
    &quot;orders&quot;: [
      {
        &quot;tag&quot;: &quot;XPS 13&quot;,
        &quot;createdAt&quot;: &quot;2018-11-11&quot;,
        &quot;customer&quot;: {
          &quot;name&quot;: &quot;Lamond Lu&quot;,
          &quot;billingAddress&quot;: &quot;Test Address&quot;
        }
      },
      {
        &quot;tag&quot;: &quot;XPS 15&quot;,
        &quot;createdAt&quot;: &quot;2018-11-11&quot;,
        &quot;customer&quot;: {
          &quot;name&quot;: &quot;Lamond Lu&quot;,
          &quot;billingAddress&quot;: &quot;Test Address&quot;
        }
      }
    ]
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;产生日志如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (16ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [o].[OrderId], [o].[CreatedAt], [o].[CustomerId], [o].[CustomerId1], [o].[Tag]
      FROM [Orders] AS [o]
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (6ms) [Parameters=[@__get_Item_0='?' (DbType = Int32)], CommandType='Text', CommandTimeout='30']
      
      SELECT TOP(1) [e].[CustomerId], [e].[BillingAddress], [e].[Name]
      FROM [Customers] AS [e]
      WHERE [e].[CustomerId] = @__get_Item_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (5ms) [Parameters=[@__get_Item_0='?' (DbType = Int32)], CommandType='Text', CommandTimeout='30']
      
      SELECT TOP(1) [e].[CustomerId], [e].[BillingAddress], [e].[Name]
      FROM [Customers] AS [e]
      WHERE [e].[CustomerId] = @__get_Item_0
info: Microsoft.AspNetCore.Hosting.Internal.WebHost[2]
      Request finished in 864.2749ms 200&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从日志上我们很清楚的看到，这个查询使用了3个查询语句，第一个语句查询所有的订单信息，第二个和第三个请求分别查询了2个订单的顾客信息。这里可以想象如果这里有N的订单，就会产生N+1个查询语句，这是非常不效率的。正常情况下我们其实可以通过2条语句就完成上述的查询，后面查询单个顾客信息其实可以整合成一条语句。&lt;/p&gt;
&lt;p&gt;为了实现这个效果，我们就需要介绍一下&lt;code&gt;GraphQL&lt;/code&gt;中的&lt;code&gt;DataLoader&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DataLoader&lt;/code&gt;是&lt;code&gt;GraphQL&lt;/code&gt;中的一个重要功能，它为&lt;code&gt;GraphtQL&lt;/code&gt;查询提供了批处理和缓存的功能。&lt;/p&gt;
&lt;p&gt;为了使用&lt;code&gt;DataLoader&lt;/code&gt;, 我们首先需要在&lt;code&gt;Startup.cs&lt;/code&gt;中注册2个新服务&lt;code&gt;IDataLoaderContextAccessor&lt;/code&gt; 和&lt;code&gt;DataLoaderDocumentListener&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;startup.cs&quot;&gt;&lt;em&gt;Startup.cs&lt;/em&gt;&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;services.AddSingleton&amp;lt;IDataLoaderContextAccessor, DataLoaderContextAccessor&amp;gt;();  
services.AddSingleton&amp;lt;DataLoaderDocumentListener&amp;gt;();  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你的某个&lt;code&gt;GraphQL&lt;/code&gt;类型需要&lt;code&gt;DataLoader&lt;/code&gt;, 你就可以在其构造函数中注入一个&lt;code&gt;IDataLoaderContextAccessor&lt;/code&gt;接口对象。&lt;/p&gt;
&lt;p&gt;但是为了使用&lt;code&gt;DataLoader&lt;/code&gt;, 我们还需要将它添加到我们的中间件中。&lt;/p&gt;
&lt;h5 id=&quot;graphqlmiddleware.cs&quot;&gt;&lt;em&gt;GraphQLMiddleware.cs&lt;/em&gt;&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async Task InvokeAsync(HttpContext httpContext, ISchema schema, IServiceProvider serviceProvider)  
{
    ....
    ....
        
    var result = await _executor.ExecuteAsync(doc =&amp;gt;
    {
        ....
        ....
        doc.Listeners.Add(serviceProvider                                                             .GetRequiredService&amp;lt;DataLoaderDocumentListener&amp;gt;());
    }).ConfigureAwait(false);

    ....
    ....            
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下一步，我们需要为我们的仓储类，添加一个新方法，这个方法可以根据顾客的id列表，返回所有的顾客信息。&lt;/p&gt;
&lt;h5 id=&quot;datastore.cs&quot;&gt;&lt;em&gt;DataStore.cs&lt;/em&gt;&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async Task&amp;lt;Dictionary&amp;lt;int, Customer&amp;gt;&amp;gt; GetCustomersByIdAsync(
    IEnumerable&amp;lt;int&amp;gt; customerIds,
    CancellationToken token)  
{
    return await _context.Customers
        .Where(i =&amp;gt; customerIds.Contains(i.CustomerId))
        .ToDictionaryAsync(x =&amp;gt; x.CustomerId);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们修改&lt;code&gt;OrderType&lt;/code&gt;类&lt;/p&gt;
&lt;h5 id=&quot;ordertype-1&quot;&gt;&lt;em&gt;OrderType&lt;/em&gt;&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Field&amp;lt;CustomerType, Customer&amp;gt;()  
    .Name(&quot;Customer&quot;)
    .ResolveAsync(ctx =&amp;gt;
    {            
        var customersLoader = accessor.Context.GetOrAddBatchLoader&amp;lt;int, Customer&amp;gt;(&quot;GetCustomersById&quot;, dataStore.GetCustomersByIdAsync);
        return customersLoader.LoadAsync(ctx.Source.CustomerId);  
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成以上修改之后，我们重新运行项目, 使用相同的&lt;code&gt;query&lt;/code&gt;, 结果如下，查询语句的数量变成了2个，效率大大提高&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;info: Microsoft.EntityFrameworkCore.Infrastructure[10403]
      Entity Framework Core 2.1.4-rtm-31024 initialized 'ApplicationDbContext' using provider 'Microsoft.EntityFrameworkCore.SqlServer' with options: None
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (19ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [o].[OrderId], [o].[CreatedAt], [o].[CustomerId], [o].[CustomerId1], [o].[Tag]
      FROM [Orders] AS [o]
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (10ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [i].[CustomerId], [i].[BillingAddress], [i].[Name]
      FROM [Customers] AS [i]
      WHERE [i].[CustomerId] IN (1)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;code&gt;DataLoader&lt;/code&gt;背后的原理&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GetOrAddBatchLoader&lt;/code&gt;方法会等到所有查询的顾客id列表准备好之后才会执行，它会一次性把所有查询id的顾客信息都收集起来。 这种技术就叫做批处理，使用了这种技术之后，无论有多少个关联的顾客信息，系统都只会发出一次请求来获取所有数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lamondlu/GraphQL_Blogs/tree/master/Part%20X%E4%B9%AC&quot;&gt;本文源代码： https://github.com/lamondlu/GraphQL_Blogs/tree/master/Part%20X&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 16 Nov 2018 15:01:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>ASP.NET Core中使用GraphQL 目录</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/9972233.html</dc:identifier>
</item>
<item>
<title>网络操作系统第十四章习题： - ✨️梅花✨️🌙️</title>
<link>http://www.cnblogs.com/W452728/p/9972234.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/W452728/p/9972234.html</guid>
<description>&lt;p&gt;&amp;#13;
                                    &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;×&lt;/span&gt;&lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt;&lt;/button&gt;&amp;#13;
                                    &lt;h4 class=&quot;modal-title&quot;&gt;&amp;#13;
                                        请完成人机识别验证&amp;#13;
                                    &lt;/h4&gt;&amp;#13;
                                &lt;/p&gt;
                                &lt;div class=&quot;modal-body&quot; readability=&quot;33&quot;&gt;
                                    
                                    &lt;p&gt;&amp;#13;
                                        &lt;span id=&quot;geetestLoading&quot;&gt; 验证码组件加载中,请稍后...&lt;/span&gt;&amp;#13;
                                    &lt;/p&gt;
                                &lt;/div&gt;
                            </description>
<pubDate>Fri, 16 Nov 2018 15:00:00 +0000</pubDate>
<dc:creator>✨️梅花✨️&amp;#127769;️</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://passport.cnblogs.com/user/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2FW452728%2Fp%2F9972234.html&amp;AspxAutoDetectCookieSupport=1</dc:identifier>
</item>
<item>
<title>深入java并发包源码(三)AQS独占方法源码分析 - zjmeow</title>
<link>http://www.cnblogs.com/stonymoon/p/9972202.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stonymoon/p/9972202.html</guid>
<description>[unable to retrieve full-text content]&quot;深入java并发包源码(一)简介&quot; &quot;深入java并发包源码(二)AQS的介绍与使用&quot; &quot;深入java并发包源码(三)AQS独占方法源码分析&quot; AQS 的实现原理 学完用 AQS 自定义一个锁以后，我们可以来看一下刚刚使用过的方法的实现。 分析源码的时候会省略一些不重要的代码。 AQS 的实现是基</description>
<pubDate>Fri, 16 Nov 2018 14:52:00 +0000</pubDate>
<dc:creator>zjmeow</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://passport.cnblogs.com/user/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2FW452728%2Fp%2F9972234.html&amp;AspxAutoDetectCookieSupport=1</dc:identifier>
</item>
<item>
<title>Python的GUI编程（TK） - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/9971974.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/9971974.html</guid>
<description>&lt;p&gt;TK在大多数 Unix平台、Windows平台和Macintosh系统都是预装好的，TKinter 模块是 Tk GUI 套件的标准Python接口。可实现Python的GUI编程。&lt;/p&gt;
&lt;p&gt;Tkinter模块(&quot;Tk 接口&quot;)是python的标准Tk GUI工具包的接口.Tk和Tkinter可以在大多数的Unix平台下使用,同样可以应用在Windows和Macintosh系统里.Tk8.0的后续版本可以实现本地窗口风格,并良好地运行在绝大多数平台中。（百度百科）&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;一般的环境里直接import tkinter即可使用，但Ubuntu里既然没有，所以要自己安装，因为笔者Ubuntu系统里默认有python2，python3是自己后来安装的，查阅资料得到结果是tkinter安装成功后，并没有和python3成功链接，需要重新安装python3才可以。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;安装：sudo apt-get install python-tk&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;安装：sudo apt install tk-dev&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;重新安装python3环境：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;进入python版本解压目录：cd python3.7&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;命令：./configure&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;命令：make&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;命令：sudo make install&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;显示图片需安装pillow库 :&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;指定版本安装：sudo pip3 install Pillow==4.3.0&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;下面先用一个小爬虫程序入门python的tkinter编程：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;效果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201811/1485202-20181116215233782-319594948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;程序：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; tkinter &lt;span&gt;import&lt;/span&gt; * 
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; tkinter &lt;span&gt;import&lt;/span&gt;&lt;span&gt; messagebox
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Image,ImageTk
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; re &lt;span&gt;#&lt;/span&gt;&lt;span&gt;正则表达式&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; butonck():
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;改变lab颜色&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     labelx[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取输入框值&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     textx=&lt;span&gt;entryx.get()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;去掉字符串前后空格&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     textx=&lt;span&gt;textx.strip()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; textx==&lt;span&gt;''&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;弹出提示框&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;       messagebox.showinfo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;东东提示&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入不可为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;字典数据&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;       datax=&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;word&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:textx,
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sizes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:60&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fonts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lfc.ttf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fontcolor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#000000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;       rx=requests.post(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.uustv.com/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,data=&lt;span&gt;datax)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;       rx.encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;       htmlx=rx.text &lt;span&gt;#&lt;/span&gt;&lt;span&gt;网站源码&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;       zz=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div class=&quot;tu&quot;&amp;gt;.*?&amp;lt;img src=&quot;(.*?)&quot;/&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;括号里的.*?表示要取的值&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;取图片地址&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;       imagex=&lt;span&gt;re.findall(zz,htmlx)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;取图片数据&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;       imagedatax=requests.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.uustv.com/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;imagex[0]).content
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;打开文件&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;       ff=open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{}.gif&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(textx),&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;写图片数据&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;      ff.write(imagedatax)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;       &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;       bmx=ImageTk.PhotoImage(file=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{}.gif&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(textx))
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;       lab2=Label(rview,image=&lt;span&gt;bmx)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;       lab2.bm=&lt;span&gt;bmx
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;       lab2.grid(row=2,columnspan=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建窗口&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; rview=&lt;span&gt;Tk()
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;标题&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; rview.title(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;东小东标题党&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;窗口大小 长高用小写x隔开&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;rview.geometry(&quot;600x300&quot;)&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;窗口基于屏幕的坐标 +x轴+y轴&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; rview.geometry(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+500+200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建lab标签&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt; labelx=Label(rview,text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;签名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,fg=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,font=(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宋体&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,30&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示lab标签 网格布局 sticky=W #左对齐 E为右对齐 默认为中间对齐&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; labelx.grid(row=0,column=&lt;span&gt;0)
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建输入框&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; entryx=Entry(rview,font=(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宋体&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,20&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示输入框&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt; entryx.grid(row=0,column=1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建按钮&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; buttonx=Button(rview,text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;确定&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,font=(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宋体&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,30),command=&lt;span&gt;butonck)
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示按钮&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt; buttonx.grid(row=1,column=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示后改变按钮属性&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;buttonx[&quot;width&quot;]=2&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;消息循环 显示窗口&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt; rview.mainloop()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;其他补充：&lt;/strong&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;em&gt;按钮标签：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;设置是否可点击buttonx.config(state=DISABLED)//不可按 NORMAL为正常&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;改变文字：buttonx[&quot;text&quot;]=&quot;改变文字&quot;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;&lt;strong&gt;Lab标签：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;改变文字内容：labx.config(text=&quot;改变文字&quot;)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;改变文字样式：labx.config(font=(&quot;xx&quot;,100,&quot;bold&quot;)) #字体，大小，加粗&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;&lt;strong&gt;grid为表格布局&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;lab2.grid(row=2,columnspan=2)#columnspan为跨列两行&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;sticky=“ew”#横向占满填充&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;&lt;strong&gt;其它属性：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;padx和pady=10 #设置边距&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;bg为背景色；fg为前景色&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;布局默认：将页面尺寸去掉，则自动根据内容大小动态包裹&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;鼠标移动到此次改变箭头样式：标签.config(cursor=&quot;gumby&quot;)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;对齐方式：anchor=W //W左E右&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;浮雕效果：relief=SUNKEN&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;&lt;strong&gt;pack布局：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;标签.pack()默认为上居中随窗口移动不变&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;标签.pack(fill=X)#横向大小填充，内容居中&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;标签.pack(fill=BOTH,expand=True)#纵向大小填充，内容居中&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;标签.pack(fill=BOTH,expand=True)#填充全部，内容居中&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;标签.pack(side=LEFT) #全部向左靠&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;em&gt;可绑定的事件：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;单击鼠标左键：&amp;lt;Button-1&amp;gt; #其中1为鼠标左键，2为鼠标右键，3为鼠标中键&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;左键移动：&amp;lt;B1-Motion&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;左键释放：&amp;lt;ButtonRelease-1&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;双击左键：&amp;lt;Double-Button-1&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;进入：&amp;lt;Enter&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;离开：&amp;lt;Leave&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;获得光标:&amp;lt;FocusIn&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;光标离开：&amp;lt;FoucusOut&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;回车键：&amp;lt;Return&amp;gt;(F1,F2,F3,Delete…)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;按任意键：&amp;lt;Key&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;em&gt;事件处理函数形参可用值：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;输出点击的坐标：event.x event.y        如：&amp;lt;Button-1&amp;gt;事件&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;输出键盘按键对应的符号：event.char     如：&amp;lt;Key&amp;gt;事件&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;&lt;strong&gt;获取鼠标点击坐标实现：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201811/1485202-20181116220533041-580301529.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;em&gt;关闭程序是出现弹出提示框：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201811/1485202-20181116220543495-2001510522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;hr/&gt;&lt;p align=&quot;left&quot;&gt;Python的tkinter参考：&lt;a href=&quot;http://effbot.org/tkinterbook/listbox.htm&quot;&gt;http://effbot.org/tkinterbook&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;教程参考：潭州教育&lt;/p&gt;

</description>
<pubDate>Fri, 16 Nov 2018 14:12:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>TK在大多数 Unix平台、Windows平台和Macintosh系统都是预装好的，TKinter 模块是 Tk GUI 套件的标准Python接口。可实现Python的GUI编程。 Tkinter模</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dongxiaodong/p/9971974.html</dc:identifier>
</item>
<item>
<title>javascript精雕细琢（四）：认亲大戏——通过console.log彻底搞清this - 阿克琉斯之踵</title>
<link>http://www.cnblogs.com/keepStudying/p/9971919.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/keepStudying/p/9971919.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;引言&lt;/h3&gt;
&lt;p&gt;       JS中的this指向一直是个老生常谈，但是新手又容易晕的地方。我在网上浏览了很多帖子，但是发现一个通病，也是博客的局限性——&lt;strong&gt;重理论说明，实践性低&lt;/strong&gt;。最多就是贴个代码或者图，增加可理解性。&lt;/p&gt;&lt;p&gt;       所以，我就想通过代码学习黄金法则——&lt;strong&gt;敲就完了&lt;/strong&gt;。以console.log，循序渐进，一步步的实践，来说明this的指向。而从我自身的理解角度来讲，这个方法效果还不错~&lt;/p&gt;&lt;p&gt;       那么，接下来我将从两个方面——&lt;strong&gt;普通函数&lt;/strong&gt;及&lt;strong&gt;箭头函数&lt;/strong&gt;两个方面来说明this指向。建议&lt;strong&gt;将所有代码copy下来，一步步打印，&lt;/strong&gt; 最终肯定能够理解this的指向。如果没理解，那么，再打印一遍~&lt;/p&gt;
&lt;h3 id=&quot;代码在前&quot;&gt;代码在前&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// function下的this基于执行环境的指定。简单理解就是函数前边挂谁，this就是谁，没有就是window。那么函数直接调用和匿名函数自执行由于前边什么都没有，就指向window。
// () =&amp;gt; {}箭头函数下的this基于作用域链查找确定，向上查找this，那个作用域里有this，就调用这个this。函数直接调用和箭头函数自执行仍旧会遵循查找原则。
       
//--------function下的this--------
//----首先是普通的函数声明
// function test() {
//   console.log(this);    
// }
// test(); // 打印window，因为没有指明执行环境，那么执行环境就是window
//
//----如果是闭包呢？
// function test() {
//   console.log(this);
//   const log = &quot;Lyu&quot;;
//   const fn = function() {
//     console.log(log); //打印Lyu
//     console.log(this); //打印window
// }
//   
// fn(); // 打印Lyu，window
// }
// test(); //window,Lyu,window。 首先调用test()，由于test()前什么都没挂，this就指向window。然后test函数内部，由于fn()前也什么都没有挂，this同样指向window。举这个例子是想证明，this并不会受函数额作用域及执行上下文影响，必须明确指定。
//
//----然后是匿名函数自执行？
// function test() {
//   (function(){
//     console.log(this); 
//   })()   
// }
// test(); //window，因为匿名函数自执行前边就不能挂其他玩意儿，所以它始终指向window
//
//----接下来看明确指定执行环境的例子
// const obj = {
//     fn: function() {
//         console.log(this);
//     }
// }
// obj.fn(); //打印obj，因为指定执行环境为obj的{}块级作用域内
//--如果改变一下调用方式呢？
// const fn = obj.fn; // 此时fn = function() { console.log(this) }，相当于创建了一个全局函数
// fn(); //打印window，因为没有指定执行环境
//
//----事件调用下的this
// document.onclick = function() {
//     console.log(this); //打印document，因为指定执行环境为document，即document在click时触发
// }
//这里相信大家都是明白的，就不再多赘述了
//----最后是通过call、apply、bind绑定下的this
//一句话说明，不再举例。前边说了，function下的this，通过指定执行环境来确定的，而call、apply、bind就是用来指定执行环境的，所以指谁，this就是谁。

//--------箭头函数下的this--------
//既然箭头函数下的this通过作用域链查找，那么作用域中如果没有声明this值，那么就向上查找
//----先说明this的创建与查找
// function Test() {
//     console.log(this);
// }
// Test(); // window，未指定作用环境，所以this指向window

// new Test(); //Test{}，此时，构造函数内Test()内的this被new声明，this指向构造函数创建的对象Test{},所以打印Test{}对象
//
//----接下来是箭头函数
// function Arrow() {
//     window.onmousewheel = () =&amp;gt; { 
//         console.log(this);
//     }
// }
// Arrow(); // window，直接调用时，Arrow()函数内并没有声明this，所以滚动鼠标，this会随作用域链查找。先在Arrow函数内，没找到this。然后一直向上，最终找到window。
//--然后我们new它一下子
// new Arrow(); //此时通过new，构造函数Arrow()内的this被声明，且指向对象Arrow{}，所以箭头函数在作用域链中查找时，在Arrow函数内就找到this为Arrow{}

//----接下来复杂一点，来个事件，顺便再加点匿名函数自执行
// function Go() {
//     //new一个this妈妈
//     window.onmousewheel = () =&amp;gt; { 
//         console.log(this); // 妈妈不见了！
//         (() =&amp;gt; {
//             console.log(this); // 妈妈去哪了？
//             (() =&amp;gt; {
//                 console.log(this); // 嘤嘤嘤，妈妈没了！
//                 (() =&amp;gt; {
//                     console.log(this); // 走啊哥几个，找妈妈去
//                 })();
//             })();
//         })();
//     }
// }
// Go(); //window，因为onmousewheel事件中及Go()函数中没有声明this，所以按照作用域链查找，找到window
//--然后我们再new它一下子
// new Go(); 
// 全部打印Go{}，因为new操作符，Go()函数中声明了this，且指向Go{}对象。而onmousewheel事件也用箭头函数指定，仍旧遵循查找原则。就这么一层一层的找，最后都找到Go函数作用域内的this，最后全部打印Go{}。这不就是小蝌蚪找妈妈嘛！

//----接下来换个搭配方式再看一下，普通function搭配箭头函数
// function GoOn() {
//     document.onclick = function() {
//         console.log(this);
                
//         (() =&amp;gt; {
//             console.log(this);
//         })();
//     }
// }
// GoOn(); 
// document、document，此时由于function中的this已经绑定到document，所以第一个打印document;
// 而由于箭头函数自执行仍旧遵循作用域链查找原则，不会指向window。所以箭头函数自执行后，根据作用域链向上查找this，找到document;
//--啥也别说了，就是new它丫的
// new GoOn() 
// document、document，此时就算new操作声明了this，但是是在click事件外的作用域中，箭头函数在click中已经找到了this，不会再向上查找;
//所以仍旧打印document，document;
// 
//----再看个混搭，然后我们结束搭配
// function Going() {
//     document.onclick = function() {
//         console.log(this);

//         (function() {
//           console.log(this);
//         })();
//
//         (() =&amp;gt; {
//           onsole.log(this);
//         })
//     }
// }
// Going(); 
// document、window、document，首先上来就指定了this为document，所以第一个打印document;
// 而function的匿名函数自执行会指向window，所以第二个打印window;
// 第三个箭头函数自执行，遵循作用域链查找原则，在onclick事件中找到this为document，所以打印document;
// --new、new、new
// new Going(); //规则不变，结果不变
//
//----好，混搭看完，接下来说个更有意思的。关于作用域的形成
//----JS的函数作用域及作用域链，是在函数创建时就被固定的
//----这么说确实不太直观，那么通过举例来说明
// function Test() {
//   console.log(this)
//   innerTest();
// }
// const innerTest = () =&amp;gt; { 
//   console.log(this); 
// }
// Test(); //window、window，如果不明白，把上边再看一遍
// new Test(); 
// Test{}、window，从这就可以看出端倪了。
// 为什么Test内的this指向Test{}对象了，而箭头函数中的this仍旧为window呢？innerTest函数在Test函数内执行，说好的按照作用域链查找呢？
// 请看文章中详细的解释
//
//----最后，call、apply、bind下的箭头函数
//一句话说明，箭头函数的this改不了，干啥都改不了，咋着都改不了，硬气！&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;function下的this&quot;&gt;1、function下的this&lt;/h3&gt;
&lt;p&gt;       我将从&lt;strong&gt;普通的函数声明&lt;/strong&gt;、&lt;strong&gt;匿名函数自执行&lt;/strong&gt;、&lt;strong&gt;对象声明&lt;/strong&gt;、&lt;strong&gt;事件绑定&lt;/strong&gt;、及&lt;strong&gt;call等方法绑定&lt;/strong&gt;来分别说明function下的this指向。&lt;/p&gt;&lt;p&gt;       function下的this理解起来也简单。我们就以&lt;strong&gt;亲爹&lt;/strong&gt;和&lt;strong&gt;干爹&lt;/strong&gt;来比喻：&lt;/p&gt;
&lt;p&gt;              假设&lt;strong&gt;window&lt;/strong&gt;是所有函数的&lt;strong&gt;干爹&lt;/strong&gt;。我们是公益组织，要给JS下的函数找到它们的&lt;strong&gt;亲爹&lt;/strong&gt;，而function声明的函数，都是渴望父爱的男孩;&lt;/p&gt;
&lt;p&gt;              确认亲爹的方式就是&lt;strong&gt;调用函数&lt;/strong&gt;的时候在它们前边加个 &lt;strong&gt;.(点)&lt;/strong&gt; 或者 &lt;strong&gt;[&quot;name&quot;]&lt;/strong&gt;，或者通过&lt;strong&gt;call、apply、bind&lt;/strong&gt;其他手段确认;&lt;/p&gt;
&lt;p&gt;              而那些调用时候，&lt;strong&gt;前边嘛也没有的&lt;/strong&gt;，他们亲爹没找到，那他们的&lt;strong&gt;干爹就当亲爹&lt;/strong&gt;来孝顺;&lt;/p&gt;
&lt;p&gt;       这场公益认爹，就是&lt;strong&gt;function的this&lt;/strong&gt;行为—&lt;strong&gt;函数前边有.(点)或者[&quot;name&quot;]，明确指定了亲爹的，this就是亲爹；直接调用的函数、匿名自执行的函数，这俩没找到亲爹的，this就是干爹window；而通过call、apply、bind其他渠道找到的亲爹，this同样是亲爹；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       下面详细说一下&lt;del&gt;这场认亲公益行，&lt;/del&gt; 各种情形下的this指向，&lt;strong&gt;一切以上边贴的代码为基础&lt;/strong&gt;！&lt;/p&gt;
&lt;h5 id=&quot;普通function声明&quot;&gt;1) 普通function声明&lt;/h5&gt;
&lt;p&gt;       最常用的函数声明无非是两种：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function test() {} 及 const test = function() {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;       这两种写法的区别在于声明方式的不同，进而影响&lt;strong&gt;变量提升&lt;/strong&gt;，并不会对this的指向产生影响。&lt;/p&gt;&lt;p&gt;       这两种声明方式下的function函数，在调用时，通常就是&lt;strong&gt;直接调用&lt;/strong&gt;。那么通过&lt;strong&gt;认爹&lt;/strong&gt;我们就能知道，这种情况下的&lt;strong&gt;this就是window&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function test() {
    console.log(this);    
}
test(); // 打印window，因为没有指明执行环境(没找到亲爹)，那么执行环境就是window(干爹)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;       为什么代码里我加上了&lt;strong&gt;闭包&lt;/strong&gt;的说明呢？主要是为了跟箭头函数做一个区分，证明一下，function下的this跟&lt;strong&gt;作用域以及作用域链&lt;/strong&gt;无关。同时跟它调用时的&lt;strong&gt;执行上下文&lt;/strong&gt;也无关，就是看函数前边有没有 &lt;strong&gt;.(点)——必须明确它的亲爹&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&quot;自执行匿名function声明函数&quot;&gt;2) 自执行匿名function声明函数&lt;/h5&gt;
&lt;p&gt;       与函数直接调用同理，不再赘述，匿名函数自执行就理解成&lt;strong&gt;父母双亡&lt;/strong&gt;，这货&lt;strong&gt;再也没有亲爹&lt;/strong&gt;了，所以它的&lt;strong&gt;this始终指向window&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&quot;对象下的function声明&quot;&gt;3) 对象下的function声明&lt;/h5&gt;
&lt;p&gt;       对象下声明的函数，在调用时是要通过对象方法访问的，所以~&lt;strong&gt;肯定有爹！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       但是这里边分了两种情况，一种情况是&lt;strong&gt;正常的通过对象调用方法&lt;/strong&gt;，另一种&lt;strong&gt;跟直接调用函数无异&lt;/strong&gt;~&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const obj = {
    fn: function() {
    console.log(this);
    }
}
obj.fn(); //打印obj，因为指定执行环境为obj的{}块级作用域内(亲爹为obj)

//如果改变一下调用方式呢？
const fn = obj.fn; // 此时fn = function() { console.log(this) }，相当于普通的function创建函数
fn(); //打印window，因为没有指定执行环境(没亲爹)&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;事件调用下的function声明&quot;&gt;4) 事件调用下的function声明&lt;/h5&gt;
&lt;p&gt;       事件的一般写法上，它必须要有 &lt;strong&gt;.(点)或者[name]&lt;/strong&gt;，所以它 &lt;strong&gt;肯定有亲爹&lt;/strong&gt;(最幸福的function函数)，那么.(点)前是谁，亲爹就是谁~&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;document.onclick = function() {
    console.log(this); //打印document，因为指定执行环境为document，即document在click时触发
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;callapplybind绑定&quot;&gt;5) call、apply、bind绑定&lt;/h5&gt;
&lt;p&gt;       一句话总结：&lt;strong&gt;给谁，谁就是亲爹！&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function test() {
    console.log(this.say);
};
const obj = {say: &quot;我是它爹&quot;};
const father = {say: &quot;我也是它爹&quot;};
const result = {say: &quot;我也是它爹，它到底几个爹&quot;};
test.apply(obj); // 我是他爹
test.call(father); // 我也是他爹
(test.bind(result))(); // 我也是它爹，他到底几个爹&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;箭头函数下的this&quot;&gt;2、箭头函数下的this&lt;/h3&gt;
&lt;p&gt;       首先，不明白箭头函数的，请先自行百度或者Google，不要还没开车就出车祸了;&lt;br/&gt;       然后，接下来我会从&lt;strong&gt;正常函数声明&lt;/strong&gt;的箭头函数、&lt;strong&gt;匿名函数自执行&lt;/strong&gt;的箭头函数、&lt;strong&gt;对象下声明&lt;/strong&gt;箭头函数、&lt;strong&gt;事件调用下&lt;/strong&gt;的箭头函数、&lt;strong&gt;function与箭头函数混合双打&lt;/strong&gt;、&lt;strong&gt;作用域链查找&lt;/strong&gt;、及&lt;strong&gt;call等方法绑定&lt;/strong&gt;来说明箭头函数下的this指向。&lt;/p&gt;
&lt;p&gt;       那么，同上，箭头函数也来个比喻，同样用&lt;strong&gt;亲爹&lt;/strong&gt;和&lt;strong&gt;干爹&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;              设定不变，&lt;strong&gt;window还是干爹&lt;/strong&gt;。但是也有一点不同——那就是箭头函数她是个拜金女，&lt;strong&gt;就爱找有钱(this)的干爹&lt;/strong&gt;;&lt;/p&gt;
&lt;p&gt;              而且吧，在拜金女眼里，&lt;strong&gt;window这个干爹是最穷的，所以不到走投无路，不找window这个干爹&lt;/strong&gt;。而&lt;strong&gt;对它的亲爹，有钱(this)才行&lt;/strong&gt;;&lt;/p&gt;
&lt;p&gt;              &lt;strong&gt;而this当然就是钱啦，谁有钱这箭头函数它就找谁！调用箭头函数就是找钱！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       所以啊，在这场发家致富之旅中，箭头函数中this的指向也是很明确的——&lt;strong&gt;如果当前作用域中，没有通过call、apply、bind、new等操作明确this的指向(没钱)，那么箭头函数将沿着作用域链(关系网)继续想上查找，直到找到明确的this(有钱的干爹)为止&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;正常声明的箭头函数&quot;&gt;1) 正常声明的箭头函数&lt;/h5&gt;
&lt;p&gt;       同function不同，对于箭头函数，只有一种声明方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const arrow = () =&amp;gt; {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以变换的地方就是&lt;strong&gt;参数和返回值部分的简写&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       同样的，这种声明方式下的函数，就是&lt;strong&gt;直接调用&lt;/strong&gt;。那么根据前边的比喻，箭头函数的认爹方式跟function是大不相同的。直接调用箭头函数时，这个拜金女就开始见钱眼开了——它先在&lt;strong&gt;当前作用域&lt;/strong&gt;中找，当前作用域下如果&lt;strong&gt;没有明确的this&lt;/strong&gt;(钱)，就继续&lt;strong&gt;沿着作用域链&lt;/strong&gt;往上找，&lt;strong&gt;直到找到this&lt;/strong&gt;为止，因为有&lt;strong&gt;window这个干爹保底，所以一点好处没捞到的时候，就找window&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function Arrow() {
    window.onmousewheel = () =&amp;gt; { 
        console.log(this);
    }
}
Arrow(); // window，直接调用时，Arrow()函数内并没有明确的this(没钱)，所以滚动鼠标，this会随作用域链查找(这个干爹不行，就再换个干爹)。先在Arrow函数内，没找到this。然后一直向上，最终找到window(只能保底)。

new Arrow(); //此时通过new，构造函数Arrow()内的this被声明(有钱了)，且指向对象Arrow{}，所以箭头函数在作用域链中查找时，在Arrow函数内就找到this为Arrow{}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;自执行匿名箭头函数&quot;&gt;2) 自执行匿名箭头函数&lt;/h5&gt;
&lt;p&gt;       箭头函数是个很有原则的拜金女，不管怎么执行它，它&lt;strong&gt;就认钱，就认钱，就认钱&lt;/strong&gt;(重要事情说3遍)，有钱才是爹。所以就算是自执行的匿名箭头函数，它仍旧遵循找爹原则，&lt;strong&gt;没钱免谈，我接着向上找&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;       所以，它仍旧先在&lt;strong&gt;当前作用域&lt;/strong&gt;中找，当前作用域下如果&lt;strong&gt;没有明确的this&lt;/strong&gt;(钱)，就继续&lt;strong&gt;沿着作用域链&lt;/strong&gt;往上找，&lt;strong&gt;直到找到this&lt;/strong&gt;为止。都没有，就找window。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function Test() {
    console.log(this);
    (() =&amp;gt; {
        console.log(this);
    })();
}
Test(); //window、window;
new Test(); //Test{}、Test{};
//规则同上，不再赘述&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;作为对象方法的箭头函数&quot;&gt;3) 作为对象方法的箭头函数&lt;/h5&gt;
&lt;p&gt;       按照function声明的逻辑，对象调用它下面的方法，this肯定是指向对象的。那么箭头函数是否也是如此呢？答案肯定是否定的，因为对象中并没有明确的this，而且对象还不能new，所以这就悲催了——&lt;strong&gt;箭头函数所存在的对象，永远不可能是它的干爹(只限于父女关系的箭头函数与对象，不包括function与箭头函数混搭的爷孙关系等等)&lt;/strong&gt;;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const obj = {
    test: () =&amp;gt; {
        console.log(this);
    }
    fn: function() {
        (() =&amp;gt; {
            console.log(this)
        })
    }
}
obj.test() // window，obj.test内没有明确的this(钱)，所以向上找到obj，结果obj也没有钱，所以最后只能委曲求全，找window
obj.fn() // obj，obj.fn中由于function的存在，this指向obj，所以一发命中，直接找obj认爹&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;事件调用下的箭头函数&quot;&gt;4) 事件调用下的箭头函数&lt;/h5&gt;
&lt;p&gt;       其实作为一个拜金女，箭头函数的生活还是挺无趣的，规则太单一。就拿这个事件调用来说吧，还是一个套路。&lt;strong&gt;不管我是不是你亲生的，反正你没钱，我就不认你&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function Go() {
//没想到唯一的希望也是身无分文……唉，又得window了
    window.onmousewheel = () =&amp;gt; { 
        console.log(this); // 亲爹看来你也没钱啊！
        (() =&amp;gt; {
            console.log(this); // 又一个穷货！
            (() =&amp;gt; {
                console.log(this); // 这也没钱！
                (() =&amp;gt; {
                    console.log(this); // 钱呢！
                })();
            })();
        })();
    }
}
Go(); // window，因为onmousewheel事件中及Go()函数中没有明确的this(钱)，所以按照作用域链查找，找到window(走投无路)

new Go(); // 有钱了
// 全部打印Go{}，因为new操作符，Go()函数中声明了this，且指向Go{}对象。
// 而onmousewheel事件也用箭头函数指定，仍旧遵循查找原则。就这么一层一层的找，最后都找到Go函数作用域内的this(钱)，最后全部打印Go{}(逮着一个有钱的可劲造，全造它一个)。
// Go{}对象左拥右抱，帝王生活让人向往！&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;function与箭头函数混搭及js静态作用域&quot;&gt;5) function与箭头函数混搭及JS静态作用域&lt;/h5&gt;
&lt;p&gt;       俗话说得好哇，一山不容二虎，除非一公一母！还有就是男女搭配，干活不累！&lt;/p&gt;
&lt;p&gt;       function与箭头函数这一男一女遇上后，那是干柴遇烈火，一拍即合，合作起来非常愉快！&lt;/p&gt;
&lt;p&gt;       在function这个&lt;del&gt;拉皮条&lt;/del&gt;缺父爱的男孩帮助下，箭头函数找干爹变得容易起来~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以开头代码中挖的坑为例，顺带说一下JS中的静态作用域&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function Test() {
    console.log(this)
    innerTest();
}
const innerTest = () =&amp;gt; { 
    console.log(this); 
}
Test(); // window、window
new Test(); // Test{}、window，从这就可以看出端倪了。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;       按照上边一路顺下来的思路理解的话，&lt;strong&gt;第二次new操作之后，应该打印Test{}和Test{}对不对？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       让我们捋一下思路：&lt;/p&gt;
&lt;p&gt;              在Test函数里调用innerTest函数，innerTest函数是一个箭头函数。那么我在Test里调用它的时候，这拜金女肯定是一步一步的往上找this(钱);&lt;/p&gt;
&lt;p&gt;              第一次无new直接调用&lt;del&gt;没毛病&lt;/del&gt;，Test里没this(钱)，所以找了window;&lt;/p&gt;
&lt;p&gt;              可是第二次new操作后，Test有this(钱)了，为啥箭头函数没找Test？难道嫌它丑？&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;一张图说明情况:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1080150/201811/1080150-20181116211429643-1113408453.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       从Chrome控制台打印的作用域中可以看出，innerTest的&lt;strong&gt;作用域链中根本没有Test函数&lt;/strong&gt;，所以它压根不会在Test中查找this。&lt;/p&gt;
&lt;p&gt;       这就表明了JS作用域与作用域链的一个问题——&lt;strong&gt;静态&lt;/strong&gt;。即&lt;strong&gt;函数的作用域及作用域链，在函数声明时形成，并且保持不变&lt;/strong&gt;。因为innerTest是在全局声明的，所以它的作用域链只有Script及Global，就算再Test函数内调用，也不会改变，除非&lt;strong&gt;在Test函数内再声明一个函数&lt;/strong&gt;，那么该函数的作用域及作用域链中就包含了Test函数，不管有没有通过闭包调用Test函数中的变量(不调用Test函数内变量的话，Chrome浏览器控制台中打印不出来闭包作用域)。&lt;/p&gt;
&lt;h5 id=&quot;callapplybind绑定-1&quot;&gt;6) call、apply、bind绑定&lt;/h5&gt;
&lt;p&gt;       一句话总结：&lt;strong&gt;我对this(钱)很专一的！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;箭头函数的this指向，无法通过call、apply、bind改变！贼专一！&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function Test() {
    const fn = () =&amp;gt; {
        console.log(this);
    }
    fn(); // Test{}
            
    const say = function() {
        console.log(this);
    }
    say() // window

    function Replace() {
        console.log(this); // Replace{}
        fn.call(this); // Text{}
        say.call(this); // Replace{}
    }
    new Replace(); 
}

new Test();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;       至此，这场认亲大戏就到此完毕。整体内容还是有点多的，我相信大多数人是没耐心读完的，所以我尽量想写的幽默有趣一点。就像开夜路怕困，会话会变多、抽烟解困，有的人肯定会反感这种文风，但我也没那么多读者~哈哈哈。&lt;/p&gt;
&lt;p&gt;       最后，有的点挖的还是不够深的，没办法，水平真是有限，挖不动了。如果能给到各位启发，希望你能继续挖下去~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如有错误或阐述不充分之处，欢迎指正~&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 16 Nov 2018 14:02:00 +0000</pubDate>
<dc:creator>阿克琉斯之踵</dc:creator>
<og:description>[toc] 引言        JS中的this指向一直是个老生常谈，但是新手又容易晕的地方。我在网上浏览了很多帖子，但是发现一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/keepStudying/p/9971919.html</dc:identifier>
</item>
<item>
<title>桥接模式 - mingmingcome</title>
<link>http://www.cnblogs.com/mingmingcome/p/9971911.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mingmingcome/p/9971911.html</guid>
<description>&lt;p&gt;&lt;code&gt;2018年11月2日09:26:00&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;桥接模式bridge-pattern&quot;&gt;桥接模式（bridge pattern）&lt;/h2&gt;
&lt;h4 id=&quot;定义&quot;&gt;定义&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;记忆中最深的就是那个外婆桥&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;家和外婆在两边&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在家里想吃和想玩的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;在外婆家都有&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;桥接模式（bridge pattern），将抽象部分与它的实现部分分离，是它们都可以独立的变化。————《设计模式：可复用面向对象软件的基础》&lt;/p&gt;
&lt;p&gt;桥接模式是一种对象结构型模式。&lt;/p&gt;
&lt;h4 id=&quot;使用场景&quot;&gt;使用场景&lt;/h4&gt;
&lt;p&gt;1、如果一个系统需要在构件的抽象化角色和实现化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。&lt;/p&gt;
&lt;p&gt;2、抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。&lt;/p&gt;
&lt;p&gt;3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。&lt;/p&gt;
&lt;p&gt;4、虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象和实现分离，各自变化。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类存在两个独立变化的维度，抽象代表一个，实现代表一个。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;组合聚合复用原则&quot;&gt;组合/聚合复用原则&lt;/h4&gt;
&lt;p&gt;组合/聚合复用原则（CARP：Composite/Aggregate Reuse Priciple），尽量使用组合/聚合复用原则，尽量不要使用类继承。————《Java与设计模式》&lt;/p&gt;
&lt;p&gt;聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；组合则是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。————《设计模式解释》&lt;/p&gt;
&lt;p&gt;组合/聚合复用原则的好处是，优先使用对象的组合/聚合复用原则将有助于你保持每个类被封装，并被集中在单个任务上，这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。————《设计模式：可复用面向对象软件的基础》&lt;/p&gt;
&lt;p&gt;组合关系就是一个人有手脚，聚合是一个人有钱。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Person {
    private Hand hand = new Hand();
    private Foot foot = new Foot();
    private Money money;

    public Person(){}
    public Person(Money money){
        this.money = money;
    }
}
public class Hand{}
public class Foot{}
public class Money{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手脚是一个正常人生来就有的，但是钱这个东西，身外之物。聚合是松耦合的，组合相对来说就是耦合性比较强。&lt;/p&gt;
&lt;p&gt;桥接模式是应用组合/聚合复用原则（CARP）。其实还有很多其他对象结构型模式都是应用了这个原则的，如代理模式、装饰者模式、对象适配者模式等，以此来达到松耦合的目的。&lt;/p&gt;
&lt;h4 id=&quot;角色&quot;&gt;角色&lt;/h4&gt;
&lt;p&gt;抽象化角色（Abstraction）：抽象化给出的定义，并保存一个对实现化对象的引用&lt;/p&gt;
&lt;p&gt;扩充抽象化角色（RefinedAbstraction）【修正抽象化(Refined Abstraction)角色】：扩展抽象化角色，改变和修正父类对抽象化的定义&lt;/p&gt;
&lt;p&gt;实现化角色（Implementor）：实现化角色的接口，但不给出具体的实现&lt;/p&gt;
&lt;p&gt;具体实现化角色（ConcreteImplementor）：具体实现&lt;/p&gt;
&lt;h4 id=&quot;图示&quot;&gt;图示&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/bridge-pattern-structure.jpg&quot; alt=&quot;桥接模式结构图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;抽象（Abstraction）和实现（Implementor）以组合的方式关联起来，抽象的动作行为是由实现来执行。抽象和实现都可以有它们各自的变化，被多个子类继承，拥有不同的功能。&lt;/p&gt;
&lt;h4 id=&quot;代码示例&quot;&gt;代码示例&lt;/h4&gt;
&lt;p&gt;故事背景：城市A和城市B是分隔两岸的两座城市，他们通过一座拥有悠久历史的桥连接起来。城市A人文气息浓厚，商店林立，人来人往，熙熙攘攘。城市B工业气息浓厚，各种机器和手工作坊相辉映，在重复的工序中输出产品。城市A和城市B交互的模式，一般是城市A下订单，城市B完成订单。&lt;/p&gt;
&lt;p&gt;抽象化角色（OrderAbstraction.java）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 订单
public abstract class OrderAbstraction {
    protected FactoryImplementor factoryImplementor;
    
    public OrderAbstraction(FactoryImplementor factoryImplementor) {
        this.factoryImplementor = factoryImplementor;
    }
    
    public abstract void provide();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;扩充抽象化角色（CakeOrderRefinedAbstraction.java）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 蛋糕订单
public class CakeOrderRefinedAbstraction extends OrderAbstraction {
    private int count;
    private String orderName = &quot;蛋糕&quot;;

    public CakeOrderRefinedAbstraction(int count, FactoryImplementor factoryImplementor) {
        super(factoryImplementor);
        this.count = count;
    }

    @Override
    public void provide() {
        factoryImplementor.provide(count, orderName);
    }

}
// 糖果订单
public class CandyOrderRefinedAbstraction extends OrderAbstraction {
    private int count;
    private String orderName = &quot;糖果&quot;;

    public CandyOrderRefinedAbstraction(int count, FactoryImplementor factoryImplementor) {
        super(factoryImplementor);
        this.count = count;
    }

    @Override
    public void provide() {
        factoryImplementor.provide(count, orderName);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现化角色（FactoryImplementor.java）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 工厂
public interface FactoryImplementor {
    public void provide(int count, String orderName);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体实现化角色（HandworkFactoryConcreteImplementor.java、MachineFactoryConcreteImplementor.java）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 手工作坊
public class HandworkFactoryConcreteImplementor implements FactoryImplementor {

    public void provide(int count, String orderName) {
        float time = (float)(count * 1);
        System.out.println(&quot;手工使用了&quot; + time + &quot;小时，完成了&quot; + count + &quot;份&quot; + orderName);
    }

}
// 工厂机器
public class MachineFactoryConcreteImplementor implements FactoryImplementor {

    public void provide(int count, String orderName) {
        float time = (float)(count * 0.5);
        System.out.println(&quot;机器使用了&quot; + time + &quot;小时，完成了&quot; + count + &quot;份&quot; + orderName);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类（BridgePatternTest.java）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class BridgePatternTest {

    public static void main(String[] args) {
        // 手工蛋糕订单
        OrderAbstraction handworkCake = 
                new CakeOrderRefinedAbstraction(10, 
                        new HandworkFactoryConcreteImplementor());
        // 机器蛋糕订单
        OrderAbstraction machineCake = 
                new CakeOrderRefinedAbstraction(10, 
                        new MachineFactoryConcreteImplementor());
        // 手工糖果订单
        OrderAbstraction handworkCandy = 
                new CandyOrderRefinedAbstraction(10, 
                        new HandworkFactoryConcreteImplementor());
        // 机器糖果订单
        OrderAbstraction machineCandy = 
                new CandyOrderRefinedAbstraction(10, 
                        new MachineFactoryConcreteImplementor());

        handworkCake.provide();
        machineCake.provide();
        handworkCandy.provide();
        machineCandy.provide();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/bridge-pattern-result.png&quot; alt=&quot;桥接模式测试结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果表明了：抽象和实现分离，各自变化。订单存在着两个维度变化，一个是种类，一个是制造方式，种类分为蛋糕和糖果，制造方式有手工和机器。&lt;/p&gt;
&lt;h4 id=&quot;其他实例&quot;&gt;其他实例&lt;/h4&gt;
&lt;p&gt;手机软件也有种类和运行在不同的操作系统上两个维度的变化，种类有通讯录、短信等，操作系统IOS，Android等，这样就适用于桥接模式。&lt;/p&gt;
&lt;p&gt;如果需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Linux、Unix等）上播放多种格式的视频文件，常见的视频格式包括MPEG、RMVB、AVI、WMV等。同样适用于桥接模式。&lt;/p&gt;
&lt;h4 id=&quot;与适配器模式的区别&quot;&gt;与适配器模式的区别&lt;/h4&gt;
&lt;p&gt;桥接模式是在设计之初，认为抽象和现实都存在多维的变化，而且抽象和实现的变化是不相关的，在可预见的情况下做出的选择，适配器模式是系统已经成熟到无法修改或者修改的工作量无法估量的时候，但是又想复用当前的功能的时候使用，或者使用第三方组件的时候使用。很多情况下，桥接模式就是使用了对象适配器模式实现的。适配器模式可以参考本人&lt;a href=&quot;https://www.cnblogs.com/mingmingcome/p/9810731.html&quot;&gt;适配者模式&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;优点&quot;&gt;优点&lt;/h4&gt;
&lt;h4 id=&quot;缺点&quot;&gt;缺点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1、增加系统的设计和理解难度&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;当在系统设计初期，发现抽象和实现存在各自的变化或某个类由两个不相关的维度描述时，可以考虑桥接模式。&lt;/p&gt;
&lt;h4 id=&quot;完&quot;&gt;完&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;2018年11月16日21:56:11&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 16 Nov 2018 13:59:00 +0000</pubDate>
<dc:creator>mingmingcome</dc:creator>
<og:description>`2018年11月2日09:26:00` 桥接模式（bridge pattern） 定义 记忆中最深的就是那个外婆桥 家和外婆在两边 在家里想吃和想玩的 在外婆家都有 桥接模式（bridge patt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mingmingcome/p/9971911.html</dc:identifier>
</item>
<item>
<title>Vue钩子函数生命周期实例详解 - 奋斗的青春最美</title>
<link>http://www.cnblogs.com/guobinhui/p/9971894.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guobinhui/p/9971894.html</guid>
<description>&lt;p&gt;&lt;strong&gt;vue生命周期简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、卸载等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。&lt;/p&gt;
&lt;p&gt;在Vue的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册js方法，可以让我们用自己注册的js方法控制整个大局，在这些事件响应方法中的this直接指向的是vue的实例。&lt;/p&gt;
&lt;p&gt;Vue.js生命周期通过下面这个图很容易理解，如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1535419/201811/1535419-20181116215031746-868995007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1535419/201811/1535419-20181116215044722-963018290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以很明显的看出现在vue2.0和vue1.0的主要区别以及vue2.0都包括了哪些生命周期的钩子函数了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生命周期探究&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于执行顺序和什么时候该执行哪个钩子函数，看上面两个图基本有个了解了。下面的案例将通过代码去看看钩子函数的执行,让大家更清晰透彻的理解Vue的生命周期。&lt;/p&gt;
&lt;p&gt;下面代码可以直接复制到项目中的html执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;95&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;title&amp;gt;vue的生命周期钩子函数详解&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
     &amp;lt;p&amp;gt;{{ message }}&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../js/vue.min.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;  
  &lt;span&gt;var&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
      el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
      data: {
          message : &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;这个vue生命周期钩子函数讲解的很棒,通俗易懂,值得关注,收藏 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
      },
      beforeCreate: function () {
              console.group(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;beforeCreate 创建前状态===============》&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
              console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; , &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;el     : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.$el); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
              console.log(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data   : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.$data); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined &lt;/span&gt;
              console.log(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.message)  
       },
       created: function () {
           console.group(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;created 创建完毕状态===============》&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
           console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;el     : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.$el); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
              console.log(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data   : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.$data); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;已被初始化 &lt;/span&gt;
              console.log(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.message); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;已被初始化&lt;/span&gt;
&lt;span&gt;       },
       beforeMount: function () {
           console.group(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;beforeMount 挂载前状态===============》&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
           console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;el     : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (&lt;span&gt;this&lt;/span&gt;.$el)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;已被初始化&lt;/span&gt;
           console.log(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$el);
              console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data   : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.$data); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;已被初始化  &lt;/span&gt;
              console.log(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.message); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;已被初始化  &lt;/span&gt;
&lt;span&gt;       },
       mounted: function () {
           console.group(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mounted 挂载结束状态===============》&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
           console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;el     : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.$el); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;已被初始化&lt;/span&gt;
           console.log(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$el);    
              console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data   : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.$data); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;已被初始化&lt;/span&gt;
              console.log(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.message); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;已被初始化 &lt;/span&gt;
&lt;span&gt;       },
       beforeUpdate: function () {
           console.group(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;beforeUpdate 更新前状态===============》&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
           console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;el     : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$el);
           console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$el);   
           console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data   : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$data); 
           console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.message); 
       },
       updated: function () {
           console.group(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;updated 更新完成状态===============》&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
           console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;el     : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$el);
           console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$el); 
           console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data   : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$data); 
           console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.message); 
       },
       beforeDestroy: function () {
           console.group(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;beforeDestroy 销毁前状态===============》&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
           console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;el     : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$el);
           console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$el);    
           console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data   : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$data); 
           console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.message); 
       },
       destroyed: function () {
           console.group(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;destroyed 销毁完成状态===============》&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
           console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;el     : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$el);
           console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$el);  
           console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data   : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$data); 
           console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.message)
       }
    })
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;created 和 mounted 相关&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;咱们在chrome浏览器里打开，F12看console就能发现&lt;/p&gt;
&lt;p&gt;beforecreated：el 和 data 并未初始化&lt;br/&gt;created：完成了 data 数据的初始化，el没有&lt;br/&gt;beforeMount：完成了 el 和 data 初始化&lt;br/&gt;mounted ：完成挂载&lt;br/&gt;另外在标红处，我们能发现el还是 {{message}}，这里就是应用的 Virtual DOM（虚拟Dom）技术，先把位置占住了。到后面mounted挂载的时候再把数据渲染进去。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1535419/201811/1535419-20181116215208523-532756648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;update 相关&lt;/h3&gt;
&lt;p&gt;这里我们在 chrome console里执行以下命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
app.message= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;你们多关注我的csdn博客,地址是https://blog.csdn.net/guobinhui&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面就能看到data里的值被修改后，将会触发update的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1535419/201811/1535419-20181116215254219-35448227.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;destroy 相关&lt;/h3&gt;
&lt;p&gt;有关于销毁，暂时还不是很清楚。我们在console里执行下命令对 vue实例进行销毁。销毁完成后，我们再重新改变message的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在，可以这么理解，执行了destroy操作，后续就不再受vue控制了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1535419/201811/1535419-20181116215345374-572490010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生命周期总结&lt;br/&gt;这么多钩子函数，我们怎么用呢，我想大家可能有这样的疑问吧，我也有，哈哈哈。&lt;/p&gt;
&lt;p&gt;beforecreate : 举个栗子：可以在这加个loading事件&lt;br/&gt;created ：在这结束loading，还做一些初始化，实现函数自执行&lt;br/&gt;mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情&lt;br/&gt;beforeDestroy： 你确认删除XX吗？ destroyed ：当前组件已被删除，清空相关内容&lt;/p&gt;
&lt;p&gt;当然，还有更多，继续探索中......&lt;/p&gt;
&lt;p&gt;本文是笔者参考官方资料整理的Vue生命周期详解，如有错误还请大牛指正。希望对大家有所帮助。&lt;/p&gt;

</description>
<pubDate>Fri, 16 Nov 2018 13:56:00 +0000</pubDate>
<dc:creator>奋斗的青春最美</dc:creator>
<og:description>vue生命周期简介 Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、卸载等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guobinhui/p/9971894.html</dc:identifier>
</item>
<item>
<title>React中使用styled-components的基础使用 - 一只菜鸟攻城狮啊</title>
<link>http://www.cnblogs.com/suihang/p/9971890.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suihang/p/9971890.html</guid>
<description>&lt;p&gt;今天准备来给大家分享分享React中styled-components的基础使用，&lt;span&gt;仅仅是我个人的一些理解，不一定全对，有错误还请大佬们指出，496838236这是我qq&lt;/span&gt;，有想指点我的大佬随时加我qq好吧，要是想约我一起做保健，那我只能随叫随到了&lt;/p&gt;
&lt;p&gt; 好了，废话不多说，开工&lt;/p&gt;
&lt;p&gt;　今天我们不对react的环境进行搭建，我直接用脚手架搭一个最简单的环境来用，进入主题&lt;/p&gt;
&lt;p&gt;　1.使用styled-components&lt;/p&gt;
&lt;p&gt;　　首先我们要安装styled-components&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yarn add styled-components  ||  npm install --save styled-components
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;2.最基础的使用，（为了方便阅读，以下所有的代码我将在一个文件中演示）&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
import React, { Component,Fragment} from 'react'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入styled-components&lt;/span&gt;
import styled from 'styled-components'

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改了div的样式&lt;/span&gt;
const Title =&lt;span&gt; styled.div`
  font&lt;/span&gt;-size:1&lt;span&gt;.5rem;
  color:red
`
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改了button的样式&lt;/span&gt;
const Button =&lt;span&gt; styled.button`
    border:none;
    background&lt;/span&gt;-&lt;span&gt;color:blue
`

class App extends Component {
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&amp;lt;Fragment&amp;gt;&lt;span&gt;
    {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始的内容&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; &amp;lt;div&amp;gt;大红牛&amp;lt;/div&amp;gt;
    &amp;lt;button&amp;gt;枸杞11&amp;lt;/button&amp;gt; &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;}
    &lt;/span&gt;&amp;lt;Title&amp;gt;大红牛&amp;lt;/Title&amp;gt;
    &amp;lt;Button&amp;gt;枸杞&amp;lt;/Button&amp;gt;
    &amp;lt;/Fragment&amp;gt;
&lt;span&gt;    )
  }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; App;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201811/1459059-20181116204358164-1819601011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是很爽，其实到这里完全就可以用styled-components来写类似于CSS的代码了，但是这肯定不够啊，所以我们继续往下看&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.塑造组件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　为什么要有塑造塑件呢，因为肯定会有一个场景，我们要对已经定义好的组件进行二次样式的修改，那这个时候我们就需要用塑造组件了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
import React, { Component,Fragment} from 'react'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入styled-components&lt;/span&gt;
import styled from 'styled-components'

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始组件&lt;/span&gt;
const Button =&lt;span&gt; styled.button`
color: palevioletred;
font&lt;/span&gt;-&lt;span&gt;size: 1em;
margin: 1em;
padding: &lt;/span&gt;0&lt;span&gt;.25em 1em;
border: 2px solid palevioletred;
border&lt;/span&gt;-&lt;span&gt;radius: 3px;
`
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对组件进行二次样式修饰&lt;/span&gt;
const YellowButton =&lt;span&gt; styled(Button)`
  background&lt;/span&gt;-&lt;span&gt;color:yellow
`

class App extends Component {
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&amp;lt;Fragment&amp;gt;
      &amp;lt;Button&amp;gt;红牛&amp;lt;/Button&amp;gt;
      &amp;lt;YellowButton&amp;gt;枸杞&amp;lt;/YellowButton&amp;gt;
    &amp;lt;/Fragment&amp;gt;
&lt;span&gt;    )
  }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; App;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201811/1459059-20181116205622289-936573277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3.props传递参数  &lt;span&gt;styled-components可以用props接受参数，从而根据传递的参数确定样式，是不是很强大&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
import React, { Component,Fragment} from 'react'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入styled-components&lt;/span&gt;
import styled from 'styled-components'

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;props传递参数（根据参数的值设置样式）&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 有传递值字体会变为红色&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 无传递值会默认取蓝色&lt;/span&gt;
const Button =&lt;span&gt; styled.button`
  padding: &lt;/span&gt;0&lt;span&gt;.5em;
  margin: &lt;/span&gt;0&lt;span&gt;.5em;
  color: ${ props &lt;/span&gt;=&amp;gt; props.inputColor || &quot;blue&quot;&lt;span&gt; };
  background: papayawhip;
  border: none;
  border&lt;/span&gt;-&lt;span&gt;radius: 3px;
`

class App extends Component {
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&amp;lt;Fragment&amp;gt;
        &amp;lt;Button inputColor=&quot;red&quot;&amp;gt;红牛啊&amp;lt;/Button&amp;gt;
    &amp;lt;/Fragment&amp;gt;
&lt;span&gt;    )
  }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; App;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201811/1459059-20181116211036986-1040275864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了可以根据参数的值进行样式的设置之外，我们还可以通过参数的有无来设置样式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
import React, { Component,Fragment} from 'react'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入styled-components&lt;/span&gt;
import styled from 'styled-components'

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;props传递参数（根据参数的有无设置样式）&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 有参数背景会变为蓝色&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 无传递值背景会默认取黄色&lt;/span&gt;
const Button =&lt;span&gt; styled.button`
  padding: &lt;/span&gt;0&lt;span&gt;.5em;
  margin: &lt;/span&gt;0&lt;span&gt;.5em;
  background: ${props&lt;/span&gt;=&amp;gt;props.blue?&quot;blue&quot;:&quot;yellow&quot;&lt;span&gt;};
  border: none;
  border&lt;/span&gt;-&lt;span&gt;radius: 3px;
`

class App extends Component {
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&amp;lt;Fragment&amp;gt;
        &amp;lt;Button blue&amp;gt;红牛啊&amp;lt;/Button&amp;gt;
    &amp;lt;/Fragment&amp;gt;
&lt;span&gt;    )
  }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; App;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201811/1459059-20181116211513027-1014777003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;4&lt;/span&gt;.修改样式的同时添加属性，同时也可以通过这种方法引入第三方的样式，只需要设置className属性即可&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
import React, { Component,Fragment} from 'react'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入styled-components&lt;/span&gt;
import styled from 'styled-components'

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;props传递参数（根据参数的有无设置样式）&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 有参数背景会变为蓝色&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 无传递值背景会默认取黄色&lt;/span&gt;
const Button =&lt;span&gt; styled.button.attrs({
  title:&lt;/span&gt;&quot;aaa&quot;&lt;span&gt;,
  id:&lt;/span&gt;'bbb'&lt;span&gt;,
  &lt;/span&gt;'data-role':(props)=&amp;gt;&lt;span&gt;props.hello
})`
  padding: &lt;/span&gt;0&lt;span&gt;.5em;
  margin: &lt;/span&gt;0&lt;span&gt;.5em;
  border: none;
  border&lt;/span&gt;-&lt;span&gt;radius: 3px;
`

class App extends Component {
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&amp;lt;Fragment&amp;gt;
        &amp;lt;Button hello=&quot;hi&quot;&amp;gt;红牛啊&amp;lt;/Button&amp;gt;
    &amp;lt;/Fragment&amp;gt;
&lt;span&gt;    )
  }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; App;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201811/1459059-20181116212608724-1055710712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过控制台我们可以看到，属性已经全部被加上去了&lt;/p&gt;

&lt;p&gt;5.&lt;span&gt;继承&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
import React, { Component,Fragment} from 'react'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入styled-components&lt;/span&gt;
import styled from 'styled-components'

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承  根据实验 如果我没出错 最新的版本应该是不支持extend了&lt;/span&gt;
const Button =&lt;span&gt; styled.button` 
      color: palevioletred; 
      font&lt;/span&gt;-&lt;span&gt;size: 1em; 
      margin: 1em; 
      padding: &lt;/span&gt;0&lt;span&gt;.25em 1em; 
      border&lt;/span&gt;-&lt;span&gt;radius: 3px; `

const YellowButton &lt;/span&gt;=&lt;span&gt; Button.extend` 
      color: yellow;
      border&lt;/span&gt;-&lt;span&gt;color: yellow; `;

class App extends Component {
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&amp;lt;Fragment&amp;gt;
        &amp;lt;Button&amp;gt;红牛啊&amp;lt;/Button&amp;gt;
        &amp;lt;YellowButton&amp;gt;枸杞啊&amp;lt;/YellowButton&amp;gt;
    &amp;lt;/Fragment&amp;gt;
&lt;span&gt;    )
  }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; App;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6.&lt;span&gt;偷懒的写法，当标签很多时，要是我们虽每个标签都要进行修饰，那岂不是要写好多的组件，但是在有些情况下我们没必要分这木多组件，那我们不妨可以试试以下的写法&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
import React, { Component,Fragment} from 'react'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入styled-components&lt;/span&gt;
import styled from 'styled-components'

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;另一种语法&lt;/span&gt;
const StyledDiv =&lt;span&gt; styled.div`
  font&lt;/span&gt;-&lt;span&gt;size: 100px;
  &lt;/span&gt;&amp;gt;&lt;span&gt; span {
    font&lt;/span&gt;-&lt;span&gt;size: 50px;
  }
  &lt;/span&gt;&amp;amp; &amp;gt;&lt;span&gt; p {
    font&lt;/span&gt;-&lt;span&gt;size: 25px;
  }
`

class App extends Component {
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&amp;lt;Fragment&amp;gt;
        &amp;lt;StyledDiv&amp;gt;
            &amp;lt;span&amp;gt;红牛&amp;lt;/span&amp;gt;
            &amp;lt;p&amp;gt;枸杞&amp;lt;/p&amp;gt;
        &amp;lt;/StyledDiv&amp;gt;
    &amp;lt;/Fragment&amp;gt;
&lt;span&gt;    )
  }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; App;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201811/1459059-20181116215333155-1789290900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;好啦，好啦今天就先到这里吧，希望各位大佬能指教指教我，实在不想指教一起约个正规保健也是可以的好吧&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;



</description>
<pubDate>Fri, 16 Nov 2018 13:55:00 +0000</pubDate>
<dc:creator>一只菜鸟攻城狮啊</dc:creator>
<og:description>今天准备来给大家分享分享React中styled-components的基础使用，仅仅是我个人的一些理解，不一定全对，有错误还请大佬们指出，496838236这是我qq，有想指点我的大佬随时加我qq好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/suihang/p/9971890.html</dc:identifier>
</item>
<item>
<title>Java入门系列-27-反射 - 极客大全</title>
<link>http://www.cnblogs.com/AIThink/p/9971770.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AIThink/p/9971770.html</guid>
<description>&lt;p&gt;咱们可能都用过 Spring AOP ，底层的实现原理是怎样的呢？&lt;/p&gt;
&lt;p&gt;反射常用于编写工具，企业级开发要用到的 Mybatis、Spring 等框架，底层的实现都用到了反射。能用好反射，就能提高我们编码的核心能力。&lt;/p&gt;

&lt;p&gt;JAVA反射机制是在运行状态中，对于任意一个实体类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性。&lt;/p&gt;
&lt;p&gt;作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在运行时判断任意一个对象所属的类&lt;/li&gt;
&lt;li&gt;在运行时构造任意一个类的对象&lt;/li&gt;
&lt;li&gt;在运行时判断任意一个类所具有的成员变量和方法&lt;/li&gt;
&lt;li&gt;在运行时调用任意一个对象的成员变量和方法&lt;/li&gt;
&lt;li&gt;生成动态代理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;常用的类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;java.lang.Class：代表一个类&lt;/li&gt;
&lt;li&gt;java.lang.reflect.Method：代表类的方法&lt;/li&gt;
&lt;li&gt;java.lang.reflect.Field：代表类的成员变量&lt;/li&gt;
&lt;li&gt;java.lang.reflect.Constructor：代表类的构造方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Class 类的实例表示正在运行的 Java 应用程序中的类和接口，Class 没有公共构造方法，Class 对象是在加载类时由 Java 虚拟机及通过调用类加载器中的 defineClass 方法自动构造的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个类在 JVM 中只会有一个 Class 实例&lt;/li&gt;
&lt;li&gt;一个 Class 对象对应的是一个加载到 JVM 中的一个 .class 文件&lt;/li&gt;
&lt;li&gt;每个类的实例都会记得自己是由哪个 Class 实例所生成&lt;/li&gt;
&lt;li&gt;通过 Class 可以完整地得到一个类中的完整结构&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;获取-class-对象&quot;&gt;获取 Class 对象&lt;/h2&gt;
&lt;p&gt;获取 Class 对象有4种方式，前三种比较常用。&lt;/p&gt;
&lt;p&gt;首先创建一个类用于测试&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.jikedaquan.reflection;

public class User {
    
    private int id;
    private String username;
    private String password;

    public User() {
    }
    
    public User(int id, String username, String password) {
        super();
        this.id = id;
        this.username = username;
        this.password = password;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
    
    public void show() {
        System.out.println(&quot;Hello&quot;);
    }
    
    @Override
    public String toString() {
        return &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, password=&quot; + password + &quot;]&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写测试&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.jikedaquan.reflection;

public class GetClass {

    public static void main(String[] args) {
        //方法1
        try {
            Class clz1=Class.forName(&quot;com.jikedaquan.reflection.User&quot;);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
            System.out.println(&quot;找不到指定类&quot;);
        }
        //方法2
        Class clz2=User.class;
        //方法3
        User user=new User();
        Class clz3=user.getClass();
        
        //方法4 类的加载器
        try {
            Class clz4=GetClass.class.getClassLoader().loadClass(&quot;com.jikedaquan.reflection.User&quot;);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
            System.out.println(&quot;找不到指定类&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;方法1语法：&lt;code&gt;Class Class对象 = Class.forName(包名+类名);&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;方法2语法：&lt;code&gt;Class Class对象 = 类名.class;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;方法3语法：&lt;code&gt;Class Class对象 = 对象.getClass();&lt;/code&gt;&lt;br/&gt;getClass() 方法是从 Object 类中继承过来的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Class 类常用方法&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Annotation[] getAnnotations()&lt;/td&gt;
&lt;td&gt;返回此元素上存在的所有注解&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Constructor&lt;/td&gt;
&lt;td&gt;获取指定参数的构造函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Constructor&amp;lt;?&amp;gt;[] getConstructors()&lt;/td&gt;
&lt;td&gt;返回包含的公有构造方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Constructor&amp;lt;?&amp;gt;[] getDeclaredConstructors()&lt;/td&gt;
&lt;td&gt;返回所有构造方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;Field getDeclaredField(String name)&lt;/td&gt;
&lt;td&gt;返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;Method getDeclaredMethod(String name, Class&amp;lt;?&amp;gt;... parameterTypes)&lt;/td&gt;
&lt;td&gt;根据方法名和参数获取方法对象&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;API 中可以看到有两种获取结构的方式：getDeclaredXxx()和getXxx()；getDeclaredXxx()可以获取所有包括私有的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;获取类的结构&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.jikedaquan.reflection;

import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class GetClassStruct {

    public static void main(String[] args) {
        try {
            Class clz=Class.forName(&quot;com.jikedaquan.reflection.User&quot;);
            System.out.println(&quot;===========构造===========&quot;);
            //获取构造方法
            Constructor[] cons=clz.getDeclaredConstructors();
            for (Constructor constructor : cons) {
                System.out.println(constructor);
            }
            //获取字段
            System.out.println(&quot;===========字段===========&quot;);
            Field[] fields=clz.getDeclaredFields();
            for (Field field : fields) {
                System.out.println(field);
            }
            //获取方法
            System.out.println(&quot;===========方法===========&quot;);
            Method[] methods=clz.getDeclaredMethods();
            for (Method method : methods) {
                System.out.println(method);
            }
            //获取父类
            System.out.println(&quot;===========父类===========&quot;);
            Class supperClass=clz.getSuperclass();
            System.out.println(supperClass.getName());
            //获取实现的接口
            System.out.println(&quot;===========接口===========&quot;);
            Class[] interfaces=clz.getInterfaces();
            for (Class interf : interfaces) {
                System.out.println(interf);
            }
            //获取注解
            System.out.println(&quot;===========注解===========&quot;);
            Annotation[] annotations=clz.getAnnotations();
            for (Annotation annotation : annotations) {
                System.out.println(annotation);
            }
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;获取构造方法并实例化对象&quot;&gt;获取构造方法并实例化对象&lt;/h2&gt;
&lt;p&gt;注意：jdk1.9弃用此方式实例化对象&lt;br/&gt;&lt;del&gt;Object obj=clz.newInstance();&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;通过反射获取有参或无参构造后方可实例化化对象&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.jikedaquan.reflection;

import java.lang.reflect.Constructor;

public class CallConstructor {

    public static void main(String[] args) {
        //获取User 的 Class
        Class&amp;lt;User&amp;gt; clz=User.class;
        
        //获取无参构造方法并实例化
        try {
            //getConstructor()方法不传参即无参
            Constructor&amp;lt;User&amp;gt; constructor=clz.getConstructor();
            User user=constructor.newInstance();
            System.out.println(user);
        } catch (Exception e) {
            e.printStackTrace();
        }
        //获取有参构造方法并实例化
        try {
            Constructor&amp;lt;User&amp;gt; constructor=clz.getConstructor(int.class,String.class,String.class);
            User user=constructor.newInstance(18,&quot;张三&quot;,&quot;abc123&quot;);
            System.out.println(user);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;获取指定构造方法时，第二个参数为动态参数，不填写即获取无参构造方法，填写指定个数和指定类型.class可获取对应方式的构造方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;调用类中的方法&quot;&gt;调用类中的方法&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.jikedaquan.reflection;

import java.lang.reflect.Method;

public class CallMethod {

    public static void main(String[] args) {
        //获取User 的 Class
        Class&amp;lt;User&amp;gt; clz=User.class;
        //获取无参方法  show
        try {
            Method method=clz.getMethod(&quot;show&quot;);
            //执行clz中的方法
            method.invoke(clz.getConstructor().newInstance());
        } catch (Exception e) {
            e.printStackTrace();
        }
        //获取一个参数为String的方法
        try {
            Method method=clz.getMethod(&quot;setUsername&quot;, String.class);
            //反射实例化对象
            User user=clz.getConstructor().newInstance();
            //执行这个对象的方法
            method.invoke(user, &quot;反射&quot;);
            //测试结果
            System.out.println(user);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;如果有多个参数，获取方法：&lt;code&gt;getMethod(&quot;方法名称&quot;,参数1.class,参数2.class,参数3.class)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;多个参数执行时：&lt;code&gt;method.invoke(对象,参数1,参数2,参数3);&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;动态代理是指客户通过代理类来调用其他对象的方法，并且是在程序运行时根据需要创建目标类的代理对象。&lt;/p&gt;
&lt;p&gt;原理：&lt;/p&gt;
&lt;p&gt;使用一个代理将对象包装起来，然后用该代理对象取代原对象，任何对原始对象的调用都要通过dialing，代理对象决定是否以及何时将方法调用转到原始对象上。&lt;/p&gt;
&lt;p&gt;生活中海外代购其实就用到了代理，你可能不方便出国，但是代购可以，最终帮你完成购买行为。&lt;/p&gt;
&lt;p&gt;以代购为例子完成静态代理&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.jikedaquan.reflection;

//购买接口(约定)
interface Buy{
    void buyProduct();
}
//被代理的
class Customer implements Buy{

    @Override
    public void buyProduct() {
        System.out.println(&quot;购买商品&quot;);
    }
}
//代理
class ProxyBuy implements Buy{
    private Customer customer;
    
    public ProxyBuy(Customer customer) {
        this.customer=customer;
    }
    
    @Override
    public void buyProduct() {
        System.out.println(&quot;代理：出国&quot;);
        //被代理的对象的行为
        customer.buyProduct();
        System.out.println(&quot;代理：回国&quot;);
    }
}

public class TestStaticProxy {

    public static void main(String[] args) {
        Customer customer=new Customer();
        ProxyBuy proxyBuy=new ProxyBuy(customer);
        proxyBuy.buyProduct();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么动态代理意味着不能只代理 Customer 类的行为，还可以代理其他类的行为&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.jikedaquan.reflection;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

//工厂接口
interface Factory{
    void product();
}
//电脑工厂
class ComputerFactory implements Factory{

    @Override
    public void product() {
        System.out.println(&quot;生产电脑&quot;);
    }
}
//动态代理处理器
class MyInvocationHandler implements InvocationHandler{
    //要被代理的对象
    private Object proxyObj;
    //产生代理对象
    public Object bind(Object proxyObj) {
        this.proxyObj=proxyObj;
        return Proxy.newProxyInstance(
                proxyObj.getClass().getClassLoader(),
                proxyObj.getClass().getInterfaces(), 
                this
                );
    }
    //代理对象实际执行的方法
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;代理：收收费&quot;);
        Object result=method.invoke(proxyObj, args);
        System.out.println(&quot;代理：代理完成&quot;);
        return result;
    }

}

public class TestDynamicProxy {

    public static void main(String[] args) {
        //创建代理对象生产器
        MyInvocationHandler invocationHandler=new MyInvocationHandler();

        //创建要被代理的对象
        ComputerFactory computerFactory=new ComputerFactory();
        //生产代理对象
        Object factoryProxy=invocationHandler.bind(computerFactory);
        Factory factory=(Factory) factoryProxy;
        factory.product();

        //创建另一个要被代理的对象(上个示例静态代理的对象和接口)
        Customer customer=new Customer();
        //生产代理对象
        Object buyProxy=invocationHandler.bind(customer);
        Buy buy=(Buy) buyProxy;
        buy.buyProduct();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 main 方法中，创建了一个 MyInvocationHandler 对象，通过 bind 方法可以传入任意要被代理的对象，实现了动态。&lt;/p&gt;
&lt;p&gt;重点来了，拿好小本子笔记！！！！！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现动态代理的步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1.创建要被代理的类的接口&lt;/p&gt;
&lt;p&gt;2.创建要被代理的类实现类&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;创建代理对象处理器(MyInvocationHandler)，实现 InvocationHandler 接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;编写生产代理对象的方法，方法内调用 Proxy.newInstance() 方法，返回代理对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;5.&lt;strong&gt;重写 InvocationHandler 的 invoke 方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;6.测试：创建代理对象生产器，生产代理对象&lt;/p&gt;
</description>
<pubDate>Fri, 16 Nov 2018 13:33:00 +0000</pubDate>
<dc:creator>极客大全</dc:creator>
<og:description>咱们可能都用过 Spring AOP ，底层的实现原理是怎样的呢？ 反射常用于编写工具，企业级开发要用到的 Mybatis、Spring 等框架，底层的实现都用到了反射。能用好反射，就能提高我们编码的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AIThink/p/9971770.html</dc:identifier>
</item>
</channel>
</rss>