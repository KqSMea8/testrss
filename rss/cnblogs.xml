<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>探索从 MVC 到 MVVM + Flux 架构模式的转变 - 牧云云</title>
<link>http://www.cnblogs.com/MuYunyun/p/8442179.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MuYunyun/p/8442179.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;本文首发于 &lt;a href=&quot;https://github.com/MuYunyun/blog/issues/14&quot;&gt;my blog&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在业务中一般 MVVM 框架一般都会配合上数据状态库(redux, mobx 等)一起使用，本文会通过一个小 demo 来讲述为什么会引人数据状态库。&lt;/p&gt;
&lt;h3 id=&quot;从-mvc-到-mvvm-模式说起&quot;&gt;从 MVC 到 MVVM 模式说起&lt;/h3&gt;
&lt;p&gt;传统 MVC 架构(如 JSP)在当今移动端流量寸土寸金的年代一个比较头疼的问题就是会进行大量的全局重复渲染。但是 MVC 架构是好东西，其对数据、视图、逻辑有了清晰的分工，于是前端 MVC 框架(比如 backbone.js) 出来了，对于很多业务规模不大的场景，前端 MVC 框架已经够用了，它也能做到前后端分离开发单页面应用，那么它的缺陷在哪呢？&lt;/p&gt;
&lt;p&gt;拿 backbone.js 说，它的 Model 对外暴露了 set 方法，也就是说可以在不止一个 View 里修改同个 Model 的数据，然后一个 Model 的数据同时对应多个 View 的呈现，如下图所示。当业务逻辑过多时，多个 Model 和多个 View 就会耦合到一块，可以想到排查 bug 的时候会比较痛苦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/11/16183c3fae895d43&quot;/&gt;&lt;/p&gt;
&lt;p&gt;针对传统 MVC 架构性能低(多次全局渲染)以及前端 MVC 框架耦合度高(Model 和 View) 的痛处，MVVM 框架完美地解决了以上两点。可以参阅之前写的 &lt;a href=&quot;https://github.com/MuYunyun/blog/issues/11&quot;&gt;MVVM 框架解析之双向绑定&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;only-mvvm&quot;&gt;only MVVM&lt;/h3&gt;
&lt;p&gt;假设有这么一个场景，在输入框中查询条件，点击查询，然后在列表中返回相应内容。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/11/16183c40b99c5093?w=318&amp;amp;h=200&amp;amp;f=jpeg&amp;amp;s=8090&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设用 react 实现，思路大体是先调用查询接口，调用成功后将获取到的数据通过 &lt;code&gt;setState&lt;/code&gt; 存进 list 中，列表显示部分代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; Decorate &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (ListComponent) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;()
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [] &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;at&quot;&gt;componentDidMount&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;fetch&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'./list.json'&lt;/span&gt;)
      .&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;((res) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;res&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;json&lt;/span&gt;())
      .&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(result &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setState&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;result&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;))
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;at&quot;&gt;render&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; (
      &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;ListComponent data&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;state&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;  }&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着往封装的 Decorate 组件里，传入无状态函数构建的 List 组件用来展示列表数据，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;List&lt;/span&gt;(props) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; (
    &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;props&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;data&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;map&lt;/span&gt;(r &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;p key&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;r&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&amp;gt;{&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;r&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    &amp;lt;/div&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
  )
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到 List 组件相当于是 View 层，而封装的 Decorate 组件相当于是 Model 层。但是这么做还是把业务逻辑写进了组件当中。而我们期望的是能得到一个纯粹的 Model 层和 View 层。接着一起看看 Flux 架构模式是如何解决这个问题的。&lt;/p&gt;
&lt;h3 id=&quot;引人-flux-架构模式&quot;&gt;引人 Flux 架构模式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/11/16183c3fade4c600?w=468&amp;amp;h=200&amp;amp;f=jpeg&amp;amp;s=9305&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Flux 架构模式的 4 个重要组成部分以及它们的关系如上图所示，下文会根据 dispatch，store, action, view 的顺序逐步揭开 Flux 架构模式的面纱。&lt;/p&gt;
&lt;p&gt;从 &lt;a href=&quot;https://github.com/facebook/flux/blob/master/src/Dispatcher.js&quot;&gt;Flux 的源码&lt;/a&gt;中可以看出 Dispacher.js 是其的核心文件，其核心是基于事件的发布/订阅模式完成的，核心源码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Dispatcher &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  ...
  &lt;span class=&quot;co&quot;&gt;// 注册回调函数，&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;register&lt;/span&gt;(callback) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; id &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; _prefix &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_lastID&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;++;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_callbacks&lt;/span&gt;[id] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; callback&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;co&quot;&gt;// 当调用 dispatch 的时候会调用 register 中注册的回调函数&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;dispatch&lt;/span&gt;(payload) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_startDispatching&lt;/span&gt;(payload)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; id &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_callbacks&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_invokeCallback&lt;/span&gt;(id)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;回顾下之前的目的：让 Store 层变得纯粹。于是定义了一个变量 comments 用来专门存放列表数据，在了解 Dispatcher 的核心原理之后，当调用 dispatch(obj) 方法时，就可以把参数传递到事先注册的 register 函数中，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// commentStore.js&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; comments &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; CommentStore &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;getComment&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; comments
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;dispathcer&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;register&lt;/span&gt;((action) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 调用 Dispatcher 实例上的 register 函数&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;switch&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;action&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;type&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'GET_LIST_SUCCESS'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      comments &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;action&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;comment&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以及 action 中的函数如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// commentAction.js&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; commentAction &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;getList&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;fetch&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'./list.json'&lt;/span&gt;)
      .&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;((res) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;res&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;json&lt;/span&gt;())
      .&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(result &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;dispathcer&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;dispatch&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 调用 Dispatcher 实例上的 dispatch 函数&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'GET_LIST_SUCCESS'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;comment&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;result&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;))
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是似乎少了点什么，当 &lt;code&gt;GET_LIST_SUCCESS&lt;/code&gt; 成功后，发现还缺少通知到页面再次调用 CommentStore.getComment() 的能力，所以再次引用事件发布/订阅模式，这次使用了 Node.js 提供的 events 模块，对 commentStore.js 文件进行修改，修改后代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; comments &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; CommentStore &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;assign&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{},&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;EventEmitter&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;getComment&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; comments
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;

  &lt;span class=&quot;at&quot;&gt;emitChange&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;emit&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'change'&lt;/span&gt;)
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;

  &lt;span class=&quot;at&quot;&gt;addListener&lt;/span&gt;(callback) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 提供给页面组件使用&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'change'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; callback)
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)

&lt;span class=&quot;va&quot;&gt;appDispathcer&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;register&lt;/span&gt;((action) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;switch&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;action&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;type&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'GET_LIST_SUCCESS'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      comments &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;action&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;comment&lt;/span&gt;
      &lt;span class=&quot;va&quot;&gt;CommentStore&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;emitChange&lt;/span&gt;() &lt;span class=&quot;co&quot;&gt;// 有了这行代码，也就有了通知页面再次进行调用 CommentStore.getComment 的能力&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;剩下最后一步了，就是整合 store 和 action 进页面中，代码如下:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ComponentList &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;()
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;comment&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;commentStore&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getComment&lt;/span&gt;()
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;at&quot;&gt;componentDidMount&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;commentStore&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;addListener&lt;/span&gt;(() &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setState&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 注册函数，上面已经提过，供 store 使用&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;comment&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;commentStore&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getComment&lt;/span&gt;()
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;))
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;at&quot;&gt;render&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; (
      &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;state&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;comment&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;map&lt;/span&gt;(r &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;p key&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;r&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&amp;gt;{&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;r&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;      &amp;lt;/div&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
    )
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;单纯以 mvvm 构建应用会发现业务逻辑以及数据都耦合在组件之中，引入了 Flux 架构模式后数据和业务逻辑得到较好的分离。但是使用 Flux 有什么缺点呢？在下篇 《聊聊 Redux 架构模式》中会进行分析，下回见。&lt;/p&gt;
&lt;p&gt;本文实践案例已上传至 &lt;a href=&quot;https://github.com/MuYunyun/stateManage&quot;&gt;stateManage&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MuYunyun/blog&quot;&gt;系列博客&lt;/a&gt;，欢迎 Star&lt;/p&gt;
</description>
<pubDate>Sun, 11 Feb 2018 07:39:00 +0000</pubDate>
<dc:creator>牧云云</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MuYunyun/p/8442179.html</dc:identifier>
</item>
<item>
<title>15、技术经理指南 - 软件项目角色指南系列文章 - lzhdim</title>
<link>http://www.cnblogs.com/lzhdim/p/8439282.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lzhdim/p/8439282.html</guid>
<description>

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;技术经理这个职位在软件项目组中的作用也是很高大上的，基本上技术经理需要配合系统架构师对软件系统的架构进行规划实现，同时需要对项目开发过程中产生的一些技术上的问题进行解决处理。技术经理在职位上需要配合项目经理对项目需求等进行分析处理，同时需要对项目的设计文档负责，对项目设计内容进行管理，让系统产生的所有编码技术问题得以解决。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;、工作职责&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;技术经理在实际的工作过程中是一个重要的角色，其作用贯穿整个项目的全部过程。在需求到设计、设计到开发阶段都具有重要的意义。&lt;/p&gt;
&lt;p&gt;l  配合系统架构师在需求到设计阶段的内容进行架构设计；&lt;/p&gt;
&lt;p&gt;l  配合项目经理在设计到开发阶段的系统内容进行处理；&lt;/p&gt;
&lt;p&gt;l  解决系统开发阶段的技术问题；&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;、应具备的知识&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;技术经理因为在项目开发阶段的重要性，所以其所需要的知识和经验比较精通。除了软件工程相关的知识，设计模式，从入门到精通系列的学习内容，技术经理还需要对整个架构下面的技术问题进行解决处理，配合软件工程师对整个项目的编码进行沟通处理。&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;、日常工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;技术经理需要在实际工作过程中也进行学习，同时配合项目组成员进行系统开发阶段的技术问题和攻关问题，更好的在项目过程中发挥自己的作用。&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;strong&gt;、经验提升的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;技术经理这个职位基本上是有招聘但是没培训等内容的，所以，技术经理也是一个自己学习提高的过程。技术经理需要在实际工作空闲之余进行不断的学习及提高经验，同时需要对系统业务等内容进行理解，更好的对项目成员进行技术上的培训，在实际工作系统开发阶段对技术问题进行解决。&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;strong&gt;、与其他角色的沟通&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;技术经理因为属于技术岗位，在项目中在需求到设计阶段配合系统架构师对系统进行架构设计，在设计到开发阶段对项目组软件工程师进行技术培训，让开发人员更好的在项目的开发过程中进行开发。&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;strong&gt;、应阅读的书籍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;技术经理更多的是自我的一个提升，所以需要阅读相关的系统设计开发书籍。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1）框架&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    程序员必须对现在正在使用的框架结构做到熟悉，才能更好的发挥出架构的优越性。不过貌似框架部分的书籍还是部分语言有部分语言比较少。这个就得看架构师的水平了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2）设计模式&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    程序员对常用的设计模式的书籍应该进行阅读，以了解架构师在现有的软件系统中所使用到的设计模式。或者应该召开会议，以讲解系统中使用到的设计模式。程序员对于设计模式只需要做到阅读即可。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3）软件工程&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    软件工程对于程序员来说是必修的课程。但是深入程度就得看个人的修行程度了。软件工程还是得看，以理解项目经理在实际过程中所应用到的内容，提高项目团队的综合水平。&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;strong&gt;、应铭记的话&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;l  不断的学习技术方面的知识；&lt;/p&gt;
&lt;p&gt;不断的对系统业务需求到设计的转换思想问题进行处理；&lt;/p&gt;
</description>
<pubDate>Sun, 11 Feb 2018 06:42:00 +0000</pubDate>
<dc:creator>lzhdim</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lzhdim/p/8439282.html</dc:identifier>
</item>
<item>
<title>大白话说Java反射：入门、使用、原理 - 陈树义</title>
<link>http://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html</guid>
<description>&lt;p&gt;反射之中包含了一个「反」字，所以想要解释反射就必须先从「正」开始解释。&lt;/p&gt;
&lt;p&gt;一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Apple apple = new Apple(); //直接初始化，「正射」
apple.setPrice(4);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这样子进行类对象的初始化，我们可以理解为「正」。&lt;/p&gt;
&lt;p&gt;而反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。&lt;/p&gt;
&lt;p&gt;这时候，我们使用 JDK 提供的反射 API 进行反射调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Class clz = Class.forName(&quot;com.chenshuyi.reflect.Apple&quot;);
Method method = clz.getMethod(&quot;setPrice&quot;, int.class);
Constructor constructor = clz.getConstructor();
Object object = constructor.newInstance();
method.invoke(object, 4);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面两段代码的执行结果，其实是完全一样的。但是其思路完全不一样，第一段代码在未运行时就已经确定了要运行的类（Apple），而第二段代码则是在运行时通过字符串值才得知要运行的类（com.chenshuyi.reflect.Apple）。&lt;/p&gt;
&lt;p&gt;所以说什么是反射？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;一个简单的例子&quot;&gt;一个简单的例子&lt;/h2&gt;
&lt;p&gt;上面提到的示例程序，其完整的程序代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Apple {

    private int price;

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }

    public static void main(String[] args) throws Exception{
        //正常的调用
        Apple apple = new Apple();
        apple.setPrice(5);
        System.out.println(&quot;Apple Price:&quot; + apple.getPrice());
        //使用反射调用
        Class clz = Class.forName(&quot;com.chenshuyi.api.Apple&quot;);
        Method setPriceMethod = clz.getMethod(&quot;setPrice&quot;, int.class);
        Constructor appleConstructor = clz.getConstructor();
        Object appleObj = appleConstructor.newInstance();
        setPriceMethod.invoke(appleObj, 14);
        Method getPriceMethod = clz.getMethod(&quot;getPrice&quot;);
        System.out.println(&quot;Apple Price:&quot; + getPriceMethod.invoke(appleObj));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码中可以看到我们使用反射调用了 setPrice 方法，并传递了 14 的值。之后使用反射调用了 getPrice 方法，输出其价格。上面的代码整个的输出结果是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Apple Price:5
Apple Price:14&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从这个简单的例子可以看出，一般情况下我们使用反射获取一个对象的步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取类的 Class 对象实例&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Class clz = Class.forName(&quot;com.zhenai.api.Apple&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;根据 Class 对象实例获取 Constructor 对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Constructor appleConstructor = clz.getConstructor();&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;使用 Constructor 对象的 newInstance 方法获取反射类对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Object appleObj = appleConstructor.newInstance();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而如果要调用某一个方法，则需要经过下面的步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取方法的 Method 对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Method setPriceMethod = clz.getMethod(&quot;setPrice&quot;, int.class);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;利用 invoke 方法调用方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;setPriceMethod.invoke(appleObj, 14);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，我们已经能够掌握反射的基本使用。但如果要进一步掌握反射，还需要对反射的常用 API 有更深入的理解。&lt;/p&gt;
&lt;p&gt;在 JDK 中，反射相关的 API 可以分为下面几个方面：获取反射的 Class 对象、通过反射创建类对象、通过反射获取类属性方法及构造器。&lt;/p&gt;
&lt;h2 id=&quot;反射常用api&quot;&gt;反射常用API&lt;/h2&gt;
&lt;h3 id=&quot;获取反射中的class对象&quot;&gt;获取反射中的Class对象&lt;/h3&gt;
&lt;p&gt;在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。&lt;/p&gt;
&lt;p&gt;在 Java API 中，获取 Class 类对象有三种方法：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;第一种，使用 Class.forName 静态方法。&lt;/em&gt;当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Class clz = Class.forName(&quot;java.lang.String&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;第二种，使用 .class 方法。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这种方法只适合在编译前就知道操作的 Class。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Class clz = String.class;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;第三种，使用类对象的 getClass() 方法。&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String str = new String(&quot;Hello&quot;);
Class clz = str.getClass();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通过反射创建类对象&quot;&gt;通过反射创建类对象&lt;/h3&gt;
&lt;p&gt;通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法。&lt;/p&gt;
&lt;p&gt;第一种：通过 Class 对象的 newInstance() 方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Class clz = Apple.class;
Apple apple = (Apple)clz.newInstance();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二种：通过 Constructor 对象的 newInstance() 方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Class clz = Apple.class;
Constructor constructor = clz.getConstructor();
Apple apple = (Apple)constructor.newInstance();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Class clz = Apple.class;
Constructor constructor = clz.getConstructor(String.class, int.class);
Apple apple = (Apple)constructor.newInstance(&quot;红富士&quot;, 15);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通过反射获取类属性方法构造器&quot;&gt;通过反射获取类属性、方法、构造器&lt;/h3&gt;
&lt;p&gt;我们通过 Class 对象的 getFields() 方法可以获取 Class 类的属性，但无法获取私有属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Class clz = Apple.class;
Field[] fields = clz.getFields();
for (Field field : fields) {
    System.out.println(field.getName());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;price&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而如果使用 Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Class clz = Apple.class;
Field[] fields = clz.getDeclaredFields();
for (Field field : fields) {
    System.out.println(field.getName());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;name
price&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法。&lt;/p&gt;
&lt;h2 id=&quot;反射源码解析&quot;&gt;反射源码解析&lt;/h2&gt;
&lt;p&gt;当我们懂得了如何使用反射后，今天我们就来看看 JDK 源码中是如何实现反射的。或许大家平时没有使用过反射，但是在开发 Web 项目的时候会遇到过下面的异常：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.lang.NullPointerException 
...
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
  at java.lang.reflect.Method.invoke(Method.java:497)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到异常堆栈指出了异常在 Method 的第 497 的 invoke 方法中，其实这里指的 invoke 方法就是我们反射调用方法中的 invoke。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Method method = clz.getMethod(&quot;setPrice&quot;, int.class); 
method.invoke(object, 4);   //就是这里的invoke方法&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如我们经常使用的 Spring 配置中，经常会有相关 Bean 的配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean class=&quot;com.chenshuyi.Apple&quot;&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们在 XML 文件中配置了上面这段配置之后，Spring 便会在启动的时候利用反射去加载对应的 Apple 类。而当 Apple 类不存在或发生启发异常时，异常堆栈便会将异常指向调用的 invoke 方法。&lt;/p&gt;
&lt;p&gt;从这里可以看出，我们平常很多框架都使用了反射，而反射中最最终的就是 Method 类的 invoke 方法了。&lt;/p&gt;
&lt;p&gt;下面我们来看看 JDK 的 invoke 方法到底做了些什么。&lt;/p&gt;
&lt;p&gt;进入 Method 的 invoke 方法我们可以看到，一开始是进行了一些权限的检查，最后是调用了 MethodAccessor 类的 invoke 方法进行进一步处理，如下图红色方框所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3npq6ecr.bkt.clouddn.com/blog/head_first_of_reflect_01.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么 MethodAccessor 又是什么呢？&lt;/p&gt;
&lt;p&gt;其实 MethodAccessor 是一个接口，定义了方法调用的具体操作，而它有三个具体的实现类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sun.reflect.DelegatingMethodAccessorImpl&lt;/li&gt;
&lt;li&gt;sun.reflect.MethodAccessorImpl&lt;/li&gt;
&lt;li&gt;sun.reflect.NativeMethodAccessorImpl&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而要看 ma.invoke() 到底调用的是哪个类的 invoke 方法，则需要看看 MethodAccessor 对象返回的到底是哪个类对象，所以我们需要进入 acquireMethodAccessor() 方法中看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3npq6ecr.bkt.clouddn.com/blog/head_first_of_reflect_02.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从 acquireMethodAccessor() 方法我们可以看到，代码先判断是否存在对应的 MethodAccessor 对象，如果存在那么就复用之前的 MethodAccessor 对象，否则调用 ReflectionFactory 对象的 newMethodAccessor 方法生成一个 MethodAccessor 对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3npq6ecr.bkt.clouddn.com/blog/head_first_of_reflect_03.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 ReflectionFactory 类的 newMethodAccessor 方法里，我们可以看到首先是生成了一个 NativeMethodAccessorImpl 对象，再这个对象作为参数调用 DelegatingMethodAccessorImpl 类的构造方法。&lt;/p&gt;
&lt;p&gt;这里的实现是使用了代理模式，将 NativeMethodAccessorImpl 对象交给 DelegatingMethodAccessorImpl 对象代理。我们查看 DelegatingMethodAccessorImpl 类的构造方法可以知道，其实是将 NativeMethodAccessorImpl 对象赋值给 DelegatingMethodAccessorImpl 类的 delegate 属性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3npq6ecr.bkt.clouddn.com/blog/head_first_of_reflect_04.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以说ReflectionFactory 类的 newMethodAccessor 方法最终返回 DelegatingMethodAccessorImpl 类对象。所以我们在前面的 ma.invoke() 里，其将会进入 DelegatingMethodAccessorImpl 类的 invoke 方法中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3npq6ecr.bkt.clouddn.com/blog/head_first_of_reflect_05.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进入 DelegatingMethodAccessorImpl 类的 invoke 方法后，这里调用了 delegate 属性的 invoke 方法，它又有两个实现类，分别是：DelegatingMethodAccessorImpl 和 NativeMethodAccessorImpl。按照我们前面说到的，这里的 delegate 其实是一个 NativeMethodAccessorImpl 对象，所以这里会进入 NativeMethodAccessorImpl 的 invoke 方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3npq6ecr.bkt.clouddn.com/blog/head_first_of_reflect_06.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而在 NativeMethodAccessorImpl 的 invoke 方法里，其会判断调用次数是否超过阀值（numInvocations）。如果超过该阀值，那么就会生成另一个MethodAccessor 对象，并将原来 DelegatingMethodAccessorImpl 对象中的 delegate 属性指向最新的 MethodAccessor 对象。&lt;/p&gt;
&lt;p&gt;到这里，其实我们可以知道 MethodAccessor 对象其实就是具体去生成反射类的入口。通过查看源码上的注释，我们可以了解到 MethodAccessor 对象的一些设计信息。&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;&quot;Inflation&quot; mechanism. Loading bytecodes to implement Method.invoke() and Constructor.newInstance() currently costs 3-4x more than an invocation via native code for the first invocation (though subsequent invocations have been benchmarked to be over 20x faster).Unfortunately this cost increases startup time for certain applications that use reflection intensively (but only once per class) to bootstrap themselves.&lt;/p&gt;
&lt;p&gt;Inflation 机制。初次加载字节码实现反射，使用 Method.invoke() 和 Constructor.newInstance() 加载花费的时间是使用原生代码加载花费时间的 3 - 4 倍。这使得那些频繁使用反射的应用需要花费更长的启动时间。&lt;/p&gt;
&lt;p&gt;To avoid this penalty we reuse the existing JVM entry points for the first few invocations of Methods and Constructors and then switch to the bytecode-based implementations. Package-private to be accessible to NativeMethodAccessorImpl and NativeConstructorAccessorImpl.&lt;/p&gt;
&lt;p&gt;为了避免这种痛苦的加载时间，我们在第一次加载的时候重用了 JVM 的入口，之后切换到字节码实现的实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就像注释里说的，实际的 MethodAccessor 实现有两个版本，一个是 Native 版本，一个是 Java 版本。&lt;/p&gt;
&lt;p&gt;Native 版本一开始启动快，但是随着运行时间边长，速度变慢。Java 版本一开始加载慢，但是随着运行时间边长，速度变快。正是因为两种存在这些问题，所以第一次加载的时候我们会发现使用的是 NativeMethodAccessorImpl 的实现，而当反射调用次数超过 15 次之后，则使用 MethodAccessorGenerator 生成的 MethodAccessorImpl 对象去实现反射。&lt;/p&gt;
&lt;p&gt;Method 类的 invoke 方法整个流程可以表示成如下的时序图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3npq6ecr.bkt.clouddn.com/blog/head_first_of_reflect_07.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;讲到这里，我们了解了 Method 类的 invoke 方法的具体实现方式。知道了原来 invoke 方法内部有两种实现方式，一种是 native 原生的实现方式，一种是 Java 实现方式，这两种各有千秋。而为了最大化性能优势，JDK 源码使用了代理的设计模式去实现最大化性能。&lt;/p&gt;

</description>
<pubDate>Sun, 11 Feb 2018 06:28:00 +0000</pubDate>
<dc:creator>陈树义</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html</dc:identifier>
</item>
<item>
<title>如何使用Python读取大文件 - DB乐之者</title>
<link>http://www.cnblogs.com/wenBlog/p/8441231.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenBlog/p/8441231.html</guid>
<description>&lt;h2&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;最近处理文本文档时（文件约2GB大小），出现&lt;code&gt;memoryError&lt;/code&gt;&lt;span&gt;错误和文件读取太慢的问题，后来找到了两种比较快&lt;code&gt;Large File Reading&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; 的方法，本文将介绍这两种&lt;a href=&quot;http://www.cnblogs.com/wenBlog/p/8441231.html&quot; target=&quot;_blank&quot;&gt;读取方法&lt;/a&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/wenBlog/p/8441231.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;原味地址&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Preliminary&quot;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;我们谈到“文本处理”时，我们通常是指处理的内容。Python 将文本文件的内容读入可以操作的字符串变量非常容易。文件对象提供了三个“读”方法： &lt;code&gt;.read()&lt;/code&gt;、&lt;code&gt;.readline()&lt;/code&gt; 和 &lt;code&gt;.readlines()&lt;/code&gt;。每种方法可以接受一个变量以限制每次读取的数据量，但它们通常不使用变量。 &lt;code&gt;.read()&lt;/code&gt; 每次读取整个文件，它通常用于将文件内容放到一个字符串变量中。然而&lt;code&gt;.read()&lt;/code&gt; 生成文件内容最直接的字符串表示，但对于连续的面向行的处理，它却是不必要的，并且如果文件大于可用内存，则不可能实现这种处理。下面是&lt;code&gt;read()&lt;/code&gt;方法示例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
f &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/path/to/file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; f.read()
&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; f:
f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　调用&lt;code&gt;read()&lt;/code&gt;会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用&lt;code&gt;read(size)&lt;/code&gt;方法，每次最多读取size个字节的内容。另外，调用&lt;code&gt;readline()&lt;/code&gt;可以每次读取一行内容，调用&lt;code&gt;readlines()&lt;/code&gt;一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　如果文件很小，&lt;code&gt;read()&lt;/code&gt;一次性读取最方便；如果不能确定文件大小，反复调用&lt;code&gt;read(size)&lt;/code&gt;比较保险；如果是配置文件，调用&lt;code&gt;readlines()&lt;/code&gt;最方便：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; f.readlines():
process(line) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;分块读取&lt;/h2&gt;
&lt;p&gt;处理大文件是很容易想到的就是将大文件分割成若干小文件处理，处理完每个小文件后释放该部分内存。这里用了&lt;code&gt;iter 和 yield&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; read_in_chunks(filePath, chunk_size=1024*1024&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
Lazy function (generator) to read a file piece by piece.
Default chunk size: 1M
You can set your own chunk size
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
file_object &lt;/span&gt;=&lt;span&gt; open(filePath)
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
chunk_data &lt;/span&gt;=&lt;span&gt; file_object.read(chunk_size)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; chunk_data:
&lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; chunk_data
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
filePath &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./path/filename&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; chunk &lt;span&gt;in&lt;/span&gt;&lt;span&gt; read_in_chunks(filePath):
process(chunk) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;do something with chunk&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;使用With open()&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;with&lt;/code&gt;语句打开和关闭文件，包括抛出一个内部块异常。&lt;code&gt;for line in f&lt;/code&gt;文件对象&lt;code&gt;f&lt;/code&gt;视为一个迭代器，会自动的采用缓冲&lt;code&gt;IO&lt;/code&gt;和内存管理，所以你不必担心大文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;If the file is line based&lt;/span&gt;
&lt;span&gt;with open(...) as f:
　　&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; f:
　　　　process(line) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;do something with line&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;优化&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;面对百万行的大型数据使用with open 是没有问题的，但是这里面参数的不同也会导致不同的效率。经过测试发先参数为&quot;rb&quot;时的效率是&quot;r&quot;的6倍。由此可知二进制读取依然是最快的模式。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div class=&quot;dp-highlighter bg_python&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
with open(filename,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as f: 

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; fLine &lt;span&gt;in&lt;/span&gt;&lt;span&gt; f: 

    　　&lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;span&gt;测试结果：rb方式最快，100w行全遍历2.9秒。基本能满足中大型文件处理效率需求。如果从&lt;span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;span&gt;二级制&lt;/span&gt;读取)&lt;/span&gt;读取改为r(读取模式)，慢5-6倍。&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;在使用python进行大文件读取时，应该让系统来处理，使用最简单的方式，交给解释器，就管好自己的工作就行了。同时根据不同的需求可以选择不同的读取参数进一步获得更高的性能。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 11 Feb 2018 06:11:00 +0000</pubDate>
<dc:creator>DB乐之者</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenBlog/p/8441231.html</dc:identifier>
</item>
<item>
<title>C#基础拾遗系列之一：先看懂IL代码 - 菠萝吹雪—Code</title>
<link>http://www.cnblogs.com/runningsmallguo/p/8440734.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/runningsmallguo/p/8440734.html</guid>
<description>&lt;p&gt;首先，想说说为什么要写这样系列的文章，有时候在和同事朋友聊天的时候，经常会听到这样的话题：&lt;/p&gt;
&lt;p&gt;（1）在这家公司没什么长进，代码太烂，学不到东西。（你有没有想想框架为什么这样写，代码还可以怎么去优化，比如公司使用Dapper，源码研究过没以及这样封装原因是啥）&lt;/p&gt;
&lt;p&gt;（2）现在只会Ctrl + C  Ctrl +V  ，不排除有时为了效率，包括我自己有时候也懒的写直接复制粘贴  （是不是感觉距离语言的本质越来越远了）&lt;/p&gt;
&lt;p&gt;（3）Ctrl + C  Ctrl +V 时间长了，都有点怀疑自己是否有勇气面试其他公司 （是不是总给自己找借口，年龄大了，不敢疯狂了，当然大家不要误解，我没鼓励大家跳槽）&lt;/p&gt;
&lt;p&gt;（4）干了几年没什么提高 （无论要精通那门技术，我们都应该从其本质出发）&lt;/p&gt;
&lt;p&gt;最近也在反思自己，之前看到博客园大神：fish-li 的一篇文章《Fish Li 该如何帮助您呢？》其中说到：如何做一个有追求的技术人员，受益匪浅。以及张善友老师分享的关于雷果果的技术之路，大家都羡慕这些大神，何曾想过他们背后的付出，不要再抱怨环境不好，环境好也是给这些有准备和有追求的人，很感谢有这样的前辈，现在的社会确实很浮躁，但与我何干，好了毒鸡汤就灌到这里，大家如果有共鸣的话，不要表达出来了，默默想想。&lt;/p&gt;

&lt;p&gt;（1）什么是IL&lt;/p&gt;
&lt;p&gt;IL（Intermediate Language），它也称为CIL或者MSIL，中文就是“中间语言”。IL由ECMA组织（ECMA-335标准）提供完整的定义和规范。我们可以直接把C#源码编译为.exe或dll文件，但是此时编译出来的程序代码并不是CPU能直接执行的二进制代码，而是IL代码。&lt;/p&gt;
&lt;p&gt;（2）反编译工具&lt;/p&gt;
&lt;p&gt;在这里使用ILDasm.exe，不适用其他的反编译工具，这个工具在安装完毕VS2010后就已经存在了，大家可以在开始菜单中输入“IL”关键字进行搜索，如果没有的话，到C：\Program Files(x86)\Microsoft SDKs\Windows\v7.0A\Bin\NETFX4.0Tools&lt;/p&gt;
&lt;p&gt;（3）IL 指令表&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/flyingbirds123/archive/2011/01/29/1947626.html&quot;&gt;IL指令表&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;案例一：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ConsoleApplication1
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; helloString = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            Console.WriteLine(helloString);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/896449/201802/896449-20180211110628201-715309815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看到IL结构：包含MANIFEST文件和ConsoleApplication1，其中MANIFEST是一个清单文件，主要包括程序集的一些属性，例如程序集名称、版本号、哈希算法、程序集模块，以及对外部引用程序的引用项目。.Program类是我们要主要介绍的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/896449/201802/896449-20180211111206482-1843852143.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（1）MANIFEST清单文件介绍&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('92b03558-29f2-44d3-9ddf-43a6190a9053')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_92b03558-29f2-44d3-9ddf-43a6190a9053&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_92b03558-29f2-44d3-9ddf-43a6190a9053&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('92b03558-29f2-44d3-9ddf-43a6190a9053',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_92b03558-29f2-44d3-9ddf-43a6190a9053&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Metadata version: v4.0.30319&lt;/span&gt;
.assembly &lt;span&gt;extern&lt;/span&gt;&lt;span&gt; mscorlib
{
  .publickeytoken &lt;/span&gt;= (B7 7A 5C &lt;span&gt;56&lt;/span&gt; &lt;span&gt;19&lt;/span&gt; &lt;span&gt;34&lt;/span&gt; E0 &lt;span&gt;89&lt;/span&gt; )                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; .z\V.4..&lt;/span&gt;
  .ver &lt;span&gt;4&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
}
.assembly ConsoleApplication1
{
  .custom instance &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; [mscorlib]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = ( &lt;span&gt;01&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;08&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;&lt;span&gt; ) 
  .custom instance &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; [mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = ( &lt;span&gt;01&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;01&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;54&lt;/span&gt; &lt;span&gt;02&lt;/span&gt; &lt;span&gt;16&lt;/span&gt; &lt;span&gt;57&lt;/span&gt; &lt;span&gt;72&lt;/span&gt; &lt;span&gt;61&lt;/span&gt; &lt;span&gt;70&lt;/span&gt; 4E 6F 6E &lt;span&gt;45&lt;/span&gt; &lt;span&gt;78&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ....T..WrapNonEx&lt;/span&gt;
                                                                                                             &lt;span&gt;63&lt;/span&gt; &lt;span&gt;65&lt;/span&gt; &lt;span&gt;70&lt;/span&gt; &lt;span&gt;74&lt;/span&gt; &lt;span&gt;69&lt;/span&gt; 6F 6E &lt;span&gt;54&lt;/span&gt; &lt;span&gt;68&lt;/span&gt; &lt;span&gt;72&lt;/span&gt; 6F &lt;span&gt;77&lt;/span&gt; &lt;span&gt;73&lt;/span&gt; &lt;span&gt;01&lt;/span&gt; )       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ceptionThrows.

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; --- 下列自定义属性会自动添加，不要取消注释 -------
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  .custom instance void [mscorlib]System.Diagnostics.DebuggableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggableAttribute/DebuggingModes) = ( 01 00 07 01 00 00 00 00 ) &lt;/span&gt;
&lt;span&gt;
  .custom instance &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; [mscorlib]System.Reflection.AssemblyTitleAttribute::.ctor(&lt;span&gt;string&lt;/span&gt;) = ( &lt;span&gt;01&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;13&lt;/span&gt; &lt;span&gt;43&lt;/span&gt; 6F 6E &lt;span&gt;73&lt;/span&gt; 6F 6C &lt;span&gt;65&lt;/span&gt; &lt;span&gt;41&lt;/span&gt; &lt;span&gt;70&lt;/span&gt; &lt;span&gt;70&lt;/span&gt; 6C &lt;span&gt;69&lt;/span&gt; &lt;span&gt;63&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...ConsoleApplic&lt;/span&gt;
                                                                                              &lt;span&gt;61&lt;/span&gt; &lt;span&gt;74&lt;/span&gt; &lt;span&gt;69&lt;/span&gt; 6F 6E &lt;span&gt;31&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; )                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ation1..&lt;/span&gt;
  .custom instance &lt;span&gt;void&lt;/span&gt; [mscorlib]System.Reflection.AssemblyDescriptionAttribute::.ctor(&lt;span&gt;string&lt;/span&gt;) = ( &lt;span&gt;01&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;&lt;span&gt; ) 
  .custom instance &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; [mscorlib]System.Reflection.AssemblyConfigurationAttribute::.ctor(&lt;span&gt;string&lt;/span&gt;) = ( &lt;span&gt;01&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;&lt;span&gt; ) 
  .custom instance &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; [mscorlib]System.Reflection.AssemblyCompanyAttribute::.ctor(&lt;span&gt;string&lt;/span&gt;) = ( &lt;span&gt;01&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;&lt;span&gt; ) 
  .custom instance &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; [mscorlib]System.Reflection.AssemblyProductAttribute::.ctor(&lt;span&gt;string&lt;/span&gt;) = ( &lt;span&gt;01&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;13&lt;/span&gt; &lt;span&gt;43&lt;/span&gt; 6F 6E &lt;span&gt;73&lt;/span&gt; 6F 6C &lt;span&gt;65&lt;/span&gt; &lt;span&gt;41&lt;/span&gt; &lt;span&gt;70&lt;/span&gt; &lt;span&gt;70&lt;/span&gt; 6C &lt;span&gt;69&lt;/span&gt; &lt;span&gt;63&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...ConsoleApplic&lt;/span&gt;
                                                                                                &lt;span&gt;61&lt;/span&gt; &lt;span&gt;74&lt;/span&gt; &lt;span&gt;69&lt;/span&gt; 6F 6E &lt;span&gt;31&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; )                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ation1..&lt;/span&gt;
  .custom instance &lt;span&gt;void&lt;/span&gt; [mscorlib]System.Reflection.AssemblyCopyrightAttribute::.ctor(&lt;span&gt;string&lt;/span&gt;) = ( &lt;span&gt;01&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;12&lt;/span&gt; &lt;span&gt;43&lt;/span&gt; 6F &lt;span&gt;70&lt;/span&gt; &lt;span&gt;79&lt;/span&gt; &lt;span&gt;72&lt;/span&gt; &lt;span&gt;69&lt;/span&gt; &lt;span&gt;67&lt;/span&gt; &lt;span&gt;68&lt;/span&gt; &lt;span&gt;74&lt;/span&gt; &lt;span&gt;20&lt;/span&gt; C2 A9 &lt;span&gt;20&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...Copyright .. &lt;/span&gt;
                                                                                                  &lt;span&gt;20&lt;/span&gt; &lt;span&gt;32&lt;/span&gt; &lt;span&gt;30&lt;/span&gt; &lt;span&gt;31&lt;/span&gt; &lt;span&gt;38&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; )                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  2018..&lt;/span&gt;
  .custom instance &lt;span&gt;void&lt;/span&gt; [mscorlib]System.Reflection.AssemblyTrademarkAttribute::.ctor(&lt;span&gt;string&lt;/span&gt;) = ( &lt;span&gt;01&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;&lt;span&gt; ) 
  .custom instance &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; [mscorlib]System.Runtime.InteropServices.ComVisibleAttribute::.ctor(&lt;span&gt;bool&lt;/span&gt;) = ( &lt;span&gt;01&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;&lt;span&gt; ) 
  .custom instance &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; [mscorlib]System.Runtime.InteropServices.GuidAttribute::.ctor(&lt;span&gt;string&lt;/span&gt;) = ( &lt;span&gt;01&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;24&lt;/span&gt; &lt;span&gt;62&lt;/span&gt; &lt;span&gt;35&lt;/span&gt; &lt;span&gt;32&lt;/span&gt; &lt;span&gt;39&lt;/span&gt; &lt;span&gt;36&lt;/span&gt; &lt;span&gt;38&lt;/span&gt; &lt;span&gt;63&lt;/span&gt; &lt;span&gt;32&lt;/span&gt; 2D &lt;span&gt;64&lt;/span&gt; &lt;span&gt;66&lt;/span&gt; &lt;span&gt;63&lt;/span&gt; &lt;span&gt;33&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ..$b52968c2-dfc3&lt;/span&gt;
                                                                                                  2D &lt;span&gt;34&lt;/span&gt; &lt;span&gt;65&lt;/span&gt; &lt;span&gt;38&lt;/span&gt; &lt;span&gt;31&lt;/span&gt; 2D &lt;span&gt;38&lt;/span&gt; &lt;span&gt;32&lt;/span&gt; &lt;span&gt;64&lt;/span&gt; &lt;span&gt;32&lt;/span&gt; 2D &lt;span&gt;64&lt;/span&gt; &lt;span&gt;39&lt;/span&gt; &lt;span&gt;66&lt;/span&gt; &lt;span&gt;35&lt;/span&gt; &lt;span&gt;62&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -4e81-82d2-d9f5b&lt;/span&gt;
                                                                                                  &lt;span&gt;62&lt;/span&gt; &lt;span&gt;33&lt;/span&gt; &lt;span&gt;32&lt;/span&gt; &lt;span&gt;38&lt;/span&gt; &lt;span&gt;33&lt;/span&gt; &lt;span&gt;64&lt;/span&gt; &lt;span&gt;37&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; )                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; b3283d7..&lt;/span&gt;
  .custom instance &lt;span&gt;void&lt;/span&gt; [mscorlib]System.Reflection.AssemblyFileVersionAttribute::.ctor(&lt;span&gt;string&lt;/span&gt;) = ( &lt;span&gt;01&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;07&lt;/span&gt; &lt;span&gt;31&lt;/span&gt; 2E &lt;span&gt;30&lt;/span&gt; 2E &lt;span&gt;30&lt;/span&gt; 2E &lt;span&gt;30&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; )             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...1.0.0.0..&lt;/span&gt;
  .custom instance &lt;span&gt;void&lt;/span&gt; [mscorlib]System.Runtime.Versioning.TargetFrameworkAttribute::.ctor(&lt;span&gt;string&lt;/span&gt;) = ( &lt;span&gt;01&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; 1C 2E 4E &lt;span&gt;45&lt;/span&gt; &lt;span&gt;54&lt;/span&gt; &lt;span&gt;46&lt;/span&gt; &lt;span&gt;72&lt;/span&gt; &lt;span&gt;61&lt;/span&gt; 6D &lt;span&gt;65&lt;/span&gt; &lt;span&gt;77&lt;/span&gt; 6F &lt;span&gt;72&lt;/span&gt; 6B   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ....NETFramework&lt;/span&gt;
                                                                                                        2C &lt;span&gt;56&lt;/span&gt; &lt;span&gt;65&lt;/span&gt; &lt;span&gt;72&lt;/span&gt; &lt;span&gt;73&lt;/span&gt; &lt;span&gt;69&lt;/span&gt; 6F 6E 3D &lt;span&gt;76&lt;/span&gt; &lt;span&gt;34&lt;/span&gt; 2E &lt;span&gt;35&lt;/span&gt; 2E &lt;span&gt;32&lt;/span&gt; &lt;span&gt;01&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ,Version=v4.5.2.&lt;/span&gt;
                                                                                                        &lt;span&gt;00&lt;/span&gt; &lt;span&gt;54&lt;/span&gt; 0E &lt;span&gt;14&lt;/span&gt; &lt;span&gt;46&lt;/span&gt; &lt;span&gt;72&lt;/span&gt; &lt;span&gt;61&lt;/span&gt; 6D &lt;span&gt;65&lt;/span&gt; &lt;span&gt;77&lt;/span&gt; 6F &lt;span&gt;72&lt;/span&gt; 6B &lt;span&gt;44&lt;/span&gt; &lt;span&gt;69&lt;/span&gt; &lt;span&gt;73&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; .T..FrameworkDis&lt;/span&gt;
                                                                                                        &lt;span&gt;70&lt;/span&gt; 6C &lt;span&gt;61&lt;/span&gt; &lt;span&gt;79&lt;/span&gt; 4E &lt;span&gt;61&lt;/span&gt; 6D &lt;span&gt;65&lt;/span&gt; &lt;span&gt;14&lt;/span&gt; 2E 4E &lt;span&gt;45&lt;/span&gt; &lt;span&gt;54&lt;/span&gt; &lt;span&gt;20&lt;/span&gt; &lt;span&gt;46&lt;/span&gt; &lt;span&gt;72&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; playName..NET Fr&lt;/span&gt;
                                                                                                        &lt;span&gt;61&lt;/span&gt; 6D &lt;span&gt;65&lt;/span&gt; &lt;span&gt;77&lt;/span&gt; 6F &lt;span&gt;72&lt;/span&gt; 6B &lt;span&gt;20&lt;/span&gt; &lt;span&gt;34&lt;/span&gt; 2E &lt;span&gt;35&lt;/span&gt; 2E &lt;span&gt;32&lt;/span&gt; )          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; amework 4.5.2&lt;/span&gt;
  .hash algorithm &lt;span&gt;0x00008004&lt;/span&gt;&lt;span&gt;
  .ver &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
}
.module ConsoleApplication1.exe
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; MVID: {A09A2101-9A49-483A-A224-5D2E14D231A6}&lt;/span&gt;
.imagebase &lt;span&gt;0x00400000&lt;/span&gt;&lt;span&gt;
.file alignment &lt;/span&gt;&lt;span&gt;0x00000200&lt;/span&gt;&lt;span&gt;
.stackreserve &lt;/span&gt;&lt;span&gt;0x00100000&lt;/span&gt;&lt;span&gt;
.subsystem &lt;/span&gt;&lt;span&gt;0x0003&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; WINDOWS_CUI&lt;/span&gt;
.corflags &lt;span&gt;0x00020003&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  ILONLY 32BITREQUIRED
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Image base: 0x01110000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;介绍：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/896449/201802/896449-20180211111636795-1832024248.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;指定当前程序集需要引用的外部程序集，如上面 ConsoleApplication1.exe就是引用了mscorlib.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.publickeytoken = (标记 )&lt;/strong&gt; &lt;span&gt;指定所引用程序集的实际公钥标记。公钥能唯一确定程序集。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.ver&lt;/strong&gt;：&lt;span&gt;指定引用程序集的版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/896449/201802/896449-20180211112238732-138727898.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.assembly 程序集名称&lt;/strong&gt;  &lt;span&gt;指定程序集名称&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/896449/201802/896449-20180211112342701-796349046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.hash algorithm int32值 &lt;/strong&gt; ：  &lt;span&gt;指定使用的hash算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;.ver :指定程序集版本号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/896449/201802/896449-20180211112538435-984222948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.module ConsoleApplication1.exe&lt;/strong&gt;    &lt;span&gt;指定组成程序集的模块名称，在此示例中，程序集中只包含一个文件&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;.subsystem 0x0003 // WINDOWS_CUI&lt;/strong&gt;  &lt;span&gt;指定程序要求的应用程序环境。在此示例中，0x0003表示该可执行文件从控制台运行&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;.corflags 0x00020003 // ILONLY 32BITREQUIRED&lt;/strong&gt; &lt;span&gt;当前是元数据中的一个保留字段&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/896449/201802/896449-20180211113121451-881183676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.class表示的Program是一个类，extends 代表Program类继承于程序集mscorlib中的System.Object类，这就告诉我们，在C#中所有的类的父类都是Object。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;private为访问权限，表明该类是私有的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;auto：表明程序加载的时候内存布局是有CLR决定的，而不是由程序本身控制的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ansi:表明类的编码为ansi编码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;beforefieldinit ：表明CLR可以在第一次访问静态字段之前的任何时刻执行类型构造函数。类型构造函数也就是构造函数，而使用beforefieldinit属性可以提高性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/896449/201802/896449-20180211114351982-445894811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.ctor&lt;/strong&gt; &lt;span&gt;表示构造函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cil managed&lt;/strong&gt; &lt;span&gt;表明方法体中的代码是IL代码，且是托管代码，即运行在CLR运行库中的代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.maxstack&lt;/strong&gt; &lt;span&gt;表明执行构造函数时，评估堆栈可容纳数据项的最大个数。评估堆栈是保存方法中所需变量的值的一个内存区域，该区域在方法执行结束时会被清空，或者存储一个返回值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IL_0000&lt;/span&gt;&lt;strong&gt;是代码行的开头&lt;/strong&gt;。&lt;span&gt;一般在IL_标记之前的部分为变量的声明和初始化操作&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ldarg.0&lt;/span&gt;&lt;strong&gt;表明加载第一个成员参数，其中ldarg是load argument 的缩&lt;/strong&gt;写&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;call 指令一般用于调用静态方法，而这段代码中call指令并不是在调用静态函数，而是调用System.Object构造函数。另外一个指令则一般用来调用实例方法，它的调用过程是：首先检查被调用的函数是否为虚函数，&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果不是就直接调用，如果是则检查子类是否重写，如果有重写就调用子类中的实现，如果没有重写就继续调用原来函数。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ret 指令表示执行完毕&lt;/span&gt;，就是return的缩写&lt;/p&gt;

&lt;p&gt;最后是Main函数，它是应用程序的入口函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/896449/201802/896449-20180211120451654-1402338139.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hidebysig&lt;/strong&gt; ：&lt;span&gt;指令表示如果当前类作为父类，用该指令标记的方法将不会被子类继承&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.entrypoint&lt;/strong&gt; ：&lt;span&gt;指令代表该函数是程序的入口函数，每个托管应用程序都有且只有一个入口函数，CLR加载的时候，首先从.entrypoint函数开始执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.locals init ([0] string helloString)&lt;/strong&gt; &lt;span&gt;表示定义string 类型的变量，变量名成为：helloString&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;IL_0000: nop 表示不做任何操作 No Operation&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ldstr &quot;Hello World&quot; :  ldstr:推送对元数据中存储的字符串的新对象引用   表示：将字符串“Hello World” 压入评估栈，此时“Hello World” 处于评估栈的栈定，栈是一种数据结构，具有先进后出的特性。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;stloc.0 &lt;/span&gt;&lt;/strong&gt; :从计算堆栈的顶部弹出当前值并将其存储到索引 0 处的局部变量列表中（也就helloString）  在此示例中：就是把字符串&quot;Hello World&quot; 赋值给变量helloString&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ldloc.0&lt;/strong&gt;&lt;/span&gt; ：将索引 0 处的局部变量加载到计算堆栈上。也就是：把变量helloString 加载到计算堆栈上&lt;/p&gt;
&lt;p&gt;（以ld为前缀的指令表示：入栈操作  st为前缀的指令则代表着出栈操作）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;call :指令表示调用静态函数&lt;/span&gt;， 这里调用的是Console类中的WriteLine函数，把第0个局部变量输出到控制台中&lt;/p&gt;
&lt;p&gt;案例二：&lt;/p&gt;
&lt;p&gt;（1）IL基本类型&lt;/p&gt;
&lt;p&gt;任何都有其内置的类型，IL语言也不例外，因为C#语言最终都会编译成IL代码，所以两者必然存在一种对应关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/896449/201802/896449-20180211142401795-1221790176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; （2）IL变量的声明&lt;/p&gt;
&lt;p&gt;.locals 指令代表变量的声明，声明语句放在IL_标记前面。例如在前面的程序中，&lt;/p&gt;
&lt;p&gt;.locals init ([0] string helloString)  就声明了一个名为helloString的变量，其中类型为string&lt;/p&gt;
&lt;p&gt;（3）基本运算符&lt;/p&gt;
&lt;p&gt;算数运算符：加法指令add   、乘法指令sub、出发指令div、以及求余指令rem等&lt;/p&gt;
&lt;p&gt;位运算符：包括一元指令not 、与指令and、或指令or，结果以1 和 0 分别表示真、假，运算结果压入评估栈栈顶&lt;/p&gt;
&lt;p&gt;比较运算：包括大于指令cgt、小于指令clt 和等于指令 ceq&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ILAdd
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result = i +&lt;span&gt; j;

            Console.WriteLine(result);

        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/896449/201802/896449-20180211130433076-1305304528.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; IL代码分析如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bb215513-ffa1-474e-98ae-6f6b2b86c62d')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_bb215513-ffa1-474e-98ae-6f6b2b86c62d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bb215513-ffa1-474e-98ae-6f6b2b86c62d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bb215513-ffa1-474e-98ae-6f6b2b86c62d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bb215513-ffa1-474e-98ae-6f6b2b86c62d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
.method &lt;span&gt;private&lt;/span&gt; hidebysig &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;  Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args) cil managed
{
  .entrypoint
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代码大小       17 (0x11)&lt;/span&gt;
  .maxstack  &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明三个变量&lt;/span&gt;
  .locals init ([&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] int32 i,
           [&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;] int32 j,
           [&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;] int32 result)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不做任何操作&lt;/span&gt;
&lt;span&gt;  IL_0000:  nop
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将整数值 2以4字节 作为 int32 推送到计算堆栈上&lt;/span&gt;
  IL_0001:  ldc.i4.&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把评估栈顶的值弹出，并赋值给第0个局部变量（即 i）,等价于i = 2&lt;/span&gt;
  IL_0002:  stloc.&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将整数值 3以4字节 作为 int32 推送到计算堆栈上&lt;/span&gt;
  IL_0003:  ldc.i4.&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把评估栈顶的值弹出，并赋值给第1个局部变量（即 j）,等价于j = 2&lt;/span&gt;
  IL_0004:  stloc.&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把第0个变量压入评估栈，即把变量 i 压入评估栈&lt;/span&gt;
  IL_0005:  ldloc.&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把第1个变量压入评估栈，即把变量 j 压入评估栈&lt;/span&gt;
  IL_0006:  ldloc.&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行add操作，之后将把变量i和j清空，并把操作结果保存在评估栈站顶&lt;/span&gt;
&lt;span&gt;  IL_0007:  add
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把站顶的值弹出，并赋值给第二个局部变量（即result） ，此时result即为i+j 的值，因为栈顶为两个值的和&lt;/span&gt;
  IL_0008:  stloc.&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将索引 2 处的局部变量加载到计算堆栈上。就是result&lt;/span&gt;
  IL_0009:  ldloc.&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;call调用静态函数&lt;/span&gt;
  IL_000a:  call       &lt;span&gt;void&lt;/span&gt;&lt;span&gt; [mscorlib]System.Console::WriteLine(int32)
  IL_000f:  nop
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回&lt;/span&gt;
&lt;span&gt;  IL_0010:  ret
} &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; end of method Program::Main&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i&amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i为正数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i为0或负数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IL分析如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('64855af4-0da9-479f-a750-cd24ecac1c1b')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_64855af4-0da9-479f-a750-cd24ecac1c1b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_64855af4-0da9-479f-a750-cd24ecac1c1b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('64855af4-0da9-479f-a750-cd24ecac1c1b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_64855af4-0da9-479f-a750-cd24ecac1c1b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
.method &lt;span&gt;private&lt;/span&gt; hidebysig &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;  Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args) cil managed
{
  .entrypoint
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代码大小       40 (0x28)&lt;/span&gt;
  .maxstack  &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
  .locals init ([&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] int32 i,
           [&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; V_1)
  IL_0000:  nop
  IL_0001:  ldc.i4.&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
  IL_0002:  stloc.&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  IL_0003:  ldloc.&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  IL_0004:  ldc.i4.&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行大于指令，比较i与0,运算结果存在于评估栈栈顶，1表示真，即i&amp;gt;0为真&lt;/span&gt;
&lt;span&gt;  IL_0005:  cgt
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;就是把比较后的值赋值个变量V_1&lt;/span&gt;
  IL_0007:  stloc.&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把变量V_1压入评估栈&lt;/span&gt;
  IL_0008:  ldloc.&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果 value 为 false、空引用或零，则将控制转移到目标指令 &lt;/span&gt;
&lt;span&gt;  IL_0009:  brfalse.s  IL_001a
  IL_000b:  nop
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;推送对元数据中存储的字符串的新对象引用。&lt;/span&gt;
  IL_000c:  ldstr      bytearray (&lt;span&gt;69&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; 3A 4E &lt;span&gt;63&lt;/span&gt; 6B &lt;span&gt;70&lt;/span&gt; &lt;span&gt;65&lt;/span&gt; )                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; i.:Nckpe&lt;/span&gt;
  IL_0011:  call       &lt;span&gt;void&lt;/span&gt; [mscorlib]System.Console::WriteLine(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;)
  IL_0016:  nop
  IL_0017:  nop
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无条件地将控制转移到目标指令（短格式）&lt;/span&gt;
&lt;span&gt;  IL_0018:  br.s       IL_0027
  IL_001a:  nop
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;推送对元数据中存储的字符串的新对象引用。&lt;/span&gt;
  IL_001b:  ldstr      bytearray (&lt;span&gt;69&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; 3A 4E &lt;span&gt;30&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;16&lt;/span&gt; &lt;span&gt;62&lt;/span&gt; 1F 8D &lt;span&gt;70&lt;/span&gt; &lt;span&gt;65&lt;/span&gt; )             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; i.:N0..b..pe&lt;/span&gt;
  IL_0020:  call       &lt;span&gt;void&lt;/span&gt; [mscorlib]System.Console::WriteLine(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;)
  IL_0025:  nop
  IL_0026:  nop
  IL_0027:  ret
} &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; end of method Program::Main&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;案例三：const的本质&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1b9517b2-0ffc-47c3-b799-078e7c0270d4')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_1b9517b2-0ffc-47c3-b799-078e7c0270d4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1b9517b2-0ffc-47c3-b799-078e7c0270d4&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1b9517b2-0ffc-47c3-b799-078e7c0270d4',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1b9517b2-0ffc-47c3-b799-078e7c0270d4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ConstIL
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
　　　　　　　
            Console.WriteLine(Person.num);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 这个就是一个所谓的const常量
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; num = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; IL代码分析：&lt;/p&gt;
&lt;p&gt;为什么可以直接类名.num？这种语法只有在该常量为static修饰是才可以，下面我们来看看IL：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/896449/201802/896449-20180211134836263-1964025678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
.field public static literal int32 num = int32(0x0000000A)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 看到没，const其实就是一个static的变量，一个静态的值，因为它是跟着类走的。而不是实例。所以 const的特征如下：&lt;/p&gt;
&lt;p&gt;（1）固定不变的值。&lt;/p&gt;
&lt;p&gt;（2）在编译的时候就已经确定了。&lt;/p&gt;
&lt;p&gt;（3）在初始化的时候设置值&lt;/p&gt;

&lt;p&gt;好了，先写到这里，回家前写这一篇，希望对你有帮助。&lt;/p&gt;

&lt;p&gt; 参考书籍：《Learning Hard》&lt;/p&gt;
&lt;p&gt;参考文章：http://www.cnblogs.com/flyingbirds123/archive/2011/01/29/1947626.html&lt;/p&gt;

&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;作者：郭峥&lt;/p&gt;
&lt;p&gt;出处：http://www.cnblogs.com/runningsmallguo/&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 11 Feb 2018 06:00:00 +0000</pubDate>
<dc:creator>菠萝吹雪—Code</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/runningsmallguo/p/8440734.html</dc:identifier>
</item>
<item>
<title>由阅读源码想到 | 下篇 - kid551</title>
<link>http://www.cnblogs.com/kid551/p/8441153.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kid551/p/8441153.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/672506/201802/672506-20180211133934826-351947059.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;2.9411764705882&quot;&gt;
&lt;p&gt;本文承接上篇：《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484162&amp;amp;idx=1&amp;amp;sn=09e32f3bb4deea92acc02a713b16ab63&amp;amp;chksm=ec20e4bedb576da823fa42563405b770828bb8680840ddf98b51fc9285d7b3a216d226be3494&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;由阅读源码想到&lt;/a&gt;》。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那为何你在数学上又有如此的勇气和魄力，去阅读那些一天甚至几天只能进展一页的大部头呢？我想，这倒不是因为它是数学，而是年少时的浪漫情怀，以及更本质的：竞争中的优越感。&lt;/p&gt;
&lt;p&gt;对于青年时期的自我来说，艰苦本身是值得期许或者追求的事情（类似于“为赋新词强说愁”）。你不会因为你处境的艰苦而垂头丧气、痛苦不已。相反，你期待这份艰苦，期待这份众人的不理解，因为似乎唯有这样，你才感觉你离那些传说中的人物更近些。艰苦本身似乎是在告诉你：“不是说天降大任要先苦其心志么，你看我现在多辛苦啊，看来大任必然是我的了。”你会因为颠倒的充分必要条件而让自己对艰苦期待不已。&lt;/p&gt;&lt;p&gt;回忆起来，就连自己最开始做数学的理由，也并不怎么高尚。虽然无数次地告诉自己，我是像那些伟大的数学大师一般，被数学的内在趣味和魅力所吸引，在上天的引领下走上了这条光辉的道路。可真相是，我是因为小孩子的虚荣心和在群体中的荣誉感而走上了这条路。&lt;/p&gt;
&lt;p&gt;读书时，周围不断地在向你发声，不断重复地灌输一个观点：数学是困难的，数学是科学的皇后因而是一切理科的前提，学好数学才可以学好后门的物理和化学。与此同时，老师对学生的“引导”也颇有偏见（虽然现在想来，这也可以看作是份善意的偏见）。班里最受老师宠溺挂在嘴边表扬的，永远是那群站在数学之巅的同学，似乎其它成绩和优势都无法与之媲美。&lt;/p&gt;
&lt;p&gt;于是，普通到不能再不同的我，自然而然地成了环境的产物：成为一个数学的爱好者。而实际目的是，成为老师终日夸奖的学生，成为班里有优越感的学生，得到周围同学羡慕的眼光。于是，披着爱好数学的外衣，我开始花大力气去研究数学、钻研数学，将与它相关的所有东西都拿来阅读和学习。&lt;/p&gt;&lt;p&gt;在这条路上，或许是花费足够巨大，以至于当周围的人已经不再以数学作为炫耀资本时，我依旧坚守在这条道路上。这或许是因为读了很多数学相关的东西，人物传记、历史发展，而在这些材料面，其内容当然会不断地做自我营销，暗示自己：学习数学是少数者的荣耀。大部分人都无法理解它，或是想要理解却不能，于是只好放弃。学习数学是一份特殊的光荣，而这份光荣，只有心智卓越者方能承受。&lt;/p&gt;&lt;p&gt;毕竟年少阅历贫瘠，我完全没有意识到这样的“宣传”，充满了异端邪教的味道。它背后的逻辑是：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;你应该从事A，因为A好。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;为什么A好呢？因为理解不了A的好处的人，都是笨蛋。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;而你是聪明人，A的好，你应该是理解的吧。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;所以，为什么A好呢？你自己知道。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;整个一个“皇帝的新衣”改良版，真是太阳底下无鲜事，都是不断演重复上演的历史。&lt;/p&gt;&lt;p&gt;这样来看，这份对数学的坚持，不过是一个以“虚荣的邀宠”作开始，又以“宗教的布道”作持续。而因这份坚持所承受的所有甘苦，反倒因布道中充斥的“因艰苦而伟大、因困难而荣耀的故事”，被一一忽略漠视了。甚至更确切地说，你开始因布道的蛊惑而开始享受这样的艰难困苦，享受“长时间的投入却只能带来少许回报”的低产，因为你是那个心智卓尔不群的特别的人，你走在少数人的路上。&lt;/p&gt;&lt;p&gt;而等到年长以后，经历了生活的艰辛、欺骗与不公，这份“数学的执着”开始出现裂痕。愤怒、不满、失去耐心，一切负面的情绪开始席卷这份原始的热爱。即便是数学为我带来了许多不可磨灭的价值：清晰的逻辑、举一反三的能力、变态式的通悟，以及掌握本质的贯穿力。&lt;/p&gt;
&lt;p&gt;曾经以为，这是多么不得了的价值观的挫败与蜕变。而现在看来，这不过是解开了那张披着“热爱数学”的狼皮，显露出了真正的追求——群体竞争中的优越感。原来我感兴趣的不是数学，而是群体中的优越感。当优越感在学生时代以数学提现时，我便热爱数学；当优越感在年长后以金钱与名誉体现时，我便热爱事业。这边是令人厌恶的伪善。可是，想要认清自己，并不是件容易的事情。因为它不仅涉及到你是否愿意，还取决于你当前是否有这个实力与洞察力，去看清被隐藏的“自欺”。&lt;/p&gt;
&lt;p&gt;考察了上面这段经历，再回到阅读源码这件事情上。阅读源码，同做数学一样，投入巨大回报微小，并且这份回报往往还无法以金钱的方式来呈现。那么，摆在你面前的就几条路：&lt;/p&gt;

&lt;p&gt;（一）&lt;/p&gt;
&lt;p&gt;要么你好好地追问一下自己，自己是否真的是热爱编程？你从事这份职业的初衷，是否真的是因为它在智慧挑战上独有的魅力。如果不是，那么是否可以考虑从事其它你真正感兴趣的行业。&lt;/p&gt;
&lt;p&gt;这是一条相对理想主义的建议，但却也不得不罗列，因为这是更进一步考虑的根基。&lt;/p&gt;

&lt;p&gt;（二）&lt;/p&gt;
&lt;p&gt;那么更现实来讲，你很可能同我一样，也是因为群体优越感的吸引进入了这个行业，又或者是，因为当前的薪酬优越，所以毅然决然地投入这个行业。无论是哪种，你的处境都比较纠结，你没有真心的纯粹的热爱，但却又不得不做这件高投入低产出的事情。&lt;/p&gt;
&lt;p&gt;更细致地讲，即便是你真心热爱这份事业，你也会有倦怠期，也会在这样阴郁的时期低落消沉，但又偏偏赶巧，逼着你得持续阅读，以赶完工期。&lt;/p&gt;
&lt;p&gt;那么，这时候，你或许可以反过来，好好地使用宗教的布道。去大量地阅读鸡汤、阅读你这个领域里先辈的艰苦故事、去历史的海洋里找寻一个个比你不幸生活艰辛的人物故事吧。然后用“皇帝新衣”式的逻辑为自己营造一种浪漫主义式的、自我感动的氛围。去拥抱艰辛、拥抱悲鸣，用苦难去实现自己荣誉上的满足。在这样的“你清楚自己的原始初衷、却又不得不妥协于现实压力和制约”的尴尬处境，便不再需要干净的逻辑，只需要干练地使用这份感性的兴奋剂，麻醉自我并让自己坚持下去。&lt;/p&gt;
&lt;p&gt;如果非要讨论理性，我也可以给出一个答案，在某种意义上，这无非就是人类心理的自我保护机制。这是宗教得以建立信仰的本质。通过臆造神话和意义，去消解生活中的不幸。运用这份布道和扭曲逻辑的“信仰强力”，来阻止内心的崩塌。按照“历史”的说法：只要你有信仰，你就能上刀山下火海，能够抵御敌人的严刑拷打。因为，越是苦痛，越是能够激发你内心的成就感与满足感。你不会因为肉体的极端痛苦而丧失自己我，走向精神的崩坏。相反，你会因为这些苦痛而不断地升华、不断地感觉自己战果斐然、成就卓越。&lt;/p&gt;
&lt;p&gt;通过这份心理的扭曲和欺骗，&lt;strong&gt;你的精神战胜了你肉体的极限&lt;/strong&gt;。（爱，同是这样的精神力量的另一种形式。）&lt;/p&gt;&lt;p&gt;（P.S.：现代人的空虚，无非就是信仰的匮乏，缺乏宗教一般强烈的“精神毒品”。倒不一定将它看作是贬义的。尼采在宣称上帝已死之后，便指出了一条路：你能通过自己的标准，去建立你自己的善与恶吗？！）&lt;/p&gt;

&lt;p&gt;（三）&lt;/p&gt;
&lt;p&gt;再进一步，如果你能够突破精神上的这层诱骗，像一个成年人那样去清醒地接受现实，达到老子所说的境界“以万物为刍狗”。不偏不倚，耐心地花功夫，长时间地做事情。既不是享受痛苦，也不是因为对痛苦的不满而拒绝痛苦。而是可以心平气和地接受这份痛苦：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;因为这项事业就是需要这么多的付出与艰辛，&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;因为这份事业就是在做西西弗斯的推石之旅，不断地读了忘、忘了读，&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;因为这份事业就是任重而道远，有无数厚砖头的书等着你去啃可你每天又只能进步一两页，它就是这么低产&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而我又确实需要完成这件事情。那么，按照这件事自身的规律和特点，一一做完就好。没有喜怒哀乐，它仅仅是一份需要按照特定步骤做完的工作而已。&lt;/p&gt;
&lt;p&gt;所以，哪一种方式更好呢？这取决于你自己对当前处境的判断，以及你实践之后的耐心调整。&lt;/p&gt;




&lt;p&gt;&lt;strong&gt;近期回顾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484162&amp;amp;idx=1&amp;amp;sn=09e32f3bb4deea92acc02a713b16ab63&amp;amp;chksm=ec20e4bedb576da823fa42563405b770828bb8680840ddf98b51fc9285d7b3a216d226be3494&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;由阅读源码想到&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484156&amp;amp;idx=1&amp;amp;sn=2715fa6c7da75533146542fcc8a26307&amp;amp;chksm=ec20e540db576c56366976975ef5b79be3236efeaddb6dd0627254838ab70559ac6da3363af6&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;志玲姐姐的《十三邀》&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484152&amp;amp;idx=1&amp;amp;sn=a806d2d92eb9655f3a22b15c34c832ed&amp;amp;chksm=ec20e544db576c5293e6d638a38f7ef97de55e1d833abc9cc47245a31be75d412018abb1c5e6&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;2018年01月写字总结&lt;/a&gt;》&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;如果你喜欢我的文章或分享，请长按下面的二维码关注我的微信公众号，谢谢！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxO9bdR9L0kttlgPe8JlGY87dGprLDyYXqdZWbhAxcETGrnWXCm3UgREhBG7DE3y9FknUCbYCUuuBg/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; width=&quot;auto&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxO9bdR9L0kttlgPe8JlGY87dGprLDyYXqdZWbhAxcETGrnWXCm3UgREhBG7DE3y9FknUCbYCUuuBg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1240&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;   &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;VIP赞赏专区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxM4uGL2UpKV92GZ6XjwDoShRKLD8ib7bibuGZVibkyhQ0At2IS64V9GX4ib91xibovBtibt7qicowFpvibP1Q/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; width=&quot;57%&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxM4uGL2UpKV92GZ6XjwDoShRKLD8ib7bibuGZVibkyhQ0At2IS64V9GX4ib91xibovBtibt7qicowFpvibP1Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1152&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 11 Feb 2018 05:41:00 +0000</pubDate>
<dc:creator>kid551</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kid551/p/8441153.html</dc:identifier>
</item>
<item>
<title>Android开发之漫漫长途 XIV——ListView - 忘了12138</title>
<link>http://www.cnblogs.com/wangle12138/p/8441136.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangle12138/p/8441136.html</guid>
<description>&lt;p&gt;&lt;em&gt;该文章是一个系列文章，是本人在Android开发的漫漫长途上的一点感想和记录，我会尽量按照先易后难的顺序进行编写该系列。该系列引用了《Android开发艺术探索》以及《深入理解Android 卷Ⅰ，Ⅱ，Ⅲ》中的相关知识，另外也借鉴了其他的优质博客，在此向各位大神表示感谢，膜拜！！！&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;列表展示控件（ListView或者RecyclerView）是我们在开发过程中经常要使用到的一种控件。而我们学习Android开发的时候，ListView也是必须掌握的。那么本篇我们来说一下ListView，虽然现在ListView逐渐的被RecyclerView取代，包括我自己的项目中也是使用的RecyclerView。那么为什么要分析一个“过时”的东西呢？因为RecyclerView的前辈，许多遗留项目是基于ListView的，可能因为种种原因不能更换或者更换代价太大，那么我们如何在ListView的基础上优化App就成了我们不得不面对的问题。同时对于ListView的学习也有助于RecyclerView的掌握。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：关于ListView的各部分内容，网上存在着大量的博客以及教程，讲解的有浅有深。本篇博客呢立足于平常开发时所遇到的一些问题，也是本身对知识的掌握程度的检视。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;listview的简单使用&quot;&gt;ListView的简单使用&lt;/h2&gt;
&lt;p&gt;关于ListView的简单使用我这里就不详细分析了，只贴上一个实例源码以及做一个小结，对应的源码目录已用红框标出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/GTVGB4o.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;listview的简单使用实例&quot;&gt;ListView的简单使用实例&lt;/h3&gt;
&lt;p&gt;布局文件activity_list_view.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;
    &amp;gt;

    &amp;lt;ListView
        android:id=&quot;@+id/list_view&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:cacheColorHint=&quot;#00000000&quot;
        android:divider=&quot;#f4f4f4&quot;
        android:dividerHeight=&quot;1dp&quot;
        &amp;gt;
    &amp;lt;/ListView&amp;gt;


&amp;lt;/LinearLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的源码ListViewActivity&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ListViewActivity extends AppCompatActivity {
    @BindView(R.id.list_view)
    ListView mListView;

    private List&amp;lt;String&amp;gt; mArrayList= new ArrayList();
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_list_view);
        ButterKnife.bind(this);
        //初始化数据
        init();

        //创建Adapater
        ListViewAdapter adapter = new ListViewAdapter(this,mArrayList);

        //设置Adapter
        mListView.setAdapter(adapter);


        //设置item点击监听事件
        mListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView&amp;lt;?&amp;gt; parent, View view, int position, long id) {
                Toast.makeText(ListViewActivity.this,mArrayList.get(position),Toast.LENGTH_SHORT).show();
            }
        });
    }

    private void init() {
        for (int i=0;i&amp;lt;20;i++){
            mArrayList.add(&quot;这是第&quot;+i+&quot;个View&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ListView对应的的Adapter&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ListViewAdapter extends BaseAdapter {
    private static final String TAG = ListViewAdapter.class.getSimpleName();

    private List&amp;lt;String&amp;gt; mList;
    private LayoutInflater inflater;
    private ViewHolder viewHolder;

    public ListViewAdapter(Context context, List&amp;lt;String&amp;gt; list) {
        mList = list;
        this.inflater  = LayoutInflater.from(context);
    }

    @Override
    public int getCount() {
        return mList == null ? 0 : mList.size();
    }

    @Override
    public Object getItem(int position) {
        return mList == null ? null : mList.get(position);
    }

    @Override
    public long getItemId(int position) {
        return position;
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {

        if (convertView == null){
            viewHolder = new ViewHolder();
            convertView = inflater.inflate(R.layout.list_view_item_simple, null);
            viewHolder.mTextView=(TextView) convertView.findViewById(R.id.text_view);
            convertView.setTag(viewHolder);

            Log.d(TAG,&quot;convertView == null&quot;);
        }else {
            Log.d(TAG,&quot;convertView != null&quot;);
            viewHolder = (ViewHolder) convertView.getTag();
        }

        viewHolder.mTextView.setText(mList.get(position));
        return convertView;
    }

   
    static class ViewHolder {
        private TextView mTextView;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;listview的简单使用小结&quot;&gt;ListView的简单使用小结&lt;/h3&gt;
&lt;p&gt;关于ListView的使用及Adapter优化，这里给出了我们常用的优化方法，使用ViewHolder进行性能优化，这些内容也都是老生常谈的内容。不过想要深入理解使用ViewHolder是如何做到优化的，我们还得继续向下看，这里呢只是给出一个小例子让读者能够应对初中级开发工程师的面试提问。&lt;/p&gt;
&lt;p&gt;在面试初中级Android开发工程师的时候,关于列表项展示这块基本上是必问的，你如果使用的ListView，那么ListView的性能优化，以及后面要讲到的下拉刷新上拉加载，基本也是必问的，因为这是你平常项目开发中也是肯定要考虑到的点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于初中级Android开发工程师来说，面试ListView的性能优化时你要回答的上来以下两点：①在ListView的Adapter中复用getView方法中的convertView ②使用静态内部类ViewHolder,用于对控件的实例存储进行缓存，减少findViewById的调用次数。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;listview的进阶使用&quot;&gt;ListView的进阶使用&lt;/h2&gt;
&lt;h3 id=&quot;属性介绍&quot;&gt;属性介绍&lt;/h3&gt;
&lt;p&gt;在这一小节中，介绍一些ListView 中的一些重要属性，有一些经常在项目开发中用到，而有一些不太常用，不过可以作为知识面的扩充&lt;/p&gt;
&lt;ol readability=&quot;13.811726734804&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;分割线&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;android:divider=&quot;#00000000&quot; //或者在javaCode中如下定义：listView.setDividerHeight(0);

android:divider=&quot;@drawable/list_driver&quot; //设置分割线的图片资源

android:divider=&quot;@drawable/@null&quot; //不想显示分割线&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;滚动条&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;android:scrollbars=&quot;none&quot;//隐藏listView的滚动条   在javaCode中如下定义setVerticalScrollBarEnabled(true);

android:fadeScrollbars=&quot;true&quot; //设置为true就可以实现滚动条的自动隐藏和显示&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;去掉上边和下边黑色的阴影&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;android:fadingEdge=&quot;none&quot; 去掉上边和下边黑色的阴影&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;快速滚动&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;android:fastScrollEnabled=&quot;true&quot; 
或者在javaCode中如下定义：mListView.setFastScrollEnabled(true); 来控制启用，参数false为隐藏。 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是当你的滚动内容较小，不到当前ListView的3个屏幕高度时则不会出现这个快速滚动滑块，同时该方法仍然是AbsListView的基础方法，可以在ListView或GridView等子类中使用快速滚动辅助。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;stackFromBottom属性，这只该属性之后你做好的列表就会显示你列表的最下面，值为true和false&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;android:stackFromBottom=&quot;true&quot;  //该属性默认为false，设置为true后，你的列表会从最后一项向前显示一屏&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5.7674418604651&quot;&gt;
&lt;p&gt;cacheColorHint属性，很多人希望能够改变一下ListView的背景，使他能够符合整体的UI设计，改变背景背很简单只需要准 备一张图片然后指定属性 android:&lt;a href=&quot;mailto:background=%22@drawable/bg%22&quot;&gt;background=&quot;@drawable/bg&quot;&lt;/a&gt;，不过不要高兴地太早，当你这么做以后，发现背景是 变了，但是当你拖动，或者点击list空白位置的时候发现ListItem都变成黑色的了，破坏了整体效果。&lt;/p&gt;
&lt;p&gt;如果你只是换背景的颜色的话，可以直接指定android:cacheColorHint为你所要的颜色，如果你是用图片做背景的话，那也只要将android:cacheColorHint指定为透明（#00000000）就可以了&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;关于上面的属性，读者可以逐一测试，我这里就不贴测试结果了。&lt;/p&gt;

&lt;p&gt;上面的内容止步于Android初中级开发工程师，那么对于中高级来说，面试官就不满足于你上面的回答了，可能会问你一些更深入的问题。&lt;strong&gt;例如ListView展示成千上万条数据为什么没有发生OOM呢？ListView在滑动的时候异步请求所导致的图片错位问题产生的原理及如何解决？？等等&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要比较完美的回答出这样的问题，那么我们就得向ListView的源码进发。&lt;/p&gt;
&lt;h2 id=&quot;listview类及adapter&quot;&gt;ListView类及Adapter&lt;/h2&gt;
&lt;p&gt;我们先来上一张图&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/hjbPmMH.png&quot;/&gt;&lt;br/&gt;作为我们第一个详细讲解的系统控件ListView，其归根到底是个View，关于View以及ViewGroup我们这里就不分析了，我们从AdapterView开始&lt;/p&gt;
&lt;h3 id=&quot;adapterview&quot;&gt;AdapterView&lt;/h3&gt;
&lt;p&gt;AdapterView顾名思义是个有Adapter的View,其内定义了setAdapter、getAdapter等抽象方法供子类实现。View说到底是展示数据的控件，就像我们的TextView一样，Android提供的这些View系统控件也都是为了展示各种各样的数据，那么AdapterView也不例外。Android设计AdapterView呢就是为了那些数据源无法确定的场景，你如果想展示大量数据，那么你需要自定义数据源（数据源可能是数组，也可能是List，也可能是数据库）。然后你需要自定义适配器即Adapter，让AdapterView通过适配器与数据源联系在一起。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也就是说AdapterView提供了一种不需要关心数据源的通用的展示大量数据的方法。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;adapter&quot;&gt;Adapter&lt;/h3&gt;
&lt;p&gt;Adapter是适配器的意思，它在ListView和数据源之间起到了一个桥梁的作用，ListView并不会直接和数据源打交道，而是会借助Adapter这个桥梁来去访问真正的数据源，与之前不同的是，Adapter的接口都是统一的，因此ListView不用再去担心任何适配方面的问题。而Adapter又是一个接口(interface)，它可以去实现各种各样的子类，每个子类都能通过自己的逻辑来去完成特定的功能，以及与特定数据源的适配操作，比如说ArrayAdapter可以用于数组和List类型的数据源适配，SimpleCursorAdapter可以用于游标类型的数据源适配，这样就非常巧妙地把数据源适配困难的问题解决掉了，并且还拥有相当不错的扩展性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也就是说Adapter是统一的接口，定义通用的适配接口，我们实现该接口方法进行自定义适配操作即可。（Android已经预先定义了一些场景所需要的接口和基类如BaseAdapter,ArrayAdapter等）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;abslistview&quot;&gt;AbsListView&lt;/h3&gt;
&lt;p&gt;作为ListView和GridView的父类，AbsListView承担了很多职责，下面我们要分析的关于ListView的View复用机制即是通过该类的内部类RecycleBin完成的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也就是说ListView和GridView使用的是同一种View复用机制，该机制主要是由两者的父类AbsListView中的内部类RecycleBin完成。&lt;/strong&gt;别万一被问到了GridView的View复用机制，GridView为什么展示成千上万条数据不发生OOM等问题时傻了眼。。。。&lt;/p&gt;
&lt;p&gt;注：以下源码来自android-6.0.0_r5&lt;/p&gt;
&lt;h2 id=&quot;abslistviewrecyclebin&quot;&gt;AbsListView$RecycleBin&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;/**
 *RecycleBin有助于在布局中重用视图。RecycleBin有两个级别的存储:ActiveViews和ScrapViews。
 *ActiveViews是在布局开始时出现在屏幕上的视图。通过构造，它们显示当前信息。
 *在布局的最后，ActiveViews中的所有视图都被降级为ScrapViews。
 *ScrapViews是可以被适配器使用的旧视图，以避免不必要地分配视图。
 * 
 */
class RecycleBin {
    private RecyclerListener mRecyclerListener;

    /**
     * 在mActiveViews中存储的第一个View的位置.
     */
    private int mFirstActivePosition;

    /**
     *在布局开始时在屏幕上的视图。这个数组在布局开始时填充，
     *在布局的末尾，mActiveViews中的所有视图都被移动到mScrapViews
     *mActiveViews表示一个连续的视图范围，第一个视图的位置存储在mFirstActivePosition。
     */
    private View[] mActiveViews = new View[0];

    /**
     *可将适配器用作转换视图的未排序视图。
     */
    private ArrayList&amp;lt;View&amp;gt;[] mScrapViews;

    private int mViewTypeCount;

    private ArrayList&amp;lt;View&amp;gt; mCurrentScrap;

    /**
     * RecycleBin当中使用mActiveViews这个数组来存储View，
     * 调用这个方法后就会根据传入的参数来将ListView中的指定元素存储到mActiveViews数组当中。
     * 
     * @param childCount
     *            第一个参数表示要存储的view的数量
     * @param firstActivePosition
     *            ListView中第一个可见元素的position值
     */
    void fillActiveViews(int childCount, int firstActivePosition) {
        if (mActiveViews.length &amp;lt; childCount) {
            mActiveViews = new View[childCount];
        }
        mFirstActivePosition = firstActivePosition;

        final View[] activeViews = mActiveViews;
        for (int i = 0; i &amp;lt; childCount; i++) {
            View child = getChildAt(i);
            AbsListView.LayoutParams lp = (AbsListView.LayoutParams) child.getLayoutParams();
            if (lp != null &amp;amp;&amp;amp; lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                activeViews[i] = child;
                lp.scrappedFromPosition = firstActivePosition + i;
            }
        }
    }

    /**
     *该方法与上面的fillActiveViews对应，功能是获取对应于指定位置的视图。视图如果被发现，就会从mActiveViews删除
     * 
     * @param position
     * 表示元素在ListView当中的位置，方法内部会自动将position值转换成mActiveViews数组对应的下标值。
     * @return 
     * 返回找到的View 下次获取同样位置的View将会返回null。
     */
    View getActiveView(int position) {
        int index = position - mFirstActivePosition;
        final View[] activeViews = mActiveViews;
        if (index &amp;gt;=0 &amp;amp;&amp;amp; index &amp;lt; activeViews.length) {
            final View match = activeViews[index];
            activeViews[index] = null;
            return match;
        }
        return null;
    }

    /**
     * 根据mViewTypeCount把一个View放进 ScapViews list. 这些View是未经过排序的.
     * 
     * @param scrap
     *            需要被加入的View
     */
    void addScrapView(View scrap, int position) {
        final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
        if (lp == null) {
            
            return;
        }

        lp.scrappedFromPosition = position;

        final int viewType = lp.viewType;
        if (!shouldRecycleViewType(viewType)) {
           
            if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                getSkippedScrap().add(scrap);
            }
            return;
        }

        scrap.dispatchStartTemporaryDetach();

        notifyViewAccessibilityStateChangedIfNeeded(
                AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);


        final boolean scrapHasTransientState = scrap.hasTransientState();
        if (scrapHasTransientState) {
            if (mAdapter != null &amp;amp;&amp;amp; mAdapterHasStableIds) {
              
                if (mTransientStateViewsById == null) {
                    mTransientStateViewsById = new LongSparseArray&amp;lt;&amp;gt;();
                }
                mTransientStateViewsById.put(lp.itemId, scrap);
            } else if (!mDataChanged) {
              
                if (mTransientStateViews == null) {
                    mTransientStateViews = new SparseArray&amp;lt;&amp;gt;();
                }
                mTransientStateViews.put(position, scrap);
            } else {
                getSkippedScrap().add(scrap);
            }
        } else {
            if (mViewTypeCount == 1) {
                mCurrentScrap.add(scrap);
            } else {
                mScrapViews[viewType].add(scrap);
            }

            if (mRecyclerListener != null) {
                mRecyclerListener.onMovedToScrapHeap(scrap);
            }
        }
    }

    /**
     * @return 根据mViewTypeCount从mScapViews中获取
     */
     View getScrapView(int position) {
        final int whichScrap = mAdapter.getItemViewType(position);
        if (whichScrap &amp;lt; 0) {
            return null;
        }
        if (mViewTypeCount == 1) {
            return retrieveFromScrap(mCurrentScrap, position);
        } else if (whichScrap &amp;lt; mScrapViews.length) {
            return retrieveFromScrap(mScrapViews[whichScrap], position);
        }
        return null;
    }

        /**
     * @return 用于从ScapViews list中取出一个View，这些废弃缓存中的View是没有顺序可言的，
     * 因此retrieveFromScrap方法中的算法也非常简单，就是直接从mCurrentScrap当中获取尾部的一个scrap view进行返回.
     */
    private View retrieveFromScrap(ArrayList&amp;lt;View&amp;gt; scrapViews, int position) {
        final int size = scrapViews.size();
        if (size &amp;gt; 0) {
            // See if we still have a view for this position or ID.
            for (int i = 0; i &amp;lt; size; i++) {
                final View view = scrapViews.get(i);
                final AbsListView.LayoutParams params =
                        (AbsListView.LayoutParams) view.getLayoutParams();

                if (mAdapterHasStableIds) {
                    final long id = mAdapter.getItemId(position);
                    if (id == params.itemId) {
                        return scrapViews.remove(i);
                    }
                } else if (params.scrappedFromPosition == position) {
                    final View scrap = scrapViews.remove(i);
                    clearAccessibilityFromScrap(scrap);
                    return scrap;
                }
            }
            final View scrap = scrapViews.remove(size - 1);
            clearAccessibilityFromScrap(scrap);
            return scrap;
        } else {
            return null;
        }
    }


    /**
    *Adapter当中可以重写一个getViewTypeCount()来表示ListView中有几种类型的数据项，
    *setViewTypeCount()方法的作用就是为每种类型的数据项都单独启用一个RecycleBin缓存机制。
    */

    public void setViewTypeCount(int viewTypeCount) {
        if (viewTypeCount &amp;lt; 1) {
            throw new IllegalArgumentException(&quot;Can't have a viewTypeCount &amp;lt; 1&quot;);
        }
        // noinspection unchecked
        ArrayList&amp;lt;View&amp;gt;[] scrapViews = new ArrayList[viewTypeCount];
        for (int i = 0; i &amp;lt; viewTypeCount; i++) {
            scrapViews[i] = new ArrayList&amp;lt;View&amp;gt;();
        }
        mViewTypeCount = viewTypeCount;
        mCurrentScrap = scrapViews[0];
        mScrapViews = scrapViews;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;listview的layout布局过程&quot;&gt;ListView的layout（布局过程）&lt;/h2&gt;
&lt;p&gt;ListView虽然很复杂，但是其继承自View，终究逃不过View的那5大过程，关于这部分内容读者如果不清楚，可参看之前的博文，&lt;a href=&quot;http://www.cnblogs.com/wangle12138/p/8441136.html&quot;&gt;Android开发之漫漫长途 Ⅴ——Activity的显示之ViewRootImpl的预测量、窗口布局、最终测量、布局、绘制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从之前的文章我们就知道，View经过预测量、窗口布局（根据条件进入）、最终测量、布局、绘制阶段，那么对于ListView也不例外，&lt;/p&gt;
&lt;p&gt;在第一次“心跳”performTraversals()函数中，我们会对ListView进行预测量、最终测量 2次测量，onMeasure()方法被调用两次，1次布局 onLayout()方法调用1次，&lt;/p&gt;
&lt;p&gt;到最后调用draw方法我们来看下面这段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (!cancelDraw &amp;amp;&amp;amp; !newSurface) {
        if (!skipDraw || mReportNextDraw) {
            if (mPendingTransitions != null &amp;amp;&amp;amp; mPendingTransitions.size() &amp;gt; 0) {
                for (int i = 0; i &amp;lt; mPendingTransitions.size(); ++i) {
                    mPendingTransitions.get(i).startChangingAnimations();
                }
                mPendingTransitions.clear();
            }
            
            //调用 performDraw();
            performDraw();
        }
} else {
    if (viewVisibility == View.VISIBLE) {
        //调用 scheduleTraversals();
        scheduleTraversals();
    } else if (mPendingTransitions != null &amp;amp;&amp;amp; mPendingTransitions.size() &amp;gt; 0) {
        for (int i = 0; i &amp;lt; mPendingTransitions.size(); ++i) {
            mPendingTransitions.get(i).endChangingAnimations();
        }
        mPendingTransitions.clear();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的代码我们可以看出，，如果cancelDraw为true或者newSurface为true时，，会调用 scheduleTraversals();而这个函数会导致“心跳”performTraversals()函数的调用，再重新走一遍上面的过程&lt;/p&gt;
&lt;p&gt;这也导致了&lt;/p&gt;
&lt;p&gt;第1次“心跳”onMeasure() onMeasure() onLayout()&lt;/p&gt;
&lt;p&gt;第2次“心跳”onMeasure() onLayout() onDraw()&lt;/p&gt;
&lt;p&gt;有些读者可能会问了，为什么第1次心跳是2次onMeasure() onMeasure(),第二次心跳是1次onMeasure呢，这跟View的measure机制有关&lt;/p&gt;
&lt;p&gt;[View.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
  ......
  // 当FLAG_FORCE_LAYOUT位为１时，就是当前视图请求一次布局操作
  //或者当前当前widthSpec和heightSpec不等于上次调用时传入的参数的时候
  //才进行从新测量。
    if ((mPrivateFlags &amp;amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||
            widthMeasureSpec != mOldWidthMeasureSpec ||
            heightMeasureSpec != mOldHeightMeasureSpec) {
            ......
            onMeasure(widthMeasureSpec, heightMeasureSpec);
            ......
    }
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;也就是说对于任意一个View而言，想显示到界面，至少经过两次onMeasur及onLayout的调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于测量和绘制不是我们这个ListView所关心的，我们只关心它的布局&lt;/p&gt;
&lt;p&gt;上面说了半天，其实就是让读者对ListView的测量、布局、绘制流程有个更深入的了解，对于其他View，我们并不关心它进行了几次Measure,几次layout，但是对于ListView而言这个却比较重要，因为ListView是在布局过程中向其中添加数据的，如果多次布局，那么不就添加重复数据了吗？这个我们可以看到ListView巧妙的设计来避免了重复添加数据的问题。&lt;/p&gt;
&lt;h3 id=&quot;第1次layout&quot;&gt;第1次layout&lt;/h3&gt;
&lt;p&gt;谈到layout，相信读者也都了然一笑，肯定看onLayout方法，结果发现ListView中没有此方法，&lt;img src=&quot;https://i.imgur.com/FeIryWs.jpg&quot;/&gt;。不着急，我们去它爸爸，果然在它爸爸那里找到了&lt;/p&gt;
&lt;p&gt;[AbsListView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
    super.onLayout(changed, l, t, r, b);

    mInLayout = true;

    final int childCount = getChildCount();
    if (changed) {
        for (int i = 0; i &amp;lt; childCount; i++) {
            getChildAt(i).forceLayout();
        }
        mRecycler.markChildrenDirty();
    }

    layoutChildren();
    mInLayout = false;

    mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR;

    // TODO: Move somewhere sane. This doesn't belong in onLayout().
    if (mFastScroll != null) {
        mFastScroll.onItemCountChanged(getChildCount(), mItemCount);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码很短，也不复杂，复杂的操作被封装在layoutChildren();方法中了，跟进&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; /**
 * Subclasses must override this method to layout their children.
 */
protected void layoutChildren() {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;空方法&lt;img src=&quot;https://i.imgur.com/FeIryWs.jpg&quot;/&gt;。&lt;/p&gt;
&lt;p&gt;看其说明应该是子类重写了该方法了，，我们又回到ListView&lt;/p&gt;
&lt;p&gt;[ListView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
protected void layoutChildren() {
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (blockLayoutRequests) {
        return;
    }

    mBlockLayoutRequests = true;

    try {
        super.layoutChildren();

        invalidate();

        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }

        final int childrenTop = mListPadding.top;
        final int childrenBottom = mBottom - mTop - mListPadding.bottom;
        /**
        *第1次Layout时，ListView内还没有数据，数据还在Adapter那，这里childCount=0
        */

        final int childCount = getChildCount();

        int index = 0;
        int delta = 0;

        ......
        /**
        *dataChanged只有在数据源发生改变的情况下才会变成true，其它情况都是false，
        */
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        ......
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        if (dataChanged) {
            for (int i = 0; i &amp;lt; childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition+i);
            }
        } else {
                /**
                *RecycleBin的fillActiveViews()方法缓存View
                *可是目前ListView中还没有任何的子View，因此这一行暂时还起不了任何作用。
                */
            recycleBin.fillActiveViews(childCount, firstPosition);
        }

        /**
        *目前ListView中还没有任何的子View，因此这一行暂时还起不了任何作用。
        */
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();

        /**
        *mLayoutMode默认为LAYOUT_NORMAL
        */
        switch (mLayoutMode) {
        case LAYOUT_SET_SELECTION:
            if (newSel != null) {
                sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
            } else {
                sel = fillFromMiddle(childrenTop, childrenBottom);
            }
            break;
        case LAYOUT_SYNC:
            sel = fillSpecific(mSyncPosition, mSpecificTop);
            break;
        case LAYOUT_FORCE_BOTTOM:
            sel = fillUp(mItemCount - 1, childrenBottom);
            adjustViewsUpOrDown();
            break;
        case LAYOUT_FORCE_TOP:
            mFirstPosition = 0;
            sel = fillFromTop(childrenTop);
            adjustViewsUpOrDown();
            break;
        case LAYOUT_SPECIFIC:
            sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
            break;
        case LAYOUT_MOVE_SELECTION:
            sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
            break;
        default:
            if (childCount == 0) {
                if (!mStackFromBottom) {
                    /**
                    *mStackFromBottom我们在上面的属性中讲过，该属性默认为false
                    */
                    final int position = lookForSelectablePosition(0, true);
                    setSelectedPositionInt(position);
                    //调用fillFromTop方法
                    sel = fillFromTop(childrenTop);
                } else {
                    final int position = lookForSelectablePosition(mItemCount - 1, false);
                    setSelectedPositionInt(position);
                    sel = fillUp(mItemCount - 1, childrenBottom);
                }
            } else {
                if (mSelectedPosition &amp;gt;= 0 &amp;amp;&amp;amp; mSelectedPosition &amp;lt; mItemCount) {
                    sel = fillSpecific(mSelectedPosition,
                            oldSel == null ? childrenTop : oldSel.getTop());
                } else if (mFirstPosition &amp;lt; mItemCount) {
                    sel = fillSpecific(mFirstPosition,
                            oldFirst == null ? childrenTop : oldFirst.getTop());
                } else {
                    sel = fillSpecific(0, childrenTop);
                }
            }
            break;
        }

       /**
        *RecycleBin的scrapActiveViews从mActivieViews缓存到mScrapActiveViews
        *可是目前RecycleBin的mActivieViews也没什么数据，因此这一行暂时还起不了任何作用。
        */
        recycleBin.scrapActiveViews();

        ......
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第1次layout时就是做一些初始化ListView的操作，调用fillFromTop方法去填充ListView，跟进fillFromTop&lt;/p&gt;
&lt;p&gt;[ListView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
*参数nextTop表示下一个子View应该放置的位置，
*这里传入的nextTop=mListPadding.top;明显第一个子View是放在ListView的最上方，
*注意padding不属于子View,属于父View的一部分
*/
private View fillFromTop(int nextTop) {
    mFirstPosition = Math.min(mFirstPosition, mSelectedPosition);
    mFirstPosition = Math.min(mFirstPosition, mItemCount - 1);
    if (mFirstPosition &amp;lt; 0) {
        mFirstPosition = 0;
    }
    //调用fillDown
    return fillDown(mFirstPosition, nextTop);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟进fillDown&lt;/p&gt;
&lt;p&gt;[ListView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 从pos开始从上向下填充ListViwe
 *
 * @param pos 
 *        list中的位置
 *        
 * @param nextTop 
 *        下一个Item应该放置的位置
 *
 * @return 
 *       返回选择位置的View,这个位置在我们的放置范围之内
 */
private View fillDown(int pos, int nextTop) {
    View selectedView = null;

    int end = (mBottom - mTop);
    if ((mGroupFlags &amp;amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        end -= mListPadding.bottom;
    }

    /**
    *这里循环判断，终止的条件是下一个item放置的位置&amp;gt;listview的底部或者当前的位置&amp;gt;总数
    */
    while (nextTop &amp;lt; end &amp;amp;&amp;amp; pos &amp;lt; mItemCount) {
        
        boolean selected = pos == mSelectedPosition;
        /**
        *这里调用makeAndAddView来获得一个View
        */
        View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected);
        
        //更新nextTop的值
        nextTop = child.getBottom() + mDividerHeight;
        if (selected) {
            selectedView = child;
        }
        //自增pos
        pos++;
    }

    setVisibleRangeHint(mFirstPosition, mFirstPosition + getChildCount() - 1);
    return selectedView;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续跟进makeAndAddView&lt;/p&gt;
&lt;p&gt;[ListView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 获取一个View并添加进ListView。这个View呢可能是新创建的，也有可能是来自mActiveViews，或者是来自mScrapViews
 * @param position 
 *        列表中的逻辑位置
 * @param y 
 *       被添加View的上 边位置或者下 边位置
 * @param flow 
 *        如果flow是true，那么y是View的上 边位置，否则那么y是View的下 边位置
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @return 
 *       返回被添加的View
 */
private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,
        boolean selected) {
    View child;


    if (!mDataChanged) {
        // 尝试从mActiveViews中获取，第1次肯定是没有获取到
        child = mRecycler.getActiveView(position);
        if (child != null) {
            // Found it -- we're using an existing child
            // This just needs to be positioned
            setupChild(child, position, y, flow, childrenLeft, selected, true);

            return child;
        }
    }

    // 为这个position创建View
    child = obtainView(position, mIsScrap);

    // 调用setupChild
    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);

    return child;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们第1次layout时，尝试从mActiveViews中获取View,这里child为null，那么我们跟进obtainView&lt;br/&gt;我们没有在ListView中找到该方法，那么应该在其父类中，，跟进&lt;/p&gt;
&lt;p&gt;[AbsListView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 获取一个视图，并让它显示与指定的数据相关联的数据的位置。
 *当我们已经发现视图无法在RecycleBin重复使用。剩下的唯一选择就是转换旧视图或创建新视图。
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 *                the returned view was taken from the scrap heap, false if otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */
View obtainView(int position, boolean[] isScrap) {
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;obtainView&quot;);

    isScrap[0] = false;

    // Check whether we have a transient state view. Attempt to re-bind the
    // data and discard the view if we fail.
    final View transientView = mRecycler.getTransientStateView(position);
    if (transientView != null) {
        final LayoutParams params = (LayoutParams) transientView.getLayoutParams();

        // If the view type hasn't changed, attempt to re-bind the data.
        if (params.viewType == mAdapter.getItemViewType(position)) {
            final View updatedView = mAdapter.getView(position, transientView, this);

            // If we failed to re-bind the data, scrap the obtained view.
            if (updatedView != transientView) {
                setItemViewLayoutParams(updatedView, position);
                mRecycler.addScrapView(updatedView, position);
            }
        }

        isScrap[0] = true;

        // Finish the temporary detach started in addScrapView().
        transientView.dispatchFinishTemporaryDetach();
        return transientView;
    }

    final View scrapView = mRecycler.getScrapView(position);
    final View child = mAdapter.getView(position, scrapView, this);
    if (scrapView != null) {
        if (child != scrapView) {
            // Failed to re-bind the data, return scrap to the heap.
            mRecycler.addScrapView(scrapView, position);
        } else {
            isScrap[0] = true;

            // Finish the temporary detach started in addScrapView().
            child.dispatchFinishTemporaryDetach();
        }
    }

    if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }

    if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
        child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
    }

    setItemViewLayoutParams(child, position);

    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        if (child.getAccessibilityDelegate() == null) {
            child.setAccessibilityDelegate(mAccessibilityDelegate);
        }
    }

    Trace.traceEnd(Trace.TRACE_TAG_VIEW);

    return child;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用obtainView一定会得到一个View,这个View要么是新创建的，要么是从mScrapViews中复用的。在第1次layout中，肯定无法得到复用的View，那么新创建的，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;final View child = mAdapter.getView(position, scrapView, this);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的mAdapter毫无疑问是跟ListView关联的Adapter，那么getView方法，读者应该想到了，就是我们需要重写的那个方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ListViewAdapter extends BaseAdapter {

    /**
    *convertView = scrapView在第1次layout中，scrapView为null
    *parent = this 即ListView本身
    */
    @Override
    public View getView(int position, View convertView, ViewGroup parent) {

        if (convertView == null){
            viewHolder = new ViewHolder();
            convertView = inflater.inflate(R.layout.list_view_item_simple, null);
            viewHolder.mTextView=(TextView) convertView.findViewById(R.id.text_view);
            convertView.setTag(viewHolder);

            Log.d(TAG,&quot;convertView == null&quot;);
        }else {
            Log.d(TAG,&quot;convertView != null&quot;);
            viewHolder = (ViewHolder) convertView.getTag();
        }

        viewHolder.mTextView.setText(mList.get(position));
        return convertView;
    }

   
    static class ViewHolder {
        private TextView mTextView;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们对这个方法有了更深入的认识，convertView就是我们得到的在mScrapViews中的View，所以我们在getView中判断convertView是否为null，如果为null，通过LayoutInfalter加载。&lt;/p&gt;
&lt;p&gt;那么到这里我们就需要回到&lt;/p&gt;
&lt;p&gt;[ListView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,
        boolean selected) {
    View child;

    ......
    // view我们这里已经得到了
    child = obtainView(position, mIsScrap);

    // 调用setupChild
    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);

    return child;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着跟进setupChild&lt;br/&gt;[ListView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 添加一个子View然后确定该子View的测量（如果必要的话）和合理的位置
 *
 * @param child 
 *        被添加的子View
 * @param position 
 *        子View的位置
 * @param y 
 *        子View被放置的坐标
 * @param flowDown
 *        如果是true的话，那么上面参数中的y表示子View的上 边的位置，否则为下 边的位置
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @param recycled 布尔值，意为child是否是从RecycleBin中得到的，如果是的话，不需要重新Measure
 * 第1次layout时，该值为false
 */
private void setupChild(View child, int position, int y, boolean flowDown, int childrenLeft,
        boolean selected, boolean recycled) {
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;setupListItem&quot;);

    final boolean isSelected = selected &amp;amp;&amp;amp; shouldShowSelector();
    final boolean updateChildSelected = isSelected != child.isSelected();
    final int mode = mTouchMode;
    final boolean isPressed = mode &amp;gt; TOUCH_MODE_DOWN &amp;amp;&amp;amp; mode &amp;lt; TOUCH_MODE_SCROLL &amp;amp;&amp;amp;
            mMotionPosition == position;
    final boolean updateChildPressed = isPressed != child.isPressed();
    final boolean needToMeasure = !recycled || updateChildSelected || child.isLayoutRequested();

    // Respect layout params that are already in the view. Otherwise make some up...
    // noinspection unchecked
    AbsListView.LayoutParams p = (AbsListView.LayoutParams) child.getLayoutParams();
    if (p == null) {
        p = (AbsListView.LayoutParams) generateDefaultLayoutParams();
    }
    p.viewType = mAdapter.getItemViewType(position);

    if ((recycled &amp;amp;&amp;amp; !p.forceAdd) || (p.recycledHeaderFooter
            &amp;amp;&amp;amp; p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) {
        attachViewToParent(child, flowDown ? -1 : 0, p);
    } else {
        p.forceAdd = false;
        if (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
            p.recycledHeaderFooter = true;
        }
        addViewInLayout(child, flowDown ? -1 : 0, p, true);
    }

    if (updateChildSelected) {
        child.setSelected(isSelected);
    }

    if (updateChildPressed) {
        child.setPressed(isPressed);
    }

    if (mChoiceMode != CHOICE_MODE_NONE &amp;amp;&amp;amp; mCheckStates != null) {
        if (child instanceof Checkable) {
            ((Checkable) child).setChecked(mCheckStates.get(position));
        } else if (getContext().getApplicationInfo().targetSdkVersion
                &amp;gt;= android.os.Build.VERSION_CODES.HONEYCOMB) {
            child.setActivated(mCheckStates.get(position));
        }
    }

    if (needToMeasure) {
        final int childWidthSpec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec,
                mListPadding.left + mListPadding.right, p.width);
        final int lpHeight = p.height;
        final int childHeightSpec;
        if (lpHeight &amp;gt; 0) {
            childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY);
        } else {
            childHeightSpec = MeasureSpec.makeSafeMeasureSpec(getMeasuredHeight(),
                    MeasureSpec.UNSPECIFIED);
        }
        child.measure(childWidthSpec, childHeightSpec);
    } else {
        cleanupLayoutState(child);
    }

    final int w = child.getMeasuredWidth();
    final int h = child.getMeasuredHeight();
    final int childTop = flowDown ? y : y - h;

    if (needToMeasure) {
        final int childRight = childrenLeft + w;
        final int childBottom = childTop + h;
        child.layout(childrenLeft, childTop, childRight, childBottom);
    } else {
        child.offsetLeftAndRight(childrenLeft - child.getLeft());
        child.offsetTopAndBottom(childTop - child.getTop());
    }

    if (mCachingStarted &amp;amp;&amp;amp; !child.isDrawingCacheEnabled()) {
        child.setDrawingCacheEnabled(true);
    }

    if (recycled &amp;amp;&amp;amp; (((AbsListView.LayoutParams)child.getLayoutParams()).scrappedFromPosition)
            != position) {
        child.jumpDrawablesToCurrentState();
    }

    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里调用了&lt;strong&gt;addViewInLayout()&lt;/strong&gt;方法将它添加到了ListView当中。那么根据fillDown()方法中的while循环，会让子元素View将整个ListView控件填满然后就跳出，也就是说即使我们的Adapter中有一千条数据，ListView也只会加载第一屏的数据，剩下的数据反正目前在屏幕上也看不到，所以不会去做多余的加载工作，这样就可以保证ListView中的内容能够迅速展示到屏幕上。&lt;/p&gt;
&lt;p&gt;那么到此为止，第一次Layout过程结束。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也就是说，ListView的第1次layout中，只是填充ListView的子View，即使我们的Adapter中有一千条数据，ListView也只会加载第一屏的数据，并不涉及RecycleBin的运作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/vyxpuYj.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;第2次layout&quot;&gt;第2次layout&lt;/h3&gt;
&lt;p&gt;[ListView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
protected void layoutChildren() {
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (blockLayoutRequests) {
        return;
    }

    mBlockLayoutRequests = true;

    try {
        super.layoutChildren();

        invalidate();

        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }

        final int childrenTop = mListPadding.top;
        final int childrenBottom = mBottom - mTop - mListPadding.bottom;
        /**
        *第2次Layout时，ListView中已经有了数据，这里的childCount为ListView一屏View的数目
        */

        final int childCount = getChildCount();

        int index = 0;
        int delta = 0;

        ......
        /**
        *dataChanged只有在数据源发生改变的情况下才会变成true，其它情况都是false，
        */
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        ......
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        if (dataChanged) {
            for (int i = 0; i &amp;lt; childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition+i);
            }
        } else {
                /**
                *RecycleBin的fillActiveViews()方法缓存View
                *第2次Layout时，ListView中已经有了数据，
                *调用fillActiveViews()，那么此时RecycleBin中mActiveViews中已有了数据
                */
            recycleBin.fillActiveViews(childCount, firstPosition);
        }

        /**
        *第2次Layout时，ListView中已经有了一屏的子View，
        *调用detachAllViewsFromParent();把ListView中的所有子View detach了
        *这也是多次调用layout不会重复添加数据的原因
        */
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();

        /**
        *mLayoutMode默认为LAYOUT_NORMAL
        */
        switch (mLayoutMode) {
        case LAYOUT_SET_SELECTION:
            if (newSel != null) {
                sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
            } else {
                sel = fillFromMiddle(childrenTop, childrenBottom);
            }
            break;
        case LAYOUT_SYNC:
            sel = fillSpecific(mSyncPosition, mSpecificTop);
            break;
        case LAYOUT_FORCE_BOTTOM:
            sel = fillUp(mItemCount - 1, childrenBottom);
            adjustViewsUpOrDown();
            break;
        case LAYOUT_FORCE_TOP:
            mFirstPosition = 0;
            sel = fillFromTop(childrenTop);
            adjustViewsUpOrDown();
            break;
        case LAYOUT_SPECIFIC:
            sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
            break;
        case LAYOUT_MOVE_SELECTION:
            sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
            break;
        default:
            if (childCount == 0) {
                if (!mStackFromBottom) {
                    final int position = lookForSelectablePosition(0, true);
                    setSelectedPositionInt(position);
                    sel = fillFromTop(childrenTop);
                } else {
                    final int position = lookForSelectablePosition(mItemCount - 1, false);
                    setSelectedPositionInt(position);
                    sel = fillUp(mItemCount - 1, childrenBottom);
                }
            } else {
                /**
                *第2次Layout时childCount不为0
                */
                if (mSelectedPosition &amp;gt;= 0 &amp;amp;&amp;amp; mSelectedPosition &amp;lt; mItemCount) {
                    sel = fillSpecific(mSelectedPosition,
                            oldSel == null ? childrenTop : oldSel.getTop());
                } else if (mFirstPosition &amp;lt; mItemCount) {
                    sel = fillSpecific(mFirstPosition,
                            oldFirst == null ? childrenTop : oldFirst.getTop());
                } else {
                    sel = fillSpecific(0, childrenTop);
                }
            }
            break;
        }

       /**
        *RecycleBin的scrapActiveViews方法把mActivieViews中的View再缓存到mScrapActiveViews
        */
        recycleBin.scrapActiveViews();

        ......
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实第二次Layout和第一次Layout的基本流程是差不多的，&lt;br/&gt;第2次Layout时childCount不为0，我们进入了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (mSelectedPosition &amp;gt;= 0 &amp;amp;&amp;amp; mSelectedPosition &amp;lt; mItemCount) {
    sel = fillSpecific(mSelectedPosition,
            oldSel == null ? childrenTop : oldSel.getTop());
} else if (mFirstPosition &amp;lt; mItemCount) {
    sel = fillSpecific(mFirstPosition,
            oldFirst == null ? childrenTop : oldFirst.getTop());
} else {
    sel = fillSpecific(0, childrenTop);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个逻辑判断不成立，因为默认情况下我们没有选中任何子元素，mSelectedPosition应该等于-1。第二个逻辑判断通常是成立的，因为mFirstPosition的值一开始是等于0的，只要adapter中的数据大于0条件就成立。那么进入到fillSpecific()方法当中，代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 *它和fillUp()、fillDown()方法功能也是差不多的，
 *主要的区别在于，fillSpecific()方法会优先将指定位置的子View先加载到屏幕上，
 *然后再加载该子View往上以及往下的其它子View。
 *那么由于这里我们传入的position就是第一个子View的位置，
 *于是fillSpecific()方法的作用就基本上和fillDown()方法是差不多的了
 *
 * @param position The reference view to use as the starting point
 * @param top Pixel offset from the top of this view to the top of the
 *        reference view.
 *
 * @return The selected view, or null if the selected view is outside the
 *         visible area.
 */
private View fillSpecific(int position, int top) {
    boolean tempIsSelected = position == mSelectedPosition;
    View temp = makeAndAddView(position, top, true, mListPadding.left, tempIsSelected);
    // Possibly changed again in fillUp if we add rows above this one.
    mFirstPosition = position;

    View above;
    View below;

    final int dividerHeight = mDividerHeight;
    if (!mStackFromBottom) {
        above = fillUp(position - 1, temp.getTop() - dividerHeight);
        // This will correct for the top of the first view not touching the top of the list
        adjustViewsUpOrDown();
        below = fillDown(position + 1, temp.getBottom() + dividerHeight);
        int childCount = getChildCount();
        if (childCount &amp;gt; 0) {
            correctTooHigh(childCount);
        }
    } else {
        below = fillDown(position + 1, temp.getBottom() + dividerHeight);
        // This will correct for the bottom of the last view not touching the bottom of the list
        adjustViewsUpOrDown();
        above = fillUp(position - 1, temp.getTop() - dividerHeight);
        int childCount = getChildCount();
        if (childCount &amp;gt; 0) {
             correctTooLow(childCount);
        }
    }

    if (tempIsSelected) {
        return temp;
    } else if (above != null) {
        return above;
    } else {
        return below;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么我们第3次回到makeAndAddView&lt;/p&gt;
&lt;p&gt;[ListView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 获取一个View并添加进ListView。这个View呢可能是新创建的，也有可能是来自mActiveViews，或者是来自mScrapViews
 * @param position 
 *        列表中的逻辑位置
 * @param y 
 *       被添加View的上 边位置或者下 边位置
 * @param flow 
 *        如果flow是true，那么y是View的上 边位置，否则那么y是View的下 边位置
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @return 
 *       返回被添加的View
 */
private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,
        boolean selected) {
    View child;


    if (!mDataChanged) {
        // 尝试从mActiveViews中获取，第2次layout中child可以从mActiveViews中获取到
        child = mRecycler.getActiveView(position);
        if (child != null) {
            //这里child不为空，调用setupChild，注意最后一个参数为true
            setupChild(child, position, y, flow, childrenLeft, selected, true);

            return child;
        }
    }

    // 为这个position创建View
    child = obtainView(position, mIsScrap);

    // 调用setupChild
    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);

    return child;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们这里又调用了setupChild，跟上面不同的是最后一个参数&lt;/p&gt;
&lt;p&gt;[ListView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 添加一个子View然后确定该子View的测量（如果必要的话）和合理的位置
 *
 * @param child 
 *        被添加的子View
 * @param position 
 *        子View的位置
 * @param y 
 *        子View被放置的坐标
 * @param flowDown
 *        如果是true的话，那么上面参数中的y表示子View的上 边的位置，否则为下 边的位置
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @param recycled 布尔值，意为child是否是从RecycleBin中得到的，如果是的话，不需要重新Measure
 * 第2次layout时，该值为true
 */
private void setupChild(View child, int position, int y, boolean flowDown, int childrenLeft,
        boolean selected, boolean recycled) {
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;setupListItem&quot;);

    final boolean isSelected = selected &amp;amp;&amp;amp; shouldShowSelector();
    final boolean updateChildSelected = isSelected != child.isSelected();
    final int mode = mTouchMode;
    final boolean isPressed = mode &amp;gt; TOUCH_MODE_DOWN &amp;amp;&amp;amp; mode &amp;lt; TOUCH_MODE_SCROLL &amp;amp;&amp;amp;
            mMotionPosition == position;
    final boolean updateChildPressed = isPressed != child.isPressed();
    final boolean needToMeasure = !recycled || updateChildSelected || child.isLayoutRequested();

    // Respect layout params that are already in the view. Otherwise make some up...
    // noinspection unchecked
    AbsListView.LayoutParams p = (AbsListView.LayoutParams) child.getLayoutParams();
    if (p == null) {
        p = (AbsListView.LayoutParams) generateDefaultLayoutParams();
    }
    p.viewType = mAdapter.getItemViewType(position);

    if ((recycled &amp;amp;&amp;amp; !p.forceAdd) || (p.recycledHeaderFooter
            &amp;amp;&amp;amp; p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) {
        attachViewToParent(child, flowDown ? -1 : 0, p);
    } else {
        p.forceAdd = false;
        if (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
            p.recycledHeaderFooter = true;
        }
        addViewInLayout(child, flowDown ? -1 : 0, p, true);
    }

    if (updateChildSelected) {
        child.setSelected(isSelected);
    }

    if (updateChildPressed) {
        child.setPressed(isPressed);
    }

    if (mChoiceMode != CHOICE_MODE_NONE &amp;amp;&amp;amp; mCheckStates != null) {
        if (child instanceof Checkable) {
            ((Checkable) child).setChecked(mCheckStates.get(position));
        } else if (getContext().getApplicationInfo().targetSdkVersion
                &amp;gt;= android.os.Build.VERSION_CODES.HONEYCOMB) {
            child.setActivated(mCheckStates.get(position));
        }
    }

    if (needToMeasure) {
        final int childWidthSpec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec,
                mListPadding.left + mListPadding.right, p.width);
        final int lpHeight = p.height;
        final int childHeightSpec;
        if (lpHeight &amp;gt; 0) {
            childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY);
        } else {
            childHeightSpec = MeasureSpec.makeSafeMeasureSpec(getMeasuredHeight(),
                    MeasureSpec.UNSPECIFIED);
        }
        child.measure(childWidthSpec, childHeightSpec);
    } else {
        cleanupLayoutState(child);
    }

    final int w = child.getMeasuredWidth();
    final int h = child.getMeasuredHeight();
    final int childTop = flowDown ? y : y - h;

    if (needToMeasure) {
        final int childRight = childrenLeft + w;
        final int childBottom = childTop + h;
        child.layout(childrenLeft, childTop, childRight, childBottom);
    } else {
        child.offsetLeftAndRight(childrenLeft - child.getLeft());
        child.offsetTopAndBottom(childTop - child.getTop());
    }

    if (mCachingStarted &amp;amp;&amp;amp; !child.isDrawingCacheEnabled()) {
        child.setDrawingCacheEnabled(true);
    }

    if (recycled &amp;amp;&amp;amp; (((AbsListView.LayoutParams)child.getLayoutParams()).scrappedFromPosition)
            != position) {
        child.jumpDrawablesToCurrentState();
    }

    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于recycled现在是true，所以会执行attachViewToParent()方法，而第一次Layout过程则是执行的else语句中的addViewInLayout()方法。这两个方法最大的区别在于，如果我们需要向ViewGroup中添加一个新的子View，应该调用addViewInLayout()方法，而如果是想要将一个之前detach的View重新attach到ViewGroup上，就应该调用attachViewToParent()方法。那么由于前面在layoutChildren()方法当中调用了detachAllViewsFromParent()方法，这样ListView中所有的子View都是处于detach状态的，所以这里attachViewToParent()方法是正确的选择。&lt;/p&gt;
&lt;p&gt;经历了这样一个detach又attach的过程，ListView中所有的子View又都可以正常显示出来了，那么第二次Layout过程结束。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也就是说，ListView的第2次layout中，把ListView中的所有子View缓存到RecycleBin中的mActiveViews，然后再detach掉ListView中所有子View，接着attach回来（这时使用的是mActiveViews中的缓存，没有重新inflate），然后再把mActiveViews缓存到mScrapViews中（还记得RecycleBin中的getActiveView方法吗，我们是怎么描述这个方法的，功能是获取对应于指定位置的视图。视图如果被发现，就会从mActiveViews删除，也就是说不能从同一个位置的View不能从mActiveViews中获得第二次）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Q4tislx.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;滑动加载&quot;&gt;滑动加载&lt;/h3&gt;
&lt;p&gt;经历了两次Layout过程，虽说我们已经可以在ListView中看到内容了，然而关于ListView最神奇的部分我们却还没有接触到，因为目前ListView中只是加载并显示了第一屏的数据而已。关于触摸事件的分发机制，读者不太清楚的可参看前面的博文&lt;a href=&quot;https://segmentfault.com/a/1190000012227736&quot;&gt;Android开发之漫漫长途 Ⅵ——图解Android事件分发机制（深入底层源码）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们这里直接来看onTouchEvent&lt;/p&gt;
&lt;p&gt;[AbsListView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public boolean onTouchEvent(MotionEvent ev) {
    ......
    switch (actionMasked) {
        ......

        case MotionEvent.ACTION_MOVE: {
            onTouchMove(ev, vtev);
            break;
        }
        ......
    }

   ......
   return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他的我们一概不关心，径直找到 MotionEvent.ACTION_MOVE当手指在屏幕上滑动时，TouchMode是等于TOUCH_MODE_SCROLL这个值的，&lt;/p&gt;
&lt;p&gt;[AbsListView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void onTouchMove(MotionEvent ev, MotionEvent vtev) {
     ......
    if (mDataChanged) {
        
        layoutChildren();
    }

    final int y = (int) ev.getY(pointerIndex);

    switch (mTouchMode) {
        ......
        case TOUCH_MODE_SCROLL:
        case TOUCH_MODE_OVERSCROLL:
            scrollIfNeeded((int) ev.getX(pointerIndex), y, vtev);
            break;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟进scrollIfNeeded&lt;/p&gt;
&lt;p&gt;[AbsListView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void scrollIfNeeded(int x, int y, MotionEvent vtev) {
    int rawDeltaY = y - mMotionY;//上次触摸事件到此次触摸事件移动的距离
    ......
    if (mLastY == Integer.MIN_VALUE) {
        rawDeltaY -= mMotionCorrection;
    }
    ......
    //如果滑动需要滑动的距离
    final int deltaY = rawDeltaY;
    int incrementalDeltaY =
            mLastY != Integer.MIN_VALUE ? y - mLastY + scrollConsumedCorrection : deltaY;
    int lastYCorrection = 0;

    if (mTouchMode == TOUCH_MODE_SCROLL) {
        ......
        if (y != mLastY) {//此次触摸事件和上次触摸事件的y值发生了改变（需要滑动的距离&amp;gt;0）
            // We may be here after stopping a fling and continuing to scroll.
            // If so, we haven't disallowed intercepting touch events yet.
            // Make sure that we do so in case we're in a parent that can intercept.
            // 当停止一个抛动且继续滑动之后，我们可能会执行此处的代码
            //确保ListView的父视图不会拦截触摸事件
            if ((mGroupFlags &amp;amp; FLAG_DISALLOW_INTERCEPT) == 0 &amp;amp;&amp;amp;
                    Math.abs(rawDeltaY) &amp;gt; mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
            }

            final int motionIndex;//down手势事件，按住的子视图在ListView之中的位置
            if (mMotionPosition &amp;gt;= 0) {
                motionIndex = mMotionPosition - mFirstPosition;
            } else {
                // If we don't have a motion position that we can reliably track,
                // pick something in the middle to make a best guess at things below.
                motionIndex = getChildCount() / 2;
            }

            int motionViewPrevTop = 0;//down手势事件，按住的子视图的顶端位置
            View motionView = this.getChildAt(motionIndex);
            if (motionView != null) {
                motionViewPrevTop = motionView.getTop();
            }

            // No need to do all this work if we're not going to move anyway
            //不需要做所有的工作，如果我们并没有进行移动
            boolean atEdge = false;//是否到达了ListView的边缘
            if (incrementalDeltaY != 0) {
                atEdge = trackMotionScroll(deltaY, incrementalDeltaY);//追踪手势滑动
            }

            // Check to see if we have bumped into the scroll limit
            //查看我们是否撞到了滑动限制（边缘）
            motionView = this.getChildAt(motionIndex);
            if (motionView != null) {
                // Check if the top of the motion view is where it is
                // supposed to be
                final int motionViewRealTop = motionView.getTop();
                if (atEdge) {//到达了ListView的边缘
                    // Apply overscroll
                    //响应的回弹效果实现
                    ......
                }
                mMotionY = y + lastYCorrection + scrollOffsetCorrection;//更新
            }
            mLastY = y + lastYCorrection + scrollOffsetCorrection;//更新
        }
    } else if (mTouchMode == TOUCH_MODE_OVERSCROLL) {
         ......
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总体而言，这一步也算是一个外壳，真正跟踪滑动运行的是trackMotionScroll方法。trackMotionScroll方法的逻辑较为复杂；&lt;/p&gt;
&lt;p&gt;[AbsListView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;boolean trackMotionScroll(int deltaY, int incrementalDeltaY) {
 
    ......
    //是否从下往上滑动  
    final boolean down = incrementalDeltaY &amp;lt; 0;  

    ......

     if (down) {//从下往上移动  
        int top = -incrementalDeltaY;//移动的距离  
        if ((mGroupFlags &amp;amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {  
            top += listPadding.top;  
        }  
        for (int i = 0; i &amp;lt; childCount; i++) {  
            final View child = getChildAt(i);  
            //是否有子视图完全被滑动离开了ListView的可见范围  
            if (child.getBottom() &amp;gt;= top) {  
                break;  
            } else {//当前子视图  
                count++;  
                int position = firstPosition + i;  
                if (position &amp;gt;= headerViewsCount &amp;amp;&amp;amp; position &amp;lt; footerViewsStart) {  
                    child.clearAccessibilityFocus();  
                    mRecycler.addScrapView(child, position);//回收子视图  
                }  
            }  
        }  
    } else {
        ......
    }

    mMotionViewNewTop = mMotionViewOriginalTop + deltaY;

    mBlockLayoutRequests = true;

     if (count &amp;gt; 0) {//如果存在完全离开了ListView可视范围的子视图  
        detachViewsFromParent(start, count);//将这些完全离开了可是范围的子视图全部删掉  
        mRecycler.removeSkippedScrap();//从视图重用池中删除需要丢弃的视图  
    }  


    //将未删除的所有的子视图朝上（下）移动incrementalDeltaY这么多距离  
    offsetChildrenTopAndBottom(incrementalDeltaY);  
    //更新第一个子视图对应的item在适配器中的位置  
    if (down) {  
        mFirstPosition += count;  
    }  

    final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);  
    //如果还有可移动的范围  
    if (spaceAbove &amp;lt; absIncrementalDeltaY || spaceBelow &amp;lt; absIncrementalDeltaY) {  
      //因为有可能有一些子视图完全离开了ListView范围，所有需要重新加载新的item来填充ListView的空白  
        fillGap(down);  
    }  
    ......
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这部分过程如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/xtGmNmf.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;fillGap在AbsListView.java是个抽象方法，那么显然在子类中找其重写的具体实现方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;abstract void fillGap(boolean down);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;[ListView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//这里参数down应该是true，我们是从上向下滑动
@Override
void fillGap(boolean down) {
    final int count = getChildCount();
    if (down) {
        int paddingTop = 0;
        if ((mGroupFlags &amp;amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            paddingTop = getListPaddingTop();
        }
        final int startOffset = count &amp;gt; 0 ? getChildAt(count - 1).getBottom() + mDividerHeight :
                paddingTop;
        //看到还是调用fillDown方法
        fillDown(mFirstPosition + count, startOffset);
        correctTooHigh(getChildCount());
    } else {
        int paddingBottom = 0;
        if ((mGroupFlags &amp;amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            paddingBottom = getListPaddingBottom();
        }
        final int startOffset = count &amp;gt; 0 ? getChildAt(0).getTop() - mDividerHeight :
                getHeight() - paddingBottom;
        fillUp(mFirstPosition - 1, startOffset);
        correctTooLow(getChildCount());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再次来看fillDown方法&lt;/p&gt;
&lt;p&gt;[ListView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 从pos开始从上向下填充ListViwe
 *
 * @param pos 
 *        list中的位置
 *        
 * @param nextTop 
 *        下一个Item应该放置的位置
 *
 * @return 
 *       返回选择位置的View,这个位置在我们的放置范围之内
 */
private View fillDown(int pos, int nextTop) {
    View selectedView = null;

    int end = (mBottom - mTop);
    if ((mGroupFlags &amp;amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        end -= mListPadding.bottom;
    }

    /**
    *这里循环判断，终止的条件是下一个item放置的位置&amp;gt;listview的底部或者当前的位置&amp;gt;总数
    */
    while (nextTop &amp;lt; end &amp;amp;&amp;amp; pos &amp;lt; mItemCount) {
        
        boolean selected = pos == mSelectedPosition;
        /**
        *这里调用makeAndAddView来获得一个View
        */
        View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected);
        
        //更新nextTop的值
        nextTop = child.getBottom() + mDividerHeight;
        if (selected) {
            selectedView = child;
        }
        //自增pos
        pos++;
    }

    setVisibleRangeHint(mFirstPosition, mFirstPosition + getChildCount() - 1);
    return selectedView;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;fillDown逻辑并没有什么变化，再次makeAndAddView&lt;/p&gt;
&lt;p&gt;[ListView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 获取一个View并添加进ListView。这个View呢可能是新创建的，也有可能是来自mActiveViews，或者是来自mScrapViews
 * @param position 
 *        列表中的逻辑位置
 * @param y 
 *       被添加View的上 边位置或者下 边位置
 * @param flow 
 *        如果flow是true，那么y是View的上 边位置，否则那么y是View的下 边位置
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @return 
 *       返回被添加的View
 */
private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,
        boolean selected) {
    View child;


    if (!mDataChanged) {
        // 尝试从mActiveViews中获取，因为我们第2次layout中已经从mActiveViews中获取到View了，，所以这次获取的为null
        child = mRecycler.getActiveView(position);
        if (child != null) {
            //这里child不为空，调用setupChild，注意最后一个参数为true
            setupChild(child, position, y, flow, childrenLeft, selected, true);

            return child;
        }
    }

    // 为这个position创建View
    child = obtainView(position, mIsScrap);

    // 调用setupChild
    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);

    return child;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着我们又来到了obtainView，不夸张的说，整个ListView中最重要的内容可能就在这个方法里了&lt;/p&gt;
&lt;p&gt;[ListView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 获取一个视图，并让它显示与指定的数据相关联的数据的位置。
 *当我们已经发现视图无法在RecycleBin重复使用。剩下的唯一选择就是转换旧视图或创建新视图。
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 *                the returned view was taken from the scrap heap, false if otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */
View obtainView(int position, boolean[] isScrap) {
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;obtainView&quot;);

    isScrap[0] = false;


    final View transientView = mRecycler.getTransientStateView(position);
    if (transientView != null) {
        final LayoutParams params = (LayoutParams) transientView.getLayoutParams();

        // If the view type hasn't changed, attempt to re-bind the data.
        if (params.viewType == mAdapter.getItemViewType(position)) {
            final View updatedView = mAdapter.getView(position, transientView, this);

            // If we failed to re-bind the data, scrap the obtained view.
            if (updatedView != transientView) {
                setItemViewLayoutParams(updatedView, position);
                mRecycler.addScrapView(updatedView, position);
            }
        }

        isScrap[0] = true;

        // Finish the temporary detach started in addScrapView().
        transientView.dispatchFinishTemporaryDetach();
        return transientView;
    }

    final View scrapView = mRecycler.getScrapView(position);
    final View child = mAdapter.getView(position, scrapView, this);
    if (scrapView != null) {
        if (child != scrapView) {
            // Failed to re-bind the data, return scrap to the heap.
            mRecycler.addScrapView(scrapView, position);
        } else {
            isScrap[0] = true;

            // Finish the temporary detach started in addScrapView().
            child.dispatchFinishTemporaryDetach();
        }
    }

    if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }

    if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
        child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
    }

    setItemViewLayoutParams(child, position);

    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        if (child.getAccessibilityDelegate() == null) {
            child.setAccessibilityDelegate(mAccessibilityDelegate);
        }
    }

    Trace.traceEnd(Trace.TRACE_TAG_VIEW);

    return child;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到这句&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;final View scrapView = mRecycler.getScrapView(position);
final View child = mAdapter.getView(position, scrapView, this);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RecyleBin的getScrapView()方法来尝试从废弃缓存中获取一个View，那么废弃缓存有没有View呢？当然有，因为刚才在trackMotionScroll()方法中我们就已经看到了，一旦有任何子View被移出了屏幕，就会将它加入到废弃缓存中，而从obtainView()方法中的逻辑来看，一旦有新的数据需要显示到屏幕上，就会尝试从废弃缓存中获取View。所以它们之间就形成了一个生产者和消费者的模式，那么ListView神奇的地方也就在这里体现出来了，不管你有任意多条数据需要显示，ListView中的子View其实来来回回就那么几个，移出屏幕的子View会很快被移入屏幕的数据重新利用起来，因而不管我们加载多少数据都不会出现OOM的情况，甚至内存都不会有所增加。&lt;/p&gt;
&lt;p&gt;那么另外还有一点是需要大家留意的，这里获取到了一个scrapView，然后我们在第上述代码中第2行将它作为第二个参数传入到了Adapter的getView()方法当中。我们再次来看我们重写的getView方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ListViewAdapter extends BaseAdapter {

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {

        if (convertView == null){
            viewHolder = new ViewHolder();
            convertView = inflater.inflate(R.layout.list_view_item_simple, null);
            viewHolder.mTextView=(TextView) convertView.findViewById(R.id.text_view);
            convertView.setTag(viewHolder);

            Log.d(TAG,&quot;convertView == null&quot;);
        }else {
            Log.d(TAG,&quot;convertView != null&quot;);
            viewHolder = (ViewHolder) convertView.getTag();
        }

        viewHolder.mTextView.setText(mList.get(position));
        return convertView;
    }

   
    static class ViewHolder {
        private TextView mTextView;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这次convertView不为null了，最后返回了convertView&lt;/p&gt;
&lt;p&gt;这下你彻底明白了吗？？&lt;/p&gt;
&lt;p&gt;最后再上张图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/CsQfIuR.png&quot;/&gt;&lt;/p&gt;


&lt;p&gt;本篇呢，分析详细介绍了ListView及其View复用机制，文中若有不正确或者不恰当的地方，欢迎各位读者前来拍砖。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;下篇呢我们把ListView换成RecyclerView&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/guolin_blog/article/details/44996879&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/guolin_blog/article/details/44996879&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;此致，敬礼&lt;/p&gt;
</description>
<pubDate>Sun, 11 Feb 2018 05:34:00 +0000</pubDate>
<dc:creator>忘了12138</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangle12138/p/8441136.html</dc:identifier>
</item>
<item>
<title>Android端生成META-INF信息文件的Gradle插件 RapidMetaInfPlugin - 天天_byconan</title>
<link>http://www.cnblogs.com/tiantianbyconan/p/8441115.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiantianbyconan/p/8441115.html</guid>
<description>&lt;blockquote readability=&quot;3.6511627906977&quot;&gt;
&lt;p&gt;来源博客：&lt;a href=&quot;http://blog.wangjiegulu.com&quot;&gt;Wang Jie's Blog&lt;/a&gt;&lt;br/&gt;本文链接：&lt;a href=&quot;http://blog.wangjiegulu.com/2018/02/05/Android%E7%AB%AF%E7%94%9F%E6%88%90META-INF%E4%BF%A1%E6%81%AF%E6%96%87%E4%BB%B6%E7%9A%84Gradle%E6%8F%92%E4%BB%B6%20RapidMetaInfPlugin/&quot;&gt;http://blog.wangjiegulu.com/2018/02/05/Android%E7%AB%AF%E7%94%9F%E6%88%90META-INF%E4%BF%A1%E6%81%AF%E6%96%87%E4%BB%B6%E7%9A%84Gradle%E6%8F%92%E4%BB%B6%20RapidMetaInfPlugin/&lt;/a&gt;&lt;br/&gt;版权声明：本博客所有文章除特别声明外，均采用 CC BY 4.0 CN协议 许可协议。转载请注明出处。&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;需求背景&quot;&gt;1. 需求背景&lt;/h2&gt;
&lt;p&gt;最近新遇到了一个需求，想在自己的一些库中写入版本信息，在别人使用了我的库后，我可以通过apk文件检测出依赖了我的哪个版本的库。感觉这个需求有点多余？那就举个例子吧。&lt;/p&gt;
&lt;p&gt;比如，我编写了一个开源库：&lt;a href=&quot;https://github.com/wangjiegulu/RapidORM&quot;&gt;RapidORM&lt;/a&gt;，并&lt;a href=&quot;http://blog.wangjiegulu.com/2015/04/02/Android-%E4%BD%BF%E7%94%A8Gradle%E6%8F%90%E4%BA%A4%E8%87%AA%E5%B7%B1%E5%BC%80%E6%BA%90Android%E5%BA%93%E5%88%B0Maven%E4%B8%AD%E5%BF%83%E5%BA%93/&quot;&gt;上传到了Maven中心库&lt;/a&gt; ，假设一个我不认识的开发者（暂且称它为&lt;code&gt;X&lt;/code&gt;）在编写app，这个app中的代码对我来说是完全未知的，但是他通过在&lt;code&gt;build.gradle&lt;/code&gt;中添加了如下依赖：&lt;/p&gt;
&lt;pre class=&quot;groovy&quot;&gt;
&lt;code&gt;compile &quot;com.github.wangjiegulu:rapidorm:1.0.0&quot;
compile &quot;com.github.wangjiegulu:rapidorm-api:1.0.0&quot;
apt &quot;com.github.wangjiegulu:rapidorm-compiler:1.0.0&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很明显，&lt;code&gt;X&lt;/code&gt;依赖了我写的&lt;code&gt;RapidORM&lt;/code&gt;库。并且打包成了Apk文件然后发布。这时我下载了这个apk，并且希望得到这个apk中依赖的&lt;code&gt;RapidORM&lt;/code&gt;版本是多少？这个&lt;code&gt;RapidORM&lt;/code&gt;在构建这个aar时的开发环境是怎么样的？反编译可能有希望能拿到&lt;code&gt;RapidORM&lt;/code&gt;具体的版本号，但是aar当时的构建环境就无法得知了。&lt;/p&gt;
&lt;p&gt;这时，我就希望在我发布&lt;code&gt;RapidORM&lt;/code&gt;的Release版本的时候能够在aar中携带好一些自定义的参数，并且这些信息会在依赖了这个库的开发者&lt;code&gt;X&lt;/code&gt;构建apk的时候跟随保存到apk文件中。&lt;/p&gt;
&lt;p&gt;比较典型的一个例子当你依赖了&lt;code&gt;RxJava&lt;/code&gt;这个库，我们构建apk完成之后，会发现在我们的apk文件中的&lt;code&gt;META-INF&lt;/code&gt;文件夹下面会有一个&lt;code&gt;rxjava.properties&lt;/code&gt;文件，打开这个文件就会发现如下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Manifest-Version=1.0
Implementation-Title=io.reactivex.rxjava2#rxjava;2.1.2
Implementation-Version=2.1.2
Built-Status=integration
Built-By=travis
Built-OS=Linux
Build-Date=2017-07-23_08:21:58
Gradle-Version=2.14
Module-Owner=benjchristensen@netflix.com
Module-Email=benjchristensen@netflix.com
Module-Source=
Module-Origin=https://github.com/ReactiveX/RxJava.git
Change=e4fbe4c
Branch=e4fbe4cfcb3c240d14a42a586eecbbd74cb379d2
Build-Host=testing-gce-361876de-b66f-4569-b841-e037b0fee9af
Build-Job=LOCAL
Build-Number=LOCAL
Build-Id=LOCAL
Created-By=1.7.0_80-b15 (Oracle Corporation)
Build-Java-Version=1.7.0_80
X-Compile-Target-JDK=1.6
X-Compile-Source-JDK=1.6&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很显然，这个文件中包含了：&lt;code&gt;RxJava版本号&lt;/code&gt;, &lt;code&gt;构建的CI信息&lt;/code&gt;，&lt;code&gt;构建时间&lt;/code&gt;, &lt;code&gt;Gradle版本&lt;/code&gt;, &lt;code&gt;模块负责人信息&lt;/code&gt;, &lt;code&gt;git分支&lt;/code&gt;, &lt;code&gt;JDK版本&lt;/code&gt;等等。&lt;/p&gt;
&lt;p&gt;通过这个方式，我可以在任意的apk中拿到它依赖的&lt;code&gt;RxJava&lt;/code&gt;的信息。&lt;/p&gt;
&lt;p&gt;当然，你可以通过在&lt;code&gt;build.gradle&lt;/code&gt;进行如下配置来过排除这个&lt;code&gt;rxjava.properties&lt;/code&gt;文件（但是不建议这么做，这个文件也许能在你遇到问题时给你帮助）：&lt;/p&gt;
&lt;pre class=&quot;groovy&quot;&gt;
&lt;code&gt;android {
    ...
    packagingOptions {
        exclude 'META-INF/rxjava.properties'
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote readability=&quot;1.4492753623188&quot;&gt;
&lt;p&gt;&lt;strong&gt;RapidMetaInfPlugin:&lt;/strong&gt; &lt;a href=&quot;https://github.com/wangjiegulu/RapidMetaInfPlugin&quot; class=&quot;uri&quot;&gt;https://github.com/wangjiegulu/RapidMetaInfPlugin&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，写了 &lt;a href=&quot;https://github.com/wangjiegulu/RapidMetaInfPlugin&quot;&gt;RapidMetaInfPlugin&lt;/a&gt; 这个 Gradle 插件。&lt;/p&gt;
&lt;p&gt;这次先说说怎么使用这个插件，以后抽时间再写一篇 Gradle 插件编写教程。之前也写过一个Gradle插件（详情见&lt;a href=&quot;http://blog.wangjiegulu.com/2017/04/19/Android-Gradle-%E6%8F%92%E4%BB%B6-DiscardFilePlugin%EF%BC%88class%E6%B3%A8%E5%85%A5-%E6%B8%85%E7%A9%BA%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%89/&quot;&gt;Android Gradle 插件 DiscardFilePlugin（清空类和方法）&lt;/a&gt;）也挺实用的。&lt;/p&gt;
&lt;h3 id=&quot;最终效果&quot;&gt;2.1 最终效果&lt;/h3&gt;
&lt;p&gt;通过这个插件，我们可以在&lt;code&gt;apk&lt;/code&gt;或者&lt;code&gt;aar&lt;/code&gt;（&lt;code&gt;app&lt;/code&gt;依赖后合并到&lt;code&gt;apk&lt;/code&gt;）中写入任意信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/wangjiegulu/RapidMetaInfPlugin/raw/master/images/apk_meta_inf.png&quot; width=&quot;600px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上在这个&lt;code&gt;apk&lt;/code&gt;的&lt;code&gt;META-INF&lt;/code&gt;中生成了一个名为&lt;code&gt;DAL_REQUEST.properties&lt;/code&gt;的文件，内容中包含了&lt;code&gt;dal_request&lt;/code&gt;这个库的名字、版本号和url。&lt;/p&gt;
&lt;h3 id=&quot;如何使用&quot;&gt;2.2 如何使用&lt;/h3&gt;
&lt;p&gt;在你的&lt;code&gt;buildscript&lt;/code&gt;的&lt;code&gt;dependencies&lt;/code&gt;中添加&lt;code&gt;classpath&lt;/code&gt;依赖（&lt;a href=&quot;http://search.maven.org/#search%7Cga%7C1%7CRapidMetaInf&quot;&gt;点击这里获取最新版本&lt;/a&gt;）：&lt;/p&gt;
&lt;pre class=&quot;groovy&quot;&gt;
&lt;code&gt;buildscript {
    repositories {
        jcenter()
        google()
    }
    dependencies {
        // ...
        classpath ('com.github.wangjiegulu:rapidmetainf:x.x.x'){
            exclude group: 'com.android.tools.build', module: 'gradle'
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在你的apk或者aar的&lt;code&gt;build.gradle&lt;/code&gt;文件的顶部写入以下代码来使用插件：&lt;/p&gt;
&lt;pre class=&quot;groovy&quot;&gt;
&lt;code&gt;apply plugin: 'com.github.wangjiegulu.plg.rapidmetainf'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后通过如下方式填写你需要写进&lt;code&gt;META-INF&lt;/code&gt;目录中的文件信息：&lt;/p&gt;
&lt;pre class=&quot;groovy&quot;&gt;
&lt;code&gt;rapidmetainf {
    metaInfName 'DAL_REQUEST.properties'
    metaInfProperties &quot;archiveName=$dbarchiveName&quot;,
            &quot;archiveVersion=$dbarchiveVersion&quot;,
            &quot;archiveUrl=$dbarchiveUrl&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，&lt;code&gt;metaInfName&lt;/code&gt;表示在&lt;code&gt;META-INF&lt;/code&gt;目录中生成的文件名称（文件名任意取，但是不能以&quot;.&quot;开头），&lt;code&gt;metaInfProperties&lt;/code&gt;表示要写入文件的数据，这个变量为数组类型，可通过Groovy语法来编写，比如通过&lt;code&gt;$符号来引用ext&lt;/code&gt;，通过如下命令参数的方式等等：&lt;/p&gt;
&lt;pre class=&quot;groovy&quot;&gt;
&lt;code&gt;rapidmetainf {
    metaInfName 'DAL_REQUEST_DEMO.properties'

    String[] infArray = new String[10]
    // ./gradlew clean build -PcommandKey=commandValue
    infArray[0] = &quot;propertyFromCommand=${getParameter('commandKey')}&quot;
    for(int i = 1; i &amp;lt; infArray.length; i++){
        infArray[i] = &quot;array_item_key_$i=array_item_value_$i&quot;
    }

    metaInfProperties infArray
}

def getParameter(String key) {
    // -D
    String value = System.getProperty(key)
    if (null != value &amp;amp;&amp;amp; value.length() &amp;gt; 0) {
        return value
    }
    // -P
    if (hasProperty(key)) {
        return getProperty(key)
    }
    return null
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上，CI构建时就可使用命令&lt;code&gt;./gradlew clean build -PcommandKey=commandValue&lt;/code&gt;来把&lt;code&gt;commandValue&lt;/code&gt;写入到文件中。&lt;/p&gt;
</description>
<pubDate>Sun, 11 Feb 2018 05:22:00 +0000</pubDate>
<dc:creator>天天_byconan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tiantianbyconan/p/8441115.html</dc:identifier>
</item>
<item>
<title>Python元编程 - 小兵千睿</title>
<link>http://www.cnblogs.com/xiaobingqianrui/p/8435075.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaobingqianrui/p/8435075.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;　　简单定义“元编程是一种编写计算机程序的技术，这些程序可以将自己看做数据，因此你可以在运行时对它进行内审、生成和/或修改”，本博参考&amp;lt;&amp;lt;Python高级编程&amp;gt;&amp;gt;将对元编程内容进行详细描述，若有不正确之处希望大家指出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;1. 概述&lt;/h2&gt;
&lt;p&gt;　　Python元编程有两种方法，一是采用类似“装饰器”的工具对基本元素（例如函数、类、类型）内审和对其进行实时创建和修改，二是运用类型&quot;元类&quot;的方式对类实例的创建过程进行修改，甚至于允许重新设计Python面对对象编程范式的实现。&lt;/p&gt;
&lt;h2&gt;2. 装饰器&lt;/h2&gt;
&lt;p&gt;　　关于装饰器的内容可以阅读上篇博客&amp;lt;&amp;lt;Python装饰器&amp;gt;&amp;gt;，链接：&lt;a title=&quot;Python装饰器&quot; href=&quot;http://www.cnblogs.com/xiaobingqianrui/p/8435074.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/xiaobingqianrui/p/8435074.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;　　对wraps装饰器的使用进行补充说明，在类装饰器中使用闭包会导致生成的对象不再是被装饰的类的实例，二是在装饰器函数创建的子类的实例，这会影响__name__和__doc__等属性，在上篇我们使用@wraps装饰器对函数装饰器进行操作让问题得到解决，但在类装饰器中这一方法无效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;3. 元类&lt;/h2&gt;
&lt;p&gt;　　元类是Python的一个重要特性，是定义其他类的类，理解其工作方式，最重要的是要知道定义了对象实例的类也是对象，那么它一定有与其相关联的类，所有的类定义的基类都是内置的type类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding=utf-8&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass:
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    myclass &lt;/span&gt;=&lt;span&gt; MyClass()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type of myclass:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, type(myclass))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type of MyClass:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, type(MyClass))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; type of myclass: &amp;lt;class '__main__.MyClass'&amp;gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; type of MyClass: &amp;lt;class 'type'&amp;gt;&lt;/p&gt;
&lt;h3&gt;3.1 type()语法&lt;/h3&gt;
&lt;p&gt;　　type()类作为class语句的动态等效，给定类名，基类名和属性映射会创建一个新类　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding=utf-8&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1(self):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (1&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; func2(*&lt;span&gt;argv):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; (argv)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    MyClass &lt;/span&gt;= type(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyClass&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(object, ), {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;func1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:func1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;func2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:func2})
    a &lt;/span&gt;=&lt;span&gt; MyClass()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; (type(a))
    a.func1()
    a.func2(2)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; &amp;lt;class '__main__.MyClass'&amp;gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; 1&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; (&amp;lt;__main__.MyClass object at 0x01A02270&amp;gt;,2)&lt;/p&gt;
&lt;h3&gt;3.2 元类的常用模板 &lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding=utf-8&lt;/span&gt;

&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;元类模板 &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass(type):
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个空的命名空间，返回一个空的dict   &lt;/span&gt;
&lt;span&gt;    @classmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__prepare__&lt;/span&gt;(mcs, name, bases, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyClass __prepare__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; super().&lt;span&gt;__prepare__&lt;/span&gt;(name, bases, **&lt;span&gt;kwargs)   

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(mcs, name, bases, namespace):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyClass __new__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; super().&lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(mcs, name, bases, namespace)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(cls, name, bases, namespace, **&lt;span&gt;kdargv):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyClass __init__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)   
        super().&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(name, bases, namespace)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(cls, *argv, **&lt;span&gt;kdargv):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyClass __call__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; super().&lt;span&gt;__call__&lt;/span&gt;(*argv, **&lt;span&gt;kdargv)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; _MyClass(metaclass=&lt;span&gt;MyClass):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(cls):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_MyClass __new__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; super().&lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(cls)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__MyClass __init__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        super().&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    a &lt;/span&gt;=&lt;span&gt;  _MyClass()
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; MyClass __prepare__&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; MyClass __new__&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; MyClass __init__&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; MyClass __call__&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; _MyClass __new__&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; __MyClass __init_&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;用class语句创建的每个类都隐式的使用type作为元类，可以用metaclass=“指定元类”的方式改变这一默认行为。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;3.3 元类的使用&lt;/h3&gt;
&lt;p&gt;　　元类是一种非常强大的特性，但总是会是代码更加复杂，将其用于任意类型的类时，这可能会降低代码的鲁棒性，我们必须灵活的使用元类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding=utf-8&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderedMeta(type):
    @classmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__prepare__&lt;/span&gt;(mcs, name, bases, **&lt;span&gt;kdargv):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; super().&lt;span&gt;__prepare__&lt;/span&gt;(mcs, name, bases, **&lt;span&gt;kdargv)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(mcs, name, bases, namespace):
        namespace[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;orderofattr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; list(namespace.keys())
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; super().&lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(mcs, name, bases, namespace)
        
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; test(metaclass =&lt;span&gt; OrderedMeta):
    first &lt;/span&gt;= 8&lt;span&gt;
    secord &lt;/span&gt;= 2

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; (test.orderofattr)    
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (test.&lt;span&gt;__dict__&lt;/span&gt;.keys())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; ['__module__', '__qualname__', 'first', 'secord']&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; dict_keys(['__module__', 'first', 'secord', 'orderofattr', '__dict__', '__weakre&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; f__', '__doc__'])&lt;/p&gt;
</description>
<pubDate>Sun, 11 Feb 2018 05:20:00 +0000</pubDate>
<dc:creator>小兵千睿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaobingqianrui/p/8435075.html</dc:identifier>
</item>
<item>
<title>python+xlsxwriter+PIL自动压图贴图到Excel小工具 - Medivh_Xu</title>
<link>http://www.cnblogs.com/medivhxu/p/8441093.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/medivhxu/p/8441093.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python3&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; coding=utf-8&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlsxwriter
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; datetime
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; argparse
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; logging
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Image

LOGGER &lt;/span&gt;= logging.getLogger(&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)

PLATFORM &lt;/span&gt;= {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;phone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x_scale&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 0.29&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y_scale&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 0.29&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 23.38&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 210.75&lt;span&gt;
},
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pad&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x_scale&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.2&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y_scale&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 0.2&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 58&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 230&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oppo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x_scale&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.29&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y_scale&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.3&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 22.17&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 230&lt;span&gt;
    }
}


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; _check_os_dir(read_dir_name, small_dir_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;small&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, xlsx_file_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    检测img文件夹及文件夹中的内容、xlsx文件是否存在
    
    :param read_dir_name: 要读取图片的文件夹
    :param small_dir_name: 压缩的图片文件夹
    :param xlsx_file_name: excel文件名
    :return: 
            all_img：所有图片对象
            xls_path：excel文件路径
            img_path：图片文件路径
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

    full_name &lt;/span&gt;= read_dir_name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_img&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    img_path &lt;/span&gt;=&lt;span&gt; os.path.join(os.getcwd(), full_name)

    LOGGER.info(img_path)
    &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; os.path.isdir(img_path), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;what?你都没有{}文件夹，我咋给你贴图啊！！！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(full_name)

    all_img &lt;/span&gt;=&lt;span&gt; os.listdir(img_path)
    &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; all_img, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}文件夹里啥也没有，咋贴！！！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(full_name)

    xls_path &lt;/span&gt;=&lt;span&gt; os.path.join(os.getcwd(), xlsx_file_name)
    &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; os.path.isfile(xls_path), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}文件不存在！！！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(xlsx_file_name)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; small_full_name = small_dir_name + datetime.datetime.now().strftime(&quot;%Y%m%d%H%M%S&quot;)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; full_name ==&lt;span&gt; small_dir_name:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; all_img, xls_path, img_path

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; os.mkdir(&quot;{}&quot;.format(small_full_name))&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; LOGGER.warning(&quot;新建文件夹{},压缩后的图片将存储在该文件夹中。&quot;.format(small_dir_name))&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; all_img, xls_path, img_path


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; _compression_img(read_dir_name, small_dir_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;small&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, height_shrink_multiple=2, width_shrink_multiple=2&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    自动压缩指定文件夹下的所有图片

    :param read_dir_name: 读取图片文件夹的名称
    :param small_dir_name：如果压缩图片就读取该文件夹下的压缩图片
    :param height_shrink_multiple: 设置图片压缩高度的倍数
    :param width_shrink_multiple: 设置图片压缩宽度的倍数
    :return: small_dir_name： 压缩后的图片文件名
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

    full_small_dir_name &lt;/span&gt;= small_dir_name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_img&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    _check_os_dir(read_dir_name&lt;/span&gt;=read_dir_name, small_dir_name=&lt;span&gt;full_small_dir_name)

    img_path &lt;/span&gt;= os.path.join(os.getcwd(), read_dir_name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_img&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    all_img &lt;/span&gt;=&lt;span&gt; os.listdir(img_path)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; unit_img &lt;span&gt;in&lt;/span&gt;&lt;span&gt; all_img:
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            img_num &lt;/span&gt;= unit_img.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            row &lt;/span&gt;=&lt;span&gt; int(img_num[0])
            column &lt;/span&gt;= int(img_num[1].split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)[0])
            suffix &lt;/span&gt;= (unit_img.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[1&lt;span&gt;])
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; column ==&lt;span&gt; 0:
                LOGGER.warning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;图片名称格式有误直接略过！错误文件名：{}，“-”前后数字必须从1开始！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(unit_img))
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt;&lt;span&gt; ValueError:
            LOGGER.warning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[-]图片命名规则有误直接略过！错误文件名是：{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(unit_img))
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;

        img_fp &lt;/span&gt;=&lt;span&gt; os.path.join(img_path, unit_img)
        origin_img &lt;/span&gt;=&lt;span&gt; Image.open(img_fp)
        w, h &lt;/span&gt;=&lt;span&gt; origin_img.size
        small_img &lt;/span&gt;= origin_img.resize((int(w / height_shrink_multiple), int(h /&lt;span&gt; width_shrink_multiple)))

        small_img.save(os.path.join(os.getcwd(), &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}/{}-{}.{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(full_small_dir_name, row, column, suffix)))
        LOGGER.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt; 正在处理图像{}-{}.{},原像素高和宽{}，压缩后的高和宽{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(row, column, suffix, (w, h), small_img.size))
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            small_img.close()
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
            LOGGER.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;未知错误\n{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(e))
    LOGGER.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------图片压缩完成--------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; small_dir_name


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; write_img_for_xls(platform, read_dir_name, sheet_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;案例截图&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, xlsx_file_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    读取同目录img文件夹下的所有图片，格式支持png\jpg\bmp。
    图片必须遵从  1-1.png、1-2.png、2-1.png、2-2.png格式。
    注意：是将图片写入新的excel文件，如果老的excel中有数据，将会替换所有数据。

    platform: 平台名称，包括phone、pad，web目前没实现
    read_dir_name： 要读取图片的文件夹名称
    xlsx_file_name: 要写入的xlsx文件名
    sheet_name: 写入excel中sheet的名字

    :return: nothing
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    all_img, xls_path, img_path &lt;/span&gt;= _check_os_dir(xlsx_file_name=xlsx_file_name, read_dir_name=&lt;span&gt;read_dir_name)

    w_book &lt;/span&gt;=&lt;span&gt; xlsxwriter.Workbook(xls_path)
    img_sheet &lt;/span&gt;= w_book.add_worksheet(name=&lt;span&gt;sheet_name)
    count_num &lt;/span&gt;=&lt;span&gt; 0

    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; unit_img &lt;span&gt;in&lt;/span&gt;&lt;span&gt; all_img:
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                img_num &lt;/span&gt;= unit_img.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                row &lt;/span&gt;=&lt;span&gt; int(img_num[0])
                column &lt;/span&gt;= int(img_num[1].split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)[0])
                suffix &lt;/span&gt;= (unit_img.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[1&lt;span&gt;])
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; column ==&lt;span&gt; 0:
                    LOGGER.warning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;图片名称格式有误直接略过！错误文件名：{}，“-”前后数字必须从1开始！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(unit_img))
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;
            &lt;span&gt;except&lt;/span&gt;&lt;span&gt; ValueError:
                LOGGER.warning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[-]图片命名规则有误直接略过！错误文件名是：{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(unit_img))
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;

            LOGGER.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt; 正在贴图到第{}条用例，第{}列...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(row, column))
            img_sheet.set_column(firstcol&lt;/span&gt;=0, lastcol=0, width=8.38&lt;span&gt;)
            img_sheet.write(row &lt;/span&gt;- 1, 0, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;案例{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(row))

            small_img &lt;/span&gt;= os.path.join(os.getcwd(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}/{}-{}.{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(read_dir_name+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_img&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, row, column,
                                                                       suffix))

            img_sheet.set_column(firstcol&lt;/span&gt;=column, lastcol=column, width=PLATFORM.get(platform).get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            img_sheet.set_row(row&lt;/span&gt;=row - 1, height=PLATFORM.get(platform).get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

            x_ &lt;/span&gt;= PLATFORM.get(platform).get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x_scale&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            y_ &lt;/span&gt;= PLATFORM.get(platform).get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y_scale&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            img_config &lt;/span&gt;= {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x_scale&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: x_, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y_scale&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: y_}

            result &lt;/span&gt;= img_sheet.insert_image(row - 1&lt;span&gt;, column, small_img, img_config)
            img_sheet.write_url(row &lt;/span&gt;- 1, column + 1, url=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://my.oschina.net/medivhxu/blog/1590012&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; result:
                LOGGER.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[+] 写入成功！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                count_num &lt;/span&gt;+= 1
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                LOGGER.error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[-] 写入失败!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
        &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; MyException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;受到不明外力袭击，程序...挂了....\n{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(e))
    &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            w_book.close()
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; PermissionError:
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; MyException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你开着{}文件我让我咋写。。。赶紧关了!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(xlsx_file_name))
    LOGGER.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------贴图完成--------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    LOGGER.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;程序贴图数量：{}，贴图成功数量：{}，贴图失败数量：{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(len(all_img), count_num, len(all_img) -&lt;span&gt; count_num))


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyException(Exception):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;


&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    parser &lt;/span&gt;=&lt;span&gt; argparse.ArgumentParser()
    parser.add_argument(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, help=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;必须选择平台phone、pad、oppo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    group &lt;/span&gt;=&lt;span&gt; parser.add_mutually_exclusive_group()
    group.add_argument(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, action=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;store_true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, help=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;压缩图片且贴图到excel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    group.add_argument(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-w&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, action=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;store_true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, help=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;直接贴图到excel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    args &lt;/span&gt;=&lt;span&gt; parser.parse_args()

    logging.basicConfig(level&lt;/span&gt;=&lt;span&gt;logging.DEBUG,
                        format&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                        datefmt&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%a, %d %b %Y %H:%M:%S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                        filename&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Paste_pictures_{}.log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(datetime.datetime.now().strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y%m%d%H%M%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)),
                        filemode&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    console &lt;/span&gt;=&lt;span&gt; logging.StreamHandler()
    console.setLevel(logging.INFO)
    formatter &lt;/span&gt;= logging.Formatter(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%(name)-12s: %(levelname)-8s %(message)s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    console.setFormatter(formatter)
    logging.getLogger(&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;).addHandler(console)

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; args.p &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; PLATFORM.keys():
        &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; MyException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;参数错误，必须在{}中选择&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(PLATFORM.keys()))
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; args.a:
        LOGGER.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 选择参数-a,即压缩图片，又贴图。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        r_small_dir_name &lt;/span&gt;= _compression_img(read_dir_name=args.p, small_dir_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;small&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        write_img_for_xls(platform&lt;/span&gt;=args.p, read_dir_name=&lt;span&gt;r_small_dir_name)
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt;&lt;span&gt; args.w:
        LOGGER.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 选择参数-w,只贴图。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        write_img_for_xls(platform&lt;/span&gt;=args.p, read_dir_name=&lt;span&gt;args.p)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        LOGGER.error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;参数错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;</description>
<pubDate>Sun, 11 Feb 2018 05:08:00 +0000</pubDate>
<dc:creator>Medivh_Xu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/medivhxu/p/8441093.html</dc:identifier>
</item>
</channel>
</rss>