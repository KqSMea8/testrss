<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>GO开发[三]：fmt,strings,strconv，指针，控制结构 - 宁生信</title>
<link>http://www.cnblogs.com/gregoryli/p/8299412.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gregoryli/p/8299412.html</guid>
<description>&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;%v  值的默认格式表示。当输出结构体时，扩展标志（%+v）会添加字段名
%#v 值的Go语法表示
%T  值的类型的Go语法表示
%%  百分号
%t  单词true或false
%b  表示为二进制
%c  该值对应的unicode码值
%d  表示为十进制
%o  表示为八进制
%q  该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示
%x  表示为十六进制，使用a-f
%X  表示为十六进制，使用A-F
%U  表示为Unicode格式：U&lt;span class=&quot;dv&quot;&gt;+1234&lt;/span&gt;，等价于&lt;span class=&quot;st&quot;&gt;&quot;U+%04X&quot;&lt;/span&gt;
%b  无小数部分、二进制指数的科学计数法，如-123456p&lt;span class=&quot;dv&quot;&gt;-78&lt;/span&gt;；参见strconv.FormatFloat %e 科学计数法，如-&lt;span class=&quot;dv&quot;&gt;1234&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;.456e+78&lt;/span&gt; %E 科学计数法，如-&lt;span class=&quot;dv&quot;&gt;1234&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;.456E+78&lt;/span&gt; %f 有小数部分但无指数部分，如123&lt;span class=&quot;fl&quot;&gt;.456&lt;/span&gt; %F 等价于%f %g    根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）
%G  根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）
%s  直接输出字符串或者[]&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt; %q  该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示
%x  每个字节用两字符十六进制数表示（使用a-f）
%X  每个字节用两字符十六进制数表示（使用A-F）
%p  表示为十六进制，并加上前导的0x
宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可能有的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为0。
%f:    默认宽度，默认精度
%9f    宽度9，默认精度
%.2f   默认宽度，精度2 %&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;.2f  宽度9，精度2 %&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;.f   宽度9，精度0
+   总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）；
-   在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）；
#   切换格式：
    八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）；
    对%q（%#q），如果strconv.CanBackquote返回真会输出反引号括起来的未转义字符串；
    对%U（%#U），如果字符是可打印的，会在输出Unicode格式、空格、单引号括起来的go字面值；
' ' 对数值，正数前加空格而负数前加负号；
    对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格；
&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;   使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面；&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main()  {
   a:=fmt.Sprintf(&lt;span class=&quot;st&quot;&gt;&quot;%[2]d %[1]d&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;22&lt;/span&gt;)
   fmt.Println(a)

   b:=fmt.Sprintf(&lt;span class=&quot;st&quot;&gt;&quot;%[3]*.[2]*[1]f&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;.0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;)
   fmt.Println(b) &lt;span class=&quot;co&quot;&gt;//在'*'之前的[n]符号表示采用第n个参数的值作为宽度或精度&lt;/span&gt;

   c:=fmt.Sprintf(&lt;span class=&quot;st&quot;&gt;&quot;%4.2f&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;.0&lt;/span&gt;)
   fmt.Println(c) &lt;span class=&quot;co&quot;&gt;//显式的索引会影响随后的verb，这种符号可以通过重设索引用于多次打印同一个值&lt;/span&gt;

   d := fmt.Sprintf(&lt;span class=&quot;st&quot;&gt;&quot;%d %d %#[1]x %#x&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;17&lt;/span&gt;)
   fmt.Println(d)
}
结果：
&lt;span class=&quot;dv&quot;&gt;22&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;
 &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;.00&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;.00&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;17&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0x10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0x11&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;printf系列和scanf系列&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; (
   &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
   &lt;span class=&quot;st&quot;&gt;&quot;bufio&quot;&lt;/span&gt;
   &lt;span class=&quot;st&quot;&gt;&quot;os&quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main()  {
   fmt.Println()
   fmt.Printf(&lt;span class=&quot;st&quot;&gt;&quot;%v&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
   &lt;span class=&quot;co&quot;&gt;//fmt.Fprintf(f,&quot;%v&quot;,1)&lt;/span&gt;
   s1 := fmt.Sprintf(&lt;span class=&quot;st&quot;&gt;&quot;http://%s/%s&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;www.baidu.com&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;/asdf&quot;&lt;/span&gt;)
   fmt.Println(s1)

   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; s &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;
   &lt;span class=&quot;co&quot;&gt;//fmt.Scanf(&quot;%d %d&quot;,&amp;amp;m,&amp;amp;n)&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; line &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;
   f :=bufio.NewReader(os.Stdin)
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {
      fmt.Print(&lt;span class=&quot;st&quot;&gt;&quot;&amp;gt; &quot;&lt;/span&gt;)
      &lt;span class=&quot;co&quot;&gt;//fmt.Scanln(&amp;amp;line)&lt;/span&gt;
      line,_=f.ReadString(&lt;span class=&quot;ch&quot;&gt;'\n'&lt;/span&gt;)
      fmt.Printf(&lt;span class=&quot;st&quot;&gt;&quot;line:#%s#&quot;&lt;/span&gt;,line)
      fmt.Sscan(line,&amp;amp;s,&amp;amp;m)
      &lt;span class=&quot;co&quot;&gt;//fmt.Scanf(&quot;%s %d&quot;,&amp;amp;s,&amp;amp;m)&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; s == &lt;span class=&quot;st&quot;&gt;&quot;stop&quot;&lt;/span&gt; {
         &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;
      }
      &lt;span class=&quot;co&quot;&gt;//fmt.Println(m,n)&lt;/span&gt;
      fmt.Println(s,m)
   }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;1.strings.HasPrefix(s string, prefix string) bool：判断字符串s是否以prefix开头 。&lt;/p&gt;
&lt;p&gt;练习1：判断一个url是否以http://开头，如果不是，则加上http://。&lt;/p&gt;
&lt;p&gt;2.strings.HasSuffix(s string, suffix string) bool：判断字符串s是否以suffix结尾。&lt;/p&gt;
&lt;p&gt;练习2：判断一个路径是否以“/”结尾，如果不是，则加上/。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; (
   &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
   &lt;span class=&quot;st&quot;&gt;&quot;strings&quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; urlProcess(url &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt; {
   res := strings.HasPrefix(url,&lt;span class=&quot;st&quot;&gt;&quot;http://&quot;&lt;/span&gt;)
   &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; !res{
      url=fmt.Sprintf(&lt;span class=&quot;st&quot;&gt;&quot;http://%s&quot;&lt;/span&gt;,url)
   }
   &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; url
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; pathProcess(path &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt; {
   result := strings.HasSuffix(path, &lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt;)
   &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; !result {
      path = fmt.Sprintf(&lt;span class=&quot;st&quot;&gt;&quot;%s/&quot;&lt;/span&gt;, path)
   }
   &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; path
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; (
      url  &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;
      path &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;
   )
   fmt.Scanf(&lt;span class=&quot;st&quot;&gt;&quot;%s%s&quot;&lt;/span&gt;, &amp;amp;url, &amp;amp;path)
   url = urlProcess(url)
   path = pathProcess(path)
   fmt.Println(url)
   fmt.Println(path)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.strings.Index(s string, str string) int：判断str在s中首次出现的位置，如果没有出现，则返回-1&lt;/p&gt;
&lt;p&gt;4.strings.LastIndex(s string, str string) int：判断str在s中最后出现的位置，如果没有出现，则返回-1&lt;/p&gt;
&lt;p&gt;练习3：写一个函数返回一个字符串在另一个字符串的首次出现和最后出现位置func StrIndex(str string, substr string)(int, int){}&lt;/p&gt;
&lt;p&gt;5.strings.Replace(str string, old string, new string, n int)：字符串替换&lt;/p&gt;
&lt;p&gt;6.strings.Count(str string, substr string)int：字符串计数&lt;/p&gt;
&lt;p&gt;7.strings.Repeat(str string, count int)string：重复count次str&lt;/p&gt;
&lt;p&gt;8.strings.ToLower(str string)string：转为小写&lt;/p&gt;
&lt;p&gt;9.strings.ToUpper(str string)string：转为大写&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; (
   &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
   &lt;span class=&quot;st&quot;&gt;&quot;strconv&quot;&lt;/span&gt;
   &lt;span class=&quot;st&quot;&gt;&quot;strings&quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
   str := &lt;span class=&quot;st&quot;&gt;&quot;   hello world greg   &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;
   result := strings.Replace(str, &lt;span class=&quot;st&quot;&gt;&quot;world&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;you&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;replace:&quot;&lt;/span&gt;, result)

   count := strings.Count(str, &lt;span class=&quot;st&quot;&gt;&quot;l&quot;&lt;/span&gt;)
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;count:&quot;&lt;/span&gt;, count)

   result = strings.Repeat(str, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;repeat:&quot;&lt;/span&gt;, result)

   result = strings.ToLower(str)
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;lower:&quot;&lt;/span&gt;, result)

   result = strings.ToUpper(str)
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;upper:&quot;&lt;/span&gt;, result)

   result = strings.TrimSpace(str)
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;trimSpace:&quot;&lt;/span&gt;, result)

   result = strings.Trim(str, &lt;span class=&quot;st&quot;&gt;&quot; &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n\r&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;)
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;trim:&quot;&lt;/span&gt;, result)

   result = strings.TrimLeft(str, &lt;span class=&quot;st&quot;&gt;&quot; &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n\r&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;)
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;trimLeft:&quot;&lt;/span&gt;, result)

   result = strings.TrimRight(str, &lt;span class=&quot;st&quot;&gt;&quot; &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n\r&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;)
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;trimRight&quot;&lt;/span&gt;, result)

   splitResult := strings.Fields(str)
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;fu&quot;&gt;len&lt;/span&gt;(splitResult); i++ {
      fmt.Println(splitResult[i])
   }

   splitResult = strings.Split(str, &lt;span class=&quot;st&quot;&gt;&quot;l&quot;&lt;/span&gt;)
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;fu&quot;&gt;len&lt;/span&gt;(splitResult); i++ {
      fmt.Println(splitResult[i])
   }

   str2 := strings.Join(splitResult, &lt;span class=&quot;st&quot;&gt;&quot;l&quot;&lt;/span&gt;)
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;join:&quot;&lt;/span&gt;, str2)

   str2 = strconv.Itoa(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;)
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;itoa:&quot;&lt;/span&gt;, str2)

   number, err := strconv.Atoi(&lt;span class=&quot;st&quot;&gt;&quot;abc&quot;&lt;/span&gt;)
   &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;ot&quot;&gt;nil&lt;/span&gt; {
      fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;can not convert to int,&quot;&lt;/span&gt;, err)
      &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;
   }

   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;number:&quot;&lt;/span&gt;, number)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;strconv.Itoa(i int)：把一个整数i转成字符串&lt;/p&gt;
&lt;p&gt;strconv.Atoi(str string)(int, error)：把一个字符串转成整数&lt;/p&gt;
&lt;p&gt;类型转换：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; (
   &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
   &lt;span class=&quot;st&quot;&gt;&quot;os&quot;&lt;/span&gt;
   &lt;span class=&quot;st&quot;&gt;&quot;strconv&quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; all &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i :=&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;fu&quot;&gt;len&lt;/span&gt;(os.Args);i++{
      s,err :=strconv.Atoi(os.Args[i])
      &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; err == &lt;span class=&quot;ot&quot;&gt;nil&lt;/span&gt; {
         all +=s
      }
   }
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;all is -&amp;gt;&quot;&lt;/span&gt;,all)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; (
    &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;time&quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; test() {
    time.Sleep(time.Millisecond * &lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;)
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
    now := time.Now()
    fmt.Println(now)
    fmt.Printf(&lt;span class=&quot;st&quot;&gt;&quot;%02d/%02d/%02d %02d:%02d:%02d&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,
               now.Year(),now.Month(),now.Day(),now.Hour(),now.Minute(),now.Second())
    fmt.Println(now.Format(&lt;span class=&quot;st&quot;&gt;&quot;2006/01/02 15:04:05&quot;&lt;/span&gt;))
    fmt.Println(now.Format(&lt;span class=&quot;st&quot;&gt;&quot;02/1/2006 15:04&quot;&lt;/span&gt;))
    fmt.Println(now.Format(&lt;span class=&quot;st&quot;&gt;&quot;2006/1/02 15:04&quot;&lt;/span&gt;))
    fmt.Println(now.Format(&lt;span class=&quot;st&quot;&gt;&quot;2006/1/02&quot;&lt;/span&gt;))

    start := time.Now().UnixNano()
    test()
    end := time.Now().UnixNano()

    fmt.Printf(&lt;span class=&quot;st&quot;&gt;&quot;cost:%d us&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, (end-start)/&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;1.普通类型，变量存的就是值，也叫值类型；&lt;/p&gt;
&lt;p&gt;获取变量的地址，用&amp;amp;，比如： var a int, 获取a的地址：&amp;amp;a&lt;/p&gt;
&lt;p&gt;2.指针类型，变量存的是一个地址，这个地址存的才是值；&lt;/p&gt;
&lt;p&gt;获取指针类型所指向的值，使用：，比如：var &lt;em&gt;p int, 使用&lt;/em&gt;p获取p指向的值。&lt;/p&gt;
&lt;p&gt;类似于ln软链接、种子、云链接。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; modify(p *&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;) {
   fmt.Println(p)
   *p = &lt;span class=&quot;dv&quot;&gt;199&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {

   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; = &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
   fmt.Println(&amp;amp;a)

   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; p *&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
   p = &amp;amp;a

   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;p的地址:&quot;&lt;/span&gt;, &amp;amp;p)
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;p-self:&quot;&lt;/span&gt;, p)
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;the value of p point to variable:&quot;&lt;/span&gt;, *p)

   *p = &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;
   fmt.Println(a)

   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; b &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; = &lt;span class=&quot;dv&quot;&gt;99&lt;/span&gt;
   p = &amp;amp;b
   *p = &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;

   fmt.Println(a)
   fmt.Println(b)

   modify(&amp;amp;a)
   fmt.Println(a)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;条件语句&quot;&gt;1.条件语句：&lt;/h2&gt;
&lt;p&gt;条件语句不需要使用括号将条件包含起来()；&lt;br/&gt;无论语句体内有几条语句，花括号{}都是必须存在的；&lt;br/&gt;左花括号{必须与if或者else处于同一行；&lt;br/&gt;在if之后，条件语句之前，可以添加变量初始化语句，使用;间隔；&lt;br/&gt;在有返回值的函数中，不允许将“最终的” return语句包含在if...else...结构中，&lt;br/&gt;否则会编译失败：&lt;br/&gt;function ends without a return statement。&lt;br/&gt;失败的原因在于， Go编译器无法找到终止该函数的return语句&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; (
   &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
   &lt;span class=&quot;st&quot;&gt;&quot;strconv&quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; str &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;
   fmt.Scanf(&lt;span class=&quot;st&quot;&gt;&quot;%s&quot;&lt;/span&gt;, &amp;amp;str)

   number, err := strconv.Atoi(str)
   &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;ot&quot;&gt;nil&lt;/span&gt; {
      fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;convert failed, err:&quot;&lt;/span&gt;, err)
      &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;
   }
   fmt.Println(number)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;选择语句-switch&quot;&gt;2.选择语句 switch：&lt;/h2&gt;
&lt;p&gt;在使用switch结构时，我们需要注意以下几点：&lt;br/&gt;左花括号{必须与switch处于同一行；&lt;br/&gt;条件表达式不限制为常量或者整数；&lt;br/&gt;单个case中，可以出现多个结果选项；&lt;br/&gt;与C语言等规则相反， Go语言不需要用break来明确退出一个case；&lt;br/&gt;只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case；&lt;br/&gt;可以 不设定switch之 后的条 件表达式， 在此种情况 下，整个switch结构与 多个if...else...的逻辑作用等同。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;24&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; (
   &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
   &lt;span class=&quot;st&quot;&gt;&quot;os&quot;&lt;/span&gt;
   &lt;span class=&quot;st&quot;&gt;&quot;strconv&quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
   &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;len&lt;/span&gt;(os.Args) != &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; {
      fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;Usage: myexpr 1 + 2&quot;&lt;/span&gt;)
      &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;
   }

   x, err := strconv.Atoi(os.Args[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;])
   &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;ot&quot;&gt;nil&lt;/span&gt; {
      fmt.Println(err)
      os.Exit(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
   }

   y, err := strconv.Atoi(os.Args[&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;])
   &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;ot&quot;&gt;nil&lt;/span&gt; {
      fmt.Println(err)
      os.Exit(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
   }

   &lt;span class=&quot;kw&quot;&gt;switch&lt;/span&gt; os.Args[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;] {
   &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;+&quot;&lt;/span&gt;:
      fmt.Printf(&lt;span class=&quot;st&quot;&gt;&quot;%v + %v = %v&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, x, y, x+y)
   &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;-&quot;&lt;/span&gt;:
      fmt.Printf(&lt;span class=&quot;st&quot;&gt;&quot;%v - %v = %v&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, x, y, x-y)
   &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;*&quot;&lt;/span&gt;:
      fmt.Printf(&lt;span class=&quot;st&quot;&gt;&quot;%v * %v = %v&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, x, y, x*y)
   &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt;:
      fmt.Printf(&lt;span class=&quot;st&quot;&gt;&quot;%v / %v = %v&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, x, y, x/y)
   &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt;:
      fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;Usage: myexpr 1 + 2&quot;&lt;/span&gt;)
   }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;循环语句&quot;&gt;3.循环语句&lt;/h2&gt;
&lt;p&gt;与多数语言不同的是， Go语言中的循环语句只支持for关键字，而不支持while和do-while结构。关键字for的基本使用方法与C和C++中非常接近。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; (
   &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
   &lt;span class=&quot;st&quot;&gt;&quot;os&quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main(){
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i:=&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;fu&quot;&gt;len&lt;/span&gt;(os.Args);i++{
      fmt.Println(os.Args[i])
   }
   i:=&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;//////////////&quot;&lt;/span&gt;)
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i &amp;lt;&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;{
      fmt.Println(i)
      i=i&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;
   }
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;//////////////&quot;&lt;/span&gt;)
   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; j=&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;
   &lt;span class=&quot;co&quot;&gt;//等价于while true&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {
      j=j&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;
      fmt.Println(j)
      &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; j&amp;gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;{
         &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;
      }
   }
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;//////////////&quot;&lt;/span&gt;)
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i,arg := &lt;span class=&quot;kw&quot;&gt;range&lt;/span&gt; os.Args{
      fmt.Println(i,arg)
   }
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;//////////////&quot;&lt;/span&gt;)
   s:=&lt;span class=&quot;st&quot;&gt;&quot;hello中文&quot;&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i,arg := &lt;span class=&quot;kw&quot;&gt;range&lt;/span&gt; s {
      &lt;span class=&quot;co&quot;&gt;//fmt.Println(i,arg)&lt;/span&gt;
      fmt.Printf(&lt;span class=&quot;st&quot;&gt;&quot;%d %c&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,i,arg)
   }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;goto跳转语句&quot;&gt;4.goto跳转语句：&lt;/h2&gt;
&lt;p&gt;label标签：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main
&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
   LABEL1:
      &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt;= &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;; i++ {
         &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; j := &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; j &amp;lt;= &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;; j++ {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; j == &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; {
               &lt;span class=&quot;kw&quot;&gt;continue&lt;/span&gt; LABEL1
            }
         fmt.Printf(&lt;span class=&quot;st&quot;&gt;&quot;i is: %d, and j is: %d&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, i, j)
         }
      }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;goto语句：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
   i := &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
   HERE:
      fmt.Println(i)
      i++
      &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; i == &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; {
         &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;
      }
      &lt;span class=&quot;kw&quot;&gt;goto&lt;/span&gt; HERE
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 16 Jan 2018 15:35:00 +0000</pubDate>
<dc:creator>宁生信</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gregoryli/p/8299412.html</dc:identifier>
</item>
<item>
<title>inline-block元素间留白现象探究 - O卖女孩的小火柴O</title>
<link>http://www.cnblogs.com/fwc1994/p/inline_block.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fwc1994/p/inline_block.html</guid>
<description>&lt;h2&gt;现象说明&lt;/h2&gt;
&lt;p&gt;最近在项目发布的时候遇到了一个奇怪的问题，在项目使用gulp打包压缩后发现之前一些行内元素间的空白消失了，导致页面中一些布局出现了问题&lt;/p&gt;
&lt;p&gt;正常样式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1027704/201801/1027704-20180116230711053-1699916174.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://images2017.cnblogs.com/blog/1027704/201801/1027704-20180116230859318-193416055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最开始出现这个问题的时候以为是gulp在压缩css，html出现了什么问题，一直在对比压缩前后对应节点的样式和结构，但却始终没有发现问题。&lt;/p&gt;
&lt;p&gt;通关观察元素的盒模型，觉得这段空白实际上是不应该出现的，压缩后异常的样式反而是正常的。最后通过查阅资料最后发现原来inline-block元素&lt;/p&gt;
&lt;p&gt;的自动留白造成的这一空隙的出现。&lt;/p&gt;
&lt;h2&gt;空白出现原因&lt;/h2&gt;
&lt;p&gt;其实产生这一空白的原因是我们在平时编码的时候这种行内元素之间往往会有一个换行符或空格，浏览器会识别并为我们的行内元素见插入一段空白。&lt;/p&gt;
&lt;p&gt;代码对比如下：&lt;/p&gt;
&lt;p&gt;压缩前html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    ul li &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; inline-block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; aquamarine
    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;元素1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;元素2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;元素3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;元素4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;压缩后html示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;style&amp;gt;
    ul li {
        display: inline-block;
        background-color: aquamarine
    }
&amp;lt;/style&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;元素1&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;元素2&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;元素3&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;元素4&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;出现这种情况不能算是bug，是一种良好布局规范的体现。但是并不是任何时候都需要这种留白，有时候这种浏览器默认的留白会对并清楚原理的开发人员&lt;/p&gt;
&lt;p&gt;造成不必要的干扰。那有什么办法可以取消这一默认设置吗。&lt;/p&gt;
&lt;h2&gt;去除inline-block元素间间距&lt;/h2&gt;
&lt;p&gt;针对这一问题网上提出了很多的解决办法在这里我就不再复述，给出的每种办法都很巧妙，不得不佩服程序员的智慧。（&lt;a href=&quot;https://www.w3cplus.com/css/fighting-the-space-between-inline-block-elements&quot; target=&quot;_blank&quot;&gt;点击查看&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;项目压缩前和压缩后出现不同的布局显然是不可取的，所以后来的话通过改变gulp压缩配置的方式保留了元素间的换行符，尽可能的保持一致。&lt;/p&gt;
&lt;p&gt;避免出现异常的布局问题。&lt;/p&gt;

</description>
<pubDate>Tue, 16 Jan 2018 15:34:00 +0000</pubDate>
<dc:creator>O卖女孩的小火柴O</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fwc1994/p/inline_block.html</dc:identifier>
</item>
<item>
<title>垃圾回收（GC） 的基本算法 - 行者酱油君</title>
<link>http://www.cnblogs.com/makor/p/base-algorithm-for-gc.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/makor/p/base-algorithm-for-gc.html</guid>
<description>&lt;p&gt;GC 作为一个长久的话题，从诞生[1]至今也算是经历了六七十年了，对于很多习惯于使用 Java/Python 的同学来说，对于内存的管理可能会稍微更陌生一些，因为这些语言在语言层面就屏蔽了内存的分配和管理，帮助我们减少了超多的麻烦。但是，在帮助我们减少麻烦的同时，也带来了很多问题，其中一个就是内存爆掉，这个问题有可能是代码写得不好，有可能是设计不好，反正就是存在这个问题。&lt;/p&gt;
&lt;p&gt;本文不准备细究这些问题，本文旨在介绍一些内存回收的基本算法，通过这些基本算法，从而介绍一下这些自动内存管理语言底层管理内存的一些套路，从而在平时使用它们的时候可以依照它们的尿性来编写代码，减少一些内存管理方面的 Bug。&lt;/p&gt;
&lt;p&gt;反观这么多年来，GC 虽然发展了这么久，从古老的 Lisp 到新一些的 Go 语言，垃圾回收的基本算法都没有太大的创新，一方面说明了这些算法的强大，另外一方面也说明了这里还有很大的挖掘空间给爱好者们/专家们去思考，挖掘出新的基本算法。本文就对这些年一直被各种编程语言直接使用/配合使用的几种垃圾回收算法进行一个总结介绍，顺便介绍一下他们的优缺点。&lt;/p&gt;
&lt;h3 id=&quot;toc_0&quot;&gt;垃圾回收算法的性能点&lt;/h3&gt;
&lt;p&gt;为什么会存在那么多的垃圾回收算法呢？我想这个问题的答案可能是没有任何一种内存回收算法是完美的，所以在针对不同的情景需求下，不同的内存回收算法有其独特的优势，所以最后就延续了多种回收算法。那么，在平时的大多数情况下，有哪些性能考虑点是我们关注的呢，下面就列举一下常见的性能指标&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;吞吐量：回收固定内存需要的时间&lt;/li&gt;
&lt;li&gt;最大暂停时间：回收过程中需要暂停代码执行的时间&lt;/li&gt;
&lt;li&gt;内存使用效率：真正用于逻辑的内存占总内存的比例&lt;/li&gt;
&lt;li&gt;访问的局部性：与计算机各项缓存的友好程度&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然这不是所有的关注指标，但是这些却是大部分情况下被关注的指标。而且，需要注意的是，这里面有一些指标是互斥的，例如我们会发现，最大吞吐量和最大暂停时间往往无法得到双赢，也就是说无法同时满足这两项的最优。所以，在选择具体的回收算法的时候，其实就是在这些指标之间进行权衡，然后根据自己的需求进行选择。下面就对常见的三种基本回收算法进行介绍。&lt;/p&gt;
&lt;h3 id=&quot;toc_1&quot;&gt;基本 GC 算法&lt;/h3&gt;
&lt;h4 id=&quot;toc_2&quot;&gt;1. 标记-清除&lt;/h4&gt;
&lt;p&gt;标记-清除算法是一个比较经典的算法了，在标记-清除算法中，一般都是有所谓的根对象，而且一般来说根对象都不止一个，有很多，以 C 语言来理解的话，我们可以理解成分配在栈中的对象和全局对象都是所谓的根对象。标记-清除算法从这些所谓的 &lt;strong&gt;根对象&lt;/strong&gt; 出发，进行第一个阶段——标记阶段，也就是将这些 &lt;strong&gt;根对象&lt;/strong&gt; 能够引用到的那些对象都作上标记，一般的做法是每个对象都有一个字段用于标识是否被标记，当然还有很多其他的做法，例如专门弄一张表来表示对象的标记等，这些都是后话啦，反正这个阶段就只做一件事情，那就是找出被使用的对象，作上标记，这样没有被标记的对象也就是不用的对象了。&lt;/p&gt;
&lt;p&gt;在第一阶段标记完之后，那么进入&lt;strong&gt;标记-清除&lt;/strong&gt;的第二个阶段——清除阶段，清除阶段其实也就是所谓的释放阶段，无非就是把不使用的对象所占用的内存释放掉，然后回收起来这么简单。&lt;/p&gt;
&lt;p&gt;看上去标记-清除算法还是比较简单的，但是，这个简单背后也是有很多需要思考的问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对象的内存分配和对象的内存回收策略&lt;/li&gt;
&lt;li&gt;从根对象开始标记对象的方式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这是两个比较常见的问题。第一个问题，对象的内存分配问题，假设现在我们的语言需要创建一个对象，那么自然需要分配一块内存给它，怎么分配这个内存呢？一个可能的做法就是从上次分配的位置往后直接分配一块，这样保证每次分配的内存都是往高位走，内存地址逐渐叠加。但是，这种方法带来了一个问题，那就是释放的时候就很尴尬了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/469840/201801/469840-20180116233402115-1424911312.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;假设这里有一段内存，按照刚才的策略分配了 A、B 和 C 三个对象，当程序运行一段时间之后，我们想回收掉对象 B，然后回收之后发现现在的内存是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/469840/201801/469840-20180116233402131-1984764229.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;这个时候，我们想再分配一个对象 D，那么不巧，D 的大小就比 B 大那么一点，所以原来 B 的位置不足以容纳 D，所以也就不能使用 B 原来的位置，那么这样的话，内存结构可能就成了这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/469840/201801/469840-20180116233402162-1286448507.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;长此以往，我们会发现内存就会有一个一个的洞，碎片化会很严重，导致内存的利用率逐渐下降。同时，因为这里的内存是一块一块的，所以我们用链表来保存它的时候，分配内存查找又是一个问题，所以就很麻烦。&lt;/p&gt;
&lt;p&gt;此外，周期性得标记对象，从而会周期性得改变对象的微小数据，所以导致操作系统 COW 体系不能得到较好的运用，从而导致性能的缺失。这是一方面，前面还有一个问题，那就是我们标记对象的时候以怎么样的顺序来查找活动对象，常见的查找方式有&lt;strong&gt;深度优先查找&lt;/strong&gt; 和 &lt;strong&gt;广度优先查找&lt;/strong&gt;，这两种查找在性能上可能没有太大区别，但是，对于临时空间的占用却是有较大的影响，所以一般来说，&lt;strong&gt;深度优先&lt;/strong&gt;比&lt;strong&gt;广度优先&lt;/strong&gt;更能压低内存使用量，所以经常使用的是&lt;strong&gt;深度优先搜索&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;虽然有缺点，但是&lt;strong&gt;标记-清除&lt;/strong&gt;的优点也是比较明显的，例如实现起来还是比较简单的，与保守式 GC 是兼容的，使得 &lt;strong&gt;标记-清除&lt;/strong&gt; 算法在实际应用中还是得到大家的青睐的。&lt;/p&gt;
&lt;h4 id=&quot;toc_3&quot;&gt;2. 引用计数&lt;/h4&gt;
&lt;p&gt;除了&lt;strong&gt;标记-清除&lt;/strong&gt;算法外，&lt;strong&gt;引用计数&lt;/strong&gt; 也是一种不错的方法，&lt;strong&gt;引用计数算法&lt;/strong&gt; 顾名思义就是在对象中额外记录自身被引用的次数，当次数减小到 0 的时候那么就知道自己已经没有用处了，可以被回收了。也是一种很简单很直观的方式，可以在对象不被使用的时候立刻回收掉内存，从而将垃圾回收的时间分散化，也不需要像 &lt;strong&gt;标记-清除&lt;/strong&gt; 一样需要进行遍历查找。&lt;/p&gt;
&lt;p&gt;但是这也带来了一定程度的麻烦，例如，我们需要使用内存屏障管理引用计数，对象的生成、赋值和引用都涉及引用计数的变化，从而导致引用计数的增减处理频繁；同时，因为引用计数的存在，我们还需要在对象的自身数据之外，为引用计数分配固定的空间来存放计数，这是固有损耗。还有一个致命的缺点就是，使用&lt;strong&gt;引用计数算法&lt;/strong&gt;，无法清除 &lt;strong&gt;循环引用&lt;/strong&gt; 的问题，从而导致内存一直占用，无法释放。&lt;/p&gt;
&lt;h4 id=&quot;toc_4&quot;&gt;3. GC 复制&lt;/h4&gt;
&lt;p&gt;前面介绍的两种方法都是在对象本身上操作的，也就是说清除和释放都是操作对象本身所在的位置，但是，&lt;strong&gt;GC 复制算法&lt;/strong&gt; 就稍微复杂一些了，&lt;strong&gt;GC 复制算法&lt;/strong&gt; 最原始的做法就是将内存一分为二，每次只使用其他一半，当要 GC 的时候就将使用着的一半中的活动对象复制到另外一半中，然后清理掉这一半中的所有对象，直接使用另外一半即可，重复这个操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/469840/201801/469840-20180116233402224-1972642811.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;这个我们一眼就可以看出问题，那就是空间的利用率不高，但是，好处也是非常明显的，首先是速度快，没有额外的标记-清理操作，就是直接的复制，高吞吐；分配对象直接分配，不需要考虑碎片化问题；还可以保持与 OS 的缓存兼容，优势还是比较明显的。然而，硬币总有正反面，除了空间利用率不高之外，这种方法不兼容保守式的 GC 算法，此外，对于递归调用还会有栈溢出的风险。&lt;/p&gt;
&lt;p&gt;所以为了更好得完善了这个算法，还有有很多改进思路被提出的，例如不是将空间划分为两部分，而是划分为多个部分，从而提升空间的利用率就是其中的一个思路。&lt;/p&gt;
&lt;h2 id=&quot;toc_5&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文就常见的三种垃圾回收基本算法以及经常需要考虑的几个性能指标进行介绍，从而为了解垃圾回收开一个头。其实看各种编程语言的 GC 实现都会发现本文中基本算法的身影，无非就是它们直接如何组合，所以，理解本文中的基本算法对于理解其他编程语言的 GC 实现还是很有帮助的。&lt;/p&gt;
&lt;h2 id=&quot;toc_6&quot;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)&quot;&gt;Garbage Collection&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 16 Jan 2018 15:34:00 +0000</pubDate>
<dc:creator>行者酱油君</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/makor/p/base-algorithm-for-gc.html</dc:identifier>
</item>
<item>
<title>移动web开发之touch事件 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/8293225.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/8293225.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　iOS版Safari为了向开发人员传达一些特殊信息，新增了一些专有事件。因为iOS设备既没有鼠标也没有键盘，所以在为移动Safari开发交互性网页时，常规的鼠标和键盘事件根本不够用。随着Android 中的WebKit的加入，很多这样的专有事件变成了事实标准，导致W3C开始制定Touch Events规范。本文将详细介绍移动端touch事件&lt;/p&gt;

&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;　　包含iOS 2.0软件的iPhone 3G发布时，也包含了一个新版本的Safari浏览器。这款新的移动Safari提供了一些与触摸(touch)操作相关的新事件。后来，Android上的浏览器也实现了相同的事件。触摸事件会在用户手指放在屏幕上面时、在屏幕上滑动时或从屏幕上移开时触发。具体来说，有以下几个触摸事件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;touchstart:当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发
touchmove:当手指在屏幕上滑动时连续地触发。在这个事件发生期间，调用preventDefault()可以阻止滚动
touchend:当手指从屏幕上移开时触发
touchcancel:当系统停止跟踪触摸时触发(不常用)。关于此事件的确切触发时间，文档中没有明确说明&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【touchenter 和 touchleave】&lt;/p&gt;
&lt;p&gt;　　触摸事件规范中曾经包含touchenter和touchleave事件，这两个事件在用户手指移入或移出某个元素时触发。但是这两个事件从来没有被实现。微软有这两个事件的替代事件，但是只有IE浏览器支持。某些情况下可以知道用户手指滑入滑出某个元素是素是非常有用的，所以希望这两个事件可以重返规范&lt;/p&gt;
&lt;p&gt;　　在触摸事件中，常用的是touchstart、touchumove和touchend这三个事件，与鼠标事件的对应如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;鼠标         触摸          
mousedown   touchstart 
mousemove   touchmove   
mouseup     touchend     &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　[注意]touch事件在chrome模拟器下部分版本使用DOM0级事件处理程序的方式来添加事件无效&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;viewport&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width=device-width, initial-scale=1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;meta http-equiv=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X-UA-Compatible&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ie=edge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;&lt;span&gt;
    #test{height:200px;width:200px;background:lightblue;}
  &lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
  (function(){ 
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; 
      stateMap &lt;/span&gt;=&lt;span&gt; {
        touchstart_index : &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
        touchmove_index  : &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
        touchend_index   : &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
      },
      elesMap &lt;/span&gt;=&lt;span&gt; {
        touch_obj: document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
      },
      showIndex, handleTouch;

    showIndex &lt;/span&gt;=&lt;span&gt; function ( type ) {
      elesMap.touch_obj.innerHTML &lt;/span&gt;= type + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + (++stateMap[type + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]);
    };

    handleTouch &lt;/span&gt;= function ( &lt;span&gt;event&lt;/span&gt;&lt;span&gt; ) {
      showIndex( &lt;/span&gt;&lt;span&gt;event&lt;/span&gt;&lt;span&gt;.type );
    };

    elesMap.touch_obj.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchstart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function(&lt;span&gt;event&lt;/span&gt;){handleTouch(&lt;span&gt;event&lt;/span&gt;&lt;span&gt;);}); 
    elesMap.touch_obj.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchmove&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function(&lt;span&gt;event&lt;/span&gt;){handleTouch(&lt;span&gt;event&lt;/span&gt;&lt;span&gt;);});
    elesMap.touch_obj.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchend&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function(&lt;span&gt;event&lt;/span&gt;){handleTouch(&lt;span&gt;event&lt;/span&gt;&lt;span&gt;);});
  })(); 

&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;300ms&lt;/h3&gt;
&lt;p&gt;　　300ms问题是指在某个元素执行它的功能和执行touch事件之间有一个300毫秒的间隔。鼠标事件、焦点事件、浏览器默认行为等相较于touch事件，都存在着300ms的延迟&lt;/p&gt;
&lt;p&gt;【点透】&lt;/p&gt;
&lt;p&gt;　　因为300ms的存在，会造成常见的点透问题。先来看例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;viewport&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;meta http-equiv=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X-UA-Compatible&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ie=edge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;&lt;span&gt;
    #test {position: absolute;top: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;;left: &lt;span&gt;0&lt;/span&gt;;opacity: &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;;height: 200px;width: 200px;background: lightblue;}
  &lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://baidu.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;百度&amp;lt;/a&amp;gt;
  &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;script&amp;gt;&lt;span&gt;
    (function () {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;
        elesMap &lt;/span&gt;=&lt;span&gt; {
          touchObj: document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        },
        fnHide, onTouch;
      fnHide &lt;/span&gt;=&lt;span&gt; function (type) {
        elesMap.touchObj.style.display &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
      };
      onTouch &lt;/span&gt;= function (&lt;span&gt;event&lt;/span&gt;&lt;span&gt;) {
        fnHide();
      };
      elesMap.touchObj.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchstart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function(&lt;span&gt;event&lt;/span&gt;){onTouch(&lt;span&gt;event&lt;/span&gt;&lt;span&gt;);});
    })(); 
  &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　浅蓝色的半透明div被点击(触发touch事件)后，如果点击位置正好位于链接的上方，则会触发链接跳转的默认行为。详细解释是，点击页面后，浏览器会记录所点击的页面坐标，300ms后，在该坐标找到元素。在该元素上触发点击行为。因此，如果300ms内同一页面坐标的上层元素消失后，300ms后在下层元素上触发点击行为。这就造成了点透问题&lt;/p&gt;

&lt;p&gt;　　造成这个问题，是因为触摸屏幕的行为被重载(overload)了。在手指触摸屏幕的瞬间，浏览器无法预知用户是在轻触(Tap)、双触(Double-Tap)、滑动(Swipe)、按住不放(Hold)还是其他什么操作。唯一保险的做法就是等上一会儿看接下来会发生什么&lt;/p&gt;
&lt;p&gt;　　问题是在于双触(Double-Tap)。即便是浏览器检测出手指离开了屏幕，它仍然无法判断接下来做什么。因为浏览器无法知道手指是会再次回到屏幕，还是就此结束触发轻触事件以及事件级联。为了确定这一点，浏览器不得不等待一小段时间。浏览器开发者找到一个最佳时间间隔，就是300毫秒&lt;/p&gt;
&lt;p&gt;【解决办法】&lt;/p&gt;
&lt;p&gt;　　1、在touch事件的事件处理程序中增加300ms的延迟&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    (function () {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;
        elesMap &lt;/span&gt;=&lt;span&gt; {
          touchObj: document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        },
        fnHide, onTouch;
      fnHide &lt;/span&gt;=&lt;span&gt; function (type) {
        elesMap.touchObj.style.display &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
      };
      onTouch &lt;/span&gt;= function (&lt;span&gt;event&lt;/span&gt;&lt;span&gt;) {
        setTimeout(function(){
          fnHide();
        },30&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
      };
      elesMap.touchObj.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchstart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function (&lt;span&gt;event&lt;/span&gt;) { onTouch(&lt;span&gt;event&lt;/span&gt;&lt;span&gt;); });
    })(); &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、使用缓动动画，增加300ms的过渡效果，注意display属性无法使用transition&lt;/p&gt;
&lt;p&gt;　　3、加入中间层的dom元素，让中间层接受这个穿透事件，稍后隐藏&lt;/p&gt;
&lt;p&gt;　　4、上下两级都使用tap事件，但默认行为不可避免&lt;/p&gt;
&lt;p&gt;　　5、在document上的touchstart事件，阻止默认行为。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
document.addEventListener(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchstart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,function(e){
    e.preventDefault();
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接着，添加a标签的跳转行为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
a.addEventListener(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchstart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,function(){
  window.location.href &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://cnblogs.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;  
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　但是，这种方法有副作用，会造成页面无法滚动、文本无法选中等。如果在某个元素上，需要恢复文本选中的行为，则可以使用阻止冒泡来恢复&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
el.addEventListener(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchstart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,function(e){
    e.stopPropagation();
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;事件对象&lt;/h3&gt;
&lt;p&gt;【基础信息】&lt;/p&gt;
&lt;p&gt;　　每个触摸事件的event对象都提供了在鼠标事件中常见的属性，包括事件类型、事件目标对象、事件冒泡、事件流、默认行为等&lt;/p&gt;
&lt;p&gt; 　　以touchstart为例，示例代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &amp;lt;script&amp;gt;&lt;span&gt;
    (function () {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;
        elesMap &lt;/span&gt;=&lt;span&gt; {
          touchObj: document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        },
        onTouch;
      onTouch &lt;/span&gt;=&lt;span&gt; function (e) {
          console.log(e)
    };
      elesMap.touchObj.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchstart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function (&lt;span&gt;event&lt;/span&gt;) { onTouch(&lt;span&gt;event&lt;/span&gt;&lt;span&gt;); });
    })(); 
  &lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1、currentTarget属性返回事件正在执行的监听函数所绑定的节点&lt;/p&gt;
&lt;p&gt;　　2、target属性返回事件的实际目标节点&lt;/p&gt;
&lt;p&gt;　　3、srcElement属性与target属性功能一致&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前目标&lt;/span&gt;
currentTarget:[&lt;span&gt;object&lt;/span&gt;&lt;span&gt; HTMLDivElement]
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实际目标&lt;/span&gt;
target:[&lt;span&gt;object&lt;/span&gt;&lt;span&gt; HTMLDivElement]
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实际目标&lt;/span&gt;
srcElement:[&lt;span&gt;object&lt;/span&gt; HTMLDivElement]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、eventPhase属性返回一个整数值，表示事件目前所处的事件流阶段。0表示事件没有发生，1表示捕获阶段，2表示目标阶段，3表示冒泡阶段&lt;/p&gt;
&lt;p&gt;　　5、bubbles属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性&lt;/p&gt;
&lt;p&gt;　　6、cancelable属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;事件流&lt;/span&gt;
eventPhase: &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可冒泡&lt;/span&gt;
bubbles: &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认事件可取消&lt;/span&gt;
cancelable: &lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【touchList】&lt;/p&gt;
&lt;p&gt;　　除了常见的DOM属性外，触摸事件对象有一个touchList数组属性，其中包含了每个触摸点的信息。如果用户使用四个手指触摸屏幕，这个数组就会有四个元素。一共有三个这样的数组&lt;/p&gt;
&lt;p&gt;　　1、touches：当前触摸屏幕的触摸点数组（至少有一个触摸在事件目标元素上）&lt;/p&gt;
&lt;p&gt;　　2、changedTouches ：导致触摸事件被触发的触摸点数组&lt;/p&gt;
&lt;p&gt;　　3、targetTouches：事件目标元素上的触摸点数组&lt;/p&gt;
&lt;p&gt;　　如果用户最后一个手指离开屏幕触发touchend事件，这最后一个触摸点信息不会出现在targetTouches和touches数组中，但是会出现在changedTouched数组中。因为是它的离开触发了touchend事件，所以changedTouches数组中仍然包含它。上面三个数组中，最常用的是changedTouches数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    (function () {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;
        elesMap &lt;/span&gt;=&lt;span&gt; {
          touchObj: document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        },
        onTouch;
      onTouch &lt;/span&gt;=&lt;span&gt; function (e) {
          elesMap.touchObj.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;touches:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; e.touches.length
                                    &lt;/span&gt;+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;changedTouches:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; e.changedTouches.length
                                    &lt;/span&gt;+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;targetTouches:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; e.targetTouches.length;
      };
      elesMap.touchObj.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchstart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function (&lt;span&gt;event&lt;/span&gt;) { onTouch(&lt;span&gt;event&lt;/span&gt;&lt;span&gt;); });
    })(); &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;【事件坐标】&lt;/p&gt;
&lt;p&gt;　　上面这些触摸点数组中的元素可以像普通数组那样用数字索引。数组中的元素包含了触摸点的有用信息，尤其是坐标信息。每个Touch对象包含下列属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;clientx:触摸目标在视口中的x坐标
clientY:触摸目标在视口中的y坐标
identifier:标识触摸的唯一ID
pageX:触摸目标在页面中的x坐标（包含滚动）
pageY:触摸目标在页面中的y坐标（包含滚动）
screenX:触摸目标在屏幕中的x坐标
screenY:触摸目标在屏幕中的y坐标
target:触摸的DOM节点目标&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　changedTouches数组中的第一个元素就是导致事件触发的那个触摸点对象(通常这个触摸点数组不包含其他对象)。这个触摸点对象含有clientX/Y和pageX/Y坐标信息。除此之外还有screenX/Y和x/y，这些坐标在浏览器间不太一致，不建议使用&lt;/p&gt;
&lt;p&gt;　　clientX/Y和pageX/Y的区别在于前者相对于视觉视口的左上角，后者相对于布局视口的左上角。布局视口是可以滚动的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    (function () {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;
        elesMap &lt;/span&gt;=&lt;span&gt; {
          touchObj: document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        },
        onTouch;
      onTouch &lt;/span&gt;=&lt;span&gt; function (e) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; touch = e.changedTouches[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
        elesMap.touchObj.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;clientX:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + touch.clientX + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;clientY:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; touch.clientY
          &lt;/span&gt;+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;pageX:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + touch.pageX + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;pageY:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; touch.pageY
          &lt;/span&gt;+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;screenX:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + touch.screenX + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;screenY:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; touch.screenY
      };
      elesMap.touchObj.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchstart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function (&lt;span&gt;event&lt;/span&gt;) { onTouch(&lt;span&gt;event&lt;/span&gt;&lt;span&gt;); });
    })(); &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Tue, 16 Jan 2018 14:38:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/8293225.html</dc:identifier>
</item>
<item>
<title>设计模式---代理模式 - Dan_Go</title>
<link>http://www.cnblogs.com/daniels/p/8242592.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daniels/p/8242592.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;       &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;代理模式的定义：&lt;/strong&gt;代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。&lt;/p&gt;
&lt;p&gt;举个例子来说明：假如说我现在想买一辆二手车，虽然我可以自己去找车源，做质量检测等一系列的车辆过户流程，但是这确实太浪费我得时间和精力了。我只是想买一辆车而已为什么我还要额外做这么多事呢？于是我就通过中介公司来买车，他们来给我找车源，帮我办理车辆过户流程，我只是负责选择自己喜欢的车，然后付钱就可以了。用图表示如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1071931/201801/1071931-20180108134122472-1822105846.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;中介隔离作用：&lt;/strong&gt;&lt;/span&gt;在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;开闭原则，增加功能：&lt;/strong&gt;&lt;/span&gt;代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;       我们有多种不同的方式来实现代理。如果按照代理创建的时期来进行分类的话， 可以分为两种：静态代理、动态代理。静态代理是由程序员创建或特定工具自动生成源代码，在对其编译。在程序员运行之前，代理类.class文件就已经被创建了。动态代理是在程序运行时通过反射机制动态创建的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.静态代理&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;第&lt;/strong&gt;&lt;strong&gt;一步：创建服务类接口&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; main.java.proxy;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * @Date: 22:40 2018/1/9 0009
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; BuyHouse {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; buyHosue();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;第二步：实现服务接口&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; main.java.proxy.BuyHouse;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * @Date: 22:42 2018/1/9 0009
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BuyHouseImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BuyHouse {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; buyHosue() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         System.out.println(&quot;我要买房&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第三步：创建代理类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; main.java.proxy.impl;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; main.java.proxy.BuyHouse;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * @Date: 22:43 2018/1/9 0009
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BuyHouseProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BuyHouse {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; BuyHouse buyHouse;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; BuyHouseProxy(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; BuyHouse buyHouse) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.buyHouse =&lt;span&gt; buyHouse;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; buyHosue() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         System.out.println(&quot;买房前准备&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        buyHouse.buyHosue();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         System.out.println(&quot;买房后装修&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第四步：编写测试类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; main.java.proxy.impl.BuyHouseImpl;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; main.java.proxy.impl.BuyHouseProxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Auther: dan gao
 * @Description:
 * @Date: 22:43 2018/1/9 0009
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProxyTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        BuyHouse buyHouse &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BuyHouseImpl();
        buyHouse.buyHosue();
        BuyHouseProxy buyHouseProxy &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BuyHouseProxy(buyHouse);
        buyHouseProxy.buyHosue();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;静态代理总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点：可以做到在符合开闭原则的情况下对目标对象进行功能扩展。&lt;/p&gt;
&lt;p&gt;缺点：我们得为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改。&lt;span&gt;&lt;strong&gt;                                             &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;_mce_tagged_br&quot;&gt;&lt;span&gt;&lt;strong&gt;2.动态代理&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;在动态代理中我们不再需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一步：编写动态处理器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; main.java.proxy.impl;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; * @Date: 20:34 2018/1/12 0012
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DynamicProxyHandler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object object;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; DynamicProxyHandler(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Object object) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.object =&lt;span&gt; object;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         System.out.println(&quot;买房前准备&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         Object result =&lt;span&gt; method.invoke(object, args);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         System.out.println(&quot;买房后装修&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二步：编写测试类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; main.java.proxy.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; main.java.proxy.BuyHouse;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; main.java.proxy.impl.BuyHouseImpl;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; main.java.proxy.impl.DynamicProxyHandler;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * @Date: 20:38 2018/1/12 0012
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DynamicProxyTest {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         BuyHouse buyHouse = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BuyHouseImpl();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         BuyHouse proxyBuyHouse = (BuyHouse) Proxy.newProxyInstance(BuyHouse.&lt;span&gt;class&lt;/span&gt;.getClassLoader(), &lt;span&gt;new&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                 Class[]{BuyHouse.&lt;span&gt;class&lt;/span&gt;}, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DynamicProxyHandler(buyHouse));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        proxyBuyHouse.buyHosue();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 注意&lt;span&gt;&lt;em&gt;&lt;span&gt;Proxy.newProxyInstance()&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;方&lt;span&gt;法接受三个参&lt;/span&gt;数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;code&gt;ClassLoader loader&lt;/code&gt;:&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;指定当前目标对象使用的类加载器,获取加载器的方法是固定的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;code&gt;Class&amp;lt;?&amp;gt;[] interfaces&lt;/code&gt;:&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;指定目标对&lt;span&gt;象实现的接口的类型,使用泛型方式确认类型&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;em&gt;&lt;code&gt;&lt;span&gt;InvocationHandler:&lt;/span&gt;&lt;/code&gt;&lt;/em&gt;&lt;/span&gt;&lt;code&gt;指定&lt;/code&gt;&lt;code&gt;动态处理器，&lt;/code&gt;执行&lt;span&gt;目标对象的方法时,会触发事件处理器的方法&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;动态代理总结：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;虽然相对于静态代理，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通。有很多条理由，人们可以否定对 class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。接口和类的划分，本就不是很明显，只是到了Java中才变得如此的细化。如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。但是，不完美并不等于不伟大，伟大是一种本质，Java动态代理就是佐例&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;3.CGLIB代理&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;       JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，如何实现动态代理呢，这就需要CGLib了。CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理。JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第一步：创建CGLIB代理类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; dan.proxy.impl;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.sf.cglib.proxy.Enhancer;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.sf.cglib.proxy.MethodInterceptor;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.sf.cglib.proxy.MethodProxy;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * @Date: 20:38 2018/1/16 0016
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CglibProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; MethodInterceptor {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object getInstance(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Object target) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         Enhancer enhancer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Enhancer();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         enhancer.setSuperclass(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.target.getClass());
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         enhancer.setCallback(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; enhancer.create();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         System.out.println(&quot;买房前准备&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         Object result =&lt;span&gt; methodProxy.invoke(object, args);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         System.out.println(&quot;买房后装修&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二步：创建测试类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; dan.proxy.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dan.proxy.BuyHouse;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dan.proxy.impl.BuyHouseImpl;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dan.proxy.impl.CglibProxy;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * @Date: 20:52 2018/1/16 0016
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CglibProxyTest {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         BuyHouse buyHouse = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BuyHouseImpl();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         CglibProxy cglibProxy = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CglibProxy();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         BuyHouseImpl buyHouseCglibProxy =&lt;span&gt; (BuyHouseImpl) cglibProxy.getInstance(buyHouse);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        buyHouseCglibProxy.buyHosue();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;CGLIB代理总结： &lt;/span&gt;&lt;/strong&gt;CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。同时由于CGLib由于是采用动态创建子类的方法，对于final修饰的方法无法进行代理。&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jan 2018 13:34:00 +0000</pubDate>
<dc:creator>Dan_Go</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/daniels/p/8242592.html</dc:identifier>
</item>
<item>
<title>【干货】分享几个写 demo 的思路 - 韩子迟</title>
<link>http://www.cnblogs.com/zichi/p/8298888.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zichi/p/8298888.html</guid>
<description>&lt;p&gt;好久没有动笔，最近发现了一个新的写 demo 的思路，非常有意思。仔细一想，自己仿佛积累了不少写 demo 的思路和想法，总结一下，抛砖引玉。&lt;/p&gt;
&lt;p&gt;本文所说 demo 主要分以下三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本地 demo&lt;/li&gt;
&lt;li&gt;外链 demo&lt;/li&gt;
&lt;li&gt;文章中带 demo&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;楼主在工作和学习中是比较喜欢写 demo 的，抛出问题非常直观。&lt;/p&gt;
&lt;p&gt;本地写 demo，爱咋整就可以咋整，简单到可以只有一个 HTML 文件，复杂到引入 React / Vue 等框架类库，视情况而定。对于楼主来说，多数情况下是一个 HTML 文件就可以搞定的。最方便的情况下，直接新建个 HTML 文件，然后起一个本地 server 即可，本地 server 可以用 Python、PHP 等起，对于前端来说，&lt;a href=&quot;https://www.npmjs.com/package/http-server&quot;&gt;http-server&lt;/a&gt; 是个不错的选择，然后再配置个 alias，比如我在 &lt;code&gt;.zshrc&lt;/code&gt; 中配置 &lt;code&gt;alias s=&quot;http-server&quot;&lt;/code&gt;，可以秒启。如果是稍微复杂的情况，需要些许调试，那么修改后自动刷新是必须的，我写了一个简单的脚手架 &lt;a href=&quot;https://github.com/hanzichi/jsj/tree/master/gulp-simple&quot;&gt;gulp-simple&lt;/a&gt; 可以满足这个需求。但是我比较懒，觉得这样还不太方便，毕竟需要编辑器和浏览器两边切换查看效果（单屏的情况下），有时只是查看一个简单的 css 特性，这样搞就显得麻烦了，我又给自己开发了两个简单的在线编辑器，分别是 &lt;a href=&quot;https://hanzichi.github.io/2017/editor-online/codeMirror/&quot;&gt;html editor1&lt;/a&gt; 以及 &lt;a href=&quot;https://hanzichi.github.io/2017/editor-online/ace/&quot;&gt;html editor2&lt;/a&gt;，方便调试简单的 html 页面。&lt;/p&gt;
&lt;p&gt;本地 demo 大概三个方式，总结下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本地新建 HTML 文件，双击启动或者本地启 server&lt;/li&gt;
&lt;li&gt;使用 &lt;a href=&quot;https://github.com/hanzichi/jsj/tree/master/gulp-simple&quot;&gt;gulp-simple&lt;/a&gt;（需要简单调试的页面）&lt;/li&gt;
&lt;li&gt;使用 &lt;a href=&quot;https://hanzichi.github.io/2017/editor-online/codeMirror/&quot;&gt;html editor1&lt;/a&gt; 或者 &lt;a href=&quot;https://hanzichi.github.io/2017/editor-online/ace/&quot;&gt;html editor2&lt;/a&gt; 在线编辑以及调试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你写了个炫酷的页面，希望分享给别人，如果把 HTML 文件发给别人，显然不是一个好的想法，最简单的方式就是将文件上传到服务器，发送链接给别人，也正是接下去要说的外链 demo。&lt;/p&gt;
&lt;p&gt;最方便的选择是选择第三方服务，类似 &lt;a href=&quot;https://codepen.io/&quot;&gt;codepen&lt;/a&gt; 或者 &lt;a href=&quot;https://jsfiddle.net/&quot;&gt;jsfiddle&lt;/a&gt;，国内的 &lt;a href=&quot;http://runjs.cn/&quot;&gt;runjs&lt;/a&gt; 也做的不错可以试试。（这些网站均有很多不错的 demo，可以看看实现）&lt;/p&gt;
&lt;p&gt;因为个人是重度 GitHub 用户，自从知道 GitHub Pages 这玩意后，一般的外链 demo 都放在那了，所以 GitHub Pages 也不失为一个好的选择。（&lt;a href=&quot;https://github.com/hanzichi/hanzichi.github.io&quot;&gt;点这里&lt;/a&gt; 看我的全部 demo）&lt;/p&gt;
&lt;p&gt;说到 GitHub Pages，其实 GitHub 中的 repo 中的静态 HTML 页面也是可以查看效果的（归根结底还是 GitHub Pages），通常用来生成项目主页等。具体设置在具体 repo 的 Settings -&amp;gt; Options -&amp;gt; GitHub Pages 中，选择分支（一般是 master branch 即可），点击 save 即可，比如我在 codedog 项目中生成的 &lt;a href=&quot;https://hanzichi.github.io/codedog/demo/demo.html&quot;&gt;demo&lt;/a&gt;。还有另一个方法，进入 &lt;a href=&quot;https://htmlpreview.github.io/&quot;&gt;GitHub &amp;amp; BitBucket HTML Preview&lt;/a&gt; 这个网站，生成静态页面链接，但是只适用于只有一个 HTML 页面的场景，如果有引用 css 的话路径会错误。&lt;/p&gt;
&lt;p&gt;另外，如果有自己的服务器，那么很显然部署到自己的服务器就可以了。&lt;/p&gt;
&lt;p&gt;外链 demo 同样大概三个方式，总结下：&lt;/p&gt;

&lt;p&gt;重点重点，这才是本文的重点！&lt;/p&gt;
&lt;p&gt;有的时候写文章，需要配个简单的 demo，怎么破？外链当然可以，但是没有直接显示在文章中显得直观。&lt;/p&gt;
&lt;p&gt;首先， &lt;a href=&quot;https://codepen.io/&quot;&gt;codepen&lt;/a&gt; / &lt;a href=&quot;https://jsfiddle.net/&quot;&gt;jsfiddle&lt;/a&gt; / &lt;a href=&quot;http://runjs.cn/&quot;&gt;runjs&lt;/a&gt; 应该都是支持 iframe 插入页面的，但是我一般不这么做，首先 iframe 加载可能会太慢影响体验，其次依赖于第三方总觉得不安全，而且很多的第三方服务并不一定支持 iframe 的插入。&lt;/p&gt;
&lt;p&gt;然后以前用新页面打开来查看页面效果，可以看下很久前写的 &lt;a href=&quot;http://www.cnblogs.com/zichi/p/4214557.html&quot;&gt;这篇文章&lt;/a&gt;，核心和 &lt;a href=&quot;https://hanzichi.github.io/2017/editor-online/codeMirror/&quot;&gt;html editor1&lt;/a&gt; 以及 &lt;a href=&quot;https://hanzichi.github.io/2017/editor-online/ace/&quot;&gt;html editor2&lt;/a&gt; 两个在线编辑器的新页面预览的实现一致，即新建个窗口：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;runCode&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; code &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;editor&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getValue&lt;/span&gt;()
  &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; handler &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;)
  &lt;span class=&quot;va&quot;&gt;handler&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;opener&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;handler&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;write&lt;/span&gt;(code)
  &lt;span class=&quot;va&quot;&gt;handler&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;close&lt;/span&gt;()
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是惊讶地发现在博客园该方式已经失效！我猜测 &lt;code&gt;window.open('')&lt;/code&gt; 被博客园给过滤掉了，所以这个方案基本已经完蛋。以前在博客园看到过页面中直接显示 css 效果的，我猜测实现应该是一样，直接混入了 html 代码，自从接触 markdown 后，我便完全抛弃了富文本编辑器，所以总觉得这样的实现有点 &quot;脏&quot;，但是一直苦于没有一个好的实现。&lt;/p&gt;
&lt;p&gt;我理想中的状态是，可以用 markdown 写文章，但是文章中有些代码可以查看 HTML 效果。最后，我开发了 &lt;a href=&quot;https://github.com/hanzichi/codedog&quot;&gt;codedog&lt;/a&gt; 这个工具，用 markdown 写文章，自动生成 html 文件，比如我前段时间在看 《CSS 揭秘》这本书，我用 markdown 做笔记，用 codedog 生成的 HTML 可以方便查看 CSS 效果，而且支持在线编辑，简直是爽，具体实现效果可以 &lt;a href=&quot;https://github.com/hanzichi/hanzichi.github.io/blob/master/css-secret/README.md&quot;&gt;点击这里&lt;/a&gt; 查看。&lt;/p&gt;
&lt;p&gt;但是 codedog 这个工具是为了这个需求量身定做的，有一定的局限性，有时候要实现文章中带 demo 的效果，不得不在 markdown 和 HTML 中取舍，比如我之前为了学习 flex 写的 &lt;a href=&quot;https://hanzichi.github.io/2017/flex/index.html&quot;&gt;这个 demo&lt;/a&gt;，是纯 HTML 写的，且存在一定的特殊性（不可复用）&lt;/p&gt;
&lt;p&gt;最后就要说到文章开头说的 “发现了一个新的写 demo 的思路”，做到首尾呼应，是什么呢？&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;通过设置 style 标签的 display:block 样式可以让页面的 style 标签显示出来，并且加上 contentEditable 属性后可以让样式成为可编辑状态，更改后的样式效果也是实时更新呈现，这就给交互创造了新的可能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前的实现如果页面有样式，并且修改样式直接预览（类似 &lt;a href=&quot;https://hanzichi.github.io/2017/editor-online/codeMirror/&quot;&gt;html editor1&lt;/a&gt; 或者 &lt;a href=&quot;https://hanzichi.github.io/2017/editor-online/ace/&quot;&gt;html editor2&lt;/a&gt; ），其实实现是获取 value 然后再插入 HTML 文档流中，而通过设置 style 标签的 display:block 样式，操作的就是实际的样式，不需要拐弯抹角。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/675542/201801/675542-20180116213105928-77063177.gif&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;style&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; style=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;display:block&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; contentEditable&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
      body &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;blue&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写了个简单的 &lt;a href=&quot;https://hanzichi.github.io/test-case/style-display-block/&quot;&gt;demo&lt;/a&gt; 可以看下，确实是另一种思路。&lt;/p&gt;
&lt;p&gt;所以说，&quot;文章中带 demo&quot; 所说的 &quot;文章&quot; 实现，可能是 HTML 的，也可能是 markdown 的，具体如何，需要视情况而定了。&lt;/p&gt;
&lt;p&gt;总结下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果是 markdown 写的文章（如果需要涉及 inline 的 demo），最后肯定是要编译成 HTML 预览，思路类似 codedog&lt;/li&gt;
&lt;li&gt;如果直接用 HTML 写文章，类似 &lt;a href=&quot;https://hanzichi.github.io/2017/flex/index.html&quot;&gt;这个&lt;/a&gt;，那么我觉得复用性其实不是很高，毕竟交互方式是不一样的（也可以没有交互），这个时候（如果有交互），可以试试 &lt;code&gt;&amp;lt;style style=&quot;display:block&quot; contentEditable&amp;gt;&lt;/code&gt; 这种方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结就不总结了，都在上面了，如果有补充，热烈欢迎 👏&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jan 2018 13:25:00 +0000</pubDate>
<dc:creator>韩子迟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zichi/p/8298888.html</dc:identifier>
</item>
<item>
<title>大话python面向对象 - 古墓派掌门</title>
<link>http://www.cnblogs.com/qflyue/p/8298555.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qflyue/p/8298555.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　师门中每逢成人礼就要下山历练一番，小掌门今年成人礼，下山也有一段时日。可恰逢年底，今年百姓收成都不是很好，各大店铺也很少招人，再加上学艺不精，小掌门无事可做就只能饿肚子了。后来小掌门饿的实在不行，只好沿街乞讨。其时惨状如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/947890/201801/947890-20180116155952881-430066042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;初识面向对象&lt;/h2&gt;
&lt;p&gt;　　就这样每天风吹日晒地乞讨,后来小掌门发现自己每天所获得的馒头都比其他同行的小乞丐少好多，他发现其他小乞丐都有自己的广告语，然后小掌门稍一改进，便成了如下模样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/947890/201801/947890-20180116160944912-972626044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每次要饭前小掌门都在地上写上几个字&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def beg():#定义一个要饭函数
    print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;求各位给个馒头吃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    beg()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就这样，小掌门的馒头比以往多了起来，时不时也分点馒头给其他乞丐。&lt;/p&gt;
&lt;p&gt;　　一天，过来一个老叫花对小掌门说：“孩子啊，你这样每天要饭前还得找个树枝在地上写一遍字，其实你可以自己做个招牌啊，就跟那人一样”，老叫花指了指对面走过来的另一个乞讨的年轻人。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/947890/201801/947890-20180116162018006-1028504962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小掌门一拍脑门，是啊，我做一个招牌就不用每次都写一遍了，小掌门找了一块破木板，在上面好好提了几笔&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Begger:
    def __init__(self,name,age,money):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age
        self.money&lt;/span&gt;=&lt;span&gt;money
    def beg(self):  # 定义一个要饭函数
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;求各位给个馒头吃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)



&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    zm&lt;/span&gt;=Begger(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古墓派掌门&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,-&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
    zm.beg()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/947890/201801/947890-20180116163501037-1063714383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;老叫花见小掌门挺聪明，笑着说：“看来你已经理解面向对象了”。&lt;/p&gt;
&lt;p&gt;“前辈，什么叫面向对象啊”，小掌门瞪着水汪汪的大眼睛问道。&lt;/p&gt;
&lt;p&gt;“说起面向对象，还得从面向过程说起”&lt;/p&gt;

&lt;h2&gt;面向对象vs面向过程&lt;/h2&gt;
&lt;p&gt;面向过程的程序设计的核心是过程（流水线式思维），过程即解决问题的步骤，面向过程的设计就好比精心设计好一条流水线，考虑周全什么时候处理什么东西。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点是：极大的降低了写程序的复杂度，只需要顺着要执行的步骤，堆叠代码即可。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点是：一套流水线或者流程就是用来解决一个问题，代码牵一发而动全身。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用场景：一旦完成基本很少改变的场景，著名的例子有Linux內核，git，以及Apache HTTP Server等。&lt;/p&gt;

&lt;p&gt;面向对象的程序设计的核心是对象（上帝式思维），要理解对象为何物，必须把自己当成上帝，上帝眼里世间存在的万物皆为对象，不存在的也可以创造出来。面向对象的程序设计好比如来设计西游记，如来要解决的问题是把经书传给东土大唐，如来想了想解决这个问题需要四个人：唐僧，沙和尚，猪八戒，孙悟空，每个人都有各自的特征和技能（这就是对象的概念，特征和技能分别对应对象的属性和方法），然而这并不好玩，于是如来又安排了一群妖魔鬼怪，为了防止师徒四人在取经路上被搞死，又安排了一群神仙保驾护航，这些都是对象。然后取经开始，师徒四人与妖魔鬼怪神仙互相缠斗着直到最后取得真经。如来根本不会管师徒四人按照什么流程去取。&lt;/p&gt;
&lt;p&gt;面向对象的程序设计的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点是：解决了程序的扩展性。对某一个对象单独修改，会立刻反映到整个体系中，如对游戏中一个人物参数的特征和技能修改都很容易。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：可控性差，无法向面向过程的程序设计流水线式的可以很精准的预测问题的处理流程与结果，面向对象的程序一旦开始就由对象之间的交互解决问题&lt;/strong&gt;，&lt;strong&gt;即便是上帝也无法预测最终结果。于是我们经常看到一个游戏人某一参数的修改极有可能导致阴霸的技能出现，一刀砍死3个人，这个游戏就失去平衡。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用场景：需求经常变化的软件，一般需求的变化都集中在用户层，互联网应用，企业内部软件，游戏等都是面向对象的程序设计大显身手的好地方。&lt;/p&gt;
&lt;p&gt;在python 中面向对象的程序设计并不是全部。&lt;/p&gt;
&lt;p&gt;面向对象编程可以使程序的维护和扩展变得更简单，并且可以大大提高程序开发效率 ，另外，基于面向对象的程序可以使它人更加容易理解你的代码逻辑，从而使团队开发变得更从容。&lt;/p&gt;
&lt;p&gt;了解一些名词：类、对象、实例、实例化&lt;/p&gt;
&lt;p&gt;类：具有相同特征的一类事物(人、狗、老虎)&lt;/p&gt;
&lt;p&gt;对象／实例：具体的某一个事物（隔壁阿花、楼下旺财）&lt;/p&gt;
&lt;p&gt;实例化：类——&amp;gt;对象的过程（这在生活中表现的不明显，我们在后面再慢慢解释）&lt;/p&gt;

&lt;h3&gt;类的声明&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #&lt;span&gt;class&lt;/span&gt;&lt;span&gt; 类名:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; #    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;类的文档字符串&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#    类体
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#如：
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Begger:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    def __init__(self,name,age,money):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         self.name=&lt;span&gt;name
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         self.age=&lt;span&gt;age
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         self.money=&lt;span&gt;money
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    def beg(self):  # 定义一个要饭函数
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         print(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;求各位给个馒头吃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在对象实例化时，会自动调用__init__函数，完成对象初识化，相当于c++，java中的构造函数&lt;/p&gt;
&lt;p&gt;上述代码定义了一个Begger类，在&lt;strong&gt;实例化对象&lt;/strong&gt;时，会自动初始化name，age，money&lt;strong&gt;实例属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面提到两个名词‘&lt;strong&gt;实例化对象&lt;/strong&gt;’，‘&lt;strong&gt;实例属性&lt;/strong&gt;’，下面我一一道来&lt;/p&gt;
&lt;h4&gt;实例化对象&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
类名加括号就是实例化，会自动触发__init__函数的运行，可以用它来为每个实例定制自己的特征
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
zm=Begger(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古墓派掌门&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,-&lt;span&gt;10&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;实例属性与类属性及私有属性&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
　　&lt;span&gt;1&lt;/span&gt;&lt;span&gt;：实例属性：

　　　　最好在__init__(self,...)中初始化

　　　　内部调用时都需要加上self.

　　　　外部调用时用instancename.propertyname

　　&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:类属性：

　　　　在__init__()外初始化

　　　　在内部用classname.类属性名调用

　　　　外部既可以用classname.类属性名又可以用instancename.类属性名来调用

　　&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;：私有属性：

　　　　&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;）：单下划线_开头：只是告诉别人这是私有属性，外部依然可以访问更改

　　　　&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）：双下划线__开头：外部不可通过instancename.propertyname来访问或者更改

　　　　　　实际将其转化为了_classname__propertyname&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如我们在乞丐类（Begger）中加一个count类属性，用来计算小乞丐的个数，每个小乞丐加一个婚姻状况（marriage）私有属性：&lt;/p&gt;
&lt;p&gt;(内心戏：没钱还想结婚，做梦吧)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Begger:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     count=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;  #这是一个类属性
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     def __init__(self,name,age,money,single=&lt;span&gt;True):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         self.name=&lt;span&gt;name #实例属性
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         self.age=&lt;span&gt;age
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         self.money=&lt;span&gt;money
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         self._single=&lt;span&gt;True #私有属性
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Begger.count+=&lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    def beg(self):  # 定义一个要饭函数
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         print(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;求各位给个馒头吃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     zm=Begger(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古墓派掌门&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,-&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    zm.beg()
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小乞丐个数：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%Begger.count)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;类方法与静态方法&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
　　&lt;span&gt;1&lt;/span&gt;&lt;span&gt;：普通类方法：

　　　　def fun_name(self,...):

　　　　　　pass

　　　　外部用实例调用

　　&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;：静态方法：@staticmethod            

　　　　　　不能访问实例属性！！！   参数不能传入self！！！

　　　　　　与类相关但是不依赖类与实例的方法！！

　　&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;:类方法：@classmethod

　　　　　　不能访问实例属性！！！   参数必须传入cls！！！

　　　　　　必须传入cls参数（即代表了此类对象&lt;/span&gt;-----区别------&lt;span&gt;self代表实例对象），并且用此来调用类属性：cls.类属性名

　　&lt;/span&gt;*静态方法与类方法都可以通过类或者实例来调用。其两个的特点都是不能够调用实例属性
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Begger:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     count=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;  #这是一个类属性
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     def __init__(self,name,age,money,single=&lt;span&gt;True):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         self.name=&lt;span&gt;name #实例属性
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         self.age=&lt;span&gt;age
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         self.money=&lt;span&gt;money
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         self._single=&lt;span&gt;True #私有属性
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Begger.count+=&lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    def beg(self):  # 定义一个要饭函数，普通类方法
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         print(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;求各位给个馒头吃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    @staticmethod
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    def beg_skill():#定义一个乞讨技巧函数，静态方法
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;乞讨技巧&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    @classmethod
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    def beg_counter(cls):
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小乞丐个数：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; Begger.count)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     zm=Begger(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古墓派掌门&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,-&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    zm.beg()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    zm.beg_skill()
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     Begger.beg_counter()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;tip：类属性与类方法是类固有的方法与属性，不会因为实例不同而改变，写他们的目的是减少多实例时所创造出来的内存空间，加快运行速度&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;封装、继承、多态&lt;/h2&gt;
&lt;p&gt;&quot;封装、继承、多态并称为类的三大特性，也是面向对象的一个主要特点&quot;老叫花说道“下面我就一一跟你讲”&lt;/p&gt;

&lt;h4&gt;封装&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;“&lt;em&gt;封装在于明确区分内外，使得类实现者可以修改封装内的东西而不影响外部调用者的代码；而外部使用用者只知道一个接口(函数)，只要接口（函数）名、参数不变，使用者的代码永远无需改变。这就提供一个良好的合作基础——或者说，只要接口这个基础约定不变，则代码改变不足为虑。你用的那个乞讨类中的乞讨技巧就是很好的体现，别人只看到你表现出的乞讨的形式，并不知道你在背后所做的何种工作&lt;/em&gt;” 老叫花意味深长地说。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;property特性&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
property是一种特殊的属性，访问它时会执行一段功能（函数）然后返回值
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;将一个类的函数定义成特性以后，对象再去使用的时候obj.name,根本无法察觉自己的name是执行了一个函数然后计算出来的，这种特性的使用方式遵循了统一访问的原则


ps：面向对象的封装有三种方式:
【&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;】
这种其实就是不封装,是对外公开的
【&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;】
这种封装方式对外不公开,但对朋友(friend)或者子类公开
【&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;】
这种封装对谁都不公开&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;python并没有在语法上把它们三个内建到自己的class机制中，在C++或java里一般会将所有的所有的数据都设置为私有的，然后提供set和get方法（接口）去设置和获取，在python中通过property方法可以实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用法如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Begger:
    count&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;  #这是一个类属性
    def __init__(self,name,age,money,single&lt;/span&gt;=&lt;span&gt;True):
        self._name&lt;/span&gt;=&lt;span&gt;name
        self._age&lt;/span&gt;=&lt;span&gt;age
        self._money&lt;/span&gt;=&lt;span&gt;money
        self._single&lt;/span&gt;=&lt;span&gt;True #私有属性
        Begger.count&lt;/span&gt;+=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    def beg(self):  # 定义一个要饭函数，普通类方法
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;求各位给个馒头吃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    @property
    def age(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self._age

    @age.setter
    def age(self,value):
        self._age&lt;/span&gt;=&lt;span&gt;value

    @age.deleter
    def age(self):
        del self._age
    @staticmethod
    def beg_skill():#定义一个乞讨技巧函数，静态方法
        print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;乞讨技巧&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    @classmethod
    def beg_counter(cls):
        print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小乞丐个数：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; Begger.count)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    zm&lt;/span&gt;=Begger(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古墓派掌门&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,-&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
    print(zm.age)#获取年龄属性
    zm.age&lt;/span&gt;=&lt;span&gt;20&lt;/span&gt;&lt;span&gt;#设置年龄属性
    print(zm.age)
    del zm.age#删除年龄属性&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;继承&lt;/h4&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;
&lt;pre readability=&quot;6&quot;&gt;
继承，以通用的类为基础建立专门的类对象&lt;p&gt;继承是一种创建新类的方式，在python中，新建的类可以继承一个或多个父类，父类又可称为基类或超类，新建的类称为派生类或子类&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;“说起继承，老叫花子我可就有话说了，什么叫继承，就是儿子继承老子的东西。‘龙生龙，凤生凤，老鼠的儿子会打洞’。虽然说古人有云，‘王侯将相宁有种乎’ ，但有钱真的可以为所欲为，地主的儿子生下来就会继承老子的东西成为富二代，跟咱们这些臭要饭的就不一样了。我来给你举几个例子 ”&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person: #定义一个人类
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     def __init__(self,name,age,money,single=&lt;span&gt;True):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         self.name=&lt;span&gt;name #实例属性
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         self.age=&lt;span&gt;age
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         self.money=&lt;span&gt;money
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         self._single=&lt;span&gt;True #私有属性
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Begger(Person):#定义一个乞丐类，继承Person
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     # count=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;  #这是一个类属性
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    def beg(self):  # 定义一个要饭函数，普通类方法
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         print(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;求各位给个馒头吃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @staticmethod
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    def beg_skill():#定义一个乞讨技巧函数，静态方法
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;乞讨技巧&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    # @classmethod
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    # def beg_counter(cls):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     #     print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小乞丐个数：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; Begger.count)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     zm=Begger(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古墓派掌门&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,-&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    zm.beg()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    zm.beg_skill()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     # Begger.beg_counter()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;tip：用已经有的类建立一个新的类，这样就重用了已经有的软件中的一部分设置大部分，大大生了编程工作量，这就是常说的软件重用，不仅可以重用自己的类，也可以继承别人的，比如标准库，来定制新的数据类型，这样就是大大缩短了软件开发周期，对大型软件开发来说，意义重大.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在python3中，子类新建与父类重名的方法叫重写，子类执行父类的方法也可以直接用super方法（这些与c++，java类似），如我们重写一下子类init方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     def __init__(self,name,age,money,single=&lt;span&gt;True):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         self.name=&lt;span&gt;name #实例属性
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         self.age=&lt;span&gt;age
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         self.money=&lt;span&gt;money
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         self._single=&lt;span&gt;True #私有属性
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Begger(Person):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     count=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;  #这是一个类属性
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    #重写父类__init__
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     def __init__(self,name,age,money,single=&lt;span&gt;True):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        super(Begger,self).__init__(name,age,money,single)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        #或者
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        # Person.__init__(self,name,age,money,single)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         Begger.count+=&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         
&lt;span&gt;17&lt;/span&gt;         
&lt;span&gt;18&lt;/span&gt;         
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    def beg(self):  # 定义一个要饭函数，普通类方法
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         print(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;求各位给个馒头吃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    @property
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    def age(self):
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self._age
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    @age.setter
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    def age(self,value):
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         self._age=&lt;span&gt;value
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    @age.deleter
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    def age(self):
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        del self._age
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    @staticmethod
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    def beg_skill():#定义一个乞讨技巧函数，静态方法
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;乞讨技巧&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    @classmethod
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    def beg_counter(cls):
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小乞丐个数：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; Begger.count)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     zm=Begger(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古墓派掌门&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,-&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    zm.beg_counter()
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     zm.beg_skill()
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;抽象类与接口类&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;继承有两种用途：

一：继承基类的方法，并且做出自己的改变或者扩展（代码重用）  

二：声明某个子类兼容于某基类，定义一个接口类Interface，接口类中定义了一些接口名（就是函数名）且并未实现接口的功能，子类继承接口类，并且实现接口中的功能&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Alipay:
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    支付宝支付
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    def pay(self,money):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;支付宝支付了%s元&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;money)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Applepay:
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    apple pay支付
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    def pay(self,money):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;apple pay支付了%s元&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;money)


def pay(payment,money):
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    支付函数，总体负责支付
    对应支付的对象和要支付的金额
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    payment.pay(money)


p &lt;/span&gt;=&lt;span&gt; Alipay()
pay(p,&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;开发中容易出现的问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Alipay:
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    支付宝支付
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    def pay(self,money):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;支付宝支付了%s元&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;money)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Applepay:
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    apple pay支付
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    def pay(self,money):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;apple pay支付了%s元&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;money)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Wechatpay:
    def fuqian(self,money):
        &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;        实现了pay的功能，但是名字不一样
        &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;        print(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;微信支付了%s元&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;money)

def pay(payment,money):
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    支付函数，总体负责支付
    对应支付的对象和要支付的金额
    &lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;    payment.pay(money)


p &lt;/span&gt;=&lt;span&gt; Wechatpay()
pay(p,&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;)   #执行会报错
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接口初成：手动报异常：NotImplementedError来解决开发中遇到的问题&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Payment:
    def pay(self):
        raise NotImplementedError

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Wechatpay(Payment):
    def fuqian(self,money):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;微信支付了%s元&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;money)


p &lt;/span&gt;=&lt;span&gt; Wechatpay()  #这里不报错
pay(p,&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;)      #这里报错了
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;借用abc模块来实现接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt;&lt;span&gt; abc import ABCMeta,abstractmethod

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Payment(metaclass=&lt;span&gt;ABCMeta):
    @abstractmethod
    def pay(self,money):
        pass


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Wechatpay(Payment):
    def fuqian(self,money):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;微信支付了%s元&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;money)

p &lt;/span&gt;= Wechatpay() #不调就报错了
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实践中，继承的第一种含义意义并不很大，甚至常常是有害的。因为它使得子类与基类出现强耦合。&lt;/p&gt;
&lt;p&gt;继承的第二种含义非常重要。它又叫“接口继承”。&lt;br/&gt;接口继承实质上是要求“做出一个良好的抽象，这个抽象规定了一个兼容接口，使得外部调用者无需关心具体细节，可一视同仁的处理实现了特定接口的所有对象”——这在程序设计上，叫做归一化。&lt;/p&gt;
&lt;p&gt;归一化使得高层的外部使用者可以不加区分的处理所有接口兼容的对象集合——就好象linux的泛文件概念一样，所有东西都可以当文件处理，不必关心它是内存、磁盘、网络还是屏幕（当然，对底层设计者，当然也可以区分出“字符设备”和“块设备”，然后做出针对性的设计：细致到什么程度，视需求而定）。&lt;/p&gt;
&lt;p&gt;在python中根本就没有一个叫做interface的关键字，上面的代码只是看起来像接口，其实并没有起到接口的作用，子类完全可以不用去实现接口 ，如果非要去模仿接口的概念，可以借助第三方模块&lt;/p&gt;
&lt;h4&gt;抽象类&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;与java一样，python也有抽象类的概念但是同样需要借助模块实现，&lt;strong&gt;抽象类是一个特殊的类，它的特殊之处在于只能被继承，不能被实例化&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0f219eca-8258-4a89-b2e1-b8991a8fc292')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_0f219eca-8258-4a89-b2e1-b8991a8fc292&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0f219eca-8258-4a89-b2e1-b8991a8fc292&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0f219eca-8258-4a89-b2e1-b8991a8fc292',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0f219eca-8258-4a89-b2e1-b8991a8fc292&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#一切皆文件
import abc #利用abc模块实现抽象类

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; All_file(metaclass=&lt;span&gt;abc.ABCMeta):
    all_type&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    @abc.abstractmethod #定义抽象方法，无需实现功能
    def read(self):
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;子类必须定义读功能&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        pass

    @abc.abstractmethod #定义抽象方法，无需实现功能
    def write(self):
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;子类必须定义写功能&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        pass

# &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Txt(All_file):
#     pass
#
# t1&lt;/span&gt;=&lt;span&gt;Txt() #报错,子类没有定义抽象方法

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Txt(All_file): #子类继承抽象类，但是必须定义read和write方法
    def read(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;文本数据的读取方法&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    def write(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;文本数据的读取方法&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sata(All_file): #子类继承抽象类，但是必须定义read和write方法
    def read(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;硬盘数据的读取方法&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    def write(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;硬盘数据的读取方法&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Process(All_file): #子类继承抽象类，但是必须定义read和write方法
    def read(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;进程数据的读取方法&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    def write(self):
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;进程数据的读取方法&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

wenbenwenjian&lt;/span&gt;=&lt;span&gt;Txt()

yingpanwenjian&lt;/span&gt;=&lt;span&gt;Sata()

jinchengwenjian&lt;/span&gt;=&lt;span&gt;Process()

#这样大家都是被归一化了,也就是一切皆文件的思想
wenbenwenjian.read()
yingpanwenjian.write()
jinchengwenjian.read()

print(wenbenwenjian.all_type)
print(yingpanwenjian.all_type)
print(jinchengwenjian.all_type)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;python中实现抽象类&lt;/span&gt;&lt;/div&gt;



&lt;h3&gt;多态&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
多态指的是一类事物有多种形态
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person:
    def __init__(self,name,age,money,single&lt;/span&gt;=&lt;span&gt;True):
        self.name&lt;/span&gt;=&lt;span&gt;name #实例属性
        self.age&lt;/span&gt;=&lt;span&gt;age
        self.money&lt;/span&gt;=&lt;span&gt;money
        self._single&lt;/span&gt;=&lt;span&gt;True #私有属性
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; landlord(Person):
    def __init__(self):
        print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是一个地主&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; prince(Person):
    def __init__(self):
        print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是一个王子&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Begger(Person):#乞丐类
    count&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;  #这是一个类属性

    #重写父类__init__
    def __init__(self,name,age,money,single&lt;/span&gt;=&lt;span&gt;True):
        super(Begger,self).__init__(name,age,money,single)
        #或者
        # Person.__init__(self,name,age,money,single)
        Begger.count&lt;/span&gt;+=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    def beg(self):  # 定义一个要饭函数，普通类方法
        print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;求各位给个馒头吃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    @property
    def age(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self._age

    @age.setter
    def age(self,value):
        self._age&lt;/span&gt;=&lt;span&gt;value

    @age.deleter
    def age(self):
        del self._age
    @staticmethod
    def beg_skill():#定义一个乞讨技巧函数，静态方法
        print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;乞讨技巧&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    @classmethod
    def beg_counter(cls):
        print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小乞丐个数：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; Begger.count)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    zm&lt;/span&gt;=Begger(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古墓派掌门&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,-&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
    zm.beg_counter()
    zm.beg_skill()
    wz&lt;/span&gt;=&lt;span&gt;prince()
    dz&lt;/span&gt;=landlord()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;鸭子类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Python崇尚鸭子类型，即‘如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子’&lt;/p&gt;
&lt;p&gt;python程序员通常根据这种行为来编写程序。例如，如果想编写现有对象的自定义版本，可以继承该对象&lt;/p&gt;
&lt;p&gt;也可以创建一个外观和行为像，但与它无任何关系的全新对象，后者通常用于保存程序组件的松耦合度。&lt;/p&gt;







&lt;h2&gt;结语&lt;/h2&gt;
&lt;p&gt;“以上就是面向对象的解释了，小家伙可还满意”老叫花拍了拍酒葫芦道&lt;/p&gt;
&lt;p&gt;“前辈你懂这么多为什么还是一个要饭的啊”&lt;/p&gt;
&lt;p&gt;“其实我以前跟他一样”说着，老叫花指了指对面的那个年轻人&lt;/p&gt;
&lt;p&gt;“前辈，你再给我讲点其他的呗”&lt;/p&gt;
&lt;p&gt;“好好，回头老叫花我慢慢给你讲点其他的，不过你得给我弄点酒。。。。。。。。。。。。”&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jan 2018 12:08:00 +0000</pubDate>
<dc:creator>古墓派掌门</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qflyue/p/8298555.html</dc:identifier>
</item>
<item>
<title>springboot(十七)：使用Spring Boot上传文件 - 纯洁的微笑</title>
<link>http://www.cnblogs.com/ityouknow/p/8298344.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ityouknow/p/8298344.html</guid>
<description>&lt;p&gt;上传文件是互联网中常常应用的场景之一，最典型的情况就是上传头像等，今天就带着带着大家做一个Spring Boot上传文件的小案例。&lt;/p&gt;
&lt;h2 id=&quot;pom包配置&quot;&gt;1、pom包配置&lt;/h2&gt;
&lt;p&gt;我们使用Spring Boot最新版本1.5.9、jdk使用1.8、tomcat8.0。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;parent&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.5.9.RELEASE&lt;span class=&quot;kw&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/parent&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;properties&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;java.version&amp;gt;&lt;/span&gt;1.8&lt;span class=&quot;kw&quot;&gt;&amp;lt;/java.version&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/properties&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-thymeleaf&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-devtools&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;optional&amp;gt;&lt;/span&gt;true&lt;span class=&quot;kw&quot;&gt;&amp;lt;/optional&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;引入了&lt;code&gt;spring-boot-starter-thymeleaf&lt;/code&gt;做页面模板引擎，写一些简单的上传示例。&lt;/p&gt;
&lt;h2 id=&quot;启动类设置&quot;&gt;2、启动类设置&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@SpringBootApplication&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; FileUploadWebApplication {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        SpringApplication.&lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;(FileUploadWebApplication.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, args);
    }

    &lt;span class=&quot;co&quot;&gt;//Tomcat large file upload connection reset&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; TomcatEmbeddedServletContainerFactory &lt;span class=&quot;fu&quot;&gt;tomcatEmbedded&lt;/span&gt;() {
        TomcatEmbeddedServletContainerFactory tomcat = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;TomcatEmbeddedServletContainerFactory&lt;/span&gt;();
        tomcat.&lt;span class=&quot;fu&quot;&gt;addConnectorCustomizers&lt;/span&gt;((TomcatConnectorCustomizer) connector -&amp;gt; {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((connector.&lt;span class=&quot;fu&quot;&gt;getProtocolHandler&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; AbstractHttp11Protocol&amp;lt;?&amp;gt;)) {
                &lt;span class=&quot;co&quot;&gt;//-1 means unlimited&lt;/span&gt;
                ((AbstractHttp11Protocol&amp;lt;?&amp;gt;) connector.&lt;span class=&quot;fu&quot;&gt;getProtocolHandler&lt;/span&gt;()).&lt;span class=&quot;fu&quot;&gt;setMaxSwallowSize&lt;/span&gt;(-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
            }
        });
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; tomcat;
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;tomcatEmbedded这段代码是为了解决，上传文件大于10M出现连接重置的问题。此异常内容GlobalException也捕获不到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/2018/springboot/connect_rest.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;详细内容参考：&lt;a href=&quot;http://www.mkyong.com/spring/spring-file-upload-and-connection-reset-issue/&quot;&gt;Tomcat large file upload connection reset&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;编写前端页面&quot;&gt;3、编写前端页面&lt;/h2&gt;
&lt;p&gt;上传页面&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns:th=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.thymeleaf.org&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Spring Boot file upload example&lt;span class=&quot;kw&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;form&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; method=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;POST&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; action=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/upload&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; enctype=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;multipart/form-data&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;input&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;file&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;file&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;input&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;submit&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Submit&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;非常简单的一个Post请求，一个选择框选择文件，一个提交按钮，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/2018/springboot/upload_submit.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上传结果展示页面：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lang=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns:th=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.thymeleaf.org&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Spring Boot - Upload Status&lt;span class=&quot;kw&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; th:if=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;${message}&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;h2&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; th:text=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;${message}&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/2018/springboot/uploadstatus.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;编写上传控制类&quot;&gt;4、编写上传控制类&lt;/h2&gt;
&lt;p&gt;访问localhost自动跳转到上传页面：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@GetMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;index&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;upload&quot;&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上传业务处理&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@PostMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/upload&quot;&lt;/span&gt;) 
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;singleFileUpload&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;@RequestParam&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;file&quot;&lt;/span&gt;) MultipartFile file,
                               RedirectAttributes redirectAttributes) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (file.&lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;()) {
        redirectAttributes.&lt;span class=&quot;fu&quot;&gt;addFlashAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;message&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Please select a file to upload&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;redirect:uploadStatus&quot;&lt;/span&gt;;
    }

    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
        &lt;span class=&quot;co&quot;&gt;// Get the file and save it somewhere&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] bytes = file.&lt;span class=&quot;fu&quot;&gt;getBytes&lt;/span&gt;();
        Path path = Paths.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(UPLOADED_FOLDER + file.&lt;span class=&quot;fu&quot;&gt;getOriginalFilename&lt;/span&gt;());
        Files.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(path, bytes);

        redirectAttributes.&lt;span class=&quot;fu&quot;&gt;addFlashAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;message&quot;&lt;/span&gt;,
                &lt;span class=&quot;st&quot;&gt;&quot;You successfully uploaded '&quot;&lt;/span&gt; + file.&lt;span class=&quot;fu&quot;&gt;getOriginalFilename&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;'&quot;&lt;/span&gt;);

    } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
        e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
    }

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;redirect:/uploadStatus&quot;&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码的意思就是，通过&lt;code&gt;MultipartFile&lt;/code&gt;读取文件信息，如果文件为空跳转到结果页并给出提示；如果不为空读取文件流并写入到指定目录，最后将结果展示到页面。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MultipartFile&lt;/code&gt;是Spring上传文件的封装类，包含了文件的二进制流和文件属性等信息，在配置文件中也可对相关属性进行配置，基本的配置信息如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;spring.http.multipart.enabled=true&lt;/code&gt; #默认支持文件上传.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spring.http.multipart.file-size-threshold=0&lt;/code&gt; #支持文件写入磁盘.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spring.http.multipart.location=&lt;/code&gt;# 上传文件的临时目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spring.http.multipart.max-file-size=1Mb&lt;/code&gt; # 最大支持文件大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spring.http.multipart.max-request-size=10Mb&lt;/code&gt; # 最大支持请求大小&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最常用的是最后两个配置内容，限制文件上传大小，上传时超过大小会抛出异常：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/2018/springboot/uploadmax.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多配置信息参考这里：&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#common-application-properties&quot;&gt;Common application properties&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;异常处理&quot;&gt;5、异常处理&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@ControllerAdvice&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; GlobalExceptionHandler {

    &lt;span class=&quot;fu&quot;&gt;@ExceptionHandler&lt;/span&gt;(MultipartException.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;handleError1&lt;/span&gt;(MultipartException e, RedirectAttributes redirectAttributes) {
        redirectAttributes.&lt;span class=&quot;fu&quot;&gt;addFlashAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;message&quot;&lt;/span&gt;, e.&lt;span class=&quot;fu&quot;&gt;getCause&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getMessage&lt;/span&gt;());
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;redirect:/uploadStatus&quot;&lt;/span&gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置一个&lt;code&gt;@ControllerAdvice&lt;/code&gt;用来监控&lt;code&gt;Multipart&lt;/code&gt;上传的文件大小是否受限，当出现此异常时在前端页面给出提示。利用&lt;code&gt;@ControllerAdvice&lt;/code&gt;可以做很多东西，比如全局的统一异常处理等，感兴趣的同学可以下来了解。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;6、总结&lt;/h2&gt;
&lt;p&gt;这样一个使用Spring Boot上传文件的简单Demo就完成了，感兴趣的同学可以将示例代码下载下来试试吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.mkyong.com/spring-boot/spring-boot-file-upload-example/&quot;&gt;Spring Boot file upload example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/ityouknow/spring-boot-examples&quot;&gt;示例代码-github&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://gitee.com/ityouknow/spring-boot-examples&quot;&gt;示例代码-码云&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jan 2018 11:14:00 +0000</pubDate>
<dc:creator>纯洁的微笑</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ityouknow/p/8298344.html</dc:identifier>
</item>
<item>
<title>vue中的checkbox全选和反选 - 爱喝酸奶的吃货</title>
<link>http://www.cnblogs.com/yingzi1028/p/8298200.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yingzi1028/p/8298200.html</guid>
<description>&lt;p&gt;      前几天有个博客园的朋友问小颖，小颖之前写的&lt;strong&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/yingzi1028/p/7781829.html&quot;&gt;vue2.0在table中实现全选和反选&lt;/a&gt;&lt;/strong&gt;  、&lt;strong&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/yingzi1028/p/5602784.html&quot;&gt;Vue.js实现checkbox的全选和反选&lt;/a&gt;&lt;/strong&gt;，为什么他将里面的js复制下来，但是实现不了全选和反选。小颖当时看他给的截图，也没太明白，后来手动巧了一下，发现一个疑问，虽然问题是解决了，但是至于为什么小颖还是不太明白，希望有哪位vue大神看到了能帮忙解答一下，嘻嘻，小颖先在这里提前说声：谢谢啦，嘻嘻。&lt;/p&gt;
&lt;p&gt;      我们先来看看第一种实现全选和反选的方法：直接使用   script   标签调用vue。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;='checked' &lt;/span&gt;&lt;span&gt;v-on:click&lt;/span&gt;&lt;span&gt;='checkedAll'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; 全选{{checked}}
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;(list,index) in checkboxList&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;='checkList' &lt;/span&gt;&lt;span&gt;:value&lt;/span&gt;&lt;span&gt;=&quot;list.id&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; {{list.product_inf}}
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        {{checkList}}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
    &amp;lt;script&amp;gt;
    &lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;'#app'&lt;span&gt;,
        data: {
            checkboxList: [{
                &lt;/span&gt;'id': '1'&lt;span&gt;,
                &lt;/span&gt;'product_inf': '女士银手链'&lt;span&gt;
            }, {
                &lt;/span&gt;'id': '2'&lt;span&gt;,
                &lt;/span&gt;'product_inf': '女士银手镯'&lt;span&gt;
            }, {
                &lt;/span&gt;'id': '3'&lt;span&gt;,
                &lt;/span&gt;'product_inf': '女士银耳环'&lt;span&gt;
            }],
            checked: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;全选框&lt;/span&gt;
&lt;span&gt;            checkList: []
        },
        methods: {
            checkedAll: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _this = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
                console.log(_this.checkList);
                console.log(_this.checked);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!_this.checked) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现反选&lt;/span&gt;
                    _this.checkList =&lt;span&gt; [];
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现全选&lt;/span&gt;
                    _this.checkList =&lt;span&gt; [];
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.checkboxList.forEach(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item, index) {
                        _this.checkList.push(item.id);
                    });
                }
            }
        },
        watch: {
            &lt;/span&gt;'checkList'&lt;span&gt;: {
                handler: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(val, oldVal) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (val.length === &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.checkboxList.length) {
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.checked = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.checked = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    }
                },
                deep: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
            }
        },
    })
    &lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/813088/201801/813088-20180116181633631-1051755922.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/813088/201801/813088-20180116181722178-2139890243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;第二种实现方式：在vue脚手架环境中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;='checked' &lt;/span&gt;&lt;span&gt;v-on:click&lt;/span&gt;&lt;span&gt;='checkedAll'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; 全选{{checked}}
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;(list,index) in checkboxList&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;='checkList' &lt;/span&gt;&lt;span&gt;:value&lt;/span&gt;&lt;span&gt;=&quot;list.id&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;{{list.product_inf}}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    {{checkList}}
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click&lt;/span&gt;&lt;span&gt;=&quot;ceshi&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ceshi&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  data() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      checkboxList: [{
        &lt;/span&gt;'id': '1'&lt;span&gt;,
        &lt;/span&gt;'product_inf': '女士银手链'&lt;span&gt;
      }, {
        &lt;/span&gt;'id': '2'&lt;span&gt;,
        &lt;/span&gt;'product_inf': '女士银手镯'&lt;span&gt;
      }, {
        &lt;/span&gt;'id': '3'&lt;span&gt;,
        &lt;/span&gt;'product_inf': '女士银耳环'&lt;span&gt;
      }],
      checked: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;全选框&lt;/span&gt;
&lt;span&gt;      checkList: []
    }
  },
  methods: {
    ceshi: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.checked)
    },
    checkedAll: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _this = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
      console.log(_this.checkList);
      console.log(_this.checked);
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$nextTick(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; DOM 现在更新了&lt;/span&gt;
&lt;span&gt;        console.log(_this.checked);
      });
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_this.checked) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现反选&lt;/span&gt;
        _this.checkList =&lt;span&gt; [];
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现全选&lt;/span&gt;
        _this.checkList =&lt;span&gt; [];
        _this.checkboxList.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item, index) {
          _this.checkList.push(item.id);
        });
      }
    }
  },
  watch: { &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;深度 watcher&lt;/span&gt;
    'checkList'&lt;span&gt;: {
      handler: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(val, oldVal) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (val.length === &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.checkboxList.length) {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.checked = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.checked = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
      },
      deep: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    }
  }
}

&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/813088/201801/813088-20180116182031724-896977531.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/813088/201801/813088-20180116182239474-249175198.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家看完上面的四张图有没有发现一个问题：&lt;/p&gt;
&lt;p&gt;同样是在 click 事件 checkedAll 中执行：   console.log(_this.checked);  但是结果却不一样，第一种环境中，在修改数据之后checkedAll事件中的_this.checked立马就变了，但是在第二种环境中，在修改数据之后checkedAll事件中的_this.checked不会立马变，而是等到下一次调用时，才发生变化，但是在 click 事件 checkedAll   的this.$nextTick事件中，能将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。&lt;/p&gt;
&lt;p&gt;    所以在两种环境中，判断全选和反选的条件也不一样：&lt;/p&gt;
&lt;p&gt;第一种&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;if&lt;/span&gt; (!_this.checked) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现反选&lt;/span&gt;
                    _this.checkList =&lt;span&gt; [];
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现全选&lt;/span&gt;
                    _this.checkList =&lt;span&gt; [];
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.checkboxList.forEach(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item, index) {
                        _this.checkList.push(item.id);
                    });
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二种：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;if&lt;/span&gt; (_this.checked) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现反选&lt;/span&gt;
        _this.checkList =&lt;span&gt; [];
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现全选&lt;/span&gt;
        _this.checkList =&lt;span&gt; [];
        _this.checkboxList.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item, index) {
          _this.checkList.push(item.id);
        });
      }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然也可以将第二种修改为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    checkedAll: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _this = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
      console.log(_this.checkList);
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$nextTick(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(_this.checked);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; DOM 现在更新了&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!_this.checked) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现反选&lt;/span&gt;
          _this.checkList =&lt;span&gt; [];
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现全选&lt;/span&gt;
          _this.checkList =&lt;span&gt; [];
          _this.checkboxList.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item, index) {
            _this.checkList.push(item.id);
          });
        }
      });
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好啦今天的分享就到这里啦，希望大神们能帮小颖解答这个疑惑呦。。。。嘻嘻。&lt;/p&gt;
&lt;p&gt;疑问解决啦，哈哈，原来是版本问题，之前博友给的低版本的，用了最新的版本后发现也要用Vue.nextTick方法&lt;/p&gt;
&lt;p&gt;用新版本后，点击事件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
            checkedAll: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _this = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
                console.log(_this.checkList);
                Vue.nextTick(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; DOM 更新了&lt;/span&gt;
&lt;span&gt;                    console.log(_this.checked);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!_this.checked) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现反选&lt;/span&gt;
                        _this.checkList =&lt;span&gt; [];
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现全选&lt;/span&gt;
                        _this.checkList =&lt;span&gt; [];
                        _this.checkboxList.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item, index) {
                            _this.checkList.push(item.id);
                        });
                    }
                })
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 16 Jan 2018 10:42:00 +0000</pubDate>
<dc:creator>爱喝酸奶的吃货</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yingzi1028/p/8298200.html</dc:identifier>
</item>
<item>
<title>Docker快速指南 - -Finley-</title>
<link>http://www.cnblogs.com/Finley/p/8297939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Finley/p/8297939.html</guid>
<description>&lt;p&gt;Docker使用Go语言开发，基于Linux内核的cgroup、namespace以及AUFS等技术对进程进行封装隔离，是一种操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。&lt;/p&gt;
&lt;p&gt;Docker则使用宿主机内核提供的隔离机制创建沙盒环境，容器内的应用进程直接运行于宿主的内核。 因为容器内没有虚拟硬件和内核，容器在启动时间、执行效率、内存占用以及镜像大小等方面相对于传统虚拟机都拥有很大优势。&lt;/p&gt;
&lt;p&gt;Docker容器将程序及其运行环境打包在一起，镜像创建后可以在任何安装了Docker的系统上运行，无需配置运行环境， 加之较小的镜像体积极大方便了协作开发和部署。&lt;/p&gt;
&lt;p&gt;使用Dockerfile将镜像构建过程透明化，也便于开发和运维人员理解程序的运行环境。&lt;/p&gt;
&lt;p&gt;Docker相对于虚拟机的优势来源于它运行与宿主内核而减少了开销，这使得Docker不能虚拟不同的内核环境。也就是说我们可以很容易地在Windows操作系统上启动一个Linux虚拟机，但是在Windows上启动一个基于Linux的Docker容器则是很困难的事情。&lt;/p&gt;
&lt;p&gt;docker官方已经发布了&lt;code&gt;docker for mac&lt;/code&gt;及&lt;code&gt;docker for windows&lt;/code&gt;。目前&lt;code&gt;docker for mac&lt;/code&gt;使用MAC OS内核提供的&lt;code&gt;HyperKit&lt;/code&gt;虚拟化技术代替了docker-toolbox采用的使用Linux虚拟机提供支持的方式。&lt;/p&gt;
&lt;p&gt;目录:&lt;/p&gt;

&lt;p&gt;cgroup和namespace是Linux内核提供的两种隔离机制，是Docker虚拟化的技术基础：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cgroup: 全名Control Groups, Linux内核提供的用于监控和管理进程组占用资源的机制。 这里的资源包括CPU，内存和IO等硬件资源。&lt;/li&gt;
&lt;li&gt;namespace: 为某个进程提供独立的空间，包括独立的：
&lt;ul&gt;&lt;li&gt;进程树： 进程拥有独立的init进程及其下进程树&lt;/li&gt;
&lt;li&gt;文件系统： 进程拥有独立的根目录&lt;code&gt;/&lt;/code&gt;及其下目录树&lt;/li&gt;
&lt;li&gt;用户: 进程可以定义自己的用户，组和权限系统&lt;/li&gt;
&lt;li&gt;协议栈: 进程可以拥有独立的ip地址及tcp/udp端口空间&lt;/li&gt;
&lt;li&gt;其它&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在了解隔离机制之后我们可以了解Docker中的两个核心概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;容器：容器的本质是进程，它拥有独立的命名空间。因此容器表现很像一个虚拟操作系统，拥有自己的进程树，文件系统等。&lt;/li&gt;
&lt;li&gt;镜像：镜像是容器运行依赖的文件系统，就像每个Linux操作系统时都需要挂载root文件系统&lt;code&gt;/&lt;/code&gt;，镜像就是容器的root文件系统。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Docker采用服务端/客户端架构：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;守护进程(dockerd): Docker服务端每个dockerd下可以运行多个容器，此外还提供了镜像和容器管理的功能。&lt;/li&gt;
&lt;li&gt;客户端: 通过API与dockerd通信进行操作，官方提供了命令行客户端以及Go和Python语言的SDK&lt;/li&gt;
&lt;li&gt;宿主机：用于运行dockerd及其容器的操作系统环境&lt;/li&gt;
&lt;li&gt;Registry：Docker镜像存储中心，用于管理和共享docker镜像。官方存储中心DockerHub中提供了大量官方和第三方镜像。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Docker采用UnionFS技术将镜像设计为分层结构，即一个镜像分为多层，每一层在上一层的基础上构建(即存储增量)。在容器中只能看到所有层叠加后的结果，隐藏了分层的结构。因为镜像层会被其它层依赖，为了保证下层能正常工作， 镜像层在创建后就无法进行修改。&lt;/p&gt;

&lt;p&gt;Docker目前分为免费的社区版（CE）和付费的商业版（EE）两种, 这里我们选用社区版。 Docker官网上提供了各种常用操作系统的安装说明：&lt;/p&gt;
&lt;p&gt;下面看一个简单的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;finley@mbp:$ uname
Darwin
finley@mbp:$ docker run -it ubuntu
root@528ab91753d6:/# uname
Linux&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在执行&lt;code&gt;docker run&lt;/code&gt;命令后发现我们已经从宿主机Mac的终端进入到了Linux终端中。 这个运行中的&quot;Linux&quot;就是容器，启动这个虚拟的Linux环境所需的文件即是镜像。&lt;/p&gt;
&lt;p&gt;上面的示例中我们使用docker代替了ubuntu虚拟机，对比之下docker在镜像大小，启动时间和运行内存占用方面都具有巨大的优势。&lt;/p&gt;
&lt;p&gt;因为启动docker容器的开销和启动相应进程的开销基本相同， 因此完全可以使用docker代替原生进程， 避免复杂的编译安装配置过程。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; run -p 6379:6379 -d redis
&lt;span class=&quot;kw&quot;&gt;3a5748eef653&lt;/span&gt;
$ &lt;span class=&quot;kw&quot;&gt;redis-cli&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;127.0.0.1&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;6379&amp;gt;&lt;/span&gt; keys *
&lt;span class=&quot;kw&quot;&gt;(empty&lt;/span&gt; list or set&lt;span class=&quot;kw&quot;&gt;)&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个示例中我们一键安装并启动了redis-server。&lt;/p&gt;
&lt;p&gt;在终端中输入&lt;code&gt;docker&lt;/code&gt;命令则会显示所有命令和使用帮助, 在docker命令后添加&lt;code&gt;--help&lt;/code&gt;选项可以查看该命令的帮助信息， 如&lt;code&gt;docker run --help&lt;/code&gt;可以查看run命令的帮助。&lt;/p&gt;

&lt;p&gt;本节将简单介绍如何搜索和管理镜像， 为介绍容器做准备。更多关于镜像的构建和共享的内容将在下文中介绍。&lt;/p&gt;
&lt;h2 id=&quot;docker-images&quot;&gt;docker images&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker images&lt;/code&gt;命令用于显示本地所有镜像：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;ubuntu&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;latest&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;00fd29ccc6f1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;3 weeks ago&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;111MB&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;redis&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;latest&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1e70071f4af4&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;4 weeks ago&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;107MB&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;和其它软件一样docker镜像也可以演进出不同版本，tag用于标识镜像的版本。&lt;/p&gt;
&lt;p&gt;repository代表同一镜像多个版本的集合, 它的值是一个URI用于全局唯一标识一组镜像，如&quot;registry.cn-hangzhou.aliyuncs.com/acs/agent&quot;。&lt;/p&gt;
&lt;p&gt;对于DockerHub中的镜像则会省略仓库的地址，诸如&lt;code&gt;dorowu/ubuntu-desktop-lxde-vnc&lt;/code&gt;和&lt;code&gt;ubuntu&lt;/code&gt;就是DockerHub中的镜像。&lt;/p&gt;
&lt;p&gt;由此可见，&lt;code&gt;repository&lt;/code&gt;和&lt;code&gt;tag&lt;/code&gt;可以唯一标识docker镜像。&lt;/p&gt;
&lt;p&gt;除此之外每个镜像还拥有一个摘要(DIGEST)，&lt;code&gt;docker images --digest&lt;/code&gt;可以显示镜像的摘要。&lt;/p&gt;
&lt;h2 id=&quot;docker-search&quot;&gt;docker search&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://hub.docker.com/&quot;&gt;DockerHub&lt;/a&gt;是docker官方提供的公有仓库，&lt;code&gt;docker search&lt;/code&gt;命令用于根据关键字搜索DockerHub中的镜像:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;format&lt;/span&gt;: docker search TERM
&lt;span class=&quot;kw&quot;&gt;demo&lt;/span&gt;: docker search ubuntu&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;ubuntu&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Ubuntu is a ...&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;7076&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;[OK]&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;center&quot;&gt;dorowu/ubuntu-desktop-lxde-vnc&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Ubuntu with openssh-server and NoVNC&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;156&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;[OK]&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;docker-pull&quot;&gt;docker pull&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker pull&lt;/code&gt;命令用于从远程下载镜像，可以通过&lt;code&gt;NAME:TAG&lt;/code&gt;或&lt;code&gt;NAME@DIGEST&lt;/code&gt;的格式来指明目标镜像。&lt;/p&gt;
&lt;p&gt;当只提供了镜像NAME时，默认下载tag为&lt;code&gt;latest&lt;/code&gt;的镜像。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$docker pull ubuntu
$docker pull ubuntu:16.04
$docker pull ubuntu@sha256:fbaf303d18563e57a3c1a0005356ad102509b60884f3aa89ef9a90c0ea5d1212&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NAME也可以是私有仓库中一个REPOSITORY的URI。&lt;/p&gt;
&lt;h2 id=&quot;docker-rmi&quot;&gt;docker rmi&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker rmi&lt;/code&gt;用于删除镜像，可以使用&lt;code&gt;IMAGE ID&lt;/code&gt;或&lt;code&gt;REPOSITORY:TAG&lt;/code&gt;来标记一个容器。&lt;/p&gt;

&lt;h2 id=&quot;docker-run&quot;&gt;docker run&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt;命令用于新建一个容器并启动， 是最重要的和最常用的docker命令之一。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;format: docker run IMAGE CMD ARGS&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt;命令的标准执行流程包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检查本地是否包含指定的镜像，若不存在就从公有仓库下载&lt;/li&gt;
&lt;li&gt;在只读的基础镜像层上挂载一个可读写层，创建容器的文件系统&lt;/li&gt;
&lt;li&gt;根据文件系统启动容器&lt;/li&gt;
&lt;li&gt;将容器与宿主机桥接&lt;/li&gt;
&lt;li&gt;用指定的身份登录容器，并在指定目录下执行&lt;code&gt;CMD ARGS&lt;/code&gt;参数指定的命令&lt;/li&gt;
&lt;li&gt;在命令执行完成后关闭容器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;docker容器在命令执行完毕后会自动退出， 容器的生存周期仅决定于执行命令所需的时间。 如果在容器中执行&lt;code&gt;bash&lt;/code&gt;等长期运行的命令， 就可以保证容器长期运行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt;命令默认会把标准输出流(stdout)重定向到终端，并与容器保持连接状态(attach)。&lt;/p&gt;
&lt;p&gt;在attach状态下， 容器退出之前&lt;code&gt;doceker run&lt;/code&gt;命令不会返回，而是在终端回显容器的输出。 若发出&lt;code&gt;kill&lt;/code&gt;信号(如&lt;code&gt;ctrl + c&lt;/code&gt;快捷键)杀死&lt;code&gt;docekr run&lt;/code&gt;, 那么容器也会提前退出。&lt;/p&gt;
&lt;p&gt;容器对文件系统的修改在可读写层，不会对镜像产生影响， 除非使用&lt;code&gt;docker commit&lt;/code&gt;创建新的镜像层。 容器退出后其文件系统仍将保存在磁盘中，下次启动后会保留所有修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;打开终端&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt;命令默认将容器的标准输出流重定向到终端， 但是没有将终端的标准输入流(stdin)重定向到容器。 也就是说，容器无法接收我们在终端中输入的命令。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;-i&lt;/code&gt;或&lt;code&gt;--interactive&lt;/code&gt;选项会保持容器的输入流(stdin)打开，即使&lt;code&gt;docker run&lt;/code&gt;不与容器保持attach状态。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker run -i ubuntu bash&lt;/code&gt;命令可以打开一个ubuntu终端, 该终端也可以接受我们输入的指令。&lt;/p&gt;
&lt;p&gt;和标准的Linux系统一样，docker镜像也为用户指定了默认终端。 使用&lt;code&gt;-t&lt;/code&gt;或&lt;code&gt;--tty&lt;/code&gt;选项会打开一个虚拟终端(Pseudo-TTY)。&lt;/p&gt;
&lt;p&gt;也就是说，&lt;code&gt;docker run -it ubuntu&lt;/code&gt;命令可以轻松地打开一个可交互ubuntu虚拟环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后台运行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt;命令默认与容器保持连接状态(attach), &lt;code&gt;-d&lt;/code&gt;或&lt;code&gt;--detach&lt;/code&gt;选项可以与容器断开连接。 &lt;code&gt;docker run&lt;/code&gt;命令在显示容器ID后立即返回，容器则会在后台运行。&lt;/p&gt;
&lt;p&gt;上文redis-server的示例即使用了&lt;code&gt;-d&lt;/code&gt;选项， &lt;code&gt;docker run&lt;/code&gt;立即返回， redis-server在后台继续运行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker run -p 6379:6379 -d redis
3a5748eef653
$ redis-cli
127.0.0.1:6379&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;端口映射&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如上文中redis-server示例， 我们经常使用docker容器提供服务，因此需要docker容器监听宿主机的某个端口。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker run -p 6379:6379 -d redis&lt;/code&gt;将对宿主机TCP6379端口的访问映射到容器的TCP6379端口。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-p 6379:6379/udp&lt;/code&gt;则可以映射udp访问(虽然对redis-server来说没有意义)。 多个&lt;code&gt;-p&lt;/code&gt;选项可以映射多个端口&lt;code&gt;docker run -p 80:8080 -p 8080:8081 -d my_server&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;端口映射是将对宿主机某个端口的访问映射到容器的某个端口上， 容器访问宿主机端口不需要配置端口映射。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;挂载数据卷&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-v&lt;/code&gt;选项可以将宿主机上某个目录挂载到容器中的某个目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ls ~/myvol
history.txt
$ docker run -it -v ~/myvol:/app ubuntu
root@e690c508219e:/# ls /app
history.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述指令将宿主机目录&lt;code&gt;~/myvol&lt;/code&gt;挂载到镜像的&lt;code&gt;/app&lt;/code&gt;目录下，&lt;code&gt;/app&lt;/code&gt;目录下原来的内容会被隐藏而是显示宿主机目录&lt;code&gt;~/myvol&lt;/code&gt;下的内容。&lt;/p&gt;
&lt;p&gt;这种方式我们称为在容器上挂载了数据卷，对数据卷的读写独立于容器之外：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;容器对数据卷的修改将立即存储到数据卷所在的(即宿主机的文件系统)上&lt;/li&gt;
&lt;li&gt;除非指明删除数据卷，否则容器删除不会对数据卷产生影响&lt;/li&gt;
&lt;li&gt;其它进程对数据卷的修改将立即生效&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;若数据卷&lt;code&gt;~/myvol&lt;/code&gt;或挂载点&lt;code&gt;/app&lt;/code&gt;不存在的时候， docker会自动创建空目录。&lt;/p&gt;
&lt;p&gt;docker提供了独立于容器的数据卷管理功能，参考&lt;a href=&quot;http://www.cnblogs.com/Finley/p/8297939.html#docker-volume&quot;&gt;docker volume&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为容器命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个容器都拥有一个唯一的&lt;code&gt;CONTAINER ID&lt;/code&gt;来标识，但ID不便于记忆和使用。 因此在&lt;code&gt;docker run&lt;/code&gt;创建容器时可以使用&lt;code&gt;--name&lt;/code&gt;选项来为容器指定一个名称。&lt;/p&gt;
&lt;p&gt;在某个dockerd中容器名称是唯一的， 我们可以使用容器名来唯一指定容器。&lt;/p&gt;
&lt;p&gt;示例：&lt;code&gt;docker run --name my_ubuntu -it ubuntu&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;退出时自动删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker run --rm&lt;/code&gt;选项会在容器退出时自动删除容器。 使用该命令时需谨慎， 容器一旦删除便不可恢复。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自定义工作目录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker run -w PATH&lt;/code&gt;选项会在启动容器时，使用PATH参数指定的路径作为工作目录。&lt;/p&gt;
&lt;h2 id=&quot;docker-create&quot;&gt;docker create&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker create&lt;/code&gt;命令与&lt;code&gt;docker run&lt;/code&gt;指令极为相似，区别在于&lt;code&gt;docker run&lt;/code&gt;创建容器后自动启动容器， 而&lt;code&gt;docker create&lt;/code&gt;不自动启动容器需要使用&lt;code&gt;docker start&lt;/code&gt;命令来启动。&lt;/p&gt;
&lt;h2 id=&quot;docker-ps&quot;&gt;docker ps&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker ps&lt;/code&gt;命令用于显示容器的信息，默认情况下显示运行中的容器：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;finley@mbp&lt;/span&gt; $ docker ps&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;3a5748eef653&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;redis&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&quot;docker-entrypoint...&quot;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;3 hours ago&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Up 3 hours&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0.0.0.0:6379-&amp;gt;6379/tcp&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;redis-server&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;c10921921bfb&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;ubuntu&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&quot;/bin/bash&quot;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;3 hours ago&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Up 52 seconds&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;my_ubuntu&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;-a&lt;/code&gt;选项可以显示包括已停止容器在内的所有容器信息。&lt;/p&gt;
&lt;h2 id=&quot;docker-start&quot;&gt;docker start&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker start&lt;/code&gt;命令用于启动一个已停止的容器，默认情况下不与容器连接(attach)也不将输入重定向到容器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker run --name redis-server -p 6379:6379 redis
$ docker stop redis-server # 此时已经存在一个名为redis-server的已停止容器
$ docker start redis-server
redis-server
$ redis-cli
127.0.0.1:6379&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若使用&lt;code&gt;-a&lt;/code&gt;或&lt;code&gt;--attach&lt;/code&gt;选项将&lt;code&gt;docker start&lt;/code&gt;与容器连接(attach), 终端将回显容器输出。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-i&lt;/code&gt;或&lt;code&gt;--interactive&lt;/code&gt;选项则会将输入重定向到容器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker run --name my_ubuntu -it ubuntu
root@c10921921bfb # exit
# 此时已经存在一个名为my_ubuntu的已停止容器
$ docker start -ai my_ubuntu
root@c10921921bfb:/#&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;docker-exec&quot;&gt;docker exec&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker exec&lt;/code&gt;用于让一个正在运行的容器执行命令，命令执行完成后&lt;code&gt;docker exec&lt;/code&gt;将返回容器继续运行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker run --name my_ubuntu -d ubuntu
$ docker exec my_ubuntu ls
home bin ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下&lt;code&gt;docker exec&lt;/code&gt;与容器连接，&lt;code&gt;-d&lt;/code&gt;或&lt;code&gt;--detach&lt;/code&gt;选项可以不与容器连接而在后台执行命令。&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;docker run&lt;/code&gt;命令类似， &lt;code&gt;-i&lt;/code&gt;选项用于将标准输入重定向到容器以便接收用户输入， &lt;code&gt;-t&lt;/code&gt;选项可以打开终端。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$docker exec -it my_ubuntu bash
root@c10921921bfb:/# &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;docker-attach&quot;&gt;docker attach&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker attach&lt;/code&gt;命令用于与容器连接， 即将容器输出流重定向到终端，终端输入流重定向到容器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker attach my_ubuntu
# 再按一次回车
root@c10921921bfb:/#&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当容器没有输出时终端中没有回显，可能令用户误以为卡死。 attach之后再次输入回车， bash将回显命令行提示符。&lt;/p&gt;
&lt;p&gt;attach状态下&lt;code&gt;ctrl + c&lt;/code&gt;快捷键会发送&lt;code&gt;SIGKILL&lt;/code&gt;信号中止容器， 而&lt;code&gt;ctrl + p, ctrl + q&lt;/code&gt;快捷键会退出attach容器继续运行。&lt;/p&gt;
&lt;h2 id=&quot;docker-stop&quot;&gt;docker stop&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker stop&lt;/code&gt;用于终止容器的运行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$docker stop redis-server&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker stop&lt;/code&gt;命令会先发送&lt;code&gt;SIGTERM&lt;/code&gt;信号要求容器中的进程执行退出操作，若达到超时时间(默认10s)容器仍未退出则会发送&lt;code&gt;SIGKILL&lt;/code&gt;信号强制退出。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-t&lt;/code&gt;或&lt;code&gt;-time&lt;/code&gt;选项可以秒为单位设置强制杀死之前的等待时间:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$docker stop -t 20 redis-server&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;docker-kill&quot;&gt;docker kill&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker kill&lt;/code&gt;命令将直接向容器发送&lt;code&gt;SIGKILL&lt;/code&gt;命令停止容器:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$docker kill redis-server&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-s&lt;/code&gt;或&lt;code&gt;--signal&lt;/code&gt;选项可以向容器发送指定的信号:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker kill -s SIGINT my_ubuntu&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;docker-cp&quot;&gt;docker cp&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker cp&lt;/code&gt;命令负责在运行的容器和宿主机之间复制文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# format: docker cp FROM TO 
$ docker cp test.txt my_ubuntu:/root/test.txt
$ docker cp my_ubuntu:/root/test.txt test.txt &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;docker-rm&quot;&gt;docker rm&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker rm&lt;/code&gt;用于删除一个镜像，通过镜像ID或镜像名来指定要删除的镜像, 默认情况下只能删除已退出的镜像：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker stop my_ubuntu
$ docker rm my_ubuntu&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-f&lt;/code&gt;或&lt;code&gt;--force&lt;/code&gt;选项可以强制删除运行中的镜像。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-v&lt;/code&gt;或&lt;code&gt;--volumes&lt;/code&gt;选项将删除所有挂载的数据卷。&lt;/p&gt;
&lt;h2 id=&quot;docker-volume&quot;&gt;docker volume&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker volume&lt;/code&gt;系列指令用于独立的管理数据卷, 请先阅读&lt;a href=&quot;http://www.cnblogs.com/Finley/p/8297939.html#run-v&quot;&gt;docker run:挂载数据卷&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;create&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将宿主机上一个目录创建为数据卷：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# format: docker volume create PATH
$ docker volume create myvol&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ls&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看所有数据卷：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker volume ls
DRIVER  VOLUME NAME
local   0c28b79a9b3f
local   myvol&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;inspect&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看某个数据卷的详细信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker volume inspect myvol
[
    {
        &quot;CreatedAt&quot;: &quot;2018-01-16T09:04:16Z&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Labels&quot;: null,
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/myvol/_data&quot;,
        &quot;Name&quot;: &quot;myvol&quot;,
        &quot;Options&quot;: {},
        &quot;Scope&quot;: &quot;local&quot;
    }
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;rm&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;删除某个数据卷：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker volume remove myvol
myvol&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;prune&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;删除所有未被使用的数据卷：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker volume prune
WARNING! This will remove all volumes not used by at least one container.
Are you sure you want to continue? [y/N] y
Total reclaimed space: 0B&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用数据卷&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt;和&lt;code&gt;docker create&lt;/code&gt;命令可以使用&lt;code&gt;-v&lt;/code&gt;或&lt;code&gt;--volume&lt;/code&gt;选项来使用数据卷:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -d -it -v myvol:/app ubuntu&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;docker会优先寻找数据卷列表中的myvol而不是当前目录下的myvol子目录。&lt;/p&gt;
&lt;p&gt;若找不到myvol数据卷且当前目录下也不存在myvol子目录，docker会自动创建myvol数据卷不会再当前目录下创建子目录。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--mount&lt;/code&gt;选项虽然语法复杂，但是可以配置更多选项：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -it --mount source=my_volume,target=/app ubuntu&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;上文中已经介绍了如何获取和使用已有镜像，接下来介绍如何构建自己的镜像。&lt;/p&gt;
&lt;p&gt;我们可以将自己的程序及其运行环境打包成Docker容器，部署到服务器或者共享给其它开发者免去配置环境的烦恼。&lt;/p&gt;
&lt;h2 id=&quot;docker-diff&quot;&gt;docker diff&lt;/h2&gt;
&lt;p&gt;前文已经提到过Docker镜像采用分层结构，容器运行时无法修改镜像的内容，而是在镜像层上挂载了一个可读写层。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker diff&lt;/code&gt;命令可以查看容器对镜像的修改：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker run --name my_ubuntu -it ubuntu 
# if exists: docker start -ai my_ubuntu
root@c10921921bfb:~# echo &quot;Hello, from finley&quot; &amp;gt; hello.txt
root@c10921921bfb:~# exit
➜  ~ docker diff my_ubuntu
C /root
A /root/.bash_history
A /root/hello.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们打开一个ubuntu容器在&lt;code&gt;/root&lt;/code&gt;目录中创建了&lt;code&gt;hello.txt&lt;/code&gt;文件， 并在其中写入&quot;Hello, from finley&quot;。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;docker diff&lt;/code&gt;可以看出这个操作产生了三个影响：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;工作目录修改为&lt;code&gt;/root&lt;/code&gt;, C代表变更工作目录&lt;/li&gt;
&lt;li&gt;命令历史&lt;code&gt;.bash_history&lt;/code&gt;文件改变, A代表文件或目录内容发生改变&lt;/li&gt;
&lt;li&gt;修改了文件&lt;code&gt;hello.txt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;docker-commit&quot;&gt;docker commit&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker commit&lt;/code&gt;命令根据容器对镜像的修改创建新的镜像层&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# format: docker commit CONTAINER REPOSITORY[:TAG]
$docker commit my_ubuntu my_ubuntu:2018_01_14
sha256:8096f47d8d6b80e52e617030938c7a83a9d50bafd73915d6952675e7126bb38a
$docker images&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;my_ubuntu&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;2018_01_14&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;8096f47d8d6b&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Less than a second ago&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;111MB&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;-a&lt;/code&gt;或&lt;code&gt;--author&lt;/code&gt;选项可以指定容器的作者， &lt;code&gt;-m&lt;/code&gt;或&lt;code&gt;--message&lt;/code&gt;可以添加备注信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$docker commit \
    -a &quot;finley&amp;lt;finley@finley.pw&amp;gt;&quot;  \
    -m &quot;say hello&quot; \
    my_ubuntu my_ubuntu:2018_01_14&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-c&lt;/code&gt;或&lt;code&gt;--change&lt;/code&gt;选项可以添加一系列Dockerfile指令，关于Dockerfile的内容我们将在下文介绍。&lt;/p&gt;
&lt;h2 id=&quot;docker-tag&quot;&gt;docker tag&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker tag&lt;/code&gt;命令用于为镜像创建一个别名。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# format: docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]
$ docker tag ubuntu my_ubuntu&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TARGET_IMAGE可以是私有仓库REPOSITORY的URI，tag命令经常被用来协助将镜像推送到私有仓库。&lt;/p&gt;
&lt;h2 id=&quot;docker-history&quot;&gt;docker history&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker history&lt;/code&gt;命令用于显示镜像各层的信息，即查看commit历史：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker history ubuntu&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;dockerfile&quot;&gt;Dockerfile&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker commit&lt;/code&gt;命令虽然可以很方便的创建新的镜像，但是我们在容器内操作(特别是尝试性的操作)可能会在新镜像内产生无关的内容，如命令历史和日志等。&lt;/p&gt;
&lt;p&gt;Dockerfile是控制镜像构建过程的脚本，使用Dockerfile可以有效避免镜像中包含无关内容。&lt;/p&gt;
&lt;p&gt;Dockerfile中包含多行指令，每个指令会在镜像中创建一层。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode dockerfile&quot;&gt;
&lt;code class=&quot;sourceCode dockerfile&quot;&gt;&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; nginx
&lt;span class=&quot;kw&quot;&gt;RUN&lt;/span&gt; echo &lt;span class=&quot;st&quot;&gt;'&amp;lt;h1&amp;gt;Hello from finley!&amp;lt;/h1&amp;gt;'&lt;/span&gt; &amp;gt; /usr/share/nginx/html/index.html&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;$ docker build -t nginx_hello .
Step 1/2 : FROM nginx
  ---&amp;gt; 3f8a4339aadd
Step 2/2 : RUN echo '&amp;lt;h1&amp;gt;Hello from finley!&amp;lt;/h1&amp;gt;' &amp;gt; /usr/share/nginx/html/index.html
  ---&amp;gt; Running in 2b3c5df09f9c
  ---&amp;gt; a918263d0f2f
Removing intermediate container 2b3c5df09f9c
Successfully built a918263d0f2f
Successfully tagged nginx_hello:latest
$ docker run --name nginx_hello -p 80:80 -d --rm nginx_hello
$ curl localhost
&amp;lt;h1&amp;gt;Hello from finley!&amp;lt;/h1&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面示例中我们以nginx为基础构建了一个新镜像，并启动它提供服务。&lt;/p&gt;
&lt;p&gt;在具体介绍Dockerfile的指令之前，我们先介绍一下&lt;code&gt;docker build&lt;/code&gt;命令。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker build&lt;/code&gt;指令用于根据Dockerfile构建镜像，通常该指令需要一个PATH参数来指定某个目录做为构建上下文(context)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-f&lt;/code&gt;或&lt;code&gt;--file&lt;/code&gt;选项用于在构建上下文指定Dockerfile文件的路径， 默认为&lt;code&gt;PATH/Dockerfile&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-t&lt;/code&gt;或&lt;code&gt;--tag&lt;/code&gt;选项用于为镜像指定标签，默认情况下名称仍然与基础镜像相同， 而&lt;code&gt;-t NAME:TAG&lt;/code&gt;则会指定容器的名称。&lt;/p&gt;
&lt;p&gt;除了使用一个目录作为构建上下文之外，也可以使用tar压缩包、git仓库作为上下文， 甚至从标准输入中读取Dockerfile或tar进行构建。&lt;/p&gt;
&lt;p&gt;接下来介绍常用的Dockerfile命令：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FROM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FROM&lt;/code&gt;指令用于指定构建容器的基础镜像，标记镜像的语法与&lt;code&gt;docker pull&lt;/code&gt;命令相同。&lt;/p&gt;
&lt;p&gt;除了使用已存在的镜像作为基础镜像之外还有一个特殊的镜像&lt;code&gt;scratch&lt;/code&gt;, 它是一个空镜像。&lt;/p&gt;
&lt;p&gt;我们可以把静态编译的可执行文件放入空白镜像中，由内核直接执行可以极大的降低镜像的体积。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RUN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RUN&lt;/code&gt;命令在镜像中创建一个容器并执行指定指令，执行结束后commit修改作为镜像的一层。&lt;/p&gt;
&lt;p&gt;上文示例中的Step2展示了&lt;code&gt;RUN&lt;/code&gt;指令运行的过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建一个中间容器(intermediate container): 2b3c5df09f9c&lt;/li&gt;
&lt;li&gt;运行命令&lt;code&gt;echo '&amp;lt;h1&amp;gt;Hello from finley!&amp;lt;/h1&amp;gt;' &amp;gt; /usr/share/nginx/html/index.html&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将修改提交，产生新的容器: a918263d0f2f&lt;/li&gt;
&lt;li&gt;删除中间容器：2b3c5df09f9c&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;RUN&lt;/code&gt;命令有两种参数格式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;命令行式： &lt;code&gt;RUN ls -al&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;函数调用式： &lt;code&gt;RUN [&quot;ls&quot;, &quot;-al&quot;]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在实际执行过程中命令行式指令会被映射为&lt;code&gt;RUN [&quot;sh&quot;, &quot;-c&quot;, &quot;ls&quot;, &quot;-al&quot;]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因为每个&lt;code&gt;RUN&lt;/code&gt;指令都会生成一层镜像， 因此最好用&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;将多条指令连接而不是写多条&lt;code&gt;RUN&lt;/code&gt;指令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;COPY&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;COPY from to&lt;/code&gt;指令将文件或目录从构建上下文(context)将文件复制到镜像内部。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode dockerfile&quot;&gt;
&lt;code class=&quot;sourceCode dockerfile&quot;&gt;&lt;span class=&quot;kw&quot;&gt;COPY&lt;/span&gt; ./config.json /root/config.json&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;WORKDIR&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WORKDIR path&lt;/code&gt;命令用于指定容器的默认工作目录。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WORKDIR&lt;/code&gt;命令对Dockerfile中的后续命令都有影响， 除非有另一条&lt;code&gt;WORKDIR&lt;/code&gt;命令修改了工作目录&lt;/p&gt;
&lt;p&gt;上文已经介绍过每条&lt;code&gt;RUN&lt;/code&gt;指令都会创建一个临时容器， 因此&lt;code&gt;RUN cd PATH &amp;amp;&amp;amp;...&lt;/code&gt;只对同一条&lt;code&gt;RUN&lt;/code&gt;中的后续指令有效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;USER&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;USER&lt;/code&gt;命令用于指定容器中的当前用户：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode dockerfile&quot;&gt;
&lt;code class=&quot;sourceCode dockerfile&quot;&gt;&lt;span class=&quot;kw&quot;&gt;RUN&lt;/span&gt; groupadd -r redis &amp;amp;&amp;amp; useradd -r -g redis redis
&lt;span class=&quot;kw&quot;&gt;USER&lt;/span&gt; redis
&lt;span class=&quot;kw&quot;&gt;RUN&lt;/span&gt; redis-server&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和&lt;code&gt;WORKDIR&lt;/code&gt;命令一样，&lt;code&gt;USER&lt;/code&gt;指令直到下一条&lt;code&gt;USER&lt;/code&gt;指令之前始终有效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CMD&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CMD&lt;/code&gt;命令用于指定启动容器的指令, 和&lt;code&gt;RUN&lt;/code&gt;命令一样有两种格式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EXPOSE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;EXPOSE&lt;/code&gt;命令用于声明需要暴露哪些接口，注意&lt;code&gt;EXPOSE&lt;/code&gt;命令没有建立端口映射， 需要在创建容器时启动端口映射。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ENV&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ENV&lt;/code&gt;命令用于为容器设置环境变量：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode dockerfile&quot;&gt;
&lt;code class=&quot;sourceCode dockerfile&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ENV&lt;/span&gt; DEBUG=on VERSION=&lt;span class=&quot;st&quot;&gt;'1.0'&lt;/span&gt; &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;ENTRYPOINT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ENTRYPOINT&lt;/code&gt;指令和CMD一样，用于指定启动容器的指令。 当指定了ENTRYPOINT之后，CMD命令的内容将被作为参数传递给ENTRYPOINT指定的指令。&lt;/p&gt;
&lt;p&gt;首先创建一个容器：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode dockerfile&quot;&gt;
&lt;code class=&quot;sourceCode dockerfile&quot;&gt;&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; ubuntu
&lt;span class=&quot;kw&quot;&gt;CMD&lt;/span&gt; ls&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;$ docker build -t ls:v1 .
$ docker run --rm ls:v1
bin boot dev etc home lib ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们试图传递&lt;code&gt;-al&lt;/code&gt;选项给ls以显示更详细的信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker docker run --rm ls -al
container_linux.go:265: starting container process caused &quot;exec: \&quot;-al\&quot;: executable file not found in $PATH&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据&lt;code&gt;docker run&lt;/code&gt;的语法我们试图让&lt;code&gt;ls&lt;/code&gt;镜像执行&lt;code&gt;-al&lt;/code&gt;命令代替默认命令， 这当然行不通。&lt;/p&gt;
&lt;p&gt;用ENTRYPOINT代替CMD:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode dockerfile&quot;&gt;
&lt;code class=&quot;sourceCode dockerfile&quot;&gt;&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; ubuntu
&lt;span class=&quot;kw&quot;&gt;ENTRYPOINT&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;ls&quot;&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重新创建：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker build -t ls:v2 .
$ docker run --rm ls:v2 -al
total 72
drwxr-xr-x   1 root root 4096 Jan 14 13:29 .
drwxr-xr-x   1 root root 4096 Jan 14 13:29 ..
-rwxr-xr-x   1 root root    0 Jan 14 13:29 .dockerenv
drwxr-xr-x   2 root root 4096 Dec  1 21:53 bin
drwxr-xr-x   2 root root 4096 Apr 12  2016 boot
drwxr-xr-x   5 root root  340 Jan 14 13:29 dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ENTRYPOINT通常用于在执行容器CMD做一些准备工作， 比如官方redis镜像中：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode dockerfile&quot;&gt;
&lt;code class=&quot;sourceCode dockerfile&quot;&gt;&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; alpine:3.4
...
&lt;span class=&quot;kw&quot;&gt;RUN&lt;/span&gt; addgroup -S redis &amp;amp;&amp;amp; adduser -S -G redis redis
...
&lt;span class=&quot;kw&quot;&gt;ENTRYPOINT&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;docker-entrypoint.sh&quot;&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;docker run --entrypoint CMD&lt;/code&gt;可以用来更改容器的ENTRYPOINT。&lt;/p&gt;

&lt;p&gt;现在我们已经了解如何构造自己的镜像，接下来的问题是如何将镜像分享给其它开发者或者部署到服务器。&lt;/p&gt;
&lt;h2 id=&quot;docker-export&quot;&gt;docker export&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker export&lt;/code&gt;命令用于导出容器的快照, 默认输出到标准输出流，需要将输出重定向到文件进行保存。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# format: docker export CONTAINER &amp;gt; TAR
$ docker export my_ubuntu &amp;gt; my_ubuntu.tar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者使用&lt;code&gt;-o&lt;/code&gt;或&lt;code&gt;--output&lt;/code&gt;选项&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker export -o my_ubuntu.tar my_ubuntu&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker export&lt;/code&gt;命令导出时会新建一个空白镜像然后将容器文件系统的内容写入，不包含容器基础镜像各层和tag等信息。&lt;/p&gt;
&lt;h2 id=&quot;docker-save&quot;&gt;docker save&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker save&lt;/code&gt;用于将镜像存储为tar压缩包，默认导出到标准输出流需要重定向以写入文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# format: docker save IMAGE &amp;gt; TAR
$ docker save ubuntu &amp;gt; ubuntu.tar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者使用&lt;code&gt;-o&lt;/code&gt;或&lt;code&gt;--output&lt;/code&gt;选项&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker save -o ubuntu.tar ubuntu&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker save&lt;/code&gt;命令会将镜像各层及其tag信息导出到文件。&lt;/p&gt;
&lt;h2 id=&quot;docker-import&quot;&gt;docker import&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker import&lt;/code&gt;命令用于导入tar格式的快照，生成的镜像只有一层不导入各层和tag信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker import my_ubuntu.tar my_ubuntu:v2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该指令与&lt;code&gt;docker export&lt;/code&gt;相对用于导入容器镜像，但也可以导入&lt;code&gt;docker save&lt;/code&gt;生成的tar文件。&lt;/p&gt;
&lt;h2 id=&quot;docker-load&quot;&gt;docker load&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker load&lt;/code&gt;用于导入tar格式的镜像副本，导入时保留各层和tag等元数据， 因此不需要指定镜像名和tag。&lt;/p&gt;
&lt;p&gt;默认从标准输入流导入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cat ubuntu.tar | docker load&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者使用&lt;code&gt;-i&lt;/code&gt;或&lt;code&gt;--input&lt;/code&gt;选项：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker load -i ubuntu.tar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker load&lt;/code&gt;命令与&lt;code&gt;docker save&lt;/code&gt;命令相对，因为缺少元数据不能导入&lt;code&gt;docker export&lt;/code&gt;生成的tar文件。&lt;/p&gt;
&lt;h2 id=&quot;registry&quot;&gt;Registry&lt;/h2&gt;
&lt;p&gt;虽然docker支持以文件的形式导入导出镜像，但这种方式对于共享镜像来说仍十分不便。&lt;/p&gt;
&lt;p&gt;Docker官方提供了一个registry镜像，我们可以使用它轻松搭建私有仓库。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ mkdir registry
$ docker run -d \
    -p 5000:5000 \
    -v registry:/var/lib/registry \
    registry&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-v&lt;/code&gt;选项将&lt;code&gt;./registry&lt;/code&gt;目录挂载到了容器中，这个目录将用来实际存储镜像。&lt;/p&gt;
&lt;p&gt;docker默认采用HTTPS方式推送和拉取镜像，本文不再介绍如何为私有仓库配置HTTPS证书。&lt;/p&gt;
&lt;p&gt;私有仓库可以配置权限认证，仅授权用户才能推送或拉取镜像，这里也不再详细介绍权限认证相关功能。&lt;/p&gt;
&lt;h2 id=&quot;docker-push&quot;&gt;docker push&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker push&lt;/code&gt;命令用于将镜像推送到仓库，推送到的仓库由镜像的REPOSITORY属性决定。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker tag ubuntu 127.0.0.1:5000/finley/my_ubuntu:v1
$ docker docker push 127.0.0.1:5000/finley/my_ubuntu:v1
The push refers to a repository [127.0.0.1:5000/finley/my_ubuntu]
f17fc24fb8d0: Mounted from registry/my_ubuntu
6458f770d435: Mounted from registry/my_ubuntu
5a876f8f1a3d: Mounted from registry/my_ubuntu
d2f8c05d353b: Mounted from registry/my_ubuntu
48e0baf45d4d: Mounted from registry/my_ubuntu
v1: digest: sha256:f871d0805ee3ce1c52b0608108dbdf1b447a34d22d5c7278a3a9dd78fc12c663 size: 1357
$ curl 127.0.0.1:5000/v2/_catalog
{&quot;repositories&quot;:[&quot;registry/my_ubuntu&quot;]}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，使用&lt;code&gt;docker tag&lt;/code&gt;命令给想要推送的镜像&lt;code&gt;unbuntu:latest&lt;/code&gt;创建一个别名&lt;code&gt;127.0.0.1:5000/registry/my_ubuntu:v1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在这个URI中， &lt;code&gt;127.0.0.1:5000&lt;/code&gt;是Registry的地址，&lt;code&gt;finley&lt;/code&gt;是私有仓库中的一个命名空间， &lt;code&gt;my_ubuntu&lt;/code&gt;是私有仓库中的一个REPOSITORY。&lt;/p&gt;
&lt;p&gt;访问&lt;code&gt;127.0.0.1:5000/v2/_catalog&lt;/code&gt;来查看私有仓库中的镜像。&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jan 2018 09:52:00 +0000</pubDate>
<dc:creator>-Finley-</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Finley/p/8297939.html</dc:identifier>
</item>
</channel>
</rss>