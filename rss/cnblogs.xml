<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>古语云：工欲善其事必先利其器 --&gt; Eclipse开发环境配置 - 黑泽君</title>
<link>http://www.cnblogs.com/chenmingjun/p/10036038.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/10036038.html</guid>
<description>&lt;h2 id=&quot;h1java&quot;&gt;&lt;span&gt;&lt;strong&gt;1、java环境&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h11jdk&quot;&gt;&lt;span&gt;&lt;strong&gt;1.1、安装jdk&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;淘淘商城系统使用java7开发，使用jdk1.7.0 _80版本开发，安装jdk1.7步骤如下图所示：&lt;br/&gt;第一步：在oracle官网下载跟系统相匹配的jdk，如下所示：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Vw1y3.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;第二步：双击运行jdk-7u80-windows-x64.exe，点击“下一步”：&lt;br/&gt;第三步：更改jdk的安装路径（注意：选择jdk安装目录时尽量选择文件名不带空格和中文的目录）&lt;br/&gt;第三步：jdk安装完成之后，会出现jre的安装界面，jdk中已经有jre了，建议不要再单独安装jre，点击“取消”即可。&lt;br/&gt;第四步：等待jdk的安装成功，点击“关闭”。
&lt;h3 id=&quot;h12&quot;&gt;&lt;span&gt;&lt;strong&gt;1.2、配置环境变量+测试&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;安装jdkjdk1.7.0 _80后需要配置环境变量，如下所示：&lt;br/&gt;此电脑/我的电脑右键 --&amp;gt; 属性 --&amp;gt; 高级系统设置 --&amp;gt; 环境变量(N)…&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5VwKVp.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;测试jdk是否安装成功：&lt;br/&gt;1）Win + R，输入cmd，在多个目录下，查看jdk版本信息，命令提示符输入java -version命令，显示如下：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5VwLEB.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;2）Win + R，输入cmd，输入java，出现如下画面表示安装java完成&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Vwe26.png&quot; alt=&quot;&quot;/&gt;
&lt;h3 id=&quot;h21tomcat&quot;&gt;&lt;span&gt;&lt;strong&gt;2.1、安装tomcat&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;淘淘商城开发环境使用tomcat6及以上版本，这里提供apache-tomcat-7.0.52.zip（32位）和apache-tomcat-7.0.47.zip（64位）两个安装程序，分别为tomcat7的32位和64位安装包。根据自己的电脑位置安装相应位数的tomcat（注意：6&lt;br/&gt;4位的操作系统也可以安装32位的软件）解压安装包到自己的电脑上，建议不要解压到有中文的目录下。&lt;/p&gt;
&lt;h3 id=&quot;h22tomcat&quot;&gt;&lt;span&gt;&lt;strong&gt;2.2、配置tomcat&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;网上有些安装教程提到需要配置&lt;code&gt;CATALINA_HOME&lt;/code&gt;环境变量，此变量指向了tomcat的目录，主要是为了方便tomcat运行使用，如果配置了，当你的电脑上有多个tomcat目录时只能成功运行那个和CATALINA_HOME一致的tomcat，如果不配置，在你启动tomcat时它会自己确定tomcat目录，这里我们就不配置了。&lt;/p&gt;
&lt;h3 id=&quot;h23tomcat&quot;&gt;&lt;span&gt;&lt;strong&gt;2.3、测试运行tomcat&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;运行tomcat目录中的bin/startup.bat，启动tomcat，如果启动不起来就到logs查看错误日志，启动后使用浏览器输入http://localhost:8080/，出现如下画面表示tomcat安装成功。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Vw6FG.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;h3eclipse&quot;&gt;&lt;span&gt;&lt;strong&gt;3、Eclipse环境&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h31eclipse&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1、安装Eclipse&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;淘淘商城使用Eclipse Mars.2 Release (4.5.2)，这里提供&lt;code&gt;eclipse-mars01_win32.rar&lt;/code&gt;和&lt;code&gt;eclipse-mars02_win64.rar&lt;/code&gt;的压缩包，根据自己的电脑位置安装相应位数的eclipse，解压安装包到固定位置，建议不要解压到中文目录，运行：eclipse.exe，初次运行会让你确定自己的工作区，工作区是你创建project工程的地方，选择一个容易到的目录作为你的工作区，建议工作区目录不要设在中文目录中。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5VwAlK.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h32eclipse&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2、配置Eclipse&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h321java&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2.1、Java环境配置&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5VwIsn.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;编译器版本：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5VwNAE.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选择java运行环境：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5VwkwQ.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h322webserver&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2.2、web Server配置&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;配置web Server，本系统使用tomcat7作为web容器，需要配置tomcat Server，配置步骤如下：&lt;br/&gt;添加tomcat运行环境：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5VwSEa.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选择Apache Tomcat v7.0：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Vw8j2.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选择Tomcat目录和JRE：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Vwf7z.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击完成，点击OK。
&lt;h4 id=&quot;h323tomcatserver&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2.3、添加Tomcat Server&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5VwxVS.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选择Server --&amp;gt; Server&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Vw2yh.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选择Tomcat v7.0 Server --&amp;gt; Finish&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Vw78H.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h324tomcatserver&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2.4、显示Tomcat Server&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5VwgFN.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选择Server --&amp;gt; Server&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Vwnuu.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;显示界面如下图：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Vwot9.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h325tomcatserver&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2.5、配置Tomcat Server&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5VwqwA.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（1）点击【参数配置】选项，Eclipse 中的 Tomcat 一般在默认情况下内存偏小，运行一会儿就会抛出内存溢出错误，需要在 Tomcat 的 VM arguments 中添加如下参数：-Xms128M -Xmx512M -XX:PermSize=512m -XX:MaxPermSize=1024m，具体大小根据自己的电脑硬件。最后点击下面的 &quot;OK&quot; 按钮保存配置。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Y35Eq.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（2）45秒和15秒分别是tomcat启动和停止的超时时间，该长一些，防止工程较大启动慢造成工程启动不了。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Y33GO.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（3）Eclipse默认将工程部署至eclipse的目录中，目录层次较深不易操作，这里改到tomcat自己的部署目录中。&lt;br/&gt;&lt;code&gt;注意&lt;/code&gt;：如果eclipse的tomcat已添加工程需要在eclipse中将tomcat下的工程全部移除后方可设置该项。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Y397e.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;配置完成后，要点击【保存】按钮。
&lt;h4 id=&quot;h326eclipse&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2.6、配置Eclipse默认字符集&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;需要设置的几处地方为：&lt;br/&gt;  Window --&amp;gt; Preferences --&amp;gt; General --&amp;gt; Content Type --&amp;gt; Text --&amp;gt; JSP 最下面设置为UTF-8&lt;br/&gt;  Window --&amp;gt; Preferences --&amp;gt; General --&amp;gt; Workspace面板 --&amp;gt; Text file encoding 选择UTF-8&lt;br/&gt;  Window --&amp;gt; Preferences --&amp;gt; Web --&amp;gt; JSP Files面板 --&amp;gt; ISO 10646/Unicode(UTF-8)&lt;br/&gt;  Window --&amp;gt; Preferences --&amp;gt; General --&amp;gt; Workspace 面板 --&amp;gt; New text file line delimiter 选择 Unix&lt;/p&gt;
&lt;h4 id=&quot;h327eclipse&quot;&gt;&lt;span&gt;3.2.7、配置Eclipse运行内存&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;为防止eclipse在启动运行时内存溢出，修改eclipse.ini文件添加如下：&lt;br/&gt;  -Xms256m&lt;br/&gt;  -Xmx1024m&lt;br/&gt;  -XX:PermSize=512m&lt;br/&gt;  -XX:MaxPermSize=1024m&lt;br/&gt;附eclipse.ini配置实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs diff&quot;&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;-startup&lt;/span&gt;&lt;br/&gt;plugins/org.eclipse.equinox.launcher_1.3.100.v20150511-1540.jar&lt;br/&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;--launcher.library&lt;/span&gt;&lt;br/&gt;plugins/org.eclipse.equinox.launcher.win32.win32.x86_64_1.1.300.v20150602-1417&lt;br/&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;-product&lt;/span&gt;&lt;br/&gt;org.eclipse.epp.package.jee.product&lt;br/&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;--launcher.defaultAction&lt;/span&gt;&lt;br/&gt;openFile&lt;br/&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;--launcher.XXMaxPermSize&lt;/span&gt;&lt;br/&gt;256M&lt;br/&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;-showsplash&lt;/span&gt;&lt;br/&gt;org.eclipse.platform&lt;br/&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;--launcher.XXMaxPermSize&lt;/span&gt;&lt;br/&gt;256m&lt;br/&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;--launcher.defaultAction&lt;/span&gt;&lt;br/&gt;openFile&lt;br/&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;--launcher.appendVmargs&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;-vmargs&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;-Dosgi.requiredJavaVersion=1.7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;-Xms256m&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;-Xmx1024m&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;-XX:PermSize=512m&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;-XX:MaxPermSize=1024m&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体大小根据自己的电脑硬件！&lt;/p&gt;
&lt;h4 id=&quot;h328eclipse&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2.8、Eclipse字体修改&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;Window --&amp;gt; Preferences --&amp;gt; General --&amp;gt; Appearance --&amp;gt; Colors and Fonts --&amp;gt; Basic --&amp;gt; Text Font&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Y3BYd.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h329eclipse&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2.9、设置Eclipse添加代码提示&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;Window --&amp;gt; Preferences --&amp;gt; Java --&amp;gt; Editor --&amp;gt; Content Assist&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Y3FyR.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;输入：.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
&lt;h2 id=&quot;h4eclipsesvn&quot;&gt;&lt;span&gt;&lt;strong&gt;4、Eclipse SVN 插件安装&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;选择菜单：Help --&amp;gt; Install New Software…&lt;br/&gt;点击Add.. --&amp;gt; 输入Name --&amp;gt; 输入地址：http://subclipse.tigris.org/update_1.8.x&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Y3H8r.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;勾选上复选框，选择【Next】&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Y3XHY.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选择【Next】，再选“I accept the terms of the license agreements”&lt;br/&gt;点击【Finish】按钮开始安装SVN插件&lt;br/&gt;安装过程中弹出如下的警告框，不用理会，直接点击【OK】按钮继续安装&lt;br/&gt;Just Waiting for a little while……(时间有点长)&lt;br/&gt;查看安装好的SVN&lt;br/&gt;Window --&amp;gt; Show View --&amp;gt; Others… --&amp;gt; SVN&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Y3mui.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;到此，我们的SVN插件就算是安装成功了。&lt;br/&gt;Eclipse中在在线安装或更新插件的时候速度出奇的慢，开始还以为是网速的问题，后来发现是配置的问题，可以采用下面两种方法来提升安装更新的速度：
&lt;ol&gt;&lt;li&gt;&lt;span&gt;打开Windows --&amp;gt; Preferences配置窗口，找到Install/Update --&amp;gt; Available Software Sites，将里面不用的信息删除，将本次更新不需要的停用（选中之后然后点右边的Disable按钮）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;在在线安装插件的Install窗口，将下面的&lt;code&gt;Contact all update sites during install to find required software&lt;/code&gt;前面的选项去掉。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Y3zty.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;经过上面两步设置之后，再次更新的话速度就会提升很多，如果被墙的话可以设置代理或者先下载下来，然后在本地安装。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;h5eclipsefreemarker&quot;&gt;&lt;span&gt;&lt;strong&gt;5、Eclipse freemarker 高亮显示插件安装&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Y3Y3X.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;将以上的文件解压后放置到plugins目录下（覆盖）重启下即可。
&lt;h2 id=&quot;h6&quot;&gt;&lt;span&gt;&lt;strong&gt;6、开发个性化设置&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h61&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1、设置显示的视图为包视图&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、关闭【Project Explorer】&lt;br/&gt;2、添加包显示视图，如下图所示：&lt;br/&gt;Window --&amp;gt; Show View --&amp;gt; Others… --&amp;gt; Java --&amp;gt; Package Explorer&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Y30Gl.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h62new&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2、设置New这个菜单的显示栏位&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Y3QLJ.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击【Shortcuts】&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Y3WRB.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;这里：取消勾选EJB、JavaEE、JPA&lt;br/&gt;设置【Maven】&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Y3jY6.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;设置【Java】&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Y3MS3.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击【OK】，效果如下：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/28/5Y3GPp.png&quot; alt=&quot;&quot;/&gt;</description>
<pubDate>Wed, 28 Nov 2018 17:00:00 +0000</pubDate>
<dc:creator>黑泽君</dc:creator>
<og:description>1、java环境 1.1、安装jdk 淘淘商城系统使用java7开发，使用jdk1.7.0 _80版本开发，安装jdk1.7步骤如下图所示：第一步：在oracle官网下载跟系统相匹配的jdk，如下所示</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/10036038.html</dc:identifier>
</item>
<item>
<title>一次python 内存泄漏解决过程 - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/10031945.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/10031945.html</guid>
<description>&lt;p&gt;最近工作中慢慢开始用python协程相关的东西，所以用到了一些相关模块，如aiohttp, aiomysql, aioredis等，用的过程中也碰到的很多问题，这里整理了一次内存泄漏的问题&lt;/p&gt;
&lt;p&gt;通常我们写python程序的时候也很少关注内存这个问题（当然可能我的能力还有待提升），可能写c和c++的朋友会更多的考虑这个问题，但是一旦我们的python程序出现了&lt;/p&gt;
&lt;p&gt;内存泄漏的问题，也将是一件非常麻烦的事情了，而最近的一次代码中也碰到了这个问题，不过好在最后内存溢出不是我代码的问题，而是所用到的一个包出现了内存的问题，下面我通过一个简单的代码模拟出内存的问题，然后也会将解决的过程描述一下，希望能帮助到遇到同样问题的朋友。&lt;/p&gt;
&lt;h2&gt;一、复现问题&lt;/h2&gt;
&lt;p&gt;其实这次主要是在使用aiohttp写一个接口的时候出现的问题，其实复现出问题非常容易，我们实现一个简单的接受post请求接口的服务端，然后实现一个并发的客户端来访问这个接口，来查看内存的情况&lt;/p&gt;
&lt;p&gt;注意： 这个问题是在一个包的特定版本出现的：multidict==4.5.1,我在整理这个文章2个小时前作者已经修复了这个问题发布了4.5.2版本，已经修复了内存的问题，并且我也进行了测试验证&lt;/p&gt;
&lt;p&gt;服务端代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; aiohttp &lt;span&gt;import&lt;/span&gt;&lt;span&gt; web

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; hello(request):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; web.json_response(await request.json())

app &lt;/span&gt;=&lt;span&gt; web.Application()
app.add_routes([web.post(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, hello)])
web.run_app(app)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; aiohttp

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; foo(times):
    data &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;}
    async with aiohttp.ClientSession() as session:
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(times):
            resp &lt;/span&gt;= await session.post(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://localhost:8080&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, json=&lt;span&gt;data)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; x % 100&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(await resp.json())

loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()
loop.run_until_complete(foo(&lt;/span&gt;100000&lt;span&gt;))
loop.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为我的代码是在linux上跑的，或者mac上我们都可以通过htop非常方面的实时查看我们程序内存的占用情况，我们先将服务端启动，查看一下我们此时的内存情况可以看到占用的&lt;/p&gt;
&lt;p&gt;非常少，当我们打开客户端之后，再次观察我们可以看到内存不断增长，及时我们客户端运行完毕内存也不会降低。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997599/201811/997599-20181128233835760-673686395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 当客户端结束之后的内存：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997599/201811/997599-20181128235917171-1022953452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果客户端不停止的话内存会一直涨，最后的结果就是把你的系统内存吃完，然后被系统杀掉你的进程。&lt;/p&gt;

&lt;h2&gt;二、解决内存泄漏的过程&lt;/h2&gt;
&lt;p&gt;像上面的例子是一个非常简单的程序，不复杂我们也并没有做上面复杂的操作就是一个简单的接受post请求的服务端，但是如果是在实际的项目中我们可能会写非常复杂的业务逻辑，那到时候我们又如何找到是哪里导致的内存问题，当我碰到这个问题的时候，其实我和很多接触python不久的人差不多，也是不知道怎么查这种问题，各种百度各种查，也找到了好多推荐的工具，memory_profiler库，objgraph库，graphviz工具，但是都没有帮助我迅速的找到问题点在哪里，最后看到标准库中的tracemalloc,地址：https://docs.python.org/3/library/tracemalloc.html&lt;/p&gt;
&lt;p&gt;通过这个包很快帮我找到了内存泄漏的地方&lt;/p&gt;
&lt;p&gt;接下来按照官网的方法我将代码进行改写，来测试到底哪里的问题导致的内存泄漏，更改后的服务端代码为：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; aiohttp &lt;span&gt;import&lt;/span&gt;&lt;span&gt; web
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tracemalloc


async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; hello(request):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; web.json_response(await request.json())

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_info(request):
    snapshot2 &lt;/span&gt;=&lt;span&gt; tracemalloc.take_snapshot()
    top_stats &lt;/span&gt;= snapshot2.compare_to(snapshot1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lineno&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(top_stats)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; web.Response(text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    app &lt;/span&gt;=&lt;span&gt; web.Application()
    app.add_routes(
        [
            web.post(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, hello),
            web.get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/get_info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, get_info)
        ]
    )
    tracemalloc.start()
    snapshot1 &lt;/span&gt;=&lt;span&gt; tracemalloc.take_snapshot()
    web.run_app(app)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;注意print(top_stats)这行打印的结果最后要关注&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt; 其实这里就是新增加了一个路由get_info, 我们启动服务端之后开启客户端，当我们客户端运行完毕之后，可以看到内存已经涨上去了，并且没有不会释放，这个时候，可以直接通过浏览器访问get_info这个路由看看print打印的内容，这里将会打印出你程序运行到这个时候那一行的代码内存增长的比较多，进行一次排序，前面的几个其实都是需要你关注的，因为这里数据较多，我就只打印如下前几个数据&lt;/p&gt;

&lt;blockquote readability=&quot;28&quot;&gt;
&lt;p&gt;&amp;lt;StatisticDiff traceback=&amp;lt;Traceback (&amp;lt;Frame filename='/Users/zhaofan/anaconda3/lib/python3.6/site-packages/aiohttp/web_response.py' lineno=56&amp;gt;,)&amp;gt; size=116500672 (+116500672) count=300004 (+300004)&amp;gt;,&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&amp;lt;StatisticDiff traceback=&amp;lt;Traceback (&amp;lt;Frame filename='/Users/zhaofan/anaconda3/lib/python3.6/site-packages/aiohttp/web_response.py' lineno=604&amp;gt;,)&amp;gt; size=11400000 (+11400000) count=200000 (+200000)&amp;gt;,&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&amp;lt;StatisticDiff traceback=&amp;lt;Traceback (&amp;lt;Frame filename='/Users/zhaofan/anaconda3/lib/python3.6/site-packages/aiohttp/web_response.py' lineno=472&amp;gt;,)&amp;gt; size=8000000 (+8000000) count=100000 (+100000)&amp;gt;,&lt;/p&gt;
&lt;p&gt;&amp;lt;StatisticDiff traceback=&amp;lt;Traceback (&amp;lt;Frame filename='/Users/zhaofan/anaconda3/lib/python3.6/site-packages/aiohttp/web_response.py' lineno=353&amp;gt;,)&amp;gt; size=5500000 (+5500000) count=100000 (+100000)&amp;gt;,&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&amp;lt;StatisticDiff traceback=&amp;lt;Traceback (&amp;lt;Frame filename='/Users/zhaofan/anaconda3/lib/python3.6/site-packages/aiohttp/web_response.py' lineno=352&amp;gt;,)&amp;gt; size=5300608 (+5300608) count=100001 (+100001)&amp;gt;,&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们拿第一行来说，我们可以非常清楚的指导web_response的56行代码导致内存增长的最多，当然如果是我们复杂的项目也可以通过类似的方法，这样就可以非常快捷的找到我们代码中哪些地方会造成内存溢出，便于排查问题，我们点进去看看这行代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997599/201811/997599-20181129003337645-688994262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们找到最终行，这个时候我们大致就可以看出哪里的问题了，我们接着看 &lt;span&gt; CIMultiDict&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; CIMultiDict(MultiDict):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; _title(self, key):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; key.title()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以看到这个它继承  &lt;span&gt;MultiDict 其实这里我们已经应该知道问题就是处在这个MultiDict上了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而这个最终其实最终就是MultiDict这个包，问题出在了这个包上，这个项目是在这里维护的：https://github.com/aio-libs/multidict&lt;/p&gt;
&lt;p&gt;查看这个包的时候看到了，果然有人和我遇到了同样的问题，问题就是出在这里了，已经有人提交了bug&lt;/p&gt;
&lt;p&gt;https://github.com/aio-libs/multidict/issues/307&lt;/p&gt;
&lt;p&gt;不过不得不说国外的程序员真的是热爱自己的职业，很快这个问题得到了aio-libs小组中人的回应，问题也在我整理这个博客的时候被修复了，在最新的版本：4.5.2中已经测试没有内存泄漏的问题&lt;/p&gt;

&lt;h2&gt;三、总结&lt;/h2&gt;
&lt;p&gt;在这里处理的过程中，其实发现了自己很多的不足，查找问题的方式，以及遇到这种问题的解决思路，不过经过这次，至少下次遇到同样的问题，自己能很快的去查找&lt;/p&gt;
&lt;p&gt;以及解决问题，还有就是针对https://docs.python.org/3/library/tracemalloc.html这个库的使用，也推荐大家多了解一下。&lt;/p&gt;

</description>
<pubDate>Wed, 28 Nov 2018 16:48:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<og:description>最近工作中慢慢开始用python协程相关的东西，所以用到了一些相关模块，如aiohttp, aiomysql, aioredis等，用的过程中也碰到的很多问题，这里整理了一次内存泄漏的问题 通常我们写</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/10031945.html</dc:identifier>
</item>
<item>
<title>【LeetCode题解】844_比较含退格的字符串（Backspace-String-Compare） - StrongXGP</title>
<link>http://www.cnblogs.com/xugenpeng/p/10035916.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xugenpeng/p/10035916.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;blockquote readability=&quot;4.4642857142857&quot;&gt;
&lt;p&gt;更多 LeetCode 题解笔记可以访问我的 &lt;a href=&quot;https://github.com/Genpeng/play-with-leetcode&quot;&gt;github&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;给定 &lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt; 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 &lt;code&gt;#&lt;/code&gt; 代表退格字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入：S = &quot;ab#c&quot;, T = &quot;ad#c&quot;
输出：true
解释：S 和 T 都会变成 “ac”。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入：S = &quot;ab##&quot;, T = &quot;c#d#&quot;
输出：true
解释：S 和 T 都会变成 “”。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入：S = &quot;a##c&quot;, T = &quot;#a#c&quot;
输出：true
解释：S 和 T 都会变成 “c”。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 4：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入：S = &quot;a#c&quot;, T = &quot;b&quot;
输出：false
解释：S 会变成 “c”，但 T 仍然是 “b”。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;1 &amp;lt;= S.length &amp;lt;= 200&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= T.length &amp;lt;= 200&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt; 只含有小写字母以及字符 &lt;code&gt;'#'&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;
&lt;p&gt;当拿到这道题时，可能最直接的想法就是&lt;u&gt;&lt;strong&gt;将两个字符串所对应的结果进行比较&lt;/strong&gt;&lt;/u&gt;。为了能够得到字符串所对应的结果，需要借助栈来模拟键入的过程。从左往右遍历字符串，如果当前的字符并不是退格字符 &lt;code&gt;#&lt;/code&gt;，那么就将当前的字符压入栈中；如果当前的字符是退格字符且栈不为空，那么就将栈顶的元素弹出。最后，栈中剩余字符所组成的字符串即为所求。&lt;/p&gt;
&lt;h2 id=&quot;java-实现&quot;&gt;Java 实现&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Solution {
    public boolean backspaceCompare(String S, String T) {
        return build(S).compare(build(T));
    }

    private String build(String s) {
        Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        for (char c : s.toCharArray()) {
            if (c != '#') {
                stack.push(c);
            } else if (!stack.isEmpty()) {
                stack.pop();
            }
        }
        return String.valueOf(stack);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;python-实现&quot;&gt;Python 实现&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Solution:
    def backspaceCompare(self, S, T):
        &quot;&quot;&quot;
        :type S: str
        :type T: str
        :rtype: bool
        &quot;&quot;&quot;
        def build(s):
            stack = []
            for c in s:
                if c != '#':
                    stack.append(c)
                elif stack:
                    stack.pop()
            return ''.join(stack)
        return build(S) == build(T)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;复杂度分析&quot;&gt;复杂度分析&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(m + n)\)&lt;/span&gt;，其中 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 分别表示字符串 &lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt; 的长度。&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(m + n)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;思路-1&quot;&gt;思路&lt;/h2&gt;
&lt;p&gt;第二种解法本质上也是对字符串所对应的结果进行比较，只不过与解法一不同的是，&lt;strong&gt;&lt;u&gt;解法二是逐个字符进行比较&lt;/u&gt;&lt;/strong&gt;，当发现有字符不相等时，返回 &lt;code&gt;false&lt;/code&gt;。为了能对两个字符串所对应的结果进行比较，需要两个指针，用于指向比较的字符。与此同时，当遇到退格符 &lt;code&gt;#&lt;/code&gt; 时，跳过下一个非退格符的符号，取下下个字符进行比较。为了能够更加生动地说明这个过程，采用了示例1的两个字符作为函数的输入（&lt;code&gt;S=&quot;ab#c&quot;&lt;/code&gt;、&lt;code&gt;T=&quot;ad#c&quot;&lt;/code&gt;），用于演示整个过程，具体的过程见下面的一系列图片。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始时， &lt;code&gt;i=3&lt;/code&gt;、&lt;code&gt;j=3&lt;/code&gt;，此时由于两个索引所对应的字符并不是退格符，直接进行比较（结果相等，&lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 都减一进入下一次循环）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181129002037524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gyNzM1OTE2NTU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当 &lt;code&gt;i=2&lt;/code&gt;、&lt;code&gt;j=2&lt;/code&gt; 时，此时两个索引所对应的字符都是退格符，因此跳过下一个非退格符的字符（字符串 &lt;code&gt;S&lt;/code&gt; 中是字符 &lt;code&gt;b&lt;/code&gt;，而字符串 &lt;code&gt;T&lt;/code&gt; 中是字符 &lt;code&gt;d&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181129002051138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gyNzM1OTE2NTU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当 &lt;code&gt;i=0&lt;/code&gt;、&lt;code&gt;j=0&lt;/code&gt; 时，此时两个索引所对应的字符都不是退格符，再一次进行比较，结果相等，至此循环结束，最终函数返回结果为 &lt;code&gt;true&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181129002106443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gyNzM1OTE2NTU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;java-实现-1&quot;&gt;Java 实现&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Solution {
    public boolean backspaceCompare(String S, String T) {
        int i = S.length() - 1, j = T.length() - 1;
        int sSkip = 0, tSkip = 0;
        
        while (i &amp;gt;= 0 || j &amp;gt;= 0) {
            // 找到字符串S所对应的结果的下一个字符
            while (i &amp;gt;= 0) {
                if (S.charAt(i) == '#') {
                    --i;
                    ++sSkip;
                } else if (sSkip &amp;gt; 0) {
                    --i;
                    --sSkip;
                } else {
                    break;
                }
            }
            
            // 找到字符串T所对应的结果的下一个字符
            while (j &amp;gt;= 0) {
                if (T.charAt(j) == '#') {
                    --j;
                    ++tSkip;
                } else if (tSkip &amp;gt; 0) {
                    --j;
                    --tSkip;
                } else {
                    break;
                }
            }
            
            // 如果索引i和j所对应的字符不相等，返回false
            if (i &amp;gt;= 0 &amp;amp;&amp;amp; j &amp;gt;= 0 &amp;amp;&amp;amp; S.charAt(i) != T.charAt(j)) {
                return false;
            }
            
            // 如果遍历完一个字符串的同时，另一个字符串还未遍历完，返回false
            if ((i &amp;gt;= 0) != (j &amp;gt;= 0)) {
                return false;
            }
            
            --i;
            --j;
        }
        return true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;python-实现-1&quot;&gt;Python 实现&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Solution:
    def backspaceCompare(self, S, T):
        &quot;&quot;&quot;
        :type S: str
        :type T: str
        :rtype: bool
        &quot;&quot;&quot;
        i, j, s_skip, t_skip = len(S) - 1, len(T) - 1, 0, 0
        while i &amp;gt;= 0 or j &amp;gt;= 0:
            # 找到字符串S所对应结果的下一个字符
            while i &amp;gt;= 0:
                if S[i] == '#':
                    i -= 1
                    s_skip += 1
                elif s_skip &amp;gt; 0:
                    i -= 1
                    s_skip -= 1
                else:
                    break
            
            # 找到字符串T所对应结果的下一个字符
            while j &amp;gt;= 0:
                if T[j] == '#':
                    j -= 1
                    t_skip += 1
                elif t_skip &amp;gt; 0:
                    j -= 1
                    t_skip -= 1
                else:
                    break
            
            # 如果索引i和j所对应的字符不相等，返回False
            if i &amp;gt;= 0 and j &amp;gt;= 0 and S[i] != T[j]:
                return False
            
            # 如果遍历完一个字符的同时，另一个字符还未遍历完，返回False
            if (i &amp;gt;= 0) != (j &amp;gt;= 0):
                return False
            
        return True
# Time Limit Exceeded&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;复杂度分析-1&quot;&gt;复杂度分析&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(m + n)\)&lt;/span&gt;，其中 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 分别表示字符串 &lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt; 的长度。&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 28 Nov 2018 16:24:00 +0000</pubDate>
<dc:creator>StrongXGP</dc:creator>
<og:description>更多 LeetCode 题解笔记可以访问我的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xugenpeng/p/10035916.html</dc:identifier>
</item>
<item>
<title>论文笔记：Learning Region Features for Object Detection - 酒精23333</title>
<link>http://www.cnblogs.com/jiujing23333/p/10035781.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiujing23333/p/10035781.html</guid>
<description>&lt;h2 id=&quot;中心思想&quot;&gt;中心思想&lt;/h2&gt;
&lt;p&gt;继Relation Network实现可学习的nms之后，MSRA的大佬们觉得目标检测器依然不够fully learnable，这篇文章类似之前的Deformable ROI Pooling，主要在ROI特征的组织上做文章，文章总结了现有的各种ROI Pooling变体，提出了一个统一的数学表达式，藉由这个表达式，提出完全可学习，无人工设计的Region特征，据Han Hu大佬的讲座所说，这篇文章现在只是提出了一种行得通的方案，还没有研究清楚，性能比Deformable Conv那篇文章稍差一点点。&lt;/p&gt;
&lt;h2 id=&quot;region特征提取的总结和统一表达&quot;&gt;Region特征提取的总结和统一表达&lt;/h2&gt;
&lt;p&gt;一般地，region feature &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{y}(b)\)&lt;/span&gt;的提取可以统一表达为如下的公式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf{y}(b) = \text{RegionFeat}(\mathbf{x}, b)\]&lt;/span&gt;&lt;br/&gt;这里x指的是输入特征，b是bbox。&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{y}(b)\)&lt;/span&gt;的维度是&lt;span class=&quot;math inline&quot;&gt;\(K\times C_f\)&lt;/span&gt;，通道数与输入特征一般相同，为&lt;span class=&quot;math inline&quot;&gt;\(C_f\)&lt;/span&gt;。注意，要特别关注自变量包含哪些东西，这里x是指整张特征图，而不只是box内的特征，譬如在Deformable ROI Pooling中就用到了box之外的特征。这个式子可以具体地表达为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf{y}_k(b) = \sum_{p \in \Omega_b}w_k(b,p,\mathbf{x})\odot \mathbf{x}(p)\]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(\Omega_b\)&lt;/span&gt;表示支撑区域“supporting region”，也就是Pooling所用到的区域，p为区域中的每个位置，&lt;span class=&quot;math inline&quot;&gt;\(\odot\)&lt;/span&gt;表示element-wise相乘，k表示pooling后的第k个位置。也就是说，pooling后的每个位置，都是&lt;span class=&quot;math inline&quot;&gt;\(\Omega_b\)&lt;/span&gt;中每个位置的加权平均。&lt;br/&gt;最原始的RoI Pooling，作者称之为Regular RoI Pooling，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[w_k(b, p) = \begin{cases} 1/|R_{bk}| &amp;amp; \text{ if $p \in R_{bk}$} \\ 0 &amp;amp; \text{else} \end{cases}\]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(R_{bk}\)&lt;/span&gt;是第k个bin的所有位置的几何。这种pooling的缺点是：&lt;strong&gt;由于空间上的下采样，难以区分非常靠近的RoIs。譬如，输入特征一般比原图缩小了16倍，如果两个RoI的距离小于16个像素，那么它们的&lt;span class=&quot;math inline&quot;&gt;\(R_{bk}\)&lt;/span&gt;完全相同，特征也就完全相同。&lt;/strong&gt;&lt;br/&gt;SPPNet中提出的Spatial Pyramid Pooling，跟原始RoI Pooling差不多，只是用了好几种bin的划分。&lt;br/&gt;Aligned ROI Pooling，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[w_k(b, p) = g(u_p, u_{bk}) \cdot g(v_p, v_{bk})\]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(g(a,b) = \max(0, 1-|a-b|)\)&lt;/span&gt;)表示一维的双线性插值核，&lt;span class=&quot;math inline&quot;&gt;\((u_{bk}, v_{bk})\)&lt;/span&gt;表示每个bin的中心点，&lt;span class=&quot;math inline&quot;&gt;\(p=(u_p,v_p)\)&lt;/span&gt;表示整数坐标。比较好理解，就是对于某个浮点坐标，考虑其与四个相邻整数坐标的距离，再进行加权。注意，以上几种Pooling方式，权重都只是依赖几何信息，并不依赖输入特征本身。&lt;/p&gt;
&lt;p&gt;Deformable RoI pooling为每个bin的中心学习一个偏移量&lt;span class=&quot;math inline&quot;&gt;\((\delta u_{bk}, \delta v_{bk})\)&lt;/span&gt;，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[w_k(b,p,\mathbf{x}) = g(u_p, u_{bk} + \delta u_{bk}) \cdot g(v_p, v_{bk} + \delta v_{bk})\]&lt;/span&gt;&lt;br/&gt;PSRoI Pooling，与原始RoI Pooling不同的是，每个bin仅与输入特征通道的某个子集相关，可以表达为&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf{y}_k(b) = \sum_{p \in \Omega_b}w_k(b,p,\mathbf{x}_k)\odot \mathbf{x}_k(p)\]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{x}_k\)&lt;/span&gt;仅包含x在通道轴上的某个子集，具体依据k来决定。&lt;/p&gt;
&lt;h2 id=&quot;学习region-features&quot;&gt;学习Region Features&lt;/h2&gt;
&lt;p&gt;重点来了，说了这么多，上面的各种变体说到底都是完全hand-crafted的。即使Deformable RoI pooling引入了一个可学习的组件，但其形式也很大程度上受限于一个规则的网络。本文的目标就是最大限度地减少手工的设计。&lt;/p&gt;
&lt;p&gt;直觉上，影响&lt;span class=&quot;math inline&quot;&gt;\(w_k\)&lt;/span&gt;的因素有二：一是位置p与RoI box b的几何关系，例如，b内部的位置理应具有较高的权重；二是图像特征x应自适应地使用，这一点Deformable中已经做到了。因此，使用下列式子对&lt;span class=&quot;math inline&quot;&gt;\(w_k\)&lt;/span&gt;进行建模：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[w_k(b,p,\mathbf{x}) \propto \exp(G_k(b,p)+A_k(\mathbf{x},p))\]&lt;/span&gt;&lt;br/&gt;其中，第一项用来捕捉几何关系：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[G_k(b,p) = \langle W^{\text{box}}_{k}\cdot \mathcal{E}^{\text{box}}(b), W^{\text{im}}\cdot \mathcal{E}^{\text{im}}(p) \rangle\]&lt;/span&gt;&lt;br/&gt;这个式子分三步进行。首先，将box和图像坐标嵌入到一个高维空间中（Relation Network中也有类似操作）。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathcal{E}_{2i}(z) = \sin \Large ( \frac{z}{1000^{2i/C_{\mathcal{E}}}} \Large ), \quad \mathcal{E}_{2i+1}(z) = \cos \Large (\frac{z}{1000^{2i/C_{\mathcal{E}}}} \Large )\]&lt;/span&gt;&lt;br/&gt;这个操作确实说不出太多道理，作者也说了这问题还没研究清楚。z是一个标量，ε(z)是一个&lt;span class=&quot;math inline&quot;&gt;\(C_ε\)&lt;/span&gt;维的向量，下标i的取值范围为0至&lt;span class=&quot;math inline&quot;&gt;\(C_ε/2-1\)&lt;/span&gt;。经过这一操作，一个图像坐标p的高维空间嵌入&lt;span class=&quot;math inline&quot;&gt;\(ε^im (p)\)&lt;/span&gt;的维度是&lt;span class=&quot;math inline&quot;&gt;\(2C_ε\)&lt;/span&gt;，一个box b的高维空间嵌入&lt;span class=&quot;math inline&quot;&gt;\(ε^box (b)\)&lt;/span&gt;的维度是&lt;span class=&quot;math inline&quot;&gt;\(4C_ε\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;而后，使用&lt;span class=&quot;math inline&quot;&gt;\(W^{\text{box}}_{k}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(W^{\text{im}}_{k}\)&lt;/span&gt;分别对上面的两个向量作线性变换，变换到同一维度&lt;span class=&quot;math inline&quot;&gt;\(C_g\)&lt;/span&gt;。注意，这里k的数值是比较大的，一般是7x7，实例分割任务中甚至会取14x14，这样搞下来可学习的参数会比较多，所以作者寻思着共享一部分参数，&lt;span class=&quot;math inline&quot;&gt;\(W^{\text{box}}_k = \hat{W}^{\text{box}}_k V^{\text{box}}\)&lt;/span&gt;， &lt;span class=&quot;math inline&quot;&gt;\(V^{\text{box}}\)&lt;/span&gt;没有下标k，所以是共享的，这样做也是比较符合直觉的，在保证输出维度不变的前提下能减少很多参数。&lt;/p&gt;
&lt;p&gt;第二项使用图像特征，跟Deformable那篇是一样的，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[A_k(\mathbf{x},p) = W^{\text{app}}_k \cdot \mathbf{x}(p)\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(W^{\text{app}}_k\)&lt;/span&gt;代表1x1卷积核的权重。&lt;/p&gt;
&lt;h2 id=&quot;高效实现&quot;&gt;高效实现&lt;/h2&gt;
&lt;p&gt;上面这一系列骚操作，乍一看是非常费劲的。但仔细分析之下可以看到，&lt;span class=&quot;math inline&quot;&gt;\(A_k(\mathbf{x},p)\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(W^{\text{im}}\cdot \mathcal{E}^{\text{im}}(p)\)&lt;/span&gt;的计算对所有的RoI是可复用的。所以计算量主要来自计算权重时要跟特征图上的所有点两两进行计算，所以数量级是H&lt;em&gt;W，可以去看原论文中的表，这里就不贴出来了，如果用这种naive的实现方式，计算量惊人。怎么办呢？很显然应该从H&lt;/em&gt;W上下手，手法是很符合直觉的，就是在RoI内部密集采样，而在RoI外部稀疏采样。如下图所示，数量级可以下降100倍左右！但个人认为不是所有的RoI都需要计算，因为一般只选取k个RoI进入到第二阶段，不选的就不必计算了，论文里好像没写这个，不过代码里想必是实现了的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1166644/201811/1166644-20181128234228646-554313217.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 28 Nov 2018 15:51:00 +0000</pubDate>
<dc:creator>酒精23333</dc:creator>
<og:description>中心思想 继Relation Network实现可学习的nms之后，MSRA的大佬们觉得目标检测器依然不够fully learnable，这篇文章类似之前的Deformable ROI Pooling</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiujing23333/p/10035781.html</dc:identifier>
</item>
<item>
<title>常见跨域方法原理及其用例 - guangzai</title>
<link>http://www.cnblogs.com/go4it/p/10021551.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/go4it/p/10021551.html</guid>
<description>&lt;p&gt;一、常见跨域方法&lt;/p&gt;
&lt;p&gt;1） JSONP跨域 需要目标服务器配合一个callback函数&lt;br/&gt;2） AJAX跨域 CORS&lt;br/&gt;3） 使用window.name+iframe来进行跨域&lt;br/&gt;4） window.postMessage:跨文档通信 API（Cross-document messaging）&lt;br/&gt;5） 跨子域:修改document.domain&lt;br/&gt;6） 通过Nginx反向代理&lt;br/&gt;7） WebSocket&lt;/p&gt;

&lt;p&gt;二、原理及其用例&lt;/p&gt;
&lt;p&gt;JSONP跨域：&lt;/p&gt;
&lt;div readability=&quot;23&quot;&gt;
&lt;p&gt;原理：&lt;/p&gt;
&lt;p&gt;&amp;lt;script&amp;gt;可跨域请求资源，json格式被原生 JavaScript支持,客户端与服务器端配合&lt;/p&gt;
&lt;p&gt;客户端动态定义并实现一个函数,将函数添加到请求的目标 URL中,通过创建 &amp;lt;script src=&quot;URL&quot;&amp;gt;跨域请求资源&lt;/p&gt;
&lt;p&gt;服务器端接受到请求,获取添加在请求 URL中的函数,将需要的数据以参数的形式传入获取到的函数中并返回&lt;/p&gt;
&lt;p&gt;客户端获取到带有参数(需要的数据)的函数,执行该函数(客户端已经定义并实现了该函数),处理数据&lt;/p&gt;
&lt;p&gt;用例：&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;客户端代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE HTML&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;JSONP&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    body, input, select, button, h1 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
      font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 28px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      line-height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1.7&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;员工查询&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;请输入员工编号：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;keyword&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;search&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;查询&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;searchResult&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 原理：
     * &amp;lt;script&amp;gt;可跨域请求资源，json格式被原生 JavaScript支持,客户端与服务器端配合
     * 客户端动态定义并实现一个函数,将函数添加到请求的目标 URL中,通过创建 &amp;lt;script src=&quot;URL&quot;&amp;gt;跨域请求资源
     * 服务器端接受到请求,获取添加在请求 URL中的函数,将需要的数据以参数的形式传入获取到的函数中并返回
     * 客户端获取到带有参数(需要的数据)的函数,执行该函数(客户端已经定义并实现了该函数),处理数据
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; myJSONP(url) {

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个十位数的随机数&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt;&lt;span&gt; randomNumber &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; Math.random().toString().substring(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成 cbname(jsonp请求用到的回调函数,后面会添加到URL中)&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt;&lt;span&gt; cbname &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;callbackName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; randomNumber;

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 cbname函数挂载到 myJSONP函数上(即 myJSONP里面有一个 cbname函数)&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt;&lt;span&gt; myJSONP_cbname &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myJSONP.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; cbname;
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现 cbname回调函数&lt;/span&gt;
&lt;span&gt;      myJSONP[cbname] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (response) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; var data=JSON.parse(data); //返回的数据已经是json格式，所以不用转换，否则错误&lt;/span&gt;
          &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (response.success)
            document.querySelector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#searchResult&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).innerHTML&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;response.msg;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求成功&lt;/span&gt;
          &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            document.querySelector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#searchResult&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).innerHTML&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;出现错误：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;response.msg;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求失败&lt;/span&gt;
&lt;span&gt;        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求完成,删除函数以及移除脚本&lt;/span&gt;
          &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; myJSONP[cbname];
          script.parentNode.removeChild(script);
        }
      };

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建script用于发送请求&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt;&lt;span&gt; script &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.createElement(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将 myJSONP里面的 cbname函数添加到URL中&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (url.indexOf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        url &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?callback=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; myJSONP_cbname;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        url &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;callback=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; myJSONP_cbname;
      }
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将脚本的 src指向请求URL,然后将脚本添加到页面中,触发http请求&lt;/span&gt;
&lt;span&gt;      script.src &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; url;
      document.body.appendChild(script);
    }

    document.querySelector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).onclick&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; jsonp跨域请求(模拟跨域请求)&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; jsonp.html 在浏览器中打开的地址为: http://localhost/jsonp.html&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; jsonp.php 服务器地址为: http://127.0.0.1:80/jsonp.php &lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt;&lt;span&gt; url&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://127.0.0.1:80/jsonp.php?number=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;document.querySelector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#keyword&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).value;
      myJSONP(url);
    }

  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;服务器端代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置页面内容是html编码格式是utf-8
// header(&quot;Content-Type: text/plain;charset=utf-8&quot;); &lt;/span&gt;
&lt;span&gt;header&lt;/span&gt;(&quot;Content-Type: application/json;charset=utf-8&quot;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;header(&quot;Content-Type: text/xml;charset=utf-8&quot;); 
//header(&quot;Content-Type: text/html;charset=utf-8&quot;); 
//header(&quot;Content-Type: application/javascript;charset=utf-8&quot;); 

//定义一个多维数组，包含员工的信息，每条员工信息为一个数组&lt;/span&gt;
&lt;span&gt;$staff&lt;/span&gt; = &lt;span&gt;array&lt;/span&gt;&lt;span&gt;
    (
        &lt;/span&gt;&lt;span&gt;array&lt;/span&gt;(&quot;name&quot; =&amp;gt; &quot;洪七&quot;, &quot;number&quot; =&amp;gt; &quot;101&quot;, &quot;sex&quot; =&amp;gt; &quot;男&quot;, &quot;job&quot; =&amp;gt; &quot;总经理&quot;),
        &lt;span&gt;array&lt;/span&gt;(&quot;name&quot; =&amp;gt; &quot;郭靖&quot;, &quot;number&quot; =&amp;gt; &quot;102&quot;, &quot;sex&quot; =&amp;gt; &quot;男&quot;, &quot;job&quot; =&amp;gt; &quot;开发工程师&quot;),
        &lt;span&gt;array&lt;/span&gt;(&quot;name&quot; =&amp;gt; &quot;黄蓉&quot;, &quot;number&quot; =&amp;gt; &quot;103&quot;, &quot;sex&quot; =&amp;gt; &quot;女&quot;, &quot;job&quot; =&amp;gt; &quot;产品经理&quot;&lt;span&gt;)
    );

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断如果是get请求，则进行搜索；如果是POST请求，则进行新建
//$_SERVER是一个超全局变量，在一个脚本的全部作用域中都可用，不用使用global关键字
//$_SERVER[&quot;REQUEST_METHOD&quot;]返回访问页面使用的请求方法&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$_SERVER&lt;/span&gt;[&quot;REQUEST_METHOD&quot;] == &quot;GET&quot;&lt;span&gt;) {
    search();
} &lt;/span&gt;&lt;span&gt;elseif&lt;/span&gt; (&lt;span&gt;$_SERVER&lt;/span&gt;[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;&lt;span&gt;){
    create();
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过员工编号搜索员工&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; search(){    
    &lt;/span&gt;&lt;span&gt;$jsonp&lt;/span&gt; = &lt;span&gt;$_GET&lt;/span&gt;[&quot;callback&quot;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查是否有员工编号的参数
    //isset检测变量是否设置；empty判断值为否为空
    //超全局变量 $_GET 和 $_POST 用于收集表单数据&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_GET&lt;/span&gt;[&quot;number&quot;]) || &lt;span&gt;empty&lt;/span&gt;(&lt;span&gt;$_GET&lt;/span&gt;[&quot;number&quot;&lt;span&gt;])) {
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$jsonp&lt;/span&gt; . '({&quot;success&quot;:false,&quot;msg&quot;:&quot;参数错误&quot;})'&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。
    //global 关键词用于访问函数内的全局变量&lt;/span&gt;
    &lt;span&gt;global&lt;/span&gt; &lt;span&gt;$staff&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取number参数&lt;/span&gt;
    &lt;span&gt;$number&lt;/span&gt; = &lt;span&gt;$_GET&lt;/span&gt;[&quot;number&quot;&lt;span&gt;];    
    &lt;/span&gt;&lt;span&gt;$result&lt;/span&gt; = &lt;span&gt;$jsonp&lt;/span&gt; . '({&quot;success&quot;:false,&quot;msg&quot;:&quot;没有找到员工。&quot;})'&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历$staff多维数组，查找key值为number的员工是否存在，如果存在，则修改返回结果&lt;/span&gt;
    &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;$staff&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$value&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$value&lt;/span&gt;[&quot;number&quot;] == &lt;span&gt;$number&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;$result&lt;/span&gt; = &lt;span&gt;$jsonp&lt;/span&gt; . '({&quot;success&quot;:true,&quot;msg&quot;:&quot;找到员工：员工编号：' . &lt;span&gt;$value&lt;/span&gt;[&quot;number&quot;] .                
                            '，员工姓名：' . &lt;span&gt;$value&lt;/span&gt;[&quot;name&quot;] . 
                            '，员工性别：' . &lt;span&gt;$value&lt;/span&gt;[&quot;sex&quot;] . 
                            '，员工职位：' . &lt;span&gt;$value&lt;/span&gt;[&quot;job&quot;] . '&quot;})'&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$result&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建员工&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; create(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断信息是否填写完全&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_POST&lt;/span&gt;[&quot;name&quot;]) || &lt;span&gt;empty&lt;/span&gt;(&lt;span&gt;$_POST&lt;/span&gt;[&quot;name&quot;&lt;span&gt;])
        &lt;/span&gt;|| !&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_POST&lt;/span&gt;[&quot;number&quot;]) || &lt;span&gt;empty&lt;/span&gt;(&lt;span&gt;$_POST&lt;/span&gt;[&quot;number&quot;&lt;span&gt;])
        &lt;/span&gt;|| !&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_POST&lt;/span&gt;[&quot;sex&quot;]) || &lt;span&gt;empty&lt;/span&gt;(&lt;span&gt;$_POST&lt;/span&gt;[&quot;sex&quot;&lt;span&gt;])
        &lt;/span&gt;|| !&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_POST&lt;/span&gt;[&quot;job&quot;]) || &lt;span&gt;empty&lt;/span&gt;(&lt;span&gt;$_POST&lt;/span&gt;[&quot;job&quot;&lt;span&gt;])) {
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '{&quot;success&quot;:false,&quot;msg&quot;:&quot;参数错误，员工信息填写不全&quot;}'&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO: 获取POST表单数据并保存到数据库
    
    //提示保存成功&lt;/span&gt;
    &lt;span&gt;echo&lt;/span&gt; '{&quot;success&quot;:true,&quot;msg&quot;:&quot;员工：' . &lt;span&gt;$_POST&lt;/span&gt;[&quot;name&quot;] . ' 信息保存成功！&quot;}'&lt;span&gt;;
}

&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1472670/201811/1472670-20181126201546688-934769632.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1472670/201811/1472670-20181126211158798-1012390274.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1472670/201811/1472670-20181126201623453-876441525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）&lt;/p&gt;
&lt;p&gt;原理：&lt;a title=&quot;跨域资源共享 CORS详解-阮一峰&quot; href=&quot;http://www.ruanyifeng.com/blog/2016/04/cors.html&quot; target=&quot;_blank&quot;&gt;详情点击这里&lt;/a&gt;（阮一峰的这篇博客讲得很清楚）&lt;a title=&quot;跨域资源共享 CORS 详解-阮一峰&quot; href=&quot;http://www.ruanyifeng.com/blog/2016/04/cors.html&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用例：&lt;/p&gt;
&lt;p&gt;AJAX跨域之CORS &quot;跨域资源共享&quot;（Cross-origin resource sharing）GET请求之简单请求：&lt;/p&gt;
&lt;p&gt;客户端代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;ie=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Document&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    body, input, select, button, h1 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
      font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 28px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      line-height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1.7&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;查询员工&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;请输入员工编号：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;keyword&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;search&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;查询&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;searchResult&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; handlerResponse(response){
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; response&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;JSON.parse(response);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (response.success)
        document.querySelector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#searchResult&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).innerHTML&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;response.msg;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求成功&lt;/span&gt;
      &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        document.querySelector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#searchResult&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).innerHTML&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;出现错误：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;response.msg;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求失败&lt;/span&gt;
&lt;span&gt;    }
    
    document.querySelector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).onclick&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; CORS跨域请求(模拟跨域请求)&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; AjaxCORS.html 在浏览器中打开的地址为: http://localhost/AjaxCORS.html&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; AjaxCORS.php 服务器地址为: http://127.0.0.1:80/AjaxCORS.php&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt;&lt;span&gt; url&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://127.0.0.1:80/AjaxCORS.php?number=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;document.querySelector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#keyword&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).value;
      ajaxGET(url,handlerResponse);
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ajaxGET(url,callback){
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; xhr&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
      xhr.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,url);
      xhr.send(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
      xhr.onreadystatechange&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(xhr.readyState&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; xhr.status&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;){
          callback(xhr.responseText);
        }
      }
    }

  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;服务器端代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置页面内容是html编码格式是utf-8
// header(&quot;Content-Type: text/plain;charset=utf-8&quot;); &lt;/span&gt;
&lt;span&gt;header&lt;/span&gt;('Access-Control-Allow-Origin:*'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;('Access-Control-Allow-Methods:POST,GET'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;('Access-Control-Allow-Credentials:true'&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;(&quot;Content-Type: application/json;charset=utf-8&quot;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;header(&quot;Content-Type: text/xml;charset=utf-8&quot;); 
//header(&quot;Content-Type: text/html;charset=utf-8&quot;); 
//header(&quot;Content-Type: application/javascript;charset=utf-8&quot;); 

//定义一个多维数组，包含员工的信息，每条员工信息为一个数组&lt;/span&gt;
&lt;span&gt;$staff&lt;/span&gt; = &lt;span&gt;array&lt;/span&gt;&lt;span&gt;
    (
        &lt;/span&gt;&lt;span&gt;array&lt;/span&gt;(&quot;name&quot; =&amp;gt; &quot;洪七&quot;, &quot;number&quot; =&amp;gt; &quot;101&quot;, &quot;sex&quot; =&amp;gt; &quot;男&quot;, &quot;job&quot; =&amp;gt; &quot;总经理&quot;),
        &lt;span&gt;array&lt;/span&gt;(&quot;name&quot; =&amp;gt; &quot;郭靖&quot;, &quot;number&quot; =&amp;gt; &quot;102&quot;, &quot;sex&quot; =&amp;gt; &quot;男&quot;, &quot;job&quot; =&amp;gt; &quot;开发工程师&quot;),
        &lt;span&gt;array&lt;/span&gt;(&quot;name&quot; =&amp;gt; &quot;黄蓉&quot;, &quot;number&quot; =&amp;gt; &quot;103&quot;, &quot;sex&quot; =&amp;gt; &quot;女&quot;, &quot;job&quot; =&amp;gt; &quot;产品经理&quot;&lt;span&gt;)
    );

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断如果是get请求，则进行搜索；如果是POST请求，则进行新建
//$_SERVER是一个超全局变量，在一个脚本的全部作用域中都可用，不用使用global关键字
//$_SERVER[&quot;REQUEST_METHOD&quot;]返回访问页面使用的请求方法&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$_SERVER&lt;/span&gt;[&quot;REQUEST_METHOD&quot;] == &quot;GET&quot;&lt;span&gt;) {
    search();
} &lt;/span&gt;&lt;span&gt;elseif&lt;/span&gt; (&lt;span&gt;$_SERVER&lt;/span&gt;[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;&lt;span&gt;){
    create();
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过员工编号搜索员工&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; search(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查是否有员工编号的参数
    //isset检测变量是否设置；empty判断值为否为空
    //超全局变量 $_GET 和 $_POST 用于收集表单数据&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_GET&lt;/span&gt;[&quot;number&quot;]) || &lt;span&gt;empty&lt;/span&gt;(&lt;span&gt;$_GET&lt;/span&gt;[&quot;number&quot;&lt;span&gt;])) {
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '{&quot;success&quot;:false,&quot;msg&quot;:&quot;参数错误&quot;}'&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。
    //global 关键词用于访问函数内的全局变量&lt;/span&gt;
    &lt;span&gt;global&lt;/span&gt; &lt;span&gt;$staff&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取number参数&lt;/span&gt;
    &lt;span&gt;$number&lt;/span&gt; = &lt;span&gt;$_GET&lt;/span&gt;[&quot;number&quot;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;$result&lt;/span&gt; = '{&quot;success&quot;:false,&quot;msg&quot;:&quot;没有找到员工。&quot;}'&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历$staff多维数组，查找key值为number的员工是否存在，如果存在，则修改返回结果&lt;/span&gt;
    &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;$staff&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$value&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$value&lt;/span&gt;[&quot;number&quot;] == &lt;span&gt;$number&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;$result&lt;/span&gt; = '{&quot;success&quot;:true,&quot;msg&quot;:&quot;找到员工：员工编号：' . &lt;span&gt;$value&lt;/span&gt;[&quot;number&quot;] . 
                            '，员工姓名：' . &lt;span&gt;$value&lt;/span&gt;[&quot;name&quot;] . 
                            '，员工性别：' . &lt;span&gt;$value&lt;/span&gt;[&quot;sex&quot;] . 
                            '，员工职位：' . &lt;span&gt;$value&lt;/span&gt;[&quot;job&quot;] . '&quot;}'&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$result&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1472670/201811/1472670-20181126214120490-1623855648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;AJAX跨域之CORS &quot;跨域资源共享&quot;（Cross-origin resource sharing）POST请求之非简单请求：&lt;/p&gt;
&lt;p&gt;客户端代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;application/json; charset=utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;AjaxCORS&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    body, input, select, button, h1 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
      font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 28px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      line-height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1.7&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;新建员工&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;请输入员工姓名：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;staffName&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;请输入员工编号：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;staffNumber&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;请选择员工性别：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;staffSex&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;女&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;男&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;请输入员工职位：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;staffJob&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;save&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;保存&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;createResult&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; handlerResponse(response){
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; response&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;JSON.parse(response);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (response.success)
        document.querySelector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#createResult&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).innerHTML&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;response.msg;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求成功&lt;/span&gt;
      &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        document.querySelector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#createResult&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).innerHTML&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;出现错误：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;response.msg;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求失败&lt;/span&gt;
&lt;span&gt;    }
    
    document.querySelector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#save&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).onclick&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; CORS跨域请求(模拟跨域请求)&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; AjaxCORS.html 在浏览器中打开的地址为: http://localhost/AjaxCORS.html&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; AjaxCORS.php 服务器地址为: http://127.0.0.1:80/AjaxCORS.php&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt;&lt;span&gt; url&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://127.0.0.1:80/AjaxCORS.php&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; data&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: document.querySelector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#staffName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).value, 
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: document.querySelector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#staffNumber&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).value, 
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: document.querySelector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#staffSex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).value, 
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;job&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: document.querySelector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#staffJob&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).value
      };
      data&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;JSON.stringify(data); 
      ajaxPOST(url,data,handlerResponse);
    }

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ajaxPOST(url,data,callback){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; xhr&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
    xhr.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,url);
    xhr.setRequestHeader(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    xhr.send(data);
    xhr.onreadystatechange&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(xhr.readyState&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; xhr.status&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;){ 
        callback(xhr.responseText);
      }
    }
  }

  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;服务器端代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置页面内容是html编码格式是utf-8&lt;/span&gt;
&lt;span&gt;header&lt;/span&gt;('Access-Control-Allow-Origin:*'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;('Access-Control-Allow-Headers:content-type'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; header('Access-Control-Allow-Methods:POST,GET,OPTION');
// header('Access-Control-Allow-Credentials:true'); 
// header(&quot;Content-Type: text/plain;charset=utf-8&quot;); &lt;/span&gt;
&lt;span&gt;header&lt;/span&gt;(&quot;Content-Type: application/json;charset=utf-8&quot;&lt;span&gt;); 

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个多维数组，包含员工的信息，每条员工信息为一个数组&lt;/span&gt;
&lt;span&gt;$staff&lt;/span&gt; = &lt;span&gt;array&lt;/span&gt;&lt;span&gt;
    (
        &lt;/span&gt;&lt;span&gt;array&lt;/span&gt;(&quot;name&quot; =&amp;gt; &quot;洪七&quot;, &quot;number&quot; =&amp;gt; &quot;101&quot;, &quot;sex&quot; =&amp;gt; &quot;男&quot;, &quot;job&quot; =&amp;gt; &quot;总经理&quot;),
        &lt;span&gt;array&lt;/span&gt;(&quot;name&quot; =&amp;gt; &quot;郭靖&quot;, &quot;number&quot; =&amp;gt; &quot;102&quot;, &quot;sex&quot; =&amp;gt; &quot;男&quot;, &quot;job&quot; =&amp;gt; &quot;开发工程师&quot;),
        &lt;span&gt;array&lt;/span&gt;(&quot;name&quot; =&amp;gt; &quot;黄蓉&quot;, &quot;number&quot; =&amp;gt; &quot;103&quot;, &quot;sex&quot; =&amp;gt; &quot;女&quot;, &quot;job&quot; =&amp;gt; &quot;产品经理&quot;&lt;span&gt;)
    );

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断如果是get请求，则进行搜索；如果是POST请求，则进行新建
//$_SERVER是一个超全局变量，在一个脚本的全部作用域中都可用，不用使用global关键字
//$_SERVER[&quot;REQUEST_METHOD&quot;]返回访问页面使用的请求方法&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$_SERVER&lt;/span&gt;[&quot;REQUEST_METHOD&quot;] == &quot;GET&quot;&lt;span&gt;) {
    search();
} &lt;/span&gt;&lt;span&gt;elseif&lt;/span&gt; (&lt;span&gt;$_SERVER&lt;/span&gt;[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;&lt;span&gt;){
    create();
}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建员工&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; create(){
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断信息是否填写完全  &lt;/span&gt;
  &lt;span&gt;$data&lt;/span&gt;=json_decode(&lt;span&gt;file_get_contents&lt;/span&gt;('php://input'),&lt;span&gt;true&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换成数组  &lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;$data&lt;/span&gt;[&quot;name&quot;] || !&lt;span&gt;$data&lt;/span&gt;[&quot;number&quot;]    || !&lt;span&gt;$data&lt;/span&gt;[&quot;sex&quot;]    || !&lt;span&gt;$data&lt;/span&gt;[&quot;job&quot;&lt;span&gt;]) {
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '{&quot;success&quot;:false,&quot;msg&quot;:&quot;参数错误，员工信息填写不全&quot;}'&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO: 获取POST表单数据并保存到数据库
      
    //提示保存成功&lt;/span&gt;
    &lt;span&gt;echo&lt;/span&gt; '{&quot;success&quot;:true,&quot;msg&quot;:&quot;员工：' . &lt;span&gt;$data&lt;/span&gt;[&quot;name&quot;] . ' 信息保存成功！&quot;}'&lt;span&gt;;
}
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1472670/201811/1472670-20181127193139193-806310643.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先是预检请求 ，使用 OPTION方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1472670/201811/1472670-20181127193056915-839979457.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后是正式请求，使用 POST方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1472670/201811/1472670-20181127194014179-1654812086.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 即：非简单请求分为 ，&quot;预检&quot;请求 + 简单请求。&lt;/p&gt;

&lt;div readability=&quot;43&quot;&gt;
&lt;p&gt;使用window.name+iframe来进行跨域：&lt;/p&gt;
&lt;p&gt;原理：&lt;/p&gt;
&lt;p&gt;通过浏览器的 window.name 属性实现跨域请求(每个浏览器窗口都有一个 window.name属性)&lt;/p&gt;
&lt;p&gt;原理：无论是否同源，只要在 “同一个窗口里”，前一个网页设置了这个属性，后一个网页就可以读取它,如页面 A中&lt;/p&gt;
&lt;p&gt;有一个 iframe,iframe.src指向页面 B,若页面 B设置了 window.name属性,那么页面 A中的那个 iframe就能获&lt;/p&gt;
&lt;p&gt;取到页面 B中的 window.name(虽然 A中的 iframe能读取到 B中的 window.name属性,但是由于iframe在页面 A中,&lt;/p&gt;
&lt;p&gt;而 iframe.src指向页面 B,浏览器会因为页面 A与 iframe不同源而阻止获取,因此还需要设置 iframe.src指向页面 A所在的域)&lt;/p&gt;
&lt;p&gt;用例：&lt;/p&gt;
&lt;p&gt;页面 a.html&lt;/p&gt;
&lt;div readability=&quot;64&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;ie=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 假设这个页面是域 www.aaa.com 下面的页面 A.html &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;a.html&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;domainA/a.html&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;btn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;get_data_by_iframe_window.name&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3 &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;data&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;      

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取按钮绑定事件，添加一个 iframe&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; btn&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    btn.onclick&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; ifr&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;document.createElement(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;iframe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟跨域请求&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a.html 在浏览器中打开的地址为: http://localhost/a.html&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; b.html 需要请求的页面地址为: http://127.0.0.1:80/b.html&lt;/span&gt;
&lt;span&gt;      ifr.src&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://127.0.0.1/b.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加 iframe到当前页面中,并设置为不可见&lt;/span&gt;
&lt;span&gt;      ifr.style.display &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; body&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;document.getElementsByTagName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
      body.appendChild(ifr);
      
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;iframe.src会触发 iframe.onload事件,因此使用标记来判断 iframe.src是否已经更改&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt;&lt;span&gt; flag&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      ifr.onload&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){                
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(flag){     
          flag&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;        
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为了不让浏览器阻止不同源获取window.name属性的值,这里需要设置 iframe与当前页面在同一个域&lt;/span&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(也可以指向其他页面,只要与创建当前 iframe的页面在同一个域都可以)&lt;/span&gt;
&lt;span&gt;          ifr.src&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost/a.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;contentWindow属性返回&amp;lt;iframe&amp;gt;元素的Window对象,由此获取 b.html页面中设置的 window.name属性的值&lt;/span&gt;
&lt;span&gt;          document.querySelector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).innerText&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;ifr.contentWindow.name;          
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取数据完成,删除 iframe&lt;/span&gt;
&lt;span&gt;          body.removeChild(ifr);   
        }
      }
    }    
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 假设当前页面为 domainA/p.html,里面有 iframe.src=domianA/a.html
     * 如果开始时候 iframe.src=domainB/b.html，后来 iframe.src=domianA/a.html时，
     * 那么必须是先执行完 iframe.src=domainB/b.html这就语句后面的代码后，iframe才会属于域 domainA,
     * 而在执行完 iframe.src=domainB/b.html这就语句后面的代码前，iframe依然属于域 domainB。
     *
     * 如：假设在页面 domainA/p.html中    属于域 domainA,iframe在 p.html中创建
     * 
     * 首先
     * iframe.src=domainB/b.html
     * 执行完其他代码             现在属于域 domainB
     * 
     * 然后
     * iframe.src=domianA/a.html 现在属于域 domainB
     * 执行完其他代码             现在属于域 domainA
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;页面 b.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;ie=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;b.html&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;b.html中设置 window.name的值(需要传输的数据)&lt;/span&gt;
&lt;span&gt;    window.name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是需要传输的数据,来自 domainB/b.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1472670/201811/1472670-20181128124916221-493033230.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;window.postMessage:跨文档通信 API（Cross-document messaging）&lt;/p&gt;
&lt;p&gt;原理：&lt;/p&gt;
&lt;div readability=&quot;44&quot;&gt;
&lt;p&gt;* HTML5为了解决跨域问题引入了一个全新的API：跨文档通信 API（Cross-document messaging）。&lt;/p&gt;
&lt;p&gt;* 这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。&lt;/p&gt;
&lt;p&gt;* 使用方法: otherWindow.postMessage(message, targetOrigin, [transfer]);&lt;/p&gt;
&lt;p&gt;* otherWindow:&lt;/p&gt;
&lt;p&gt;* 其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames&lt;/p&gt;
&lt;p&gt;* message:&lt;/p&gt;
&lt;p&gt;* 将要发送到其他 window的数据。&lt;/p&gt;
&lt;p&gt;* targetOrigin:&lt;/p&gt;
&lt;p&gt;* 通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串&quot;*&quot;（表示无限制）或者一个URI&lt;/p&gt;
&lt;p&gt;* 只有当目标窗口与 targetOrigin的源完全相同时消息才能被成功发送,只要协议、主机名、端口其中一项不同消息都不会被发送&lt;/p&gt;
&lt;p&gt;* (这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的origin属性完全一致，来防止密码被恶意的第三方截获)&lt;/p&gt;
&lt;p&gt;* [transfer]:&lt;/p&gt;
&lt;p&gt;* 是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。&lt;/p&gt;
&lt;p&gt;* 父窗口和子窗口都可以通过message事件，监听对方的消息。&lt;/p&gt;
&lt;p&gt;* message事件的事件对象event，提供以下三个属性。&lt;/p&gt;
&lt;p&gt;* event.source：记录调用 window.postMessage()方法的窗口信息&lt;/p&gt;
&lt;p&gt;* event.origin: 表示调用 window.postMessage()方法时,调用页面的当前状态&lt;/p&gt;
&lt;p&gt;* event.data: 要发送到其他 window的数据&lt;/p&gt;

&lt;p&gt;用例：&lt;/p&gt;
&lt;p&gt;页面 a.html&lt;/p&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;ie=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;a.html&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 本例中：模拟跨域
     * a.html :  http://localhost/a.html
     * b.html :  http://127.0.0.1/b.html
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    
      &lt;span&gt;var&lt;/span&gt;&lt;span&gt; popup&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;window.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://127.0.0.1/b.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title b.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; targetOrigin为:http://127.0.0.1 协议: http 主机名: 127.0.0.1 端口号: 默认(80) &lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; b.html中的域为:http://127.0.0.1 协议: http 主机名: 127.0.0.1 端口号: 默认(80) &lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可见目标窗口与 targetOrigin的源完全相同&lt;/span&gt;
&lt;span&gt;      popup.postMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aaaaaa 在a.html中 通过 postMessage 发送&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://127.0.0.1/b.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); 
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;监听子窗口信息&lt;/span&gt;
&lt;span&gt;    window.addEventListener(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;event.origin: 表示调用 window.postMessage()方法时,调用页面的当前状态&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在本例中,这里监听的是 b.html中 evnet.source.postMessage()事件,event.source.postMessage()的当前状态还是属于域 http://127.0.0.1&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(event.origin); //输出: http://127.0.0.1&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (event.origin &lt;/span&gt;&lt;span&gt;!==&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
      console.log(event.data);
    });

    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;页面 b.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;ie=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;b.html&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;监听父窗口信息&lt;/span&gt;
&lt;span&gt;    window.addEventListener(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){     
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;event.origin: 表示调用 window.postMessage()方法时,调用页面的当前状态&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在本例中,这里监听的是 a.html中 popup.postMessage()事件,popup.postMessage()的当前状态还是属于域 http://localhost&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(event.origin); //输出: http://localhost&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (event.origin &lt;/span&gt;&lt;span&gt;!==&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;      
      console.log(event.data);
      
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;event.source：记录调用 window.postMessage()方法的窗口信息&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在本例中,这里监听的是 a.html中 popup.postMessage()事件,因此这里 event.source记录的是 a.html页面窗口的信息&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; targetOrigin为:http:localhost 协议: http 主机名: localhost 端口号: 默认(80) &lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a.html中的域为:http:localhost 协议: http 主机名: localhost 端口号: 默认(80) &lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可见目标窗口与 targetOrigin的源完全相同&lt;/span&gt;
&lt;span&gt;      event.source.postMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bbbbbb 在b.html中 通过 postMessage 发送&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http:localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    });

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当然也可以使用 window.opener发送信息&lt;/span&gt;
&lt;span&gt;    window.opener.postMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bbbbbb 在b.html中 通过 window.opener.postMessage 发送&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http:localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1472670/201811/1472670-20181128212807560-757166556.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;跨子域:修改document.domain&lt;/p&gt;
&lt;p&gt;原理：两个文档上一层级的域名相同，下一层级(或该层级以下的域名不同)，将两个文档的 document.domain都修改为上一层级的域名(这样他们的 document.domain就一样了)&lt;/p&gt;
&lt;p&gt;用例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
      页面一 http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a.test.com/a.html  &lt;/span&gt;
        域为: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a.test.com&lt;/span&gt;
        设置该页面的 document.domain=&lt;span&gt;test.com  
        设置 document.cookie&lt;/span&gt;= &quot;hello=world&quot;&lt;span&gt;
      页面二 http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;b.test.com/b.html  &lt;/span&gt;
        域为: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;b.test.com&lt;/span&gt;
        设置该页面的 document.domain=&lt;span&gt;test.com  
        这里 console.log(document.cookie) 输出结果包含 &lt;/span&gt;&quot;hello=world&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过反向代理 （Reverse Proxy）&lt;/p&gt;
&lt;p&gt;原理：反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。跨域时，页面A 、页面 B不同域，但是页面 A与代理服务器在同一个域，页面 A将请求发送给代理服务器(同一个域)，由代理服务器到页面 B获取所需要的数据(跨域是浏览器阻止跨域，服务器不存在跨域问题)，然后代理服务器将获取的数据返回给页面 A(同一个域)&lt;/p&gt;
&lt;p&gt;用例：无&lt;/p&gt;

&lt;p&gt;WebSocket 跨域&lt;/p&gt;
&lt;p&gt;原理：WebSocket是一种通信协议，使用&lt;code&gt;ws://&lt;/code&gt;（非加密）和&lt;code&gt;wss://&lt;/code&gt;（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。&lt;/p&gt;
&lt;p&gt;用例：无&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;MDN 官网：https://developer.mozilla.org/&lt;/p&gt;
&lt;p&gt;阮一峰博客-浏览器同源政策及其规避方法：http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html&lt;/p&gt;
&lt;p&gt;阮一峰博客-跨域资源共享 CORS 详解：http://www.ruanyifeng.com/blog/2016/04/cors.html&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 28 Nov 2018 15:50:00 +0000</pubDate>
<dc:creator>guangzai</dc:creator>
<og:description>一、常见跨域方法 1） JSONP跨域 需要目标服务器配合一个callback函数2） AJAX跨域 CORS3） 使用window.name+iframe来进行跨域 4） window.postMe</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/go4it/p/10021551.html</dc:identifier>
</item>
<item>
<title>【ABP框架系列学习】启动配置(5) - 大龄Giser</title>
<link>http://www.cnblogs.com/OlderGiser/p/10035819.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/OlderGiser/p/10035819.html</guid>
<description>&lt;p&gt;ABP提供了在启动时配置模块的基础设施和模型。&lt;/p&gt;

&lt;p&gt;配置ABP是在模块的&lt;strong&gt;PreInitialize&lt;/strong&gt;方法中完成的，例如：&lt;/p&gt;

&lt;p&gt;ABP是基于模块设计的。不同的模块都可以配置ABP。例如：不同的模块可以添加导航提供者(navigation providers)往主菜单添加自定义子菜单。&lt;/p&gt;
&lt;h2&gt;替换内置(Built-In)服务&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Configuration.ReplaceService()&lt;/strong&gt;方法可以覆盖内置服务。例如，你可以用定义实现的类替换IAbpSession服务：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ReplaceService()&lt;/strong&gt;方法通过重载操作以定义方式实现替换(也可以直接使用Castle Windsor高级的注册API)。&lt;/p&gt;
&lt;p&gt;同一个服务可以多次被替换，尤其是在不同的模块间。生效的服务是最后被替换的那个。&lt;strong&gt;PreInitialize()&lt;/strong&gt;方法按依赖顺序执行。&lt;/p&gt;

&lt;p&gt;除了ABP框架自身的启动配置外，模块也可以通过扩展IAbpModuleConfigurations接口，为模块提供配置点。&lt;/p&gt;

&lt;p&gt;在上述代码中，配置AbpWebCommon模块把所有异常发送给客户端。&lt;/p&gt;
&lt;p&gt;不是每个模块都应该定义类似这种类型的配置，通常情况是在不同的应用程序中需要重复使用的才定义，并且要在启动时进行配置。&lt;/p&gt;

&lt;p&gt;假设我们有一个叫MyModule的模块，它带有一些配置属性。首先，为这些配置属性创建一个类：&lt;/p&gt;

&lt;p&gt;然后在PreInitialize方法中通过DI(Dependency Injection)注册这个类(因此，MyModuleConfig是可注册的类)：&lt;/p&gt;

&lt;p&gt;像本事例那样注册为单例对象。那么，我们可以使用如下代码在PreInitialize方法中配置MyModule模块：&lt;/p&gt;

&lt;p&gt;然而我们可以类似如下代码，通过创建IModuleConfigurations扩展方法，使用IAbpStartupConfiguration.Get()方法获得引用：&lt;/p&gt;

&lt;p&gt;那么，其它模块可以通过扩展方法配置MyModule模块：&lt;/p&gt;

&lt;p&gt;这使得查询模块配置和收集它们变得容易(Configuration.Modules...)。ABP本身为它自己的模块配置定义了扩展方法。&lt;/p&gt;
&lt;p&gt;在某些地方，MyModule模块需要这些配置，你可以通过构造函数注入并使用配置值。如下：&lt;/p&gt;

&lt;p&gt;这样，在ABP系统中，模块可以创建集中配置的点。&lt;/p&gt;
</description>
<pubDate>Wed, 28 Nov 2018 15:49:00 +0000</pubDate>
<dc:creator>大龄Giser</dc:creator>
<og:description>ABP提供了在启动时配置模块的基础设施和模型。 1.配置ABP 配置ABP是在模块的PreInitialize方法中完成的，例如： public class SimpleTaskSystemModul</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/OlderGiser/p/10035819.html</dc:identifier>
</item>
<item>
<title>补习系列(13)-springboot redis 与发布订阅 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/10035786.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/10035786.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;一订阅发布&quot;&gt;一、订阅发布&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;订阅发布&lt;/strong&gt;是一种常见的设计模式，常见于消息系统的场景。&lt;br/&gt;如下面的图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201811/242916-20181128233806987-440877065.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;[图来自百科]&lt;br/&gt;消息发布者是消息载体的生产者，其通过某些主题来向&lt;strong&gt;调度中心&lt;/strong&gt;发送消息；&lt;br/&gt;而消息订阅者会事先向&lt;strong&gt;调度中心&lt;/strong&gt;订阅其&lt;strong&gt;&quot;感兴趣&quot;&lt;/strong&gt;的主题，随后会获得新消息。&lt;br/&gt;在这里，&lt;strong&gt;调度中心&lt;/strong&gt;是一个负责消息控制中转的逻辑实体，可以是消息队列如ActiveMQ，也可以是Web服务等等。&lt;/p&gt;
&lt;h3 id=&quot;常见应用&quot;&gt;常见应用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;微博，每个用户的粉丝都是该用户的订阅者，当用户发完微博，所有粉丝都将收到他的动态；&lt;/li&gt;
&lt;li&gt;新闻，资讯站点通常有多个频道，每个频道就是一个主题，用户可以通过主题来做订阅(如RSS)，这样当新闻发布时，订阅者可以获得更新。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二redis-与订阅发布&quot;&gt;二、Redis 与订阅发布&lt;/h2&gt;
&lt;p&gt;Redis 支持 (pub/sub) 的订阅发布能力，客户端可以通过channel(频道)来实现消息的发布及接收。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端通过 SUBSCRIBE 命令订阅 channel；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201811/242916-20181128233829563-1376860022.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端通过PUBLISH 命令向channel 发送消息；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201811/242916-20181128233841819-2136859731.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而后，订阅 channel的客户端可实时收到消息。&lt;/p&gt;
&lt;p&gt;除了简单的SUBSCRIBE/PUBLISH命令之外，Redis还支持订阅某一个模式的主题(正则表达式)，&lt;br/&gt;如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PSUBSCRIBE  /topic/cars/*&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;于是，我们可以利用这点实现相对复杂的订阅能力，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在电商平台中订阅多个品类的商品促销信息；&lt;/li&gt;
&lt;li&gt;智能家居场景，APP可以订阅所有房间的设备消息。&lt;br/&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;尽管如此，Redis pub/sub 机制存在一些缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;消息无法持久化，存在丢失风险；&lt;/li&gt;
&lt;li&gt;没有类似 RabbitMQ的ACK机制；&lt;/li&gt;
&lt;li&gt;由于是广播机制，无法通过添加worker 提升消费能力；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，Redis 的订阅发布建议用于&lt;strong&gt;&lt;em&gt;实时且可靠性要求不高&lt;/em&gt;&lt;/strong&gt;的场景。&lt;/p&gt;
&lt;h2 id=&quot;三springboot-与订阅发布&quot;&gt;三、SpringBoot 与订阅发布&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;接下来，看一下SpringBoot 怎么实现订阅发布的功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;spring-boot-starter-data-redis&lt;/strong&gt; 帮我们实现了Jedis的引入，pom 依赖如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;!-- redis --&amp;gt;
  &amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;${spring-boot.version}&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;strong&gt;&lt;em&gt;application.properties&lt;/em&gt;&lt;/strong&gt; 中指定配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# redis 连接配置
spring.redis.database=0 
spring.redis.host=127.0.0.1
spring.redis.password=
spring.redis.port=6379
spring.redis.ssl=false

# 连接池最大数
spring.redis.pool.max-active=10 
# 空闲连接最大数
spring.redis.pool.max-idle=10
# 获取连接最大等待时间(s)
spring.redis.pool.max-wait=600000&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;a.-消息模型&quot;&gt;A. 消息模型&lt;/h3&gt;
&lt;p&gt;消息模型描述了订阅发布的数据对象，这要求生产者与消费者都能理解&lt;br/&gt;以下面的POJO为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static class SimpleMessage {

        private String publisher;
        private String content;
        private Date createTime;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在SimpleMessage类中，我们声明了几个字段：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;publisher&lt;/td&gt;
&lt;td&gt;发布者&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;content&lt;/td&gt;
&lt;td&gt;文本内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;createTime&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;b.-序列化&quot;&gt;B. 序列化&lt;/h3&gt;
&lt;p&gt;如下的代码采用了JSON 作为序列化方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class RedisConfig {

    private static final Logger logger = LoggerFactory.getLogger(RedisConfig.class);

    /**
     * 序列化定制
     * 
     * @return
     */
    @Bean
    public Jackson2JsonRedisSerializer&amp;lt;Object&amp;gt; jackson2JsonSerializer() {
        Jackson2JsonRedisSerializer&amp;lt;Object&amp;gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&amp;lt;&amp;gt;(
                Object.class);

        // 初始化objectmapper
        ObjectMapper mapper = new ObjectMapper();
        mapper.setSerializationInclusion(Include.NON_NULL);
        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(mapper);
        return jackson2JsonRedisSerializer;
    }

    /**
     * 操作模板
     * 
     * @param connectionFactory
     * @param jackson2JsonRedisSerializer
     * @return
     */
    @Bean
    public RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate(JedisConnectionFactory connectionFactory,
            Jackson2JsonRedisSerializer&amp;lt;Object&amp;gt; jackson2JsonRedisSerializer) {

        RedisTemplate&amp;lt;String, Object&amp;gt; template = new RedisTemplate&amp;lt;String, Object&amp;gt;();
        template.setConnectionFactory(connectionFactory);

        // 设置key/hashkey序列化
        RedisSerializer&amp;lt;String&amp;gt; stringSerializer = new StringRedisSerializer();
        template.setKeySerializer(stringSerializer);
        template.setHashKeySerializer(stringSerializer);

        // 设置值序列化
        template.setValueSerializer(jackson2JsonRedisSerializer);
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();

        return template;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;c.-发布消息&quot;&gt;C. 发布消息&lt;/h3&gt;
&lt;p&gt;消息发布，需要先指定一个ChannelTopic对象，随后通过RedisTemplate方法操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Service
public class RedisPubSub {  
    private static final Logger logger = LoggerFactory.getLogger(RedisPubSub.class);

    @Autowired
    private RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate;

    private ChannelTopic topic = new ChannelTopic(&quot;/redis/pubsub&quot;);

  
    @Scheduled(initialDelay = 5000, fixedDelay = 10000)
    private void schedule() {
        logger.info(&quot;publish message&quot;);
        publish(&quot;admin&quot;, &quot;hey you must go now!&quot;);
    }

    /**
     * 推送消息
     * 
     * @param publisher
     * @param message
     */
    public void publish(String publisher, String content) {
        logger.info(&quot;message send {} by {}&quot;, content, publisher);

        SimpleMessage pushMsg = new SimpleMessage();
        pushMsg.setContent(content);
        pushMsg.setCreateTime(new Date());
        pushMsg.setPublisher(publisher);

        redisTemplate.convertAndSend(topic.getTopic(), pushMsg);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码使用一个定时器(@Schedule)来做发布，为了保证运行需要在主类中启用定时器注解：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@EnableScheduling
@SpringBootApplication
public class BootSampleRedis{
...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;d.-接收消息&quot;&gt;D. 接收消息&lt;/h3&gt;
&lt;p&gt;定义一个消息接收处理的Bean：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Component
    public static class MessageSubscriber {

        public void onMessage(SimpleMessage message, String pattern) {
            logger.info(&quot;topic {} received {} &quot;, pattern, JsonUtil.toJson(message));
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，利用 MessageListenerAdapter 可将消息通知到Bean方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;       /**
         * 消息监听器，使用MessageAdapter可实现自动化解码及方法代理
         * 
         * @return
         */
        @Bean
        public MessageListenerAdapter listener(Jackson2JsonRedisSerializer&amp;lt;Object&amp;gt; jackson2JsonRedisSerializer,
                MessageSubscriber subscriber) {
            MessageListenerAdapter adapter = new MessageListenerAdapter(subscriber, &quot;onMessage&quot;);
            adapter.setSerializer(jackson2JsonRedisSerializer);
            adapter.afterPropertiesSet();
            return adapter;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，关联到消息发布的Topic：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        /**
         * 将订阅器绑定到容器
         * 
         * @param connectionFactory
         * @param listenerAdapter
         * @return
         */
        @Bean
        public RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory,
                MessageListenerAdapter listener) {

            RedisMessageListenerContainer container = new RedisMessageListenerContainer();
            container.setConnectionFactory(connectionFactory);
            container.addMessageListener(listener, new PatternTopic(&quot;/redis/*&quot;));
            return container;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;运行结果&lt;/strong&gt;&lt;br/&gt;启动程序，从控制台可输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.RedisPubSub : publish message
.RedisPubSub : message send hey you must go now! by admin
.RedisPubSub : topic /redis/* received {&quot;publisher&quot;:&quot;admin&quot;,&quot;content&quot;:&quot;hey you must go now!&quot;,&quot;createTime&quot;:1543418694007} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，我们便完成了订阅发布功能。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/littleatp/springboot-samples/tree/master/springboot-samples/springboot-redis&quot;&gt;示例程序下载&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;消息订阅发布是分布式系统中的常用手段，也经常用来实现系统解耦、性能优化等目的；&lt;br/&gt;当前小节结合SpringBoot 演示了 Redis订阅发布(pub/sub)的实现，在部分场景下可以参考使用。&lt;br/&gt;欢迎继续关注&quot;美码师的补习系列-springboot篇&quot; ，期待更多精彩内容^-^&lt;/p&gt;
</description>
<pubDate>Wed, 28 Nov 2018 15:39:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>[TOC] 一、订阅发布 订阅发布 是一种常见的设计模式，常见于消息系统的场景。 如下面的图： [图来自百科] 消息发布者是消息载体的生产者，其通过某些主题来向 调度中心 发送消息； 而消息订阅者会事</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/10035786.html</dc:identifier>
</item>
<item>
<title>eShopOnContainers 知多少[4]：Catalog microservice - 『圣杰』</title>
<link>http://www.cnblogs.com/sheng-jie/p/10035771.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sheng-jie/p/10035771.html</guid>
<description>&lt;p&gt;Catalog microservice（目录微服务）维护着所有产品信息，包括库存、价格。所以该微服务的核心业务为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;产品信息的维护&lt;/li&gt;
&lt;li&gt;库存的更新&lt;/li&gt;
&lt;li&gt;价格的维护&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-8ee92fc413d17822.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;数据驱动/CRUD 微服务设计&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，本微服务采用简单的数据驱动的CRUD微服务架构，来执行产品信息的创建、读取、更新和删除（CRUD）操作。&lt;br/&gt;这种类型的服务在单个 ASP.NET Core Web API 项目中即可实现所有功能，该项目包括数据模型类、业务逻辑类及其数据访问类。其项目结构如下：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-2283cbfdcc9a7271.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;核心技术选型：&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;ASP.NET Core Web API&lt;/li&gt;
&lt;li&gt;Entity Framework Core&lt;/li&gt;
&lt;li&gt;SQL Server&lt;/li&gt;
&lt;li&gt;Swashbuckle（可选）&lt;/li&gt;
&lt;li&gt;Autofac&lt;/li&gt;
&lt;li&gt;Eventbus&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Polly&lt;/p&gt;

&lt;p&gt;该微服务的核心领域实体是商品，其类图如下：&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-0ffd78f8c096b32d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于实体这一块，有两个小知识点需要说明一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进行数据库字段映射时，主键都使用了&lt;code&gt;ForSqlServerUseSequenceHiLo&lt;/code&gt;指定使用&lt;code&gt;HI-LO&lt;/code&gt;高低位序列进行主键生成。&lt;/li&gt;
&lt;li&gt;使用NoTracking提升查询速度&lt;br/&gt;在&lt;code&gt;CatalogController&lt;/code&gt;的构造方法中，明确指定以下代码来进行查询优化，这一点也是我们值得学习的地方。&lt;code&gt;((DbContext)context).ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在进行种子数据的预置时，使用了&lt;code&gt;Polly&lt;/code&gt;开启了Retry机制。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;private Policy CreatePolicy( ILogger&amp;lt;CatalogContextSeed&amp;gt; logger, string prefix,int retries = 3)
{
    return Policy.Handle&amp;lt;SqlException&amp;gt;().
        WaitAndRetryAsync(
            retryCount: retries,
            sleepDurationProvider: retry =&amp;gt; TimeSpan.FromSeconds(5),
            onRetry: (exception, timeSpan, retry, ctx) =&amp;gt;
            {
                logger.LogTrace($&quot;[{prefix}] Exception {exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {retries}&quot;);
            }
        );
}
public async Task SeedAsync(CatalogContext context,IHostingEnvironment env,IOptions&amp;lt;CatalogSettings&amp;gt; settings,ILogger&amp;lt;CatalogContextSeed&amp;gt; logger)
{
    var policy = CreatePolicy(logger, nameof(CatalogContextSeed));

    await policy.ExecuteAsync(async () =&amp;gt;
    {
        //...
    });       
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-fda90fdfdbaec4bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;CatalogDb&quot;/&gt;&lt;br/&gt;你肯定会好奇为什么会多了一张&lt;code&gt;IntegrationEventLog&lt;/code&gt;表，这里先按住不表。&lt;/p&gt;

&lt;p&gt;如果eShopOnContainers采用的是单体式应用架构而非微服务架构，那么以上业务逻辑的实现并不复杂，使用简单的CRUD再辅以ACID事务就能很好的完成业务需求。本文的介绍也就可以到此为止了。&lt;/p&gt;
&lt;p&gt;然而将其抽取出来成为独立的基础微服务，那么我们要考虑的问题就多了。比如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;修改产品价格时，需要同步更新购物车中保存的产品信息的价格。&lt;/li&gt;
&lt;li&gt;下订单时，需要验证当前商品库存是否充足，进行锁库抢占，以避免库存不足导致的订单无效。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;而这一切我们都不能再享受单体应用中直接使用ACID事务的便利了。因为在微服务应用里，产品表和购物篮表被各自的微服务所占有。任何微服务不应该在自己的事务中包含其他微服务的表或存储，即使是直接查询也是不可以的。目录微服务不能直接更新购物篮表，因为购物篮表被购物篮微服务占有。要更新购物篮微服务，产品微服务应该使用基于异步通信，如集成事件（消息和基于事件的通信）来实现最终一致性。&lt;/p&gt;
&lt;p&gt;那下一节我们就来详细阐述eShopOnContainers是如何通过事件机制完成最终一致性的。&lt;/p&gt;
</description>
<pubDate>Wed, 28 Nov 2018 15:36:00 +0000</pubDate>
<dc:creator>『圣杰』</dc:creator>
<og:description>引言 Catalog microservice（目录微服务）维护着所有产品信息，包括库存、价格。所以该微服务的核心业务为： 1. 产品信息的维护 2. 库存的更新 3. 价格的维护 架构模式 如上图所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sheng-jie/p/10035771.html</dc:identifier>
</item>
<item>
<title>Go标准库：深入剖析Go template - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10035768.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10035768.html</guid>
<description>&lt;p&gt;本文只关注Go text/template的底层结构，带上了很详细的图片以及示例帮助理解，有些地方也附带上了源码进行解释。有了本文的解释，对于Go template的语法以及html/template的用法，一切都很简单。&lt;/p&gt;
&lt;h2 id=&quot;入门示例&quot;&gt;入门示例&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;html/template&quot;
    &quot;os&quot;
)

type Person struct {
    Name string
    Age    int
}

func main() {
    p := Person{&quot;longshuai&quot;, 23}
    tmpl, err := template.New(&quot;test&quot;).Parse(&quot;Name: {{.Name}}, Age: {{.Age}}&quot;)
    if err != nil {
        panic(err)
    }
    err = tmpl.Execute(os.Stdout, p)
    if err != nil {
        panic(err)
    }
    fmt.Println(tmpl)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面定义了一个Person结构，有两个&lt;strong&gt;大写字母开头&lt;/strong&gt;(意味着这俩字段是导出的)的字段Name和Age。然后main()中创建了Person的实例对象p。&lt;/p&gt;
&lt;p&gt;紧接着使用template.New()函数创建了一个空Template实例(对象)，然后通过这个template实例调用Parse()方法，Parse()方法用来解析、评估模板中需要执行的action，其中需要评估的部分都使用&lt;code&gt;{{}}&lt;/code&gt;包围，并将评估后(解析后)的结果赋值给tmpl。&lt;/p&gt;
&lt;p&gt;最后调用Execute()方法，该方法将数据对象Person的实例p应用到已经解析的tmpl模板，最后将整个应用合并后的结果输出到os.Stdout。&lt;/p&gt;
&lt;p&gt;上面的示例很简单，两个注意点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;流程：构建模板对象New()--&amp;gt;解析数据Parse()--&amp;gt;应用合并Execute()&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Parse()解析的对象中包含了&lt;code&gt;{{}}&lt;/code&gt;，其中使用了点(.)，&lt;code&gt;{{.Name}}&lt;/code&gt;代表Execute()第二个参数p对象的Name字段，同理&lt;code&gt;{{.Age}}&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;也就是说，&lt;code&gt;{{.}}&lt;/code&gt;代表的是要应用的对象，类似于java/c++中的this，python/perl中的self。&lt;/p&gt;
&lt;p&gt;更通用地，&lt;code&gt;{{.}}&lt;/code&gt;表示的是所处作用域的当前对象，而不仅仅只代表Execute()中的第二个参数对象。例如，本示例中&lt;code&gt;{{.}}&lt;/code&gt;代表顶级作用域的对象p，如果Parse()中还有嵌套的作用域range，则&lt;code&gt;{{.}}&lt;/code&gt;代表range迭代到的每个元素对象。如果了解perl语言，&lt;code&gt;{{.}}&lt;/code&gt;可以理解为默认变量&lt;code&gt;$_&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;模板关联associate&quot;&gt;模板关联(associate)&lt;/h2&gt;
&lt;p&gt;template中有不少函数、方法都直接返回&lt;code&gt;*Template&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181128115459994-1350629608.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中使用红色框线框起来一部分返回值是&lt;code&gt;*Template&lt;/code&gt;的函数、方法。对于函数，它们返回一个Template实例(假设为t)，对于使用t作为参数的Must()函数和那些框起来的Template方法，它们返回的&lt;code&gt;*Template&lt;/code&gt;&lt;strong&gt;其实是原始实例t&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;t := template.New(&quot;abc&quot;)
tt,err := t.Parse(&quot;xxxxxxxxxxx&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的t和tt其实都指向同一个模板对象。&lt;/p&gt;
&lt;p&gt;这里的&lt;strong&gt;t称为模板的关联名称&lt;/strong&gt;。通俗一点，就是创建了一个模板，关联到变量t上。但&lt;strong&gt;注意，t不是模板的名称，因为Template中有一个未导出的name字段，它才是模板的名称&lt;/strong&gt;。可以通过Name()方法返回name字段的值，而且仔细观察上面的函数、方法，有些是以name作为参数的。&lt;/p&gt;
&lt;p&gt;之所以要区分模板的关联名称(t)和模板的名称(name)，是因为&lt;strong&gt;一个关联名称t(即模板对象)上可以&quot;包含&quot;多个name，也就是多个模板，通过t和各自的name，可以调用到指定的模板&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;模板结构详解&quot;&gt;模板结构详解&lt;/h2&gt;
&lt;p&gt;首先看Template结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type Template struct {
    name string
    *parse.Tree
    *common
    leftDelim  string
    rightDelim string
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;name是这个Template的名称，Tree是解析树，common是另一个结构，稍后解释。leftDelim和rightDelim是左右两边的分隔符，默认为&lt;code&gt;{{&lt;/code&gt;和&lt;code&gt;}}&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里主要关注name和common两个字段，name字段没什么解释的。common是一个结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type common struct {
    tmpl   map[string]*Template // Map from name to defined templates.
    option option
    muFuncs    sync.RWMutex // protects parseFuncs and execFuncs
    parseFuncs FuncMap
    execFuncs  map[string]reflect.Value
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个结构的第一个字段tmpl是一个Template的map结构，key为template的name，value为Template。也就是说，一个common结构中可以包含多个Template，而Template结构中又指向了一个common结构。所以，common是一个模板组，在这个模板组中的(tmpl字段)所有Template都共享一个common(模板组)，模板组中包含parseFuncs和execFuncs。&lt;/p&gt;
&lt;p&gt;大概结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181128144435142-440659768.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了需要关注的name和common，parseFuncs和execFuncs这两个字段也需要了解下，它们共同成为模板的FuncMap。&lt;/p&gt;
&lt;h3 id=&quot;new函数和init方法&quot;&gt;New()函数和init()方法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用template.New()函数可以创建一个空的、无解析数据的模板，同时还会创建一个common，也就是模板组&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func New(name string) *Template {
    t := &amp;amp;Template{
        name: name,
    }
    t.init()
    return t
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中t为模板的关联名称，name为模板的名称，t.init()表示如果模板对象t还没有common结构，就构造一个新的common组：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (t *Template) init() {
    if t.common == nil {
        c := new(common)
        c.tmpl = make(map[string]*Template)
        c.parseFuncs = make(FuncMap)
        c.execFuncs = make(map[string]reflect.Value)
        t.common = c
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，&lt;strong&gt;template.New()函数不仅创建了一个模板，还创建了一个空的common结构(模板组)。需要注意，新创建的common是空的，只有进行模板解析(Parse()，ParseFiles()等操作)之后，才会将模板添加到common的tmpl字段(map结构)中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以，下面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tmpl := template.New(&quot;mytmpl1&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完后将生成如下结构，其中tmpl为模板关联名称，mytmpl1为模板名称。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181128161909028-1756603346.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为还没有进行解析操作，所以上图使用虚线表示尚不存在的部分。&lt;/p&gt;
&lt;p&gt;实际上，在template包中，很多涉及到操作Template的函数、方法，都会调用init()方法保证返回的Template都有一个有效的common结构。当然，因为init()方法中进行了判断，对于已存在common的模板，不会新建common结构。&lt;/p&gt;
&lt;p&gt;假设现在执行了Parse()方法，将会把模板name添加到common tmpl字段的map结构中，其中模板name为map的key，模板为map的value。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    t1 := template.New(&quot;test1&quot;)
    tmpl,_ := t1.Parse(
            `{{define &quot;T1&quot;}}ONE{{end}}
            {{define &quot;T2&quot;}}TWO{{end}}
            {{define &quot;T3&quot;}}{{template &quot;T1&quot;}} {{template &quot;T2&quot;}}{{end}}
            {{template &quot;T3&quot;}}`)
    fmt.Println(t1)
    fmt.Println(tmpl)
    fmt.Println(t1.Lookup(&quot;test1&quot;))  // 使用关联名称t1检索test1模板
    fmt.Println(t1.Lookup(&quot;T1&quot;))
    fmt.Println(tmpl.Lookup(&quot;T2&quot;)) // 使用关联名称tmpl检索T2模板
    fmt.Println(tmpl.Lookup(&quot;T3&quot;))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码的执行结果：注意前3行的结果完全一致，所有行的第二个地址完全相同。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;amp;{test1 0xc0420a6000 0xc0420640c0  }
&amp;amp;{test1 0xc0420a6000 0xc0420640c0  }
&amp;amp;{test1 0xc0420a6000 0xc0420640c0  }
&amp;amp;{T1 0xc0420a6100 0xc0420640c0  }
&amp;amp;{T2 0xc0420a6200 0xc0420640c0  }
&amp;amp;{T3 0xc0420a6300 0xc0420640c0  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先使用template.New()函数创建了一个名为test1的模板，同时创建了一个模板组(common)，它们关联在t1变量上。&lt;/p&gt;
&lt;p&gt;然后调用Parse()方法，在Parse()的待解析字符串中使用define又定义了3个新的模板对象，模板的name分别为T1、T2和T3，其中T1和T2嵌套在T3中，因为调用的是t1的Parse()，所以这3个新创建的模板都会关联到t1上。&lt;/p&gt;
&lt;p&gt;也就是说，现在t1上关联了4个模板：test1、T1、T2、T3，它们全都共享同一个common。因为已经执行了Parse()解析操作，这个Parse()会将test1、T1、T2、T3的name添加到common.tmpl的map中。也就是说，common的tmpl字段的map结构中有4个元素。&lt;/p&gt;
&lt;p&gt;结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181128171511862-2078777047.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;必须注意，虽然test1、T1、T2、T3都关联在t1上，但t1只能代表test1(所以上图中只有test1下面标注了t1)，因为t1是一个Template类型。可以认为test1、T1、T2、T3这4个模板共享一个组，但T1、T2、T3都是对外部不可见的，只能通过特殊方法的查询找到它们。&lt;/p&gt;
&lt;p&gt;另外，前文说过，template包中很多返回&lt;code&gt;*Template&lt;/code&gt;的函数、方法返回的其实是原始的t(看源代码即可知道)，这个规则也适用于这里的Parse()方法，所以tmpl和t1这两个变量是完全等价的，都指向同一个template，即test1。所以前面的执行结果中前3行完全一致。&lt;/p&gt;
&lt;p&gt;再回头看上面代码的执行结果，假设结果中的每一行都分为3列，&lt;strong&gt;第一列为template name，第二个字段为parseTree的地址，第三列为common结构的地址&lt;/strong&gt;。因为tmpl1、t1都指向test1模板，所以前3行结果完全一致。因为test1、T1、T2、T3共享同一个common，所以第三列全都相同。因为每个模板的解析树不一样，所以第二列全都不一样。&lt;/p&gt;
&lt;h3 id=&quot;new方法&quot;&gt;New()方法&lt;/h3&gt;
&lt;p&gt;除了template.New()函数，还有一个Template.New()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// New allocates a new, undefined template associated with the given one and with the same
// delimiters. The association, which is transitive, allows one template to
// invoke another with a {{template}} action.
func (t *Template) New(name string) *Template {
    t.init()
    nt := &amp;amp;Template{
        name:       name,
        common:     t.common,
        leftDelim:  t.leftDelim,
        rightDelim: t.rightDelim,
    }
    return nt
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看注释很难理解，但是看它的代码，结合前文的解释，New()方法的作用很明显。&lt;/p&gt;
&lt;p&gt;首先t.init()保证有一个有效的common结构，然后构造一个新的Template对象nt，这个nt除了name和解析树parse.Tree字段之外，其它所有内容都和t完全一致。换句话说，nt和t共享了common。&lt;/p&gt;
&lt;p&gt;也就是说，New()方法使得名为name的nt模板对象加入到了关联组中。更通俗一点，&lt;strong&gt;通过调用&lt;code&gt;t.New()&lt;/code&gt;方法，可以创建一个新的名为name的模板对象，并将此对象加入到t模板组中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这和New()函数的作用基本是一致的，只不过New()函数是构建新的模板对象并构建一个新的common结构，而New()方法则是构建一个新的模板对象，并加入到已有的common结构中。&lt;/p&gt;
&lt;p&gt;只是还是要说明，因为New()出来的新对象在执行解析之前(如Parse())，它们暂时都还不会加入到common组中，在New()出来之后，仅仅只是让它指向已有的一个common结构。&lt;/p&gt;
&lt;p&gt;所以：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;t1 := template.New(&quot;test1&quot;)
t1 = t1.Parse(...)
t2 := t1.New(&quot;test2&quot;)
t2 = t2.Parse(...)
t3 := t1.New(&quot;test3&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181128195700011-1903510599.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果t1和t2的Parse()中，都定义一个或多个name相同的模板会如何？例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;t1 := template.New(&quot;test1&quot;)
t2 := t1.New(&quot;test2&quot;)
t1, _ = t1.Parse(
    `{{define &quot;T1&quot;}}ONE{{end}}
    {{define &quot;T2&quot;}}TWO{{end}}
    {{define &quot;T3&quot;}}{{template &quot;T1&quot;}} {{template &quot;T2&quot;}}{{end}}
    {{template &quot;T3&quot;}}`)
t2, _ = t2.Parse(
    `{{define &quot;T4&quot;}}ONE{{end}}
    {{define &quot;T2&quot;}}TWOO{{end}}
    {{define &quot;T3&quot;}}{{template &quot;T4&quot;}} {{template &quot;T2&quot;}}{{end}}
    {{template &quot;T3&quot;}}`)

    _ = t1.Execute(os.Stdout, &quot;a&quot;)
    _ = t2.Execute(os.Stdout, &quot;a&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的t1和t2中，它们共享同一个common，且t1.Parse()中定义了T1、T2和T3，t2.Parse()中定义了T4、T2和T3，且两个T2的解析内容不一样(解析树不一样)。&lt;/p&gt;
&lt;p&gt;因为T1、T2、T3、T4都会加入到t1和t2共享的common中，所以无论是通过t1还是通过t2这两个关联名称都能找到T1、T2、T3、T4。但是后解析的会覆盖先解析的，也就是说，无论是&lt;code&gt;t1.Lookup(&quot;T2&quot;)&lt;/code&gt;还是&lt;code&gt;t2.Lookup(&quot;T2&quot;)&lt;/code&gt;得到的T2对应的template，都是在t2.Parse()中定义的。当&lt;code&gt;t1.Execute()&lt;/code&gt;的时候，会得到t2中定义的T2的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ONE TWOO
ONE TWOO&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;parse&quot;&gt;Parse()&lt;/h2&gt;
&lt;p&gt;Parse(string)方法用于解析给定的文本内容string。用法上很简单，前面也已经用过几次了，没什么可解释的。重点在于它的作用。&lt;/p&gt;
&lt;p&gt;当创建了一个模板对象后，会有一个与之关联的common(如果不存在，template包中的各种函数、方法都会因为调用init()方法而保证common的存在)。&lt;strong&gt;只有在Parse()之后，才会将相关的template name放进common中，表示这个模板已经可用了，或者称为已经定义了(defined)，可用被Execute()或ExecuteTemplate()，也表示可用使用Lookup()和DefinedTemplates()来检索模板&lt;/strong&gt;。另外，调用了Parse()解析后，会将给定的FuncMap中的函数添加到common的FuncMap中，只有添加到common的函数，才可以在模板中使用。&lt;/p&gt;
&lt;p&gt;Parse()方法是解析字符串的，且只解析New()出来的模板对象。如果想要解析文件中的内容，见后文ParseFiles()、ParseGlob()。&lt;/p&gt;
&lt;h2 id=&quot;lookupdefinedtemplates和templates方法&quot;&gt;Lookup()、DefinedTemplates()和Templates()方法&lt;/h2&gt;
&lt;p&gt;这三个方法都用于检索已经定义的模板，Lookup()根据template name来检索并返回对应的template，DefinedTemplates()则是返回所有已定义的templates。Templates()和DefinedTemplates()类似，但是它返回的是&lt;code&gt;[]*Template&lt;/code&gt;，也就是已定义的template的slice。&lt;/p&gt;
&lt;p&gt;前面多次说过，只有在解析之后，模板才加入到common结构中，才算是已经定义，才能被检索或执行。&lt;/p&gt;
&lt;p&gt;当检索不存在的templates时，Lookup()将返回nil。当common中没有模板，DefinedTemplates()将返回空字符串&quot;&quot;，Templates()将返回空的slice。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    t1 := template.New(&quot;test1&quot;)
    t2 := t1.New(&quot;test2&quot;)
    t1, _ = t1.Parse(
        `{{define &quot;T1&quot;}}ONE{{end}}
        {{define &quot;T2&quot;}}TWO{{end}}
        {{define &quot;T3&quot;}}{{template &quot;T1&quot;}} {{template &quot;T2&quot;}}{{end}}
        {{template &quot;T3&quot;}}`)
    t2, _ = t2.Parse(
        `{{define &quot;T4&quot;}}ONE{{end}}
        {{define &quot;T2&quot;}}TWOO{{end}}
        {{define &quot;T3&quot;}}{{template &quot;T4&quot;}} {{template &quot;T2&quot;}}{{end}}
        {{template &quot;T3&quot;}}`)

    fmt.Println(t1.DefinedTemplates())
    fmt.Println(t2.DefinedTemplates())
    fmt.Println(t2.Templates())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;; defined templates are: &quot;T1&quot;, &quot;T2&quot;, &quot;T3&quot;, &quot;test1&quot;, &quot;T4&quot;, &quot;test2&quot;
; defined templates are: &quot;test1&quot;, &quot;T4&quot;, &quot;test2&quot;, &quot;T1&quot;, &quot;T2&quot;, &quot;T3&quot;
[0xc04201c280 0xc042064100 0xc04201c1c0 0xc04201c2c0 0xc04201c300 0xc042064080]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从结果可见，返回的顺序虽然不一致，但包含的template name是完全一致的。&lt;/p&gt;
&lt;h2 id=&quot;clone方法&quot;&gt;Clone()方法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Clone()&lt;/code&gt;方法用于克隆一个完全一样的模板，包括&lt;strong&gt;common结构也会完全克隆&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;t1 := template.New(&quot;test1&quot;)
t1 = t1.Parse(...)
t2 := t1.New(&quot;test2&quot;)
t2 = t2.Parse(...)

t3, err := t1.Clone()
if err != nil {
    panic(err)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的t3和t1在内容上完全一致，但在内存中它们是两个不同的对象。但无论如何，目前t3中会包含t1和t2共享的common，即使t2中定义了&lt;code&gt;{{define &quot;Tx&quot;}}...{{end}}&lt;/code&gt;，这个Tx也会包含在t3中。&lt;/p&gt;
&lt;p&gt;因为是不同的对象，所以修改t3，不会影响t1/t2。&lt;/p&gt;
&lt;p&gt;看下面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    t1 := template.New(&quot;test1&quot;)
    t2 := t1.New(&quot;test2&quot;)
    t1, _ = t1.Parse(
        `{{define &quot;T1&quot;}}ONE{{end}}
        {{define &quot;T2&quot;}}TWO{{end}}
        {{define &quot;T3&quot;}}{{template &quot;T1&quot;}} {{template &quot;T2&quot;}}{{end}}
        {{template &quot;T3&quot;}}`)
    t2, _ = t2.Parse(
        `{{define &quot;T4&quot;}}ONE{{end}}
        {{define &quot;T2&quot;}}TWOO{{end}}
        {{define &quot;T3&quot;}}{{template &quot;T4&quot;}} {{template &quot;T2&quot;}}{{end}}
        {{template &quot;T3&quot;}}`)

    t3, err := t1.Clone()
    if err != nil {
        panic(err)
    }

    // 结果完全一致
    fmt.Println(t1.Lookup(&quot;T4&quot;))
    fmt.Println(t3.Lookup(&quot;T4&quot;))
    
    // 修改t3
    t3,_ = t3.Parse(`{{define &quot;T4&quot;}}one{{end}}`)
    // 结果将不一致
    fmt.Println(t1.Lookup(&quot;T4&quot;))
    fmt.Println(t3.Lookup(&quot;T4&quot;))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;must函数&quot;&gt;Must()函数&lt;/h2&gt;
&lt;p&gt;正常情况下，很多函数、方法都返回两个值，一个是想要返回的值，一个是err信息。template包中的函数、方法也一样如此。&lt;/p&gt;
&lt;p&gt;但有时候不想要err信息，而是直接取第一个返回值，并赋值给变量。操作大概是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;t1 := template.New(&quot;ttt&quot;)
t1,err := t1.Parse(...)
if err != nil {
    panic(err)
}
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Must()函数将上面的过程封装了，使得Must()可以简化上面的操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func Must(t *Template, err error) *Template {
    if err != nil {
        panic(err)
    }
    return t
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当某个返回&lt;code&gt;*Template,err&lt;/code&gt;的函数、方法需要直接使用时，可用将其包装在Must()中，它会自动在有err的时候panic，无错的时候只返回其中的&lt;code&gt;*Template&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这在赋值给变量的时候非常简便，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var t = template.Must(template.New(&quot;name&quot;).Parse(&quot;text&quot;))&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;parsefiles和parseglob&quot;&gt;ParseFiles()和ParseGlob()&lt;/h2&gt;
&lt;p&gt;Parse()只能解析字符串，要解析文件中的内容，需要使用ParseFiles()或ParseGlob()。&lt;/p&gt;
&lt;p&gt;template包中有ParseFiles()和ParseGlob()函数，也有ParseFiles()和ParseGlob()方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181128205842554-814542634.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两个函数和这两个方法的区别，看一下文档就很清晰：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ go doc template.ParseFiles
func ParseFiles(filenames ...string) (*Template, error)
    ParseFiles creates a new Template and parses the template definitions from
    the named files. The returned template's name will have the (base) name and
    (parsed) contents of the first file. There must be at least one file. If an
    error occurs, parsing stops and the returned *Template is nil.

$ go doc template.template.ParseFiles
func (t *Template) ParseFiles(filenames ...string) (*Template, error)
    ParseFiles parses the named files and associates the resulting templates
    with t. If an error occurs, parsing stops and the returned template is nil;
    otherwise it is t. There must be at least one file.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释很清晰。ParseFiles()函数是直接解析一个或多个文件的内容，并返回第一个文件名的basename作为Template的名称，也就是说这些文件的template全都关联到第一个文件的basename上。ParseFiles()方法则是解析一个或多个文件的内容，并将这些内容关联到t上。&lt;/p&gt;
&lt;p&gt;看示例就一目了然。&lt;/p&gt;
&lt;p&gt;例如，当前go程序的目录下有3个文件：a.cnf、b.cnf和c.cnf，它们的内容无所谓，反正空内容也可以解析。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    t1,err := template.ParseFiles(&quot;a.cnf&quot;,&quot;b.cnf&quot;,&quot;c.cnf&quot;)
    if err != nil {
        panic(err)
    }
    fmt.Println(t1.DefinedTemplates())
    fmt.Println()
    fmt.Println(t1)
    fmt.Println(t1.Lookup(&quot;a.cnf&quot;))
    fmt.Println(t1.Lookup(&quot;b.cnf&quot;))
    fmt.Println(t1.Lookup(&quot;c.cnf&quot;))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;; defined templates are: &quot;a.cnf&quot;, &quot;b.cnf&quot;, &quot;c.cnf&quot;

&amp;amp;{a.cnf 0xc0420ae000 0xc042064140  }
&amp;amp;{a.cnf 0xc0420ae000 0xc042064140  }
&amp;amp;{b.cnf 0xc0420bc000 0xc042064140  }
&amp;amp;{c.cnf 0xc0420bc100 0xc042064140  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从结果中可以看到，已定义的template name都是文件的basename，且t1和a.cnf这个template是完全一致的，即t1是文件列表中的第一个模板对象。&lt;/p&gt;
&lt;p&gt;结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181128214151396-595751013.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;理解了ParseFiles()函数，理解ParseFiles()方法、ParseGlob()函数、ParseGlob()方法，应该不会再有什么问题。但是还是有需要注意的地方：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    t1 := template.New(&quot;test&quot;)
    t1,err := t1.ParseFiles(&quot;a.cnf&quot;,&quot;b.cnf&quot;,&quot;c.cnf&quot;)
    if err != nil {
        panic(err)
    }
    // 先注释下面这行
    //t1.Parse(&quot;&quot;)
    fmt.Println(t1.DefinedTemplates())
    fmt.Println()
    fmt.Println(t1)
    fmt.Println(t1.Lookup(&quot;a.cnf&quot;))
    fmt.Println(t1.Lookup(&quot;b.cnf&quot;))
    fmt.Println(t1.Lookup(&quot;c.cnf&quot;))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;; defined templates are: &quot;a.cnf&quot;, &quot;b.cnf&quot;, &quot;c.cnf&quot;

&amp;amp;{test &amp;lt;nil&amp;gt; 0xc0420640c0  }
&amp;amp;{a.cnf 0xc0420b0000 0xc0420640c0  }
&amp;amp;{b.cnf 0xc0420be000 0xc0420640c0  }
&amp;amp;{c.cnf 0xc0420be100 0xc0420640c0  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现template.New()函数创建的模板对象test并没有包含到common中。为什么？&lt;/p&gt;
&lt;p&gt;因为t.ParseFiles()、t.ParseGlob()方法的解析过程是独立于t之外的，它们只解析文件内容，不解析字符串。而New()出来的模板，需要Parse()方法来解析才会加入到common中。&lt;/p&gt;
&lt;p&gt;将上面的注释行取消掉，执行结果将如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;; defined templates are: &quot;a.cnf&quot;, &quot;b.cnf&quot;, &quot;c.cnf&quot;, &quot;test&quot;

&amp;amp;{test 0xc0420bc200 0xc0420640c0  }
&amp;amp;{a.cnf 0xc0420ae000 0xc0420640c0  }
&amp;amp;{b.cnf 0xc0420bc000 0xc0420640c0  }
&amp;amp;{c.cnf 0xc0420bc100 0xc0420640c0  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体原因可分析parseFiles()源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func parseFiles(t *Template, filenames ...string) (*Template, error) {
    if len(filenames) == 0 {
        // Not really a problem, but be consistent.
        return nil, fmt.Errorf(&quot;template: no files named in call to ParseFiles&quot;)
    }
    for _, filename := range filenames {
        b, err := ioutil.ReadFile(filename)
        if err != nil {
            return nil, err
        }
        s := string(b)

        // name为文件名的basename部分
        name := filepath.Base(filename)

        var tmpl *Template
        if t == nil {
            t = New(name)
        }
        // 如果调用t.Parsefiles()，则t.Name不为空
        // name也就不等于t.Name
        // 于是新New(name)一个模板对象给tmpl
        if name == t.Name() {
            tmpl = t
        } else {
            tmpl = t.New(name)
        }
        // 解析tmpl。如果选中了上面的else分支，则和t无关
        _, err = tmpl.Parse(s)
        if err != nil {
            return nil, err
        }
    }
    return t, nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;execute和executetemplate&quot;&gt;Execute()和ExecuteTemplate()&lt;/h2&gt;
&lt;p&gt;这两个方法都可以用来应用已经解析好的模板，应用表示对需要评估的数据进行操作，并和无需评估数据进行合并，然后输出到io.Writer中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (t *Template) Execute(wr io.Writer, data interface{}) error
func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两者的区别在于Execute()是应用整个common中已定义的模板对象，而ExecuteTemplate()可以选择common中某个已定义的模板进行应用。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    t1 := template.New(&quot;test1&quot;)
    t1, _ = t1.Parse(`{{define &quot;T1&quot;}}ONE{{end}}
        {{- define &quot;T2&quot;}}TWO{{end}}
        {{- define &quot;T3&quot;}}{{template &quot;T1&quot;}} {{template &quot;T2&quot;}}{{end}}
        {{- template &quot;T3&quot;}}`)
    
    _ = t1.Execute(os.Stdout,&quot;&quot;)
    fmt.Println()
    fmt.Println(&quot;-------------&quot;)
    _ = t1.ExecuteTemplate(os.Stdout, &quot;T2&quot;, &quot;&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ONE TWO
-------------
TWO&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;funcmap和funcs&quot;&gt;FuncMap和Funcs()&lt;/h2&gt;
&lt;p&gt;template内置了一系列函数，但这些函数毕竟有限，可能无法满足特殊的需求。template允许我们定义自己的函数，添加到common中，然后就可以在待解析的内容中像使用内置函数一样使用自定义的函数。&lt;/p&gt;
&lt;p&gt;自定义函数的优先级高于内置的函数优先级，即先检索自定义函数，再检索内置函数。也就是说，如果自定义函数的函数名和内置函数名相同，则内置函数将失效。&lt;/p&gt;
&lt;p&gt;本文只对此稍作解释，本文的重点不是template的具体语法和用法。&lt;/p&gt;
&lt;p&gt;在common结构中，有一个字段是FuncMap类型的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type common struct {
    tmpl   map[string]*Template
    option option
    muFuncs    sync.RWMutex // protects parseFuncs and execFuncs
    parseFuncs FuncMap
    execFuncs  map[string]reflect.Value
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类型的定义为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type FuncMap map[string]interface{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它是一个map结构，key为模板中可以使用的函数名，value为函数对象(为了方便称呼，这里直接成为函数)。函数必须只有1个值或2个值，如果有两个值，第二个值必须是error类型的，当执行函数时err不为空，则执行自动停止。&lt;/p&gt;
&lt;p&gt;函数可以有多个参数。假如函数str有两个参数，在待解析的内容中调用函数str时，如果调用方式为&lt;code&gt;{{str . &quot;aaa&quot;}}&lt;/code&gt;，表示第一个参数为当前对象，第二个参数为字符串&quot;aaa&quot;。&lt;/p&gt;
&lt;p&gt;假如，要定义一个将字符串转换为大写的函数，可以：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import &quot;strings&quot;
func upper(str string) string {
    return strings.ToUpper(str)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后将其添加到FuncMap结构中，并将此函数命名为&quot;strupper&quot;，以后在待解析的内容中就可以调用&quot;strupper&quot;函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;funcMap := template.FuncMap{
    &quot;strupper&quot;: upper,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者，直接将匿名函数放在FuncMap内部：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;funcMap := template.FuncMap{
    &quot;strupper&quot;: func(str string) string { return strings.ToUpper(str) },
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在只是定义了一个FuncMap实例，这个实例中有一个函数。还没有将它关联到模板，严格地说还没有将其放进common结构。要将其放进common结构，调用Funcs()方法(其实调用此方法也没有将其放进common，只有在解析的时候才会放进common)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (t *Template) Funcs(funcMap FuncMap) *Template&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;funcMap := template.FuncMap{
    &quot;strupper&quot;: func(str string) string { return strings.ToUpper(str) },
}
t1 := template.New(&quot;test&quot;)
t1 = t1.Funcs(funcMap)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，和t1共享common的所有模板都可以调用&quot;strupper&quot;函数。&lt;/p&gt;
&lt;p&gt;注意，必须在解析之前调用Funcs()方法，在解析的时候会将函数放进common结构。&lt;/p&gt;
&lt;p&gt;下面是完整的示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;os&quot;
    &quot;strings&quot;
    &quot;text/template&quot;
)

func main() {
    funcMap := template.FuncMap{
        &quot;strupper&quot;: upper,
    }
    t1 := template.New(&quot;test1&quot;)
    tmpl, err := t1.Funcs(funcMap).Parse(`{{strupper .}}`)
    if err != nil {
        panic(err)
    }
    _ = tmpl.Execute(os.Stdout, &quot;go programming&quot;)
}

func upper(str string) string {
    return strings.ToUpper(str)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面调用了&lt;code&gt;{{strupper .}}&lt;/code&gt;，这里的strupper是我们自定义的函数，&quot;.&quot;是它的参数(注意，参数不是放进括号里)。这里的&quot;.&quot;代表当前作用域内的当前对象，对于这个示例来说，当前对象就是那段字符串对象&quot;go programming&quot;。&lt;/p&gt;
</description>
<pubDate>Wed, 28 Nov 2018 15:35:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>本文只关注Go text/template的底层结构，带上了很详细的图片以及示例帮助理解，有些地方也附带上了源码进行解释。有了本文的解释，对于Go template的语法以及html/template</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10035768.html</dc:identifier>
</item>
<item>
<title>Java NIO 学习笔记（一）----概述，Channel/Buffer - czwbig</title>
<link>http://www.cnblogs.com/czwbig/p/10035631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/czwbig/p/10035631.html</guid>
<description>&lt;p&gt;Java NIO （来自 Java 1.4）可以替代标准 IO 和 Java Networking API ，NIO 提供了与标准 IO 不同的使用方式。学习 NIO 之前建议先掌握标准 IO 和 Java 网络编程，推荐教程：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文目的：&lt;/strong&gt; 掌握了标准 IO 之后继续学习 NIO 知识。主要参考 JavaDoc 和 Jakob Jenkov 的英文教程 &lt;a href=&quot;http://tutorials.jenkov.com/java-nio/index.html&quot;&gt;Java NIO Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;java-nio-概览&quot;&gt;Java NIO 概览&lt;/h2&gt;
&lt;p&gt;NIO 由以下核心组件组成：&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;通道和缓冲区&lt;br/&gt;在标准 IO API 中，使用字节流和字符流。 在 NIO 中使用通道和缓冲区。 数据总是从通道读入缓冲区，或从缓冲区写入通道。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;非阻塞IO&lt;br/&gt;NIO 可以执行非阻塞 IO 。 例如，当通道将数据读入缓冲区时，线程可以执行其他操作。 并且一旦数据被读入缓冲区，线程就可以继续处理它。 将数据写入通道也是如此。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;选择器&lt;br/&gt;NIO 包含“选择器”的概念。 选择器是一个可以监视多个事件通道的对象（例如：连接打开，数据到达等）。 因此，单个线程可以监视多个通道的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;NIO 有比这些更多的类和组件，但在我看来，Channel，Buffer 和 Selector 构成了 API 的核心。 其余的组件，如 Pipe 和 FileLock ，只是与三个核心组件一起使用的实用程序类。&lt;/p&gt;
&lt;h5 id=&quot;channelsbuffers-通道和缓冲区&quot;&gt;Channels/Buffers 通道和缓冲区&lt;/h5&gt;
&lt;p&gt;通常，NIO 中的所有 IO 都以 Channel 开头，频道有点像流。 数据可以从 Channel 读入 Buffer，也可以从 Buffer 写入 Channel ：&lt;br/&gt;&lt;img src=&quot;http://tutorials.jenkov.com/images/java-nio/overview-channels-buffers.png&quot; alt=&quot;通道将数据读入缓冲区，缓冲区将数据写入通道&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有几种 Channel 和 Buffer ，以下是 NIO 中主要 Channel 实现类的列表，这些通道包括 UDP + TCP 网络 IO 和文件 IO：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FileChannel ：文件通道&lt;/li&gt;
&lt;li&gt;DatagramChannel ：数据报通道&lt;/li&gt;
&lt;li&gt;SocketChannel ：套接字通道&lt;/li&gt;
&lt;li&gt;ServerSocketChannel ：服务器套接字通道&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些类也有一些有趣的接口，但为了简单起见，这里暂时不提，后续会进行学习的。&lt;/p&gt;
&lt;p&gt;以下是 NIO 中的核心 Buffer 实现，其实就是 7 种基本类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ByteBuffer&lt;/li&gt;
&lt;li&gt;CharBuffer&lt;/li&gt;
&lt;li&gt;ShortBuffer&lt;/li&gt;
&lt;li&gt;IntBuffer&lt;/li&gt;
&lt;li&gt;LongBuffer&lt;/li&gt;
&lt;li&gt;FloatBuffer&lt;/li&gt;
&lt;li&gt;DoubleBuffer&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;NIO 还有一个 MappedByteBuffer，它与内存映射文件一起使用，同样这个后续再讲。&lt;/p&gt;
&lt;h5 id=&quot;selectors-选择器&quot;&gt;Selectors 选择器&lt;/h5&gt;
&lt;p&gt;选择器允许单个线程处理多个通道。 如果程序打开了许多连接（通道），但每个连接只有较低的流量，使用选择器就很方便。 例如，在聊天服务器中， 以下是使用 Selector 处理 3 个 Channel 的线程图示：&lt;br/&gt;&lt;img src=&quot;http://tutorials.jenkov.com/images/java-nio/overview-selectors.png&quot; alt=&quot;1个线程使用选择器处理3个通道&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要使用选择器，需要使用它注册通道。 然后你调用它的 select() 方法。 此方法将阻塞，直到有一个已注册通道的事件准备就绪。 一旦该方法返回，该线程就可以处理这些事件。 事件可以是传入连接，接收数据等。&lt;/p&gt;
&lt;h2 id=&quot;channel-通道&quot;&gt;Channel （通道）&lt;/h2&gt;
&lt;p&gt;NIO 通道类似于流，但有一些区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通道可以读取和写入。 流通常是单向的（读或写）。&lt;/li&gt;
&lt;li&gt;通道可以异步读取和写入。&lt;/li&gt;
&lt;li&gt;通道始终读取或写入缓冲区，即它只面向缓冲区。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如上所述，NIO 中总是将数据从通道读取到缓冲区，或将数据从缓冲区写入通道。 这是一个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 文件内容是 123456789
RandomAccessFile accessFile = new RandomAccessFile(&quot;D:\\test\\1.txt&quot;, &quot;rw&quot;);
FileChannel fileChannel = accessFile.getChannel();

ByteBuffer buffer = ByteBuffer.allocate(48);

int data = fileChannel.read(buffer); // 将 Channel 的数据读入缓冲区，返回读入到缓冲区的字节数&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;buffer缓冲区&quot;&gt;Buffer（缓冲区）&lt;/h2&gt;
&lt;p&gt;使用 Buffer 与 Channel 交互，数据从通道读入缓冲区，或从缓冲区写入通道。&lt;br/&gt;缓冲区本质上是一个可以写入数据的内存块，之后可以读取数据。 Buffer 对象包装了此内存块，提供了一组方法，可以更轻松地使用内存块。&lt;/p&gt;
&lt;h5 id=&quot;buffer-的基本用法&quot;&gt;Buffer 的基本用法&lt;/h5&gt;
&lt;p&gt;使用 Buffer 读取和写入数据通常遵循以下四个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将数据写入缓冲区&lt;/li&gt;
&lt;li&gt;调用 buffer.flip() 反转读写模式&lt;/li&gt;
&lt;li&gt;从缓冲区读取数据&lt;/li&gt;
&lt;li&gt;调用 buffer.clear() 或 buffer.compact() 清除缓冲区内容&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;将数据写入Buffer 时，Buffer 会跟踪写入的数据量。 当需要读取数据时，就使用 flip() 方法将缓冲区从写入模式切换到读取模式。 在读取模式下，缓冲区允许读取写入缓冲区的所有数据。&lt;/p&gt;
&lt;p&gt;读完所有数据之后，就需要清除缓冲区，以便再次写入。 可以通过两种方式执行此操作：通过调用 clear() 或调用 compact() 。区别在于 clear() 是方法清除整个缓冲区，而 compact() 方法仅清除已读取的数据，未读数据都会移动到缓冲区的开头，新数据将在未读数据之后写入缓冲区。&lt;/p&gt;
&lt;p&gt;这是一个简单的缓冲区用法示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ChannelExample {
    public static void main(String[] args) throws IOException {
    // 文件内容是 123456789
        RandomAccessFile accessFile = new RandomAccessFile(&quot;D:\\test\\1.txt&quot;, &quot;rw&quot;);
        FileChannel fileChannel = accessFile.getChannel();

        ByteBuffer buffer = ByteBuffer.allocate(48); //创建容量为48字节的缓冲区

        int data = fileChannel.read(buffer); // 将 Channel 的数据读入缓冲区，返回读入到缓冲区的字节数
        while (data != -1) {
            System.out.println(&quot;Read &quot; + data); // Read 9
            buffer.flip(); // 将 buffer 从写入模式切换为读取模式
            while (buffer.hasRemaining()) {
                System.out.print((char) buffer.get()); // 每次读取1byte，循环输出 123456789
            }
            buffer.clear(); // 清除当前缓冲区
            data = fileChannel.read(buffer); // 将 Channel 的数据读入缓冲区
        }
        accessFile.close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;buffer-的-capacityposition-和-limit&quot;&gt;Buffer 的 capacity，position 和 limit&lt;/h5&gt;
&lt;p&gt;缓冲区有 3 个需要熟悉的属性，以便了解缓冲区的工作原理。 这些是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;capacity : 容量缓冲区的容量，是它所包含的元素的数量。不能为负并且不能更改。&lt;/li&gt;
&lt;li&gt;position ：缓冲区的位置 是下一个要读取或写入的元素的索引。不能为负，并且不能大于 limit&lt;/li&gt;
&lt;li&gt;limit : 缓冲区的限制，缓冲区的限制不能为负，并且不能大于 capacity&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;另外还有标记 mark ，&lt;br/&gt;标记、位置、限制和容量值遵守以下不变式：&lt;br/&gt;0 &amp;lt;= mark&amp;lt;= position &amp;lt;= limit&amp;lt;= capacity&lt;/p&gt;
&lt;p&gt;position 和 limit 的含义取决于 Buffer 是处于读取还是写入模式。 无论缓冲模式如何，capacity 总是一样的表示容量。&lt;/p&gt;
&lt;p&gt;以下是写入和读取模式下的容量，位置和限制的说明：&lt;br/&gt;&lt;img src=&quot;http://tutorials.jenkov.com/images/java-nio/buffers-modes.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;capacity&quot;&gt;capacity&lt;/h5&gt;
&lt;p&gt;作为存储器块，缓冲区具有一定的固定大小，也称为“容量”。 只能将 capacity 多的 byte，long，char 等写入缓冲区。 缓冲区已满后，需要清空它（读取数据或清除它），然后才能将更多数据写入。&lt;/p&gt;
&lt;h5 id=&quot;position&quot;&gt;position&lt;/h5&gt;
&lt;p&gt;将数据写入缓冲区时，可以在某个位置执行操作。 position​ 初始值为 ​0 ，当一个 byte，long，char 等已写入缓冲区时，position 被移动，指向缓冲区中的下一个单元以插入数据。 position 最大值为 capacity -1&lt;/p&gt;
&lt;p&gt;从缓冲区读取数据时，也可以从给定位置开始读取数据。 当缓冲区从写入模式切换到读取模式时，position 将重置为 0 。当从缓冲区读取数据时，将从 position 位置开始读取数据，读取后会将 position 移动到下一个要读取的位置。&lt;/p&gt;
&lt;h5 id=&quot;limit&quot;&gt;limit&lt;/h5&gt;
&lt;p&gt;在写入模式下，Buffer 的 limit 是可以写入缓冲区的数据量的限制，此时 limit=capacity。&lt;/p&gt;
&lt;p&gt;将缓冲区切换为读取模式时，limit 表示最多能读到多少数据。 因此，当将 Buffer 切换到读取模式时，limit被设置为之前写入模式的写入位置（position ），换句话说，你能读到之前写入的所有数据（例如之前写写入了 6 个字节，此时 position=6 ，然后切换到读取模式，limit 代表最多能读取的字节数，因此 limit 也等于 6）。&lt;/p&gt;
&lt;h5 id=&quot;分配缓冲区&quot;&gt;分配缓冲区&lt;/h5&gt;
&lt;p&gt;要获取 Buffer 对象，必须先分配它。 每个 Buffer 类都有一个 allocate() 方法来执行此操作。 下面是一个显示ByteBuffer分配的示例，容量为48字节：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ByteBuffer buffer = ByteBuffer.allocate(48); //创建容量为48字节的缓冲区&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;将数据写入缓冲区&quot;&gt;将数据写入缓冲区&lt;/h5&gt;
&lt;p&gt;可以通过两种方式将数据写入 Buffer：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将数据从通道写入缓冲区&lt;/li&gt;
&lt;li&gt;通过缓冲区的 put() 方法,自己将数据写入缓冲区。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这是一个示例，显示了 Channel 如何将数据写入 Buffer：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int data = fileChannel.read(buffer); // 将 Channel 的数据读入缓冲区，返回读入到缓冲区的字节数
buffer.put(127); // 此处的 127 是 byte 类型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;put() 方法有许多其他版本，允许以多种不同方式将数据写入 Buffer 。 例如，在特定位置写入，或将一个字节数组写入缓冲区。&lt;/p&gt;
&lt;h5 id=&quot;flip-切换缓冲区的读写模式&quot;&gt;flip() 切换缓冲区的读写模式&lt;/h5&gt;
&lt;p&gt;flip() 方法将 Buffer 从写入模式切换到读取模式。 调用 flip() 会将 position 设置回 0，并将 limit 的值设置为切换之前的 position 值。换句话说，limit 表示之前写进了多少个 byte、char 等 —— 现在能读取多少个 byte、char 等。&lt;/p&gt;
&lt;h5 id=&quot;从缓冲区读取数据&quot;&gt;从缓冲区读取数据&lt;/h5&gt;
&lt;p&gt;有两种方法可以从 Buffer 中读取数据：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将数据从缓冲区读入通道。&lt;/li&gt;
&lt;li&gt;使用 get() 方法之一，自己从缓冲区读取数据。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以下是将缓冲区中的数据读入通道的示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int bytesWritten = fileChannel.write(buffer);
byte aByte = buffer.get();    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和 put() 方法一样，get() 方法也有许多其他版本，允许以多种不同方式从 Buffer 中读取数据。有关更多详细信息，请参阅JavaDoc以获取具体的缓冲区实现。&lt;/p&gt;
&lt;p&gt;以下列出 ByteBuffer 类的部分方法：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;16&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;byte[] array()&lt;/td&gt;
&lt;td&gt;返回实现此缓冲区的 byte 数组，此缓冲区的内容修改将导致返回的数组内容修改，反之亦然。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;CharBuffer asCharBuffer()&lt;/td&gt;
&lt;td&gt;创建此字节缓冲区作为新的独立的char 缓冲区。新缓冲区的内容将从此缓冲区的当前位置开始&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;XxxBuffer asXxxBuffer()&lt;/td&gt;
&lt;td&gt;同上，创建对应的 Xxx 缓冲区，Xxx 可为 Short/Int/Long/Float/Double&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;byte get()&lt;/td&gt;
&lt;td&gt;相对 get 方法。读取此缓冲区当前位置的字节，然后该 position 递增。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;ByteBuffer get(byte[] dst, int offset, int length)&lt;/td&gt;
&lt;td&gt;相对批量 get 方法，后2个参数可省略&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;byte get(int index)&lt;/td&gt;
&lt;td&gt;绝对 get 方法。读取指定索引处的字节。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;char getChar()&lt;/td&gt;
&lt;td&gt;用于读取 char 值的相对 get 方法。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;char getChar(int index)&lt;/td&gt;
&lt;td&gt;用于读取 char 值的绝对 get 方法。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;xxx getXxx(int index)&lt;/td&gt;
&lt;td&gt;用于读取 xxx 值的绝对 get 方法。index 可以选，指定位置。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;众多 put() 方法&lt;/td&gt;
&lt;td&gt;参考以上 get() 方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;static ByteBuffer wrap(byte[] array)&lt;/td&gt;
&lt;td&gt;将 byte 数组包装到缓冲区中。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;rewind-倒带&quot;&gt;rewind() 倒带&lt;/h5&gt;
&lt;p&gt;Buffer对象的 rewind() 方法将 position 设置回 0，因此可以重读缓冲区中的所有数据， limit 则保持不变。&lt;/p&gt;
&lt;h5 id=&quot;clear-和-compact&quot;&gt;clear() 和 compact()&lt;/h5&gt;
&lt;p&gt;如果调用 clear() ,则将 position 设置回 0 ，并将 limit 被设置成 capacity 的值。换句话说，Buffer 被清空了。 但是 Buffer 中的实际存放的数据并未清除。&lt;/p&gt;
&lt;p&gt;如果在调用 clear() 时缓冲区中有任何未读数据，数据将被“遗忘”，这意味着不再有任何标记告诉读取了哪些数据，还没有读取哪些数据。&lt;/p&gt;
&lt;p&gt;如果缓冲区中仍有未读数据，并且想稍后读取它，但需要先写入一些数据，这时候应该调用 compact() ，它会将所有未读数据复制到 Buffer 的开头，然后它将 position 设置在最后一个未读元素之后。 limit 属性仍设置为 capacity ，就像 clear() 一样。 现在缓冲区已准备好写入，并且不会覆盖未读数据。&lt;/p&gt;
&lt;h5 id=&quot;mark-和-reset&quot;&gt;mark() 和 reset()&lt;/h5&gt;
&lt;p&gt;以通过调用 Buffer 对象的 mark() 方法在 Buffer 中标记给定位置。 然后，可以通过调用 Buffer.reset() 方法将位置重置回标记位置，就像在标准 IO 中一样。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;buffer.mark();
// 调用 buffer.get() 等方法读取数据...

buffer.reset();  // 设置 position 回到 mark 位置。&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;equals-和-compareto&quot;&gt;equals() 和 compareTo()&lt;/h5&gt;
&lt;p&gt;可以使用 equals() 和 compareTo() 比较两个缓冲区。&lt;/p&gt;
&lt;p&gt;equals() 成立的条件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它们的类型相同（byte，char，int等）&lt;/li&gt;
&lt;li&gt;它们在缓冲区中具有相同数量的剩余字节，字符等。&lt;/li&gt;
&lt;li&gt;所有剩余的字节，字符等都相等。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如上，equals 仅比较缓冲区的一部分，而不是它内部的每个元素。 实际上，它只是比较缓冲区中的其余元素。&lt;/p&gt;
&lt;p&gt;compareTo() 方法比较两个缓冲区的剩余元素（字节，字符等）， 在下列情况下，一个 Buffer 被视为“小于”另一个 Buffer：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一个不相等的元素小于另一个 Buffer 中对应的元素 。&lt;/li&gt;
&lt;li&gt;所有元素都相等，但第一个 Buffer 在第二个 Buffer 之前耗尽了元素（第一个 Buffer 元素较少）。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 28 Nov 2018 15:01:00 +0000</pubDate>
<dc:creator>czwbig</dc:creator>
<og:description>掌握了标准 IO 之后继续学习 NIO 知识。主要参考 JavaDoc 和 Jakob Jenkov 的英文教程 [Java NIO Tutorial]</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/czwbig/p/10035631.html</dc:identifier>
</item>
</channel>
</rss>