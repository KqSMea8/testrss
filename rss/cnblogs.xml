<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ROS 用 roboware实现节点信息发送和接收 - 未完代码</title>
<link>http://www.cnblogs.com/fuhang/p/9635150.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fuhang/p/9635150.html</guid>
<description>&lt;p&gt;在ros下实现节点编程，实现一个节点发送消息，另一个节点接收。实现方式有多种，可以直接在命令窗口创建工作空间包以及节点，用catkin_make进行编译，添加.bash路径，然后执行rosrun  package  node_name 。这种方式对于一个ROS初学者来说容易出错，而且很多网上的教程中出现了不同的问题，比如需要修改CMakeLists.txt和package.xml中的内容，相当繁琐。为了避免不必要的麻烦，初学者可以应用IDE进行节点编程，达到一定的水平后，再用上面的方式去实现。下面就介绍一下roboware 软件实现helloword的发送和接收。&lt;/p&gt;
&lt;p&gt;这个例子是在ROS能正常运行的情况下进行的，所以为了不必要的麻烦，最好先跑跑小乌龟的例子。&lt;/p&gt;
&lt;p&gt;1.下载安装roboware.&lt;/p&gt;
&lt;p&gt;去官网下载地址：http://www.roboware.me/#/home &lt;/p&gt;
&lt;p&gt;选择Studio v1.2.64bit deb  下载 。如果是32位机选择v.2.0 32bit deb版本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1256253/201809/1256253-20180912141810861-741893800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;傻瓜式安装，一直下一步。安装好以后如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1256253/201809/1256253-20180912142323069-162900492.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;487&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.创建工作区&lt;/p&gt;
&lt;p&gt;打开软件后，选择新建工作区，这里要选择一个文件夹,这里最后选择主文件夹。然后在名称：robot&lt;/p&gt;
&lt;p&gt;robot 即为新建的工作空间名称。建好之后后出现一个src文件夹，和一个CMakeLists.txt文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1256253/201809/1256253-20180912142742155-2077022981.png&quot; alt=&quot;&quot; width=&quot;722&quot; height=&quot;512&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.新建ROS包&lt;/p&gt;
&lt;p&gt;右键src文件夹选择“新建ROS包”在名称栏：test&lt;/p&gt;
&lt;p&gt;建好之后会出现一个test文件夹，下有一个SRC文件夹。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1256253/201809/1256253-20180912143533300-2034263522.png&quot; alt=&quot;&quot; width=&quot;761&quot; height=&quot;530&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.新建ROS节点&lt;/p&gt;
&lt;p&gt;右键test文件夹，选择新建C++ROS节点。在名称：test&lt;/p&gt;
&lt;p&gt;建好之后文件内有两个.cpp文件，一个是test_pub.cpp ,用于发送helloworld 信息，称为发送者。 另一个是test_sub.cpp用于接收信息，称为订阅者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1256253/201809/1256253-20180912144213199-312287236.png&quot; alt=&quot;&quot; width=&quot;780&quot; height=&quot;549&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.点击左上角的锤子编译文件，ROS节点界面会出现test节点。看到100%说明编译成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1256253/201809/1256253-20180912144418414-1319991008.png&quot; alt=&quot;&quot; width=&quot;802&quot; height=&quot;560&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上就完成了整个工程的编译，这部分内容一般不会出现什么问题，接下来就要执行了，问题就来了。&lt;/p&gt;
&lt;p&gt;6.打开ROS master&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1256253/201809/1256253-20180912145029431-1245155985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7.rosrun执行节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
rosrun test test_pub
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1256253/201809/1256253-20180912145914475-1789841525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分析其原因可能是因为在安装ROS时已经创建了工作空间，新建的工作空间和之前的不同，所以需要将新建的工作空间的路径添加到bashrc文件中。&lt;/p&gt;
&lt;p&gt;于是执行下面的步骤：新开一个终端输入下面的命令打开文件bashrc&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
gedit .bashrc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在新建工作空间的devel 文件下找到setup.bash文件，查看其路径将其路径添加到bashrc文件的末尾，具体如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1256253/201809/1256253-20180912150754813-1658952750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后关闭所有终端，重新打开终端执行&lt;/p&gt;

&lt;p&gt;再打开一个终端：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
rosrun test test_pub
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;出现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1256253/201809/1256253-20180912151041517-1754004503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里实现了发送&lt;/p&gt;
&lt;p&gt;8.执行接收节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
rosrun test test_sub
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1256253/201809/1256253-20180912151502016-1849980929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现same name的问题。&lt;/p&gt;
&lt;p&gt;这是我们在创建节点时没有修改cpp文件中初始化文件名导致的。&lt;/p&gt;
&lt;p&gt;将名称改为test_pub和test_sub&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1256253/201809/1256253-20180912151819926-1666043369.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1256253/201809/1256253-20180912151829623-695013739.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存，重新编译。然后将所以终端全部关闭，重新执行打开master和发送、接收&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1256253/201809/1256253-20180912153923223-237139324.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以实现接收了。&lt;/p&gt;
</description>
<pubDate>Wed, 12 Sep 2018 07:40:00 +0000</pubDate>
<dc:creator>未完代码</dc:creator>
<og:description>在ros下实现节点编程，实现一个节点发送消息，另一个节点接收。实现方式有多种，可以直接在命令窗口创建工作空间包以及节点，用catkin_make进行编译，添加.bash路径，然后执行rosrun pa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fuhang/p/9635150.html</dc:identifier>
</item>
<item>
<title>玩转SpringCloud（F版本）  四．路由网关(zuul) - 房上的猫</title>
<link>http://www.cnblogs.com/lsy131479/p/9635075.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsy131479/p/9635075.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_ImageLink&quot; href=&quot;https://www.cnblogs.com/lsy131479/archive/2018/09/09.html&quot;&gt;01）&lt;/a&gt;&lt;/span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/lsy131479/p/9613755.html&quot;&gt;玩转SpringCloud 一．服务的注册与发现（Eureka）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;02) &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_2&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/lsy131479/p/9625479.html&quot;&gt;玩转SpringCloud 二．服务消费者（1）ribbon+restTemplate&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;03) &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_1&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/lsy131479/p/9626805.html&quot;&gt;玩转SpringCloud 二．服务消费者（2）feign&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;04) &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/lsy131479/p/9628448.html&quot;&gt;转SpringCloud 三．断路器（Hystrix）RestTemplate+Ribbon和Feign两种方式&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在微服务架构中，需要几个基础的服务治理组件，包括&lt;span&gt;服务注册与发现、服务消费、负载均衡、断路器、智能路由、配置管理&lt;/span&gt;等，由这几个基础组件相互协作，共同组建了一个简单的&lt;span&gt;微服务&lt;/span&gt;系统。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在&lt;/span&gt;Spring Cloud微服务系统中，一种常见的负载均衡方式是，客户端的请求首先经过负载均衡（zuul、Ngnix），再到达服务网关（zuul集群），然后再到具体的服。，服务统一注册到高可用的服务注册中心集群，服务的所有的&lt;span&gt;配置文件由配置服务管理，配置服务的配置文件&lt;/span&gt;放在&lt;span&gt;git仓库&lt;/span&gt;，方便开发人员随时改配置。&lt;/p&gt;

&lt;h2&gt;一、&lt;strong&gt;Z&lt;/strong&gt;&lt;strong&gt;uul&lt;span&gt;简介&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;zuul有以下功能：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　· Authentication&lt;/p&gt;
&lt;p&gt;　　· Insights&lt;/p&gt;
&lt;p&gt;　　· Stress Testing&lt;/p&gt;
&lt;p&gt;　　· Canary Testing&lt;/p&gt;
&lt;p&gt;　　· Dynamic Routing&lt;/p&gt;
&lt;p&gt;　　· Service Migration&lt;/p&gt;
&lt;p&gt;　　· Load Shedding&lt;/p&gt;
&lt;p&gt;　　· Security&lt;/p&gt;
&lt;p&gt;　　· Static Response handling&lt;/p&gt;
&lt;p&gt;　　· Active/Active traffic management&lt;/p&gt;

&lt;h2&gt;二、&lt;strong&gt;&lt;span&gt;配置路由&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt; 项目架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201809/1211814-20180912154817660-1202980817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在原有的工程上，创建一个新的工程。&lt;/span&gt;demo5&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;依赖主工程以及所需&lt;/span&gt;jar&lt;span&gt;包：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.fsdm&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;SpringCloud_test1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-eureka-client&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-zuul&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在其入口&lt;/span&gt;applicaton类加上注解@EnableZuulProxy，开启zuul的功能：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
&lt;span&gt;@EnableZuulProxy&lt;/span&gt;
@EnableEurekaClient
@EnableDiscoveryClient
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo5Application {

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
      SpringApplication.run(Demo5Application.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注解解析：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;@EnableZuulProxy&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果使用注解&lt;/span&gt;@EnableZuulProxy&lt;span&gt;，那么除上述过滤器之外，&lt;/span&gt;&lt;span&gt;Spring Cloud&lt;/span&gt;&lt;span&gt;还会增加以下过滤器：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1&lt;span&gt;、&lt;/span&gt;&lt;span&gt;pre&lt;/span&gt;&lt;span&gt;类型过滤器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PreDecorationFilter&lt;span&gt;：该过滤器根据提供的&lt;/span&gt;&lt;span&gt;RouteLocator&lt;/span&gt;&lt;span&gt;确定路由到的地址，以及怎样去路由。该路由器也可为后端请求设置各种代理相关的&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2&lt;span&gt;、&lt;/span&gt;&lt;span&gt;route&lt;/span&gt;&lt;span&gt;类型过滤器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(1) RibbonRoutingFilter&lt;span&gt;：该过滤器使用&lt;/span&gt;&lt;span&gt;Ribbon&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Hystrix&lt;/span&gt;&lt;span&gt;和可插拔的&lt;/span&gt;&lt;span&gt;HTTP&lt;/span&gt;&lt;span&gt;客户端发送请求。&lt;/span&gt;&lt;span&gt;serviceId&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;RequestContext.getCurrentContext().get(&quot;serviceId&quot;)&lt;/span&gt;&lt;span&gt;中。该过滤器可使用不同的&lt;/span&gt;&lt;span&gt;HTTP&lt;/span&gt;&lt;span&gt;客户端，例如&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Apache HttpClient&lt;span&gt;：默认的&lt;/span&gt;&lt;span&gt;HTTP&lt;/span&gt;&lt;span&gt;客户端&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SquareupOkHttpClient v3&lt;span&gt;：如需使用该客户端，需保证&lt;/span&gt;&lt;span&gt;com.squareup.okhttp3&lt;/span&gt;&lt;span&gt;的依赖在&lt;/span&gt;&lt;span&gt;classpath&lt;/span&gt;&lt;span&gt;中，并设置&lt;/span&gt;&lt;span&gt;ribbon.okhttp.enabled = true&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Netflix Ribbon HTTP client&lt;span&gt;：设置&lt;/span&gt;&lt;span&gt;ribbon.restclient.enabled = true&lt;/span&gt;&lt;span&gt;即可启用该&lt;/span&gt;&lt;span&gt;HTTP&lt;/span&gt;&lt;span&gt;客户端。需要注意的是，该客户端有一定限制，例如不支持&lt;/span&gt;&lt;span&gt;PATCH&lt;/span&gt;&lt;span&gt;方法，另外，它有内置的重试机制。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2) SimpleHostRoutingFilter&lt;span&gt;：该过滤器通过&lt;/span&gt;&lt;span&gt;Apache HttpClient&lt;/span&gt;&lt;span&gt;向指定的&lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;发送请求。&lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;RequestContext.getRouteHost()&lt;/span&gt;&lt;span&gt;中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;yml配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;eureka:&lt;/span&gt;
  &lt;span&gt;client:&lt;/span&gt;
    &lt;span&gt;serviceUrl:&lt;/span&gt;
      &lt;span&gt;defaultZone:&lt;/span&gt; &lt;span&gt;http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8761/eureka/&lt;/span&gt;
&lt;span&gt;server:&lt;/span&gt;
  &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;8766&lt;/span&gt;
&lt;span&gt;spring:&lt;/span&gt;
  &lt;span&gt;application:&lt;/span&gt;
    &lt;span&gt;name:&lt;/span&gt;&lt;span&gt; service-zuul
&lt;/span&gt;&lt;span&gt;zuul:&lt;/span&gt;
  &lt;span&gt;routes:&lt;/span&gt;&lt;span&gt;
    api-&lt;/span&gt;&lt;span&gt;a:&lt;/span&gt;
      &lt;span&gt;path:&lt;/span&gt; /api-a&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
      serviceId: service-ribbon
    api-b:
      path: /api-b/**
      serviceId: service-feign&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;首先指定服务注册中心的地址为&lt;/span&gt;&lt;a href=&quot;http://localhost:8761/eureka/&quot;&gt;http://localhost:8761/eureka/&lt;/a&gt;&lt;span&gt;，服务的端口为&lt;/span&gt;8766&lt;span&gt;，服务名为&lt;/span&gt;service-zuul；以/api-a/ 开头的请求都转发给service-ribbon服务；以/api-b/开头的请求都转发给service-feign服务；&lt;/p&gt;

&lt;p&gt;&lt;span&gt;把五个项目都跑起来：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201809/1211814-20180912152716979-1796798413.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;打开浏览器&lt;/span&gt;&lt;span&gt;分别&lt;/span&gt;&lt;span&gt;访问：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://localhost:8769/api-a/hi?name=forezp&quot;&gt;　　　　　　http://localhost:8766/api-a/hi?name=fsdm&lt;/a&gt; ;&lt;/p&gt;

&lt;p&gt;　　　　　　&lt;a href=&quot;http://localhost:8769/api-a/hi?name=forezp&quot;&gt;http://localhost:876/api-b/hi?name=fsdm&lt;/a&gt; ;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;浏览器显示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201809/1211814-20180912152752525-373870255.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;这说明&lt;/span&gt;zuul起到了路由的作用&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;三、&lt;strong&gt;&lt;span&gt;服务过滤&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt; 项目架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201809/1211814-20180912154901379-1158107763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;zuul不仅只是路由，并且还能过滤，做一些安全验证&lt;/span&gt;&lt;/strong&gt;。继续改造工程；&lt;/p&gt;


&lt;p&gt;&lt;span&gt;添加过滤器类：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyFilter &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ZuulFilter {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：
     * pre：路由之前
     * routing：路由之时
     * post： 路由之后
     * error：发送错误调用
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String filterType() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;pre&quot;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;过滤的顺序&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; filterOrder() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里可以写逻辑判断，是否要过滤，本文true,永远过滤。&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; shouldFilter() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object run() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ZuulException {
        System.out.println(&lt;/span&gt;&quot;==============================================================&quot;&lt;span&gt;);
        RequestContext ctx &lt;/span&gt;=&lt;span&gt; RequestContext.getCurrentContext();
        HttpServletRequest request &lt;/span&gt;=&lt;span&gt; ctx.getRequest();
        System.out.println(String.format(&lt;/span&gt;&quot;%s &amp;gt;&amp;gt;&amp;gt; %s&quot;&lt;span&gt;, request.getMethod(), request.getRequestURL().toString()));
        Object accessToken &lt;/span&gt;= request.getParameter(&quot;token&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(accessToken == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;token is empty&quot;&lt;span&gt;);
            ctx.setSendZuulResponse(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            ctx.setResponseStatusCode(&lt;/span&gt;401&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                ctx.getResponse().getWriter().write(&lt;/span&gt;&quot;token is empty&quot;&lt;span&gt;);
            }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){}

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        System.out.println(&lt;/span&gt;&quot;ok&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;访问：&lt;/span&gt;&lt;a href=&quot;http://localhost:8769/api-a/hi?name=forezp&quot;&gt;http://localhost:8766/api-a/hi?name=fsdm&lt;/a&gt; &lt;span&gt;；网页显示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201809/1211814-20180912152912536-809048792.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;访问&lt;/span&gt;http://localhost:8766/api-a/hi?name=fsdm&amp;amp;token=22&lt;span&gt;页面显示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201809/1211814-20180912152938996-985915638.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;这里是一个非常简单的模拟验证，通过是否又token值来决定是否有权限访问&lt;/p&gt;




&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;span&gt;　　未完，待续。。。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 12 Sep 2018 07:36:00 +0000</pubDate>
<dc:creator>房上的猫</dc:creator>
<og:description>本篇文章基于： 01）玩转SpringCloud 一．服务的注册与发现（Eureka） 02) 玩转SpringCloud 二．服务消费者（1）ribbon+restTemplate 03) </og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lsy131479/p/9635075.html</dc:identifier>
</item>
<item>
<title>使用python制作时间戳转换工具 - vinter_he</title>
<link>http://www.cnblogs.com/vinter/p/9635094.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vinter/p/9635094.html</guid>
<description>&lt;p&gt;python 时间戳转日期 日期转时间戳&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;前言：作为一个程序员一般情况下，json和时间戳是常用的两个工具，我咨询过很多个朋友，他们一般都是通过在线工具对json进行格式化，或者查询时间戳。这个方式也是我之前的使用方式，此种方式不足之处如下：&lt;br/&gt;1.每次打开过程步骤繁琐，即使收藏了也要先打开浏览器，然后点击&lt;br/&gt;2.如果打开的浏览器标签足够多的话，根本找不到（就是说的我这样的人）&lt;br/&gt;3.等&lt;br/&gt;后来我发现了hijson这个工具可以本地格式化json后，一直想找一个本地查找时间戳的小工具。奈何互联网大神们没有满足我的需求。于是我决定自己写一个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;本文的环境&quot;&gt;本文的环境&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;python 3.6&lt;/li&gt;
&lt;li&gt;time 库&lt;/li&gt;
&lt;li&gt;tkinter 库&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可选：可以使用pyinstaller打包成exe文件运行。程序大小大约8m，运行时内存占用15m左右。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先贴代码（因为时间有限，没有写的太工整，见谅）：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;
from tkinter import *
from time import *

'''
1、这个程序实现时间戳和日期格式的相互转换。
2、使用grid方法按照表格方式对组件位置进行安排
3、通过Button按钮进行转换和刷新操作。
4、通过Entry来获取用户输入。
'''
root = Tk()
root.title('时间戳转换')
root.resizable(0,0)#禁止拉伸 会变丑
# 对变量进行创建，和数据初始化
Label1 = Label(root, text='时间戳:').grid(row=0, column=0)
Label2 = Label(root, text='日期:').grid(row=1, column=0)
v1 = StringVar()
p1 = StringVar()
v1.set(int(time()))

Label3 = Label(root, text='日期:').grid(row=3, column=0)
Label4 = Label(root, text='时间戳').grid(row=4, column=0)
v2 = StringVar()
p2 = StringVar()
timeArray1 = localtime(int(time()))
v2.set(strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, timeArray1))
p2.set(int(time()))
#时间戳转换成日期
def trans1():

    e1 = Entry(root, textvariable=v1)  # Entry 是 Tkinter 用来接收字符串等输入的控件.
    e2 = Entry(root, textvariable=p1)
    e1.grid(row=0, column=1, padx=10, pady=5)  # 设置输入框显示的位置，以及长和宽属性
    e2.grid(row=1, column=1, padx=10, pady=5)

    timeArray = localtime(int(e1.get()))
    p1.set(strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, timeArray))
#日期转换为时间戳
def trans2():
    e3 = Entry(root, textvariable=v2)  # Entry 是 Tkinter 用来接收字符串等输入的控件.
    e4 = Entry(root, textvariable=p2)
    e3.grid(row=3, column=1, padx=10, pady=5)  # 设置输入框显示的位置，以及长和宽属性
    e4.grid(row=4, column=1, padx=10, pady=5)
    p2.set(int(mktime(strptime(e3.get(), &quot;%Y-%m-%d %H:%M:%S&quot;))))
#刷新第二个模组
def refresh():
    timeArray1 = localtime(int(time()))
    v2.set(strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, timeArray1))
    p2.set(int(time()))



Button(root, text='转换', width=10, command=trans1) \
    .grid(row=2, column=0, sticky=W, padx=10, pady=5)
Button(root, text='转换', width=10, command=trans2) \
    .grid(row=5, column=0, sticky=W, padx=10, pady=5)
Button(root, text='刷新', width=10, command=refresh) \
    .grid(row=5, column=1, sticky=W, padx=10, pady=5)
Button(root, text='退出', width=10, command=root.quit) \
    .grid(row=6, column=1, sticky=E, padx=10, pady=5)
trans1()
trans2()
#设置窗口初始显示位置
sw = root.winfo_screenwidth()
sh = root.winfo_screenheight()
x = (sw) / 2
y = (sh) / 2
root.geometry(&quot;+%d+%d&quot; %(x,y))
mainloop()

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我一直信奉代码写的足够好不需要额外的太多解释。请看上面代码中的注释&lt;/p&gt;
&lt;h2 id=&quot;pyinstaller的安装和使用&quot;&gt;pyinstaller的安装和使用&lt;/h2&gt;
&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pip install pyinsatller

#安装直接运行一下如下命令
pyinstaller
#如果能运行会提示选项&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;打包文件&quot;&gt;打包文件&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#打包的命令（在命令行中运行，如果不成功记得配置好环境变量）
pyinsatller -F -w D:\python\timeTran.py 
#选项介绍
#-F –onefile    产生一个文件用于部署 (参见XXXXX).
#-w,–windowed,–noconsole 使用Windows子系统执行.当程序启动的时候不会打开命令行(只对Windows有效) 就是不会显示一个黑窗口（太丑了，还要手动去关闭）如果不知道什么意思，可以自己去试试&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;github地址：&lt;a href=&quot;https://github.com/VinterHe/timeTransverter&quot; class=&quot;uri&quot;&gt;https://github.com/VinterHe/timeTransverter&lt;/a&gt;&lt;br/&gt;生成成功后提示中会有一条INFO: Appending archive to EXE C:\Users\XXX\dist\timeTransverter.exe，里面放着你想要的exe文件。欢迎大家转载和使用，谢谢。&lt;/p&gt;
</description>
<pubDate>Wed, 12 Sep 2018 07:33:00 +0000</pubDate>
<dc:creator>vinter_he</dc:creator>
<og:description>使用python制作时间戳转换工具 python 时间戳转日期 日期转时间戳 前言：作为一个程序员一般情况下，json和时间戳是常用的两个工具，我咨询过很多个朋友，他们一般都是通过在线工具对json进</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vinter/p/9635094.html</dc:identifier>
</item>
<item>
<title>.Net外包篇:我是怎么看待外包的(二) - 从此启程</title>
<link>http://www.cnblogs.com/fancunwei/p/9635036.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fancunwei/p/9635036.html</guid>
<description>&lt;p&gt;延续上篇文章&lt;a href=&quot;https://www.cnblogs.com/fancunwei/p/9632817.html&quot; title=&quot;.net外包篇：我是如何看待外包的&quot;&gt;.net外包篇：我是如何看待外包的&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;从这家公司辞职以后，得益于我校园信息平台和高校信息管理的经验，我进入了一个互联网类型公司。以前的经历，环环相扣，步步提升。&lt;/p&gt;

&lt;h2&gt;第四家客户(未谈成)&lt;/h2&gt;
&lt;p&gt;这个是属于网上自己找的项目，和负责人探妥了条件后，就出发去他们公司了，里面已经有部分开发人员了。简单了过了下需求，发现让我做的，比负责人谈的要多很多。经过周末的试开发，发现他们提供的接口还有bug，由于时间和预期目标关系不符，所以选择了退出。&lt;/p&gt;
&lt;p&gt;按道理，没谈成的项目不应该列出来，但这个还有后话。&lt;/p&gt;
&lt;h4&gt;收获&lt;/h4&gt;
&lt;p&gt;接一个项目，如果没有足够的时间，要有自己的预期，不符合预期就不要接下来，以防后期不好交付。更大的收获是和其中的几个开发人员互加了微信，后期为我带来了另外的一个项目。&lt;/p&gt;
&lt;h2&gt;第五个客户&lt;/h2&gt;
&lt;p&gt;这个就是程序媛妹妹登场的时候了，音乐响起来！&lt;/p&gt;
&lt;p&gt;第四个客户过后一段时间，快过年了，一个叫静静的程序媛联系了我，说有个项目是否有兴趣，很融洽的商量了下来，功能模型类似我 实用中小型公司支付中心搭建那篇文章列举模型，会员分销提成。&lt;/p&gt;
&lt;p&gt;这个项目我收获很大，但遗憾也不少。&lt;/p&gt;
&lt;p&gt;由于是兼职，所以大多说都是晚上撸代码，也经常视频聊天沟通需求。大晚上有个美女视频着开发，感觉还是挺好的。然后就到了过年。因为我回老家，家里也没网，就牵了电信的网。那几天矛盾挺多的，静静一直很着急，但我那段时间准备结婚事宜和网络原因，没法敲代码，有些延误工期。等婚礼结束，网络连好后，就开始继续敲代码了，不过以后就再没视频过了，都是语音或微信沟通。&lt;/p&gt;
&lt;p&gt;开年大吉，项目第一期完工后，项目老板举行一个简单的聚会，大家非常happy，老板说让我辞职过去，不过我找了个理由推辞了。后来的南京举行的发布会，我也没有去。我模糊的记得，静静好像说过：以前不是说好以后一起做项目的么，你就这样退出了？大概是这个意思。我觉得很愧疚，不好回答。&lt;/p&gt;
&lt;p&gt;我为什么没有继续跟进了？&lt;/p&gt;
&lt;p&gt;一个原因是人员，初创公司人员不齐全加上两个老板，三个兼职开发，一个更兼职的就五六个人。&lt;/p&gt;
&lt;p&gt;第二个原因产品，第一版核心功能是会员分销拿提成，投资股权。我觉得这些有点虚，产品有传销风险。&lt;/p&gt;
&lt;p&gt;第三个原因是我在现公司待的很好，同事们相处很融洽。我喜欢这个工作环境。&lt;/p&gt;
&lt;p&gt;虽然没有跟进后续的项目，但也是结识了一些人，如果我有好的项目机会也会联系他们的。&lt;br/&gt;&lt;/p&gt;
&lt;h4&gt;收获&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;实践了微信支付&lt;/strong&gt;，虽然在公司经常用支付，但还没真正从零接过微信支付。这次算弥补了愿望。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GDI+海报&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用gdi+实现了自动基于粉丝信息汇出分销海报。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数二维码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;熟悉了微信的参数二维码，利用参数二维码实现分销。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;熟悉微信开发流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从微信获取openid开始，到发模版图文消息等流程。对于微信不再是迷茫区。&lt;/p&gt;
&lt;h2&gt;第六个客户(失败)&lt;/h2&gt;
&lt;p&gt;这算是个失败的项目，因为从事过支付，微信和分销的项目，又接下了朋友的一个分销商品系统。我初期以为很快搞定，但搞了一个月后发现一个人搞不定了，界面说简单也简单，是一个完善带分销的完善电商系统，我想的太简单了。又是从头开发，没有适合的开源系统，注定不能快速的完成。&lt;/p&gt;
&lt;p&gt;一个月后，我退钱结束项目。因为是朋友，他也没啥损失。以后再有人问我说电商之类系统，我都建议以阿里，有赞，微店看看是否适合。每个人都有特性的需求，完全开发，小店没有财力和时间去完成，只能以现成产品去用。&lt;/p&gt;
&lt;p&gt;最近两年由于时间关系，再没接过外包了，耗时耗力。&lt;/p&gt;
&lt;h2&gt;大总结&lt;/h2&gt;
&lt;p&gt;我的外包故事到此结束，有成功有失败。酸甜苦辣，滋味不同。因为外包，我前些年有了全栈的开发能力，当然这在现在的大前端面前有点心虚。但当时从jquery到编码到数据库到部署，一系列流程都能搞定，也算是全栈吧？现在系统规模一大，队列，缓存，容器，大数据一来，我仿佛什么都不会了。&lt;/p&gt;
&lt;p&gt;微软感受到了自己的落后而开源了.netcore，我也得补充自己的知识框架，我会的那些也许都过时了。竞争不过新人，就会被淘汰，这是真理。&lt;/p&gt;
&lt;p&gt;虽然我断断续续接了些外包，但我也建议新人不要太过专注接外包。我上面所列的东西，你完全可以走另一条路，自研组件写博客，写书之路，这也许是一天更好的路。外包能影响你一份工作，但一本好书可以影响你的一生。&lt;/p&gt;
&lt;p&gt;初生牛犊不怕虎，开源软件路先行。谨以此篇回忆文章纪念2011年在51aspx开源的XX远程控制系统。七年之内，却没有第二个开源出来。甚为遗憾。&lt;/p&gt;
&lt;p&gt;此篇结束。&lt;/p&gt;
</description>
<pubDate>Wed, 12 Sep 2018 07:25:00 +0000</pubDate>
<dc:creator>从此启程</dc:creator>
<og:description>延续上篇文章.net外包篇：我是如何看待外包的。从这家公司辞职以后，得益于我校园信息平台和高校信息管理的经验，我进入了一个互联网类型公司。以前的经历，环环相扣，步步提升。互联网时代第四家客户(未谈成)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fancunwei/p/9635036.html</dc:identifier>
</item>
<item>
<title>C#简单操作MongoDB - 陈惊蛰</title>
<link>http://www.cnblogs.com/pasoraku/p/9634946.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pasoraku/p/9634946.html</guid>
<description>&lt;p&gt;官网按需下载, 安装, 一步到位.&lt;/p&gt;

&lt;p&gt;创建一个.netcore console项目, 然后nuget安装驱动MongoDB.Driver&lt;/p&gt;

&lt;p&gt;在Program.Main函数中添加代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; client = &lt;span&gt;new&lt;/span&gt; MongoClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mongodb://127.0.0.1:27017&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; database = client.GetDatabase(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; collection = database.GetCollection&amp;lt;BsonDocument&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三个对象, client是连接数据库的客户端, database对应库, collection是对象集合.&lt;/p&gt;
&lt;p&gt;对对象的操作是争对collection来的.&lt;/p&gt;

&lt;h2&gt;1&amp;gt; 插入&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; document = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BsonDocument
            {
                { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试数据1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;大类&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt; },
                { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BsonDocument
                          {
                              { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;111&lt;/span&gt;&lt;span&gt; },
                              { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;222&lt;/span&gt;&lt;span&gt; }
                          }}
            };
collection.InsertOne(document);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同理还有InsertMany(), 鉴于VS高超的智能提示, 一目了然.&lt;/p&gt;
&lt;h2&gt;2&amp;gt; 查找&lt;/h2&gt;
&lt;p&gt;上一步插入之后, 通过find将它查找出来&lt;/p&gt;
&lt;p&gt;find()需要一个filter参数, 根据条件查询&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
collection.Find(Builders&amp;lt;BsonDocument&amp;gt;.Filter.Empty);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述表示无条件查询, matches everything.&lt;/p&gt;
&lt;p&gt;如果有条件的话, 可以从Builders&amp;lt;BsonDocument&amp;gt;.Filter中选择, 比如Eq为相等, Lt为小于, Gt大于...顾名思义. 基于VS强大的智能提示, 非常清晰.&lt;/p&gt;
&lt;p&gt;举例条件查询:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
collection.Find(Builders&amp;lt;BsonDocument&amp;gt;.Filter.Eq(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试数据1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;amp; Builders&amp;lt;BsonDocument&amp;gt;.Filter.Lt(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;多项条件之间的与或关系, 对应使用&amp;amp;和|符号&lt;/p&gt;
&lt;h2&gt;3&amp;gt; 更新&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
collection.UpdateMany(Builders&amp;lt;BsonDocument&amp;gt;.Filter.Eq(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试数据1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), Builders&amp;lt;BsonDocument&amp;gt;.Update.Set(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 6));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新使用UpdateMany(), 同样支持条件从Builders&amp;lt;BsonDocument&amp;gt;.Filter中获取.&lt;/p&gt;
&lt;p&gt;更新支持添加新的field, 如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
collection.UpdateMany(Builders&amp;lt;BsonDocument&amp;gt;.Filter.Eq(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试数据1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), Builders&amp;lt;BsonDocument&amp;gt;.Update.Set(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;number2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;666&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4&amp;gt; 删除&lt;/h2&gt;
&lt;p&gt;collection.DeleteMany()&lt;/p&gt;
&lt;p&gt;其他几个API大同小异&lt;/p&gt;

&lt;p&gt;不要引入Json.Net(Newtonsoft.Json)&lt;/p&gt;
&lt;h2&gt;1&amp;gt; 自定义类型到BsonDocument&lt;/h2&gt;
&lt;p&gt;　　扩展函数:&lt;/p&gt;
&lt;p&gt;　　　　entity.ToBsonDocument()&lt;/p&gt;
&lt;h2&gt;2&amp;gt; BsonDocument到自定义类型&lt;/h2&gt;
&lt;p&gt;　　通常是在Find的时候吧, IFindFluent.As&amp;lt;TEntity&amp;gt;()转就可以了. &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; collection
                .Find((Builders&lt;/span&gt;&amp;lt;BsonDocument&amp;gt;.Filter.Lt(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;999&lt;/span&gt;) &amp;amp; Builders&amp;lt;BsonDocument&amp;gt;.Filter.Gt(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;110&lt;/span&gt;)) &amp;amp; Builders&amp;lt;BsonDocument&amp;gt;.Filter.Eq(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试数据1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))&lt;br/&gt;　　　　　　　　　 .OrderBy(x=&amp;gt;x[&quot;number&quot;])//排序
                .Skip(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)//跳过
                .Limit(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;)//限制&lt;br/&gt;.As&amp;lt;Bar&amp;gt;&lt;span&gt;()//m=&amp;gt;o
                .ToList();//像极了Linq吧?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果不是呢?&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
var entity = BsonSerializer.Deserialize&amp;lt;Bar&amp;gt;(bson);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用到的自定义class大概长这样:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bar
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ObjectId _id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; type { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; number { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; number2 { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BarInfo info { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BarInfo
        {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; x { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; y { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;mongodb对程序员是极友好的, 可以动态变化的结构, 让程序员不再害怕频繁变动的需求. &lt;/p&gt;

</description>
<pubDate>Wed, 12 Sep 2018 07:15:00 +0000</pubDate>
<dc:creator>陈惊蛰</dc:creator>
<og:description>一 安装MongoDB 官网按需下载, 安装, 一步到位. 二 VS创建新项目 创建一个.netcore console项目, 然后nuget安装驱动MongoDB.Driver 三 建立连接 在Pr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pasoraku/p/9634946.html</dc:identifier>
</item>
<item>
<title>【翻译】使用Vuex解决Vue中的身份验证 - 婷风</title>
<link>http://www.cnblogs.com/jtjds/p/9634840.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jtjds/p/9634840.html</guid>
<description>&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;3&quot; readability=&quot;7.572192513369&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;这就是&lt;a href=&quot;https://vuex.vuejs.org/&quot; target=&quot;_blank&quot;&gt;Vuex&lt;/a&gt;的作用。 Vuex为&lt;a href=&quot;https://vuejs.org/&quot; target=&quot;_blank&quot;&gt;Vue.js&lt;/a&gt;应用管理状态.。对于应用中所有的组件来说，它被当做中央存储，并用规则确保状态只能以可预见的方式改变。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;4&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;对于经常检查本地存储来说，听起来是个更好的选择？让我们一起来探索下吧。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2 id=&quot;setting-up-the-application-modules&quot;&gt;&lt;span class=&quot;translate-inline&quot;&gt;建立应用模块&lt;/span&gt;&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;6&quot; readability=&quot;7.5321637426901&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;对于这个项目，我们想创建一个使用vuex和&lt;a href=&quot;https://router.vuejs.org/&quot; target=&quot;_blank&quot;&gt;vue-router&lt;/a&gt;的vue应用。我们会使用vue cli 3.0 来创建一个vue项目，并从选项中选择路由和vuex。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;7&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;执行下面的命令开始创建:&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
$ vue create vue-auth
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;8&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;按照对话框的提示，添加必要的信息，并选择我们需要的选项，完成安装。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;9&quot; readability=&quot;5.4&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;下一步, 安装&lt;a href=&quot;https://github.com/axios/axios&quot; target=&quot;_blank&quot;&gt;axios&lt;/a&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
$ npm install axios --save
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h3 id=&quot;setup-axios&quot;&gt;&lt;span class=&quot;translate-inline&quot;&gt;配置Axios&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;11&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;我们在许多组件中都需要用到axios。让我们在全局整体来配置它，这样当我们需要它的时候，不用每次都去引入。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;12&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;打开 &lt;code&gt;./src/main.js&lt;/code&gt; 文件，并且添加下面:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
[...]
import store from './store'
import Axios from 'axios'

Vue.prototype.$http = Axios;
const token = localStorage.getItem('token')
if (token) {
  Vue.prototype.$http.defaults.headers.common['Authorization'] = token
}
[...]
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;13&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;现在，当我们想在组件内使用axios时, 我们可以用&lt;code&gt;this.$http&lt;/code&gt; ，这样相当于直接是axios。我们也可以在axios头部给自己的token, 设置&lt;code&gt;身份验证&lt;/code&gt;，这样如果token是必需的，我们的请求将处于控制中。在这种方式下，当我们想要发送请求时，任何时候都不用设置token。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;15&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;完成之后，让我们使用服务器来处理身份验证。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2 id=&quot;setting-up-the-server-for-authentication&quot;&gt;&lt;span class=&quot;translate-inline&quot;&gt;创建身份验证服务&lt;/span&gt;&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;17&quot; readability=&quot;6.8321167883212&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;我已经写过关于这个，在我解释如何用vue-router来解决身份验证时。仔细看看&lt;a href=&quot;https://scotch.io/tutorials/vue-authentication-and-route-handling-using-vue-router#toc-setup-nodejs-server&quot; target=&quot;_blank&quot;&gt;Setup Node.js Server&lt;/a&gt; 这个章节。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2 id=&quot;setup-components&quot;&gt;&lt;span class=&quot;translate-inline&quot;&gt;创建组件&lt;/span&gt;&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;h3 id=&quot;the-login-component&quot;&gt;&lt;span class=&quot;translate-inline&quot;&gt;登录组件&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;20&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;创建&lt;code&gt;Login.vue&lt;/code&gt; 在 &lt;code&gt;./src/components&lt;/code&gt; 目录下。 之后, 给登录页面添加模板:&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
 &amp;lt;div&amp;gt;
   &amp;lt;form class=&quot;login&quot; @submit.prevent=&quot;login&quot;&amp;gt;
     &amp;lt;h1&amp;gt;Sign in&amp;lt;/h1&amp;gt;
     &amp;lt;label&amp;gt;Email&amp;lt;/label&amp;gt;
     &amp;lt;input required v-model=&quot;email&quot; type=&quot;email&quot; placeholder=&quot;Name&quot;/&amp;gt;
     &amp;lt;label&amp;gt;Password&amp;lt;/label&amp;gt;
     &amp;lt;input required v-model=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;Password&quot;/&amp;gt;
     &amp;lt;hr/&amp;gt;
     &amp;lt;button type=&quot;submit&quot;&amp;gt;Login&amp;lt;/button&amp;gt;
   &amp;lt;/form&amp;gt;
 &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;21&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;当你做完之后, 添加data属性，将其绑定到HTML表单中：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
[...]
&amp;lt;script&amp;gt;
  export default {
    data(){
      return {
        email : &quot;&quot;,
        password : &quot;&quot;
      }
    },
  }
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;22&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;现在, 让我们给登录添加方法：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
[...]
&amp;lt;script&amp;gt;
  export default {
    [...]
    methods: {
      login: function () {
        let email = this.email 
        let password = this.password
        this.$store.dispatch('login', { email, password })
       .then(() =&amp;gt; this.$router.push('/'))
       .catch(err =&amp;gt; console.log(err))
      }
    }
  }
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;23&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;我们正在使用vuex的action — &lt;code&gt;login&lt;/code&gt; 来解决身份验证。我们可以在将actions细化到回调里面，这样就可以在自己的组件里面做一些很酷的事情了。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h3 id=&quot;the-register-component&quot;&gt;&lt;span class=&quot;translate-inline&quot;&gt;注册组件&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;25&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;跟login组件类似，那我们给注册用户弄一个了。在组件目录里面创建&lt;code&gt;Register.vue&lt;/code&gt; ，并将下面的添加进去：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h4&amp;gt;Register&amp;lt;/h4&amp;gt;
    &amp;lt;form @submit.prevent=&quot;register&quot;&amp;gt;
      &amp;lt;label for=&quot;name&quot;&amp;gt;Name&amp;lt;/label&amp;gt;
      &amp;lt;div&amp;gt;
          &amp;lt;input id=&quot;name&quot; type=&quot;text&quot; v-model=&quot;name&quot; required autofocus&amp;gt;
      &amp;lt;/div&amp;gt;

      &amp;lt;label for=&quot;email&quot; &amp;gt;E-Mail Address&amp;lt;/label&amp;gt;
      &amp;lt;div&amp;gt;
          &amp;lt;input id=&quot;email&quot; type=&quot;email&quot; v-model=&quot;email&quot; required&amp;gt;
      &amp;lt;/div&amp;gt;

      &amp;lt;label for=&quot;password&quot;&amp;gt;Password&amp;lt;/label&amp;gt;
      &amp;lt;div&amp;gt;
          &amp;lt;input id=&quot;password&quot; type=&quot;password&quot; v-model=&quot;password&quot; required&amp;gt;
      &amp;lt;/div&amp;gt;

      &amp;lt;label for=&quot;password-confirm&quot;&amp;gt;Confirm Password&amp;lt;/label&amp;gt;
      &amp;lt;div&amp;gt;
          &amp;lt;input id=&quot;password-confirm&quot; type=&quot;password&quot; v-model=&quot;password_confirmation&quot; required&amp;gt;
      &amp;lt;/div&amp;gt;

      &amp;lt;div&amp;gt;
          &amp;lt;button type=&quot;submit&quot;&amp;gt;Register&amp;lt;/button&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/form&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;26&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;让我们定义一下这些将绑定到表单里面的data属性:&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
[...]
&amp;lt;script&amp;gt;
  export default {
    data(){
      return {
        name : &quot;&quot;,
        email : &quot;&quot;,
        password : &quot;&quot;,
        password_confirmation : &quot;&quot;,
        is_admin : null
      }
    },
  }
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;27&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;现在，让我们添加方法进去：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
[...]
&amp;lt;script&amp;gt;
  export default {
    [...]
    methods: {
      register: function () {
        let data = {
          name: this.name,
          email: this.email,
          password: this.password,
          is_admin: this.is_admin
        }
        this.$store.dispatch('register', data)
       .then(() =&amp;gt; this.$router.push('/'))
       .catch(err =&amp;gt; console.log(err))
      }
    }
  }
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h3 id=&quot;the-secure-component&quot;&gt;&lt;span class=&quot;translate-inline&quot;&gt;安全组件&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;29&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;让我们创建一个普通的组件，它在用户通过验证后会显示。文件命名为&lt;code&gt;Secure.vue&lt;/code&gt;，并添加下面的进去：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h1&amp;gt;This page is protected by auth&amp;lt;/h1&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
更新App组件
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;31&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;打开&lt;code&gt;./src/App.vue&lt;/code&gt; 文件，并添加下面的进去:&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;div id=&quot;nav&quot;&amp;gt;
      &amp;lt;router-link to=&quot;/&quot;&amp;gt;Home&amp;lt;/router-link&amp;gt; |
      &amp;lt;router-link to=&quot;/about&quot;&amp;gt;About&amp;lt;/router-link&amp;gt;&amp;lt;span v-if=&quot;isLoggedIn&quot;&amp;gt; | &amp;lt;a @click=&quot;logout&quot;&amp;gt;Logout&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;router-view/&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;32&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;如果用户登录进去后，你能看到关联的&lt;code&gt;Logout&lt;/code&gt;了 吗？很好。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;33&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;现在，让我们给logout添加逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;script&amp;gt;
  export default {
    computed : {
      isLoggedIn : function(){ return this.$store.getters.isLoggedIn}
    },
    methods: {
      logout: function () {
        this.$store.dispatch('logout')
        .then(() =&amp;gt; {
          this.$router.push('/login')
        })
      }
    },
  }
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;34&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;当用户点击退出按钮时，我们其实在做两件事 — 计算用户验证的状态和分发vuex store里面的退出事件。在退出之后，我们利用 &lt;code&gt;this.$router.push('/login')&lt;/code&gt;，切换用户到 &lt;code&gt;login&lt;/code&gt;页面。当然你可以改变任何你想让用户跳转的地方。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;35&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;就是这样了。让我们用vuex构建权限模块。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2 id=&quot;vuex-auth-module&quot;&gt;&lt;span class=&quot;translate-inline&quot;&gt;Vuex权限模块&lt;/span&gt;&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;37&quot; readability=&quot;9.0740740740741&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;如果你读过以前的&lt;a href=&quot;https://scotch.io/tutorials/vue-authentication-and-route-handling-using-vue-router#toc-setup-nodejs-server&quot; target=&quot;_blank&quot;&gt;Setup Node.js Server&lt;/a&gt; **部分, 你应该注意到我们需要在本地存储用户权限token，同时，当用户被授予权限后，我们随时需要重新得到token以及用户信息。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;38&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;首先, 让我们给vuex创建 &lt;code&gt;store.js&lt;/code&gt;文件:&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
import Vue from 'vue'
import Vuex from 'vuex'
import axios from 'axios'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    status: '',
    token: localStorage.getItem('token') || '',
    user : {}
  },
  mutations: {

  },
  actions: {

  },
  getters : {

  }
})
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;39&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;如果你注意到，我们同时引入了vue,vuex和axios，之后让vue使用vuex，这是因为它是很重要的一步。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;40&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;我们已经定义了state的属性。现在vuex的state能够支持验证状态， &lt;code&gt;jwt&lt;/code&gt; token以及用户信息。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h3 id=&quot;create-the-vuex-login-action&quot;&gt;&lt;span class=&quot;translate-inline&quot;&gt;创建Vuex登录事件&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;42&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;Vuex actions里面主要是提交更改到vuex的store里面。我们将创建一个&lt;code&gt;login&lt;/code&gt; 的action，它将使用服务器对用户进行身份验证，并向vuex存储提交用户凭据。打开&lt;code&gt;./src/store.js&lt;/code&gt;文件，并添加下面到actions对象中：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
login({commit}, user){
    return new Promise((resolve, reject) =&amp;gt; {
      commit('auth_request')
      axios({url: 'http://localhost:3000/login', data: user, method: 'POST' })
      .then(resp =&amp;gt; {
        const token = resp.data.token
        const user = resp.data.user
        localStorage.setItem('token', token)
        axios.defaults.headers.common['Authorization'] = token
        commit('auth_success', token, user)
        resolve(resp)
      })
      .catch(err =&amp;gt; {
        commit('auth_error')
        localStorage.removeItem('token')
        reject(err)
      })
    })
},
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;43&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;登录action通过vuex &lt;code&gt;commit&lt;/code&gt;验证，我们将用它进行触发更改。vuex store里面能记录这些更改的变化。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;44&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;我们正在调用服务器的登录路径并返回必要的数据。我们在本地存储token，之后通过&lt;code&gt;auth_success&lt;/code&gt;来更新存储用户信息和token。在这一点上，我们也在头部设置了&lt;code&gt;axios&lt;/code&gt; 。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;45&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;我们可以在vuex store中存储token，但是如果用户离开我们的应用，所有在vuex里面的存储都将消失。为了确保用户在有效时间内不用再重复登录，我们只能将token进行本地存储。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;46&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;重要的是你知道这些是如何工作的，这样你就能决定你到底想要实现什么。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;47&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;我们返回一个promise，这样我们能在用户登录完成后，做出响应。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h3 id=&quot;create-the-vuex-register-action&quot;&gt;&lt;span class=&quot;translate-inline&quot;&gt;创建Vuex&lt;code&gt;注册&lt;/code&gt;事件&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;49&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;像 &lt;code&gt;login&lt;/code&gt; 事件, the &lt;code&gt;register&lt;/code&gt; 事件是同一种工作方式。在相同的文件中，添加下面的到actions对象里面:&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
register({commit}, user){
  return new Promise((resolve, reject) =&amp;gt; {
    commit('auth_request')
    axios({url: 'http://localhost:3000/register', data: user, method: 'POST' })
    .then(resp =&amp;gt; {
      const token = resp.data.token
      const user = resp.data.user
      localStorage.setItem('token', token)
      axios.defaults.headers.common['Authorization'] = token
      commit('auth_success', token, user)
      resolve(resp)
    })
    .catch(err =&amp;gt; {
      commit('auth_error', err)
      localStorage.removeItem('token')
      reject(err)
    })
  })
},
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;50&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;它与&lt;code&gt;login&lt;/code&gt; 事件工作方式很像,。称之为有共同的mutators的 &lt;code&gt;login&lt;/code&gt; 和&lt;code&gt;register&lt;/code&gt; ，具有相同的目标——让用户进入系统。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h3 id=&quot;create-the-vuex-logout-action&quot;&gt;&lt;span class=&quot;translate-inline&quot;&gt;创建Vuex&lt;code&gt;退出&lt;/code&gt;事件&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;52&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;我们希望用户能够退出系统，同时，我们希望销毁上一次验证的会话数据。在同一个&lt;code&gt;actions&lt;/code&gt;对象中，添加下面：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
logout({commit}){
  return new Promise((resolve, reject) =&amp;gt; {
    commit('logout')
    localStorage.removeItem('token')
    delete axios.defaults.headers.common['Authorization']
    resolve()
  })
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;53&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;现在，当用户点击退出时，我们将移除之前在 &lt;code&gt;axios&lt;/code&gt;头部设置的&lt;code&gt;jwt&lt;/code&gt; token 。他们现在将无法执行需要token的事务。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h3 id=&quot;create-the-mutations&quot;&gt;&lt;span class=&quot;translate-inline&quot;&gt;创建Mutations&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;55&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;像我之前提到的，mutators是被用来改变vuex store的状态。让我们在应用中给用过的mutators定义。在mutators对象中，添加下面的：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
mutations: {
  auth_request(state){
    state.status = 'loading'
  },
  auth_success(state, token, user){
    state.status = 'success'
    state.token = token
    state.user = user
  },
  auth_error(state){
    state.status = 'error'
  },
  logout(state){
    state.status = ''
    state.token = ''
  },
},
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h3 id=&quot;create-the-getters&quot;&gt;&lt;span class=&quot;translate-inline&quot;&gt;创建Getters&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;57&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;我们使用getter来获取vuex状态中的属性值。在这种情况下，getter的作用是将应用程序数据与应用程序逻辑分离，并确保我们不会泄露敏感信息。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;58&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;添加下面的到&lt;code&gt;getters&lt;/code&gt; 对象中:&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
getters : {
  isLoggedIn: state =&amp;gt; !!state.token,
  authStatus: state =&amp;gt; state.status,
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;59&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;你会同意我的观点，这是一种更简洁的访问存储数据的方式☺️.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2 id=&quot;hide-pages-behind-auth&quot;&gt;&lt;span class=&quot;translate-inline&quot;&gt;在Auth后面隐藏页面&lt;/span&gt;&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;61&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;这篇文章的整个目的是实现身份验证，让没有权限的用户看不到某些页面。为了实现这个，我们需要知道用户想要访问的页面，以及当用户被授权时，我们有一定的方法来检验它。我们同时需要一定的方式，如果某些页面，授权或者未授权的用户可以单独或者同时访问的。这些都是很重要的考虑条件，幸运地是，我们可以通过vue-router来说实现。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h3 id=&quot;defiing-routes-for-authenticated-and-unauthenticated-pages&quot;&gt;&lt;span class=&quot;translate-inline&quot;&gt;定义路由给授权和未授权的页面&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;63&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;打开 &lt;code&gt;./src/router.js&lt;/code&gt; 文件，并引入我们需要的这些:&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
import Vue from 'vue'
import Router from 'vue-router'
import store from './store.js'
import Home from './views/Home.vue'
import About from './views/About.vue'
import Login from './components/Login.vue'
import Secure from './components/Secure.vue'
import Register from './components/Register.vue'

Vue.use(Router)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;64&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;正如你看到的这样，我们已经引入vue,vue-router和我们创建的vuex。我们同时还引入了定义的所有组件，并设置vue中使用路由。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;65&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;让我们定义路由:&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
[...]
let router = new Router({
  mode: 'history',
  routes: [
    {
      path: '/',
      name: 'home',
      component: Home
    },
    {
      path: '/login',
      name: 'login',
      component: Login
    },
    {
      path: '/register',
      name: 'register',
      component: Register
    },
    {
      path: '/secure',
      name: 'secure',
      component: Secure,
      meta: { 
        requiresAuth: true
      }
    },
    {
      path: '/about',
      name: 'about',
      component: About
    }
  ]
})

export default router
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;66&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;我们路由的定义是很普遍的。对于需要权限验证的路由，我们需要增加额外的数据，确保当用户访问它时，我们可以识别它。这是添加到路由定义中的元属性的本质。如果你想问_”我可以添加更过的数据给元数据并使用它吗?”，我很坚定的告诉你，这是绝对的😁。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h3 id=&quot;handling-unauthorized-access-cases&quot;&gt;&lt;span class=&quot;translate-inline&quot;&gt;解决未授权访问示例&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;68&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;我们有自己的路由定义。现在，让我们检验未授权访问并采取行动。在 &lt;code&gt;router.js&lt;/code&gt;文件中，添加下面的在 &lt;code&gt;export default router&lt;/code&gt;之前：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
router.beforeEach((to, from, next) =&amp;gt; {
  if(to.matched.some(record =&amp;gt; record.meta.requiresAuth)) {
    if (store.getters.isLoggedIn) {
      next()
      return
    }
    next('/login') 
  } else {
    next() 
  }
})
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;69&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;从这篇文章，通过使用vue router来进行身份验证，你可以回想一下我们这里有一个非常复杂的机制，它变得非常大，变得非常混乱。vuex已经帮我们简化了它，我们可以继续给路由添加任何条件。在我们的vuex存储中，我们可以定义操作来检查这些条件并获取返回它们的值。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h3 id=&quot;handling-expired-token-cases&quot;&gt;&lt;span class=&quot;translate-inline&quot;&gt;解决Token过期示例&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;71&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;因为我们在本地存储token,它可以一直保留着。这意味着无论何时，我们打开自己的应用，它可以自动的验证用户，即使token已经过期失效。最多的情况是，我们的请求会因为无效token而持续失败。这对于用户是个不好的体验。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;72&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;现在, 打开&lt;code&gt;./src/App.vue&lt;/code&gt; 文件并在script里面，添加下面的：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
export default {
  [...]
  created: function () {
    this.$http.interceptors.response.use(undefined, function (err) {
      return new Promise(function (resolve, reject) {
        if (err.status === 401 &amp;amp;&amp;amp; err.config &amp;amp;&amp;amp; !err.config.__isRetryRequest) {
          this.$store.dispatch(logout)
        }
        throw err;
      });
    });
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;73&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;我们截获axios请求，已确定是否获取到&lt;code&gt;401未授权&lt;/code&gt;响应。如果这么做，我们分发 &lt;code&gt;logout&lt;/code&gt; 事件，那么用户获得退出应用。这会让用户跳转到之前设计的 &lt;code&gt;login&lt;/code&gt;页面，这样他们可以再次登录。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;74&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;我赞同这样会提升用户体验 ☺️.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;&lt;span class=&quot;translate-inline&quot;&gt;结束&lt;/span&gt;&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;76&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline highlighted&quot;&gt;从以前的文章来看，您可以看到，基于vuex的引入，我们目前的应用程序发生了重大变化。现在，我们不依赖于一直检查token，不管到哪里都有混乱的条件。我们可以简单地使用vuex存储来管理权限，并且只需使用几行代码检查应用程序中的状态。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;77&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;我希望这可以帮助您建立更好的应用。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 12 Sep 2018 07:11:00 +0000</pubDate>
<dc:creator>婷风</dc:creator>
<og:description>翻译原文链接：https://scotch.io/tutorials/handling-authentication-in-vue-using-vuex 我的翻译小站：https://www.zcfy</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jtjds/p/9634840.html</dc:identifier>
</item>
<item>
<title>流畅的python(笔记) - 从零开始的程序员生活</title>
<link>http://www.cnblogs.com/lgjbky/p/9634773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lgjbky/p/9634773.html</guid>
<description>&lt;p&gt;流畅的python中有很多奇技淫巧，整本书都在强调如何最大限度地利用Python 标准库。介绍了很多python的不常用的数据类型、操作、库等，对于入门python后想要提升对python的认识应该有帮助。目前读一遍记录了一些有共鸣的操作:&lt;/p&gt;
&lt;h4 id=&quot;python内置序列类型的主要分类&quot;&gt;Python内置序列类型的主要分类:&lt;/h4&gt;
&lt;p&gt;按可存放的元素类型分为：容器序列和扁平序列&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;容器序列，就是什么都能作为元素往里放，包括另一个序列。需要注意的是，如果元素是序列类型，那么存放的往往是引用，需要小心。&lt;br/&gt;常见的容器序列包括：list，tuple，array.array，collections.deque等。&lt;/li&gt;
&lt;li&gt;扁平序列，存放的都是原子级元素，此时存放的是值而不会是引用。&lt;br/&gt;常见的扁平序列包括：str，bytes，bytearray, memoryview, array.array等。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;按序列能否被修改分为：可变序列与不可变序列&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可变序列：可以进行增、删、改等操作的序列，包括list, bytearray, array.array, collections.deque, memoryview等。&lt;/li&gt;
&lt;li&gt;不可变序列：不可进行上述操作的序列，包括tuple, str, bytes等。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;字典的变种&quot;&gt;字典的变种&lt;/h4&gt;
&lt;p&gt;标准库里collections模块中提供了很多与字典类型相似的变种。&lt;/p&gt;
&lt;p&gt;OrderDict： 这个类型在添加键的时候，会保存顺序，因此键的迭代顺序总是一致的&lt;/p&gt;
&lt;p&gt;ChainMap： 该类型可以容纳数个不同的映射对像，在进行键的查找时，这些对象会被当做一个整体逐个查找，直到键被找到为止&lt;/p&gt;
&lt;p&gt;Counter： 这个映射类型会给键准备一个整数技术器，每次更行一个键的时候都会增加这个计数器，所以这个类型可以用来给散列表对象计数，或者当成多重集来用。&lt;/p&gt;
&lt;p&gt;UserDict： 这个类其实就是把标准的dict用Python又写了一遍。一般用来给程序员想要通过继承dict创建自己的dict时，代替dict使用的。主要是因为直接继承原生dict会出现bug。&lt;/p&gt;
&lt;p&gt;defaultdict：处理找不到的键的一个选择&lt;br/&gt;当某个键不在映射里, 我们也希望也能得到一个默认值. 这就是 defaultdict , 它是 dict 的子类, 并实现了 &lt;strong&gt;missing&lt;/strong&gt; 方法.&lt;/p&gt;
&lt;h4 id=&quot;dict的实现以及导致的结果&quot;&gt;dict的实现以及导致的结果&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;键必须是可散列的:
一个可散列的对象必须满足以下要求。
    (1) 支持 hash() 函数，并且通过 __hash__() 方法所得到的散列值是不变的。
    (2) 支持通过 __eq__() 方法来检测相等性。
    (3) 若 a == b 为真，则 hash(a) == hash(b) 也为真。
    所有由用户自定义的对象默认都是可散列的，因为它们的散列值由 id() 来获取，而
    且它们都是不相等的。
字典在内存上开销很大（用内存换效率）。
    元组取代字典就能节省空间的原因有两个：
    (1) 避免了散列表所耗费的空间，
    (2) 无需把记录中字段的名字在每个元素里都存一遍。
键的查询很快
键的次序取决于添加顺序
往字典里添加新键可能会改变已有键的顺序&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;set的实现以及导致的结果&quot;&gt;set的实现以及导致的结果&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;结合的元素必须是可散列的
集合和消耗内存
可以很高效的判断元素是否存在于某个集合
元素的次序取决于被添加到集合里的顺序
往集合里添加元素，可能会改变集合里已有的元素次序&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;collections.namedtuple-可以用来构建一个带字段名的元组和一个有名字的类&quot;&gt;collections.namedtuple 可以用来构建一个带字段名的元组和一个有名字的类&lt;/h4&gt;
&lt;p&gt;创建一个具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字。后者&lt;br/&gt;可以是由数个字符串组成的可迭代对象，或者是由空格分隔开的字段名组成的字符串。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from collections import namedtuple
&amp;gt;&amp;gt;&amp;gt; City = namedtuple('City', 'name country population coordinates')
&amp;gt;&amp;gt;&amp;gt; tokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667)) 
&amp;gt;&amp;gt;&amp;gt; tokyo
City(name='Tokyo', country='JP', population=36.933, coordinates=(35.689722,
139.691667))
&amp;gt;&amp;gt;&amp;gt; tokyo.population 
36.933
&amp;gt;&amp;gt;&amp;gt; tokyo.coordinates
(35.689722, 139.691667)
&amp;gt;&amp;gt;&amp;gt; tokyo[1]
'JP'

&amp;gt;&amp;gt;&amp;gt; City = namedtuple('City_Name', 'name country population coordinates')
&amp;gt;&amp;gt;&amp;gt; tokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667))
&amp;gt;&amp;gt;&amp;gt; tokyo
City_Name(name='Tokyo', country='JP', population=36.933, coordinates=(35.689722, 139.691667))&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;当列表不是首选时&quot;&gt;当列表不是首选时&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;如果我们需要一个只包含数字的列表，那么 array.array 比 list 更高效。数组支持所&lt;br/&gt;有跟可变序列有关的操作，包括 .pop、.insert 和 .extend。另外，数组还提供从文件&lt;br/&gt;读取和存入文件的更快的方法，如 .frombytes 和 .tofile。&lt;/li&gt;
&lt;li&gt;set 专为检查元素是否存在做过优化&lt;/li&gt;
&lt;li&gt;memoryview 是一个内置类，它能让用户在不复制内容的情况下操作同一个数组的不同切&lt;br/&gt;片。&lt;/li&gt;
&lt;li&gt;使用NumPy和SciPy提供的高阶数组和矩阵操作&lt;/li&gt;
&lt;li&gt;使用双向队列和其他形式的队列(collections.deque 双向队列类、queue类中的 Queue、LifoQueue和PriorityQueue、multiprocessing. Queue、heapq可以把可变序列当作堆队列或者优先队列来使用)&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;python-格式化输出&quot;&gt;Python 格式化输出&lt;/h4&gt;
&lt;p&gt;在进行格式化输出时，%r 与 %s 的区别就好比 repr() 函数处理对象与 str() 函数处理对象的差别。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;%s -&amp;gt; str()，比较智能；&lt;/li&gt;
&lt;li&gt;%r -&amp;gt; repr()，处理较为简单和直接； 处理一些简单对象时，二者几乎没有差别.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文重点列举一些二者的差异化用法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;处理字符串时&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt; s = 'world'

&amp;gt;&amp;gt; print('hello %s'%s)
hello world
&amp;gt;&amp;gt; print('hello %r'%s)
hello 'world'

&amp;gt;&amp;gt; str(s)
'world'
&amp;gt;&amp;gt; repr(s)
&quot;'world'&quot;
2. datetime 库中的 datetime 对象
&amp;gt;&amp;gt; from datetime import datetime 
&amp;gt;&amp;gt; timeinfo = datetime.today()

&amp;gt;&amp;gt; timeinfo
datetime.datetime(2016, 6, 7, 21, 17, 34, 925488)
&amp;gt;&amp;gt; type(timeinfo)
datetime.datetime

&amp;gt;&amp;gt; repr(timeinfo)
'datetime.datetime(2016, 6, 7, 21, 17, 34, 925488)'
&amp;gt;&amp;gt; str(timeinfo)
'2016-06-07 21:17:34.925488'&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;反汇编函数-python-opcode&quot;&gt;反汇编函数 python opcode&lt;/h4&gt;
&lt;p&gt;Python dis 模块支持对Python代码进行反汇编， 生成字节码指令。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In[1]: def test():
...         x = 1
...         if x &amp;lt; 3:
...             return &quot;yes&quot;
...         else:
...             return &quot;no&quot;

In[2]: dis.dis(test)
  2           0 LOAD_CONST               1 (1)
              3 STORE_FAST               0 (x)
 
  3           6 LOAD_FAST                0 (x)
              9 LOAD_CONST               2 (3)
             12 COMPARE_OP               0 (&amp;lt;)
             15 POP_JUMP_IF_FALSE       22
 
  4          18 LOAD_CONST               3 ('yes')
             21 RETURN_VALUE        
 
  6     &amp;gt;&amp;gt;   22 LOAD_CONST               4 ('no')
             25 RETURN_VALUE        
             26 LOAD_CONST               0 (None)
             29 RETURN_VALUE        

&amp;gt;&amp;gt;&amp;gt; def add(a, b = 0):
...     return a + b
... 
&amp;gt;&amp;gt;&amp;gt; 

&amp;gt;&amp;gt;&amp;gt; dis.dis(add)
  2           0 LOAD_FAST                0 (a)
              2 LOAD_FAST                1 (b)
              4 BINARY_ADD
              6 RETURN_VALUE
&amp;gt;&amp;gt;&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;class memoryview(obj)是python的内置类，如果要用memoryview 去引用一个object, 那么这个object 必须支持buffer protocol, python3 中原生（built-in) 支持buffer protocol的obj有bytes和bytearray，memoryview可以使用不同的方式读取和操作同一块内存，并且原有的内存字节不会随意移动。类似于C中的强转，好处是不会有内存拷贝。&lt;/p&gt;
&lt;p&gt;例如，使用memoryview修改一个短整型有符号整数数组的数据。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from array import array
from random import random

numbers = array('h', [-2, -1, 0, 1, 2]) #signed short
memv = memoryview(numbers)      #5个短整型有符号整数的数组创建一个memoryview
print (len(memv))               #打印长度
print (memv.tolist())           #转换成列表形式

memv_oct = memv.cast('B')       #内存共享 转换成无符号字符类型
print (memv_oct.tolist())

memv_oct[5] = 4                 #把位置5的字节赋值成4
print (numbers)                 #因为我们把占 2 个字节的整数的高位字节改成了 4，所以这个有符号整数的值就变成了 1024

输出如下：

5                       #数组长度
[-2, -1, 0, 1, 2]       #列表形式显示
[254, 255, 255, 255, 0, 0, 1, 0, 2, 0]#长度扩大一倍 转换为无符号字符类型
array('h', [-2, -1, 1024, 1, 2])   #原来的数组被修改
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;bytearray是可变(mutable)的字节序列，相对于Python2中的str，但str是不可变(immutable)的。&lt;br/&gt;在Python3中由于str默认是unicode编码，所以只有通过bytearray才能按字节访问。&lt;br/&gt;下面两种行为的对比：&lt;br/&gt;简单点就是，str和bytearray的切片操作会产生新的切片str和bytearry并拷贝数据，使用memoryview之后不会。&lt;/p&gt;
&lt;p&gt;python2中的例子&lt;/p&gt;
&lt;h5 id=&quot;不使用memoryview&quot;&gt;不使用memoryview&lt;/h5&gt;
&lt;blockquote readability=&quot;4&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;a = 'aaaaaa'&lt;br/&gt;b = a[:2] # 会产生新的字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;4.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;a = bytearray('aaaaaa')&lt;br/&gt;b = a[:2] # 会产生新的bytearray&lt;br/&gt;b[:2] = 'bb' # 对b的改动不影响a&lt;br/&gt;a&lt;br/&gt;bytearray(b'aaaaaa')&lt;br/&gt;b&lt;br/&gt;bytearray(b'bb')&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;使用memoryview&quot;&gt;使用memoryview&lt;/h5&gt;
&lt;blockquote readability=&quot;4.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;a = 'aaaaaa'&lt;br/&gt;ma = memoryview(a)&lt;br/&gt;ma.readonly # 只读的memoryview&lt;br/&gt;True&lt;br/&gt;mb = ma[:2] # 不会产生新的字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;a = bytearray('aaaaaa')&lt;br/&gt;ma = memoryview(a)&lt;br/&gt;ma.readonly # 可写的memoryview&lt;br/&gt;False&lt;br/&gt;mb = ma[:2] # 不会会产生新的bytearray&lt;br/&gt;mb[:2] = 'bb' # 对mb的改动就是对ma的改动&lt;br/&gt;mb.tobytes()&lt;br/&gt;'bb'&lt;br/&gt;ma.tobytes()&lt;br/&gt;'bbaaaa'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;Python 中有各种各样可调用的类型，因此判断置的 callable() 函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; abs, str, 13
(&amp;lt;built-in function abs&amp;gt;, &amp;lt;class 'str'&amp;gt;, 13)
&amp;gt;&amp;gt;&amp;gt; [callable(obj) for obj in (abs, str, 13)]
[True, True, False]&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;random.shuffle-打乱序列&quot;&gt;random.shuffle 打乱序列&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import random
&amp;gt;&amp;gt;&amp;gt; a=range(10)
&amp;gt;&amp;gt;&amp;gt; random.shuffle(a)
&amp;gt;&amp;gt;&amp;gt; a
[1, 0, 8, 5, 6, 7, 9, 3, 2, 4]
&amp;gt;&amp;gt;&amp;gt; random.shuffle(a)
&amp;gt;&amp;gt;&amp;gt; a
[7, 5, 6, 2, 1, 8, 9, 0, 3, 4]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;vim常用快捷&quot;&gt;vim常用快捷&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;0 → 数字零，到行头&lt;/li&gt;
&lt;li&gt;$ → 到本行行尾&lt;/li&gt;
&lt;li&gt;a → 在光标后插入&lt;/li&gt;
&lt;li&gt;o → 在当前行后插入一个新行&lt;/li&gt;
&lt;li&gt;O → 在当前行前插入一个新行&lt;/li&gt;
&lt;li&gt;cw → 替换从光标所在位置后到一个单词结尾的字符&lt;/li&gt;
&lt;li&gt;. → (小数点) 可以重复上一次的命令&lt;/li&gt;
&lt;li&gt;NG → 到第 N 行 （注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）&lt;/li&gt;
&lt;li&gt;gg → 到第一行。（相当于1G，或 :1）&lt;/li&gt;
&lt;li&gt;G → 到最后一行。&lt;/li&gt;
&lt;li&gt;在 Insert 模式下，你可以输入一个词的开头，然后按或是，自动补齐功能就出现了…&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;内置函数&quot;&gt;内置函数&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;Math
Function    Description
abs()   Returns absolute value of a number
divmod()    Returns quotient and remainder of integer division
max()   Returns the largest of the given arguments or items in an iterable
min()   Returns the smallest of the given arguments or items in an iterable
pow()   Raises a number to a power
round() Rounds a floating-point value
sum()   Sums the items of an iterable

Type Conversion
Function    Description
ascii() Returns a string containing a printable representation of an object
bin()   Converts an integer to a binary string
bool()  Converts an argument to a Boolean value
chr()   Returns string representation of character given by integer argument
complex()   Returns a complex number constructed from arguments
float() Returns a floating-point object constructed from a number or string
hex()   Converts an integer to a hexadecimal string
int()   Returns an integer object constructed from a number or string
oct()   Converts an integer to an octal string
ord()   Returns integer representation of a character
repr()  Returns a string containing a printable representation of an object
str()   Returns a string version of an object
type()  Returns the type of an object or creates a new type object

Iterables and Iterators
Function    Description
all()   Returns True if all elements of an iterable are true
any()   Returns True if any elements of an iterable are true
enumerate() Returns a list of tuples containing indices and values from an iterable
filter()    Filters elements from an iterable
iter()  Returns an iterator object
len()   Returns the length of an object
map()   Applies a function to every item of an iterable
next()  Retrieves the next item from an iterator
range() Generates a range of integer values
reversed()  Returns a reverse iterator
slice() Returns a slice object
sorted()    Returns a sorted list from an iterable
zip()   Creates an iterator that aggregates elements from iterables

Composite Data Type
Function    Description
bytearray() Creates and returns an object of the bytearray class
bytes() Creates and returns a bytes object (similar to bytearray, but immutable)
dict()  Creates a dict object
frozenset() Creates a frozenset object
list()  Constructs a list object
object()    Returns a new featureless object
set()   Creates a set object
tuple() Creates a tuple object

Classes, Attributes, and Inheritance
Function    Description
classmethod()   Returns a class method for a function
delattr()   Deletes an attribute from an object
getattr()   Returns the value of a named attribute of an object
hasattr()   Returns True if an object has a given attribute
isinstance()    Determines whether an object is an instance of a given class
issubclass()    Determines whether a class is a subclass of a given class
property()  Returns a property value of a class
setattr()   Sets the value of a named attribute of an object
super() Returns a proxy object that delegates method calls to a parent or sibling class

Input/Output
Function    Description
format()    Converts a value to a formatted representation
input() Reads input from the console
open()  Opens a file and returns a file object
print() Prints to a text stream or the console

Variables, References, and Scope
Function    Description
dir()   Returns a list of names in current local scope or a list of object attributes
globals()   Returns a dictionary representing the current global symbol table
id()    Returns the identity of an object
locals()    Updates and returns a dictionary representing current local symbol table
vars()  Returns __dict__ attribute for a module, class, or object

Miscellaneous
Function    Description
callable()  Returns True if object appears callable
compile()   Compiles source into a code or AST object
eval()  Evaluates a Python expression
exec()  Implements dynamic execution of Python code
hash()  Returns the hash value of an object
help()  Invokes the built-in help system
memoryview()    Returns a memory view object
staticmethod()  Returns a static method for a function
__import__()    Invoked by the import statement&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;跟运算符无关的特殊方法&quot;&gt;跟运算符无关的特殊方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;类别 方法名
字符串 / 字节序列表示形式 __repr__、__str__、__format__、__bytes__
数值转换 __abs__、__bool__、__complex__、__int__、__float__、__hash__、__index__
集合模拟 __len__、__getitem__、__setitem__、__delitem__、__contains__
迭代枚举 __iter__、__reversed__、__next__
可调用模拟 __call__
上下文管理 __enter__、__exit__
实例创建和销毁 __new__、__init__、__del__
属性管理 __getattr__、__getattribute__、__setattr__、__delattr__、__dir__
属性描述符 __get__、__set__、__delete__
跟类相关的服务 __prepare__、__instancecheck__、__subclasscheck__&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;bisect模块管理有序的序列&quot;&gt;Bisect模块管理有序的序列&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;bisect.bisect_left(a,x, lo=0, hi=len(a)) :
查找在有序列表 a 中插入 x 的index。lo 和 hi 用于指定列表的区间，默认是使用整个列表。如果 x 已经存在，在其左边插入。返回值为 index。
bisect.bisect_right(a,x, lo=0, hi=len(a))
bisect.bisect(a, x,lo=0, hi=len(a)) ：
这2个函数和 bisect_left 类似，但如果 x 已经存在，在其右边插入。
bisect.insort_left(a,x, lo=0, hi=len(a)) ：
在有序列表 a 中插入 x。和 a.insert(bisect.bisect_left(a,x, lo, hi), x) 的效果相同。
bisect.insort_right(a,x, lo=0, hi=len(a))
bisect.insort(a, x,lo=0, hi=len(a)) :
和 insort_left 类似，但如果 x 已经存在，在其右边插入。
Bisect 模块提供的函数可以分两类： bisect* 只用于查找 index， 不进行实际的插入；而 insort* 则用于实际插入。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;当list不是最优选择时dict是python的核心类型但它是以空间换时间的结果比较占内存tuple是dict结构比较好的替代set用来做是否包含和去重很合适&quot;&gt;当list不是最优选择时，dict是python的核心类型，但它是以空间换时间的结果，比较占内存，tuple是dict结构比较好的替代，set用来做是否包含和去重很合适。&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;from array import array  
from random import random
floats = array('d', (random() for i in range(10**7)))  
fp = open('floats.bin', 'wb')
floats.tofile(fp)  
fp.close()
floats2 = array('d')  
fp = open('floats.bin', 'rb')
floats2.fromfile(fp, 10**7)  
fp.close()
floats2 == floats&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;python_内置四种队列&quot;&gt;Python_内置四种队列&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;from queue import Queue #LILO队列
q = Queue() #创建队列对象
q.put(0)    #在队列尾部插入元素
q.put(1)
q.put(2)
print('LILO队列',q.queue)  #查看队列中的所有元素
print(q.get())  #返回并删除队列头部元素
print(q.queue)

from queue import LifoQueue #LIFO队列
lifoQueue = LifoQueue()
lifoQueue.put(1)
lifoQueue.put(2)
lifoQueue.put(3)
print('LIFO队列',lifoQueue.queue)
lifoQueue.get() #返回并删除队列尾部元素
lifoQueue.get()
print(lifoQueue.queue)

from queue import PriorityQueue #优先队列
priorityQueue = PriorityQueue() #创建优先队列对象
priorityQueue.put(3)    #插入元素
priorityQueue.put(78)   #插入元素
priorityQueue.put(100)  #插入元素
print(priorityQueue.queue)  #查看优先级队列中的所有元素
priorityQueue.put(1)    #插入元素
priorityQueue.put(2)    #插入元素
print('优先级队列:',priorityQueue.queue)  #查看优先级队列中的所有元素
priorityQueue.get() #返回并删除优先级最低的元素
print('删除后剩余元素',priorityQueue.queue)
priorityQueue.get() #返回并删除优先级最低的元素
print('删除后剩余元素',priorityQueue.queue)  #删除后剩余元素
priorityQueue.get() #返回并删除优先级最低的元素
print('删除后剩余元素',priorityQueue.queue)  #删除后剩余元素
priorityQueue.get() #返回并删除优先级最低的元素
print('删除后剩余元素',priorityQueue.queue)  #删除后剩余元素
priorityQueue.get() #返回并删除优先级最低的元素
print('全部被删除后:',priorityQueue.queue)  #查看优先级队列中的所有元素

from collections import deque   #双端队列
dequeQueue = deque(['Eric','John','Smith'])
print(dequeQueue)
dequeQueue.append('Tom')    #在右侧插入新元素
dequeQueue.appendleft('Terry')  #在左侧插入新元素
print(dequeQueue)
dequeQueue.rotate(2)    #循环右移2次
print('循环右移2次后的队列',dequeQueue)
dequeQueue.popleft()    #返回并删除队列最左端元素
print('删除最左端元素后的队列：',dequeQueue)
dequeQueue.pop()    #返回并删除队列最右端元素
print('删除最右端元素后的队列：',dequeQueue)


以上队列在多线程中可以使用的且线程安全，但在多进程中都不能用于通信。在多进程中，需要这样使用：
from multiprocessing import Process, Queue
myqueue = Queue(100)


## 参考

https://blog.csdn.net/sinat_38682860/article/details/80392493 
https://www.cnblogs.com/cmnz/p/6936181.html&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;关键字&quot;&gt;关键字&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;from keyword import kwlist
print(kwlist)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;builtins模块&quot;&gt;builtins模块&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;import builtins
dir(builtins)&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 12 Sep 2018 06:56:00 +0000</pubDate>
<dc:creator>从零开始的程序员生活</dc:creator>
<og:description>流畅的python中有很多奇技淫巧，整本书都在强调如何最大限度地利用Python 标准库。介绍了很多python的不常用的数据类型、操作、库等，对于入门python后想要提升对python的认识应该有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lgjbky/p/9634773.html</dc:identifier>
</item>
<item>
<title>微服务化之服务拆分与服务发现 - popsuper1982</title>
<link>http://www.cnblogs.com/popsuper1982/p/9634578.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/popsuper1982/p/9634578.html</guid>
<description>&lt;p&gt;本文章为《互联网高并发微服务化架构实践》系列课程的第六篇&lt;/p&gt;
&lt;p&gt;前五篇为：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484778&amp;amp;idx=1&amp;amp;sn=f3a29677d7030370fdd9b8931a0449d0&amp;amp;chksm=ea151248dd629b5e1439bc4fa84411cdb5444d0bf0e8c09267a868fcb18f78602482dea51107&amp;amp;scene=21#wechat_redirect&quot;&gt;微服务化的基石——持续集成&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484791&amp;amp;idx=1&amp;amp;sn=4cb4fb04b481c3aee8a882934c8d925f&amp;amp;chksm=ea151255dd629b43c6383d912234ae0d53fad34e354fdf985a6461aa2774deaf313a234d64fb&amp;amp;scene=21#wechat_redirect&quot;&gt;微服务的接入层设计与动静资源隔离&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484821&amp;amp;idx=1&amp;amp;sn=1d73b718ddb6bcbdd28a7fa98d7dcda0&amp;amp;chksm=ea1512b7dd629ba12412b22a213f281638b2e21161938fbb82c176a2b8a869753afa46a841f6&amp;amp;scene=21#wechat_redirect&quot;&gt;微服务化的数据库设计与读写分离&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484852&amp;amp;idx=1&amp;amp;sn=bf08e717f6d0b4dde432109753c00f36&amp;amp;chksm=ea151296dd629b80fbf9d623b7fa7c8c063b9bfab74913ca3e7e7eb3daf0bfa331e7125678de&amp;amp;scene=21#wechat_redirect&quot;&gt;微服务化之无状态化与容器化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484868&amp;amp;idx=1&amp;amp;sn=5e6a6960557e373b4e21afa05f9a49ab&amp;amp;chksm=ea1512e6dd629bf0e53545da90b761965033ed1447db0a4d22d5c6a70b4c4364ef443c5aa3e7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;微服务化之缓存的设计&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;说到微服务，服务拆分是绕不过去的话题，但是微服务不是说拆就能拆的，有很多的前提条件，需要完成前面几节所论述的部分。&lt;/p&gt;
&lt;p&gt;首先要有一个持续集成的平台，使得服务在拆分的过程中，功能的一致性，这种一致性不能通过人的经验来，而需要经过大量的回归测试集，并且持续的拆分，持续的演进，持续的集成，从而保证系统时刻处于可以验证交付的状态，而非闭门拆分一段时间，最终谁也不知道功能最终究竟有没有bug，因而需要另外一个月的时间专门修改bug。&lt;/p&gt;
&lt;p&gt;其次在接入层，API和UI要动静分离，API由API网关统一的管理，这样后端无论如何拆分，可以保证对于前端来讲，统一的入口，而且可以实现拆分过程中的灰度发布，路由分发，流量切分，从而保证拆分的平滑进行。而且拆分后的微服务之间，为了高性能，是不建议每次调用都进行认证鉴权的，而是在API网关上做统一的认证鉴权，一旦进入网关，服务之间的调用就是可信的。&lt;/p&gt;
&lt;p&gt;其三对于数据库，需要进行良好的设计，不应该有大量的联合查询，而是将数据库当成一个简单的key-value查询，复杂的联合查询通过应用层，或者通过Elasticsearch进行。如果数据库表之间耦合的非常严重，其实服务拆分是拆不出来的。&lt;/p&gt;
&lt;p&gt;其四要做应用的无状态化，只有无状态的应用，才能横向扩展，这样拆分才有意义。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、服务拆分的时机&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;满足了服务拆分的前提之后，那先拆哪个模块，后拆哪个模块呢？什么情况下一个模块应该拆分出来呢？&lt;/p&gt;
&lt;p&gt;微服务拆分绝非一个大跃进运动，由高层发起，把一个应用拆分的七零八落的，最终大大增加运维成本，但是并不会带来收益。&lt;/p&gt;
&lt;p&gt;微服务拆分的过程，应该是一个由痛点驱动的，是业务真正遇到了快速迭代和高并发的问题，如果不拆分，将对于业务的发展带来影响，只有这个时候，微服务的拆分是有确定收益的，增加的运维成本才是值得的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;微服务解决的问题之一，就是快速迭代。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;互联网产品的特点就是迭代速度快，一般一年半就能决出胜负，第一一统天下，第二被第一收购，其他死翘翘。所以快速上线，快速迭代，就是生命线，而且一旦成功就是百亿身家，所以无论付出多大运维成本，使用微服务架构都是值得的。&lt;/p&gt;
&lt;p&gt;这也就是为什么大部分使用微服务架构的都是互联网企业，因为对于这些企业来讲收益明显。而对于很多传统的应用，半年更新一次，企业运营相对平稳，IT系统的好坏对于业务没有关键性影响，在他们眼中，微服务化改造带来的效果，还不如开发多加几次班。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;微服务拆分时机一：提交代码频繁出现大量冲突&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;微服务对于快速迭代的效果，首先是开发独立，如果是一单体应用，几百人开发一个模块，如果使用GIT做代码管理，则经常会遇到的事情就是代码提交冲突。&lt;/p&gt;
&lt;p&gt;同样一个模块，你也改，他也改，几百人根本没办法沟通。所以当你想提交一个代码的时候，发现和别人提交的冲突了，于是因为你是后提交的人，你有责任去merge代码，好不容易merge成功了，等再次提交的时候，发现又冲突了，你是不是很恼火。随着团队规模越大，冲突概率越大。&lt;/p&gt;
&lt;p&gt;所以应该拆分成不同的模块，每十个人左右维护一个模块，也即一个工程，首先代码冲突的概率小多了，而且有了冲突，一个小组一吼，基本上问题就解决了。&lt;/p&gt;
&lt;p&gt;每个模块对外提供接口，其他依赖模块可以不用关注具体的实现细节，只需要保证接口正确就可以。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;微服务拆分时机二：小功能要积累到大版本才能上线，上线开总监级别大会&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;微服务对于快速迭代的效果，首先是上线独立。如果没有拆分微服务，每次上线都是一件很痛苦的事情。当你修改了一个边角的小功能，但是你不敢马上上线，因为你依赖的其他模块才开发了一半，你要等他，等他好了，也不敢马上上线，因为另一个被依赖的模块也开发了一半，当所有的模块都耦合在一起，互相依赖，谁也没办法独立上线，而是需要总监协调各个团队，大家开大会，约定一个时间点，无论大小功能，死活都要这天上线。&lt;/p&gt;
&lt;p&gt;这种模式导致上线的时候，单次上线的需求列表非常长，这样风险比较大，可能小功能的错误会导致大功能的上线不正常，将如此长的功能，需要一点点check，非常小心，这样上线时间长，影响范围大。因而这种的迭代速度快不了，顶多一个月一次就不错了。&lt;/p&gt;
&lt;p&gt;服务拆分后，在接口稳定的情况下，不同的模块可以独立上线。这样上线的次数增多，单次上线的需求列表变小，可以随时回滚，风险变小，时间变短，影响面小，从而迭代速度加快。&lt;/p&gt;
&lt;p&gt;对于接口要升级部分，保证灰度，先做接口新增，而非原接口变更，当注册中心中监控到的调用情况，发现接口已经不用了，再删除。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;微服务解决的问题之二，就是高并发。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;互联网一个产品的特点就是在短期内要积累大量的用户，这甚至比营收和利润还重要，如果没有大量的用户基数，融资都会有问题。&lt;/p&gt;
&lt;p&gt;因而对于并发量不大的系统，进行微服务化的驱动力差一些，如果只有不多的用户在线，多线程就能解决问题，最多做好无状态化，前面部署个负载均衡，单体应用部署多份。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;微服务拆分时机三：横向扩展流程复杂，主要业务和次要业务耦合&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;单体应用无状态化之后，虽然通过部署多份，可以承载一定的并发量，但是资源非常浪费。因为有的业务是需要扩容的，例如下单和支付，有的业务是不需要扩容的，例如注册。如果一起扩容，消耗的资源可能是拆分后的几倍，成本可能多出几个亿。而且由于配置复杂，在同一个工程里面，往往在配置文件中是这样组织的，这一块是这个模块的，下一块是另一个模块的，这样扩容的时候，一些边角的业务，也是需要对配置进行详细审核，否则不敢贸然扩容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;微服务拆分时机四：熔断降级全靠if-else&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在高并发场景下，我们希望一个请求如果不成功，不要占用资源，应该尽快失败，尽快返回，而且希望当一些边角的业务不正常的情况下，主要业务流程不受影响。这就需要熔断策略，也即当A调用B，而B总是不正常的时候，为了让B不要波及到A，可以对B的调用进行熔断，也即A不调用B，而是返回暂时的fallback数据，当B正常的时候，再放开熔断，进行正常的调用。&lt;/p&gt;
&lt;p&gt;有时候为了保证核心业务流程，边角的业务流程，如评论，库存数目等，人工设置为降级的状态，也即默认不调用，将所有的资源用于大促的下单和支付流程。&lt;/p&gt;
&lt;p&gt;如果核心业务流程和边角业务流程在同一个进程中，就需要使用大量的if-else语句，根据下发的配置来判断是否熔断或者降级，这会使得配置异常复杂，难以维护。&lt;/p&gt;
&lt;p&gt;如果核心业务和边角业务分成两个进程，就可以使用标准的熔断降级策略，配置在某种情况下，放弃对另一个进程的调用，可以进行统一的维护。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、服务拆分的方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;好了，当你觉得要将一个程序的某个部分拆分出来的时候，有什么方法可以保障平滑吗？&lt;/p&gt;
&lt;p&gt;首先要做的，就是原有工程代码的标准化，我们常称为“任何人接手任何一个模块都能看到熟悉的面孔”&lt;/p&gt;

&lt;p&gt;例如打开一个java工程，应该有以下的package：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;API接口包：所有的接口定义都在这里，对于内部的调用，也要实现接口，这样一旦要拆分出去，对于本地的接口调用，就可以变为远程的接口调用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;访问外部服务包：如果这个进程要访问其他进程，对于外部访问的封装都在这里，对于单元测试来讲，对于这部分的Mock，可以使得不用依赖第三方，就能进行功能测试。对于服务拆分，调用其他的服务，也是在这里。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;数据库DTO：如果要访问数据库，在这里定义原子的数据结构&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;访问数据库包：访问数据库的逻辑全部在这个包里面&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;服务与商务逻辑：这里实现主要的商业逻辑，拆分也是从这里拆分出来。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;外部服务：对外提供服务的逻辑在这里，对于接口的提供方，要实现在这里。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外是测试文件夹，每个类都应该有单元测试，要审核单元测试覆盖率，模块内部应该通过Mock的方法实现集成测试。&lt;/p&gt;
&lt;p&gt;接下来是配置文件夹，配置profile，配置分为几类：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;内部配置项(启动后不变，改变需要重启)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;集中配置项(配置中心，可动态下发)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;外部配置项(外部依赖，和环境相关)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当一个工程的结构非常标准化之后，接下来在原有服务中，先独立功能模块 ，规范输入输出，形成服务内部的分离。在分离出新的进程之前，先分离出新的jar，只要能够分离出新的jar，基本也就实现了松耦合。&lt;/p&gt;
&lt;p&gt;接下来，应该新建工程，新启动一个进程，尽早的注册到注册中心，开始提供服务，这个时候，新的工程中的代码逻辑可以先没有，只是转调用原来的进程接口。&lt;/p&gt;
&lt;p&gt;为什么要越早独立越好呢？哪怕还没实现逻辑先独立呢？因为服务拆分的过程是渐进的，伴随着新功能的开发，新需求的引入，这个时候，对于原来的接口，也会有新的需求进行修改，如果你想把业务逻辑独立出来，独立了一半，新需求来了，改旧的，改新的都不合适，新的还没独立提供服务，旧的如果改了，会造成从旧工程迁移到新工程，边迁移边改变，合并更加困难。如果尽早独立，所有的新需求都进入新的工程，所有调用方更新的时候，都改为调用新的进程，对于老进程的调用会越来越少，最终新进程将老进程全部代理。&lt;/p&gt;
&lt;p&gt;接下来就可以将老工程中的逻辑逐渐迁移到新工程，由于代码迁移不能保证逻辑的完全正确，因而需要持续集成，灰度发布，微服务框架能够在新老接口之间切换。&lt;/p&gt;
&lt;p&gt;最终当新工程稳定运行，并且在调用监控中，已经没有对于老工程的调用的时候，就可以将老工程下线了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、服务拆分的规范&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;微服务拆分之后，工程会比较的多，如果没有一定的规范，将会非常混乱，难以维护。&lt;/p&gt;
&lt;p&gt;首先人们经常问的一个问题是，服务拆分之后，原来都在一个进程里面的函数调用，现在变成了A调用B调用C调用D调用E，会不会因为调用链路过长而使得相应变慢呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;服务拆分的规范一：服务拆分最多三层，两次调用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;服务拆分是为了横向扩展，因而应该横向拆分，而非纵向拆成一串的。也即应该将商品和订单拆分，而非下单的十个步骤拆分，然后一个调用一个。&lt;/p&gt;
&lt;p&gt;纵向的拆分最多三层：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;基础服务层：用于屏蔽数据库，缓存层，提供原子的对象查询接口，有这一层，为了数据层做一定改变的时候，例如分库分表，数据库扩容，缓存替换等，对于上层透明，上层仅仅调用这一层的接口，不直接访问数据库和缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;组合服务层：这一层调用基础服务层，完成较为复杂的业务逻辑，实现分布式事务也多在这一层&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Controller层：接口层，调用组合服务层对外&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;服务拆分的规范二：仅仅单向调用，严禁循环调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微服务拆分后，服务之间的依赖关系复杂，如果循环调用，升级的时候就很头疼，不知道应该先升级哪个，后升级哪个，难以维护。&lt;/p&gt;
&lt;p&gt;因而层次之间的调用规定如下：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;基础服务层主要做数据库的操作和一些简单的业务逻辑，不允许调用其他任何服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;组合服务层，可以调用基础服务层，完成复杂的业务逻辑，可以调用组合服务层，不允许循环调用，不允许调用Controller层服务&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Controller层，可以调用组合业务层服务，不允许被其他服务调用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果出现循环调用，例如A调用B，B也调用A，则分成Controller层和组合服务层两层，A调用B的下层，B调用A的下层。也可以使用消息队列，将同步调用，改为异步调用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;服务拆分的规范三：将串行调用改为并行调用，或者异步化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果有的组合服务处理流程的确很长，需要调用多个外部服务，应该考虑如何通过消息队列，实现异步化和解耦。&lt;/p&gt;
&lt;p&gt;例如下单之后，要刷新缓存，要通知仓库等，这些都不需要再下单成功的时候就要做完，而是可以发一个消息给消息队列，异步通知其他服务。&lt;/p&gt;
&lt;p&gt;而且使用消息队列的好处是，你只要发送一个消息，无论下游依赖方有一个，还是有十个，都是一条消息搞定，只不过多几个下游监听消息即可。&lt;/p&gt;
&lt;p&gt;对于下单必须同时做完的，例如扣减库存和优惠券等，可以进行并行调用，这样处理时间会大大缩短，不是多次调用的时间之和，而是最长的那个系统调用时间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;服务拆分的规范四：接口应该实现幂等&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;微服务拆分之后，服务之间的调用当出现错误的时候，一定会重试，但是为了不要下两次单，支付两次，需要所有的接口实现幂等。&lt;/p&gt;
&lt;p&gt;幂等一般需要设计一个幂等表来实现，幂等表中的主键或者唯一键可以是transaction id，或者business id，可以通过这个id的唯一性标识一个唯一的操作。&lt;/p&gt;
&lt;p&gt;也有幂等操作使用状态机，当一个调用到来的时候，往往触发一个状态的变化，当下次调用到来的时候，发现已经不是这个状态，就说明上次已经调用过了。&lt;/p&gt;
&lt;p&gt;状态的变化需要是一个原子操作，也即并发调用的时候，只有一次可以执行。可以使用分布式锁，或者乐观锁CAS操作实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;服务拆分的规范五：接口数据定义严禁内嵌，透传&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;微服务接口之间传递数据，往往通过数据结构，如果数据结构透传，从底层一直到上层使用同一个数据结构，或者上层的数据结构内嵌底层的数据结构，当数据结构中添加或者删除一个字段的时候，波及的面会非常大。&lt;/p&gt;
&lt;p&gt;因而接口数据定义，在每两个接口之间约定，严禁内嵌和透传，即便差不多，也应该重新定义，这样接口数据定义的改变，影响面仅仅在调用方和被调用方，当接口需要更新的时候，比较可控，也容易升级。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;服务拆分的规范六：规范化工程名&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;微服务拆分后，工程名非常多，开发人员，开发团队也非常多，如何让一个开发人员看到一个工程名，或者jar的名称，就大概知道是干什么的，需要一个规范化的约定。&lt;/p&gt;

&lt;p&gt;例如出现pay就是支付，出现order就是下单，出现account就是用户。&lt;/p&gt;
&lt;p&gt;再如出现compose就是组合层，controller就是接口层，basic就是基础服务层。&lt;/p&gt;
&lt;p&gt;出现api就是接口定义，impl就是实现。&lt;/p&gt;
&lt;p&gt;pay-compose-api就是支付组合层接口定义。&lt;/p&gt;
&lt;p&gt;account-basic-impl就是用户基础服务层的实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、服务发现的选型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;微服务拆分后，服务之间的调用需要服务发现和注册中心进行维护。也能主流的有几种方法。&lt;/p&gt;
&lt;p&gt;第一是dubbo，Dubbo是SOA架构的微服务框架的标准，已经被大量使用，虽然中间中断维护过一段时间，但是随着微服务的兴起，重新进行了维护，是很多熟悉Dubbo RPC开发人员的首选。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/635909/201809/635909-20180912142901097-153189631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二种是springcloud，springcloud为微服务而生，在dubbo已经没有人维护的情况下，推出了支撑微服务的成熟框架。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/635909/201809/635909-20180912143427911-1700868495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;dubbo vs. springcloud的对比，dubbo更加注重服务治理，原生功能不够全面，而springcloud注重整个微服务生态，工具链非常全面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/635909/201809/635909-20180912143459582-631163014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;springcloud可定制性强，通过各种组件满足各种微服务场景，使用springboot统一编程模型，能够快速构建应用，基于注解，使用方便，但是学习门槛比较高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/635909/201809/635909-20180912143541069-1508798159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Dubbo注册到zookeeper里面的是接口，而springcloud注册到Eureka或者consul里面的是实例，在规模比较小的情况下没有分别，但是规模一旦大了，例如实例数目万级别，接口数据就算十万级别，对于zookeeper中的树规模比较大，而且zookeeper是强一致性的，当一个节点挂了的时候，节点之间的数据同步会影响线上使用，而springcloud就好很多，实例级别少一个量级，另外consul也非强一致的。&lt;/p&gt;

&lt;p&gt;第三是kubernetes，Kubernetes虽然是容器平台，但是他设计出来，就是为了跑微服务的，因而提供了微服务运行的很多组件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/635909/201809/635909-20180912143647202-1366413791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;很多springcloud可以做的事情，kubernetes也有相应的机制，而且由于是容器平台，相对比较通用，可以支持多语言，对于业务无侵入，但是也正因为是容器平台，对于微服务的运行生命周期的维护比较全面，对于服务之间的调用和治理，比较弱，service只能满足最最基本的服务发现需求。&lt;/p&gt;

&lt;p&gt;因而实践中使用的时候，往往是kubernetes和springcloud结合使用，kubernetes负责提供微服务的运行环境，服务之间的调用和治理，由springlcoud搞定。&lt;/p&gt;

&lt;p&gt;第四是service mesh，service mesh一定程度上弥补了kubernetes对于服务治理方面的不足，对业务代码0侵入，将服务治理下沉到平台层，是服务治理的一个趋势。&lt;/p&gt;

&lt;p&gt;然而service mesh需要使用单独的进程进行请求转发，性能还不能让人满意，另外社区比较新，成熟度不足，暂时没有达到大规模生产使用的标准。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/635909/201809/635909-20180912143736194-1675736607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;欢迎关注微信公众号&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/635909/201809/635909-20180912144112931-1130185772.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 12 Sep 2018 06:43:00 +0000</pubDate>
<dc:creator>popsuper1982</dc:creator>
<og:description>本文章为《互联网高并发微服务化架构实践》系列课程的第六篇 前五篇为： 微服务化的基石——持续集成 微服务的接入层设计与动静资源隔离 微服务化的数据库设计与读写分离 微服务化之无状态化与容器化 微服务化</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/popsuper1982/p/9634578.html</dc:identifier>
</item>
<item>
<title>教你编写百度搜索广告过滤的chrome插件 - jiulang</title>
<link>http://www.cnblogs.com/kewei/p/9634582.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kewei/p/9634582.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;1 前言&lt;/h2&gt;
&lt;p&gt;目前百度搜索列表首页里，广告5条正常内容是10条，而且广告都是前1到5条的位置，与正常内容的显示样式无异。对于我们这样有能力的开发者，其实可以简单的实现一个chrome插件，在百度搜索页面里执行一些我们自己的javascript，删除掉这些广告条目。&lt;/p&gt;
&lt;h2 id=&quot;插件简介&quot;&gt;2 插件简介&lt;/h2&gt;
&lt;p&gt;Chrome插件逻辑主体为两部分组成，一是在目标文档（比如www.baidu.com页面）运行的js和css，叫content_scripts；一部分是在chrome外壳上加载与显示的内容（比如图标和设置界面）叫browser_action，这些都需要在一个manifest.json的文件里描述。&lt;/p&gt;
&lt;h3 id=&quot;插件结构&quot;&gt;2.1 插件结构&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;manifest.json
scripts
  --jquery-1.7.1.min.js
  --include.js
images
  --icon16.png
  --icon32.png&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，scripts下的js是content_scripts需要的,images下的图片是叫browser_action需要的。&lt;/p&gt;
&lt;h2 id=&quot;百度搜索的广告特征&quot;&gt;3 百度搜索的广告特征&lt;/h2&gt;
&lt;h3 id=&quot;文档结构特征&quot;&gt;3.1 文档结构特征&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div id=&quot;content_left&quot;&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;div&amp;gt;广告1&amp;lt;/div&amp;gt;
        &amp;lt;div&amp;gt;广告2&amp;lt;/div&amp;gt;
        &amp;lt;div&amp;gt;广告3&amp;lt;/div&amp;gt;
        &amp;lt;div&amp;gt;广告4&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div&amp;gt;搜索记录1&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;搜索记录2&amp;lt;/div&amp;gt;

    &amp;lt;div&amp;gt;
        &amp;lt;div&amp;gt;广告5&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;广告可以分首尾两个地方显示，也可能只有在首部显示&lt;/li&gt;
&lt;li&gt;多个广告可能被一个div包住，此div与搜索记录平行，但有时候广告与搜索记录直接平行&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;样式特征&quot;&gt;3.2 样式特征&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;广告条目的class名称是动态的，每次刷新都得到不一样的class名&lt;/li&gt;
&lt;li&gt;广告条目使用了内联样式，用于保证广告的显示属性不受样式表的影响&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;自保护特征&quot;&gt;3.3 自保护特征&lt;/h3&gt;
&lt;p&gt;在文档加载完成的两秒之内，广告条目的dom受到保护，试图修改广告的内联样式或直接删除广告的dom，都会触发生成新的不一样广告，插入搜索记录前面。&lt;/p&gt;
&lt;h2 id=&quot;广告过滤思路&quot;&gt;4 广告过滤思路&lt;/h2&gt;
&lt;p&gt;由于百度搜索在反反广告上做了很多措施，基于css级别的隐藏广告思路是不太可行了，我们可以基于jQuery，监测document的元素插入事件，在里面搜索广告条件，进而删除。虽然百度有自保护特征，但终究插入新广告也是触发到测document的元素插入事件。&lt;/p&gt;
&lt;h3 id=&quot;include.js代码&quot;&gt;4.1 include.js代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;; (function () {
    $(document).bind(&quot;DOMNodeInserted&quot;, function (e) {
        $(&quot;#content_left div[data-click] span:contains('广告')&quot;)
            .parents(&quot;#content_left div[data-click]&quot;)
            .remove();
    });
})();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;$(&quot;#content_left div[data-click] span:contains('广告')&quot;)可以将广告标识选择出来，向上选择到#content_left div[data-click]，就是广告条目，然后把它删除。删除之后，百度会自动插入新的广告，新广告也符合这个选择器，所以会二次运行我们的去广告代码逻辑。&lt;/p&gt;
&lt;h3 id=&quot;插件和源代码&quot;&gt;4.2 插件和源代码&lt;/h3&gt;
&lt;p&gt;源代码已经放到github上，把里面有一个已打包好的BaiduAdBlock.crx，将其拖曳到chrome内核的浏览器上，勾选“允许访问敏感页面”就完成安装。&lt;/p&gt;
&lt;p&gt;github链接&lt;br/&gt;&lt;a href=&quot;https://github.com/xljiulang/BaiduAdBlock&quot; class=&quot;uri&quot;&gt;https://github.com/xljiulang/BaiduAdBlock&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 12 Sep 2018 06:30:00 +0000</pubDate>
<dc:creator>jiulang</dc:creator>
<og:description>1 前言 目前百度搜索列表首页里，广告5条正常内容是10条，而且广告都是前1到5条的位置，与正常内容的显示样式无异。对于我们这样有能力的开发者，其实可以简单的实现一个chrome插件，在百度搜索页面里</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kewei/p/9634582.html</dc:identifier>
</item>
<item>
<title>dp方法论——由矩阵相乘问题学习dp解题思路 - mozi_song</title>
<link>http://www.cnblogs.com/mozi-song/p/9629137.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mozi-song/p/9629137.html</guid>
<description>&lt;p&gt;前篇戳：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/mozi-song/p/9615167.html&quot;&gt;dp入门——由分杆问题认识动态规划&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;导语&lt;/h2&gt;
&lt;p&gt;刷过一些算法题，就会十分珍惜“&lt;strong&gt;方法论&lt;/strong&gt;”这种东西。Leetcode上只有题目、讨论和答案，没有方法论。往往答案看起来十分切中要害，但是从看题目到得到思路的那一段，就是绕不过去。楼主有段时间曾把这个过程归结于智商和灵感的结合，直到有天为了搞懂Leetcode上一位老兄的题型总结，花两天时间学习了回溯法，突然有种惊为天人的感觉——原来真正掌握一个算法是应该触类旁通的，而不是将题中一个细节换掉就又成了新题……&lt;/p&gt;
&lt;p&gt;掌握方法论绝对是一种很爽的感觉。看起来好像很花费时间，其实是一种“因为慢，所以快”的方法。以前可能你学习一个dp题目要大半天；当你花了半个周时间，学会了dp的套路，你会发现，有些medium的dp题甚至不需要半个小时就能做完，而且从头到尾不需提示，全靠自己！&lt;/p&gt;
&lt;h2&gt;方法论&lt;/h2&gt;
&lt;p&gt;那么，怎么从一个看起来毫无头绪的问题出发，找到解题的思路并用dp将问题解出来呢？本文以矩阵相乘问题为例，给出dp问题的一般解题思路。&lt;/p&gt;
&lt;p&gt;当然，按照思路解题的前提是你已经知道这道题要用dp去解，如何确定一个问题可以用dp去解，则是下一篇要讨论的话题。&lt;/p&gt;
&lt;p&gt;下面就是动态规划的一般解题思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;分析最优解的特征。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;递归地定义最优解的值。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;计算最优解的值。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根据计算好的信息构造最优解。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;看起来非常抽象是吧？在这里不需要完全理解。等你看完全文再回来，保你会有不一样的感受。&lt;/p&gt;
&lt;h2&gt;矩阵相乘问题&lt;/h2&gt;
&lt;h3&gt;问题&lt;/h3&gt;
&lt;p&gt;这是一个看起来可能有点抽象的数学问题，但请你耐心往下看。当你看完解法时，你会惊异于动态规划的魔力。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;题目：给出一个由n个矩阵组成的矩阵链&amp;lt;A&lt;sub&gt;1&lt;/sub&gt;,A&lt;sub&gt;2&lt;/sub&gt;,...,An&amp;gt;，矩阵A&lt;sub&gt;i&lt;/sub&gt;的秩为&lt;em&gt;p&lt;sub&gt;i-1&lt;/sub&gt;×p&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;。将A&lt;sub&gt;1&lt;/sub&gt;A&lt;sub&gt;2&lt;/sub&gt;...A&lt;sub&gt;n&lt;/sub&gt;这个乘积&lt;em&gt;全括号化&lt;/em&gt;，使得计算这个乘积所需要的的标量乘法最少。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;全括号化&lt;/span&gt;&lt;/em&gt;&lt;span&gt;是以一种递归的形式定义的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;一个全括号化的乘积只有两种可能：一是一个单个矩阵；二是两个全括号化的乘积的乘积。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;天啦也太绕了，举个例子吧。对于矩阵链&amp;lt;A&lt;sub&gt;1&lt;/sub&gt;,A&lt;sub&gt;2&lt;/sub&gt;,A&lt;sub&gt;3&lt;/sub&gt;,A&lt;sub&gt;4&lt;/sub&gt;&amp;gt;的乘积，共有五种全括号化的方法：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(A&lt;sub&gt;1&lt;/sub&gt;(A&lt;sub&gt;2&lt;/sub&gt;(A&lt;sub&gt;3&lt;/sub&gt;A&lt;sub&gt;4&lt;/sub&gt;))),&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;(A&lt;sub&gt;1&lt;/sub&gt;((A&lt;sub&gt;2&lt;/sub&gt;A&lt;sub&gt;3&lt;/sub&gt;)A&lt;sub&gt;4&lt;/sub&gt;)),&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;((A&lt;sub&gt;1&lt;/sub&gt;A&lt;sub&gt;2&lt;/sub&gt;)(A&lt;sub&gt;3&lt;/sub&gt;A&lt;sub&gt;4&lt;/sub&gt;)),&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;(((A&lt;sub&gt;1&lt;/sub&gt;A&lt;sub&gt;2&lt;/sub&gt;)A&lt;sub&gt;3&lt;/sub&gt;)A&lt;sub&gt;4&lt;/sub&gt;),&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;((A&lt;sub&gt;1&lt;/sub&gt;(A&lt;sub&gt;2&lt;/sub&gt;A&lt;sub&gt;3&lt;/sub&gt;))A&lt;sub&gt;4&lt;/sub&gt;)&lt;/span&gt;&lt;/span&gt;&lt;sub&gt;&lt;br/&gt;&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们知道矩阵乘法是满足结合律的，所以以上五个式子的乘积相等，但是它们的运算时间是否相等呢？&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;矩阵乘法的运算时间&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们知道，矩阵乘法的定义是:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两个&lt;em&gt;互相兼容&lt;/em&gt;的矩阵A,B可以相乘。互相兼容是指A的列数与B的行数相等。假如A是一个p&lt;span&gt;&lt;em&gt;×&lt;/em&gt;&lt;/span&gt;q的矩阵，而B是一个q&lt;span&gt;&lt;em&gt;×&lt;/em&gt;&lt;/span&gt;r的矩阵，则乘积C是一个p&lt;span&gt;&lt;em&gt;×&lt;/em&gt;&lt;/span&gt;r的矩阵且有&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;c&lt;sub&gt;ij&lt;/sub&gt; = ∑ a&lt;sub&gt;ik&lt;/sub&gt;·b&lt;sub&gt;kj&lt;/sub&gt;, k = 1,...,q.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于要对C中的每一个元素进行计算（共q&lt;span&gt;&lt;strong&gt;·&lt;/strong&gt;&lt;/span&gt;r个元素），而每次运算要做q次乘法，所以总的运算时间为&lt;strong&gt;&lt;em&gt;pqr。&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;来看看让乘积中的不同因子结合对运算时间有什么影响。假设我们有&lt;/span&gt; &lt;span&gt;&amp;lt;A&lt;sub&gt;1&lt;/sub&gt;,A&lt;sub&gt;2&lt;/sub&gt;&lt;/span&gt;&lt;span&gt;,A&lt;sub&gt;3&lt;/sub&gt;&amp;gt;这个矩阵链，三个矩阵的秩分别为10&lt;span&gt;&lt;span&gt;×&lt;/span&gt;&lt;/span&gt;100, 100&lt;span&gt;&lt;span&gt;×&lt;/span&gt;&lt;/span&gt;5和5&lt;span&gt;&lt;span&gt;×&lt;/span&gt;&lt;/span&gt;50。则&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;((A&lt;sub&gt;1&lt;/sub&gt;A&lt;sub&gt;2&lt;/sub&gt;)A&lt;sub&gt;3&lt;/sub&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的运算时间为10&lt;span&gt;&lt;span&gt;&lt;span&gt;×&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;100&lt;span&gt;&lt;span&gt;&lt;span&gt;×&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;5+10&lt;span&gt;&lt;span&gt;&lt;span&gt;×&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;5&lt;span&gt;&lt;span&gt;&lt;span&gt;×&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;50=7500;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;A&lt;sub&gt;1&lt;/sub&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;A&lt;sub&gt;2&lt;/sub&gt;A&lt;sub&gt;3&lt;/sub&gt;)&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的运&lt;span&gt;算时间为100×5×50+10&lt;span&gt;&lt;span&gt;&lt;span&gt;×&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;100&lt;span&gt;&lt;span&gt;&lt;span&gt;×&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;50=75000。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;按照不同的顺序做矩阵乘法，所需要的乘法次数竟相差10倍。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;初步分析&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;按照惯例，我们来感受一下穷举的算法复杂度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设有一个长度为n的矩阵链，我们通过遍历所有的全括号化的可能性来解题。设全括号化的可能性数目为P(n)。当n为1时，矩阵链只有一个矩阵，符合全括号化的定义；当n&amp;gt;=2时，全括号化后为两个矩阵的乘积，即((...)(...))的形式。用递归的思路去分析，则中间两个括号的分界位置有n-1种可能，如下面竖线所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;A&lt;sub&gt;1&lt;/sub&gt;|A&lt;sub&gt;2&lt;/sub&gt;&lt;span&gt;&lt;span&gt;|A&lt;sub&gt;3&lt;/sub&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;|&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;...|A&lt;sub&gt;n&lt;/sub&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当分界线将矩阵链分为长度为k和n-k的两个子矩阵链时，全括号化可能性为&lt;span&gt;&lt;span&gt;P(k)P(n-k)&lt;/span&gt;&lt;/span&gt;。我们对所有的k值求和，就得出给整个矩阵链全括号化的数目：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;P(n) = ∑ P(k)P(n-k), k=1...n-1　　　(&lt;span&gt;&lt;span&gt;n&amp;gt;=2&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是一个&lt;span&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Catalan_number&quot; target=&quot;_blank&quot;&gt;卡塔兰数（Catalan Number)&lt;/a&gt;&lt;/span&gt;，它的增长速率为Ω(&lt;span&gt;4&lt;sup&gt;n&lt;/sup&gt;&lt;/span&gt;/n&lt;sup&gt;3/2&lt;/sup&gt;),它的渐进值为&lt;strong&gt;&lt;span&gt;Ω&lt;/span&gt;(2&lt;sup&gt;n&lt;/sup&gt;)&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;em&gt;对渐进值还不太熟，如果有小伙伴明白“增长速率”和“渐进值”之间的关系，欢迎指教。&lt;/em&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总的来说，如果对这个题目使用穷举法，算法复杂度是&lt;strong&gt;指数的&lt;/strong&gt;。后面我们分析了dp的算法复杂度，再来比较。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;用dp方法论解题&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;算法的学习永远没有“手把手”这一说。如果你在认真学习这篇文章，希望你能做到比你看到的小节思路提前一点。比如，在看第一步前，先对这个题目有一点大致思路，明白让自己迷茫的点在哪里；看第x步前，对第x步的内容在心中有一个猜测。这样做比起完全放弃思考，只是跟着文章的思路走，收获会大很多。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;第一步：分析最优解的特征&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;这一步的精髓是分析&lt;strong&gt;最优子解如何构成最优解&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在上一节中已经提&lt;span&gt;到，对于n&amp;gt;=2的情况，&lt;span&gt;全括号化后为((&lt;em&gt;chain_1&lt;/em&gt;)(&lt;em&gt;chain_2&lt;/em&gt;))的形式。这样，问题自然而然地分成了两个子问题：求前后两个子括号中的最优解。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;假设对于某种特定的分割（即&lt;span&gt;&lt;span&gt;&lt;em&gt;chain_1&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span&gt;&lt;span&gt;&lt;em&gt;chain_2&lt;/em&gt;之间的分界线位置固定&lt;/span&gt;&lt;/span&gt;），&lt;em&gt;chain_1&lt;/em&gt;的秩为m&lt;span&gt;&lt;span&gt;&lt;em&gt;×&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;p,其内部的标量乘法数目为x;&lt;em&gt;chain_2&lt;/em&gt;的秩为p&lt;span&gt;&lt;span&gt;&lt;em&gt;×&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;n，其&lt;span&gt;&lt;span&gt;内部的标量乘法数目为&lt;/span&gt;&lt;/span&gt;y。则整个矩阵链的乘法次数为&lt;em&gt;x+y+mpn&lt;/em&gt;。由于m,p,n是固定的，我们需要让x和y为最小值从而使整个矩阵链的乘法次数最小。即，对于某种特定的分割，两个子括号中的最优解构成整个问题的最优解的一个&lt;strong&gt;选项&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;总结来说，我们将矩阵乘积简略地看成两个子矩阵&lt;span&gt;&lt;span&gt;链&lt;/span&gt;&lt;/span&gt;的乘积，这两个子矩阵&lt;span&gt;&lt;span&gt;链&lt;/span&gt;&lt;/span&gt;的分界有n-1种可能。对每一种可能，问题被分割成两个子问题，即求左右两个子矩阵链的最优解。如果遍历这n-1种可能并选出最好的一个，那就是整个问题的最优解。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;第二步：递归地定义最优解的值&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;第二步非常关键，是我们将前后思路打通的一步。&lt;/p&gt;
&lt;p&gt;第一步中提出了一个比较简单的思路，即把矩阵链分割成左右两个子矩阵链。既然有了这个初步思路，我们就来涂鸦一番，看看这个思路是否可行。&lt;/p&gt;
&lt;p&gt;对于递归性的问题，一个很好的方法是画递归树，这样会使得问题看起来比较具象，而且也会暴露一些算法上的问题，比如重叠子树等。画递归树的时候，最好举一个实际的例子。这里我们假设有一个长度为4的矩阵链&lt;span&gt;&amp;lt;A&lt;sub&gt;1&lt;/sub&gt;,A&lt;sub&gt;2&lt;/sub&gt;&lt;span&gt;,A&lt;sub&gt;3&lt;/sub&gt;,A&lt;sub&gt;4&lt;/sub&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;，简单地画一下它的子问题分割：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1154131/201809/1154131-20180912103251996-1457969096.png&quot; alt=&quot;&quot; width=&quot;411&quot; height=&quot;224&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图中的数字表示子矩阵链的长度，根为4，即初始矩阵链；它可以分为1+3,2+2,3+1三种情况，这三种情况又可以各自细分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里暴露了一个问题，请看图中的两个涂色的子树。两个子树的节点数字是一样的。但是左边这个子树的根节点3代表的是&lt;span&gt;A&lt;sub&gt;2&lt;/sub&gt;&lt;span&gt;A&lt;sub&gt;3&lt;/sub&gt;A&lt;sub&gt;4&lt;/sub&gt;这个乘积；而右边这个代表的是&lt;span&gt;A&lt;sub&gt;1&lt;/sub&gt;A&lt;sub&gt;2&lt;/sub&gt;&lt;span&gt;A&lt;sub&gt;3&lt;/sub&gt;这个乘积。由于&lt;span&gt;A&lt;sub&gt;1&lt;/sub&gt;,A&lt;sub&gt;2&lt;/sub&gt;&lt;span&gt;,A&lt;sub&gt;3&lt;/sub&gt;,A&lt;sub&gt;4&lt;/sub&gt;&lt;/span&gt;&lt;/span&gt;四个矩阵的秩是未知的，它们很可能不相同，则&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;A&lt;sub&gt;1&lt;/sub&gt;A&lt;sub&gt;2&lt;/sub&gt;&lt;span&gt;A&lt;sub&gt;3&lt;/sub&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span&gt;&lt;span&gt;A&lt;sub&gt;2&lt;/sub&gt;&lt;span&gt;A&lt;sub&gt;3&lt;/sub&gt;A&lt;sub&gt;4&lt;/sub&gt;的最优解也很有可能不同。换言之，它们并不是同一个子问题，它们的子子树也并不相同。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这个问题意味着我们对子问题的定义不够严谨——子问题不能只用长度这个变量来确定。也就是说，如果在bottom-up的dp中用一个数组记录子问题的值，那么这个数组应该是一个&lt;strong&gt;二维&lt;/strong&gt;数组。子问题不仅应该由子矩阵链的长度确定，还要加上起始index这样的信息。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;为了更通用一些，我们不用起始index+长度，而选用起始index+结束index的定义方法，这是二维dp的惯用套路，在许多字符串和数组有关的问题中都有用到。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;设用一个二位矩阵dp[][]存取子问题的解。定义dp[i][j](1&amp;lt;=i&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;=&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;j&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;=&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;n)的值为&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;A&lt;sub&gt;i&lt;/sub&gt;...A&lt;sub&gt;j&lt;/sub&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的最小乘法次数。则按照以上的思路，可以把&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;A&lt;sub&gt;i&lt;/sub&gt;...A&lt;sub&gt;j&lt;/sub&gt;再递归细分为子问题&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;A&lt;sub&gt;i&lt;/sub&gt;...A&lt;sub&gt;k&lt;/sub&gt;和&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;A&lt;sub&gt;k+1&lt;/sub&gt;...A&lt;sub&gt;j&lt;/sub&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;(i&amp;lt;=k&amp;lt;j)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，则&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;A&lt;sub&gt;i&lt;/sub&gt;...A&lt;sub&gt;j&lt;/sub&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的最优解值为两个子问题最优解的和+两个子矩阵链相乘的乘法次数。即有&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;i==j时，dp[i][j] = 0;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;i &amp;lt;j时，dp[i][j] = min{dp[i][k] + dp[k+1][j] + p&lt;sub&gt;i-1&lt;/sub&gt;p&lt;sub&gt;k&lt;/sub&gt;p&lt;sub&gt;j&lt;/sub&gt;}, k = i...j-1&lt;/strong&gt; (p为各个矩阵的秩，见题目一节)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;到此为止，最关键的一步顺利完成啦（楼主写得好累，击掌&lt;span class=&quot;st&quot;&gt;╭(○｀∀´○)╯╰(○'◡'○)╮&lt;/span&gt;）。在这一步中，我们递归地定义了子问题最优解的值，完成了算法最核心的设计部分。在后面两步中，我们只要把上面这两个式子翻译成代码，再注意一些实现细节就可以了。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;第三步：计算最优解的值&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;细节一&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;从第二步顺理成章，我们会在一个二维数组里记录子问题的解。但是按照什么顺序去填这个二维数组是个问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还是举例子，在&lt;span&gt;&amp;lt;A&lt;sub&gt;1&lt;/sub&gt;,A&lt;sub&gt;2&lt;/sub&gt;&lt;span&gt;,A&lt;sub&gt;3&lt;/sub&gt;,A&lt;sub&gt;4&lt;/sub&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;这个矩阵链中，我们会有一个5×5的二维数组，随便挑选dp[1][4]这个元素举例。根据第二步中的状态转移方程，有&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;dp[1][4] = min{(dp[1][1]+dp[2][4]+...),(dp[1][2]+dp[3][4]+...),(dp[1][3]+dp[4][4]+...)}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;省略号表示我们此处不需关注&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;p&lt;sub&gt;i-1&lt;/sub&gt;p&lt;sub&gt;k&lt;/sub&gt;p&lt;sub&gt;j&lt;/sub&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;这一项，只需要看这个格子对其它格子的依赖是什么样子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1154131/201809/1154131-20180912130941680-2038875156.png&quot; alt=&quot;&quot; width=&quot;244&quot; height=&quot;222&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图可以看出，要计算某一个元素（粉色边框），我们需要其&lt;strong&gt;左边&lt;/strong&gt;和&lt;strong&gt;下面&lt;/strong&gt;的元素（同样深度的蓝色表示一组数据）。&lt;/p&gt;
&lt;p&gt;所以，我们的遍历方向是&lt;strong&gt;从下到上，从左到右&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;细节二&lt;br/&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;细心的读者可能注意到还有一个问题，就是我们一直在求“&lt;strong&gt;最优解的值&lt;/strong&gt;”，也就是“最小的乘法次数”，可是题目中要求的是“&lt;strong&gt;最优解&lt;/strong&gt;”，也就是“加括号的方式”。&lt;/p&gt;
&lt;p&gt;这两者并不矛盾，专注于求解前者可以让我们先思考相对简单的问题，通常在求解前者的过程中，我们也找出了后者，只是没有将它记录下来。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在此题中，我们可以选择用一个同样的二维矩阵s[][]来记录后者，其中s[i][j]中记录&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;A&lt;sub&gt;i&lt;/sub&gt;...A&lt;sub&gt;j&lt;/sub&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的分割分界线k。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;代码&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; matrixChain(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] p){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; n = p.length - 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;number of matrices&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;[][] dp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[n + 1][n + 1]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;we need dp[1][n]&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;[][] s = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[n + 1][n + 1];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;for storing of k&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] row : dp)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            Arrays.fill(row, Integer.MAX_VALUE);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt;= n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             dp[i][i] = 0;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;dp[i][j] = 0 when i == j&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = n; i &amp;gt;= 1; i--&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = i; j &amp;lt;= n; j++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(i ==&lt;span&gt; j){
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     dp[i][j] = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; k = i; k &amp;lt; j; k++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                         &lt;span&gt;int&lt;/span&gt; count = dp[i][k] + dp[k+1][j] + p[i-1]*p[k]*&lt;span&gt;p[j];
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;(count &amp;lt;&lt;span&gt; dp[i][j]){
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                             dp[i][j] = count; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;record optimal solution value&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                             s[i][j] = k;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;record splitting point k&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; dp[1&lt;span&gt;][n];
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行一个例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1154131/201809/1154131-20180912135446266-220157501.png&quot; alt=&quot;&quot; width=&quot;424&quot; height=&quot;42&quot;/&gt;&lt;/p&gt;
&lt;p&gt;即输入的数组&lt;span&gt;p为{30,35,15,5,10,20,25}。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果在return之前打印出dp[][]和s[][]的值，结果为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1154131/201809/1154131-20180912135316809-795378174.png&quot; alt=&quot;&quot; width=&quot;478&quot; height=&quot;112&quot;/&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1154131/201809/1154131-20180912135232436-1619769806.png&quot; alt=&quot;&quot; width=&quot;118&quot; height=&quot;119&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从左图可看出最优解为&lt;span&gt;dp[1][6] = 15,125，即最少可以进行一万五千多次乘法&lt;/span&gt;。右图记录了对于每一个&lt;span&gt;[i,j]决定的子矩阵链如何进行括号分割。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;顺便分享一&lt;span&gt;个ArrayPrinter的util，可以直接用，能打印出上图那样的二维int数组。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('edb52134-e2c1-4a53-a67c-4a6e1ac07336')&quot; readability=&quot;49&quot;&gt;&lt;img id=&quot;code_img_closed_edb52134-e2c1-4a53-a67c-4a6e1ac07336&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_edb52134-e2c1-4a53-a67c-4a6e1ac07336&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('edb52134-e2c1-4a53-a67c-4a6e1ac07336',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_edb52134-e2c1-4a53-a67c-4a6e1ac07336&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;93&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ArrayPrinter {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; print(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         printReplacing(&lt;span&gt;false&lt;/span&gt;, arr, 0,&quot;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; print(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[][] matrix){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         printReplacing(&lt;span&gt;false&lt;/span&gt;, matrix, 0,&quot;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; printReplacing(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; before, String after){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         printReplacing(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, arr, before, after);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; printReplacing(&lt;span&gt;int&lt;/span&gt;[][] matrix, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; before, String after){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         printReplacing(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, matrix, before, after);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--------------------------private utils-------------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; printReplacing(&lt;span&gt;boolean&lt;/span&gt; replace, &lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; before, String after){
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; maxLen =&lt;span&gt; maxLength(arr);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(replace){
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i : arr)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 print(((i==before)?&lt;span&gt;after:number(i)), maxLen);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i : arr)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                print(number(i), maxLen);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         print(&quot;\n&quot;&lt;span&gt;, maxLen);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; printReplacing(&lt;span&gt;boolean&lt;/span&gt; replace, &lt;span&gt;int&lt;/span&gt;[][] matrix, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; before, String after){
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; maxLen =&lt;span&gt; maxLength(matrix);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(replace){
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] row : matrix){
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i : row)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                     print(((i==before)?&lt;span&gt;after:number(i)), maxLen);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 print(&quot;\n&quot;&lt;span&gt;, maxLen);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] row : matrix){
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i : row)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                    print(number(i), maxLen);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 print(&quot;\n&quot;&lt;span&gt;, maxLen);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxLength(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr){
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; maxLen = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; aint : arr)
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             maxLen =&lt;span&gt; Math.max(Integer.toString(aint).length(), maxLen);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; maxLen;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxLength(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[][] matrix){
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; maxLen = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; row[] : matrix)
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             maxLen =&lt;span&gt; Math.max(maxLength(row), maxLen);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; maxLen;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     
&lt;span&gt;63&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;actual printing &lt;/span&gt;
&lt;span&gt;64&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; print(String s, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length){
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         System.out.print(String.format(&quot;%1$&quot;+(length+1)+&quot;s&quot;&lt;span&gt;, s));
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     
&lt;span&gt;68&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;formatting of number&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String number(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i){
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NumberFormat.getNumberInstance(Locale.US).format(i);
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;    } 
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;ArrayPrinter&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;使用方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ArrayPrinter.printReplacing(dp, Integer.MAX_VALUE, &quot;/&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; ArrayPrinter.print(s);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;第四步：根据计算好的信息构造最优解&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;还差一步就大功告成。这一步我们要拿着上一步计算出的&lt;span&gt;矩阵s把最终的全括号矩阵乘积打印出来。递归打印即可。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; printParenthesis(&lt;span&gt;int&lt;/span&gt;[][] s, &lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(i ==&lt;span&gt; j)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             print(&quot;A&quot;+&lt;span&gt;i);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             print(&quot;(&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            printParenthesis(s, i, s[i][j]);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             printParenthesis(s, s[i][j]+1&lt;span&gt;, j);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             print(&quot;)&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1154131/201809/1154131-20180912140514553-1911294763.png&quot; alt=&quot;&quot; width=&quot;174&quot; height=&quot;41&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;复杂度&lt;/h2&gt;
&lt;p&gt;前面说过，穷举法的复杂度大概是&lt;span&gt;O(2&lt;sup&gt;n&lt;/sup&gt;)。在以上的dp算法中，主算法需要填满一个(n+1)×(n+1)的二维数组的上半部分，每填一个元素需要一个长度为j-i的循环，可通过这个思路对j-i进行求和(i=0...n, j=i...n)，也可以通过大概估算得到时间复杂度为&lt;strong&gt;O(n&lt;sup&gt;3&lt;/sup&gt;)&lt;/strong&gt;,远好于穷举法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;空间复杂度主要由二维数组决定，为&lt;span&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本文主要介绍了解一个&lt;span&gt;dp问题的思路。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;dp问题一般有两个显著特点，这一点下一篇会详细讲述：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;问题的最优解由子问题的最优解构成&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;子问题互相重叠&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也再复习一下解题的四个步骤，看你现在有没有更深刻的理解：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分析最优解的特征。　　  　　         &lt;span&gt;（分析最优子解如何构成最优解）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;递归地定义最优解的值。               （画递归树，定义子问题，写状态转移方程）&lt;/li&gt;
&lt;li&gt;计算最优解的值。                        （写代码求出最优解，如果有要求的话，记录额外信息，为第&lt;span&gt;4步&lt;/span&gt;作准备）&lt;/li&gt;
&lt;li&gt;根据计算好的信息构造最优解。       （从第3步记录的信息中构建最优解，在本题中就是括号的写法）&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://bayanbox.ir/view/4177858657730907268/introduction-to-algorithms-3rd-edition.pdf&quot; target=&quot;_blank&quot;&gt;算法导论（英文版）3rd Ed. 15.2&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 12 Sep 2018 06:19:00 +0000</pubDate>
<dc:creator>mozi_song</dc:creator>
<og:description>前篇戳：dp入门——由分杆问题认识动态规划 导语 刷过一些算法题，就会十分珍惜“方法论”这种东西。Leetcode上只有题目、讨论和答案，没有方法论。往往答案看起来十分切中要害，但是从看题目到得到思路</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mozi-song/p/9629137.html</dc:identifier>
</item>
</channel>
</rss>