<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【年终总结】微信前端社招有感 - -渔人码头-</title>
<link>http://www.cnblogs.com/imwtr/p/10048065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imwtr/p/10048065.html</guid>
<description>&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;时间飞快，转眼间8102还差一个月就over了，顺了顺好几天没理的胡渣儿，好像已经老了不少。&lt;/p&gt;
&lt;p&gt;不，我还很年轻！虽然年终还没到，但好像也差不多了。&lt;/p&gt;
&lt;p&gt;几经辗转，年底前终于拿到了微信的offer，可以说是今年一大幸事了。&lt;/p&gt;
&lt;p&gt;是一个结束，结束本命年的坎坷；是一个开始，开始新的征程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇杂文就简单记录一下微信前端社招的经历，以及回顾这两年半做过的东西。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201812/688270-20181201030955913-1537769356.jpg&quot; alt=&quot;&quot; width=&quot;471&quot; height=&quot;628&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;一、过七关&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;微信社招，老早就听说难度极大，十几轮面试的情况都有。&lt;/p&gt;
&lt;p&gt;所以急不得，大概今年下半年开始，本菜菜就着手准备了，主要是扩充知识面以及加深对相关知识的理解与运用（暴露了平时有点懒。。。）&lt;/p&gt;
&lt;p&gt;说实话，这半年收获颇多，熬夜也最多，应该有十来次为了理清某些东西，奋战到半夜两三点，若是失败了就过几天再战...&lt;/p&gt;

&lt;p&gt;可能不同的岗位性质不同，要求也不同，对我而言，整体上对&lt;strong&gt;业务解决能力&lt;/strong&gt;要求很高，算法方面则没有太高要求&lt;/p&gt;
&lt;p&gt;每轮都问到了职业规划，为什么离开目前的环境&lt;/p&gt;
&lt;p&gt;我总共经历了七轮（4轮技术、两轮GM、一轮HR），轮次可穿插并不是按顺序的。面试体验都非常棒~&lt;/p&gt;
&lt;p&gt;当时觉得可能面不到最后，没有刻意去记录面试问的东西，所以现在也忘得差不多了，也没必要刻意去刷面试题，就算刷到了，不久之后也会忘的。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;1、技术电面（1h）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这轮算是探实力吧，确认有没有前端基础和好的项目经历。&lt;/p&gt;
&lt;p&gt;首先以在公司承担的角色作为开端，问了平常做过的一些项目，介绍其中一个，就从里头挖掘业务的问题和解决办法，同时抽取一些前端技术题。&lt;/p&gt;
&lt;p&gt;没办法，项目说起来不够复杂呀，似乎面试官并不满意，自己就趁机把话题引向了其他有特色的项目来突围。&lt;/p&gt;
&lt;p&gt;抽了一些博客上记录的知识点来问，期间竟然找了我四年前的文章（问了各种编码，以及BOM头优缺点适用性）和某道算法题 -_- &lt;/p&gt;
&lt;p&gt;HTTP和HTTPS的握手过程，是否了解HTTP2的特点，以及怎么理解它的多路复用&lt;/p&gt;
&lt;p&gt;还讲了对前端安全和性能的理解，移动端的认识等&lt;/p&gt;
&lt;p&gt;总之第一轮感觉还好，勉勉强强，话比较多，时间不慢的。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2、技术现场（1h）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这轮感觉跟第一轮差不多，只是比较正式些，来到了广州塔旁边的T.I.T&lt;/p&gt;
&lt;p&gt;除了栽在了iPhoneX刘海屏的相关问题和移动端适配是否需要支持高清屏的“争论”外，基本稳住了气场。&lt;/p&gt;
&lt;p&gt;深知自己没有可以拿出手的很牛逼的项目，为了体现自己还是会一些东东的，就只能穿插着讲出几个项目了。&lt;/p&gt;
&lt;p&gt;讲了前端优化的实践（为什么优化，怎么优化，怎么评估，还能怎么优化）&lt;/p&gt;
&lt;p&gt;前端错误收集（怎么记录，怎么区分是不是第三方插件的问题，怎么上报，怎么分析）&lt;/p&gt;
&lt;p&gt;问了PC端和移动端的转换，ES6常用的东西，数组方法大全等&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;3、技术现场（1h）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;本轮是和前一轮衔接在一起的，这种方式挺好的，可以节约候选人来回奔波时间。&lt;/p&gt;
&lt;p&gt;当时感觉是总监级别的，因为气场有点强大，短裤拖鞋很随性，判断得出来&lt;strong&gt;反应必须非常快&lt;/strong&gt;才能留下好印象，后来才知道是组长&lt;/p&gt;
&lt;p&gt;问的东西，前端方面相对少一点了，偏向于&lt;strong&gt;整体性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;问了目前团队现状，在团队前端沉淀，技术预研上做了什么，为什么这么做，有没有起到什么作用。&lt;/p&gt;
&lt;p&gt;列举几条前端代码检查规则，为什么这么制定&lt;/p&gt;
&lt;p&gt;有没有做接口的统一规范，返回码之类的规定，怎么和后端协商好这些规则，怎么让新人很好地用好这些&lt;/p&gt;
&lt;p&gt;为什么要做小程序预研，它不是很简单么&lt;/p&gt;
&lt;p&gt;MVVW是什么，有什么优缺点&lt;/p&gt;
&lt;p&gt;怎么实现记住登录功能（很强的整体性）&lt;/p&gt;
&lt;p&gt;怎么实现统一登录，或者授权登录需要考虑什么（更强的整体性）&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;4、HR现场（35min）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;直接就来到了hr面，很快吧......流程可以随意插进来&lt;/p&gt;
&lt;p&gt;一不小心提前1h到了现场，前台那小伙子也不知怎的，直接就联系hr了，说实话我本不想打扰的&lt;/p&gt;
&lt;p&gt;不过hr马上就下楼来接待了，进入稍许嘈杂的咖啡厅慢等，服务质量还阔以，在这里是要点个赞的&lt;/p&gt;
&lt;p&gt;本轮面试主要考察了团队感受，过往的项目经历，技术学习能力，薪酬期望&lt;/p&gt;
&lt;p&gt;期间面试官也很直白的说，她要知道&lt;strong&gt;有没有解决复杂问题的能力&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接从大学阶段问起了，从在校时期做的最好项目，到工作时期做的最好项目，&lt;/p&gt;
&lt;p&gt;听起来似乎还是没对胃口，就只有拿出自己为解决问题不辞辛劳很有决心的不堪历史来说了 -_- &lt;/p&gt;
&lt;p&gt;问了平时解决问题的方式，有没有从团队中学到了什么，跟谁学到的，团队中角色，觉得团队有什么问题&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;5、GM现场（30min）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;本轮是直接连着HR面的，基本没问技术，侧重&lt;strong&gt;考量业务理解能力以及是否适合部门&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看到面试官戴着一个佳明跑表，想必也是跑马人士哈哈哈，相对来说还是蛮轻松的，把之前的项目又说了一遍&lt;/p&gt;
&lt;p&gt;如果要做一个数据分析系统，在前端方面可以做什么东西（涉及了需求理解、功能拆分、技术实现）&lt;/p&gt;
&lt;p&gt;问了自己做过什么业务，期望什么业务方向&lt;/p&gt;
&lt;p&gt;介绍了职级体系，部门的业务特点&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;6、GM电面（15min）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;本轮面试可以说是最惨的了，感觉面试官并不满意自己做的项目，草草就收场了，也就诞生了第七轮技术面。&lt;/p&gt;
&lt;p&gt;团队的成员分布，各角色职责和定位，怎么进行版本迭代，一个系统的开发与维护周期是怎样的，项目延期的时候怎么做的&lt;/p&gt;
&lt;p&gt;因为做的主要是内部系统（面向公司内部的需求），被问到为什么不尝试部门间转岗，为什么两年多了还一直在做内部系统&lt;/p&gt;
&lt;p&gt;介绍公司其他部门团队的业务等&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;7、技术现场（1h）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;本轮面试属于技术交叉面，即由其他部门的人来面，主要还是因为前几轮表现不佳，让面试官们犹犹豫豫的。&lt;/p&gt;
&lt;p&gt;这小哥一直乐呵呵的，看起来很容易谈得来，也确实很容易谈得来。后面HR说他是少有的T4级前端，大大牛呀...真是随和&lt;/p&gt;
&lt;p&gt;面到后面才知道，他一直想挖出我&lt;strong&gt;拆分问题的能力&lt;/strong&gt;，如何对大的问题进行分解，逐个击破，同时思维要发散，也许还有更简便的方法。&lt;/p&gt;
&lt;p&gt;一个难题，比如我提到了曾经想过整一个适合部门的CI/CD方案并实现，不过遇到了蛮多难题就没有做下去了&lt;/p&gt;
&lt;p&gt;这里就缺了拆分问题模型的能力，不应想着难度太大做不了就做不了，而应该分析好从小的做起，一点一点地添加，慢慢坚持。&lt;/p&gt;
&lt;p&gt;其实是自己作死挖了坑自己跳进去了..&lt;/p&gt;
&lt;p&gt;说了经常写技术博客和整一些Github项目是一个非常好的习惯，挑了性能和安全方面的项目实践来问，&lt;/p&gt;
&lt;p&gt;为什么用requestAnimationFrame来代替setTimeout&lt;/p&gt;
&lt;p&gt;首屏太慢的问题除了SSR这种方法还有没有其他更简便的方法（在前端方面直接干）&lt;/p&gt;
&lt;p&gt;前端规范的落地，碰到的问题和解决过程&lt;/p&gt;
&lt;p&gt;过往业务能力与技术能力的实践&lt;/p&gt;
&lt;p&gt;有没有看过一些源码，整理的webpack项目有什么难点，怎么进行优化的&lt;/p&gt;
&lt;p&gt;怎么调试，sourcemap是什么东东&lt;/p&gt;
&lt;p&gt;两颗树比对一般怎么做，React中虚拟DOM是什么，它在树对比方面做了什么优化，新版本React有什么性能上的变化&lt;/p&gt;

&lt;p&gt;从开始到结束，进行了差不多一个月，进度好像还是蛮快的，&lt;/p&gt;
&lt;p&gt;总之，就目前这个部门的社招面试而言，我感觉侧重考察的点是 &lt;strong&gt;是否具有解决复杂业务的能力&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;当然，学习能力，技术专研，技术广度在两三年经验这个阶段是非常重要的。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、出师不利&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;其实我在这前两周，还面了微信公众平台那个部门，一面电面就跪了，面完感觉可挂可不挂的样子&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要问题出在：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用了很久的JQ，却没认真地看过源码，被问到如何像JQ那样实现动画向左再向右不同的速度，回答得七零八乱&lt;/p&gt;
&lt;p&gt;问了JQ中选择器的识别解析顺序是怎样的，为什么从右到左，我竟然说成了从左到右性能应该会更高。。。可能是大脑空白了吧&lt;/p&gt;
&lt;p&gt;问了在React中事件处理回调里面，连续setState N次，会出发几次render，理解错误，以为他说的是特殊的那种自定义事件绑定，回答了这个事件不会受到事务处理的周期影响，所以是N次。我还有骨气地争论了起来。。。&lt;/p&gt;
&lt;p&gt;问了平时有没有意识去看一些项目中用到的框架插件源码，我竟然表达出了一种并不想了解其内部实现的论调 -_-&lt;/p&gt;
&lt;p&gt;项目中的某种解决方案太暴力了，还有更优雅的方案没有用到，联想到所做项目复杂度和技术追求应该不会很高&lt;/p&gt;

&lt;p&gt;也不知当时是怎么了，面完就呆坐在那回想，不敢相信自己会那么回答&lt;/p&gt;
&lt;p&gt;应该就是很久没被面试了吧，慌了神，也没有总结好自己所做的项目，分析出项目中的重要部分，技术积累还是不足。&lt;/p&gt;
&lt;p&gt;不服呀，随之就利用了接下来的一周时间，把JQ源码完整地看了一遍，我等菜菜只看懂了八九十这样子（也算是第一次完整地看源码）&lt;/p&gt;
&lt;p&gt;然鹅，公众平台的告吹经历，直接导致了下一个运营平台的不合适（因为是同一个大团队负责的），可以说很惨烈了&lt;/p&gt;
&lt;p&gt;还好后面有个机遇&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;三、这两年半&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;算起来毕业差不多两年半了，毕业那会定下来的职业规划，前端规划，现在看来肯定是没实现多少的了。回想起来，还真没有什么可说的&lt;/p&gt;
&lt;p&gt;前一年半大概过得很潇洒，大部分周末都会带着小相机外出拍来拍去的，逛了广佛附近蛮多所谓的景点（四五十个应该有了），&lt;/p&gt;
&lt;p&gt;近一年意识到再这么下去会不会废了，就减少了周末外出的次数，想着看看书搞搞个人项目什么的，&lt;/p&gt;
&lt;p&gt;然鹅那是不可能的，在家会不知不觉玩起了手机，还熬夜玩手机...&lt;/p&gt;

&lt;p&gt;部门负责的是公司内部的系统，内部系统，即用户群体为内部员工&lt;/p&gt;
&lt;p&gt;常人看来多为管理后台，外加很多奇奇怪怪的权限&lt;/p&gt;
&lt;p&gt;权限多那是没错，但管理后台就真没几个了，内部系统也可以有各种各样的系统&lt;/p&gt;
&lt;p&gt;就系统来说，算下来应该新开发了十来个新系统了，项目参与度都非常高，各有特色，也有蛮多有意思的技术点&lt;/p&gt;
&lt;p&gt;对业务的理解能力应该有了一些提升，至少不会趋于局限，能经常从整体的逻辑关联上考虑问题了&lt;/p&gt;
&lt;p&gt;其中大概有三个系统，大大锻炼了前端整体架构方面的能力（这里指的是需求整体分解，功能模块划分及通信，技术实现规划，人员分工排期）&lt;/p&gt;
&lt;p&gt;也从最初的对产品毕恭毕敬到现在的产品沙比-_- 需求调整真是非常快&lt;/p&gt;
&lt;p&gt;整了一些移动端活动页，不过也仅是活动页了，若是说移动端的系统，我还是没有太多经验的，所以后面就跟随技术的步伐，整了个移动端的适配布局，以备不时之需。&lt;/p&gt;

&lt;p&gt;移动端的调试，部门内一直没有一个可用的方案，一碰上问题，根本不知道怎么解决。后面就整理了一个比较完整的调试方案，用得还算方便&lt;/p&gt;
&lt;p&gt;资源文件缓存的问题一直存在，很多时候大家会忘记加上时间戳（或不知道要加，或忘了加）&lt;/p&gt;
&lt;p&gt;为了改善这个问题，把尘封已久的Node.js拿出来玩了玩，整了一个本地监听文件改变则更改相关引用资源时间戳的小工具，在其他老项目中也一直沿用着&lt;/p&gt;
&lt;p&gt;在requirejs项目中的去缓存配置是比较暴力的，设置urlArgs直接配置所有资源的时间戳，后来想着能不能结合Grunt和Gulp来自定义资源的时间戳，正好也可以搞起前端构建工具，然鹅都失败了，文件依赖实在不好解决。把目光投向webpack，也是想着先结合一下，差不多到成功的时候发现，一个关键的路径依赖问题实在搞不下去了，时间关系只有放弃（当时这块已经研究了一周多了，不能再浪费时间）。就放弃了对requirejs项目进行这种时间戳优化&lt;/p&gt;
&lt;p&gt;从而也诞生了另外一个方案：使用webpack和es6（或者再加上React）作为技术栈。webpack这个东西，其实配置是蛮复杂的，好像也没有一个比较完整的构建配置例子和说明。React和Vue提供了开箱即用的脚手架，但当时觉得还是自己整一个好一点，就花了非常多精力去调试配置项，印象中最麻烦的应该就是热更新替换、jquery相关引用、编译性能、模块提取权衡、资源路径处理这几块，不过最终还是搞了起来搞出成绩，绩效拿到了唯一的一个S。多的时候会同时开十几个项目的编译进程编译，随之整了一个同步读取可用端口的npm包，防止热更新端口冲突。为了便于维护，也对开发和生产环境做了区分。&lt;/p&gt;
&lt;p&gt;后端已经完善了一套代码规范，而前端竟然参考的还是后端的PHP规范，也只有JS有这种规范。没有规矩不成方圆，就在某个季度初期，决定把前端规范搞一搞。遂参考了大大公司们的规范，结合项目中的使用情况，整了一套适合部门的规则，看着算是比较完整的。然鹅，人是不可信的，还是应该有工具来限制好这个规范的实施，又搞起了前端代码检查工具，经历了选工具、选规则集、各编辑器配置规则集、webpack配置规则检查四个痛苦的过程，本来还想弄一下SVN的hooks来做提交前检查的，只记得遇到了蛮多问题就没有继续往下了。不过，前端规范的落地，目前来说并不是非常理想，落地这块还是蛮有难度的，还得考虑后端突然也改前端的代码。&lt;/p&gt;
&lt;p&gt;渣渣电脑越来越卡，项目编译得越来越慢， 在webpack4趋于稳定的时候，觉得应该升级升级以提升效率，果不其然，升级后速度提升了近7倍。结合日常开发的那堆项目，心想应该可以让配置更为简单，便对配置项再度抽离，核心文件抹平不同项目之间文件路径的不同，对外暴露业务关键配置部分，绩效继续拿了个A&lt;/p&gt;
&lt;p&gt;前端安全这块也是一个很大的知识点，自己最初也是懵懵懂懂的，后来也是想着要彻底理解它，以在部门内进行分享为目标去研究它。在项目中不断地测试后，最后便整理出了之前那篇文章，因眼界不足还有很多可以改善的，得等以后慢慢去整了。&lt;/p&gt;
&lt;p&gt;前端性能方面，完整地看了Chrome DevTools和相关官方出品的文档，早些时候也过了过那本《Webkit技术内幕》。目前进行了四个比较有意义的优化实践，两个移动端活动页的卡顿优化（主要是安卓手机呀为什么经常卡..），一个页面加载性能优化，一个页面运行时性能优化。目前正在尝试做JS运行优化的实践&lt;/p&gt;
&lt;p&gt;前端错误记录，打点监控方面，也没有做过太多的实践，这个和前端测试一样，都算是没啥经验了。目前正在开展这块的调研&lt;/p&gt;
&lt;p&gt;源码解析方面，完整看了JQ源码，看了React源码实现的主要部分，理解了webpack编译生成的文件规则&lt;/p&gt;
&lt;p&gt;看书方面，看了两本小说，十几本技术相关的&lt;/p&gt;
&lt;p&gt;个人项目方面，就写了四五个小项目&lt;/p&gt;

&lt;p&gt;带了两个新人，第一个是个好苗子可惜后面就撤了&lt;/p&gt;
&lt;p&gt;另外一个就差一些了，没啥基础，校招后端转过来的（也不能怪他，就怪老大骗他进来做前端）&lt;/p&gt;
&lt;p&gt;面了十几个人，有不一样的感受，还是很感谢能有这种面人的经历的&lt;/p&gt;
&lt;p&gt;团队管理方面，说真的，我们前端老大真是失职呀，团队基本没什么成长，没什么规划，也经常请假，我都替他忧心。找个好老大很重要&lt;/p&gt;
&lt;p&gt;所以平时就承担了一些本该前端负责人才做的工作，也了解到并实践了一些管理者的日常&lt;/p&gt;
&lt;p&gt;然鹅好像没啥兴趣，看起来我还是比较偏向做技术的...&lt;/p&gt;

&lt;p&gt;最后回头看看，技术提升的曲线的是有些放缓了，可能我不算是那种Geek吧，有时会懒得写代码懒得做技术，有时又很能投入进去。&lt;/p&gt;
&lt;p&gt;应该多回顾一下过于做过的东西，有没有价值，有没有提升，自己有没有懈怠。多看看外面的世界是怎样的。&lt;/p&gt;
&lt;p&gt;新的平台，带来新的机遇和挑战，就加油吧 ^-^&lt;/p&gt;

</description>
<pubDate>Fri, 30 Nov 2018 19:11:00 +0000</pubDate>
<dc:creator>-渔人码头-</dc:creator>
<og:description>时间飞快，转眼间8102还差一个月就over了，顺了顺好几天没理的胡渣儿，好像已经老了不少。 不，我还很年轻！虽然年终还没到，但好像也差不多了。 几经辗转，年底前终于拿到了微信的offer，可以说是今</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imwtr/p/10048065.html</dc:identifier>
</item>
<item>
<title>裁员浪潮，互联网人该何去何从？ - 初一丶</title>
<link>http://www.cnblogs.com/wyl-0120/p/10047907.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyl-0120/p/10047907.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;就在昨天某互联网公司副总裁发了一条微博&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img title=&quot;图片描述&quot; src=&quot;http://img.mukewang.com/5c0166a200017e0004360614.png&quot; alt=&quot;图片描述&quot;/&gt;图片描述&lt;/p&gt;
&lt;p&gt;今年以来，众多知名互联网企业纷纷宣布裁员、缩减招聘，调整人才发展策略。仅仅在即将结束的九月，压缩招聘的队伍中就聚齐了中国三大巨头BAT(百度、阿里巴巴、腾讯公司的简称)。有人警示，这是一个危险的信号，预示着互联网行业的寒冬将至，全球缩招裁员潮滚滚来袭。从第一波冲击的传统行业，第二波是爆雷的P2P，第三波是互联网公司，对于一众寻求自保的企业主来说，裁员成了当下简单粗暴却也无法避免的必要手段。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;2018年6月以来，全国上百家P2P平台接连爆雷,裁员潮在互金领域抢先发生。&lt;br/&gt;2018年7月20日，《国税地税征管体制改革方案》正式确定了社保费用将由税务部门统一征收，并将于2019年1月1日正式实施新政方案。&lt;br/&gt;2018年8月25日，美图公司Q2季度财报收入同比下降5.9%，净亏损1.27亿，较上年同比收窄3.4%，随即网曝美图公司裁员消息。&lt;br/&gt;2018年8月27日，拉勾网前CEO马德龙离职，并随即网曝拉勾网裁员消息，而极具讽刺的是拉勾网本身即是一家专注于互联网人才的招聘平台。&lt;br/&gt;2018年8月28日,网曝碧桂园裁员30%,后官方回应人才优化属企业日常管理行为.&lt;br/&gt;2018年8月30日，网曝人民币创投基金将采取新政，税收从20%或将调整至35%。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回顾历史，2001年纳斯达克互联网泡沫破灭之时，网景为首的一众北美互联网公司的破产裁员和重组。2008年，全球金融危机大背景下的中国互联网公司，百度与阿里巴巴在此前后分别进行了大幅度的裁员瘦身与业务线的战略级调整，从而在那次寒冬中侥幸不死。&lt;/p&gt;
&lt;p&gt;十几年后的今天，在同样糟糕的外部条件下已经不再年轻的第一代中国互联网人正深陷中年危机的折磨，一部分人选择了离开，而更多的则是栖身于公司中高层为了自保而不惜政治斗争；与此同时，又以「今日头条」为代表，崛起于移动互联网时代，过去从来都是散尽千金求猛将的第二代中国互联网公司，如今在寒冬前却面临自断手足的痛苦抉择。究竟是温水煮青蛙在作死中等死，还是在等死前勉强求生？&lt;/p&gt;
&lt;p&gt;2017年12月，来自原天猫商城的运营专家老袁递交了辞呈，离开了工作9年的阿里巴巴后，他转向一家D轮公司，并直接进入了该公司的中层管理团队。刚刚才喜添爱子的他之所以离开外界看来高收入，且稳定的大平台，而转入存在着诸多风险和不确定因素的创业公司的直接原因是他认为自己和平台当前都面临着第一代互联网人中年危机的焦虑。「内部流行的说法就是32岁P8，一分为二的看就是32岁了还不到P8的人和32岁前想升到P8的人都是属于一种情况。」老袁离职几天后，阿里巴巴集团高层迎来两名少壮派代表：一位是已经被《中国企业家》提前「封神」的70后「新零售尖刀」——靖捷出任天猫总裁，另一位则是谷歌出身就任淘宝网总裁的85后「少帅」——蒋凡。官方力推两位年轻的高层，一方面证明了阿里的大脑和决策中枢依然年轻且充满活力，另一方面也直接对位了自己的竞争对手：70后的京东刘强东和80后同为谷歌中国出身的拼多多黄峥，阿里此番点将后的牌面堪称麻将桌上的一把「对对胡」。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图片描述&quot; src=&quot;http://img.mukewang.com/5c01670c00016d2706400427.jpg&quot; alt=&quot;图片描述&quot;/&gt;图片描述&lt;br/&gt;2018年9月，传统互联网公司的校招季正式开启，刚刚因为新闻「被裁员」的腾讯公司甚至开出3000人规模的校招岗位，BAT们即将迎来出生于1995年以后的小朋友。而这些小朋友的老板——那些70后的第一代互联网人中的大多数已经位居上述企业的中层管理团队，眼下已是40多岁还生了一堆小朋友的他们除了在内网吐槽95后新人的奇葩举动外，新的问题则是如何基于这些躁动的年轻人在保持自己部门稳定发展的同时，自己本人又不被淘汰。&lt;/p&gt;

&lt;p&gt;2018年的前9个月时间里，中年腾讯VS少年头条，上演了腾讯自2011年3Q大战以来最为严重的一次危机，并在此期间被成功贴上了「没梦想」的标签；中年淘宝VS少年拼多多，无论公关暗战还是「淘宝特价」+「拼团」的双重打击，拼多多最新Q2财报依然亮眼：收入环比增长96%，较去年同期增长2490%，所谓「消费降级巨头」抢了增量市场又抄了阿里后路的同时恰逢遭遇国内经济下行，让战略层主打新零售+消费升级的阿里很是焦虑。今日头条和拼多多的相继得手，除去战略战术运用上的巧妙外，非常重要的一点是两家年轻的互联网公司至少当前还不存在所谓的「大企业病」。&lt;/p&gt;
&lt;p&gt;互联网寒冬给人的绝望不只是它先前割韭菜时的毫不手软，而是其赶尽杀绝时的心狠手辣。挥刀见血，有时已是最大的仁慈。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图片描述&quot; src=&quot;http://img.mukewang.com/5c01671600010d7806830485.jpg&quot; alt=&quot;图片描述&quot;/&gt;图片描述&lt;br/&gt;通过分析BATJ(百度、阿里、腾讯、京东)还有网易近五年的市值，2018年后五个大厂的市值上都在下降，尤其是京东和网易，这当然也和大环境有关。我们看看这五大公司在18年有哪些大的变化：&lt;/p&gt;

&lt;p&gt;百度：中国大陆网路公司百度18日晚上宣布陆奇卸任集团总裁和营运长后，百度在美上市股票连着18日和21日两个交易日大幅下跌共14%，市值蒸发137亿美元（新台币4110亿元）。&lt;/p&gt;
&lt;p&gt;阿里：中国最大的电子商务企业阿里巴巴集团联合创始人马云宣佈，他将在「一年后的今天」，即2019年9月10日起不再担任集团董事局主席。&lt;/p&gt;
&lt;p&gt;腾讯：大陆互联网巨头腾讯今年1月股价创新高，但此势头并未延续，截至昨（14）日，股价跌幅逾13％，市值缩水770亿美元。外界分析，这跟腾讯多投资和其主营业务无关的业务，成本大幅提高，及游戏业务放缓有关。腾讯明将公布第一季财报，预计将面临2003年以来最差的业绩。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图片描述&quot; src=&quot;http://img.mukewang.com/5c016721000166fa04970342.jpg&quot; alt=&quot;图片描述&quot;/&gt;图片描述&lt;/p&gt;
&lt;p&gt;京东：9月2日刘强东“性侵事件”造成美国上市的京东股票暴跌，仅仅两个交易日股价跌去15.97%，市值蒸发487亿美元，相当于3300亿人民币。&lt;/p&gt;
&lt;p&gt;网易：股价走势在一定程度上反映业绩。今年以来，网易股价跌去约35%，市值缩水超1000亿元。而这份有些“尴尬”的二季度财报，显示出网易目前的隐忧。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图片描述&quot; src=&quot;http://img.mukewang.com/5c0167410001902a07910592.jpg&quot; alt=&quot;图片描述&quot;/&gt;图片描述&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人认为互联网寒潮只是部分公司。&lt;/strong&gt;&lt;br/&gt;至于普通员工如何扛过去呢？&lt;/p&gt;
&lt;p&gt;很简单啊，别让自己自己被裁掉就好了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那怎么不让自己被裁掉呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尽力做好自己的工作，不要被末尾淘汰掉，当然，真要裁人，可能你表现很好也会被裁掉，但是做好自己的工作至少让你有一技防身。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果不幸被裁掉了怎么办呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找下一个工作啊，不过这需要你在被裁之前就做好准备，还是那句话，让自己有一技防身，这一技最好是行业通用的，而不是只在一个组织里有用的，比如，你作为产业经理只会伺候某一个公司的CEO，但是对业界产品设计一窍不通，那被裁了就惨了。预先学习一些行业有通用需求的技能，对你有百益而无一害。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果被裁掉之后还找不到工作怎么办呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接着找，我见过找工作找了一年才找到合适工作的人，当然，前提是你的存款能支持你生活这么久，所以，不要做月光族，人还是应该有一些储蓄，以备不时之需。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果我没有储蓄怎么做呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从今天开始就存钱。&lt;/p&gt;
&lt;p&gt;与其他行业相比，IT公司因裁员、辞职等造成的人力资源流动率总体上要高一点，就算是全行业范围内，在某个特定阶段有相当数量公司批量裁员，历史上也不止发生过一次。总是有涨有落，这事实属正常。对于普通员工，日子好过时别把钱都花光了，要有点积蓄。如果买房子，别“越大越好”，确实，&quot;大房子&quot;住得舒服，但每月还贷也多，要量力而行，比如你现在月入3万，当前月供1万似乎问题不大，但风险在于你不能假设这个收入能够持续多年，并且你的收入一直是上升的，这就太乐观了。在手中一定要保留有足够的现金流，这很重要！！！技术上要多学几手，多个本事多条路，“把鸡蛋放到一个篮子里”是很危险的。程序员要横向拓展自己的技术，不要只顾着深钻，因为技术进步太快，万一你所深钻的技术被&quot;颠覆&quot;，而你又不会别的，那就危险了!!!&lt;/p&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;欢迎关注我的个人公众号：&lt;strong&gt;程序员共成长&lt;/strong&gt;。给新来的小伙伴们准备了见面礼。包括但不限于：Java、Python、数据库、大数据、架构和各方向电子书回复【礼包】 可根据自己需求进行选择。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 30 Nov 2018 16:41:00 +0000</pubDate>
<dc:creator>初一丶</dc:creator>
<og:description>就在昨天某互联网公司副总裁发了一条微博 图片描述 今年以来，众多知名互联网企业纷纷宣布裁员、缩减招聘，调整人才发展策略。仅仅在即将结束的九月，压缩招聘的队伍中就聚齐了中国三大巨头BAT(百度、阿里巴巴</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyl-0120/p/10047907.html</dc:identifier>
</item>
<item>
<title>Redis数据类型（上） - MrChengs</title>
<link>http://www.cnblogs.com/Mrchengs/p/10047880.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mrchengs/p/10047880.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据类型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.string（字符串）&lt;/p&gt;
&lt;p&gt;2.hash（哈希，类似java里的Map）&lt;/p&gt;
&lt;p&gt;3.list（列表）&lt;/p&gt;
&lt;p&gt;4.set（集合）&lt;/p&gt;
&lt;p&gt;5.zset(sorted set：有序集合)&lt;/p&gt;
&lt;p&gt;6.基数&lt;/p&gt;

&lt;p&gt;String（字符串）&lt;/p&gt;
&lt;p&gt;string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。&lt;/p&gt;
&lt;p&gt;string类型是&lt;span&gt;&lt;strong&gt;二进制安全的&lt;/strong&gt;&lt;/span&gt;。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。&lt;/p&gt;
&lt;p&gt;string类型是Redis&lt;span&gt;&lt;strong&gt;最基本的数据类型&lt;/strong&gt;&lt;/span&gt;，一个redis中字符串value最多可以是512M&lt;/p&gt;

&lt;p&gt;Hash（哈希）&lt;/p&gt;
&lt;p&gt;Redis hash 是一个键值对集合。&lt;/p&gt;
&lt;p&gt;Redis hash是一个string类型的&lt;strong&gt;&lt;span&gt;field&lt;/span&gt;&lt;/strong&gt;和&lt;span&gt;&lt;strong&gt;value&lt;/strong&gt;&lt;/span&gt;的映射表，hash特别适合用于存储对象。&lt;/p&gt;
&lt;p&gt;类似Java里面的Map&amp;lt;String,Object&amp;gt;&lt;/p&gt;

&lt;p&gt;List（列表）&lt;/p&gt;
&lt;p&gt;Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;它的底层实际是个链表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Set（集合）&lt;/p&gt;
&lt;p&gt;Redis的Set是string类型的&lt;span&gt;&lt;strong&gt;无序&lt;/strong&gt;&lt;/span&gt;集合。它是通过&lt;span&gt;&lt;strong&gt;HashTable实现实现的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;zset(sorted set：有序集合)&lt;/p&gt;
&lt;p&gt;Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。&lt;/p&gt;
&lt;p&gt;不同的是每个元素都会关联一个&lt;span&gt;&lt;strong&gt;double&lt;/strong&gt;&lt;/span&gt;类型的&lt;strong&gt;&lt;span&gt;分数&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;命令地址：&lt;a href=&quot;http://redisdoc.com/&quot;&gt;&lt;span&gt;http://redisdoc.com/&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Redis 键(key)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. keys *&lt;/p&gt;
&lt;p&gt;2. exists key的名字，判断某个key是否存在&lt;/p&gt;
&lt;p&gt;3. move key db   ---&amp;gt;当前库就没有了，被移除了&lt;/p&gt;
&lt;p&gt;4. expire key 秒钟：为给定的key设置过期时间&lt;/p&gt;
&lt;p&gt;5. ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期,即已被删除&lt;/p&gt;
&lt;p&gt;6. type key 查看你的key是什么类型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130234922708-1451981142.png&quot; alt=&quot;&quot; width=&quot;373&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130234955109-64351801.png&quot; alt=&quot;&quot; width=&quot;425&quot; height=&quot;187&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130235036629-1178918512.png&quot; alt=&quot;&quot; width=&quot;393&quot; height=&quot;173&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130235045568-1557236834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;&lt;span&gt;String类型：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字符串是Redis的最基本额数据结构，以一个键和一个值存储在Redis内部&lt;/p&gt;
&lt;p&gt;类似java的Map结构，通过键去找值&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130235213315-811181487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基本命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130235235272-1239054055.png&quot; alt=&quot;&quot; width=&quot;612&quot; height=&quot;259&quot;/&gt;&lt;/p&gt;
&lt;p&gt;支持简单运算的命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130235303501-1832273289.png&quot; alt=&quot;&quot; width=&quot;592&quot; height=&quot;135&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 下面是代码的测试流程：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130235330609-942771064.png&quot; alt=&quot;&quot; width=&quot;413&quot; height=&quot;131&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130235443989-597405051.png&quot; alt=&quot;&quot; width=&quot;449&quot; height=&quot;204&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;getrange/setrange&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;getrange:获取指定区间范围内的值，类似between......and的关系从零到负一表示全部，默认从0开始&lt;/p&gt;
&lt;p&gt;                0 -1：代表全部&lt;/p&gt;
&lt;p&gt;setrange设置指定区间范围内的值，格式是&lt;span&gt;setrange key值 具体值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;            &lt;span&gt;即修改原来字符串额值从某个位置开始 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130235736517-271538951.png&quot; alt=&quot;&quot; width=&quot;488&quot; height=&quot;201&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; setex(set with expire)键秒值/setnx(set if not exist)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;setex:设置带过期时间的key，动态设置。&lt;/p&gt;
&lt;p&gt;            setex 键 秒值 真实值&lt;/p&gt;
&lt;p&gt;setnx:只有在 key 不存在时设置 key 的值。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130235911943-717358601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; mset/mget/msetnx&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mset:同时设置&lt;span&gt;一个或多个&lt;/span&gt; key-value 对。&lt;/p&gt;
&lt;p&gt;mget:获取所有(&lt;span&gt;一个或多个&lt;/span&gt;)给定 key 的值。&lt;/p&gt;
&lt;p&gt;msetnx:同时设置一个或多个 key-value 对，当且仅当&lt;span&gt;所有给定 key 都不存在&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;            否则不生效&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130235927497-142876381.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;&lt;span&gt;链表List&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;链表结构是 Redis 中一个常用的结构，它可以存储多个字符串，而且它是有序的&lt;/p&gt;
&lt;p&gt;Redis 链表是双向的，&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201000908569-807836505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用链表结构就意味着读性能的丧失&lt;/p&gt;
&lt;p&gt;链表只能从 个方向中去遍历所要节点&lt;/p&gt;
&lt;p&gt;优势：在于插入和删除的便利&lt;/p&gt;
&lt;p&gt;链表的数据节点是分配在不同的内存域的，并不连续&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201000922616-361232905.png&quot; alt=&quot;&quot; width=&quot;516&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此可见，链表结构的使用是需要注意场景的，对于那些经常需要对数据进行插入和&lt;/p&gt;
&lt;p&gt;删除的列表数据使用它是十分方便的，因为它可以在不移动其他节点的情况下完成插入和&lt;/p&gt;
&lt;p&gt;删除。而对于需要经常查找的，使用它性能并不佳，它只能从左到右或者从右到左的查找&lt;/p&gt;
&lt;p&gt;和比对。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201000947281-1663368522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; lpush/rpush/lrange&lt;/p&gt;
&lt;p&gt;lpush: 从链表的左边插入&lt;/p&gt;
&lt;p&gt;rpush: 从链表的右边插入&lt;/p&gt;
&lt;p&gt;lrange ：查看链表的节点值&lt;/p&gt;
&lt;p&gt;            &lt;span&gt;  lrange  list  start    end          end=-1代表全部&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201001132993-1221484791.png&quot; alt=&quot;&quot; width=&quot;460&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;p&gt; lpop/rpop&lt;/p&gt;
&lt;p&gt;lpop:删除左边的第一个节点，&lt;span&gt;并且将其返回&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;rpop：删除右边第一个节点，&lt;span&gt;并且将其返回&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201001153446-1374327441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; lindex，按照索引下标获得元素(从上到下)&lt;/p&gt;
&lt;p&gt;lindex：  lindex key index，&lt;span&gt;索引从零开始&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过索引获取列表中的元素 &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201001248455-1238787070.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; llen&lt;/p&gt;
&lt;p&gt;求链表的长度，&lt;span&gt;返回长度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201001402022-1691475020.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; lrem key 删N个value&lt;/p&gt;
&lt;p&gt; * 从left往right删除2个值等于v1的元素，返回的值为实际删除的数量&lt;/p&gt;
&lt;p&gt; *  LREM list3 0 值，表示删除全部给定的值。零个就是全部值&lt;/p&gt;
&lt;p&gt;   &lt;span&gt; lrem list 个数  节点值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201001507016-1695918517.png&quot; alt=&quot;&quot; width=&quot;501&quot; height=&quot;298&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ltrim key 开始index 结束index，截取指定范围的值后再赋值给key&lt;/p&gt;
&lt;p&gt;ltrim：截取指定索引区间的元素，格式是ltrim list的key 起始索引 结束索引&lt;/p&gt;
&lt;p&gt;       【start end】 开区间    会把截取的内容保存在原来的list中，默认截取位置从0 开始&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201001648216-1976904798.png&quot; alt=&quot;&quot; width=&quot;505&quot; height=&quot;189&quot;/&gt;&lt;/p&gt;
&lt;p&gt; rpoplpush 源列表 目的列表&lt;/p&gt;
&lt;p&gt;移除列表的最后一个元素，并将该元素添加到另一个列表并返回&lt;/p&gt;
&lt;p&gt;&lt;span&gt;移除源列表的最后一个元素并且将其左插到目的列表中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201002110785-713504670.png&quot; alt=&quot;&quot; width=&quot;480&quot; height=&quot;395&quot;/&gt;&lt;/p&gt;
&lt;p&gt; lset key index value&lt;/p&gt;
&lt;p&gt;给index出的索引修改值&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201002133113-289591494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;linsert key  before/after 值1 值2&lt;/p&gt;
&lt;p&gt;在值1 前面/后面  插入值2&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201002152542-1725962709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它是一个字符串链表，left、right都可以插入添加；&lt;/p&gt;
&lt;p&gt;如果键不存在，创建新的链表；&lt;/p&gt;
&lt;p&gt;如果键已存在，新增内容；&lt;/p&gt;
&lt;p&gt;如果值全移除，对应的键也就消失了。&lt;/p&gt;
&lt;p&gt;链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;链表的命令都是进程不安全的，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Red is 提供了链表的阻塞命令，它 在运行的时候 会给链表加锁，以保&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;证操作链表的命令安全性，&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 30 Nov 2018 16:23:00 +0000</pubDate>
<dc:creator>MrChengs</dc:creator>
<og:description>数据类型 1.string（字符串） 2.hash（哈希，类似java里的Map） 3.list（列表） 4.set（集合） 5.zset(sorted set：有序集合) 6.基数 String（字</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mrchengs/p/10047880.html</dc:identifier>
</item>
<item>
<title>机器学习笔记(2)  集成学习 随机森林先导知识 - sdu20112013</title>
<link>http://www.cnblogs.com/sdu20112013/p/10032795.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdu20112013/p/10032795.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;每一种机器学习算法都可以看做是一种看待数据的视角.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就像我们看待一个问题,一个观点一样.每一种视角必然有他合理的地方,也有他片面的地方.对机器学习而言,也是一样.所以为了提高我们对数据的了解程度,我们要尽可能地从多个视角考&lt;span&gt;察我们的数据. 这样对&lt;/span&gt;新的test data,不管是分类还是回归,我们才可能有更高的预测准确率.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际上上述过程,就是所谓的ensemble。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;集成学习&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;机器学习中的集成学习就是将选择若干算法，针对同样的train data去训练模型，然后看看结果，使用投票机制，少数服从多数，用多数算法给出的结果当作最终的决策依据，这就是集成学习的核心思路.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.voting&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;from sklearn.ensemble import VotingClassifier

voting_clf = VotingClassifier(estimators=[
    ('log_clf', LogisticRegression()), 
    ('svm_clf', SVC()),
    ('dt_clf', DecisionTreeClassifier(random_state=666))],
                             voting='hard')&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://sklearn.apachecn.org/cn/latest/modules/generated/sklearn.ensemble.VotingClassifier.html#sklearn.ensemble.VotingClassifier&quot; target=&quot;_blank&quot;&gt;VotingClassifier&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;em class=&quot;property&quot;&gt;class &lt;/em&gt;&lt;code class=&quot;descclassname&quot;&gt;sklearn.ensemble.&lt;/code&gt;&lt;code class=&quot;descname&quot;&gt;VotingClassifier&lt;/code&gt;&lt;span class=&quot;sig-paren&quot;&gt;(&lt;em&gt;estimators&lt;/em&gt;, &lt;em&gt;voting='hard'&lt;/em&gt;, &lt;em&gt;weights=None&lt;/em&gt;, &lt;em&gt;n_jobs=1&lt;/em&gt;, &lt;em&gt;flatten_transform=None&lt;/em&gt;&lt;span class=&quot;sig-paren&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这里解释一下voting这个参数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举一个例子，假设有3个模型，针对同一个二分类问题，将每种类别都计算出了概率：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;模型1 A-99%，B-1%&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;模型2 A-49%，B-51%&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;模型3 A-49%，B-51%&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;如果单纯地投票的话,会分类为B.  这就是所谓的hard voting。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然而显然是有问题的,因为模型1非常确认类别应该是A（99%），而模型2和模型3几乎无法认定是A还是B（49% VS 51%）,那么这种情况下，将结果分类为A是更合理的.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这也就引入了soft voting。即根据概率来投票.  p(A)=(0.99 + 0.49 + 0.49)/3 = 0.657  p(B)=(0.01+0.51+0.51)/3 = 0.343  p(A)&amp;gt;p(B)所以应该分类为A。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.bagging&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从投票的角度来说,虽然有了很多机器学习算法,但是还是不够多！ 所以我们想创建尽可能多的子模型,集成各种子模型的意见.同时又要保证子模型之间要有差异,否则就失去了投票的意义.&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;我们想要尽可能多的子模型&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;子模型之间要有差异性&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;那么怎么保证子模型的差异性呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一种简单的方法：让机器学习算法只训练训练集的一部分.  那么这又带来一个问题,每个子模型只学习到了一部分的训练数据信息,那么这种子模型的预测准确率不就很低了吗？答案是肯定的,&lt;strong&gt;单个子模型的准确率确实会降低,但是没有关系.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如单个子模型的准确率为51%&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么整个系统的准确率为&lt;strong&gt;：$$P=\sum_{i=m/2}^mC_m^ip^i(1-p)^{m-i}$$&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; scipy.special &lt;span&gt;import&lt;/span&gt;&lt;span&gt; comb, perm&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(x,n):
    r &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(x,n+1&lt;span&gt;):
        r &lt;/span&gt;+= comb(n,i)*np.power(0.51,i)*np.power(0.49,n-&lt;span&gt;i)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; r &lt;/span&gt;&lt;p&gt;&lt;span&gt;f(2,3) = 0.5149980000000001&lt;/span&gt;&lt;br/&gt;&lt;span&gt;f(251,500) = 0.6564399889597903&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;由以上代码可以看到,当子模型的准确率为51%时，如果一个系统有3个子模型,那么系统的准确率为51.5%。  当一个系统有500个子模型时,准确率则到了65.6%.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;怎么样从训练数据中取出一部分呢？即如何取样？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;放回取样          bagging 更常用.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不放回取样      pasting&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;我们把放回取样叫bagging，不放回取样叫pasting。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;放回取样的方式可以训练更多的模型. 在一次模型的fit中,比如样本500,每次取100,不放回取样最多只能训练5个子模型.  放回可以训练成千上万个子模型.并且由pasting能训练的次数太少,这500个样本划分成怎样的5个100就有讲究了,可能会对最后的结果带来很大的影响.  bagging的话在成千上万个子模型的训练中就一定程度上消除了这种随机性.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;out of bag(OOB)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;放回取样的一个问题是:在有限次的取样过程中,有一部分样本可能一直没被选取到.大概有37%的样本没有取到.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数学证明可以参考一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/cholocatehe/article/details/42130341&quot; target=&quot;_blank&quot;&gt;37%的由来&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以用这部分没被取样的数据集作为我们的验证集.  sklearn中的oob_score_就是相应的验证集得到的分数.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.BaggingClassifier.html#sklearn.ensemble.BaggingClassifier&quot; target=&quot;_blank&quot;&gt;sklearn中的bagging&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;83.977869986169&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;em class=&quot;property&quot;&gt;class &lt;/em&gt;&lt;code class=&quot;descclassname&quot;&gt;sklearn.ensemble.&lt;/code&gt;&lt;code class=&quot;descname&quot;&gt;BaggingClassifier&lt;/code&gt;&lt;span class=&quot;sig-paren&quot;&gt;(&lt;em&gt;base_estimator=None&lt;/em&gt;, &lt;em&gt;n_estimators=10&lt;/em&gt;, &lt;em&gt;max_samples=1.0&lt;/em&gt;, &lt;em&gt;max_features=1.0&lt;/em&gt;, &lt;em&gt;bootstrap=True&lt;/em&gt;, &lt;em&gt;bootstrap_features=False&lt;/em&gt;, &lt;em&gt;oob_score=False&lt;/em&gt;, &lt;em&gt;warm_start=False&lt;/em&gt;, &lt;em&gt;n_jobs=None&lt;/em&gt;, &lt;em&gt;random_state=None&lt;/em&gt;, &lt;em&gt;verbose=0&lt;/em&gt;&lt;span class=&quot;sig-paren&quot;&gt;)&lt;a class=&quot;reference external&quot; href=&quot;https://github.com/scikit-learn/scikit-learn/blob/55bf5d9/sklearn/ensemble/bagging.py#L430&quot;&gt;&lt;span class=&quot;viewcode-link&quot;&gt;[source]&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;base_estimator&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;object or None, optional (default=None)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;The base estimator to fit on random subsets of the dataset. If None, then the base estimator is a decision tree.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;n_estimators&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;int, optional (default=10)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;The number of base estimators in the ensemble.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;max_samples&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;int or float, optional (default=1.0)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first&quot;&gt;The number of samples to draw from X to train each base estimator.&lt;/p&gt;
&lt;ul class=&quot;last simple&quot;&gt;&lt;li&gt;If int, then draw &lt;cite&gt;max_samples&lt;/cite&gt; samples.&lt;/li&gt;
&lt;li&gt;If float, then draw &lt;cite&gt;max_samples * X.shape[0]&lt;/cite&gt; samples.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;max_features&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;int or float, optional (default=1.0)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first&quot;&gt;The number of features to draw from X to train each base estimator.&lt;/p&gt;
&lt;ul class=&quot;last simple&quot;&gt;&lt;li&gt;If int, then draw &lt;cite&gt;max_features&lt;/cite&gt; features.&lt;/li&gt;
&lt;li&gt;If float, then draw &lt;cite&gt;max_features * X.shape[1]&lt;/cite&gt; features.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;bootstrap&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;boolean, optional (default=True)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;Whether samples are drawn with replacement.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bootstrap_features&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;boolean, optional (default=False)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;Whether features are drawn with replacement.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;oob_score&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;bool, optional (default=False)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;Whether to use out-of-bag samples to estimate the generalization error.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;warm_start&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;bool, optional (default=False)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first&quot;&gt;When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new ensemble. See &lt;a class=&quot;reference internal&quot; href=&quot;https://scikit-learn.org/stable/glossary.html#term-warm-start&quot;&gt;the Glossary&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;last versionadded&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;versionmodified&quot;&gt;New in version 0.17: &lt;em&gt;warm_start&lt;/em&gt; constructor parameter.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;n_jobs&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;int or None, optional (default=None)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;The number of jobs to run in parallel for both &lt;cite&gt;fit&lt;/cite&gt; and &lt;cite&gt;predict&lt;/cite&gt;. &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;None&lt;/span&gt;&lt;/code&gt; means 1 unless in a &lt;a class=&quot;reference external&quot; title=&quot;(in joblib v0.13.0)&quot; href=&quot;https://joblib.readthedocs.io/en/latest/parallel.html#joblib.parallel_backend&quot;&gt;&lt;code class=&quot;xref py py-obj docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;joblib.parallel_backend&lt;/span&gt;&lt;/code&gt;&lt;/a&gt; context. &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;-1&lt;/span&gt;&lt;/code&gt; means using all processors. See &lt;a class=&quot;reference internal&quot; href=&quot;https://scikit-learn.org/stable/glossary.html#term-n-jobs&quot;&gt;Glossary&lt;/a&gt; for more details.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;random_state&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;int, RandomState instance or None, optional (default=None)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by &lt;cite&gt;np.random&lt;/cite&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;verbose&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;int, optional (default=0)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;Controls the verbosity when fitting and predicting.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;first&quot;&gt;&lt;span&gt;max_samples  每个子模型取样的样本数&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first&quot;&gt;&lt;span&gt;bootstrap 为true表示放回取样&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first&quot;&gt;&lt;span&gt;oob_score 是否使用out-of-bag samples做验证&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; bagging_clf =&lt;span&gt; BaggingClassifier(DecisionTreeClassifier(),
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;                                n_estimators=500, max_samples=100&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                                bootstrap=True, oob_score=&lt;span&gt;True,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                                n_jobs=-1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; bagging_clf.fit(X, y)
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;first&quot;&gt;&lt;strong&gt;随机森林Random Forest&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;first&quot;&gt;了解了前面ensemble的相关概念后,就很容易理解随机森林了. 所谓随机森林,就是由很多个decision tree做ensemble得到的模型.&lt;/p&gt;
&lt;p class=&quot;first&quot;&gt;后面的文章会继续详细介绍random forest&lt;/p&gt;
&lt;p class=&quot;first&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;first&quot;&gt;&lt;span&gt;机器学习笔记系列文章列表&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/sdu20112013/p/10032468.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;机器学习笔记(1) 决策树&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;first&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/sdu20112013/p/10032795.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;机器学习笔记(2)  集成学习 随机森林先导知识&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;first&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;first&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;first&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;first&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;first&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Fri, 30 Nov 2018 16:07:00 +0000</pubDate>
<dc:creator>sdu20112013</dc:creator>
<og:description>每一种机器学习算法都可以看做是一种看待数据的视角. 就像我们看待一个问题,一个观点一样.每一种视角必然有他合理的地方,也有他片面的地方.对机器学习而言,也是一样.所以为了提高我们对数据的了解程度,我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sdu20112013/p/10032795.html</dc:identifier>
</item>
<item>
<title>redux源码解析(深度解析redux) - 薛小白</title>
<link>http://www.cnblogs.com/yangyangxxb/p/10047648.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangyangxxb/p/10047648.html</guid>
<description>&lt;h2&gt;redux源码解析&lt;/h2&gt;
&lt;p&gt;1、首先让我们看看都有哪些内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459163/201811/1459163-20181130224428163-1065981613.png&quot; alt=&quot;&quot; width=&quot;229&quot; height=&quot;391&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;2、让我们看看redux的流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459163/201811/1459163-20181130230204491-2018619875.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;Store：一个库，保存数据的地方，整个项目只有一个&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;　　　　创建store&lt;/p&gt;
&lt;p&gt;　　　　　　Redux提供 creatStore 函数来生成 Store&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入redux&lt;/span&gt;
import { createStore } from 'redux'&lt;span&gt;;  

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Store 需要传递一个函数fn 这里的fn是之后会提及的reducers&lt;/span&gt;
const store = createStore(fn);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;State：状态，某时刻的数据即是Store的状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　获取状态的方法是store.getState()&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;Action：行为，它有一个不可或缺的type属性&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　&lt;/strong&gt;action还可以携带其他内容&lt;/p&gt;
&lt;p&gt;　　　　　　我们可以使用action来改变State的值，&lt;/p&gt;
&lt;p&gt;　　　　　　从而将我们需要的数据通过Action“运输”到 Store；&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;dispatch：发送action&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　&lt;/strong&gt;dispatch(action)接受一个action对象为参数，并将它发送出去，&lt;/p&gt;
&lt;p&gt;　　　　　　Store接受Action，接受之后需要返回一个新的State（状态）&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;Reducer：处理器&lt;/strong&gt;&lt;strong&gt;　　　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　dispatch(action)接受一个action对象为参数，并将它发送出去，&lt;/p&gt;
&lt;p&gt;　　　　　　Store接受Action，接受之后需要返回一个新的State（状态）&lt;/p&gt;
&lt;p&gt;　　　　　　而创建这个新的状态的过程就是reducer&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;3、从isPlainObject.js开始&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; isPlainObject(obj) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; obj !== 'object' || obj === &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;

  let proto &lt;/span&gt;=&lt;span&gt; obj
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (Object.getPrototypeOf(proto) !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    proto &lt;/span&gt;=&lt;span&gt; Object.getPrototypeOf(proto)
  }

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Object.getPrototypeOf(obj) ===&lt;span&gt; proto
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　· 这个函数的核心思想在于什么呢？&lt;/p&gt;
&lt;p&gt;　　在于判断一个值是否为一个普通的对象&lt;/p&gt;
&lt;p&gt;　　此处的普通对象指的是直接通过字面量(let obj={})或者new Object()创建出来的对象&lt;/p&gt;

&lt;p&gt;　　· 那么他是怎么做判断的呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; obj !== 'object' || obj === &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这行代码排除掉肯定不是对象的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/span&gt;：&lt;span&gt;typeof&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; 的返回值为 &quot;object&quot;. 所以只使用 &lt;span&gt;typeof&lt;/span&gt; obj !== 'object' 不能将 &lt;span&gt;null&lt;/span&gt; 值排除掉. &lt;br/&gt;因此应使用 &lt;span&gt;typeof&lt;/span&gt; obj !== 'object' || obj === &lt;span&gt;null&lt;/span&gt; 进行判断.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再往下就是通过原型链判断了.&lt;/p&gt;
&lt;p&gt;　　通过 while 不断地判断 Object.getPrototypeOf(proto) !== null 并执行,&lt;/p&gt;
&lt;p&gt;　　最终 proto 会指向 Object.prototype. 这时再判断 Object.getPrototypeOf(obj) === proto,&lt;/p&gt;
&lt;p&gt;　　如果为 true 的话就代表 obj 是通过字面量或调用 new Object() 所创建的对象了.&lt;/p&gt;
&lt;p&gt;　　&lt;code&gt;Object.getPrototypeOf()&lt;/code&gt; 方法用于获取一个对象的原型属性指向的是哪个对象. &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;举个🌰：
假设有一个构造器：&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Fun(){}
创建一个对象：&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; f = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Fun()

Object.getPrototypeOf(f) 得到的返回值
和访问 f.__proto__ 是一样的
这个值指向 Fun.prototype.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　假如一个对象是普通对象&lt;/p&gt;
&lt;p&gt;　　那么这个对象的 __proto__ 一定是指向 Object.prototype 的,&lt;/p&gt;
&lt;p&gt;　　而非普通对象, 例如 f, 其 __proto__ 是指向其构造函数的 prototype 属性.&lt;/p&gt;
&lt;p&gt;　　因此比较 Object.getPrototypeOf(obj) 与 proto 相等, 则判定 obj 是普通对象.&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;4、接下来是createStore.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48.5&quot;&gt;
&lt;pre class=&quot;hljs javascript&quot;&gt;
&lt;code class=&quot;javascript&quot;&gt;//如果第二个参数为方法且第三个参数为空，则将两个参数交换&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; preloadedState === 'function' &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; enhancer === 'undefined'&lt;span&gt;) {
    enhancer &lt;/span&gt;=&lt;span&gt; preloadedState
    preloadedState &lt;/span&gt;=&lt;span&gt; undefined
  }&lt;/span&gt;
&lt;/pre&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;　//reducer需要是个方法&lt;/p&gt;

&lt;p&gt;　if (typeof reducer !== 'function') {&lt;/p&gt;
&lt;p&gt;　　　　throw new Error('Expected the reducer to be a function.')&lt;/p&gt;
&lt;p&gt;　}&lt;/p&gt;
&lt;/div&gt;
&lt;pre&gt;
//不支持这样写
&lt;/pre&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;p&gt;if (&lt;/p&gt;
&lt;p&gt;　　(typeof preloadedState === 'function' &amp;amp;&amp;amp; typeof enhancer === 'function') ||&lt;/p&gt;
&lt;p&gt;　　(typeof enhancer === 'function' &amp;amp;&amp;amp; typeof arguments[3] === 'function')&lt;/p&gt;
&lt;p&gt;　　) {&lt;/p&gt;
&lt;p&gt;throw new Error(&lt;/p&gt;
&lt;p&gt;　　'It looks like you are passing several store enhancers to ' +&lt;/p&gt;
&lt;p&gt;　　'createStore(). This is not supported. Instead, compose them ' +&lt;/p&gt;
&lt;p&gt;　　'together to a single function'&lt;/p&gt;
&lt;p&gt;　　)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;let currentReducer = reducer　　当前的reducer函数&lt;/p&gt;
&lt;p&gt;let currentState = preloadedState　　　当前的state树&lt;/p&gt;
&lt;p&gt;let currentListeners = []　　监听函数列表&lt;/p&gt;
&lt;p&gt;let nextListeners = currentListeners　　监听列表的一个引用&lt;/p&gt;
&lt;p&gt;let isDispatching = false　　是否正在dispatch&lt;/p&gt;
&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　里面的几个函数　&lt;/p&gt;
&lt;p&gt;　　getState()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//返回当前state树&lt;br/&gt;function&lt;/span&gt;&lt;span&gt; getState() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDispatching) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(
        &lt;/span&gt;'You may not call store.getState() while the reducer is executing. ' +
          'The reducer has already received the state as an argument. ' +
          'Pass it down from the top reducer instead of reading it from the store.'&lt;span&gt;
      )
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; currentState
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　subscribe()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;br/&gt;//这个函数用于给store添加监听函数，把需要添加的监听函数作为参数传入即可&lt;br/&gt;//nextListeners 即为目前的监听函数列表，添加了之后，subscribe方法会返回一个unsubscribe()方法&lt;br/&gt;//此方法用于注销刚才添加的监听函数。&lt;br/&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; subscribe(listener) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; listener !== 'function'&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error('Expected the listener to be a function.'&lt;span&gt;)
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDispatching) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(
        &lt;/span&gt;'You may not call store.subscribe() while the reducer is executing. ' +
          'If you would like to be notified after the store has been updated, subscribe from a ' +
          'component and invoke store.getState() in the callback to access the latest state. ' +
          'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.'&lt;span&gt;
      )
    }

    let isSubscribed &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;

    ensureCanMutateNextListeners()
    nextListeners.push(listener)

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; unsubscribe() {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isSubscribed) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
      }

      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDispatching) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(
          &lt;/span&gt;'You may not unsubscribe from a store listener while the reducer is executing. ' +
            'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.'&lt;span&gt;
        )
      }

      isSubscribed &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;

      ensureCanMutateNextListeners()
      const index &lt;/span&gt;=&lt;span&gt; nextListeners.indexOf(listener)
      nextListeners.splice(index, &lt;/span&gt;1&lt;span&gt;)
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　dispatch()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40.5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; dispatch(action) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;action必须是一个包含type的对象&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isPlainObject(action)) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(
        &lt;/span&gt;'Actions must be plain objects. ' +
        'Use custom middleware for async actions.'&lt;span&gt;
      )
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; action.type === 'undefined'&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(
        &lt;/span&gt;'Actions may not have an undefined &quot;type&quot; property. ' +
        'Have you misspelled a constant?'&lt;span&gt;
      )
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果正处于isDispatching状态，报错&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDispatching) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error('Reducers may not dispatch actions.'&lt;span&gt;)
    }

    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      isDispatching &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里就是调用我们reducer方法的地方，返回一个新的state作为currentState&lt;/span&gt;
      currentState =&lt;span&gt; currentReducer(currentState, action)
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
      isDispatching &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用所有的监听函数&lt;/span&gt;
    const listeners = currentListeners =&lt;span&gt; nextListeners
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; listeners.length; i++&lt;span&gt;) {
      const listener &lt;/span&gt;=&lt;span&gt; listeners[i]
      listener()
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; action
  }&lt;/span&gt;
&lt;/pre&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;p&gt;它只是执行了当前的reducer方法，&lt;/p&gt;
&lt;p&gt;然后把当前的state和你在调用dispatch时传入的action作为参数，&lt;/p&gt;
&lt;p&gt;返回的值就是新的currentState。&lt;/p&gt;
&lt;p&gt;从这里我们也可以看出，改变state的代码逻辑就在reducer方法中，&lt;br/&gt;在这些执行完之后，dispatch方法会遍历当前的监听列表，并执行所有的监听函数。&lt;/p&gt;
&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　replaceReducer()&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; replaceReducer(nextReducer) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; nextReducer !== 'function'&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error('Expected the nextReducer to be a function.'&lt;span&gt;)
    }

    currentReducer &lt;/span&gt;=&lt;span&gt; nextReducer
    dispatch({ type: ActionTypes.REPLACE })
  }&lt;br/&gt;替换reducer之后重新初始化状态树&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;　　observable()&lt;/p&gt;
&lt;div readability=&quot;32&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//是一种观察者模式的思想&lt;br/&gt;function&lt;/span&gt;&lt;span&gt; observable() {
    const outerSubscribe &lt;/span&gt;=&lt;span&gt; subscribe
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      subscribe(observer) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; observer !== 'object' || observer === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
          &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TypeError('Expected the observer to be an object.'&lt;span&gt;)
        }
　　　　　　&lt;br/&gt;　　　　　　&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;hljs javascript&quot;&gt;
&lt;code class=&quot;javascript&quot;/&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; observeState() {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (observer.next) {
            observer.next(getState())
          }
        }

        observeState()
        const unsubscribe &lt;/span&gt;=&lt;span&gt; outerSubscribe(observeState)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; { unsubscribe }
      },

      [$$observable]() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;
      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;

&lt;p&gt;5、接下来就是compose.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; compose(...funcs) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (funcs.length === 0&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; arg =&amp;gt;&lt;span&gt; arg
  }

  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (funcs.length === 1&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; funcs[0&lt;span&gt;]
  }

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; funcs.reduce((a, b) =&amp;gt; (...args) =&amp;gt;&lt;span&gt; a(b(...args)))
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;49&quot;&gt;
&lt;p&gt;reduce方法接受2个参数，第一个参数是一个callback函数，第二个是一个初始值initValue&lt;br/&gt;第一个函数有四个参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;previousValue: 上一次调用callback时返回的值&lt;/li&gt;
&lt;li&gt;currentValue: 正在处理的数组元素&lt;/li&gt;
&lt;li&gt;index: 正在处理的数组元素下标&lt;/li&gt;
&lt;li&gt;array: 被处理的数组&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果有initValue，initValue将作为第一次的previousValue，若没有，则数组第一个元素将作为previousValue，&lt;/p&gt;
&lt;p&gt;后面一个元素将作为currentValue，然后执行callback的函数体，将返回的值作为previousValue，&lt;/p&gt;
&lt;p&gt;将下一个元素作为currentValue,一直到最后一个数组最后一个元素执行完位置，再返回最终的结果。&lt;/p&gt;
&lt;p&gt;比如有一个数组arr=[1,2,3,4,5]，我们使用reduce来求和：&lt;/p&gt;
&lt;p&gt;let sum = [1,2,3,4,5].reduce((a,b)=&amp;gt;a+b);&lt;/p&gt;
&lt;p&gt;它巧妙的地方在于数组的每个元素都是函数，&lt;/p&gt;
&lt;p&gt;callback返回一个复合函数作为previousValue,在reduce方法执行完之后，&lt;/p&gt;
&lt;p&gt;也就返回了一个将整个数组中所有函数串式调用的一个函数。&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;6、然后是applyMiddleware.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre readability=&quot;6&quot;&gt;
export &lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span readability=&quot;3&quot;&gt; applyMiddleware(...middlewares) {&lt;p&gt;//return一个函数，可以接收createStore方法作为参数&lt;br/&gt;//给返回的store的dispatch方法再进行一次包装&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; createStore =&amp;gt; (...args) =&amp;gt;&lt;span&gt; {
    const store &lt;/span&gt;=&lt;span&gt; createStore(...args)
    let dispatch &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(
        `Dispatching &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; constructing your middleware is not allowed. ` +&lt;span&gt;
          `Other middleware would not be applied to &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt; dispatch.`
      )
    }
&lt;br/&gt;　　&lt;br/&gt;　　//暴露两个方法给外部&lt;br/&gt;const middlewareAPI &lt;/span&gt;=&lt;span&gt; {
      getState: store.getState,
      dispatch: (...args) &lt;/span&gt;=&amp;gt;&lt;span readability=&quot;3&quot;&gt; dispatch(...args)
    }&lt;p&gt;　　&lt;br/&gt;　　//传入middlewareAPI参数并执行每一个外部函数，返回结果汇聚成数组&lt;br/&gt;const chain &lt;/p&gt;&lt;/span&gt;= middlewares.map(middleware =&amp;gt;&lt;span&gt; middleware(middlewareAPI))
   &lt;br/&gt;　　//用到了上面的compose方法&lt;p&gt;　　dispatch &lt;/p&gt;&lt;/span&gt;=&lt;span&gt; compose(...chain)(store.dispatch)

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      ...store,
      dispatch
    }
  }
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div readability=&quot;14&quot;&gt;
&lt;p&gt;　　还记得刚才createStore方法中的enhancer参数吗？&lt;/p&gt;
&lt;p&gt;　　applyMiddleware就是用来创建enhancer函数的。&lt;br/&gt;　　官方的注释中提到了redux-thunk，&lt;/p&gt;
&lt;p&gt;　　就是使用applyMiddleware的一个很好的例子，&lt;/p&gt;
&lt;p&gt;　　我们结合它的代码来看可以更好的理解，下面是它的代码：&lt;/p&gt;

&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createThunkMiddleware(extraArgument) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ({ dispatch, getState }) =&amp;gt; next =&amp;gt; action =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; action === 'function'&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; action(dispatch, getState, extraArgument);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next(action);
  };
}

const thunk &lt;/span&gt;=&lt;span&gt; createThunkMiddleware();
thunk.withExtraArgument &lt;/span&gt;=&lt;span&gt; createThunkMiddleware;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; thunk;
&lt;/pre&gt;&lt;/div&gt;


&lt;div readability=&quot;29&quot;&gt;
&lt;div readability=&quot;53&quot;&gt;
&lt;p&gt;　　最终export了一个接受{ dispatch, getState }作为参数的function thunk，&lt;/p&gt;
&lt;p&gt;　　这个thunk方法也就是传给applyMiddleware方法的参数，&lt;/p&gt;
&lt;p&gt;　　此时的middlewares只有thunk一个方法，&lt;/p&gt;
&lt;p&gt;　　那么applyMiddleware中的chain也就很显然的是执行了thunk方法后返回的结果，&lt;/p&gt;
&lt;p&gt;　　我们再看redux-thunk的代码，返回了一个接受next作为参数的方法A!&lt;/p&gt;
&lt;p&gt;　　applyMiddleware的下一行，&lt;/p&gt;
&lt;p&gt;　　dispatch = compose(...chain)(store.dispatch)，&lt;/p&gt;
&lt;p&gt;　　chain只有一个function，所以这里可以忽略compose，&lt;/p&gt;
&lt;p&gt;　　那么这一句就是将store.dispatch 作为next参数传给了刚才的方法A，&lt;/p&gt;
&lt;p&gt;　　终于，方法A返回了我们熟悉的dispatch方法。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　但是注意，此时的dispatch方法还是原来的dispatch方法吗？&lt;/p&gt;
&lt;p&gt;　　它已经不是原来的它了。经过thunk方法的包装，早已物是人非。&lt;/p&gt;
&lt;p&gt;　　我们来看一下redux-thunk的代码，第三行之后的4行，&lt;/p&gt;
&lt;p&gt;　　如果dispatch方法接受的参数不是一个function，&lt;/p&gt;
&lt;p&gt;　　那么这个dispatch就和普通的dispatch没什么不同，&lt;/p&gt;
&lt;p&gt;　　但如果此时的action是一个方法，那么就会执行此方法，且第一个参数是store.dispatch。&lt;/p&gt;
&lt;p&gt;　　这意味着我们的action创建函数不再只能创建一个包含type的Object，而可以是一个方法。&lt;/p&gt;
&lt;p&gt;　　你可能会问有什么用呢？当你在action中需要一个异步操作，并需要在回调中改变state的状态的时候，这就是一个绝佳的解决方案。&lt;/p&gt;
&lt;p&gt;　　所以说，applyMiddleware实际上做了一件事，就是根据外部函数(中间件函数)包装原来的dispatch函数，然后将新的dispatch函数暴露出去。&lt;/p&gt;
&lt;p&gt;　　再回头去看createStore.jsx中的 return enhancer(createStore)(reducer, preloadedState)这句代码，是不是明白了很多事情？&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;7、combineReducers.js&lt;/p&gt;
&lt;div readability=&quot;20&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;很简单却很关键，我就不解释了~&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bindActionCreator(actionCreator, dispatch) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (...args) =&amp;gt;&lt;span&gt; dispatch(actionCreator(...args))
}

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 将action与dispatch函数绑定，生成直接可以触发action的函数，
   * 可以将第一个参数对象中所有的action都直接生成可以直接触发dispatch的函数
   * 而不需要一个一个的dispatch，生成后的方法对应原来action生成器的函数名
   * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; bindActionCreators(actionCreators, dispatch) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; actionCreators === 'function'&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bindActionCreator(actionCreators, dispatch)
  }
    
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;actionCreators必须为object类型&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; actionCreators !== 'object' || actionCreators === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(
      `bindActionCreators expected an object or a &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;, instead received ${actionCreators === &lt;span&gt;null&lt;/span&gt; ? 'null' : &lt;span&gt;typeof&lt;/span&gt; actionCreators}. ` +&lt;span&gt;
      `Did you write &lt;/span&gt;&quot;import ActionCreators from&quot; instead of &quot;import * as ActionCreators from&quot;?&lt;span&gt;`
    )
  }

  const keys &lt;/span&gt;=&lt;span&gt; Object.keys(actionCreators)
  const boundActionCreators &lt;/span&gt;=&lt;span&gt; {}
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; keys.length; i++&lt;span&gt;) {
    const key &lt;/span&gt;=&lt;span&gt; keys[i]
    const actionCreator &lt;/span&gt;=&lt;span&gt; actionCreators[key]
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给actionCreators的每一个成员都绑定dispatch方法生成新的方法，&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后注入新的对象中，新方法对应的key即为原来在actionCreators的名字&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; actionCreator === 'function'&lt;span&gt;) {
      boundActionCreators[key] &lt;/span&gt;=&lt;span&gt; bindActionCreator(actionCreator, dispatch)
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      warning(`bindActionCreators expected a &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; actionCreator &lt;span&gt;for&lt;/span&gt; key '${key}', instead received type '${typeof actionCreator}'&lt;span&gt;.`)
    }
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; boundActionCreators

这个方法主要的作用就是将action与dispatch函数绑定，生成直接可以触发action的函数。代码比较简单注释也比较明白，就过去了&lt;/span&gt;~
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;

&lt;p&gt;8、bindActionCreators.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据key和action生成错误信息&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getUndefinedStateErrorMessage(key, action) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一些警告级别的错误&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  const reducerKeys &lt;/span&gt;=&lt;span&gt; Object.keys(reducers)
  const argumentName &lt;/span&gt;= action &amp;amp;&amp;amp; action.type === ActionTypes.INIT ?
    'preloadedState argument passed to createStore'&lt;span&gt; :
    &lt;/span&gt;'previous state received by the reducer'

  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断reducers是否为空数组&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断state是否是对象&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;给state中存在而reducer中不存在的属性添加缓存标识并警告&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个方法用于检测用于组合的reducer是否是符合redux规定的reducer&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; assertReducerSanity(reducers) {
  Object.keys(reducers).forEach(key &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    const reducer &lt;/span&gt;=&lt;span&gt; reducers[key]
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用reducer方法，undefined为第一个参数&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用前面说到过的ActionTypes.INIT和一个随机type生成action作为第二个参数&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若返回的初始state为undefined，则这是一个不符合规定的reducer方法，抛出异常&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;  })
}

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; combineReducers(reducers) {
  const reducerKeys &lt;/span&gt;= Object.keys(reducers) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;所有的键名&lt;/span&gt;
  const finalReducers =&lt;span&gt; {}
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; reducerKeys.length; i++&lt;span&gt;) {
    const key &lt;/span&gt;=&lt;span&gt; reducerKeys[i]

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== 'production'&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; reducers[key] === 'undefined'&lt;span&gt;) {
        warning(`No reducer provided &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; key &quot;${key}&quot;&lt;span&gt;`)
      }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;finalReducers是过滤后的reducers，它的每一个属性都是一个function&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; reducers[key] === 'function'&lt;span&gt;) {
      finalReducers[key] &lt;/span&gt;=&lt;span&gt; reducers[key]
    }
  }

  const finalReducerKeys &lt;/span&gt;=&lt;span&gt; Object.keys(finalReducers)

  let unexpectedKeyCache
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== 'production'&lt;span&gt;) {
    unexpectedKeyCache &lt;/span&gt;=&lt;span&gt; {}
  }

  let sanityError

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测每个reducer是否是符合标准的reducer&lt;/span&gt;
  &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    assertReducerSanity(finalReducers)
  } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
    sanityError &lt;/span&gt;=&lt;span&gt; e
  }

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; combination(state =&lt;span&gt; {}, action) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sanityError) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; sanityError
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是成产环境，做一些警告判断&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== 'production'&lt;span&gt;) {
      const warningMessage &lt;/span&gt;=&lt;span&gt; getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache)
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (warningMessage) {
        warning(warningMessage)
      }
    }

    let hasChanged &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    const nextState &lt;/span&gt;= {} &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下一个state树&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历所有reducers，然后将每个reducer返回的state组合起来生成一个大的状态树，所以任何action，redux都会遍历所有的reducer&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; finalReducerKeys.length; i++&lt;span&gt;) {
      const key &lt;/span&gt;=&lt;span&gt; finalReducerKeys[i]
      const reducer &lt;/span&gt;=&lt;span&gt; finalReducers[key]
      const previousStateForKey &lt;/span&gt;=&lt;span&gt; state[key]
      const nextStateForKey &lt;/span&gt;=&lt;span&gt; reducer(previousStateForKey, action)

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果此reducer返回的新的state是undefined，抛出异常&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; nextStateForKey === 'undefined'&lt;span&gt;) {
        const errorMessage &lt;/span&gt;=&lt;span&gt; getUndefinedStateErrorMessage(key, action)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(errorMessage)
      }
      nextState[key] &lt;/span&gt;=&lt;span&gt; nextStateForKey
      hasChanged &lt;/span&gt;= hasChanged || nextStateForKey !==&lt;span&gt; previousStateForKey
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前action对应的reducer方法执行完后，该处数据没有变化，则返回原来的流程树&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; hasChanged ?&lt;span&gt; nextState : state
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;未完待续。&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 30 Nov 2018 16:02:00 +0000</pubDate>
<dc:creator>薛小白</dc:creator>
<og:description>redux源码解析 1、首先让我们看看都有哪些内容 2、让我们看看redux的流程图 Store：一个库，保存数据的地方，整个项目只有一个 创建store Redux提供 creatStore 函数来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangyangxxb/p/10047648.html</dc:identifier>
</item>
<item>
<title>Java快速IO(ACM)必备 - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/10047565.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/10047565.html</guid>
<description>&lt;p&gt; en....&lt;/p&gt;
&lt;p&gt;无非用到的是&lt;/p&gt;
&lt;p&gt;1. new Scanner(System.in);&lt;/p&gt;
&lt;p&gt;2.new BUfferReader(new InputStreamReader(System.in);&lt;/p&gt;
&lt;p&gt;3.System.in.read() //需要转换&lt;/p&gt;
&lt;p&gt;当然1，2这两个还有许多坑要注意，比如说 next() 不会读入null字符，就一直等待，nextline() 吸收\n到缓冲区 但是不会读入，readLine 与read（）也是一样&lt;/p&gt;
&lt;p&gt;这里需要注意：in.nextInt() 接着 in.nextLine（）会出现读入空缺现象，很明显，我前面说过，nextLine会吸收\n到缓冲区&lt;/p&gt;
&lt;p&gt;贴代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package IO;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStreamReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.StringTokenizer;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Class for buffered reading int and double values
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Reader解决超时 {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; BufferedReader reader;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; StringTokenizer tokenizer;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * call this method to initialize reader for InputStream
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(InputStream input) {
        reader &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedReader(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(input));
        tokenizer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringTokenizer(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * get next word
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String next() throws IOException {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;tokenizer.hasMoreTokens()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO add check for eof if necessary&lt;/span&gt;
            tokenizer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringTokenizer(
                    reader.readLine());
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tokenizer.nextToken();
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; String nextLine()throws IOException{
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;tokenizer.hasMoreElements()){
            tokenizer&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringTokenizer(
                    reader.readLine()
            );
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; tokenizer.nextToken(&lt;span&gt;&quot;\n&quot;&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; int nextInt() throws IOException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Integer.parseInt(next());
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; double nextDouble() throws IOException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Double.parseDouble(next());
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) throws IOException{
        init(System.&lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt;);
        StringTokenizer st &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringTokenizer(&lt;span&gt;&quot;this is a test&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (st.hasMoreTokens())

        {

            System.out.println(st.nextToken());

        }
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; System.out.println(next());&lt;/span&gt;
&lt;span&gt;        System.out.println(nextLine());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 30 Nov 2018 15:52:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<og:description>en.... 无非用到的是 1. new Scanner(System.in); 2.new BUfferReader(new InputStreamReader(System.in); 3.Syst</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgwblog/p/10047565.html</dc:identifier>
</item>
<item>
<title>JS之setTimeOut与clearTimeOut - JoeJoan</title>
<link>http://www.cnblogs.com/Joe-and-Joan/p/10047384.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Joe-and-Joan/p/10047384.html</guid>
<description>&lt;p&gt;&lt;strong&gt;小练习1：针对HTML，分别使用 setTimeout 和 setInterval 实现以下功能：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;点击按钮时，开始改变 fade-obj 的透明度，开始一个淡出（逐渐消失）动画，直到透明度为0&lt;/li&gt;
&lt;li&gt;在动画过程中，按钮的状态变为不可点击&lt;/li&gt;
&lt;li&gt;在动画结束后，按钮状态恢复，且文字变成“淡入”&lt;/li&gt;
&lt;li&gt;在 按钮显示 淡入 的状态时，点击按钮，开始一个“淡入”（逐渐出现）的动画，和上面类似按钮不可点，直到透明度完全不透明&lt;/li&gt;
&lt;li&gt;淡入动画结束后，按钮文字变为“淡出”&lt;/li&gt;
&lt;li&gt;暂时不要使用 CSS animation （以后我们再学习）&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;与页面对话4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;fade-obj&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;width:300px;height:300px;background:#000;opacity: 1;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;fade-btn&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;beLowOpa()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;淡出&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt;&lt;span&gt; opaCount &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; btn&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fade-btn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; beLowOpa() {
            btn.disabled &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            opaCount &lt;/span&gt;&lt;span&gt;-=&lt;/span&gt; &lt;span&gt;0.05&lt;/span&gt;&lt;span&gt;;
            document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fade-obj&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).style.opacity &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; opaCount;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; t &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; setTimeout(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;beLowOpa()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (opaCount &lt;/span&gt;&lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                clearTimeout(t);
                btn.disabled &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                btn.innerHTML &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;淡入&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                btn.addEventListener(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, beHighOpa);
            }
        }
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; beHighOpa() {
            btn.disabled &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            opaCount &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt; &lt;span&gt;0.05&lt;/span&gt;&lt;span&gt;;
            document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fade-obj&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).style.opacity &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; opaCount;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; t &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; setTimeout(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;beHighOpa()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (opaCount &lt;/span&gt;&lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
                clearTimeout(t);
                btn.disabled &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                btn.innerHTML &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;淡出&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                btn.addEventListener(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, beLowOpa);
            }
        }
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 30 Nov 2018 15:35:00 +0000</pubDate>
<dc:creator>JoeJoan</dc:creator>
<og:description>小练习1：针对HTML，分别使用 setTimeout 和 setInterval 实现以下功能： 点击按钮时，开始改变 fade-obj 的透明度，开始一个淡出（逐渐消失）动画，直到透明度为0 在动</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Joe-and-Joan/p/10047384.html</dc:identifier>
</item>
<item>
<title>C#编写扫雷游戏 - firefox逍遥一下</title>
<link>http://www.cnblogs.com/xu-yi/p/10047375.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xu-yi/p/10047375.html</guid>
<description>&lt;p&gt;翻看了下以前大学学习的一些小项目，突然发现有个项目比较有意思，觉得有必要把它分享出来。当然现在看来，里面有很多的不足之处，但因博主现在已经工作，没有时间再去优化。这个项目就是利用C#编写一个Windows系统下的扫雷小游戏。&lt;/p&gt;
&lt;p&gt;首先讲下扫雷小游戏的玩法：&lt;/p&gt;
&lt;p&gt;(1)扫雷就是要把所有非地雷的格子揭开即胜利；踩到地雷格子就算失败。&lt;/p&gt;
&lt;p&gt;(2)当点开的格子不是地雷区域的时候，该格子会显示一个数字，该数字表示的含义就是该格子周边有多少个地雷。&lt;/p&gt;
&lt;p&gt;(3)同时点开的如果非地雷的格子，周边连贯的非地雷区域都会自动被扫描打开，直到遇到旁边有雷区的时候停止。&lt;/p&gt;
&lt;p&gt;(4)当你判断出格子是地雷的时候，你可以使用鼠标右键将该块方格标记为雷区。当不确定的时候，你可标记个问号以待确定。&lt;/p&gt;

&lt;p&gt;下面来说下我大学时候实现这个扫雷小游戏的思路：&lt;/p&gt;
&lt;p&gt;（1）因为雷区是一个个格子联合组成的，那我们可以使用winform程序自带的系统按钮控件Button来实现雷区方格。&lt;/p&gt;
&lt;p&gt;（2）代表雷区方格的Button按钮需要实现下面几个事件：鼠标左键点击扫雷事件，鼠标右键点击标记雷区事件，鼠标右键点击标记问号区域事件。&lt;/p&gt;
&lt;p&gt;（3）为了更好的实现游戏的可玩性，增加一个自由设置地雷数量的小功能，可自行设置雷区包含的地雷数量，设置完成后，自动刷新界面，重新部署地雷。&lt;/p&gt;
&lt;p&gt;（4）我们将雷区的方格存储在一个全局的二维数组中，Form窗体在初始化的时候，自动生成面板区域的Button按钮列表。&lt;/p&gt;
&lt;p&gt;（5）为了实现每次玩游戏的时候，地雷分布不一致，我们在Button列表生成后。随机抽取出某些Button按钮作为地雷分布点，并记录该Button的雷区属性为含有地雷。&lt;/p&gt;
&lt;p&gt;（6）算法中的关键：递归算法计算雷区。当点击某个方格的时候，如果该方格是雷区，则直接Game Over,如果不是的话，则我们需要一个算法去计算旁边区域的地雷数量，以及旁边区域没有地雷的区域，当没有地雷的区域连成一片的时候，我们需要使用递归算法，去查找二维数组，找到对应的连片非雷区，将之打开。&lt;/p&gt;
&lt;p&gt; （7）如何设置方格的状态：当鼠标左键点击的方块区域非雷区的时候，我们将Button按钮的属性设置为Disabled即可呈现打开的状态。当鼠标左键打开的方格是雷区时候，此时我们可以将所有地雷区域块的Button的背景图设置为地雷图片，并播放相应的爆炸音效，弹出游戏终止界面即可。当鼠标右键标记雷区或者待确定区域的时候，只需要更改Button的背景图即可。当然上述所有点击操作，都得判断Button方格区域当前的状态值：初始化状态、已标记为待确定状态、已标记为雷区。&lt;/p&gt;
&lt;p&gt;游戏的最终效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466191/201811/466191-20181130231055646-524200938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们下面来剖析下几个关键点，因为代码量比较多，我就不全部详细剖析了。&lt;/p&gt;
&lt;p&gt;首先我们定义一个LeiButton类，这个类继承于系统控件Button，增加x,y,youlei三个字段，x表示二维数组的第一个索引，y表示二维数组的第二个索引值，youlei用于标记Button方块区域按钮的状态(0表示无雷，1表示有雷）。同时我们使用Button按钮类自带的一个Tag属性标记该方块区域是否被翻开。具体定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466191/201811/466191-20181130230559678-1686696081.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们在窗体对象Form类中定义一些常用的变量之类，如下图，都有相应注释&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466191/201811/466191-20181130230759874-1438653000.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们来看下生成Button的二维数组，即生成雷区的Button列表。我们需要在Form中添加GroupBox组件，然后将动态生成的Button列表添加到这个groupbox组件中。生成Button的二维数组方法体如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466191/201811/466191-20181130231234873-110018145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成完Button列表后，我们就开始部署地雷了，地雷随机部署到Button列表中，部署地雷的方法如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/466191/201811/466191-20181130231406090-24416089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到了这一步，我们就应该将雷区的界面渲染出来了，这时候我们可以将上面两个方法放入窗体的Form_Load事件中即可渲染出游戏界面。如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466191/201811/466191-20181130231545270-1634978522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们继续，下面写扫雷的算法，当鼠标左键点开某个方格的时候，如果该方格不是雷区，那我们需要计算该方格周边的地雷数量，计算方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466191/201811/466191-20181130231730543-696878856.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面是个递归计算的核心算法，非常关键&lt;/strong&gt;。当我们点开的方格非雷区的时候，周边连片的非雷区的方格块会被打开。这一块的核心算法参考下列代码，row表示行，col表示列&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466191/201811/466191-20181130232117190-711022334.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们来添加鼠标的点击事件，我这边采用的是bt_MouseUp事件来处理。点击后，我们首先判断游戏是否结束，如果没结束，则进行下列操作，获取到被点击的按钮的x,y值以及点击事件按下的键值(判断按下的是鼠标左键还是右键)。x,y值获取到了，我们就可以到Button二维数组中找到对应元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466191/201811/466191-20181130232648709-889547757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假如点击的是鼠标左键，则我们进行扫雷操作，具体的代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466191/201811/466191-20181130232901295-793206963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果按下的是鼠标右键，则是标记方块是雷区或者待确定区域，具体代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466191/201811/466191-20181130232946004-565214535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后再给出一个判断是否扫雷完毕的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466191/201811/466191-20181130233046073-140086497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 扫雷游戏的设计大概到此结束，中间还有很多可以优化的地方，比如将扫雷的逻辑代码抽离Form类独立出来等，这些都靠读者自行去优化了。如果有需要源码的初学者，可联系博主，博主免费赠与学习。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;最后，附上博主的IT技术学习群，欢迎各位同行入群指导交流。技术群：872894940&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 30 Nov 2018 15:34:00 +0000</pubDate>
<dc:creator>firefox逍遥一下</dc:creator>
<og:description>翻看了下以前大学学习的一些小项目，突然发现有个项目比较有意思，觉得有必要把它分享出来。当然现在看来，里面有很多的不足之处，但因博主现在已经工作，没有时间再去优化。这个项目就是利用C#编写一个Windo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xu-yi/p/10047375.html</dc:identifier>
</item>
<item>
<title>sau交流学习社区--在element-ui中新建FormData对象组合上传图片和文件的文件对象，同时需要携带其他参数 - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/10047376.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/10047376.html</guid>
<description>&lt;p&gt;今天有一个坑，同时要上传图片和文件，而且图片要展示缩略图，文件要展示列表。&lt;/p&gt;
&lt;p&gt;我的思路是：&lt;/p&gt;
&lt;p&gt;首先，只上传附件照片，这个直接看ele的官方例子就行，不仅仅上传附件照片，还同时上传其他参数。&lt;/p&gt;
&lt;p&gt;然后，再做上传照片和文件，上传其他参数，其实也就是文件合并。&lt;/p&gt;
&lt;p&gt; 同步到sau交流学习社区：&lt;a href=&quot;https://www.mwcxs.top/page/465.html&quot; target=&quot;_blank&quot;&gt;https://www.mwcxs.top/page/465.html&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;一、上传照片和其他参数&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;页面样式大约就是这样的，参数有优先级，发生时间，服务单名称，服务单描述，图片附件上传。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2018/11/30-LFQKcZSYd6u4vxrqjcVJDXU.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（一）视图部分代码&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &amp;lt;el-form-item prop=&quot;image&quot; label=&quot;图片附件上传&quot;&amp;gt;
          &amp;lt;el-&lt;span&gt;upload
            ref&lt;/span&gt;=&quot;upload&quot;&lt;span&gt;
            :action&lt;/span&gt;=&quot;uploadAction&quot;&lt;span&gt;
            :beforeUpload&lt;/span&gt;=&quot;beforeUploadPicture&quot;&lt;span&gt;
            :on&lt;/span&gt;-change=&quot;imageChange&quot;&lt;span&gt;
            list&lt;/span&gt;-type=&quot;picture-card&quot;&lt;span&gt;
            name&lt;/span&gt;=&quot;files&quot;&lt;span&gt;
            :data&lt;/span&gt;=&quot;paramsData&quot;&lt;span&gt;
            :limit&lt;/span&gt;=&quot;3&quot;&lt;span&gt;
            multiple
            :auto&lt;/span&gt;-upload=&quot;false&quot;&lt;span&gt;
            :on&lt;/span&gt;-preview=&quot;handlePictureCardPreview&quot;&lt;span&gt;
            :on&lt;/span&gt;-remove=&quot;handleRemovePicture&quot;&amp;gt;
            &amp;lt;i class=&quot;el-icon-plus&quot;&amp;gt;&amp;lt;/i&amp;gt;
          &amp;lt;/el-upload&amp;gt;
          &amp;lt;el-dialog :visible.sync=&quot;dialogVisible&quot;&amp;gt;
            &amp;lt;img width=&quot;100%&quot; :src=&quot;dialogImageUrl&quot; alt=&quot;&quot;&amp;gt;
          &amp;lt;/el-dialog&amp;gt;
     &amp;lt;/el-form-item&amp;gt;

 &amp;lt;el-button size=&quot;mini&quot; type=&quot;primary&quot; @click=&quot;confirm()&quot;&amp;gt;确 定&amp;lt;/el-button&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;1、action变量为后端图片接口的地址&lt;/p&gt;
&lt;p&gt;2、beforeUpload方法是指的上传之前触发的函数，可以用来做前端文件格式判断，文件大小判断&lt;/p&gt;
&lt;p&gt;3、on-change方法是指每次选择文件都会触发函数，可以用来前端删除和添加照片&lt;/p&gt;
&lt;p&gt;4、list-type属性指的是照片picture-card展示的方式&lt;/p&gt;
&lt;p&gt;5、name指的是上传的文件字段名，这是后端确认文件流的字段名，可以随便写&lt;/p&gt;
&lt;p&gt;6、data属性指的是上传时附带的额外参数，这是指的其他参数&lt;/p&gt;
&lt;p&gt;7、limit属性指的是上传文件的个数极限。&lt;/p&gt;
&lt;p&gt;8、multiple属性指的是可以每次多选文件，true为多选，false为单选&lt;/p&gt;
&lt;p&gt;9、auto-upload属性指的是自动上传的，true为可以自动上传，false为不可以自动上传&lt;/p&gt;
&lt;p&gt;10、on-preview方法指的是查看缩略图的方法&lt;/p&gt;
&lt;p&gt;11、on-remove方法指的是删除文件的方法&lt;/p&gt;
&lt;p&gt;12、ref绑定dom元素&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（二）data部分代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; data () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      selectedCategorySpe: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.selectedCategory,
      serviceForm: {
        title: &lt;/span&gt;''&lt;span&gt;,
        desc: &lt;/span&gt;''&lt;span&gt;,
        priority: &lt;/span&gt;''&lt;span&gt;,
        occurDate: &lt;/span&gt;''&lt;span&gt;
      },
       dialogImageUrl: &lt;/span&gt;''&lt;span&gt;,
       dialogVisible: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
      uploadAction: &lt;/span&gt;&quot;/inner/event/order/submit/submit&quot; + &quot;&amp;amp;accessToken=&quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$store.getters.token
    }
  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;strong&gt;（三）computed部分代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; computed: {
    ...mapGetters([
      &lt;/span&gt;'constConfig'&lt;span&gt;
    ]),
    paramsData: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
      let params &lt;/span&gt;=&lt;span&gt; {
        eventCategory: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.selectedCategorySpe.categoryId,
          priority: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.serviceForm.priority,
          title: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.serviceForm.title,
          dsc: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.serviceForm.desc,
          occurDate: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.serviceForm.occurDate
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; params
    }
  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用computed实现实时监测paramsData的值，只要selectedCategorySpe.categoryId，serviceForm.priority，serviceForm.title&lt;/p&gt;
&lt;p&gt;，serviceForm.desc，serviceForm.occurDate中只有一个变化，都会重新计算paramsData的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（四）methods部分方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    beforeUploadPicture(file){
      const isImage &lt;/span&gt;= file.type == 'image/png' || file.type == 'image/jpg' ||  file.type == 'image/jpeg' || file.type == 'image/bmp' || file.type == 'image/gif' || file.type == 'image/webp'&lt;span&gt;;
      const isLt2M &lt;/span&gt;= file.size &amp;lt;  1024 * 1024 * 2&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isImage) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$message.error('上传只能是png,jpg,jpeg,bmp,gif,webp格式!'&lt;span&gt;);
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isLt2M) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$message.error('上传图片大小不能超过 2MB!'&lt;span&gt;);
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; isImage &amp;amp;&amp;amp;&lt;span&gt; isLt2M;
    },
    handlePictureCardPreview(file) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dialogImageUrl =&lt;span&gt; file.url;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dialogVisible = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    },
    handleRemovePicture(file, fileList) {
      console.log(file, fileList);
    },
    imageChange(file, fileList, name) {
      console.log(file, fileList);
    },

 confirm(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs.upload.submit();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明:confirm使用ref的绑定的upload，紧接着调用form的表单的submit方法。这个vue已经封装好了，这时候传的参数可以看到post传递的文件对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2018/11/30mSVdBl7-uafYFal-kJBVEsM6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h4&gt;&lt;strong&gt;二、同时上传图片和文件，并且图片可以看缩略图文件显示成列表&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;但是当你出现这样的需求的时候，一脸蒙蔽&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2018/11/30i4RSkCRS5prTOfiAAorMEzwS.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（一）视图部分代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &amp;lt;el-form-item prop=&quot;image&quot; label=&quot;图片附件上传&quot;&amp;gt;
          &amp;lt;el-&lt;span&gt;upload
            ref&lt;/span&gt;=&quot;uploadImage&quot;&lt;span&gt;
            :action&lt;/span&gt;=&quot;uploadAction&quot;&lt;span&gt;
            :beforeUpload&lt;/span&gt;=&quot;beforeUploadPicture&quot;&lt;span&gt;
            :on&lt;/span&gt;-change=&quot;imageChange&quot;&lt;span&gt;
            list&lt;/span&gt;-type=&quot;picture-card&quot;&lt;span&gt;
            name&lt;/span&gt;=&quot;files&quot;&lt;span&gt;
            :limit&lt;/span&gt;=&quot;3&quot;&lt;span&gt;
            multiple
            :auto&lt;/span&gt;-upload=&quot;false&quot;&lt;span&gt;
            :on&lt;/span&gt;-preview=&quot;handlePictureCardPreview&quot;&lt;span&gt;
            :on&lt;/span&gt;-remove=&quot;handleRemovePicture&quot;&amp;gt;
            &amp;lt;i class=&quot;el-icon-plus&quot;&amp;gt;&amp;lt;/i&amp;gt;
          &amp;lt;/el-upload&amp;gt;
          &amp;lt;el-dialog :visible.sync=&quot;dialogVisible&quot;&amp;gt;
            &amp;lt;img width=&quot;100%&quot; :src=&quot;dialogImageUrl&quot; alt=&quot;&quot;&amp;gt;
          &amp;lt;/el-dialog&amp;gt;
        &amp;lt;/el-form-item&amp;gt;
        &amp;lt;el-form-item prop=&quot;image&quot; label=&quot;文件附件上传&quot;&amp;gt;
          &amp;lt;el-&lt;span&gt;upload
            ref&lt;/span&gt;=&quot;uploadFile&quot;&lt;span&gt;
            class&lt;/span&gt;=&quot;upload-demo&quot;&lt;span&gt;
            name&lt;/span&gt;=&quot;files&quot;&lt;span&gt;
            :on&lt;/span&gt;-change=&quot;fileChange&quot;&lt;span&gt;
            :action&lt;/span&gt;=&quot;uploadAction&quot;&lt;span&gt;
            :on&lt;/span&gt;-preview=&quot;handlePreviewFile&quot;&lt;span&gt;
            :on&lt;/span&gt;-remove=&quot;handleRemoveFile&quot;&lt;span&gt;
            :before&lt;/span&gt;-remove=&quot;beforeRemoveFile&quot;&lt;span&gt;
            multiple
            :auto&lt;/span&gt;-upload=&quot;false&quot;&lt;span&gt;
            :limit&lt;/span&gt;=&quot;3&quot;&lt;span&gt;
            :on&lt;/span&gt;-exceed=&quot;handleExceedFile&quot;&lt;span&gt;
            :file&lt;/span&gt;-list=&quot;fileList&quot;&amp;gt;
            &amp;lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&amp;gt;点击上传&amp;lt;/el-button&amp;gt;
            &amp;lt;!--&amp;lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&amp;gt;只能上传文件，且不超过2M&amp;lt;/div&amp;gt;--&amp;gt;
          &amp;lt;/el-upload&amp;gt;
        &amp;lt;/el-form-item&amp;gt;

 &amp;lt;el-button size=&quot;mini&quot; type=&quot;primary&quot; @click=&quot;confirm()&quot;&amp;gt;确 定&amp;lt;/el-button&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;（2）data部分数据&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; data () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; { 
      selectedCategorySpe: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.selectedCategory,
      serviceForm: {
        title: &lt;/span&gt;''&lt;span&gt;,
        desc: &lt;/span&gt;''&lt;span&gt;,
        priority: &lt;/span&gt;''&lt;span&gt;,
        occurDate: &lt;/span&gt;''&lt;span&gt;,
      },
      images: {},
      files: {},
      dialogImageUrl: &lt;/span&gt;''&lt;span&gt;,
      dialogVisible: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    }
  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）method部分数据&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;beforeUploadPicture(file){
     const isImage &lt;/span&gt;= file.type == 'image/png' || file.type == 'image/jpg' ||  file.type == 'image/jpeg' || file.type == 'image/bmp' || file.type == 'image/gif' || file.type == 'image/webp'&lt;span&gt;;
      const isLt2M &lt;/span&gt;= file.size &amp;lt;  1024 * 1024 * 2&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isImage) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$message.error('上传只能是png,jpg,jpeg,bmp,gif,webp格式!'&lt;span&gt;);
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isLt2M) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$message.error('上传图片大小不能超过 2MB!'&lt;span&gt;);
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; isImage &amp;amp;&amp;amp;&lt;span&gt; isLt2M;
    },
    handlePictureCardPreview(file) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dialogImageUrl =&lt;span&gt; file.url;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dialogVisible = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    },
    handleRemovePicture(file, fileList) {
      console.log(file, fileList);
    },
    imageChange(file, fileList, name) {
      console.log(file, fileList);
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.imageList =&lt;span&gt; fileList;
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.images[''] =&lt;span&gt; fileList;
    },

    handleRemoveFile(file, fileList) {
      console.log(file, fileList);
    },
    handlePreviewFile(file) {
      console.log(file);
    },
    handleExceedFile(files, fileList) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$message.warning(`当前限制选择 3 个文件，本次选择了 ${files.length} 个文件，共选择了 ${files.length +&lt;span&gt; fileList.length} 个文件`);
    },
    beforeRemoveFile(file, fileList) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$confirm(`确定移除 ${ file.name }？`);
    },
    fileChange(file,fileList) {
      console.log(file, fileList);
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fileList =&lt;span&gt; fileList;

      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.files[''] =&lt;span&gt; fileList;
    },

    confirm(){
          let wfForm &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FormData();
          wfForm.append( &lt;/span&gt;'eventCategory',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.selectedCategorySpe.categoryId)
          wfForm.append( &lt;/span&gt;'priority',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.serviceForm.priority)
          wfForm.append( &lt;/span&gt;'title',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.serviceForm.title)
          wfForm.append( &lt;/span&gt;'dsc',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.serviceForm.desc)
          wfForm.append( &lt;/span&gt;'occurDate',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.serviceForm.occurDate)
          Object.entries(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.images).forEach(file =&amp;gt;&lt;span&gt; {
            file[&lt;/span&gt;1].forEach(item =&amp;gt;&lt;span&gt; {
              wfForm.append(&lt;/span&gt;'files'&lt;span&gt;, item.raw)
              wfForm.append(item.name, file[&lt;/span&gt;0&lt;span&gt;])
            })
          })
          Object.entries(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.files).forEach(file =&amp;gt;&lt;span&gt; {
            file[&lt;/span&gt;1].forEach(item =&amp;gt;&lt;span&gt; {
              wfForm.append(&lt;/span&gt;'files'&lt;span&gt;, item.raw)
              wfForm.append(item.name, file[&lt;/span&gt;0&lt;span&gt;])
            })
          })
          createEventOrder(wfForm).then( res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            console.log(res, &lt;/span&gt;'res'&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(res.retValue === 1&lt;span&gt;){
              &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$message.success( '成功创建服务单'&lt;span&gt; );
              &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.handleClose()
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{

            }
          })

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;说明一下，新建了&lt;/strong&gt;&lt;strong&gt;this.files存文件列表，this.images存图片列表。在confirm中新建一个FormData对象，使用append方法将参数变量加到数据对象中，和文件对象。最后将FormData对象传给后端。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传递的参数截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2018/11/30xkajXJVOJlsvE5ygX6AoWIbx.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 30 Nov 2018 15:34:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<og:description>今天有一个坑，同时要上传图片和文件，而且图片要展示缩略图，文件要展示列表。 我的思路是： 首先，只上传附件照片，这个直接看ele的官方例子就行，不仅仅上传附件照片，还同时上传其他参数。 然后，再做上传</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/10047376.html</dc:identifier>
</item>
<item>
<title>ASP.Net Core开发(踩坑)指南 - 7m鱼</title>
<link>http://www.cnblogs.com/selimsong/p/10047321.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/selimsong/p/10047321.html</guid>
<description>&lt;p&gt;　　ASP.NET与ASP.NET Core很类似，但它们之间存在一些细微区别以及ASP.NET Core中新增特性的使用方法，在此之前也写过一篇简单的对比文章ASP.NET MVC应用迁移到ASP.NET Core及其异同简介，但没有进行深入的分析和介绍，在真正使用ASP.NET Core进行开发时，如果忽略这些细节可能会出现奇怪的问题，特此将这些细节进行分享。&lt;br/&gt;　　本文主要内容有：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：本文基于ASP.Net Core 2.1版本，.Net Core SDK版本需要2.1.401+。长篇预警( ╯□╰ )&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;无处不在的依赖注入&lt;/h2&gt;
&lt;p&gt;　　ASP.NET与ASP.NET Core之间最大区别之一就是内置了依赖注入机制，虽然ASP.NET中也有DI机制，但没有内置容器，一般都需要使用第三方的容器来提供服务，另外依赖注入的概念也不像ASP.NET Core中这样无处不在。&lt;br/&gt;　　简单来说依赖注入的目的是为了让代码解耦以提高代码的可维护性，同时也要求代码设计符合依赖导致原则使得代码更加灵活，而其原理实际上就是在应用程序中添加一个对象容器，在应用初始化时将实际的服务“放”到容器中，然后当需要相应服务时从容器中获取，由容器来组装服务。&lt;/p&gt;
&lt;h3&gt;服务的注册&lt;/h3&gt;
&lt;p&gt;　　ASP.NET Core的Startup(注：Startup仅仅只是约定名称，实际使用是在Program类型中创建 WebHost时使用的)，该类型中包含两个方法分别是ConfigureServices和Configure，其中ConfigureServices的主要作用就是用来将服务“放”置到容器中&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130224737601-1170181466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　代码来自：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.1&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;替换默认的依赖注入容器&lt;/h3&gt;
&lt;p&gt;　　ASP.NET Core的默认容器仅提供了构造注入功能，如果需要使用属性注入等功能或者在迁移时原有应用依赖于其它容器，那么可以通过使用第三方容器实现。&lt;br/&gt;　　将默认容器替换为其它容器仅需三步：&lt;br/&gt;　　1. 将ConfigureServices方法的返回类型改为IServiceProvider。&lt;br/&gt;　　2. 将ASP.NET Core中的服务注册到第三方容器中。&lt;br/&gt;　　3. 使用第三方容器实现IServiceProvider接口并返回。&lt;/p&gt;
&lt;p&gt;　　官方文档以Autofac为例，Autofac已经实现了ASP.NET Core服务注册到Autofac容器中，以及Autofac容器的IServiceProvider接口封装，仅需安装Autofac以及Autofac.Extensions.DependencyInjection包即可。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130224834130-1256285150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　详情参考：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.1#default-service-container-replacement&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.1#default-service-container-replacement&lt;/a&gt;&lt;br/&gt;　　使用windsor或其它容器可以参考：&lt;br/&gt;　　&lt;a href=&quot;https://stackoverflow.com/questions/47672614/how-to-use-windsor-ioc-in-asp-net-core-2&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/47672614/how-to-use-windsor-ioc-in-asp-net-core-2&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;将Controller注册为服务&lt;/h3&gt;
&lt;p&gt;　　虽然Controller在激活时是通过容器来获取Controller的依赖(即构造方法需要的参数)，在代码运行的时候给人一种Controller是从容器中组装的错觉，但是实际上默认情况下Controller的组装过程不是直接由容器组装的，如果要让Controller从容器组装，那么在配置MVC服务时需要通过.AddControllerAsServices()方法将Controller注册到容器中：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130224917545-1631018180.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　注：一般情况下是否将Controller注册为服务对Controller的开发和代码的运行并没有很大区别，但是如果当容器变更为其它容器，并且使用了容器提供的如属性注入等功能时，如果没有将Controller注册为服务，那么相应的属性注入的过程也不会被触发，简单来说就是只有将Controller注册为服务，那么实例化Controller的工作才会由容器完成，才会触发或者使用到容器提供的其它特性。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;服务的获取&lt;/h3&gt;
&lt;p&gt;　　前面介绍了服务的注册，现在来介绍一下在ASP.NET Core中有哪些方法可以获取服务：&lt;br/&gt;　　1. Controller构造方法参数。&lt;br/&gt;　　2. 通过Controller注入IServiceProvider类型，通过IServiceProvider来获取服务：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130225003455-559353874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3. 在Action方法或者Mvc过滤器(过滤器的上下文参数中包含HttpContext)中通过HttpContext的RequestServices对象获取服务：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130225022336-1179508035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4. 在View上通过@inject注入服务：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130225044440-369662410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　5. 在Action方法中，通过FormServices特性注入：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130225103283-1690727659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　注：一般来说尽可能显式的标明类型的依赖(即通过构造参数的方式声明当前类型所依赖的组件)，上面的2和3两点分别都是通过服务提供器在方法内部来获取依赖，这样做依赖对于外界来说是不可知的，可能会对代码的可维护、可测试性等造成一定影响，这种模式被称为Service Locator模式，在开发过程中尽可能避免Service Locator模式的使用。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;常用的服务&lt;/h3&gt;
&lt;p&gt;　　ASP.NET Core相对于ASP.NET来说取消了一些常用的静态类型，比如HttpContext、ConfigurationManager等，取而代之的是通过将类似的组件以服务的形式注册到容器中，使用时通过容易来获取相应的服务组件，这些常用的服务有：&lt;br/&gt;　　1. IHostingEnvironment：包含了环境名称、应用名称以及当前应用程序所处的根目录及Web静态内容的根目录(默认wwwroot)。&lt;br/&gt;　　2. IHttpContextAccessor：从名字可以看出，它用来访问当前请求的HttpContext。&lt;br/&gt;　　3. IConfiguration：ASP.NET Core配置信息对象。&lt;br/&gt;　　4. IServiceProvider： ASP.NET Core服务提供器。&lt;br/&gt;　　5. DbContext: 这里的DbContext指的是EFCore的DbContext，在ASP.NET Core中，EFCore的DbContext也是在ConfigureServices方法中进行配置并添加到容器，使用时直接从容器中获取(但要注意的是对于分层结构的开发风格来说，DbContext不会直接被Controller依赖，而是被Controller中依赖的业务服务类型所以来，就是说编写Controller代码的时候不会直接与DbContext发生直接交互)。&lt;/p&gt;
&lt;h2&gt;Configuration&amp;amp;Options&lt;/h2&gt;
&lt;p&gt;　　在ASP.NET的开发中，通常某个变量需要从配置文件读取，一般都是在相应类型的构造方法中，通过静态类型ConfigurationManager的AppSettings方法来读取并初始化变量。虽然ASP.NET Core也可以在类型中注入IConfiguration实例来直接读取配置文件，但该方法由于Options模式的出现已经不再建议使用，使用组件通过依赖相应的组件Options可以做到关注点分离，提高程序的灵活性、可拓展性，Options使用方法见文档：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-2.1&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;ASP.NET Core 请求管道建立&lt;/h2&gt;
&lt;p&gt;　　ASP.NET由于是基于IIS请求管道的，ASP.NET应用程序仅仅是管道中的一个处理环节，管道中还包含如身份验证、静态文件处理等环节，但ASP.NET Core不一样，它脱离了IIS处理管道，所以整个管道的建立均需要靠程序自身完成，而ASP.NET Core建立管道的代码就是Startup类型的Configure方法，该方法通过IApplicationBuilder实例来添加不同功能的中间件，通过中间件的串联形成处理管道，下图是ASP.NET Mvc模板生成的管道代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130225203486-189694735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　图片来自：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/startup?view=aspnetcore-2.1#the-configure-method&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/startup?view=aspnetcore-2.1#the-configure-method&lt;/a&gt;&lt;br/&gt;　　该管道主要包含了错误处理(开发环境显示异常信息，其它环境跳转错误页面)中间件、静态文件处理中间件以及Mvc中间件。&lt;br/&gt;　　更多中间件可参考文档：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/index?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/index?view=aspnetcore-2.1&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;ASP.NET Core Mvc&lt;/h2&gt;
&lt;p&gt;　　ASP.NET Core Mvc与ASP.NET Mvc相比整体上区别不大，但仍然有很多细节上的变化，下面就开始一一介绍：&lt;/p&gt;
&lt;h3&gt;路由&lt;/h3&gt;
&lt;p&gt;　　路由的作用是将请求根据Url映射到“对应”的处理器上，在Mvc中请求的终点就是Controller的Action方法，而这里所谓的“对应”指的是Url与路由模板的匹配，ASP.NET Core Mvc通过以下的方式添加路由模板：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130225242985-1260249372.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图中的路由模板是最常用的路由模板，使用花括号内的内容为路由参数及其默认值，Url中通过路由参数控制器名称、活动方法名称来匹配到相应控制器的活动方法。&lt;br/&gt;在注册路由时可以为相应路由添加默认值、路由参数约束以及对应路由的相关附加数据(datatokens)：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130225307059-1383021551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　路由的功能除了处理请求匹配外，还具有链接生成的功能，特别是Mvc程序的View中使用IUrlHelper或TagHelper来生成页面的超链接：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130225324123-162291260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其生成原理是通过链接参数(如上图所示的Controller和Action)去路由表中匹配，然后使用匹配结果中的第一个路由(可能会匹配到多个路由对象，具体内容在后续Area章节介绍)来生成链接。&lt;/p&gt;
&lt;p&gt;　　更多路由信息及路由模板定义参考文档：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-2.1&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;控制器&lt;/h3&gt;
&lt;p&gt;　　ASP.NET Core Mvc的Controller一般继承Controller类型实现，基类Controller中包含了Mvc中常用的返回方法(如Json以及View等)以及用于数据存储的ViewBag、ViewData、TempData。&lt;/p&gt;
&lt;h3&gt;Area&lt;/h3&gt;
&lt;p&gt;　　Area是Mvc应用中用来进行功能拆分或分组的一种方式，Area一般有自己的命名空间和目录结构，一般Area的默认目录结构如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130225414758-1353193284.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　ASP.NET Core Mvc和ASP.NET Mvc中的概念和用法基本上是一致的，但也存在一些区别：&lt;br/&gt;　　1. Area下面的Controller需要使用Area特性标明当前Controller属于哪一个Area：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130225437206-364187696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：Area的目录结构不是必须的，只需要通过特性标记的Controller都会被正确识别，但目录结构的改变会导致无法找到View，关于View的查找路径会在后续介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　2. Area的路由注册也是在UseMvc方法中完成：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130225502517-1226770373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：携带Area的路由模板需要放在前面，否则在生成通过IUrlHelper或TagHelper生成链接时，由于Controller以及action会匹配到没有area的模板并使用该模板生成链接，导致area参数被忽略，而生成类似：/controller/action?area=area的结果(在生成Url时，ASP.NET Core会将多余的路由参数放置到查询字符串中)&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;View&lt;/h3&gt;
&lt;p&gt;　　View是基于Razor的HTML模板，Razor的详细语法参考文档：&lt;br/&gt;　　&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-2.1&lt;/a&gt;&lt;br/&gt;　　ASP.NET Core Mvc的View与ASP.NET Mvc中的使用方法基本一致，主要区别如下：&lt;br/&gt;　　1. 引入了TagHelper，使用TagHelper可以让View的代码更接近Html。更多TagHelper信息参考文档：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/intro?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/intro?view=aspnetcore-2.1&lt;/a&gt;&lt;br/&gt;　　2. Controller将参数传输到View的方法添加了ViewData特性，使用方法如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130225535960-1780072849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　View中访问被ViewData标记的方式：&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130225559285-218387537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　更多详情参考文档：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/mvc/views/overview?view=aspnetcore-2.1#passing-data-to-views&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/mvc/views/overview?view=aspnetcore-2.1#passing-data-to-views&lt;/a&gt;&lt;br/&gt;　　3. 新增View组件：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/mvc/views/view-components?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/mvc/views/view-components?view=aspnetcore-2.1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　配置View的查找路径：&lt;br/&gt;　　ASP.NET Core可以在ConfigureServices方法中对RazorViewEngineOptions进行配置，如下图所示，在默认查找位置基础上添加了View以及AreaView的查找路径：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130225652726-1211334779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;模型绑定&lt;/h3&gt;
&lt;p&gt;　　模型绑定指的是ASP.NET Core Mvc将请求携带的数据绑定到Action参数的过程，ASP.NET Core Mvc的模型绑定数据源默认使用Form Values、Route Values以及Query Strings，所有值都以Name-Value的形式存在，模型绑定时主要通过参数名称、参数名称.属性名称、参数名称[索引]等方式与数据源的Name进行匹配。&lt;br/&gt;　　除了默认的数据源之外还可以从Http请求Header、Http请求Body甚至从依赖注入容器中获取数据，要从这些数据源中获取数据需要在相应参数上使用[FromHeader]、[FromBody]、[FromServices]特性。&lt;br/&gt;　　如果需要获取的数据在不同数据源中都存在时(Name存在于多个数据源中)，还可以通过特性指明从哪一个数据源中获取，如[FromForm]、[FromQuery]及[FromRoute]。&lt;br/&gt;　　需要注意的是[FromBody]默认只支持Json格式的内容，如果需要支持其它格式，如XML需要添加相应的格式化器，添加方法如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130225726969-1257150244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　更多模型绑定及验证内容请参考文档：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/mvc/models/model-binding?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/mvc/models/model-binding?view=aspnetcore-2.1&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-2.1&lt;/a&gt;&lt;br/&gt;　　其中模型验证的使用方式与ASP.NET Mvc一致，仍然是通过相应的验证特性对模型或模型属性进行标记。&lt;/p&gt;
&lt;h3&gt;Action的返回值与Json序列化&lt;/h3&gt;
&lt;p&gt;　　说完Action方法参数的绑定，再来看一下Action方法的返回类型，在ASP.NET Mvc中Controller提供了返回页面内容的View方法以及返回Json内容的Json方法(当然还有文件、重定向、404等等其它内容返回方法，详见Controller与ControllerBase类型)。&lt;br/&gt;　　这里有一个需要注意的地方是当使用Json方法返回一个对象实例时，默认使用首字母小写的驼峰命名方式序列化实例的属性名称，如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130225832650-941689802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　访问结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130225849494-1067508188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　要使用大写驼峰形式命名需要在配置Mvc服务时添加以下代码来修改Json默认的序列化配置：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130225920535-709800226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：同样的问题也存在于WebAPI的Ok方法以及Signalr的Json格式协议。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;静态资源&lt;/h3&gt;
&lt;p&gt;　　由于ASP.NET Core已经不再使用IIS请求管道，所以对于静态资源的访问来说需要在请求管道中添加相应的处理中间件来完成：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130225956857-526910180.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　默认的无参UseStaticFiles方法将wwwroot目录作为静态资源存放目录，如果要添加其它静态内容目录可以再次使用UseStaticFiles方法，并通过StaticFileOptions对目录的访问路径以及实际路径进行配置：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130230022533-890450358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　注：由于ASP.NET Core可以在Linux下运行，所以对于Linux来说路径是大小写敏感的，另外由于Windows和Linux类系统的路径分隔符也不一致，所以为了保证路径的统一，可以使用Path.Combine方法，该方法会根据操作系统的不同对路径进行不同的处理。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　另外对于css及js资源文件的打包、压缩功能，最新版本(ASP.NET Core 2.1)的应用模板以及不会自动添加相关功能，需要在拓展工具中添加Bunlder&amp;amp; Minifier拓展：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130230050626-1680509020.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后通过右键js等资源文件来创建bundleconfig.json文件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130230110152-478341636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;WebAPI&lt;/h2&gt;
&lt;h3&gt;API控制器的创建&lt;/h3&gt;
&lt;p&gt;　　ASP.NET Core将Mvc和WebAPI进行了合并，它们的实现都直接或间接继承了ControllerBase类型，只不过Mvc的基类Controller在ControllerBase的基础上添加了一些用于处理View的功能。&lt;br/&gt;　　用ASP.NET Core开发WebAPI时，Controller类型直接继承ControllerBase。然后这个API的Controller就具有了基类的特性，返回一个结果仅需要使用Ok方法即可，如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130230140082-1836332137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后在路由表中添加路由：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130230155596-784947358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　即可通过/api/default/index访问到这个API：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130230325806-1886554062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　但对于REST风格的API来说，它需要通过ApiController特性对Controller类型进行标记，并且通过Route特性来设置路由：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130230341601-203232658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后就可以通过HTTP谓词来访问API：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130230359431-462522767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　但要注意的是在ASP.NET Core中实现的REST风格的Controller，它不会再根据action方法的名称来匹配谓词，所以存在多个方法时会，那怕对方法进行了命名，但仍然会出现以下错误：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130230417176-92407890.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为了解决这个问题，需要通过添加谓词特性解决：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130230515395-84252274.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;模型绑定&lt;/h3&gt;
&lt;p&gt;　　WebAPI中的模型绑定与MVC存在一些区别，首先当使用ApiController标记Controller类型时，如果模型绑定验证未通过，会直接返回400错误，不会执行Action方法(免去了使用!ModelState.IsValid进行判断)：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130230547356-1085495426.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　执行结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130230602020-372432047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其次使用ApiController标记的Controller在执行模型绑定时会使用默认的推断规则，该规则分别从Body、Form、Header、Query、Route、Services(它们分别对应FromBody、FromForm、FromHeader、FromQuery、FromRoute、FromServices特性)中推断获取数据并绑定，为什么说推断？&lt;/p&gt;
&lt;p&gt;　　因为有一些特殊的规则：&lt;br/&gt;　　1. FromBody用于复杂类型推断，如果不是复杂类型(如int、string等)以及特殊的内置类型(IFormCollection文档例子)，则不会从Body中获取数据，除非通过[FromBody]特性指明，例子如下：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130230650810-401513277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　请求结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130230713321-1706006306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当使用[FormBody]指明参数数据源后可以正常访问：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130230731458-933776454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：当请求参数为简单类型时，请求体内容类型需要为application/json，内容不能为Json字符串，使用参数值作为内容即可(上图id没有提供的异常并不是因为Json格式问题，而是没有指明从body中获取数据导致的)。&lt;/span&gt;&lt;br/&gt;　　2. 只能存在一个参数从Body中获取数据，如果出现多个参数时，只能保证一个参数从Body中获取数据，其它参数需要指明获取数据的位置：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130230756696-276260042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　该API的调用方式如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130230855801-665496637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3. FromForm默认只推断文件(IFormFile)及文件集合类型(IFormFileCollection)，其余类型默认均不会从Form中获取。&lt;br/&gt;　　4. 使用FromForm特性时会推断multipart/form-data请求内容类型。&lt;/p&gt;
&lt;p&gt;　　以上推断行为可以通过如下配置禁用：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130230922334-1145138408.png&quot; alt=&quot;&quot;/&gt;　&lt;/p&gt;
&lt;p&gt;　　更多信息参考文档：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/web-api/?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/aspnet/core/web-api/?view=aspnetcore-2.1&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;SignalR&lt;/h2&gt;
&lt;p&gt;　　SignalR是用于客户端服务器实时通信的工具库，从ASP.NET中就具有该功能，ASP.NET Core中的SignalR概念与用法与原来基本一致，但也存在一些区别：&lt;br/&gt;　　1. 支持更多的客户端，.Net客户端、Java客户端、Js客户端以及非官方的C++客户端、Swift客户端。&lt;br/&gt;　　2. 当链接SignalR并通过身份验证后，SignalR会保存当前用户链接SignalR的ID以及通过验证后的用户名，可以通过用户名向用户客户端推送消息。&lt;br/&gt;　　3. 在应用程序中可以通过IHubContext&amp;lt;HubType&amp;gt;方式，对SignalR上下文进行注入，并且可以直接通过该上下文推送数据给已经链接的客户端，IHubContext&amp;lt;HubType&amp;gt;实际上是GlobalHost.ConnectionManager.GetHubContext&amp;lt;HubType&amp;gt;()的替代方式。&lt;br/&gt;　　4. ASP.NET Core中通过app.UserSignalR以及route参数来映射一个Hub，每一个Hub拥有独立的上下文，因此如果要使用IHubContext&amp;lt;HubType&amp;gt;来向客户端推送信息，那么必须准确注明Hub的类型，如下图代码应该使用IHubContext&amp;lt;ChatHub&amp;gt;，不能使用除ChatHub以外的类型(基类也不行)。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130230959346-1659184436.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　5. SignalR默认使用Json协议传输数据，默认情况下使用首字母小写的驼峰命名方式序列化对象，要更改该默认行为需要通过一下代码，替换默认的序列化行为：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201811/640251-20181130231017540-1152946267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　6. ASP.NET Core的客户端代码(特指Js客户端)有变更，需要对应版本使用。&lt;br/&gt;　　关于更多SignalR内容请参考文档：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/signalr/introduction?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/signalr/introduction?view=aspnetcore-2.1&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;　　本文主要介绍了ASP.NET Core中Mvc、WebAPI以及SignalR开发时与原来ASP.NET中的一些细小区别和新特性，整体来说ASP.NET Core与ASP.NET从使用方式上基本上是一致的，这也使得从ASP.NET迁移到ASP.NET Core变得更加容易，但可能因为这些细小的问题往往会向代码中埋入一些坑，所以特别编写了本文来解释这些问题。&lt;br/&gt;　　总的来说ASP.NET Core的文档相当齐全，本文中大部分内容实际都是文档中提到的，所以建议大家在使用ASP.NET Core开发时，首先第一步就是熟读文档，避免遗漏细节。希望本篇文章对大家有帮助(*^_^*)&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/?view=aspnetcore-2.1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: ASP.Net Core开发(踩坑)指南&quot; href=&quot;https://www.cnblogs.com/selimsong/p/10047321.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/selimsong/p/10047321.html&lt;/a&gt; &lt;/p&gt;

</description>
<pubDate>Fri, 30 Nov 2018 15:27:00 +0000</pubDate>
<dc:creator>7m鱼</dc:creator>
<og:description>ASP.NET与ASP.NET Core很类似，但它们之间存在一些细微区别以及ASP.NET Core中新增特性的使用方法，在此之前也写过一篇简单的对比文章ASP.NET MVC应用迁移到ASP.NE</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/selimsong/p/10047321.html</dc:identifier>
</item>
</channel>
</rss>