<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>简单的骰子游戏 - YancyMauno</title>
<link>http://www.cnblogs.com/Mauno/p/9772766.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mauno/p/9772766.html</guid>
<description>&lt;p&gt;偶尔看到的了一个需求，闲来无事就简单写了一下，仅供学习娱乐，欢迎指正交流。&lt;/p&gt;
&lt;p&gt;骰子数：3个&lt;/p&gt;
&lt;p&gt;奖励倍数：1-9倍&lt;/p&gt;
&lt;p&gt;奖励结果 = 赌注 * 奖励倍数&lt;/p&gt;
&lt;p&gt;游戏玩法选择：  猜和值，猜和值大小单双，猜点数，猜点数两同，猜点数三同且猜中点数，猜点数三同不猜点数&lt;/p&gt;
&lt;p&gt;游戏玩法步骤: &lt;/p&gt;
&lt;p&gt;        1. 运行程序&lt;/p&gt;
&lt;p&gt;        2. 控制台输入玩法标识  1--猜和值 2--猜和值大小 3--猜和值单双 4--猜点数 5--猜两同 6--猜点数三同且猜中点数 7--猜点数三同 不猜点数&lt;/p&gt;
&lt;p&gt;        3. 控制台输入竞猜(和值3-18/大小00,01/单双10,11/点数 1-3个以逗号隔开的数字/三同点数 1-6).注 猜两同 猜三同不猜点数 可随意输入&lt;/p&gt;
&lt;p&gt;        4. 控制台输入赌注(数字)&lt;/p&gt;
&lt;p&gt;        5. 回车查看奖励&lt;/p&gt;
&lt;p&gt;CODE:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;骰子游戏&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; diceGame() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化奖励倍数&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; times1=1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜中和值的奖励倍数&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; times2=2;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜中和值大小的奖励倍数&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; times3=3;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜中和值单双的奖励倍数&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; times4=4;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜中点数的个数为1个的奖励倍数&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; times5=5;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜中点数的个数为2个的奖励倍数&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; times6=6;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜中点数的个数为3个的奖励倍数&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; times7=7;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜中点数两同的奖励倍数&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; times8=8;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜中点数三同的奖励倍数&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; times9=9;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜中点数三同通选的奖励倍数
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成三个 1-6 随机数 a,b,c&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; a=(&lt;span&gt;int&lt;/span&gt;) (Math.random()*6+1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b=(&lt;span&gt;int&lt;/span&gt;) (Math.random()*6+1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c=(&lt;span&gt;int&lt;/span&gt;) (Math.random()*6+1&lt;span&gt;);
        System.out.println(a&lt;/span&gt;+&quot;,&quot;+b+&quot;,&quot;+&lt;span&gt;c);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最终奖励倍数 times 初始化为0&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; times = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;三个随机数的玩法组合结果 result： 和值，和值大小单双，猜中点数的个数，点数两同，点数三同，点数三同通选&lt;/span&gt;
        String resultFlag = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标识选择的玩法（输入1,2,3,4....）&lt;/span&gt;
        String result= &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户的竞猜结果&lt;/span&gt;
        String beans= &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户竞猜的金豆数&lt;/span&gt;
        Scanner s = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
            resultFlag &lt;/span&gt;=&lt;span&gt; s.nextLine();
        }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(resultFlag.length()==0&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
            result &lt;/span&gt;=&lt;span&gt; s.nextLine();
        }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(result.length()==0&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
            beans &lt;/span&gt;=&lt;span&gt; s.nextLine();
        }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(beans.length()==0&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜和值&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(resultFlag.equals(&quot;1&quot;)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜和值&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(a+b+c==&lt;span&gt;Integer.parseInt(result)) {
                System.out.println(&lt;/span&gt;&quot;猜中和值&quot;&lt;span&gt;);
                times &lt;/span&gt;=&lt;span&gt; times1;
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜和值大小&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(resultFlag.equals(&quot;2&quot;&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a+b+c&amp;lt;=10&amp;amp;&amp;amp;result.equals(&quot;00&quot;)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字符串标识 &quot;00&quot; 大 &quot;01&quot;小&lt;/span&gt;
                    System.out.println(&quot;猜中和值小&quot;&lt;span&gt;);
                    times &lt;/span&gt;=&lt;span&gt; times2;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;((a+b+c)%2==1&amp;amp;&amp;amp;result.equals(&quot;01&quot;&lt;span&gt;)){
                System.out.println(&lt;/span&gt;&quot;猜中和值大&quot;&lt;span&gt;);
                times &lt;/span&gt;=&lt;span&gt; times2;
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜和值单双&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(resultFlag.equals(&quot;3&quot;&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((a+b+c)%2==1&amp;amp;&amp;amp;result.equals(&quot;10&quot;)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字符串标识 &quot;10&quot; 单 &quot;11&quot;双&lt;/span&gt;
                System.out.println(&quot;猜中和值单数&quot;&lt;span&gt;);
                times &lt;/span&gt;=&lt;span&gt; times3;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;((a+b+c)%2==0&amp;amp;&amp;amp;result.equals(&quot;11&quot;&lt;span&gt;)){
                System.out.println(&lt;/span&gt;&quot;猜中和值双数&quot;&lt;span&gt;);
                times &lt;/span&gt;=&lt;span&gt; times3;
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜点数&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(resultFlag.equals(&quot;4&quot;&lt;span&gt;)) {
            String[] res &lt;/span&gt;= result.split(&quot;,&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜点数玩法  用户输入一行1-3个数以逗号隔开&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(res.length==1) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜一个数&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(a==Integer.parseInt(res[0])||b==Integer.parseInt(res[0])||c==Integer.parseInt(res[0&lt;span&gt;])) {
                    System.out.println(&lt;/span&gt;&quot;猜中三个随机数中含有某一个点数&quot;&lt;span&gt;);
                    times &lt;/span&gt;=&lt;span&gt; times4;
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(res.length==2) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜两个数&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(a==Integer.parseInt(res[0])&amp;amp;&amp;amp;b==Integer.parseInt(res[1&lt;span&gt;])
                        &lt;/span&gt;||a==Integer.parseInt(res[1])&amp;amp;&amp;amp;b==Integer.parseInt(res[0&lt;span&gt;])) {
                    times &lt;/span&gt;=&lt;span&gt; times5;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a==Integer.parseInt(res[0])&amp;amp;&amp;amp;c==Integer.parseInt(res[1&lt;span&gt;])
                        &lt;/span&gt;||a==Integer.parseInt(res[1])&amp;amp;&amp;amp;c==Integer.parseInt(res[0&lt;span&gt;])) {
                    times &lt;/span&gt;=&lt;span&gt; times5;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(b==Integer.parseInt(res[0])&amp;amp;&amp;amp;a==Integer.parseInt(res[1&lt;span&gt;])
                        &lt;/span&gt;||b==Integer.parseInt(res[1])&amp;amp;&amp;amp;a==Integer.parseInt(res[0&lt;span&gt;])) {
                    times &lt;/span&gt;=&lt;span&gt; times5;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(b==Integer.parseInt(res[0])&amp;amp;&amp;amp;c==Integer.parseInt(res[1&lt;span&gt;])
                        &lt;/span&gt;||b==Integer.parseInt(res[1])&amp;amp;&amp;amp;c==Integer.parseInt(res[0&lt;span&gt;])) {
                    times &lt;/span&gt;=&lt;span&gt; times5;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(c==Integer.parseInt(res[0])&amp;amp;&amp;amp;a==Integer.parseInt(res[1&lt;span&gt;])
                        &lt;/span&gt;||c==Integer.parseInt(res[1])&amp;amp;&amp;amp;a==Integer.parseInt(res[0&lt;span&gt;])) {
                    times &lt;/span&gt;=&lt;span&gt; times5;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(c==Integer.parseInt(res[0])&amp;amp;&amp;amp;b==Integer.parseInt(res[1&lt;span&gt;])
                        &lt;/span&gt;||c==Integer.parseInt(res[1])&amp;amp;&amp;amp;b==Integer.parseInt(res[0&lt;span&gt;])) {
                    times &lt;/span&gt;=&lt;span&gt; times5;
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(res.length==3) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜三个数&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(a==Integer.parseInt(res[0])&amp;amp;&amp;amp;b==Integer.parseInt(res[1])&amp;amp;&amp;amp;c==Integer.parseInt(res[2&lt;span&gt;])) {
                    times &lt;/span&gt;=&lt;span&gt; times6;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a==Integer.parseInt(res[0])&amp;amp;&amp;amp;b==Integer.parseInt(res[2])&amp;amp;&amp;amp;c==Integer.parseInt(res[1&lt;span&gt;])) {
                    times &lt;/span&gt;=&lt;span&gt; times6;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a==Integer.parseInt(res[1])&amp;amp;&amp;amp;b==Integer.parseInt(res[0])&amp;amp;&amp;amp;c==Integer.parseInt(res[2&lt;span&gt;])) {
                    times &lt;/span&gt;=&lt;span&gt; times6;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a==Integer.parseInt(res[1])&amp;amp;&amp;amp;b==Integer.parseInt(res[2])&amp;amp;&amp;amp;c==Integer.parseInt(res[0&lt;span&gt;])) {
                    times &lt;/span&gt;=&lt;span&gt; times6;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a==Integer.parseInt(res[2])&amp;amp;&amp;amp;b==Integer.parseInt(res[0])&amp;amp;&amp;amp;c==Integer.parseInt(res[1&lt;span&gt;])) {
                    times &lt;/span&gt;=&lt;span&gt; times6;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a==Integer.parseInt(res[2])&amp;amp;&amp;amp;b==Integer.parseInt(res[1])&amp;amp;&amp;amp;c==Integer.parseInt(res[0&lt;span&gt;])) {
                    times &lt;/span&gt;=&lt;span&gt; times6;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(resultFlag.equals(&quot;5&quot;)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜两同&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(a==b||a==c||b==&lt;span&gt;c) {
                System.out.println(&lt;/span&gt;&quot;猜中两同&quot;&lt;span&gt;);
                times &lt;/span&gt;=&lt;span&gt; times7;
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(resultFlag.equals(&quot;6&quot;)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜三同&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(a==b&amp;amp;&amp;amp;b==c&amp;amp;&amp;amp;a==&lt;span&gt;Integer.parseInt(result)) {
                System.out.println(&lt;/span&gt;&quot;猜三同且猜中数字&quot;&lt;span&gt;);
                times &lt;/span&gt;=&lt;span&gt; times8;
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(resultFlag.equals(&quot;7&quot;)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;猜三同通选&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(a==b&amp;amp;&amp;amp;b==&lt;span&gt;c) {
                System.out.println(&lt;/span&gt;&quot;猜中三同&quot;&lt;span&gt;);
                times &lt;/span&gt;=&lt;span&gt; times9;
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印输出  奖励数=金豆数*倍数&lt;/span&gt;
        System.out.println(Integer.parseInt(beans)*&lt;span&gt;times);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 运行截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1116734/201810/1116734-20181011153430582-1702923816.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 11 Oct 2018 07:36:00 +0000</pubDate>
<dc:creator>YancyMauno</dc:creator>
<og:description>偶尔看到的了一个需求，闲来无事就简单写了一下，仅供学习娱乐，欢迎指正交流。 骰子数：3个 奖励倍数：1-9倍 奖励结果 = 赌注 * 奖励倍数 游戏玩法选择： 猜和值，猜和值大小单双，猜点数，猜点数两</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mauno/p/9772766.html</dc:identifier>
</item>
<item>
<title>原生js实现一个自定义下拉单选选择框 - 山海之间</title>
<link>http://www.cnblogs.com/websharehome/p/9772755.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/websharehome/p/9772755.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; jshint esversion: 6 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (window, document) {
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     let Selector = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (option) {
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行初始化方法，&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._init(option);
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt;     Selector.prototype =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化传入参数并定义初始化的相关变量&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;        _init({
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;             eleSelector = &quot;&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入的选择器 id,class，tag等，用于将选择框渲染到此选择器所在的元素&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;             options =&lt;span&gt; [{
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;                 name: &quot;请选择&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;                 value: &quot;0&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;             }], &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入的下拉框对象，name为选择的文字，value为值&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt;             defaultText = &quot;请选择&quot; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;提供的默认选择的值&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;        }) {
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;             
&lt;span&gt; 19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将传入的数据绑定到this上&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.parentEle = document.querySelector(eleSelector) || document.body; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;要邦定的dom &lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.options = options; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择值数组对象&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.defaultText = defaultText; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认值&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.dropboxShow = &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义存储下拉框的显示隐藏状态&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.defaultValue = &quot;&quot;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义村赤默认选中的值&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;._creatElement(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化后执行创建元素方法&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建下拉选择框dom&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;        _creatElement() {
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择框最外层的包裹元素&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;             let wrapEle = document.createElement(&quot;div&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;             wrapEle.className = &quot;my-select&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据传入的值获取选择框默认的值和内容&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.options.forEach(item =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (item.name === &quot;this.defaultText&quot;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.defaultValue =&lt;span&gt; item.value;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt;             let selectWarpBox = document.createElement(&quot;div&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择框包裹元素&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;             selectWarpBox.className = &quot;select-selection&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt;             let inputHideBox = document.createElement(&quot;input&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;隐藏保存选择值得元素&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;             inputHideBox.type = &quot;hidden&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             inputHideBox.value = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaultValue;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt;             let selectShowBox = document.createElement(&quot;div&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择框默认展示框&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt;             let selectNameBox = document.createElement(&quot;span&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择框展现的值ele&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;             selectNameBox.className = &quot;select-selected-value&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;             selectNameBox.id = &quot;select-option&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;             selectNameBox.innerText = &lt;span&gt;this&lt;/span&gt;.defaultText; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将传入的默认值赋值&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;             let selectIcon = document.createElement(&quot;i&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;图标ele&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;             selectIcon.className = &quot;arrow-down icon-select-arrow&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将span和角标添加到外层div&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;            selectShowBox.appendChild(selectNameBox);
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;            selectShowBox.appendChild(selectIcon);
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; 
&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;            selectWarpBox.appendChild(inputHideBox);
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;            selectWarpBox.appendChild(selectShowBox);
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下拉框&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt;             let dropbox = document.createElement(&quot;div&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;                 ulbox = document.createElement(&quot;ul&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;             dropbox.id = &quot;select-drop&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;             dropbox.className = &quot;select-dropdown&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;             ulbox.className = &quot;select-dropdown-list&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历传入的选项数组对象，生成下拉菜单的li元素并赋值&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.options.forEach((item) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;                 let itemLi = document.createElement(&quot;li&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.defaultText ===&lt;span&gt; item.name) {
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;                     itemLi.className = &quot;select-item select-item-selected&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                     itemLi.className = &quot;select-item&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt;                 itemLi.setAttribute(&quot;data-value&quot;&lt;span&gt;, item.value);
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                 itemLi.innerText =&lt;span&gt; item.name;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;                ulbox.appendChild(itemLi);
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将下拉框ul推入到包裹元素&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;            dropbox.appendChild(ulbox);
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; 
&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;            wrapEle.appendChild(selectWarpBox);
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;            wrapEle.appendChild(dropbox);
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.parentEle.appendChild(wrapEle); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将生成的下拉框添加到所选元素中&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt; 
&lt;span&gt; 92&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把需要操作的dom挂载到当前实例&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;this.wrapEle = wrapEle;     //最外层包裹元素&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.eleSelect = selectWarpBox; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择框&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.eleDrop = dropbox; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下拉框&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.eleSpan = selectNameBox; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示文字的span节点&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt; 
&lt;span&gt; 98&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定事件处理函数&lt;/span&gt;
&lt;span&gt; 99&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;._bind(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.parentEle);
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击下拉框事件处理函数&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt; &lt;span&gt;        _selectHandleClick() {
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dropboxShow) {
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._selectDropup();
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._selectDropdown();
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;收起下拉选项&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt; &lt;span&gt;        _selectDropup() {
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.eleDrop.style.transform = &quot;scale(1,0)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.eleDrop.style.opacity = &quot;0&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.eleSelect.className = &quot;select-selection&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.dropboxShow = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; 
&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;展示下拉选项&lt;/span&gt;
&lt;span&gt;120&lt;/span&gt; &lt;span&gt;        _selectDropdown() {
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.eleDrop.style.transform = &quot;scale(1,1)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.eleDrop.style.opacity = &quot;1&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.eleSelect.className = &quot;select-selection select-focus&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.dropboxShow = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击下拉选项进行赋值&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt; &lt;span&gt;        _dropItemClick(ele) {
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.defaultValue = ele.getAttribute(&quot;data-value&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;document.querySelector(&quot;#select-value&quot;).value = ele.getAttribute(&quot;data-value&quot;);&lt;/span&gt;
&lt;span&gt;131&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.eleSpan.innerText =&lt;span&gt; ele.innerText;
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;             ele.className = &quot;select-item select-item-selected&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对点击选中的其他所有兄弟元素修改class去除选中样式&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;._siblingsDo(ele, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (ele) {
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ele) {
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;                     ele.className = &quot;select-item&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._selectDropup();
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; 
&lt;span&gt;142&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;node遍历是否是子元素包裹元素&lt;/span&gt;
&lt;span&gt;143&lt;/span&gt; &lt;span&gt;        _getTargetNode(ele, target) {
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ele是内部元素，target是你想找到的包裹元素&lt;/span&gt;
&lt;span&gt;145&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!ele || ele === document) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; ele === target ? &lt;span&gt;true&lt;/span&gt; : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._getTargetNode(ele.parentNode, target);
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; 
&lt;span&gt;149&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;兄弟元素遍历处理函数&lt;/span&gt;
&lt;span&gt;150&lt;/span&gt; &lt;span&gt;        _siblingsDo(ele, fn) {
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; 
&lt;span&gt;152&lt;/span&gt;             (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (ele) {
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;                fn(ele);
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (ele &amp;amp;&amp;amp;&lt;span&gt; ele.previousSibling) {
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; &lt;span&gt;                    arguments.callee(ele.previousSibling);
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;            })(ele.previousSibling);
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; 
&lt;span&gt;159&lt;/span&gt;             (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (ele) {
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; &lt;span&gt;                fn(ele);
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (ele &amp;amp;&amp;amp;&lt;span&gt; ele.nextSibling) {
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; &lt;span&gt;                    arguments.callee(ele.nextSibling);
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; &lt;span&gt;            })(ele.nextSibling);
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; 
&lt;span&gt;166&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; 
&lt;span&gt;168&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定下拉框事件处理函数&lt;/span&gt;
&lt;span&gt;169&lt;/span&gt; &lt;span&gt;        _bind(parentEle) {
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;             let _this = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;事件委托到最外层包裹元素进行绑定处理&lt;/span&gt;
&lt;span&gt;172&lt;/span&gt;             parentEle.addEventListener(&quot;click&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;                 const ele =&lt;span&gt; e.target;
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;                 
&lt;span&gt;175&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历当前点击的元素，如果是选中框内的元素执行&lt;/span&gt;
&lt;span&gt;176&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_this._getTargetNode(ele, _this.eleSelect)) {
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_this.dropboxShow) {
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; &lt;span&gt;                        _this._selectDropup();
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;                     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; &lt;span&gt;                        _this._selectDropdown();
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ele.className === &quot;select-item&quot;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是点击的下拉框的选项执行&lt;/span&gt;
&lt;span&gt;183&lt;/span&gt; &lt;span&gt;                    _this._dropItemClick(ele);
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击其他地方隐藏下拉框&lt;/span&gt;
&lt;span&gt;185&lt;/span&gt; &lt;span&gt;                    _this._selectDropup();
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt; 
&lt;span&gt;188&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; 
&lt;span&gt;190&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; 
&lt;span&gt;192&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将构造函数挂载到全局window&lt;/span&gt;
&lt;span&gt;194&lt;/span&gt;     window.$Selector =&lt;span&gt; Selector;
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; })(window, document);
&lt;/pre&gt;</description>
<pubDate>Thu, 11 Oct 2018 07:35:00 +0000</pubDate>
<dc:creator>山海之间</dc:creator>
<og:description>原生js自定义的下拉选择框</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/websharehome/p/9772755.html</dc:identifier>
</item>
<item>
<title>sass(scss）的安装与使用 - 汪聪先生</title>
<link>http://www.cnblogs.com/wangmingcong/p/9772746.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangmingcong/p/9772746.html</guid>
<description>&lt;p&gt;CSS预编译器有 SASS LESS Stylus等等，SCSS是SASS3引入的新语法。那为什么要选择SCSS呢？那我只能说我喜欢啊！不管SASS也好，LESS也罢，还是Stylus都只是一种工具，各有各的优缺点，选择自己喜欢的用着舒服的就是了。没必要纠结这么多。&lt;/p&gt;
&lt;h5&gt;准备工作（注意：这是windows平台下的安装）&lt;/h5&gt;
&lt;h5&gt;1.1 安装&lt;/h5&gt;
&lt;h5&gt;　　SASS是Ruby语言写的，但是两者的语法没有关系。所以不懂Ruby，一样可以使用。只是必须先&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Frubyinstaller.org%2Fdownloads%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;安装Ruby&lt;/a&gt;，然后再安装SASS。&lt;/h5&gt;
&lt;p&gt;　　根据自己系统的位数（64 OR 32）选择合适的安装包，下载安装包之后双击打开，一路下一步，完成！&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1491136/201810/1491136-20181011152819925-1267078441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　打开ruby的控制台，输入ruby -v，如果出现以下结果，则证明ruby安装成功！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ruby -v&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div readability=&quot;13.925213675214&quot;&gt;
&lt;div readability=&quot;18.5&quot;&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1491136/201810/1491136-20181011152747222-2004570030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　安装完ruby之后，直接在控制台就可以安装SASS。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;gem install sass&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　至此，SCSS安装完毕！&lt;/p&gt;
&lt;h5&gt;1.2 使用&lt;/h5&gt;
&lt;p&gt;    SASS文件就是普通的文本文件，里面可以直接使用CSS语法。文件后缀名是.scss，意思为Sassy CSS。&lt;br/&gt;下面的命令，可以将.scss文件转化的css代码并保存到一个新文件中。（假设文件名为app。）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sass app.scss app.css&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;     SASS提供四种编译风格的选项：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;nested：嵌套缩进的css代码，它是默认值。&lt;br/&gt;expanded：没有缩进的、扩展的css代码。&lt;br/&gt;compact：简洁格式的css代码。&lt;br/&gt;compressed：压缩后的css代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;    编码风格自行设置，用一次就知道了嘛。&lt;/p&gt;
&lt;/div&gt;
&lt;h5&gt;1.3 安装Koala&lt;/h5&gt;
&lt;p&gt;        Koala是一款图形化界面的编译软件，支持Sass Less CoffeeScript的编译。官网下载直接安装，不过需要依赖于Ruby。具体安装就不做介绍了。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1491136/201810/1491136-20181011153113812-921445533.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;
</description>
<pubDate>Thu, 11 Oct 2018 07:34:00 +0000</pubDate>
<dc:creator>汪聪先生</dc:creator>
<og:description>CSS预编译器有 SASS LESS Stylus等等，SCSS是SASS3引入的新语法。那为什么要选择SCSS呢？那我只能说我喜欢啊！不管SASS也好，LESS也罢，还是Stylus都只是一种工具，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangmingcong/p/9772746.html</dc:identifier>
</item>
<item>
<title>我要翻译《Think Python》 - 开篇申明 - 鬼画符</title>
<link>http://www.cnblogs.com/simba/p/9772722.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/simba/p/9772722.html</guid>
<description>&lt;p&gt;突然做了一个决定，想翻译一下《Think Python》这本书。&lt;/p&gt;
&lt;p&gt;这本书是基于GUN自由文档协议的，可以自由修改发布。&lt;/p&gt;
&lt;p&gt;原文地址：&lt;/p&gt;
&lt;p&gt;http://www.greenteapress.com/thinkpython/html/index.html&lt;/p&gt;
&lt;p&gt;电子版PDF下载地址：&lt;/p&gt;
&lt;p&gt;http://www.greenteapress.com/thinkpython/thinkpython.pdf&lt;/p&gt;
&lt;p&gt;书中的范例可以从Github下载&lt;/p&gt;
&lt;p&gt;https://github.com/AllenDowney/ThinkPython&lt;/p&gt;

&lt;p&gt;声明：翻译得不一定能适合所有人口味，很多地方并非按原文直译，而是按自己的理解尽可能的描述作者想要表达的意思，众网友要是能看得下去，就凑活着看吧，希望可以帮助到想学Python又苦于英文不熟练的朋友，即使我本人也是英文张口就结巴，权当是帮自己在学习Python的同时顺便历练提高一下自己的英语水平。&lt;/p&gt;

&lt;p&gt;希望可以帮到一些人，哪怕只有我自己一个人！&lt;/p&gt;

</description>
<pubDate>Thu, 11 Oct 2018 07:32:00 +0000</pubDate>
<dc:creator>鬼画符</dc:creator>
<og:description>我要翻译《Think Python》</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/simba/p/9772722.html</dc:identifier>
</item>
<item>
<title>python之路 第一篇 - Matthew92</title>
<link>http://www.cnblogs.com/majian1992/p/9772684.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/majian1992/p/9772684.html</guid>
<description>&lt;p&gt;一 编程语言：&lt;/p&gt;
&lt;p&gt;1.机器语言：直接用二进制编程，直接操作硬件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　&lt;span&gt;优点：执行效率快

　缺点：学习难度大，开发效率低&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.汇编语言：用英文标签来代替一串特定意义的二进制，直接操作硬件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;优点：执行效率快，不如机器语言快

缺点：学习难度大，开发效率低，比机器语言降一个难度&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3.高级语言：站在人的角度的语言，机器无法理解&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;编译型（c）：相当于百度翻译，翻译一次，拿着翻译结果去执行

　　　　　　优点：执行效率高

　　　　　　缺点：开发效率低

解释型（python）：相当于同声传译，一边解释一边执行。

　　　　　　优点：开发效率高

　　　　　　缺点：执行效率低&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;综合来讲，由于程序员的时间比电脑时间更有价值，所以开发效率高更重要。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_6b65885f-ac23-477c-b6e9-0bb2a9ba4ec9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6b65885f-ac23-477c-b6e9-0bb2a9ba4ec9&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6b65885f-ac23-477c-b6e9-0bb2a9ba4ec9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;机器语言
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;优点是最底层，执行速度最快&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;缺点是最复杂，开发效率最低&lt;/span&gt;
&lt;span&gt;
汇编语言
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;优点是比较底层，执行速度最快&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;缺点是复杂，开发效率最低&lt;/span&gt;
&lt;span&gt;
高级语言
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;编译型语言执行速度快，不依赖语言环境运行，跨平台差&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;解释型跨平台好，一份代码，到处使用，缺点是执行速度慢，依赖解释器运行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;总结&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;二 数据类型：&lt;/p&gt;
&lt;p&gt;　　数字&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int 整型

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;就是整数 1/2/3/4&lt;/span&gt;
&lt;span&gt;
float 浮点型

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;就是小数 1.0/2.0&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果参与出发的两个数中有一个数为浮点数，运算结果也为浮点数&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;1.0/2.0
0.5
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　字符串&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在Python中，加了引号的字符类型就是字符串。&lt;/span&gt;
&lt;span&gt;
比如：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello world!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在Python中，单引号，双引号，多引号没有区别，但多行字符串的时候需用多引号&lt;/span&gt;
&lt;span&gt;
msg &lt;/span&gt;= &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;hi Matthew!
             你今天真帅！
             我说的是真的！
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;字符串拼接（只能在字符串中进行）&lt;/span&gt;
name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Matthew&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
age &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&amp;gt;&amp;gt;&amp;gt;name +&lt;span&gt; age
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Matthew18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&amp;gt;&amp;gt;&amp;gt;name*2
&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MatthewMatthew&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;注意：字符串相加的效率不高&lt;/span&gt;
字符串1+&lt;span&gt;字符串2，并不会在字符串1的基础上加字符串2，而是申请一个全新的内存空间存入字符串1和字符串2，相当字符串1与字符串2的空间被复制了一次，
 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Thu, 11 Oct 2018 07:28:00 +0000</pubDate>
<dc:creator>Matthew92</dc:creator>
<og:description>一 编程语言： 1.机器语言：直接用二进制编程，直接操作硬件。 2.汇编语言：用英文标签来代替一串特定意义的二进制，直接操作硬件 3.高级语言：站在人的角度的语言，机器无法理解 综合来讲，由于程序员的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/majian1992/p/9772684.html</dc:identifier>
</item>
<item>
<title>深入源码分析Java线程池的实现原理 - Java修炼记</title>
<link>http://www.cnblogs.com/Javaba/p/9772648.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Javaba/p/9772648.html</guid>
<description>&lt;p&gt;程序的运行，其本质上，是对系统资源（CPU、内存、磁盘、网络等等）的使用。如何高效的使用这些资源是我们编程优化演进的一个方向。今天说的线程池就是一种对CPU利用的优化手段。&lt;/p&gt;
&lt;p&gt;网上有不少介绍如何使用线程池的文章，那我想说点什么呢？我希望通过学习线程池原理，明白所有池化技术的基本设计思路。遇到其他相似问题可以解决。&lt;/p&gt;

&lt;p&gt;前面提到一个名词——池化技术，那么到底什么是池化技术呢？&lt;/p&gt;
&lt;p&gt;池化技术简单点来说，就是提前保存大量的资源，以备不时之需。在机器资源有限的情况下，使用池化技术可以大大的提高资源的利用率，提升性能等。&lt;/p&gt;
&lt;p&gt;在编程领域，比较典型的池化技术有：&lt;/p&gt;
&lt;p&gt;线程池、连接池、内存池、对象池等。&lt;/p&gt;
&lt;p&gt;本文主要来介绍一下其中比较简单的线程池的实现原理，希望读者们可以举一反三，通过对线程池的理解，学习并掌握所有编程中池化技术的底层原理。&lt;/p&gt;

&lt;p&gt;在Java的并发编程中，线程是十分重要的，在Java中，创建一个线程比较简单：&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;671&quot; data-height=&quot;192&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-a48378c359c11db3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/671/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-a48378c359c11db3.png&quot; data-original-width=&quot;671&quot; data-original-height=&quot;192&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;14943&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们通过创建一个线程对象，并且实现Runnable接口就可以实现一个简单的线程。可以利用上多核CPU。当一个任务结束，当前线程就接收。&lt;/p&gt;
&lt;p&gt;但很多时候，我们不止会执行一个任务。如果每次都是如此的创建线程-&amp;gt;执行任务-&amp;gt;销毁线程，会造成很大的性能开销。&lt;/p&gt;
&lt;p&gt;那能否一个线程创建后，执行完一个任务后，又去执行另一个任务，而不是销毁。这就是线程池。&lt;/p&gt;
&lt;p&gt;这也就是池化技术的思想，通过预先创建好多个线程，放在池中，这样可以在需要使用线程的时候直接获取，避免多次重复创建、销毁带来的开销。&lt;/p&gt;


&lt;p&gt;以下代码，是在Java中创建线程池：&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;674&quot; data-height=&quot;337&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-c009740885104f5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/674/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-c009740885104f5d.png&quot; data-original-width=&quot;674&quot; data-original-height=&quot;337&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;27456&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;Jdk提供给外部的接口也很简单。直接调用ThreadPoolExecutor构造一个就可以了，也可以通过Executors静态工厂构建，但一般不建议。&lt;/p&gt;
&lt;p&gt;可以看到，开发者想要在代码中使用线程池还是比较简单的，这得益于Java给我们封装好的一系列API。但是，这些API的背后是什么呢，让我们来揭开这个迷雾，看清线程池的本质。&lt;/p&gt;

&lt;p&gt;通常，一般构造函数会反映出这个工具或这个对象的数据存储结构。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1029&quot; data-height=&quot;730&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-1ee00b96d8b99163?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-1ee00b96d8b99163&quot; data-original-width=&quot;1029&quot; data-original-height=&quot;730&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;87124&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;679&quot; data-height=&quot;151&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-c85b89d97db76ebe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/679/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-c85b89d97db76ebe.png&quot; data-original-width=&quot;679&quot; data-original-height=&quot;151&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;20850&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;acc : 获取调用上下文&lt;/p&gt;
&lt;p&gt;corePoolSize: 核心线程数量，可以类比正式员工数量，常驻线程数量。&lt;/p&gt;
&lt;p&gt;maximumPoolSize: 最大的线程数量，公司最多雇佣员工数量。常驻+临时线程数量。&lt;/p&gt;
&lt;p&gt;workQueue：多余任务等待队列，再多的人都处理不过来了，需要等着，在这个地方等。&lt;/p&gt;
&lt;p&gt;keepAliveTime：非核心线程空闲时间，就是外包人员等了多久，如果还没有活干，解雇了。&lt;/p&gt;
&lt;p&gt;threadFactory: 创建线程的工厂，在这个地方可以统一处理创建的线程的属性。每个公司对员工的要求不一样，恩，在这里设置员工的属性。&lt;/p&gt;
&lt;p&gt;handler：线程池拒绝策略，什么意思呢？就是当任务实在是太多，人也不够，需求池也排满了，还有任务咋办？默认是不处理，抛出异常告诉任务提交者，我这忙不过来了。&lt;/p&gt;

&lt;p&gt;接着，我们看一下线程池中比较重要的execute方法，该方法用于向线程池中添加一个任务。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;841&quot; data-height=&quot;787&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-75d5d342565a753a?imageMogr2/auto-orient/strip%7CimageView2/2/w/841/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-75d5d342565a753a&quot; data-original-width=&quot;841&quot; data-original-height=&quot;787&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;80446&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;核心模块用红框标记了。&lt;/p&gt;
&lt;p&gt;第一个红框：workerCountOf方法根据ctl的低29位，得到线程池的当前线程数，如果线程数小于corePoolSize，则执行addWorker方法创建新的线程执行任务；&lt;/p&gt;
&lt;p&gt;第二个红框：判断线程池是否在运行，如果在，任务队列是否允许插入，插入成功再次验证线程池是否运行，如果不在运行，移除插入的任务，然后抛出拒绝策略。如果在运行，没有线程了，就启用一个线程。&lt;/p&gt;
&lt;p&gt;第三个红框：如果添加非核心线程失败，就直接拒绝了。&lt;/p&gt;
&lt;p&gt;这里逻辑稍微有点复杂，画了个流程图仅供参考&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;500&quot; data-height=&quot;850&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-ee3c62a0672910b4?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-ee3c62a0672910b4&quot; data-original-width=&quot;500&quot; data-original-height=&quot;850&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;19214&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;接下来，我们看看如何添加一个工作线程的？&lt;/p&gt;

&lt;p&gt;从方法execute的实现可以看出：addWorker主要负责创建新的线程并执行任务，代码如下（这里代码有点长，没关系，也是分块的，总共有5个关键的代码块）：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;808&quot; data-height=&quot;536&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-c7ca22f84ebef0f2?imageMogr2/auto-orient/strip%7CimageView2/2/w/808/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-c7ca22f84ebef0f2&quot; data-original-width=&quot;808&quot; data-original-height=&quot;536&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;45600&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;第一个红框：做是否能够添加工作线程条件过滤：&lt;/p&gt;
&lt;p&gt;判断线程池的状态，如果线程池的状态值大于或等SHUTDOWN，则不处理提交的任务，直接返回；&lt;/p&gt;
&lt;p&gt;第二个红框：做自旋，更新创建线程数量：&lt;/p&gt;
&lt;p&gt;通过参数core判断当前需要创建的线程是否为核心线程，如果core为true，且当前线程数小于corePoolSize，则跳出循环，开始创建新的线程&lt;/p&gt;
&lt;p&gt;有人或许会疑问 retry 是什么？这个是java中的goto语法。只能运用在break和continue后面。&lt;/p&gt;
&lt;p&gt;接着看后面的代码：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1080&quot; data-height=&quot;751&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-730e90e8f79ff078?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-730e90e8f79ff078&quot; data-original-width=&quot;1080&quot; data-original-height=&quot;751&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;48837&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;第一个红框：获取线程池主锁。&lt;/p&gt;
&lt;p&gt;线程池的工作线程通过Woker类实现，通过ReentrantLock锁保证线程安全。&lt;/p&gt;
&lt;p&gt;第二个红框：添加线程到workers中（线程池中）。&lt;/p&gt;
&lt;p&gt;第三个红框：启动新建的线程。&lt;/p&gt;
&lt;p&gt;接下来，我们看看workers是什么。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;762&quot; data-height=&quot;181&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-ef25a17a59fad713?imageMogr2/auto-orient/strip%7CimageView2/2/w/762/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-ef25a17a59fad713&quot; data-original-width=&quot;762&quot; data-original-height=&quot;181&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;5425&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;一个hashSet。所以，线程池底层的存储结构其实就是一个HashSet。&lt;/p&gt;


&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1080&quot; data-height=&quot;766&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-6ca82710ef49cd27?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-6ca82710ef49cd27&quot; data-original-width=&quot;1080&quot; data-original-height=&quot;766&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;58959&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;第一个红框：是否是第一次执行任务，或者从队列中可以获取到任务。&lt;/p&gt;
&lt;p&gt;第二个红框：获取到任务后，执行任务开始前操作钩子。&lt;/p&gt;
&lt;p&gt;第三个红框：执行任务。&lt;/p&gt;
&lt;p&gt;第四个红框：执行任务后钩子。&lt;/p&gt;
&lt;p&gt;这两个钩子（beforeExecute，afterExecute）允许我们自己继承线程池，做任务执行前后处理。&lt;/p&gt;
&lt;p&gt;到这里，源代码分析到此为止。接下来做一下简单的总结。&lt;/p&gt;

&lt;p&gt;所谓线程池本质是一个hashSet。多余的任务会放在阻塞队列中。&lt;/p&gt;
&lt;p&gt;只有当阻塞队列满了后，才会触发非核心线程的创建。所以非核心线程只是临时过来打杂的。直到空闲了，然后自己关闭了。&lt;/p&gt;
&lt;p&gt;线程池提供了两个钩子（beforeExecute，afterExecute）给我们，我们继承线程池，在执行任务前后做一些事情。&lt;/p&gt;
&lt;p&gt;线程池原理关键技术：锁（lock,cas）、阻塞队列、hashSet（资源池）&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;820&quot; data-height=&quot;425&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-81e0c42e5e41804b?imageMogr2/auto-orient/strip%7CimageView2/2/w/820/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-81e0c42e5e41804b&quot; data-original-width=&quot;820&quot; data-original-height=&quot;425&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;27757&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;最后希望对你理解线程池有帮助。最后，留一个思考题，为什么线程池的底层数据接口采用HashSet来实现？&lt;/p&gt;

</description>
<pubDate>Thu, 11 Oct 2018 07:25:00 +0000</pubDate>
<dc:creator>Java修炼记</dc:creator>
<og:description>程序的运行，其本质上，是对系统资源（CPU、内存、磁盘、网络等等）的使用。如何高效的使用这些资源是我们编程优化演进的一个方向。今天说的线程池就是一种对CPU利用的优化手段。 网上有不少介绍如何使用线程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Javaba/p/9772648.html</dc:identifier>
</item>
<item>
<title>java中对JVM的深度解析、调优工具、垃圾回收 - 四季写爱</title>
<link>http://www.cnblogs.com/ya-qiang/p/9772507.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ya-qiang/p/9772507.html</guid>
<description>&lt;h2&gt;jdk自带的JVM调优工具&lt;/h2&gt;
&lt;p&gt;jvm监控分析工具一般分为两类，一种是jdk自带的工具，一种是第三方的分析工具。jdk自带工具一般在jdk bin目录下面，以exe的形式直接点击就可以使用，其中包含分析工具已经很强大，几乎涉及了方方面面，但是我们最常使用的只有两款：jconsole.exe和jvisualvm.exe；第三方的分析工具有很多，各自的侧重点不同，比较有代表性的：MAT(Memory Analyzer Tool)、GChisto等。&lt;/p&gt;
&lt;h3 id=&quot;jconsole&quot;&gt;jconsole&lt;/h3&gt;
&lt;p&gt;Jconsole（Java Monitoring and Management Console）是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控，是一个基于JMX（java management extensions）的GUI性能监测工具。jconsole使用jvm的扩展机制获取并展示虚拟机中运行的应用程序的性能和资源消耗等信息。&lt;/p&gt;
&lt;p&gt;直接在jdk/bin目录下点击jconsole.exe即可启动，界面如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/2017/jvm/jconsole01.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在弹出的框中可以选择本机的监控本机的java应用，也可以选择远程的java服务来监控，如果监控远程服务需要在tomcat启动脚本中添加如下代码：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_914371&quot; class=&quot;syntaxhighlighter notranslate text&quot; readability=&quot;31.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
-Dcom.sun.management.jmxremote.port=6969 
-Dcom.sun.management.jmxremote.ssl=&lt;span&gt;false&lt;/span&gt; 
-Dcom.sun.management.jmxremote.authenticate=&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;连接进去之后，就可以看到jconsole概览图和主要的功能：概述、内存、线程、类、VM、MBeans&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;概述，以图表的方式显示出堆内存使用量，活动线程数，已加载的类，CUP占用率的折线图，可以非常清晰的观察在程序执行过程中的变动情况。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/2017/jvm/jconsole02.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内存，主要展示了内存的使用情况，同时可以查看堆和非堆内存的变化值对比，也可以点击执行GC来处罚GC的执行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/2017/jvm/jconsole03.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线程，主界面展示线程数的活动数和峰值，同时点击左下方线程可以查看线程的详细信息，比如线程的状态是什么，堆栈内容等，同时也可以点击“检测死锁”来检查线程之间是否有死锁的情况。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/2017/jvm/jconsole04.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类，主要展示已加载类的相关信息。&lt;/li&gt;
&lt;li&gt;VM 概要，展示JVM所有信息总览，包括基本信息、线程相关、堆相关、操作系统、VM参数等。&lt;/li&gt;
&lt;li&gt;Mbean,查看Mbean的属性，方法等。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;visualvm&quot;&gt;VisualVM&lt;/h3&gt;
&lt;p&gt;简介&lt;/p&gt;
&lt;p&gt;VisualVM 是一个工具，它提供了一个可视界面，用于查看 Java 虚拟机 (Java Virtual Machine, JVM) 上运行的基于 Java 技术的应用程序（Java 应用程序）的详细信息。VisualVM 对 Java Development Kit (JDK) 工具所检索的 JVM 软件相关数据进行组织，并通过一种使您可以快速查看有关多个 Java 应用程序的数据的方式提供该信息。您可以查看本地应用程序以及远程主机上运行的应用程序的相关数据。此外，还可以捕获有关 JVM 软件实例的数据，并将该数据保存到本地系统，以供后期查看或与其他用户共享。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://www.ityouknow.com/assets/images/2017/jvm/jvisualvm.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;VisualVM 是javajdk自带的最牛逼的调优工具了吧，也是我平时使用最多调优工具，几乎涉及了jvm调优的方方面面。同样是在jdk/bin目录下面双击jvisualvm.exe既可使用，启动起来后和jconsole 一样同样可以选择本地和远程，如果需要监控远程同样需要配置相关参数，主界面如下；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1256944/201810/1256944-20181011145509494-1106256769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;VisualVM可以根据需要安装不同的插件，每个插件的关注点都不同，有的主要监控GC，有的主要监控内存，有的监控线程等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1256944/201810/1256944-20181011145549161-1226036932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如何安装：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;1、从主菜单中选择“工具”&amp;gt;“插件”。&lt;br/&gt;2、在“可用插件”标签中，选中该插件的“安装”复选框。单击“安装”。&lt;br/&gt;3、逐步完成插件安装程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;大家可能在这里会遇到安装不了的坑！！！！&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;解决：首先用浏览器浏览：&lt;a href=&quot;https://visualvm.github.io/pluginscenters.html&quot; target=&quot;_blank&quot;&gt;https://visualvm.github.io/pluginscenters.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1256944/201810/1256944-20181011150535305-1444296654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其次从中找到自己的版本，我的是jdk1.8版本，我选择了第二个，复制它的地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1256944/201810/1256944-20181011150633982-1435579932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复制地址到上面的url中，就可以去查看可用插件进行下载了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里以IntelliJ Platform (pid 15784)为例，双击后直接展开，主界面展示了系统和jvm两大块内容，点击右下方jvm参数和系统属性可以参考详细的参数信息.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1256944/201810/1256944-20181011145728763-1724999378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为VisualVM的插件太多，我这里主要介绍三个我主要使用几个：监控、线程、Visual GC&lt;/p&gt;
&lt;p&gt;监控的主页其实也就是，cpu、内存、类、线程的图表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1256944/201810/1256944-20181011145808697-507062317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;线程和jconsole功能没有太大的区别&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1256944/201810/1256944-20181011145858497-116062092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Visual GC 是常常使用的一个功能，可以明显的看到年轻代、老年代的内存变化，以及gc频率、gc的时间等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1256944/201810/1256944-20181011150100329-126702406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上的功能其实jconsole几乎也有，VisualVM更全面更直观一些，另外VisualVM非常多的其它功能，可以分析dump的内存快照，dump出来的线程快照并且进行分析等，还有其它很多的插件大家可以去探索&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/2017/jvm/jvisualvm07.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;JVM垃圾回收&lt;/h2&gt;
&lt;p&gt;JVM的新生代分为三个区域，一个Eden区和两个Survivor区，它们之间的比例为（8：1：1），这个比例也是可以修改的。通常情况下，对象主要分配在新生代的Eden区上，少数情况下也可能会直接分配在老年代中。Java虚拟机每次使用新生代中的Eden和其中一块Survivor（From），在经过一次Minor GC后，将Eden和Survivor中还存活的对象一次性地复制到另一块Survivor空间上（这里使用的复制算法进行GC），最后清理掉Eden和刚才用过的Survivor（From）空间。将此时在Survivor空间存活下来的对象的年龄设置为1，以后这些对象每在Survivor区熬过一次GC，它们的年龄就加1，当对象年龄达到某个年龄（默认值为15）时，就会把它们移到老年代中。&lt;/p&gt;
&lt;p&gt;在新生代中进行GC时，有可能遇到另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代；&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;bjh-p&quot;&gt;1. 新生代(Young Generation)：也有叫做年轻代的，这里使用《深入理解JAVA虚拟机》中的叫法，下同。&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;其实看名称就能看出一些，一般情况下，新创建的对象都会存放到新生代中(大对象除外)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;新生代中对象的特点是：很快就会被GC回收掉的或者不是特别大的对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;为了方便垃圾收集，新生代又分出了一个Eden区，两个 Survivor区。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;JVM 每次只会使用 Eden区 和其中的一块 Survivor 区域来为对象服务，另一块Survivor区域是空的，用于垃圾回收。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;举个例子，第一次回收的时候，虚拟机会将 Eden区+Survivor（from）区域的存活对象复制到Survivor（to）上（存活对象小于Survivor（to）的空间），清空Survivor（from），虚拟机使用Eden区+Survivor（to）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;第二次回收的时候，虚拟机再将Eden区+Survivor（to）存活的对象复制到Survivor（from）。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;img-container&quot;&gt;&lt;img class=&quot;large&quot; src=&quot;https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=514516254,395710132&amp;amp;fm=173&amp;amp;app=25&amp;amp;f=JPEG?w=639&amp;amp;h=236&amp;amp;s=E5D2377687F84C295C7DC0FE02005070&quot; alt=&quot;&quot; data-loadfunc=&quot;0&quot; data-loaded=&quot;0&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;这三个区域默认情况下是按照8：1：1分配，也可以手动配置。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;bjh-p&quot;&gt;2. Eden区&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;  Eden区位于Java堆的新生代，是新对象分配内存的地方，由于堆是所有线程共享的，因此在堆上分配内存需要加锁。而Sun JDK为提升效率，会为每个新建的线程在Eden上分配一块独立的空间由该线程独享，这块空间称为TLAB（Thread Local Allocation Buffer）。在TLAB上分配内存不需要加锁，因此JVM在给线程中的对象分配内存时会尽量在TLAB上分配。如果对象过大或TLAB用完，则仍然在堆上进行分配。如果Eden区内存也用完了，则会进行一次Minor GC（young GC）。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;bjh-p&quot;&gt;3.Survival from to&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt; Survival区与Eden区相同都在Java堆的年轻代。Survival区有两块，一块称为from区，另一块为to区，这两个区是相对的，在发生一次Minor GC后，from区就会和to区互换。在发生Minor GC时，Eden区和Survivalfrom区会把一些仍然存活的对象复制进Survival to区，并清除内存。Survival to区会把一些存活得足够旧的对象移至年老代。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;bjh-p&quot;&gt;4. 老年代（Old Generation）：在新生代每进行一次垃圾收集后，就会给存活的对象“加1岁”，当年龄达到一定数量的时候就会进入老年代（默认是15,可以通过-XX：MaxTenuringThreshold来设置）。&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;另外，比较大的对象也会进入老年代，可以-XX：PretenureSizeThreshold进行设置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;如-XX：PretenureSizeThreshold3M，那么大于3M的对象就会直接就进入老年代。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;因此，老年代中存放的都是一些生命周期较长的对象或者特别大的对象。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;bjh-p&quot;&gt;5. 永久代（Permanent Generation ）：即JVM的方法区。在这里存放着一些被虚拟机加载的类信息（别忘了还有动态生成的类）的静态文件，这就导致了这个区中的东西比老年代和新生代更不容易回收。&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;永久代大小通过-XX:MaxPermSize=&amp;lt;N&amp;gt;进行设置。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;bjh-p&quot;&gt;6. 元空间（Metaspace）：从JDK 8开始，Java开始使用元空间取代永久代，元空间并不在虚拟机中，而是直接使用本地内存。&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;那么，默认情况下，元空间的大小仅受本地内存限制。当然，也可以对元空间的大小手动的配置。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;bjh-p&quot;&gt;JVM常见的垃圾回收机制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span class=&quot;bjh-p&quot;&gt;Minor GC&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;Minor GC指新生代GC，即发生在新生代（包括Eden区和Survivor区）的垃圾回收操作，当新生代无法为新生对象分配内存空间的时候，会触发Minor GC。因为新生代中大多数对象的生命周期都很短，所以发生Minor GC的频率很高，虽然它会触发stop-the-world，但是它的回收速度很快。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;bjh-p&quot;&gt;Major GC&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;Major GC清理Tenured区，用于回收老年代，出现Major GC通常会出现至少一次Minor GC。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;bjh-p&quot;&gt;Full GC&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;Full GC是针对整个新生代、老生代、元空间（metaspace，java8以上版本取代perm gen）的全局范围的GC。Full GC不等于Major GC，也不等于Minor GC+Major GC，发生Full GC需要看使用了什么垃圾收集器组合，才能解释是什么样的垃圾回收。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;bjh-p&quot;&gt;复制算法：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;将区域分成两部分，其中一部分作为保留空间，另一部分作为使用空间、当发生&lt;a class=&quot;baidu-highlight&quot; href=&quot;https://www.baidu.com/s?wd=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6&amp;amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;amp;rsv_dl=gh_pc_zhidao&quot; target=&quot;_blank&quot;&gt;垃圾回收&lt;/a&gt;时，首先检查使用空间里有哪些对象是存活的，检查完之后把存活的对象复制到保留空间（这样复制过来的好处是减少了内存碎片，如果直接在使用空间清除的话，那空间会很零散）里，然后清洗使用空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;bjh-p&quot;&gt;Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历（默认）15次Minor GC还能在新生代中存活的对象，才会被送到老年代。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-为什么要设置两个survivor区&quot;&gt;为什么要设置两个Survivor区&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;设置两个Survivor区最大的好处就是解决了碎片化&lt;/em&gt;，下面我们来分析一下。&lt;/p&gt;
&lt;p&gt;为什么一个Survivor区不行？第一部分中，我们知道了必须设置Survivor区。假设现在只有一个survivor区，我们来模拟一下流程： &lt;br/&gt;刚刚新建的对象在Eden中，一旦Eden满了，触发一次Minor GC，Eden中的存活对象就会被移动到Survivor区。这样继续循环下去，下一次Eden满了的时候，问题来了，此时进行Minor GC，Eden和Survivor各有一些存活对象，如果此时把Eden区的存活对象硬放到Survivor区，很明显这两部分对象所占有的内存是不连续的，也就导致了内存碎片化。 &lt;br/&gt;我绘制了一幅图来表明这个过程。其中色块代表对象，白色框分别代表Eden区（大）和Survivor区（小）。Eden区理所当然大一些，否则新建对象很快就导致Eden区满，进而触发Minor GC，有悖于初衷。 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20160516173704870&quot; alt=&quot;一个Survivor区带来碎片化&quot;/&gt;&lt;/p&gt;
&lt;p&gt;碎片化带来的风险是极大的，严重影响JAVA程序的性能。堆空间被散布的对象占据不连续的内存，最直接的结果就是，堆中没有足够大的连续内存空间，接下去如果程序需要给一个内存需求很大的对象分配内存。。。画面太美不敢看。。。这就好比我们爬山的时候，背包里所有东西紧挨着放，最后就可能省出一块完整的空间放相机。如果每件行李之间隔一点空隙乱放，很可能最后就要一路把相机挂在脖子上了。&lt;/p&gt;
&lt;p&gt;那么，顺理成章的，应该建立两块Survivor区，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）。S0和Eden被清空，然后下一轮S0与S1交换角色，如此循环往复。如果对象的复制次数达到16次，该对象就会被送到老年代中。下图中每部分的意义和上一张图一样，就不加注释了。 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20160516174938778&quot; alt=&quot;两块Survivor避免碎片化&quot;/&gt; &lt;br/&gt;上述机制最大的好处就是，整个过程中，永远有一个survivor space是空的，另一个非空的survivor space无碎片。&lt;/p&gt;
&lt;p&gt;那么，Survivor为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果Survivor区再细分下去，每一块的空间就会比较小，很容易导致Survivor区满，因此，两块Survivor区是经过权衡之后的最佳方案。&lt;/p&gt;
</description>
<pubDate>Thu, 11 Oct 2018 07:08:00 +0000</pubDate>
<dc:creator>四季写爱</dc:creator>
<og:description>jdk自带的JVM调优工具 jvm监控分析工具一般分为两类，一种是jdk自带的工具，一种是第三方的分析工具。jdk自带工具一般在jdk bin目录下面，以exe的形式直接点击就可以使用，其中包含分析工</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ya-qiang/p/9772507.html</dc:identifier>
</item>
<item>
<title>QA系统Match-LSTM代码研读 - 苦力笨笨</title>
<link>http://www.cnblogs.com/terencezhou/p/9772451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/terencezhou/p/9772451.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;在QA模型中，&lt;a href=&quot;https://arxiv.org/abs/1608.07905&quot;&gt;Match-LSTM&lt;/a&gt;是较早提出的，使用Prt-Net边界模型。本文是对阅读其实现代码的总结。主要思路是对照着论文和代码，对论文中模型的关键结构，查看代码中的具体实现。参考代码是&lt;a href=&quot;https://github.com/MurtyShikhar/Question-Answering&quot;&gt;MurtyShikhar实现的&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;模型简介&quot;&gt;模型简介&lt;/h2&gt;
&lt;p&gt;模型的输入是(Passage, Question)，模型的输出是(start_idx, end_idx)。对于输入，Passage是QA任务中的正文，输入给模型时已经转化为经过Padding的id-list；Question是QA任务中的问题，输入给模型时已经转化为经过Padding的id-list。对于输出，start_idx是答案在正文的起始位置，end_idx是答案在正文的结束位置。&lt;/p&gt;
&lt;p&gt;用于QA的Match-LSTM模型主要由三层构成：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;LSTM预处理层。&lt;br/&gt;分别将Passage和Question通过LSTM进行处理，使每个位置的表示都带有一些上下文信息。&lt;/li&gt;
&lt;li&gt;Match-LSTM层。&lt;br/&gt;Match-LSTM最早用于文本蕴含，输入一个前提，一个猜测，判断前提是否能蕴含猜测。在用于QA任务时，Question被当做前提，Passage被当做猜测。依次处理Passage的每个位置，计算Passage每个位置对Question的Attention，进而求出对Question的Attend Vector。该Attend Vector与第一层的输出拼接起来，输入给一个LSTM进行处理，这整个流程被称作Match-LSTM。&lt;br/&gt;其中Attention选择BahdanauAttention，Attention的输入（Query）由上一时刻Match-LSTM的输出及Passage在当前位置的表示拼接，Attention的key是Question每个位置的表示，Attention的value也是Question每个位置的表示。根据Attention的alignment对Attention Value加权求和计算出Attend Vector。&lt;br/&gt;所以，Match-LSTM本质上由一个LSTM单元和一个Attention单元组成。LSTM单元的输出作为Match-LSTM层的输出，LSTM单元的状态和下一个位置的输入拼接起来作为Attention单元的输入（Query），Attention单元的输出（Attend Vector）与当前位置的输入拼接起来作为LSTM单元的输入。也可以理解为在LSTM的基础上增加Attention，改变LSTM的输入，在LSTM的原始输入上增加当前位置对于Question的Attention。&lt;/li&gt;
&lt;li&gt;Pointer-Net层。&lt;br/&gt;Pointer-Net层在代码实现上，与Match-LSTM十分接近。只在涉及输入、输出的地方有几处不同。从原理上看，Pointer-Net层也是一个序列化迭代的Attention过程，首先用zero_state作为query对Match-LSTM层的所有输出计算attention，作为回答第一个符号的logit。然后以AttentionWrapper的输出作为下一时刻的query，对Match-LSTM层的所有输出计算attention，如此迭代进行。对于边界模型，秩序计算start_index和end_index，这个迭代过程秩序进行两次。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;接下来的几部分对照论文及代码中模型关键结构实现。&lt;/p&gt;
&lt;h2 id=&quot;模型&quot;&gt;模型&lt;/h2&gt;
&lt;p&gt;模型图构建的入口在qa_model.py文件中&lt;code&gt;class QASystem&lt;/code&gt;类的&lt;code&gt;def setup_system(self)&lt;/code&gt;方法内。这一节主要就是对该方法的细节展开解读。&lt;/p&gt;
&lt;h3 id=&quot;lstm预处理层&quot;&gt;LSTM预处理层&lt;/h3&gt;
&lt;p&gt;所有逻辑都包含在qa_model.py文件中，入口位于&lt;code&gt;class QASystem&lt;/code&gt;类的&lt;code&gt;def setup_system(self)&lt;/code&gt;方法内，具体逻辑位于&lt;code&gt;class Encoder&lt;/code&gt;的&lt;code&gt;def encode(self, inputs, masks, encoder_state_input = None)&lt;/code&gt;方法内。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;def setup_system(self)&lt;/code&gt;方法内，通过以下语句调用&lt;code&gt;class Encoder&lt;/code&gt;的&lt;code&gt;def encode(self, inputs, masks, encoder_state_input = None)&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;encoder = self.encoder
decoder = self.decoder
encoded_question, encoded_passage, q_rep, p_rep = encoder.encode([self.question, self.passage],
                 [self.question_lengths, self.passage_lengths], encoder_state_input = None)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再看一下&lt;code&gt;encode&lt;/code&gt;方法的实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def encode(self, inputs, masks, encoder_state_input = None):
    &quot;&quot;&quot;
    :param inputs: vector representations of question and passage (a tuple) 
    :param masks: masking sequences for both question and passage (a tuple)
    :param encoder_state_input: (Optional) pass this as initial hidden state to tf.nn.dynamic_rnn to build conditional representations
    :return: an encoded representation of the question and passage.
    &quot;&quot;&quot;
    
    question, passage = inputs
    masks_question, masks_passage = masks

    # read passage conditioned upon the question
    with tf.variable_scope(&quot;encoded_question&quot;):
        lstm_cell_question = tf.contrib.rnn.BasicLSTMCell(self.hidden_size, state_is_tuple = True)
        encoded_question, (q_rep, _) = tf.nn.dynamic_rnn(lstm_cell_question, question, masks_question, dtype=tf.float32) # (-1, 
Q, H)

    with tf.variable_scope(&quot;encoded_passage&quot;):
        lstm_cell_passage  = tf.contrib.rnn.BasicLSTMCell(self.hidden_size, state_is_tuple = True)
        encoded_passage, (p_rep, _) =  tf.nn.dynamic_rnn(lstm_cell_passage, passage, masks_passage, dtype=tf.float32) # (-1, P, 
H)
    # outputs beyond sequence lengths are masked with 0s
    return encoded_question, encoded_passage , q_rep, p_rep&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码可以看出，对Passage和Question的预处理就是分别经过两个单向LSTM层（不共享参数），LSTM每个位置的输出作为预处理后的表示。&lt;/p&gt;
&lt;h3 id=&quot;match-lstm层&quot;&gt;Match-LSTM层&lt;/h3&gt;
&lt;p&gt;Match-LSTM的逻辑主要在qa_model.py和attention_wrapper.py两个文件中。虽然tensorflow的contrib库中现在也有attention_wrapper这个模块，但是两者在具体实现上不太相同。入口位于qa_model.py文件&lt;code&gt;class Decoder&lt;/code&gt;类中&lt;code&gt;decode&lt;/code&gt;方法内。&lt;/p&gt;
&lt;p&gt;首先，看一下最外层的入口，与LSTM预处理层一样，位于&lt;code&gt;class QASystem&lt;/code&gt;类的&lt;code&gt;def setup_system(self)&lt;/code&gt;方法内。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if self.config.use_match:
    self.logger.info(&quot;\n========Using Match LSTM=========\n&quot;)
    logits= decoder.decode([encoded_question, encoded_passage], q_rep, [self.question_lengths, self.passage_lengths], self.
labels)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，进入&lt;code&gt;class Decoder&lt;/code&gt;类中&lt;code&gt;decode&lt;/code&gt;方法。函数逻辑非常清晰，先通过Match-LSTM层，再通过Ptr-Net层。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def decode(self, encoded_rep, q_rep, masks, labels):
    output_attender = self.run_match_lstm(encoded_rep, masks)
    logits = self.run_answer_ptr(output_attender, masks, labels)

    return logits&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后进入&lt;code&gt;run_match_lstm&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def run_match_lstm(self, encoded_rep, masks):
    encoded_question, encoded_passage = encoded_rep
    masks_question, masks_passage = masks

    match_lstm_cell_attention_fn = lambda curr_input, state : tf.concat([curr_input, state], axis = -1)
    query_depth = encoded_question.get_shape()[-1]


    # output attention is false because we want to output the cell output and not the attention values
    with tf.variable_scope(&quot;match_lstm_attender&quot;):
        attention_mechanism_match_lstm = BahdanauAttention(query_depth, encoded_question, memory_sequence_length = masks_question)
        cell = tf.contrib.rnn.BasicLSTMCell(self.hidden_size, state_is_tuple = True)
        lstm_attender  = AttentionWrapper(cell, attention_mechanism_match_lstm, output_attention = False, attention_input_fn = match_lstm_cell_attention_fn)

        # we don't mask the passage because masking the memories will be handled by the pointerNet
        reverse_encoded_passage = _reverse(encoded_passage, masks_passage, 1, 0)

        output_attender_fw, _ = tf.nn.dynamic_rnn(lstm_attender, encoded_passage, dtype=tf.float32, scope =&quot;rnn&quot;)
        output_attender_bw, _ = tf.nn.dynamic_rnn(lstm_attender, reverse_encoded_passage, dtype=tf.float32, scope = &quot;rnn&quot;)

        output_attender_bw = _reverse(output_attender_bw, masks_passage, 1, 0)


    output_attender = tf.concat([output_attender_fw, output_attender_bw], axis = -1) # (-1, P, 2*H)
    return output_attender&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;65&quot;&gt;
&lt;p&gt;该方法的输入&lt;code&gt;encoded_rep&lt;/code&gt;是一个&lt;code&gt;tuple&lt;/code&gt;，包含Passage和Question的表示；&lt;code&gt;masks&lt;/code&gt;也是一个&lt;code&gt;tuple&lt;/code&gt;，包含Passage和Question的长度。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;match_lstm_cell_attention_fn = lambda curr_input, state : tf.concat([curr_input, state], axis = -1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这条语句定义了&lt;code&gt;Match-LSTM&lt;/code&gt;单元中&lt;code&gt;AttentionMechanism&lt;/code&gt;的输入函数，作为参数该函数被传递给&lt;code&gt;AttentionWrapper&lt;/code&gt;的构造函数，作为&lt;code&gt;attention_input_fn&lt;/code&gt;。&lt;code&gt;AttentionWrapper&lt;/code&gt;本身也是一个&lt;code&gt;RNN&lt;/code&gt;，它组合了一个&lt;code&gt;RNN&lt;/code&gt;和一个&lt;code&gt;AttentionMechanism&lt;/code&gt;，形成一个高级的&lt;code&gt;RNN&lt;/code&gt;单元。该函数就是定义了用于Attention机制的Query是如何生成的，由当前时刻的输入拼接上一个时刻的state，形成Attention的Query。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;attention_mechanism_match_lstm = BahdanauAttention(query_depth, encoded_question, memory_sequence_length = masks_question)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这条语句定义了一个&lt;code&gt;AttentionMechanism&lt;/code&gt;，也就是一个Attention单元，该类包含一个&lt;code&gt;__call__&lt;/code&gt;方法，调用该对象可以计算出&lt;code&gt;alignments&lt;/code&gt;，调用该类对象的参数如方法定义所示&lt;code&gt;def __call__(self, query, previous_alignments)&lt;/code&gt;。联系上面一起来看，这里的&lt;code&gt;query&lt;/code&gt;就是上面所说的Attention的Query。&lt;br/&gt;至于&lt;code&gt;BahdanauAttention&lt;/code&gt;是如何实现的，暂时不做过详细的介绍，目前该类位于&lt;code&gt;tf.contrib.seq2seq.BahdanauAttention&lt;/code&gt;，已经是tensorflow库的一部分。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cell = tf.contrib.rnn.BasicLSTMCell(self.hidden_size, state_is_tuple = True)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这条语句定义一个普通的LSTM单元。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;lstm_attender  = AttentionWrapper(cell, attention_mechanism_match_lstm, output_attention = False, attention_input_fn = match_lstm_cell_attention_fn)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这条语句将上面两步定义的&lt;code&gt;AttentionMechanism&lt;/code&gt;及LSTM单元组装为一个高级RNN单元。参数还包括了在&lt;code&gt;run_match_lstm&lt;/code&gt;方法一开头顶一个的一个函数，该函数用来生成&lt;code&gt;AttentionMechanism&lt;/code&gt;的&lt;code&gt;query&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;reverse_encoded_passage = _reverse(encoded_passage, masks_passage, 1, 0)
output_attender_fw, _ = tf.nn.dynamic_rnn(lstm_attender, encoded_passage, dtype=tf.float32, scope =&quot;rnn&quot;)
output_attender_bw, _ = tf.nn.dynamic_rnn(lstm_attender, reverse_encoded_passage, dtype=tf.float32, scope = &quot;rnn&quot;)
output_attender_bw = _reverse(output_attender_bw, masks_passage, 1, 0)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分别正向、反向对Passage的表示应用Match-LSTM，再将输出沿最后一个维度拼接起来作为Match-LSTM层的输出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们还可以再近距离看一下LSTM单元和&lt;code&gt;AttentionMechanism&lt;/code&gt;是如何配合工作的，这需要深入到&lt;code&gt;AttentionWrapper&lt;/code&gt;的&lt;code&gt;call&lt;/code&gt;方法，这也是所有RNN单元都需要实现的一个方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def call(self, inputs, state):
    output_prev_step = state.cell_state.h # get hr_(i-1)
    attention_input = self._attention_input_fn(inputs, output_prev_step) # get input to BahdanauAttention to get alpha_i
    alignments, raw_scores = self._attention_mechanism(
        attention_input, previous_alignments=state.alignments)

    expanded_alignments = array_ops.expand_dims(alignments, 1)

    attention_mechanism_values = self._attention_mechanism.values
    context = math_ops.matmul(expanded_alignments, attention_mechanism_values)
    context = array_ops.squeeze(context, [1])


    cell_inputs = self._cell_input_fn(inputs, context) #concatenate input with alpha*memory and feed into root LSTM
    cell_state = state.cell_state
    cell_output, next_cell_state = self._cell(cell_inputs, cell_state)

    if self._attention_layer is not None:
      attention = self._attention_layer(
          array_ops.concat([cell_output, context], 1))
    else:
      attention = context

    if self._alignment_history:
      alignment_history = state.alignment_history.write(
          state.time, alignments)
    else:
      alignment_history = ()

    next_state = AttentionWrapperState(
        time=state.time + 1,
        cell_state=next_cell_state,
        attention=attention,
        alignments=alignments,
        alignment_history=alignment_history)

    if self._output_attention:
      return raw_scores, next_state
    else:
      return cell_output, next_state&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;code&gt;output_prev_step = state.cell_state.h # get hr_(i-1)
attention_input = self._attention_input_fn(inputs, output_prev_step)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;取LSTM单元上一时刻的状态，与&lt;code&gt;AttentionWrapper&lt;/code&gt;当前时刻的输入，通过&lt;code&gt;self._attention_input_fn&lt;/code&gt;函数生成attention的Query。这里的&lt;code&gt;self._attention_input_fn&lt;/code&gt;就是上面&lt;code&gt;AttentionWrapper&lt;/code&gt;构造函数的参数&lt;code&gt;attention_input_fn&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alignments, raw_scores = self._attention_mechanism(attention_input, previous_alignments=state.alignments)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用&lt;code&gt;AttentionMechaism&lt;/code&gt;对象，计算Attention的alignments。这里的&lt;code&gt;self._attention_mechanism&lt;/code&gt;就是&lt;code&gt;AttentionWrapper&lt;/code&gt;构造函数的参数&lt;code&gt;attention_mechanism_match_lstm&lt;/code&gt;，也就是&lt;code&gt;BahdanauAttention&lt;/code&gt;的一个对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;expanded_alignments = array_ops.expand_dims(alignments, 1)       # [batch_size, 1, ques_size]
attention_mechanism_values = self._attention_mechanism.values   # [batch_size, ques_size, value_dims]
context = math_ops.matmul(expanded_alignments, attention_mechanism_values) # [batch_size, 1, value_dims]
context = array_ops.squeeze(context, [1])   # [batch_size, value_dims]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过alignments和attention的Values，计算attend vector，就是对values以alignments为权重求和。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cell_inputs = self._cell_input_fn(inputs, context) #concatenate input with alpha*memory and feed into root LSTM
cell_state = state.cell_state
cell_output, next_cell_state = self._cell(cell_inputs, cell_state)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;_cell_input_fn&lt;/code&gt;将当前时刻的输入，和attend vector组合起来，成为当前时刻LSTM的输入。然后调用LSTM单元计算当前时刻LSTM单元的输出和状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if self._attention_layer is not None:
   attention = self._attention_layer(
                     array_ops.concat([cell_output, context], 1))
else:
   attention = context&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是否需要对attend vector再进行一次线性变换，作为attention，在本例中未做变换，直接用attend vector作为attention。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;next_state = AttentionWrapperState(
      time=state.time + 1,
      cell_state=next_cell_state,
      attention=attention,
      alignments=alignments,
      alignment_history=alignment_history)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作为RNN的&lt;code&gt;AttentionWrapper&lt;/code&gt;的下一时刻状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if self._output_attention:
    return raw_scores, next_state
  else:
    return cell_output, next_state&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据构造函数的参数，决定&lt;code&gt;AttentionWrapper&lt;/code&gt;的输出是attention score还是LSTM的输出，attention score的意义是求alignments概率之前的那个东西。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;pointer-net层&quot;&gt;Pointer-Net层&lt;/h3&gt;
&lt;p&gt;以下代码是Pointer-Net层的逻辑，与Match-LSTM层的逻辑非常接近，但是在一些细节上有所区别。相似的部分是，Pointer-Net层的主体也是通过一个&lt;code&gt;AttentionWrapper&lt;/code&gt;完成的，也是组装了一个&lt;code&gt;LSTM&lt;/code&gt;单元和一个&lt;code&gt;BahdanauAttention&lt;/code&gt;单元。与Match-LSTM不同的地方是，&lt;code&gt;LSTM&lt;/code&gt;单元及&lt;code&gt;BahdanauAttention&lt;/code&gt;单元的输入函数不同，&lt;code&gt;AttentionWrapper&lt;/code&gt;的输出内容不同，并且Pointer-Net层使用一个静态rnn。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def run_answer_ptr(self, output_attender, masks, labels):
    batch_size = tf.shape(output_attender)[0]
    masks_question, masks_passage = masks
    labels = tf.unstack(labels, axis=1) 
    #labels = tf.ones([batch_size, 2, 1])


    answer_ptr_cell_input_fn = lambda curr_input, context : context # independent of question
    query_depth_answer_ptr = output_attender.get_shape()[-1]

    with tf.variable_scope(&quot;answer_ptr_attender&quot;):
        attention_mechanism_answer_ptr = BahdanauAttention(query_depth_answer_ptr , output_attender, memory_sequence_length = masks_passage)
        # output attention is true because we want to output the attention values
        cell_answer_ptr = tf.contrib.rnn.BasicLSTMCell(self.hidden_size, state_is_tuple = True )
        answer_ptr_attender = AttentionWrapper(cell_answer_ptr, attention_mechanism_answer_ptr, cell_input_fn = answer_ptr_cell_input_fn)
        logits, _ = tf.nn.static_rnn(answer_ptr_attender, labels, dtype = tf.float32)

        return logits &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来具体看一下上面这段代码。&lt;/p&gt;
&lt;blockquote readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;code&gt;batch_size = tf.shape(output_attender)[0]       # [batch_size, passage_length, 2 * hidden_size]
masks_question, masks_passage = masks
labels = tf.unstack(labels, axis=1)     # labels : [batch_size, 2]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;output_attender&lt;/code&gt;是上一层，也就是Match-LSTM层的输出，形状为&lt;code&gt;[batch_size, passage_length, 2 * hidden_size]&lt;/code&gt;。&lt;code&gt;labels&lt;/code&gt;的形状为&lt;code&gt;[batch_size, 2]&lt;/code&gt;。&lt;code&gt;masks_question&lt;/code&gt;和&lt;code&gt;masks_passage&lt;/code&gt;分别为问题的长度和文章的长度。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;answer_ptr_cell_input_fn = lambda curr_input, context : context # independent of question
query_depth_answer_ptr = output_attender.get_shape()[-1]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;answer_ptr_cell_input_fn&lt;/code&gt;定义了&lt;code&gt;AttentionWrapper&lt;/code&gt;中&lt;code&gt;LSTM&lt;/code&gt;单元的输入函数。&lt;code&gt;query_depth_answer_ptr&lt;/code&gt;从变量名的字面含义看，是Answer-Ptr层的attention单元的query的维度。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with tf.variable_scope(&quot;answer_ptr_attender&quot;):
   attention_mechanism_answer_ptr = BahdanauAttention(query_depth_answer_ptr , output_attender, memory_sequence_length = masks_passage)
   # output attention is true because we want to output the attention values
   cell_answer_ptr = tf.contrib.rnn.BasicLSTMCell(self.hidden_size, state_is_tuple = True )
   answer_ptr_attender = AttentionWrapper(cell_answer_ptr, attention_mechanism_answer_ptr, cell_input_fn = answer_ptr_cell_input_fn)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来是装配&lt;code&gt;AttentionWrapper&lt;/code&gt;，&lt;strong&gt;这里与Match-LSTM层有区别&lt;/strong&gt;。在Match-LSTM层的定义中，没有显式地为&lt;code&gt;AttentionWrapper&lt;/code&gt;指定&lt;code&gt;cell_input_fn&lt;/code&gt;参数，而是使用了默认函数。在Match-LSTM层的定义中，显式指定了&lt;code&gt;attention_input_fn&lt;/code&gt;，但是这里没有指定，使用了默认函数。另外一个区别，在Match-LSTM层的定义中，&lt;code&gt;AttentionWrapper&lt;/code&gt;的&lt;code&gt;output_attention&lt;/code&gt;参数是&lt;code&gt;False&lt;/code&gt;，在这里该参数用默认的&lt;code&gt;True&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对比Match-LSTM层与Pointer-Net层&lt;code&gt;cell_input_fn&lt;/code&gt;的区别。&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;默认的&lt;code&gt;cell_input_fn&lt;/code&gt;的定义如下，这是Match-LSTM层采用的。逻辑是将attention的输出和当前的输入拼接起来，作为&lt;code&gt;LSTM&lt;/code&gt;单元的输入。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if cell_input_fn is None:
   cell_input_fn = ( 
       lambda inputs, attention: array_ops.concat([inputs, attention], -1))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Pointer-Net层使用的&lt;code&gt;cell_input_fn&lt;/code&gt;在上面的代码中已经给出，这里对比一下。只用Attention单元的输出，作为&lt;code&gt;LSTM&lt;/code&gt;单元的输入。这样，&lt;code&gt;LSTM&lt;/code&gt;单元的输入，就与RNN的输入无关了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;answer_ptr_cell_input_fn = lambda curr_input, context : context # independent of question&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;对比Match-LSTM层与Pointer-Net层&lt;code&gt;attention_input_fn&lt;/code&gt;的区别。&lt;/p&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;Match-LSTM层采用的&lt;code&gt;attention_input_fn&lt;/code&gt;是非默认的，在上一节中已经给出，这里对比一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;match_lstm_cell_attention_fn = lambda curr_input, state : tf.concat([curr_input, state], axis = -1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Pointer-Net层的&lt;code&gt;attention_input_fn&lt;/code&gt;是默认的，定义如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if attention_input_fn is None:
   attention_input_fn = ( 
       lambda _, state: state)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，在Match-LSTM层，&lt;code&gt;attention&lt;/code&gt;单元的输入是上一时刻状态与当前输入的拼接。在Pointer-Net层，&lt;code&gt;attention&lt;/code&gt;单元的输入仅仅是上一时刻的状态，与当前时刻的输入无关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;综上两处，可以看出区别。在Match-LSTM层，无论&lt;code&gt;Attention&lt;/code&gt;单元还是&lt;code&gt;LSTM&lt;/code&gt;单元，其输入都要拼接当前时刻输入。而在Pointer-Net层，无论&lt;code&gt;Attention&lt;/code&gt;单元还是&lt;code&gt;LSTM&lt;/code&gt;单元，其输入都与当前时刻的输入无关。这也解释了我最早看代码时的疑惑，为什么计算&lt;code&gt;logits&lt;/code&gt;的函数需要&lt;code&gt;labels&lt;/code&gt;作为参数，&lt;code&gt;labels&lt;/code&gt;不是只有在计算&lt;code&gt;loss&lt;/code&gt;的时候才需要吗？其实虽然这里有&lt;code&gt;labels&lt;/code&gt;这个参数，但是没有实际使用其内容，对于预测过程，只需传一个同样形状的tensor就可以。&lt;/p&gt;
&lt;p&gt;再对比最后一个区别，Match-LSTM层与Pointer-Net层在output_attention参数上的区别。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code&gt;if self._output_attention:
    return raw_scores, next_state
else:
    return cell_output, next_state&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;raw_scores&lt;/code&gt;是&lt;code&gt;attention&lt;/code&gt;单元的原始输出，即通过&lt;code&gt;softmax&lt;/code&gt;计算&lt;code&gt;alignments&lt;/code&gt;前的那个输出。&lt;code&gt;cell_output&lt;/code&gt;是&lt;code&gt;LSTM&lt;/code&gt;单元的输出，也就是状态&lt;code&gt;h&lt;/code&gt;。在Match-LSTM层，&lt;code&gt;AttentionWrapper&lt;/code&gt;输出的是其内部&lt;code&gt;LSTM&lt;/code&gt;单元的输出。在Pointer-Net层，&lt;code&gt;AttentionWrapper&lt;/code&gt;输出的是其内部&lt;code&gt;attention&lt;/code&gt;单元的&lt;code&gt;raw_scores&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;pre&gt;
&lt;code&gt;logits, _ = tf.nn.static_rnn(answer_ptr_attender, labels, dtype = tf.float32)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后是计算&lt;code&gt;logits&lt;/code&gt;。因为&lt;code&gt;labels&lt;/code&gt;是个长度为2的&lt;code&gt;list&lt;/code&gt;，&lt;code&gt;logits&lt;/code&gt;也是长度为2的&lt;code&gt;list&lt;/code&gt;。但是，这两个&lt;code&gt;list&lt;/code&gt;中元素的&lt;code&gt;shape&lt;/code&gt;是不一样的，&lt;code&gt;labels&lt;/code&gt;中的元素的&lt;code&gt;shape&lt;/code&gt;是&lt;code&gt;[batch_size, 1]&lt;/code&gt;,&lt;code&gt;logits&lt;/code&gt;中的元素的&lt;code&gt;shape&lt;/code&gt;是&lt;code&gt;[batch_size, passage_length]&lt;/code&gt;。&lt;br/&gt;从代码层面来理解，首先是以&lt;code&gt;zero_state&lt;/code&gt;为query去计算attention，&lt;code&gt;attention&lt;/code&gt;单元的key和value都是Match-LSTM层的输出，&lt;code&gt;attention&lt;/code&gt;计算的&lt;code&gt;raw_score&lt;/code&gt;就是第一个输出的&lt;code&gt;logit&lt;/code&gt;。&lt;code&gt;attention&lt;/code&gt;计算出的&lt;code&gt;alignments&lt;/code&gt;与&lt;code&gt;values&lt;/code&gt;计算&lt;code&gt;attend vector&lt;/code&gt;，以其为输入计算&lt;code&gt;LSTM&lt;/code&gt;单元的输出，作为下一时刻的query去计算attention。这样，就计算出了两个&lt;code&gt;logits&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至此，计算出&lt;code&gt;logits&lt;/code&gt;，预测部分就已经完成了。&lt;code&gt;logits&lt;/code&gt;是一个长度为2的&lt;code&gt;list&lt;/code&gt;，其中每个元素是一个&lt;code&gt;shape&lt;/code&gt;为&lt;code&gt;[batch_size, passage_length]&lt;/code&gt;的tensor。&lt;/p&gt;
&lt;h3 id=&quot;损失函数&quot;&gt;损失函数&lt;/h3&gt;
&lt;p&gt;有了&lt;code&gt;logits&lt;/code&gt;，就可以计算损失函数了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;losses = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=self.logits[0], labels=self.labels[:,0])
losses += tf.nn.sparse_softmax_cross_entropy_with_logits(logits=self.logits[1], labels=self.labels[:,1])
self.loss = tf.reduce_mean(losses)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里只需要理解一个函数即可&lt;code&gt;tf.nn.sparse_softmax_cross_entropy_with_logits&lt;/code&gt;，该函数&lt;code&gt;logits&lt;/code&gt;参数的&lt;code&gt;rank&lt;/code&gt;比&lt;code&gt;labels&lt;/code&gt;多1，多出的那个&lt;code&gt;axis&lt;/code&gt;的维度是&lt;code&gt;num_classes&lt;/code&gt;。&lt;code&gt;labels&lt;/code&gt;以稀疏形式表示，每个元素都是整数，小于&lt;code&gt;num_classes&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;由于之前已经知道，Pointer-Net层求出&lt;code&gt;logits&lt;/code&gt;是一个&lt;code&gt;list&lt;/code&gt;，每个元素的形状是&lt;code&gt;[batch_size, passage_length]&lt;/code&gt;，而输入的&lt;code&gt;labels&lt;/code&gt;的形状是&lt;code&gt;[batch_size, 2]&lt;/code&gt;。因此按照上面代码的方式调用可求出损失函数。&lt;/p&gt;
</description>
<pubDate>Thu, 11 Oct 2018 07:00:00 +0000</pubDate>
<dc:creator>苦力笨笨</dc:creator>
<og:description>QA系统Match LSTM代码研读 背景 在QA模型中，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/terencezhou/p/9772451.html</dc:identifier>
</item>
<item>
<title>Linux入门实践笔记（一）--安装JDK与运行jar包 - 比脚更长的路</title>
<link>http://www.cnblogs.com/lonelyJay/p/9772246.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lonelyJay/p/9772246.html</guid>
<description>&lt;p&gt;&amp;#13;
                                    &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;×&lt;/span&gt;&lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt;&lt;/button&gt;&amp;#13;
                                    &lt;h4 class=&quot;modal-title&quot;&gt;&amp;#13;
                                        请完成人机识别验证&amp;#13;
                                    &lt;/h4&gt;&amp;#13;
                                &lt;/p&gt;
                                &lt;div class=&quot;modal-body&quot; readability=&quot;33&quot;&gt;
                                    
                                    &lt;p&gt;&amp;#13;
                                        &lt;span id=&quot;geetestLoading&quot;&gt; 验证码组件加载中,请稍后...&lt;/span&gt;&amp;#13;
                                    &lt;/p&gt;
                                &lt;/div&gt;
                            </description>
<pubDate>Thu, 11 Oct 2018 06:45:00 +0000</pubDate>
<dc:creator>比脚更长的路</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://passport.cnblogs.com/user/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2FlonelyJay%2Fp%2F9772246.html&amp;AspxAutoDetectCookieSupport=1</dc:identifier>
</item>
<item>
<title>你的专业知识并不等于你的能力——如何提升自我 - 雪雁</title>
<link>http://www.cnblogs.com/codelove/p/9772093.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codelove/p/9772093.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201810/70544-20181011140420429-115686047.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;我家东东上幼儿园了，看着他在幼儿园改变了很多，做父母的非常欣慰。但是也有些不快，甚至是感到惊讶。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从幼儿园开始，居然就有了作业，比如连续观察并记录月亮，画画等等，这让我非常不快。一方面，孩子正是天真烂漫无忧无虑的时候，他具备了许多能力，但是显然并不足以让他独自完成作业。另一方面，父母将孩子送到幼儿园，本就失去了很多自主的亲子时间，结果晚上还需陪孩子做一些&lt;/span&gt;“乱七八糟”的比我们小时候还烦的作业。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201810/70544-20181011140515591-179362197.gif&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;正是这种不快，促使我给幼儿园老师写下了如下的言语：&lt;/p&gt;
&lt;p&gt;张老师你好，打扰一下。关于小朋友的作业和教育这块，我有些不一样的看法。以后我家的作业我们想选择性的参与，我们并不想给孩子强行赋予某些能力、知识包括技能，我们更期望他在学前阶段只是开心玩乐，顺其自然，兴趣使然。比如本次的作业，我平常偶尔带他去看月亮星星，但是我并不希望灌输给他月有阴晴圆缺。我晚上经常陪他玩轨道火车，但是并不想告知他国庆节这些知识。家长的时间是有限的，这个阶段，我们更愿意陪他玩，讲故事，尊重他。曾经很长一段时间他并不喜欢和人打招呼，包括现在也有些不太情愿，甚至不够礼貌。我们也有焦虑，但是我们深知他并不内向，哪怕在外面经常会有失面子，但是我们除了言传身教之外，从没有强迫他一定做到。以上是我作为一个年轻父亲的肺腑之言，望理解。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201810/70544-20181011140559068-935988327.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;我之所以如此回复，很大的原因是来自于我成长过程中以及工作过程中的一些体会和感悟。奶粉厂商为了推销奶粉，于是母乳无用论甚嚣尘上；早教机构为了拉客户，于是有了不能让孩子输在起跑线上；特教学校为了招生，于是网瘾堪比毒瘾。我们的一生，被许多利益集团左右着，绑架着，被洗脑，被网瘾，被中产阶级，乃至被割韭菜。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201810/70544-20181011140659424-99107145.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们这一代，真是经历了太多太多，我们可以早上去碧桂园维权，中午去&lt;/span&gt;P2P&lt;span&gt;公司催债，下午对着惨不忍睹的股市流泪，晚上看着下跌的比特币骂娘，但是我们不希望他们如我们曾经的生活，我们也不希望再看到那些灰色又晦涩的名词——留守儿童、忙碌儿童、雷电法王、网瘾……。己所不欲勿施于人啊，何况面对的是我们的孩子。我们抚养他们长大，不求回报，但是我们希望他们记得父母的陪伴、关怀、尊重和理解，我们希望他们有一个精彩的童年，我们希望他们带着兴趣学习和成长，我们希望他们成为自己想成为的人！大树长成大树，小草长成小草，鲜花自由绽放！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201810/70544-20181011140714572-1961626082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生活不是你死我活的斗争，而是选择一种适合自己的存在方式。我们的一生可以是奋斗的一生，但是也希望水到渠成，开花结果。付出了努力，付出了时间，总是希望有所回报。我们花了许多时间学习知识和技巧，但是又很快忘记。我们的一生是有限的，我们渴望成功，但是我们的付出或者我们的资本真的用在刀刃上了吗？它们能提升我们的能力吗？能促进我们成功吗？戴尔&lt;/span&gt;·卡耐基说过，一个人的成功，只有&lt;span&gt;15%&lt;/span&gt;&lt;span&gt;归结于他的专业知识，另外的&lt;/span&gt;&lt;span&gt;85%&lt;/span&gt;&lt;span&gt;要归结于他的表达思想、领导他人及唤起他人热情的能力。也就是说，你就算掌握了足够的专业知识，并不代表你就拥有相关专业领域的能力，或者更强的综合能力。何况，这世界不比过去，发展的速度越来越快，信息量、知识量以几何倍的在翻番，而人类在浩瀚的知识海洋里明显脑子越来越不够用。哪怕你穷尽一生苦读苦学，也会存在大量的知识死角。那么，存在知识死角，是否就意味着无法解决相关的问题呢？是否能力就会受限呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201810/70544-20181011140729052-1551019095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我一直以技术专家自诩，我经常会碰到许多未知的问题，甚至都没有接触过的问题，但是我从来相信自己一定能解决。我也经常会接触到许多许多新技术，但是我从来相信自己就可以很快上手。因为，所谓专家，就是有些难点他没有接触过，甚至不知道它是什么，但是他一定能解决。而所谓优秀，是遇到问题有方法有手段来解决。知识只是工具，用之即学！我们的大脑不比硬盘，虽然容量同样有限，但是装的慢，忘得快。什么都装，忘记什么却无法主导或者选择，那么你的脑子里到底装了些什么？没有梳理，没有主导性有意识的封装，在你需要的时候不能为你所用，在你需要的时候你不能快速抓取，那么你的能力从何而来？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201810/70544-20181011140811903-433982302.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我从业以来，带过许多团队。敏捷开发一直是向往和追求的，其实本质上我觉得各行各业都一个鸟样，即以人为本。如果你有创新，你有想法，离开了优秀的合适的人才，那么简直就是缘木求鱼。因此，我非常侧重于培养人的思维、理念、沟通和表达能力，因为同样的问题，有些人可以举一反三提出多种解决方案，有的人却绞尽脑汁而一无所得。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201810/70544-20181011140836674-1567548570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们经常会谈到要自我充电，要自我提升，甚至要自我刷新，但是我们究竟要加强、提升些什么呢？在我看来，就是需要积累这些东西&lt;/span&gt;——思维、理念、沟通、表达能力和解决问题的经验。有道是，”腹有诗书气自华“，我想，这个气自华，不是来自于熟读唐诗三百首，而是来自于对诗书的理解，对人生、生活的感悟、思维和表达能力，只要到了这一境界，你才能真正的气自华，否则说的好听点，只能算是个“活”的书本，只是不用端着书念罢了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/70544/201810/70544-20181011140849239-1929223596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，借用王国维在《人间词话》中的几句话赠与各位。学习也好，专研也罢，首先得目标和方向明确&lt;/span&gt;——明确自己所追求的，感兴趣的，所迫切需要的，并且概览全局，做好长远奋斗打算，即“昨夜西风凋碧树，独上高楼，望尽天涯路。”。接下来，执着追求，废寝忘食，不达目的不罢休，即“ 衣带渐宽终不悔，为伊消得人憔悴。”这里我奉劝各位一句，做一行爱一行，如果带着兴趣，再苦再累有时都是甘之如饴，否则只能说是劣质勤奋、尸位素餐了。最后，专注、聚焦，反复实践、探索、追寻，直到豁然开朗，融会贯通，即“ 众里寻他千百度，蓦然回首，那人却在，灯火阑珊处。”&lt;/p&gt;
</description>
<pubDate>Thu, 11 Oct 2018 06:34:00 +0000</pubDate>
<dc:creator>雪雁</dc:creator>
<og:description>我家东东上幼儿园了，看着他在幼儿园改变了很多，做父母的非常欣慰。但是也有些不快，甚至是感到惊讶。 从幼儿园开始，居然就有了作业，比如连续观察并记录月亮，画画等等，这让我非常不快。一方面，孩子正是天真烂</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codelove/p/9772093.html</dc:identifier>
</item>
</channel>
</rss>