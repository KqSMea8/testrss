<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>再次实践 MySQL chart - 每天5分钟玩转 Docker 容器技术（166） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/9017730.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/9017730.html</guid>
<description>&lt;p&gt;&lt;span&gt;学习了 chart 结构和模板的知识后，现在重新实践一次 MySQL chart，相信会有更多收获。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;chart 安装前的准备&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;作为准备工作，安装之前需要先清楚 chart 的使用方法。这些信息通常记录在 values.yaml 和 README.md 中。除了下载源文件查看，执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;helm inspect values&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 可能是更方便的方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180510065917400-1739358097.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输出的实际上是 values.yaml 的内容。阅读注释就可以知道 MySQL chart 支持哪些参数，安装之前需要做哪些准备。其中有一部分是关于存储的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180510065927864-250014069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;chart 定义了一个 PersistentVolumeClaim，申请 8G 的 PersistentVolume。由于我们的实验环境不支持动态供给，所以得预先创建好相应的 PV，其配置文件 &lt;/span&gt;&lt;code&gt;&lt;span&gt;mysql-pv.yml&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 内容为：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180510065937971-1476328653.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;创建 PV &lt;/span&gt;&lt;code&gt;&lt;span&gt;mysql-pv&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180510065948598-757575110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来就可以安装 chart 了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;定制化安装 chart&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;除了接受 values.yaml 的默认值，我们还可以定制化 chart，比如设置 &lt;/span&gt;&lt;code&gt;&lt;span&gt;mysqlRootPassword&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Helm 有两种方式传递配置参数：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;指定自己的 values 文件。&lt;br/&gt;通常的做法是首先通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;helm inspect values mysql &amp;gt; myvalues.yaml&lt;/span&gt;&lt;/code&gt;&lt;span&gt;生成 values 文件，然后设置 &lt;/span&gt;&lt;code&gt;&lt;span&gt;mysqlRootPassword&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，之后执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;helm install --values=myvalues.yaml mysql&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;--set&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 直接传入参数值，比如：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180510065959271-848770985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;mysqlRootPassword&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 设置为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;abc123&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。另外，&lt;/span&gt;&lt;code&gt;&lt;span&gt;-n&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 设置 release 为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;my&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，各类资源的名称即为&lt;/span&gt;&lt;code&gt;&lt;span&gt;my-mysql&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;helm list&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;helm status&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 可以查看 chart 的最新状态。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180510070010378-882490543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;PVC 已经 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Bound&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，Deployment 也 &lt;/span&gt;&lt;code&gt;&lt;span&gt;AVAILABLE&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;升级和回滚 release&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;release 发布后可以执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;helm upgrade&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对其升级，通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;--values&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 或 &lt;/span&gt;&lt;code&gt;&lt;span&gt;--set&lt;/span&gt;&lt;/code&gt;&lt;span&gt;应用新的配置。比如将当前的 MySQL 版本升级到 5.7.15：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180510070024316-1755065840.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;等待一些时间，升级成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180510070033648-666060921.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;helm history&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 可以查看 release 所有的版本。通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;helm rollback&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 可以回滚到任何版本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180510070042591-221581890.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回滚成功，MySQL 恢复到 5.7.14。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180510070054707-1744734545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到这里，相信大家已经会使用 chart 了。下一节我们学习如何开发自己的 chart。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;书籍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.《每天5分钟玩转Kubernetes》&lt;br/&gt;&lt;a href=&quot;https://item.jd.com/26225745440.html&quot;&gt;https://item.jd.com/26225745440.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.《每天5分钟玩转Docker容器技术》&lt;br/&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 10 May 2018 22:31:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/9017730.html</dc:identifier>
</item>
<item>
<title>想想就好：我感觉我欠下的代码，再写十年也写不完 - 路过秋天</title>
<link>http://www.cnblogs.com/cyq1162/p/9022771.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyq1162/p/9022771.html</guid>
<description>&lt;p&gt;大伙帮我算算，我还欠了多少行代码，要多少年才能还清？&lt;/p&gt;

&lt;p&gt;今天，稍为研究了一下.Net Core打包Nuget后，然后把 &lt;a href=&quot;https://www.nuget.org/packages?q=cyqdatacore&quot; target=&quot;_blank&quot;&gt;CYQ.Data Core&lt;/a&gt; 给送上去了。&lt;/p&gt;
&lt;p&gt;Nuget上可搜：cyqdatacore。&lt;/p&gt;
&lt;p&gt;然后又研究了一下DotNetCore项目解决方案的共存，然后把源码解决方案给也提交了。&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/cyq1162/cyqdata&quot; target=&quot;_blank&quot;&gt;https://github.com/cyq1162/cyqdata&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个框架已经有十年历史了，已经相当完善了，后续的想法：&lt;/p&gt;
&lt;p&gt;1、 支持postgresql。&lt;/p&gt;
&lt;p&gt;2、优化Redis或Memcahe。&lt;/p&gt;

&lt;p&gt;这几天，都在折腾它，好在最后总算支持上.Net Core了。&lt;/p&gt;
&lt;p&gt;刚刚又把源码的工程文件给提交好了（下载源码就可以直接运行.NET Core版本了）。&lt;/p&gt;
&lt;p&gt;如此这般之后，开发.NET Core网站，让大伙除了微软家的MVC Core+EF，还有Taurus.MVC+CYQ.Data选择了。&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/cyq1162/Taurus.MVC&quot; target=&quot;_blank&quot;&gt;https://github.com/cyq1162/Taurus.MVC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个框架，追源的话，也差不多有10年历史了，是从当初秋色园博客那套框架的进化来的。&lt;/p&gt;
&lt;p&gt;后续的想法：&lt;/p&gt;
&lt;p&gt;1、发布Nuget&lt;/p&gt;
&lt;p&gt;2、加强CMS的模板处理功能。&lt;/p&gt;


&lt;p&gt;大伙都上.NET Core了，所以也在研究如何让它也上去，有了Taurus.MVC的先例，这个应该也能上。&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/cyq1162/Aries&quot; target=&quot;_blank&quot;&gt;https://github.com/cyq1162/Aries&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个框架，是在完善CYQ.Data的自动化编程思想后，在13年人在天越时创出来1.0版本，后来离开后，又花了很多心血，重新打造升级而成。&lt;/p&gt;
&lt;p&gt;后续的想法：&lt;/p&gt;
&lt;p&gt;1、支持.NET Core&lt;/p&gt;
&lt;p&gt;2、支持移动端&lt;/p&gt;
&lt;p&gt;3、支持工作流（当初写了开头就放下了）&lt;/p&gt;


&lt;p&gt;之前发布的版本，仅支持到vs2015，最近都在折腾vs2017,所以准备增加vs2017支持，源码已经支持了并提交了。&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;http://www.cnblogs.com/cyq1162/p/6027051.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cyq1162/p/6027051.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有了它，开发调试的效率会提高很多，属于是用VS开发的必备技能。&lt;/p&gt;
&lt;p&gt;后续的想法：&lt;/p&gt;
&lt;p&gt;1、发布支持VS2017的版本。&lt;/p&gt;
&lt;p&gt;2、查查为何VS2017下.NET Core无效的原因。&lt;/p&gt;

&lt;p&gt;当年开源的时候，开到2.5版（多用户），之后又在3.0版本的基础上，最新了3.0的单用户版本（不过未开源）。&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;http://www.cyqdata.com/download/article-detail-427&quot; target=&quot;_blank&quot;&gt;http://www.cyqdata.com/download/article-detail-427&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这套博客，功能很强大，集博客、论坛双层功能，又是多语言，支持域名绑定。&lt;/p&gt;
&lt;p&gt;后续的想法：&lt;/p&gt;
&lt;p&gt;1、用Taurus.MVC 重写QBlog&lt;/p&gt;
&lt;p&gt;2､ 用ASP.NET Aries 重写QBlog后台管理系统。&lt;/p&gt;


&lt;p&gt;当年用来屏网页搜索的广告、各大视频网站的广告、以前一键FQ和代理功能的使用。&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;http://www.cnblogs.com/cyq1162/p/4953032.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cyq1162/p/4953032.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当年也是很号的软件，毕竟广告浪费人生，FQ不容易，VPN经常连不上，而自定义的加密代理通讯，则没有这些限制。&lt;/p&gt;
&lt;p&gt;后续的想法：&lt;/p&gt;
&lt;p&gt;1、维护原有的广告屏蔽功能&lt;/p&gt;
&lt;p&gt;2、支持各大视频VIP功能。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;IISLogsViewer &lt;a href=&quot;http://www.cyqdata.com/iislogviewer&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;简单IIS日志分析工具&lt;/span&gt;&lt;/a&gt; 是CYQ系列中的一款用于&lt;a href=&quot;http://www.cyqdata.com/iislogviewer&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;分析IIS日志&lt;/span&gt;&lt;/a&gt;的&lt;a href=&quot;http://www.cyqdata.com/iislogviewer&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;简单IIS日志分析工具&lt;/span&gt;&lt;/a&gt;，使用简单，分析简单，效果不一般。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://www.cyqdata.com/download/article-detail-42518&quot; target=&quot;_blank&quot;&gt;http://www.cyqdata.com/download/article-detail-42518&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个没开源，代码也写的一般，唯一点可取就是关于大文件的读取。&lt;/p&gt;
&lt;p&gt;后续的想法：&lt;/p&gt;
&lt;p&gt;1、重写。&lt;/p&gt;
&lt;p&gt;2、增强完善各种功能&lt;/p&gt;


&lt;p&gt;这一款分布式网站负载压力测试工具，可以测试服务器负载性能和网站并发性能，默认可以使用2个节点发起近2048个并发链接，是网站开发者必备工具之一。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://www.cyqdata.com/download/article-detail-54396&quot; target=&quot;_blank&quot;&gt;http://www.cyqdata.com/download/article-detail-54396&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当年是很牛B的存在，后来网站让人举报，域名都被国家安全信息中心封了，后来解封了，网站该功能也停了。&lt;/p&gt;
&lt;p&gt;之后，转而开发了一个客户端让大伙使用。&lt;/p&gt;
&lt;p&gt;后续的想法：&lt;/p&gt;
&lt;p&gt;1、还没想。&lt;/p&gt;
&lt;p&gt;2、还没想。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;一款支持从一种数据库中反向工程生成多种数据库脚本和多数据库间批量互导数据功能的小工具&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下载地址：&lt;a href=&quot;http://www.cyqdata.com/download/article-detail-42517&quot; target=&quot;_blank&quot;&gt;http://www.cyqdata.com/download/article-detail-42517&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这好像是我唯一保留的共享软件。&lt;/p&gt;
&lt;p&gt;后续的想法：&lt;/p&gt;
&lt;p&gt;1、还没想。&lt;/p&gt;
&lt;p&gt;2、还没想。&lt;/p&gt;


&lt;p&gt;OS Develop Framework（Sagittarius 射手座：IOS下的一套基础快速开发框架）&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/cyq1162/Sagit&quot; target=&quot;_blank&quot;&gt;https://github.com/cyq1162/Sagit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用它开发原生的苹果app，很节省很多时间。&lt;/p&gt;
&lt;p&gt;后续的想法：&lt;/p&gt;
&lt;p&gt;1、从基础开发框架，升级为深度开发框架。&lt;/p&gt;
&lt;p&gt;2、补教程。&lt;/p&gt;


&lt;p&gt;我感觉还欠Java和Android各一套框架〜〜〜〜大伙帮我算算，我还欠了多少行代码，要多少年才能还清？&lt;/p&gt;

</description>
<pubDate>Thu, 10 May 2018 21:50:00 +0000</pubDate>
<dc:creator>路过秋天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cyq1162/p/9022771.html</dc:identifier>
</item>
<item>
<title>NewLife.Net——管道处理器解决粘包 - 大石头</title>
<link>http://www.cnblogs.com/nnhy/p/newlife_net_handler.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnhy/p/newlife_net_handler.html</guid>
<description>&lt;p&gt;Tcp网络编程，必须要解决的一个问题就是粘包，尽管解决办法有很多，这里讲一个比较简单的方法。&lt;/p&gt;

&lt;p&gt;老规矩，先上代码：&lt;a href=&quot;https://github.com/nnhy/NewLife.Net.Tests&quot; target=&quot;_blank&quot;&gt;https://github.com/nnhy/NewLife.Net.Tests&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;新建管道处理器项目HandlerTest，源码复制自第一节课的EchoTest项目，增加一个管道处理器类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; EchoHandler : Handler
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Object Read(IHandlerContext context, Object message)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; session =&lt;span&gt; context.Session;

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pk = message &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Packet;
        session.WriteLog(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;收到：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, pk.ToStr());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把收到的数据发回去&lt;/span&gt;
&lt;span&gt;        session.Send(pk);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;EchoHandler继承自处理器基类Handler，重载Read方法，当网络层收到数据包时，会调用该方法。&lt;/p&gt;
&lt;p&gt;这里我们实现了Echo功能，并打印日志。返回null告知不再执行管道上的后续处理器。&lt;/p&gt;

&lt;p&gt;既然有了处理器，第一节课中的MyNetServer就用不上啦，在TestServer中改回来标准的NetServer&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例化服务端，指定端口，同时在Tcp/Udp/IPv4/IPv6上监听&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; svr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NetServer
{
    Port &lt;/span&gt;= &lt;span&gt;1234&lt;/span&gt;&lt;span&gt;,
    Log &lt;/span&gt;=&lt;span&gt; XTrace.Log
};
svr.Add&lt;/span&gt;&amp;lt;EchoHandler&amp;gt;&lt;span&gt;();
svr.Start();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的svr.Add&amp;lt;EchoHandler&amp;gt;()把上面的处理器给注册进去，大意就是由这个处理器来负责处理收到的网络数据包。&lt;/p&gt;

&lt;p&gt;跑起来服务端和客户端看看效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201805/19592-20180511011552753-1941470013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，收发正常！&lt;/p&gt;


&lt;p&gt;真实应用场景中，不可能允许我们间隔1秒才发出一个网络包，直接就不该有等待。连续发送多个数据包，就很容易产生粘包。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestClient()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; uri = &lt;span&gt;new&lt;/span&gt; NetUri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp://127.0.0.1:1234&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;var uri = new NetUri(&quot;tcp:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;net.newlifex.com:1234&quot;);&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; client =&lt;span&gt; uri.CreateRemote();
    client.Log &lt;/span&gt;=&lt;span&gt; XTrace.Log;
    client.Received &lt;/span&gt;+= (s, e) =&amp;gt;&lt;span&gt;
    {
        XTrace.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;收到：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e.Packet.ToStr());
    };
    client.Open();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定时显示性能数据&lt;/span&gt;
    _timer = &lt;span&gt;new&lt;/span&gt; TimerX(ShowStat, client, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环发送数据&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Thread.Sleep(1000);&lt;/span&gt;

        &lt;span&gt;var&lt;/span&gt; str = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你好&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        client.Send(str);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;client.Dispose();&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里注释了睡眠语句，让它紧密发出5个数据包。注释后面的Dispose，让其有机会收到响应包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201805/19592-20180511011859445-2124747056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跑起来看到，粘包了！！！&lt;/p&gt;
&lt;p&gt;客户端发送5次，服务端作为一个包给接收了，整体处理，然后返回给客户端。&lt;/p&gt;
&lt;p&gt;粘包的解决办法很多，一般是加头部长度或者分隔符，也有取巧的办法直接设置NoDelay。&lt;/p&gt;
&lt;p&gt;从使用上来讲，相对可靠的做法是加头部长度。因为除了多个包粘在一起，还可能出现一个包被拆成两半，分别在前后两个包里面。&lt;/p&gt;


&lt;p&gt;我们加上头部长度来解决解包问题。&lt;/p&gt;
&lt;p&gt;修改一下服务端，增加一个处理器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestServer()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例化服务端，指定端口，同时在Tcp/Udp/IPv4/IPv6上监听&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; svr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NetServer
    {
        Port &lt;/span&gt;= &lt;span&gt;1234&lt;/span&gt;&lt;span&gt;,
        Log &lt;/span&gt;=&lt;span&gt; XTrace.Log
    };
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;svr.Add(new LengthFieldCodec { Size = 4 });&lt;/span&gt;
    svr.Add&amp;lt;StandardCodec&amp;gt;&lt;span&gt;();
    svr.Add&lt;/span&gt;&amp;lt;EchoHandler&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打开原始数据日志&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; ns =&lt;span&gt; svr.Server;
    ns.LogSend &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    ns.LogReceive &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    svr.Start();

    _server &lt;/span&gt;=&lt;span&gt; svr;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定时显示性能数据&lt;/span&gt;
    _timer = &lt;span&gt;new&lt;/span&gt; TimerX(ShowStat, svr, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;StandardCodec处理器是新生命团队标准封包。https://github.com/NewLifeX/X/tree/master/NewLife.Core/Net&lt;/p&gt;
&lt;p&gt;其固定4字节作为头部，其中后面两个字节标识负载长度。&lt;/p&gt;
&lt;p&gt;也可以使用LengthFieldCodec编码器（如上注释部分），并制定头部加4字节作为长度。&lt;/p&gt;
&lt;p&gt;编码器顺序非常重要，网络层收到数据包以后，会从前向后走过每一个处理器；SendAsync/SendMessage发送消息时，会从后向前走过每一个过滤器，逆序。&lt;/p&gt;

&lt;p&gt;客户端也要增加相应过滤器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestClient()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; uri = &lt;span&gt;new&lt;/span&gt; NetUri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp://127.0.0.1:1234&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;var uri = new NetUri(&quot;tcp:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;net.newlifex.com:1234&quot;);&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; client =&lt;span&gt; uri.CreateRemote();
    client.Log &lt;/span&gt;=&lt;span&gt; XTrace.Log;
    client.Received &lt;/span&gt;+= (s, e) =&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pk = e.Message &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Packet;
        XTrace.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;收到：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, pk.ToStr());
    };
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;client.Add(new LengthFieldCodec { Size = 4 });&lt;/span&gt;
    client.Add&amp;lt;StandardCodec&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打开原始数据日志&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; ns =&lt;span&gt; client;
    ns.LogSend &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    ns.LogReceive &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    client.Open();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定时显示性能数据&lt;/span&gt;
    _timer = &lt;span&gt;new&lt;/span&gt; TimerX(ShowStat, client, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环发送数据&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; str = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你好&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pk = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Packet(str.GetBytes());
        client.SendAsync(pk);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发送函数改为SendAsync，原来的Send(Packet pk)会绕过管道处理器。&lt;/p&gt;
&lt;p&gt;客户端接收时，e.Message表示经过处理器处理得到的消息，e.Packet表示原始数据包。&lt;/p&gt;

&lt;p&gt;同时，通过LogSend/LogReceive打开收发数据日志。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201805/19592-20180511021443666-479998457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图效果，客户端发出第5个包，头部多了4个字节，其中07-00表示后续负载数据长度为7字节（NewLife）。&lt;/p&gt;
&lt;p&gt;服务端先收到第一个包11字节，然后收到44字节，这是4个包粘在一起。&lt;/p&gt;
&lt;p&gt;然后StandardCodec编码器成功将其拆分成为4个，并依次通过EchoHandler。&lt;/p&gt;
&lt;p&gt;到了客户端这边，也是后面4个粘在一起，并且也得到了正确拆分。&lt;/p&gt;

&lt;p&gt;如果一个大包被拆分为几个，StandardCodec也能缓冲合并，半包超过500~5000ms仍未能组合完整时将抛弃。&lt;/p&gt;


&lt;p&gt;借助管道处理器架构，我们轻易解决了粘包问题！&lt;/p&gt;
&lt;p&gt;显然，管道架构并非单纯为了粘包问题而设计，它有着非常重要的意义，加解密、压缩、各种协议处理，等等。&lt;/p&gt;
&lt;p&gt;管道架构的设计，参考了Netty，因此大部分Netty的编解码器都可以在此使用。&lt;/p&gt;
</description>
<pubDate>Thu, 10 May 2018 18:24:00 +0000</pubDate>
<dc:creator>大石头</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnhy/p/newlife_net_handler.html</dc:identifier>
</item>
<item>
<title>AspnetCore 缓存篇 - 乐途</title>
<link>http://www.cnblogs.com/szlblog/p/9022607.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/szlblog/p/9022607.html</guid>
<description>&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;一、缓存的作用&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;&lt;span&gt;怎样理解缓存：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;     &lt;span&gt;其实所有的程序，架构，优化，线程&lt;/span&gt;...&lt;span&gt;等技术手段，最终的目的都是如何使产品快速的响应用户的操作，提高用户的体验性，目标都是为了系统的使用者，缓存的存在也是同样的道理，缓存常用于存放不经常更改的数据信息，比如，用户的基础数据、&lt;/span&gt;&lt;span&gt;Token&lt;/span&gt;&lt;span&gt;等一些长被使用并且不常更改的&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;&lt;span&gt;举例说明&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;span&gt;咱们就拿用户的登录操作来说，有一个系统是这样设计的，（&lt;/span&gt;1&lt;span&gt;）用户（输入用户名：密码）登录》》》（&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）首先程序做的是在缓存中查询数据，判断是否有缓存存在，缓存是否过期，如果缓存过期了》》》（&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;）进库查询用户是否具有登录的权限》》》最后是功能页面。  一张简单的图加深一下印象&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1027558/201805/1027558-20180511011418822-179041891.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;在上图中我们可以看到如果缓存存在的话，我们大可不必进库去查询数据了，省去了查询的动作、开关库、判断的操作。加入这些动作可以省去&lt;/span&gt;1&lt;span&gt;秒钟的时间，这就已经在提高用户的体验性了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;缓存的作用不只是这一个方面，建议大家多去找找资料，每个人学出来的东西都不一样。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;比如缓存的状态、生存期、缓存的类别 等&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;h2&gt;二、&lt;strong&gt;ASPNet Core&lt;span&gt;的内置缓存&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;AspNetCore支持多种缓存，首先说一下AspNetCore 的内置缓存 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.caching.memory.imemorycache&quot;&gt;&lt;span&gt;IMemoryCache&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.caching.memory.imemorycache&quot;&gt;&lt;span&gt;IMemoryCache&lt;/span&gt;&lt;/a&gt;&lt;span&gt;把数据存储在&lt;/span&gt;&lt;strong&gt;Web服务器的内置缓存中，&lt;/strong&gt;&lt;span&gt;也就是&lt;/span&gt;Web服务器缓存，和 &lt;strong&gt;System.Web.HttpRuntime&lt;/strong&gt;&lt;strong&gt; &lt;span&gt;缓存作用上差别不大&lt;/span&gt; ,&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;但是在&lt;/span&gt;Core中去掉了System.Web.HttpRu&lt;/strong&gt;ntime 的命名引用被移除，引入命名空间Microsoft.Extensions.Caching.Memory&lt;/p&gt;
&lt;p&gt;使用NuGet管理工具添加如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1027558/201805/1027558-20180511011633279-1253802459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;针对Core缓存我们做出如下几个操作：&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;首先创建一个缓存：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;操作步骤引入命名空间，&lt;/span&gt;Microsoft.Extensions.Caching.Memory&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在我们的帮助类中用&lt;strong&gt;构造器注入&lt;/strong&gt;的方式创建&lt;/span&gt;&lt;strong&gt;IMemoryCache &lt;span&gt;的&lt;/span&gt;&lt;span&gt;对象&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_fd945412-b62f-4d9d-9c3f-e68dea72e0c8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fd945412-b62f-4d9d-9c3f-e68dea72e0c8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fd945412-b62f-4d9d-9c3f-e68dea72e0c8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IMemoryCache _cache;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造器注入&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CoreMemoryCache(IMemoryCache memoryCache)
        {
            _cache &lt;/span&gt;=&lt;span&gt; memoryCache;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;创建缓存的方法有两个：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1) Set();&lt;/strong&gt; &lt;span&gt;创建一个缓存项，可以设置缓存项的绝对和滑动过期时间，优先级等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) GetOrCreate()&lt;/strong&gt;&lt;span&gt;； 方法的含义和命名一致，获取或创建，如果缓存存在则获取缓存项，如果不存在则创建缓存项。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;（1）&lt;strong&gt;Set();&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_b9c1d8d4-5de5-4ef2-8d79-c5668faf8a06&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b9c1d8d4-5de5-4ef2-8d79-c5668faf8a06&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b9c1d8d4-5de5-4ef2-8d79-c5668faf8a06&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Add(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; value)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(key))
            {
                &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; ArgumentNullException说明
                &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
                 * 如果不想返回异常信息的话也可以返回 自己定义的
                 * 当参数为空时放生的异常
                 * 和 ArgumentException 作用相同
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;#endregion&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; throw new ArgumentNullException(key);&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                MemoryCacheEntryOptions cacheExpirationOptions &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemoryCacheEntryOptions();
                cacheExpirationOptions.AbsoluteExpiration &lt;/span&gt;= DateTime.Now.AddMinutes(&lt;span&gt;30&lt;/span&gt;&lt;span&gt;);
                cacheExpirationOptions.Priority &lt;/span&gt;=&lt;span&gt; CacheItemPriority.Normal;
                cacheExpirationOptions.RegisterPostEvictionCallback(IDGCacheItemChangedHandler, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类似 System.Web.HttpRuntime.Cache[key] &lt;/span&gt;
&lt;span&gt;                _cache.Set(key, value, cacheExpirationOptions);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果添加成功则验证是否存在返回True 或false&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Exists(key);
        }
设置缓存的CacheItemPriority&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;添加缓存的时候利用&lt;/span&gt;MemoryCacheEntryOptions &lt;span&gt;来设置缓存：&lt;strong&gt;重点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体实现：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1027558/201805/1027558-20180511012203306-604487742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;利用缓存中&lt;/span&gt;Set&lt;span&gt;方法最后一个参数  上方截图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;MemoryCacheEntryOptions&lt;span&gt;：绝对重要，他决定着怎么设置绝对过期时间和滑动过期时间，优先级等&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_3c505048-58d5-4fac-a8dc-364a02ecc464&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3c505048-58d5-4fac-a8dc-364a02ecc464&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3c505048-58d5-4fac-a8dc-364a02ecc464&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;缓存添加实现如下
 MemoryCacheEntryOptions cacheExpirationOptions &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemoryCacheEntryOptions();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绝对过期时间&lt;/span&gt;
                cacheExpirationOptions.AbsoluteExpiration = DateTime.Now.AddMinutes(&lt;span&gt;30&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存优先级&lt;/span&gt;
                cacheExpirationOptions.Priority =&lt;span&gt; CacheItemPriority.Normal;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加缓存&lt;/span&gt;
   _cache.Set(key, value, cacheExpirationOptions);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;MemoryCacheEntryOptions的&lt;strong&gt;Priority&lt;/strong&gt;属性。 Priority属性指定应将哪些对象（基于已设置的优先级）从缓存中删除，作为每当Web服务器内存空间不足时回收内存的运行时策略的一部分。要设置优先级，我们使用CacheItemPriority枚举。这可以具有以下可能的值之一：低，正常，高和NeverRemove。 ASP.Net Core中的内存缓存提供程序将在内存压力下移除缓存条目，&lt;span&gt;如果&lt;/span&gt;&lt;span&gt;将缓存优先级设置为&lt;/span&gt;CacheItemPriority.NeverRemove。&lt;span&gt;这个时候我们可以&lt;/span&gt;&lt;span&gt;注册一个回调，该回调将在从缓存中移除&lt;/span&gt;&lt;span&gt;条&lt;/span&gt;&lt;span&gt;目时执行&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;MemoryCacheEntryOptions中的 RegisterPostEvictionCallback&lt;/strong&gt; 这个可以用来记录日志什么的&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;举例代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
cacheExpirationOptions.RegisterPostEvictionCallback(AddCallback,&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;public enum EvictionReason
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    None = 0,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     Manually
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    Removed = 1,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     Overwritten
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    Replaced = 2,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     Timed out
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    Expired = 3,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     Event
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    TokenExpired = 4,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     Overflow
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    Capacity = 5
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AddCallback(&lt;span&gt;object&lt;/span&gt; key, &lt;span&gt;object&lt;/span&gt; value, EvictionReason reason, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; state)
        {
            _cache.Set(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CallbackMsg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, reason);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;（2）&lt;strong&gt;GetOrCreate();&lt;/strong&gt;&lt;/h4&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_466a952e-654a-4aed-8934-6e1c3190cd86&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_466a952e-654a-4aed-8934-6e1c3190cd86&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_466a952e-654a-4aed-8934-6e1c3190cd86&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;代码如下：
 &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 存在创建不存在获取
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; AddOrCreate(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; value)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(key))
            { }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; public static TItem GetOrCreate&amp;lt;TItem&amp;gt;(this IMemoryCache cache, object key, Func&amp;lt;ICacheEntry, TItem&amp;gt; factory);&lt;/span&gt;
                _cache.GetOrCreate(key, ENTRY =&amp;gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; value; });  
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果添加成功则验证是否存在&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Exists(key);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;2. &lt;strong&gt;&lt;span&gt;删除缓存&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1) &lt;strong&gt;Remove&lt;/strong&gt;&lt;strong&gt;();&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个见名就知道了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_dd313641-c5ba-4ddf-8e94-35bbcc554607&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_dd313641-c5ba-4ddf-8e94-35bbcc554607&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_dd313641-c5ba-4ddf-8e94-35bbcc554607&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 删除缓存
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Remove(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(key))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除&lt;/span&gt;
&lt;span&gt;                _cache.Remove(key);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果删除成功则验证是否存在返回bool&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; !&lt;span&gt;Exists(key);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;h3&gt;3. &lt;strong&gt;&lt;span&gt;修改缓存&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;（1）&lt;span&gt;修改缓存并没有具体的方法，咱们代码走的是，先删除后添加的方法&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_2f91298e-35cf-49dd-9406-79083874f775&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2f91298e-35cf-49dd-9406-79083874f775&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2f91298e-35cf-49dd-9406-79083874f775&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 修改缓存
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 修改时 MemoryCache 没有提供相对相应的方法，先删除后添加&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Modify(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; value)
        {
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; ReturnBool = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(key))
            { }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Exists(key))
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Remove(key))
                    {
                        ReturnBool &lt;/span&gt;=&lt;span&gt; Add(key, value);
                    }
                }

            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ReturnBool;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;4.&lt;span&gt;获取缓存项&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;p class=&quot;pre&quot;&gt;(1)Get();&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_91ebd1c8-47dc-4c7d-85e0-6c23fa2ea211&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_91ebd1c8-47dc-4c7d-85e0-6c23fa2ea211&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_91ebd1c8-47dc-4c7d-85e0-6c23fa2ea211&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取缓存 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Get(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(key))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {

                &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 另一种判断方式
                &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
                _cache.TryGetValue(key, out ReturnValue)检索缓存输出Bool;
                用这个也可以直接把 out 输出就行
                &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;#endregion&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _cache.Get(key);
                

            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;5.&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;验证缓存是否存在&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;代码如下：利用&lt;/span&gt;TryGetValue&lt;span&gt;（）&lt;/span&gt;;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_9fee5056-f21d-4649-bd08-293cc5a7a1a6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9fee5056-f21d-4649-bd08-293cc5a7a1a6&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9fee5056-f21d-4649-bd08-293cc5a7a1a6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 验证缓存是否存在
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Exists(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; ReturnValue;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(key))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _cache.TryGetValue(key, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; ReturnValue);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;缓存中整体的方法，不过有的没去实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是所有方法的截图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1027558/201805/1027558-20180511013236870-1218016424.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;睡觉了一点半了，后面写的有点捉急抱歉，&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;span&gt;欢迎大家指出错误之处，转载注明出处，谢谢&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Thu, 10 May 2018 17:36:00 +0000</pubDate>
<dc:creator>乐途</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/szlblog/p/9022607.html</dc:identifier>
</item>
<item>
<title>用Maven实现一个protobuf的Java例子 - jihite</title>
<link>http://www.cnblogs.com/kaituorensheng/p/9022591.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kaituorensheng/p/9022591.html</guid>
<description>&lt;p&gt;注：试验环境在Mac Idea环境下&lt;/p&gt;
&lt;h3&gt;1. 介绍Protocol Buffers&lt;/h3&gt;
&lt;p&gt;Protocal Buffers(简称protobuf)是谷歌的一项技术，用于结构化的数据序列化、反序列化，常用于RPC 系统和持续数据存储系统。&lt;/p&gt;
&lt;p&gt;其类似于XML生成和解析，但protobuf的效率高于XML，不过protobuf生成的是&lt;strong&gt;字节码&lt;/strong&gt;，可读性比XML差。类似的还有json、Java的Serializable等。&lt;/p&gt;
&lt;p&gt;很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。&lt;/p&gt;
&lt;h3&gt;2. Idea 安装protobuf插件&lt;/h3&gt;
&lt;p&gt;安装插件protobuf Support，之后重启&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/408927/201805/408927-20180511003443289-1489480098.png&quot; alt=&quot;&quot; width=&quot;870&quot; height=&quot;415&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3. 配置依赖&lt;/h3&gt;
&lt;p&gt;pom.xml添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.google.protobuf&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;protobuf-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.4.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;br/&gt;&amp;lt;build&amp;gt;
        &amp;lt;extensions&amp;gt;
            &amp;lt;extension&amp;gt;
                &amp;lt;groupId&amp;gt;kr.motd.maven&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;os-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;1.4.1.Final&amp;lt;/version&amp;gt;
            &amp;lt;/extension&amp;gt;
        &amp;lt;/extensions&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.xolstice.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;protobuf-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;0.5.0&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;protocArtifact&amp;gt;&lt;span&gt;
                        com.google.protobuf:protoc:&lt;/span&gt;3.1.0&lt;span&gt;:exe:${os.detected.classifier}
                    &lt;/span&gt;&amp;lt;/protocArtifact&amp;gt;
                    &amp;lt;pluginId&amp;gt;grpc-java&amp;lt;/pluginId&amp;gt;
                &amp;lt;/configuration&amp;gt;
                &amp;lt;executions&amp;gt;
                    &amp;lt;execution&amp;gt;
                        &amp;lt;goals&amp;gt;
                            &amp;lt;goal&amp;gt;compile&amp;lt;/goal&amp;gt;
                            &amp;lt;goal&amp;gt;compile-custom&amp;lt;/goal&amp;gt;
                        &amp;lt;/goals&amp;gt;
                    &amp;lt;/execution&amp;gt;
                &amp;lt;/executions&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;&lt;br/&gt;&amp;lt;/build&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4. 书写proto文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
syntax = &quot;proto3&quot;&lt;span&gt;;
option java_package &lt;/span&gt;= &quot;com.jihite&quot;&lt;span&gt;;
option java_outer_classname &lt;/span&gt;= &quot;PersonModel&quot;&lt;span&gt;;

message Person {
     int32 id &lt;/span&gt;= 1&lt;span&gt;;
     string name &lt;/span&gt;= 2&lt;span&gt;;
     string email &lt;/span&gt;= 3&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;5. 转化成Java文件&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/408927/201805/408927-20180511004104987-656534702.png&quot; alt=&quot;&quot; width=&quot;917&quot; height=&quot;422&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;6. 测试&lt;/h3&gt;
&lt;p&gt;把生成的类考的代码路径下，用下面测试用例测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.jihite;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.google.protobuf.InvalidProtocolBufferException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; protobufTest {
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testN() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InvalidProtocolBufferException {
        PersonModel.Person.Builder builder &lt;/span&gt;=&lt;span&gt; PersonModel.Person.newBuilder();
        builder.setId(&lt;/span&gt;1&lt;span&gt;);
        builder.setName(&lt;/span&gt;&quot;jihite&quot;&lt;span&gt;);
        builder.setEmail(&lt;/span&gt;&quot;jihite@jihite.com&quot;&lt;span&gt;);

        PersonModel.Person person &lt;/span&gt;=&lt;span&gt; builder.build();
        System.out.println(&lt;/span&gt;&quot;before:&quot; +&lt;span&gt; person);

        System.out.println(&lt;/span&gt;&quot;===Person Byte:&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; b : person.toByteArray()) {
            System.out.print(b);
        }
        System.out.println(&lt;/span&gt;&quot;================&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] byteArray =&lt;span&gt; person.toByteArray();
        PersonModel.Person p2 &lt;/span&gt;=&lt;span&gt; PersonModel.Person.parseFrom(byteArray);
        System.out.println(&lt;/span&gt;&quot;after id:&quot; +&lt;span&gt; p2.getId());
        System.out.println(&lt;/span&gt;&quot;after name:&quot; +&lt;span&gt; p2.getName());
        System.out.println(&lt;/span&gt;&quot;after email:&quot; +&lt;span&gt; p2.getEmail());

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 10 May 2018 17:17:00 +0000</pubDate>
<dc:creator>jihite</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kaituorensheng/p/9022591.html</dc:identifier>
</item>
<item>
<title>区块链踩坑之搭建以太坊网络私有链（多节点）及创建多重签名钱包 - 潇十一郎</title>
<link>http://www.cnblogs.com/zhangxiaoyong/p/9020236.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangxiaoyong/p/9020236.html</guid>
<description>&lt;h4 class=&quot;postTitle&quot;&gt;连载篇提前看&lt;/h4&gt;
&lt;h4 class=&quot;postTitle&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/zhangxiaoyong/p/9017079.html&quot; target=&quot;_blank&quot;&gt;系列文章一：区块链踩坑之搭建以太坊网络私有链（单节点）&lt;/a&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;a href=&quot;http://www.cnblogs.com/zhangxiaoyong/p/9020236.html&quot; target=&quot;_blank&quot;&gt;系列文章二：区块链踩坑之搭建以太坊网络私有链（多节点）及创建多重签名钱包&lt;/a&gt;&lt;/h4&gt;
&lt;h4&gt;前言&lt;/h4&gt;
&lt;p&gt;上一篇 我们介绍了如果搭建一个以太坊网络私有链环境，不过是再一台电脑 属于单节点网络环境，真实情况是点对点的，一定是多节点（多台电脑数据一致），所以，本篇文章将继续探讨如何再本地演示多节点的私有链如何搭建以及如何创建多重签名钱包如何创建和使用还有应用场景。废话不多少，开整！&lt;/p&gt;
&lt;h4&gt;多节点私有链网络搭建&lt;/h4&gt;
&lt;p&gt;为了在本地演示多节点情况，我们安装虚拟机，然后新装一个系统，用以区分本电脑和其他电脑，以下统称主电脑为“”a节点“”，虚拟机 环境称为 “”b节点“”。&lt;/p&gt;
&lt;p&gt;① 安装 VMware 及Windows64 系统分配25G空间大小如图（安装过程不过详解，需要系统下载地址的可以私信或者留言也可以进群找文件）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510164853528-944058837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;② 将上篇文章中Mist钱包拷贝到C盘Mist目录下 运行&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510165009904-1536147283.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510233532834-1069684927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后经过漫长的等待 出现了这个文件夹 说明 本地下载节点已经ok&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510165118500-1804436207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③然后我们把Geth添加到环境变量，方便我们后续操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510165320403-1108068830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;验证 Geth是否添加成功 执行cmd  geth -h 如下 ，则表示Geth安装并运行成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510165511528-1693455352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 按照上篇文章提到的配置本地私有链操作，操作b节点私有链即可&lt;/p&gt;
&lt;p&gt;④新建目录 c:\Mychains\dev  然后将创始区块文件CustomGenesis.json放入， 文件内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nonce&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0x0000000000000042&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,     
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0x00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;parentHash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0x0000000000000000000000000000000000000000000000000000000000000000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;extraData&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0x00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,     
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gasLimit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0x8000000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,     
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;difficulty&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0x400&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mixhash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0x0000000000000000000000000000000000000000000000000000000000000000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;coinbase&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0x3333333333333333333333333333333333333333&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,     
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alloc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
     },
     &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chainId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;15&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;homesteadBlock&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eip155Block&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eip158Block&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释一下各个参数的作用：&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;13.5&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;mixhash&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;与nonce配合用于挖矿，由上一个区块的一部分生成的hash。注意他和nonce的设置需要满足以太坊的Yellow paper, 4.3.4. Block Header Validity, (44)章节所描述的条件。.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;nonce&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;nonce就是一个64位随机数，用于挖矿，注意他和mixhash的设置需要满足以太坊的Yellow paper, 4.3.4. Block Header Validity, (44)章节所描述的条件。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;difficulty&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;设置当前区块的难度，如果难度过大，cpu挖矿就很难，这里设置较小难度&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;alloc&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;用来预置账号以及账号的以太币数量，因为私有链挖矿比较容易，所以我们不需要预置有币的账号，需要的时候自己创建即可以。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;coinbase&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;矿工的账号，随便填&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;timestamp&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;设置创世块的时间戳&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;parentHash&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;上一个区块的hash值，因为是创世块，所以这个值是0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;extraData&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;附加信息，随便填，可以填你的个性信息&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;gasLimit&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;该值设置对GAS的消耗总量限制，用来限制区块能包含的交易信息总和，因为我们是私有链，所以填最大。&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;然后执行启动创始区块命令和启动私有链命令，命令内容如下：&lt;/p&gt;
&lt;p&gt;执行创始区块&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;geth --identity &quot;mydev&quot; --rpc --rpcport &quot;8086&quot; --rpccorsdomain &quot;*&quot; --datadir &quot;E:\Mychains\dev&quot; --port &quot;8545&quot; --nodiscover --rpcapi &quot;db,eth,net,web3&quot; --networkid 99 init &quot;E:\Mychains\dev\CustomGenesis.json&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;启动私有链&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;geth  --identity &quot;mydev&quot; --rpc --rpcport &quot;8080&quot; --rpccorsdomain &quot;*&quot; --datadir &quot;E:\Mychains\dev&quot; --port &quot;8545&quot; --nodiscover  --rpcapi &quot;db,eth,net,web3&quot; --networkid 99 console&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;执行成功后会在 目录下创建两个文件夹 如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510234623270-789777218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动私有链成功后 可以打开 Mist客户端 如下图(右上角显示有PRIVATE-NET)即为私有链连接成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510234705759-1299436983.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑤在b节点 打开的Mist客户端中创建一个主账户(创建账户可参考上篇文章)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510170143933-374691950.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; ⑥将a节点添加到b节点中，找到a节点Info信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510170254246-907422835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将[::]更改成a节点本地IP后如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&quot;enode://c87ba6e2f75ddff7a7ec19913e4d7161ef4304104e1ac91cd2a5a5608943a9ad4022d84082276caf55c3e3921663c07d8ce18ec041b417875c92073d4384a0a6@192.168.180.1:8545?discport=0&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将a节点信息添加到b节点中如下(&lt;strong&gt;&lt;span&gt;使用命令 web3.admin.addPeer&lt;/span&gt;&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510170441932-1658874974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;添加成功后返回true，然后查询下当前节点（&lt;strong&gt;&lt;span&gt;web3.admin.peers查询当前连接节点情况&lt;/span&gt;&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510171449789-45548461.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 返回a节点查看节点连接情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510172140752-920838408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们返回b节点验证一下 当前b节点ID是否是044开头的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510172527511-1341199463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对比后完全一致，说明a和b两个节点已经连接成了一个网络&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在我们针对a节点的主账户 先进行挖矿操作 用miner.start()开启挖矿&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510235204797-583637262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 现在 我们用a节点的子分账户Account2是有20个以太币的，现在往 b节点的主账户 转账10个以太币 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510235451670-1857333209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;进行过转币操作，然后 确认密码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510174404221-1649236731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 待区块被矿工挖到确认后 交易成功 生成交易记录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510231409716-1948613980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确认完毕，交易成功，双方同时可查看账户详情。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510231818057-987818117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 至此，一个真正的点对点的 私有链网络搭建和转账交易完毕。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;多重签名钱包&lt;/h4&gt;
&lt;p&gt;①a节点新增钱包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510231927607-952281612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;②下一步为了模拟真实环境，我们用a节点和b节点 不同的账户地址 做多重签名认证，然后点击创建&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510232326691-1523550478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 输入密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510232400593-1357421847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;等待创建确认&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510232444016-1027025166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; ③创建成功，并像公共钱包  存入1000以太坊&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180510235846588-574346627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180511000044570-1267117221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 输入交易密码 开始待矿工挖取 交易&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180511000116937-1347190602.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180511000232053-1141909183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;④从公共钱包转50到b节点中，我们看看会是什么情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180511000459684-1456944809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们交易操作我们创建钱包时约定的每个账户只能发小余10个，超出就需要约定账户确认。我们继续操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180511000610652-1430379862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入密码，确认&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180511000730427-56867154.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们执行挖矿，让交易开始，矿工确认后 如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180511001018754-2082439014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在b节点目前是有10个以太坊&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180511001856706-1648849485.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们点击批准&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180511002039830-1118875634.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 进行挖矿操作会看到 &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180511002311730-1200441177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看看b节点情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180511002616668-796139488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此，多重签名钱包的实际应用已经完毕，不过上述图中有一个问题，大家可以思考一下。&lt;/p&gt;
&lt;h4&gt;应用场景&lt;/h4&gt;
&lt;p&gt; 多重钱包的应用 ，可以是再公司与公司之前交易合作上，也可以是多人之间的合作关系，合伙人之间。那么就有一个问题，公共钱包不能只再节点a能看到，如果合伙人b节点也想看到公共钱包，并且操作钱包怎么做呢？&lt;/p&gt;
&lt;p&gt;我们在b节点新增钱包，选择钱包类型的时候  我们选择导入钱包 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180511003126329-1634206980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180511003441037-1668739134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后我们从b节点操作公共钱包，往a节点子账户发送50个以太坊，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180511003542212-1235623600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，a节点子账户是有20个以太坊的，我们直接操作转账：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180511003834670-173793620.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;b节点上操作公共钱包超出限额 也是需要其他账户确认的。我们继续操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180511004954816-1804174121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们点击批准并选择Account2 继续&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180511005018746-570957667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180511005050902-893822077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入密码 确定&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/762349/201805/762349-20180511011221459-1216852786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，关于以搭建以太坊私有网络多节点和创建及使用多重钱包 已经全部结束，文中并未涉及完整，还有些细微地方可能没有提及到，如有需要，可以进群讨论。&lt;/p&gt;
&lt;p&gt;下一篇，我们将开始 讨论 关于编写 智能合约及发一个简单代币 &lt;/p&gt;

&lt;p&gt;未完待续。。。。&lt;/p&gt;

</description>
<pubDate>Thu, 10 May 2018 17:16:00 +0000</pubDate>
<dc:creator>潇十一郎</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangxiaoyong/p/9020236.html</dc:identifier>
</item>
<item>
<title>SpringCloud实战-Ribbon客户端负载均衡 - 蜗居在小黑屋操控世界</title>
<link>http://www.cnblogs.com/huangjuncong/p/9022055.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangjuncong/p/9022055.html</guid>
<description>&lt;p&gt;前面我们已经完成了注册中心和服务提供者两个基础组件。接着介绍使用Spring Cloud Ribbon在客户端负载均衡的调用服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ribbon 是一个客户端负载均衡器，可以简单的理解成类似于 nginx的负载均衡模块的功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主流的LB方案可分成两类：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;一种是集中式LB, 即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；&lt;/p&gt;
&lt;p&gt;　　另一种是进程内LB，将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。Ribbon就属于后者，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。&lt;/p&gt;

&lt;p&gt;　　Ribbon的架构图：如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180510210043269-156245862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.首先我们先在原来的基础上新建一个Ribbon模块，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180510205719787-1067413754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们单独使用ribbon，在Ribbon模块下添加依赖，如下图所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
       &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
       &amp;lt;artifactId&amp;gt;spring-cloud-starter-ribbon&amp;lt;/artifactId&amp;gt;
       &amp;lt;version&amp;gt;1.4.0.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 修改application.yml文件，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: &lt;/span&gt;8082&lt;span&gt;
spring:
  application:
    name: Ribbon&lt;/span&gt;-&lt;span&gt;Consumer
#providers这个是自己命名的，ribbon,listOfServer这两个是规定的
providers:
  ribbon:
    listOfServers: localhost:&lt;/span&gt;8080,localhost:8081
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Ribbon模块下新建一个测试类如下代码&lt;span&gt; * Created by cong on 2018/5/8.&lt;/span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConsumerController {
&lt;br/&gt;　　//注入负载均衡客户端
&lt;/span&gt;&lt;span&gt;  　@Autowired&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    private LoadBalancerClient loadBalancerClient;&lt;/span&gt;&lt;span&gt;

    @RequestMapping(&lt;/span&gt;&quot;/consumer&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String helloConsumer() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ExecutionException, InterruptedException {&lt;br/&gt;　　　　　//这里是根据配置文件的那个providers属性取的
&lt;/span&gt;&lt;span&gt;        ServiceInstance serviceInstance = loadBalancerClient.choose(&quot;providers&quot;);&lt;br/&gt;　　　　　　//负载均衡算法默认是轮询，轮询取得服务
&lt;/span&gt;&lt;span&gt;        URI uri = URI.create(String.format(&quot;http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;%s:%s&quot;, serviceInstance.getHost(), serviceInstance.getPort()));
&lt;/span&gt;&lt;span&gt;        return uri.toString();&lt;br/&gt;　　}&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;　　会轮询的获取到两个服务的URL 访问第一次，浏览器出现http://localhost:8080  访问第二次就会出现http://localhost:8081&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180510211424387-1482257611.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在这里给普及一下有哪些负载均衡算法：&lt;/p&gt;

&lt;p&gt;　　1:简单轮询负载均衡（RoundRobin）&lt;/p&gt;
&lt;p&gt;    　　 以轮询的方式依次将请求调度不同的服务器，即每次调度执行i = (i + 1) mod n，并选出第i台服务器。&lt;/p&gt;

&lt;p&gt;   2:随机负载均衡 （Random）&lt;/p&gt;
&lt;p&gt;    　　 随机选择状态为UP的Server&lt;/p&gt;

&lt;p&gt;   3:加权响应时间负载均衡 （WeightedResponseTime）&lt;/p&gt;
&lt;p&gt;     根据相应时间分配一个weight，相应时间越长，weight越小，被选中的可能性越低。&lt;/p&gt;

&lt;p&gt;   4:区域感知轮询负载均衡（ZoneAvoidanceRule）&lt;/p&gt;
&lt;p&gt;    　　 复合判断server所在区域的性能和server的可用性选择server&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180510211644468-795865311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180510211703313-723677962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有兴趣的还可以看一下我在Ngnix的随笔文章中列出的负载均衡算法实现&lt;/strong&gt;：http://www.cnblogs.com/huangjuncong/p/8319182.html&lt;/p&gt;
&lt;p&gt;如果想配置其他轮询算法在yml配置文件中配置，如下配置一个随机算法所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: &lt;/span&gt;8082&lt;span&gt;
spring:
  application:
    name: Ribbon&lt;/span&gt;-&lt;span&gt;Consumer
#providers这个是自己命名的，ribbon,listOfServer这两个是规定的
providers:
  ribbon:
    listOfServers: localhost:&lt;/span&gt;8080,localhost:8081&lt;span&gt;

##如果不想选用默认的轮询的负载均衡算法，在这里做如下配置
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接着在启动类动一下手脚让我们配置的随机算法的负载均衡生效，只需要实现一个实现了IRule接口的Bean即可，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; hjc;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netflix.loadbalancer.IRule;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netflix.loadbalancer.RandomRule;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.discovery.EnableDiscoveryClient;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.loadbalancer.LoadBalanced;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.client.RestTemplate;

@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RibbonApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(RibbonApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IRule ribbonRule(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RandomRule();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此重新启动Ribbon启动类，得到的结果是随机的，如下所示：&lt;/p&gt;
&lt;p&gt;　　浏览器随机出现http://localhost:8080 或者http://localhost:8081&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那么问题来了，服务的地址是写死在配置文件中，如果某个服务挂了，那么还会把请求转发到挂掉的服务中，因此，解决的办法是，跟Eureka对接，结合一起用。就可以依靠Eureka动态的获取一个可用的服务列表，隔一段时间我就更新一次，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;或者Eureka设置一个监听端口，某一个服务挂了，Eureka通知我，我会知道，变更服务列表，这样不久形成一个闭环了吗？这样就不存在高可用性问题了。跟Eureka配合一起用同时解决了的Ribbon的单点故障问题&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;第一步，毫无疑问就是修改Ribbon模块的pom.xml文件，加入如下依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.3.5.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二步，修改yml配置文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: &lt;/span&gt;&lt;span&gt;8082&lt;/span&gt;&lt;span&gt;
spring:
  application:
    name: Ribbon&lt;/span&gt;-&lt;span&gt;Consumer

eureka:
#客户端
  client:
#注册中心地址
    service&lt;/span&gt;-&lt;span&gt;url:
      defaultZone: http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8888/eureka/,&lt;/span&gt;&lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;:8889/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就可以跟Eureka结合，这样Ribbon就可以通过Eureka动态的获取服务列表&lt;/p&gt;

&lt;p&gt;接着在启动类加上服务发现注解，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
@EnableDiscoveryClient
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动类接着声明一个负载均衡的请求器@LoadBalanced，还有请求发起的工具RestTemplate&lt;/p&gt;
&lt;p&gt;如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
@EnableDiscoveryClient
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RibbonApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(RibbonApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
&lt;/span&gt;&lt;span&gt;

    @Bean
    @LoadBalanced
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RestTemplate();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接着我们在上一节文章中的两个provider1，provider2模块添加一下测试代码：如下：&lt;/p&gt;
&lt;p&gt;provider1:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package hjc.hello;


import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/5/8.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloController {

    @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String hello(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;provider2代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package hjc.hello;


import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/5/8.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloController {

    @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String hello(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接着我们用RestTemplate进行面向服务调用，不再面向IP调用。&lt;/p&gt;
&lt;p&gt;如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/5/8.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConsumerController {



    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;  RestTemplate restTemplate;

    @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/consumer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String helloConsumer() throws ExecutionException, InterruptedException {

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; restTemplate.getForEntity(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://HELLO-SERVICE/hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,String.&lt;span&gt;class&lt;/span&gt;).getBody();&lt;p&gt;}
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着启动Ribbon模块，我们看一下Eureka仪表盘，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180510214829108-682598453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到多了RIBBON-CONSUMER服务&lt;/p&gt;

&lt;p&gt;接着我们继续在已经运行的Ribbon模块上，在浏览器输入localhost:8082,运行结果如下：&lt;/p&gt;
&lt;p&gt;　　hello1或者hello2，&lt;/p&gt;
&lt;p&gt;可以看到hello1 ，hello2轮询方式出现，因为默认就是轮询方式&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;到这里我们还发现Ribbon还是单点故障的，这里我来解释一下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　因为这里我是单独建立一个SpringBoot的Ribbon模块，实际使用并不是这样用的，Ribbon是客户端的负载均衡，是跟客户端绑定在一起的，我们实际运用的时候往往会在服务里面引入一个客户端负载均衡去连接到Eureka客户中心，&lt;/p&gt;
&lt;p&gt;这样我们还存在Ribbon单点故障吗？不存在了，因为我们服务提供者就是高可用的，这样还是个单点吗？这里读者的思考必须转过弯来，这一篇随笔我只是为了演示Ribbon,实际使用并不是这样用的。&lt;/p&gt;
</description>
<pubDate>Thu, 10 May 2018 15:06:00 +0000</pubDate>
<dc:creator>蜗居在小黑屋操控世界</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangjuncong/p/9022055.html</dc:identifier>
</item>
<item>
<title>QUIC协议的分析，性能测试以及在QQ会员实践 - 腾讯WeTest</title>
<link>http://www.cnblogs.com/wetest/p/9022214.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wetest/p/9022214.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;WeTest 导读&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你听过HTTPS、HTTP2.0、SPDY，但是这些应用层协议都是基于可靠的传输层协议TCP来实现的。那么，基于高效的UDP协议有没有一种相对可靠的应用层协议呢？&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Why QUIC?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;你听过HTTPS、HTTP2.0、SPDY，但是这些应用层协议都是基于可靠的传输层协议TCP来实现的。那么，基于高效的UDP协议有没有一种相对可靠的应用层协议呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223709979-217992775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 图1 why quic?&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;What is QUIC?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Quick UDP Internet Connection(QUIC)协议是Google公司提出的基于UDP的高效可靠协议。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;说它高效，是因为使用了无连接的UDP而不是迭代周期更长的需要修改系统内核网络栈的TCP协议。&lt;br/&gt;说它可靠，是因为将改进了的可靠TCP的协议特征用到了QUIC上。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;同时，也复用和改进了HTTP2的典型特征，譬如二进制分帧，多路复用，header压缩等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223718848-443035167.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2 what's quic?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;How QUIC works?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;建立连接&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、基于TCP+TLS的HTTP2建连&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;出于HTTP的明文和无法验证服务器的真实性，在TCP的基础上引入了TLS协议，目前广泛使用的HTTPS是基于TCP+TLS协议，HTTP2也被主流浏览器默认支持TLS。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;但对于建立连接的耗时而言，TCP本身就需要握手时延，而TLS协议为了使得客户端和服务器端在不安全的网络通信中协商出后续安全通信所需的加密私钥，更是要经过额外2次RTT(RoundTrip Time往返时间)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223726806-2103569862.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图3 TCP+TLS建连过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;除了TCP建立连接过程，TLS握手过程要经过如下步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、客户端提供加密套件（算法）列表，版本等信息&lt;/p&gt;
&lt;p&gt;2、服务器端提供自己的证书，选择的加密套件，非对称加密公钥（自己保留私钥）等&lt;/p&gt;
&lt;p&gt;3、客户端提供自己的证书，用服务器公钥和加密套件加密的自己的私钥&lt;/p&gt;
&lt;p&gt;4、服务端用保留的私钥解密客户端传来的加密私钥，得到的私钥即为后续加密传输使用的对称密钥，最后完成握手&lt;/p&gt;

&lt;p&gt;此时，双方协商出了对称密钥。基于TCP+TLS的HTTP2建连过程结束，大约需要耗时200-300ms。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、 QUIC建连&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了保证安全，QUIC也是加密传输数据的，所以在QUIC的建连过程中也需要双方协商出一个加密私钥。但与TLS不同，QUIC采用的加密算法仅需要一个RTT就能实现密钥交换，并且该算法也被用于目前正在草案阶段的TLS1.3协议。该就是Diffie-Hellman密钥交换算法。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223803894-1488820547.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图4 Diffie-Hellman算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到，客户端和服务端各自保留了自己的私钥a和b，通过交换各自的公钥B和A，以及基底G和很大的质数P，双方就能计算出相等的私钥S，这个S就是加密传输的对称密钥。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;另外，根据离散对数的不可逆，即使拿到G,P,和质数B，也很难推导出私钥b（同理私钥a），也就保证了计算密钥的安全。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;该过程对应到QUIC建连的过程中如下图&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223810759-505023789.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图5 1RTT建连&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、客户端发起Inchoate client hello&lt;/p&gt;
&lt;p&gt;2、服务器返回Rejection，包括密钥交换算法的公钥信息，算法信息，证书信息等被放到server config中传给客户端&lt;/p&gt;
&lt;p&gt;3、客户端发起client hello，包括客户端公钥信息&lt;/p&gt;

&lt;p&gt;此时，双方各自计算出了对称密钥。QUIC的1RTT建连过程结束，平均只耗时100ms以内。&lt;/p&gt;

&lt;p&gt;后续发起连接的过程中，一旦客户端缓存或持久化了server config，就可以复用并结合本地生成的私钥进行加密数据传输了，不需要再次握手，从而实现0RTT建立连接。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;协商升级&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;一般情况下，Chrome浏览器和服务器端协商使用QUIC协议要经过如下步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、客户端发出tcp请求&lt;/p&gt;
&lt;p&gt;2、服务端如果支持quic可以通过响应头alt-svc告知客户端&lt;/p&gt;
&lt;p&gt;3、客户端同时发起tcp连接和quic连接竞赛&lt;/p&gt;
&lt;p&gt;4、一旦quic建立连接获胜则采用quic协议发送请求&lt;/p&gt;
&lt;p&gt;5、如遇网络或服务器不支持quic/udp，客户端标记quic为broken&lt;/p&gt;
&lt;p&gt;6、传输中的请求通过tcp重发&lt;/p&gt;
&lt;p&gt;7、5min后尝试重试quic，下一次尝试增大到10min&lt;/p&gt;
&lt;p&gt;8、一旦再次成功采用quic并把broken标记取消&lt;/p&gt;

&lt;p&gt;其中，支持quic的alt-svc头部信息如下图示，ma为有效时间（单位秒），v为支持的quic版本信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223826102-674298838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图6 alt-svc头信息&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;研究过程中发现，除了alt-svc header，http2.0下服务端还可以通过支持alt-svc frame来让客户端在第一次请求的时候就走新协议，比通过header让浏览器第二次才能请求新协议更高效，这个留给后续研究。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;连接迁移&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TCP使用四元组（源IP，源端口，目的IP，目的端口）来标识一条连接，当四元组中的IP或端口任一个发生变化了连接就需要重新建立，从而不具备连接迁移的能力。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;而QUIC使用了connection id对连接进行唯一标识。即使网络从4G变成了wifi，只要两次连接中的connection id不变，并且客户端或者服务器能通过校验，就不需要重新建立连接，连接迁移就能成功。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;改进的多路复用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在SPDY协议出现以前，每个HTTP请求都需要建立一条TCP连接，那么如果希望请求并行，就需要同时开启多条TCP连接（都是有建连代价的）。而大多数浏览器对于同一个域名可以建立的最大TCP连接数是有限制的，所以，如果超出限制，更多的请求资源是无法并行的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;SPDY协议以来提出的多路复用，是让所有请求基于一条TCP连接，解决了上述的问题但同时引入了新的问题——队头阻塞，如果某个资源的某个包丢失了，因为TCP是保证时序的，就会在接收端形成队头阻塞，TCP此时无法区分各个资源的包是否关联，因此会停止处理所有资源直到丢包恢复。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223837035-275432930.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图7 基于TCP的多路复用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;QUIC也有多路复用，但是QUIC是基于UDP的，UDP不需要保证包的时序，只会在接收包的时候对包进行重组，因而不存在等待丢包恢复的队头阻塞问题，这样某个资源的包丢失只会影响自身不会影响到其他资源的继续传输，所以是改进的多路复用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223843400-304488573.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图8 基于QUIC的多路复用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;双级别流量控制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;QUIC是多路复用的，多条stream可以建立在一条connection上，所以QUIC的流量控制不仅基于单个stream，还基于connection。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;stream级别的流控能够控制单stream的数据发送情况。另外，接收窗口的收缩取决于最大接收字节的偏移而不是所有已接受字节的总和，它不像tcp流控，不会受到丢失数据的影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223853057-1761717946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图9 stream流控&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果满足(flow control receive offset - consumed bytes) &amp;lt; (max receive window / 2)&lt;br/&gt;会触发WINDOW_UPDATE frame的发送来增大发送窗口大小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223906067-1901737156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图10 WINDOW_UPDATE触发前&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223913141-685255609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 图11 WINDOW_UPDATE触发后&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;connection级别流控算法和stream一致，各项数值是所有stream的总和。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;connection级别的流控存在的必要是，即使做好了stream流控，但如果stream过多也会导致connection过度消耗带宽和系统资源；而且即使某一条stream过慢，其他stream依然能触发&lt;/p&gt;

&lt;p&gt;connection级别的WINDOW_UPDATE，从而不会被影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223920279-278118793.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图12 connection流控&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;拥塞控制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们知道TCP有多种拥塞控制算法，当遇到网络拥塞会通过减包等方式来避免网络环境恶化。但是，UDP本身是没有拥塞控制的，一旦不加约束的使用会导致侵占其他“守规矩”的网络协议的带宽。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;所以，为了避免上述情况，基于UDP的QUIC协议借鉴了TCP的一些优秀的拥塞控制算法，如默认使用Cubic，同时，为了避免AIMD机制带来的带宽利用率低，采用了packet pacing来探测网络带宽。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;思路是，QUIC会通过追踪包的到达时间来预测当前带宽的使用情况，以决定是否提高，保持或者减少发送包的速率来避免网络拥塞。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223928905-536245805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图13 packet pacing&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;丢包恢复&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似拥塞控制，除了基于TCP的一些丢包恢复机制，如：TLP，FACK。QUIC的丢包恢复也在一些方面做了改进。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;比如：通过引入严格递增的sequence number使得计算RTT更加精确。更精确的RTT也意味更精确的RTO和超时重传机制。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;还比如我们知道TCP中有个SACK选项，该选项打开时用于记录传输过程中一些没有被确认的数据的范围，便于后续定向重传多组丢失数据，而不是全部重传，所以更多的范围便于更多的选择重传，也意味着更少的重传包频率。但TCP最多支持3个SACK范围，而QUIC能支持255个。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;除了上述基于TCP的改进的丢包恢复特性以外，早期的QUIC版本还有一个丢包恢复机制，就是FEC（Forward Error Correction），这个特性虽然目前处于正在改造阶段（可能会浪费带宽并且作用不是很明显），但是依然是一个有意思的解决方案。FEC的思路是通过在一组包（一般是10个）中，通过增加一个FEC包，并用FEC和每个包进行XOR，如果一旦有丢包，那么将FEC包和其余包XOR，得到的FEC包就是那个丢包，所以一组包最多只能恢复一个丢包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223936526-1918221228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;更多特性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;除了上述的主要特性，QUIC还有一些其他特性，如：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;● 通过header stream保证流顺序&lt;/p&gt;
&lt;p&gt;● 底层保证连接持久&lt;/p&gt;
&lt;p&gt;● 源地址令牌防止地址欺骗&lt;/p&gt;
&lt;p&gt;● 握手时压缩证书避免放大攻击&lt;/p&gt;

&lt;p&gt;在此不深入研究，大家有兴趣可以翻阅Google相关的文档查阅。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;业界应用情况&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;● Google超过50%的请求来自QUIC&lt;/p&gt;
&lt;p&gt;● 目前Youtube有20%的流量来自QUIC&lt;/p&gt;
&lt;p&gt;● 微博移动端全面支持QUIC协议&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;测试demo&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;● 客户端&lt;/strong&gt;&lt;br/&gt;最新版本PC Chrome（控制开启/关闭quic）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 服务器&lt;/strong&gt;&lt;br/&gt;经stgw改造支持quic的nginx&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 页面地址（机器被回收，后续会更换机器供测试）&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://stgwquic.kof.qq.com/club/platform/act/gift/test1.html&quot;&gt;https://stgwquic.kof.qq.com/club/platform/act/gift/test1.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://stgwquic.kof.qq.com/club/platform/act/gift/test2.html&quot;&gt;https://stgwquic.kof.qq.com/club/platform/act/gift/test2.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://stgwquic.kof.qq.com/club/platform/act/gift/test3.html&quot;&gt;https://stgwquic.kof.qq.com/club/platform/act/gift/test3.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 网络&lt;/strong&gt;&lt;br/&gt;公司staffwifi&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 抓包工具&lt;/strong&gt;&lt;br/&gt;wireshark&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 效果对比&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223946843-173400727.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;图15 HTTP1.1协议的页面&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223956465-65746837.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;图16 HTTP2协议的页面&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510224003808-623024835.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;图17 QUIC协议的页面&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510224018186-222890630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;图18页面请求20个，大小2MB&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510224025750-73203067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;图 19 页面请求15个，大小465KB&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;公司业务接入步骤&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;● 客户端支持&lt;/strong&gt;&lt;br/&gt;X5内核团队（移动端）&lt;/p&gt;
&lt;p&gt;依赖用户浏览器支持QUIC情况（PC端）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 服务端支持&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;STGW团队&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 业务自身&lt;/strong&gt;&lt;br/&gt;按照路径灰度，控制灰度策略&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;QQ会员页面接入效果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以上测试demo数据是基于公司良好的网络情况下测试得到的，在实际运用过程中，大家可能更关心在复杂的网络环境下QUIC的表现。于是QQ会员团队通过灰度现网的一个页面来考察QUIC在现网的性能情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 页面情况&lt;/strong&gt;&lt;br/&gt;Android日PV100w，页面大小95KB&lt;br/&gt;总请求30个，其中主资源请求1个，CDN请求24个，其他请求5个&lt;br/&gt;展示部分依赖php直出和js渲染&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 灰度情况&lt;/strong&gt;&lt;br/&gt;QUIC请求1个（php页面主资源），HTTP2请求29个&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 灰度策略&lt;/strong&gt;&lt;br/&gt;客户端每天放量，对比灰度过程中页面主资源的HTTP2和QUIC的性能数据&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 灰度效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510224034766-834086325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图20 QQ会员页面QUIC灰度情况&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 效果说明&lt;/strong&gt;&lt;br/&gt;因为建连依赖于1RTT和0RTT机制，使得QUIC建连平均耗时仅需46ms，比HTTP2的225ms减少180ms左右。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;由于目前灰度量只占到总请求量的10%，因此更严谨的性能对比数据有待进一步提高灰度范围，以上仅作现阶段参考。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;但依然可以看到QUIC在现网环境总体表现忧于HTTP2。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在实践QUIC的过程中，我们也遇到了一些需要注意的问题。&lt;/p&gt;
&lt;p&gt;● &lt;strong&gt;QUIC支持头部alt-svc的缓存机制面向整个域名&lt;/strong&gt;&lt;br/&gt;业务即使只在一个页面路径下加了支持头部（STGW可以是路径级别支持，X5只能是域名级别支持），浏览器也会根据头部的缓存时长作用于用户访问该域名下的其他页面，但STGW可能只支持了路径级别。所以灰度过程中，尽量使用有独立域名的页面。从而保证尽量不影响其他页面的请求情况（虽然QUIC请求失败会降级H2），尽量减少ma缓存时间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 客户端对于QUIC的协商机制有待改善&lt;/strong&gt;&lt;br/&gt;在X5目前的实现机制中，无论如何首次请求都会基于HTTP2，后续才会尝试QUIC，但如果缓存时间设置的不够长（譬如1天），会使得用户一般1天内很难通过再次请求走到QUIC。所以，目前我们做的是推动X5在请求时候让白名单链接直接尝试QUIC。同时，避免缓存时间随着用户退出手Q而失效，推动让其落地。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 目前客户端基于X5的QUIC与一些基于缓存和预加载的页面秒开方案冲突&lt;/strong&gt;&lt;br/&gt;如果你们的页面是基于X5内核，但是使用了上述类似的技术，那么存在一个问题是原本直接通过X5走QUIC协议的页面不直接走X5了，而是基于你当前方案的缓存或者自定义的webview请求方式。于是通过统计数据会发现QUIC的请求量很少，因为上述技术目前还不支持QUIC协议。当前的做法是在QUIC和该方案中二选一。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● CDN请求灰度需要自支持&lt;/strong&gt;&lt;br/&gt;由于CDN请求不基于STGW代理，因而需要CDN团队针对业务方域名灰度支持，目前CDN整体处于运营商灰度QUIC阶段。在此之前如果需要灰度CDN请求就需要业务方自己处理转发。&lt;/p&gt;

&lt;p&gt;● &lt;strong&gt;运营商的Qos影响需要更完善的上报数据进行评估&lt;/strong&gt;&lt;br/&gt;使用QUIC协议比较担心的一个问题就是在网络质量差的情况下运行商Qos会对其产生怎样的影响。从目前整体的统计数据，包括慢速用户占比等情况来看，影响不是很大。后续需要推动各方完善上报监控该情况下耗时。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;未来工作List&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;● 和X5团队一起解决首次请求必走HTTP2请求问题&lt;/p&gt;
&lt;p&gt;● 和X5团队一起解决alt-svc缓存有效期落地问题&lt;/p&gt;
&lt;p&gt;● 和终端团队一起解决秒开方案下Webview对QUIC的支持，争取既能使用QUIC协议又能使用秒开方案&lt;/p&gt;
&lt;p&gt;● 配合CDN团队验证QUIC扩大灰度的支持效果&lt;/p&gt;
&lt;p&gt;● 推动各方更细粒度的数据统计完善&lt;/p&gt;

&lt;p&gt;参考资料&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.chromium.org/quic&quot;&gt;http://www.chromium.org/quic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.google.com/document/d/1gY9-YNDNAB1eip-RTPbqphgySwSNSDHLq9D5Bty4FSU/edit&quot;&gt;https://docs.google.com/document/d/1gY9-YNDNAB1eip-RTPbqphgySwSNSDHLq9D5Bty4FSU/edit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;QUIC Crypto Adam Langley Wan-Teh Chang&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000007060218&quot;&gt;https://segmentfault.com/a/1190000007060218&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000007075961&quot;&gt;https://segmentfault.com/a/1190000007075961&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xiaofei0859/article/details/77512746&quot;&gt;https://blog.csdn.net/xiaofei0859/article/details/77512746&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://fasterdata.es.net/host-tuning/packet-pacing/&quot;&gt;http://fasterdata.es.net/host-tuning/packet-pacing/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imququ.com/post/http-alt-svc.html&quot;&gt;https://imququ.com/post/http-alt-svc.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HTTP over UDP: an Experimental Investigation of QUIC&lt;/p&gt;
&lt;p&gt;QUIC FEC v1 Author: ianswett@google.com Last Updated: 2016-02-19&lt;/p&gt;
&lt;p&gt;Understanding QUIC wire protocol&lt;/p&gt;
&lt;p&gt;IETF93 QUIC BarBoF: Congestion Control and Loss Recovery&lt;/p&gt;
&lt;p&gt;QUIC: Performance and Security at the Transport Layer&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;WeTest压测大师&lt;/span&gt;——&lt;/strong&gt;为了帮助开发者发现服务器端的性能瓶颈，腾讯WeTest开放了压力测试功能，通过基于真实业务场景和用户行为进行压力测试，实现针对性的性能调优，降低服务器采购和维护成本。&lt;/p&gt;

&lt;p&gt;目前压测大师服务了包括王者荣耀、QQ飞车手游、QQ炫舞手游等多款高星级手游， 也服务了QQ、NOW直播、摩拜单车、企鹅FM等明星产品。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;目前&lt;/span&gt;WeTest&lt;span&gt;压测大师对外开放中，点击链接：&lt;/span&gt;&lt;a href=&quot;http://wetest.qq.com/gaps/?from=content_cnblogs&quot;&gt;&lt;span&gt;http://wetest.qq.com/gaps&lt;/span&gt;&lt;/a&gt; &lt;span&gt;即可使用。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;如果对使用当中有任何疑问，欢迎联系腾讯WeTest企业QQ：800024531&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;腾讯WeTest有奖征文活动进行中，欢迎投稿！了解详情： http://wetest.qq.com/lab/view/379.html&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


</description>
<pubDate>Thu, 10 May 2018 14:47:00 +0000</pubDate>
<dc:creator>腾讯WeTest</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wetest/p/9022214.html</dc:identifier>
</item>
<item>
<title>在Web中获取MAC地址 - tosser</title>
<link>http://www.cnblogs.com/tosser/p/9022187.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tosser/p/9022187.html</guid>
<description>&lt;p&gt;　　很多时候都很难琢磨客户在想什么，也许是自己业务经验不足，也许是客户要显示出他在软件方面也非常的专业。记得以前听过一个故事，说一个富人想娶个媳妇，然后他比较钟意的有三个女人，然后就想从三个女人中选一个，他分别给了三个女人各一千块钱，并对她们说，“我这里有一个房间，请你们用自己的一千块钱尽可能的将房间填满”。第一个女人，将1000块钱都买了棉花，但是这些棉花只填满了整个房间的三分之一；第二个女人，将1000块钱都买了气球，但是这些气球也只填满了整个房间的三分之二；第三个女人，花了1块钱买了一支蜡烛，让蜡烛的光照亮了整个房间。然后……这个富人愉快的娶了其中胸部最大的那个女人。这个故事告诉我们，有时你根本不知道客户到底要的是什么！&lt;/p&gt;

&lt;p&gt;解决安全登录的问题&lt;/p&gt;
&lt;p&gt;　　去给客户演示系统，演示完刚开发完的系统以后客户就将我们的系统批的遍体鳞伤，这时才知道自己的系统比想象中的更不堪。在如此不堪的系统面前，客户又提出了一个需求，要限制用户的登录机器。补充一下，演示的系统是一个ERP系统，是BS结构的，用Java写的。客户要求，要限制能够登录系统的电脑，需要绑定MAC地址。因为系统里的数据比较重要，不能让员工回家登录系统，因此必须要进行限制。&lt;/p&gt;

&lt;p&gt;解决思路&lt;/p&gt;
&lt;p&gt;　　这样的问题，能想到的解决思路只有两个：&lt;/p&gt;
&lt;p&gt;　　1、在EXE文件中嵌入一个浏览器控件，浏览器中显示ERP的页面，EXE获取MAC地址后提交到服务器。感觉这样先是要处理EXE提交的MAC地址，然后还要和页面交互，想想貌似比较复杂，就否掉了。&lt;/p&gt;
&lt;p&gt;　　2、写一个OCX，让页面中的JS与OCX进行交互，OCX获取到MAC地址后，将MAC返回给JS，JS通过DOM操作写入到对应的表单中，然后和用户名、密码一起提交给服务器。感觉这个好像实现起来还比较简单。就这个吧！&lt;/p&gt;

&lt;p&gt;OCX中获取MAC地址的关键代码&lt;/p&gt;
&lt;p&gt;　　OCX中可以直接调用Windows操作系统的API函数，写起来也比较简单，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; BSTR CGetMacCtrl::GetMacAddress(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    AFX_MANAGE_STATE(AfxGetStaticModuleState());
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    CString strResult;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: 在此添加调度处理程序代码&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     ULONG outBufLen = &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(IP_ADAPTER_ADDRESSES);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     PIP_ADAPTER_ADDRESSES pAddresses = (IP_ADAPTER_ADDRESSES*)&lt;span&gt;malloc&lt;/span&gt;&lt;span&gt;(outBufLen);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (pAddresses ==&lt;span&gt; NULL) 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Make an initial call to GetAdaptersAddresses to get the necessary size into the ulOutBufLen variable&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(GetAdaptersAddresses(AF_UNSPEC, &lt;span&gt;0&lt;/span&gt;, NULL, pAddresses, &amp;amp;outBufLen) ==&lt;span&gt; ERROR_BUFFER_OVERFLOW)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(pAddresses);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         pAddresses = (IP_ADAPTER_ADDRESSES*)&lt;span&gt;malloc&lt;/span&gt;&lt;span&gt;(outBufLen);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (pAddresses ==&lt;span&gt; NULL) 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     wchar_t acMAC[&lt;span&gt;32&lt;/span&gt;] = { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(GetAdaptersAddresses(AF_UNSPEC, &lt;span&gt;0&lt;/span&gt;, NULL, pAddresses, &amp;amp;outBufLen) ==&lt;span&gt; NO_ERROR)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If successful, output some information from the data we received&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(PIP_ADAPTER_ADDRESSES pCurrAddresses = pAddresses; pCurrAddresses != NULL; pCurrAddresses = pCurrAddresses-&amp;gt;&lt;span&gt;Next)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 确保MAC地址的长度为 00-00-00-00-00-00&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(pCurrAddresses-&amp;gt;PhysicalAddressLength != &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             wsprintf((LPWSTR)acMAC, _T(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%02X-%02X-%02X-%02X-%02X-%02X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; (pCurrAddresses-&amp;gt;PhysicalAddress[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]),
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; (pCurrAddresses-&amp;gt;PhysicalAddress[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]),
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; (pCurrAddresses-&amp;gt;PhysicalAddress[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]),
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; (pCurrAddresses-&amp;gt;PhysicalAddress[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]),
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; (pCurrAddresses-&amp;gt;PhysicalAddress[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]),
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; (pCurrAddresses-&amp;gt;PhysicalAddress[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    } 
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(pAddresses);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     strResult =&lt;span&gt; acMAC;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; strResult.AllocSysString();
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　代码差不多就这样吧，我用的VS2012写的ActiveX，编译生成OCX。&lt;/p&gt;

&lt;p&gt;在Web中进行测试&lt;/p&gt;
&lt;p&gt;　　在Web中测试也比较简单，通过clsid引入OCX文件，然后JS调用OCX文件中的函数，函数返回MAC地址给JS，JS进行DOM操作，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;!DOCTYPE html&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &amp;lt;head&amp;gt;
&lt;span&gt; 4&lt;/span&gt;         &amp;lt;meta charset=&quot;utf8&quot;&amp;gt;
&lt;span&gt; 5&lt;/span&gt;         &amp;lt;title&amp;gt;获取Mac地址Demo&amp;lt;/title&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;/head&amp;gt;
&lt;span&gt; 7&lt;/span&gt;     &amp;lt;body&amp;gt;
&lt;span&gt; 8&lt;/span&gt;         &amp;lt;object id=&quot;getmac&quot; classid=&quot;clsid:52931A6A-93B4-4750-8FE6-B666E90B1D54&quot; 
&lt;span&gt; 9&lt;/span&gt;         codebase=&quot;'getmac.ocx'&quot; style=&quot;display:none&quot;&amp;gt;&amp;lt;/object&amp;gt;
&lt;span&gt;10&lt;/span&gt;         
&lt;span&gt;11&lt;/span&gt;         &amp;lt;h1&amp;gt;MAC:&amp;lt;/h1&amp;gt;
&lt;span&gt;12&lt;/span&gt;         &amp;lt;span id=&quot;mac&quot;&amp;gt;&amp;lt;/span&amp;gt;
&lt;span&gt;13&lt;/span&gt;         &amp;lt;input type=&quot;text&quot; id=&quot;macAddress&quot; name=&quot;macAddress&quot; value=&quot;&quot; /&amp;gt;
&lt;span&gt;14&lt;/span&gt;     &amp;lt;/body&amp;gt;
&lt;span&gt;15&lt;/span&gt;         &amp;lt;script&amp;gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; mac =&lt;span&gt; getmac.GetMacAddress();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             document.getElementById(&quot;mac&quot;).innerHTML =&lt;span&gt; mac;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             document.getElementById(&quot;macAddress&quot;).value =&lt;span&gt; mac;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             document.getElementById(&quot;macAddress&quot;).style.display = ''&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &amp;lt;/script&amp;gt;
&lt;span&gt;21&lt;/span&gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过object标签引入了OCX文件，定义了id为getmac，然后通过getmac来调用OCX中的函数GetMacAddress()获取MAC地址。&lt;/p&gt;

&lt;p&gt;　　经过简单的测试还是可以的，然后我整合进入了JeeSite系统中（我其他文章说过，我们的项目是在JeeSite上做二次开发），测试以后发现ERP的页面对IE浏览器支持不好。因为OCX只能在IE浏览器中使用，结果这个方案就放弃了。后来，找到一个开源的Chrome的插件，也完成MAC地址的获取，该Chrome插件分为两部分，一部分是Chrome的插件，另外一个是EXE文件，该EXE文件也是与插件进行通信的，由于该插件不是我写的，我就不往这里放了。总之，最好还是把客户端这个需求解决了。OCX的方法就留在这里吧！也许，我以后会用到也说不定呢。&lt;/p&gt;
</description>
<pubDate>Thu, 10 May 2018 14:41:00 +0000</pubDate>
<dc:creator>tosser</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tosser/p/9022187.html</dc:identifier>
</item>
<item>
<title>用js来实现那些数据结构—目录 - Zaking</title>
<link>http://www.cnblogs.com/zaking/p/9016600.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zaking/p/9016600.html</guid>
<description>&lt;p&gt;　　首先，有一点要声明，下面所有文章的所有内容的代码，都不是我一个人独立完成的，它们来自于一本叫做《学习JavaScript数据结构和算法》（第二版），人民邮电出版社出版的这本书。github代码地址是&lt;a href=&quot;https://github.com/loiane/javascript-datastructures-algorithms&quot; target=&quot;_blank&quot;&gt;https://github.com/loiane/javascript-datastructures-algorithms&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　先说下我个人对这本书的看法吧。对于数据结构的介绍不够深入和详细，对于那些计算机专业的前端从业者来说，十分的鸡肋。而对于那些非计算机专业，又完全没接触过数据结构是什么东西的前端coder来说。其中的讲解又十分的不具体，对于思路的讲解并不明了。&lt;/p&gt;
&lt;p&gt;　　当然，我也在网上找到了很多类似于本系列的文章，大多数都是基于此书的代码，但是要么就是完全复制的代码，解释十分的少或者几乎没有，要么就是整体不清不楚，让人不知所以然。&lt;/p&gt;
&lt;p&gt;　　所以，我就想在学习的过程中把自己的理解，自己对于这个数据结构的思路和每一行代码在上下文中所起到的作用等等写出来。希望大家在学习数据结构的时候可以走的更容易一点。&lt;/p&gt;
&lt;p&gt;　　在学习的过程中，有不理解的地方，书中讲的不易理解的地方，都是自己画图，自己去找资料，然后再回来结合代码，给出一个“自认为”还不错的解释。&lt;/p&gt;
&lt;p&gt;　　终于，完成了有关用js来实现数据结构的所有内容，前后大概花了一个多月的时间，一共16篇文章。有最基本的js数组的详细讲解。也有非线性的散列表、树和图。其实对于用js来实现数据结构，个人感觉更多要学习的是那种数据结构的思想。一旦你理解了这个数据结构的思想，那么自然，实现代码也不过就是时间的问题了。&lt;/p&gt;
&lt;p&gt;　　本系列所有的内容，都是我一个字一个字打出来的，包括书中的代码和自己加上的注释，当然，其中概念性的问题一部分来自于此书，书中解释不清楚的我都在文中附上了资料的链接。&lt;/p&gt;
&lt;p&gt;　　那么，如果各位老爷在阅读的时候有不理解或者觉得不清楚的地方，还希望可以留言提出。互相学习。&lt;/p&gt;
&lt;p&gt;　　噢，对，还是要说一下我觉得这个系列的重点吧。重点在后6篇，也就是从散列表开始的非线性数据结构。而对于前面的栈，队列等。是你学习后面的基础，因为在树，图等数据结构的实现中，都用到了前面的代码。&lt;/p&gt;
&lt;p&gt;　　所以，大家如果想要学习数据结构。那么个人觉得这系列文章是个不错的开始。或许你会问，我看完这系列文章会学到什么？我真的就懂了数据结构么？当然没有。就单单拿一个图来说，足够写一本厚厚的书了。所以，你学完这个系列，最多只是打开了数据结构的大门，迈出了你的右脚（或者左脚）向门里面的世界探了探，连走进这个大门都不算。&lt;/p&gt;
&lt;p&gt;　　我完成这16篇文章，大概花了四十个小时的时间。如果你想要真的弄懂下面目录内的所有内容，每天一个小时，大概需要花上一个月。当然，不仅仅是读一遍，而是跟着文章中的代码和注释完整的过了一遍自己的脑子。&lt;/p&gt;
&lt;p&gt;　　最后说一下本系列的使用方法吧，首先，你把代码复制到本地，去掉所有的注释，然后就着文章，看一遍代码。然后自己打一遍代码，有不明白的地方再去看注释。这是本系列的服用说明。&lt;/p&gt;
&lt;p&gt;　　好了，不罗嗦了。就到这里吧。也算是给自己的交上了一份6分的答卷。&lt;/p&gt;

&lt;p&gt;　　下面是目录：&lt;/p&gt;
&lt;p&gt;　　　　1、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl05_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8686676.html&quot;&gt;用js来实现那些数据结构01（数组篇01-数组的增删）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 　　　　2、 &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8711731.html&quot;&gt;用js来实现那些数据结构02（数组篇02-数组方法）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　3、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8784575.html&quot;&gt;用js来实现那些数据结构03（数组篇03-排序及多维数组）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　4、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8799326.html&quot;&gt;用js来实现那些数据结构04（栈01-栈的实现）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　5、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8837056.html&quot;&gt;用js来实现那些数据结构05（栈02-栈的应用）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　6、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8863434.html&quot;&gt;用js来实现那些数据结构06（队列）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　7、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl07_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8870705.html&quot;&gt;用js来实现那些数据结构07（链表01-链表的实现）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　8、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl06_DayList_TitleUrl_1&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8886941.html&quot;&gt;用js来实现那些数据结构08（链表02-双向链表）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　9、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl06_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8902219.html&quot;&gt;用js来实现那些数据结构09（集合01-集合的实现）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　10、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl05_DayList_TitleUrl_1&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8905884.html&quot;&gt;用js来实现那些数据结构10（集合02-集合的操作）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　11、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl05_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8909401.html&quot;&gt;用js来实现那些数据结构11（字典）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　12、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8950607.html&quot;&gt;用js来实现那些数据结构12（散列表）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　13、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8964937.html&quot;&gt;用js来实现那些数据结构13（树01-二叉搜索树的实现）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　14、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8976362.html&quot;&gt;用js来实现那些数据结构14（树02-AVL树）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　15、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8992910.html&quot;&gt;用js来实现那些数据结构15（图01）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　16、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/9004976.html&quot;&gt;用js来实现那些数据结构16（图02-图的遍历）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 10 May 2018 12:37:00 +0000</pubDate>
<dc:creator>Zaking</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zaking/p/9016600.html</dc:identifier>
</item>
</channel>
</rss>