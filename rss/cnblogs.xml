<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>函数操作之函数参数操作 - 马一特</title>
<link>http://www.cnblogs.com/mayite/p/8657738.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mayite/p/8657738.html</guid>
<description>&lt;p&gt;&lt;strong&gt;在了解函数参数之前，我们先来回顾一下，上次讲解过的内容&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;函数的作用&lt;/h2&gt;
&lt;h3&gt;1 函数可以使代码组织结构清楚，结构性强，便于阅读&lt;/h3&gt;
&lt;h3&gt;2 遇到重复内容，可以用函数代替，避免代码冗余&lt;/h3&gt;
&lt;h3&gt;3 当程序功能需要修改时，我们只需要对函数内功能模块进行修改即可，便于维护&lt;/h3&gt;
&lt;h2&gt;函数的种类&lt;/h2&gt;
&lt;p&gt;定义一个函数很简单，函数的种类也很简单，这里分成三类，是为了便于我们记忆函数的特征，函数有三个特种，分别是作用，种类，返回值，三个特征下又分别对应三种特点&lt;/p&gt;
&lt;h3&gt;1 无参函数 def func():&lt;/h3&gt;
&lt;p&gt;比如用户输入功能模块会用到，请看如下代码演示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; interaction():
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;一个让用户输入用户名和密码的交互功能
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     name = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user name&amp;gt;&amp;gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     password = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&amp;gt;&amp;gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name,password)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name,password
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; interaction()
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2 有参函数 def func(x,y):&lt;/h3&gt;
&lt;p&gt;最常用的函数类型之一，请看如下代码演示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; function(x,y):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; x &amp;gt;&lt;span&gt; y:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(x)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(y)
function(&lt;/span&gt;1,2)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3 空函数 def func():&lt;/h3&gt;
&lt;p&gt;                   pass&lt;/p&gt;
&lt;p&gt;一般用于组织代码结构，用多个空函数定义出，程序员写代码所需要用的功能模块，就是想 先把工具列好，准备一个清单，按照这个清单去找工具，提高写代码效率&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; modification():
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; interaction():
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; function():
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;函数的返回值&lt;/h2&gt;
&lt;p&gt;函数用return接受其返回值，与print不同，&lt;/p&gt;
&lt;h2&gt;return接受返回值有三种形式&lt;/h2&gt;
&lt;p&gt;1 return = None  或者 不写return，就代表该函数没有返回值，也不需要再用 其返回值&lt;/p&gt;
&lt;p&gt;2 return = 1,2,3  return后面可以接多个返回值，以元组形式输出返回&lt;/p&gt;
&lt;p&gt;3 同一个函数，可以有多个 return，但是 只有执行一个return，该函数即结束，不在继续执行，就像做爱，只要射了，就不能在做了&lt;/p&gt;
&lt;p&gt;关于函数的参数&lt;/p&gt;
&lt;p&gt;函数的参数是我们学习函数知识的重点，也是难点，因此我们会花比较大的时间来对这一部分内容进行讲解&lt;/p&gt;
&lt;p&gt;十年前，python刚开始有人用的时候，我当时就提出这么一个观点 ：&lt;/p&gt;
&lt;p&gt;函数即变量，形参是变量名，实参是变量值，当函数调用时，将值绑定到变量名上面，函数调用结束时，解除绑定&lt;/p&gt;
&lt;p&gt;虽然这句话只是一个类比的说法，并不是正确的，但是对于帮助一些小白理解函数很有帮助，因此现在网上面很多都有这种说法，我要告诉你的是，“”函数即变量“”，这句话，是十年前我提出来的&lt;/p&gt;
&lt;p&gt;函数的参数有两种，一种是形参，就是形式上的参数，是写在定时的函数时括号里面的，另外一种是实参，也就是实际的参数，是在调用函数时，括号里面传入的实际的值&lt;/p&gt;
&lt;p&gt;参数有 四种 写作形式&lt;/p&gt;
&lt;h3&gt;1 位置参数&lt;/h3&gt;
&lt;p&gt;按照从左往右的顺序，依次对应往后写，‘如果形参是这么写的，那么请你猜一下，实参应该怎么写？&lt;/p&gt;
&lt;p&gt;没错，实参也是应该这么写，位置参数，形参与实参应该是一一对应的关系，这样的是实参也就叫做位置实参，请看如下代码演示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; function(x,y):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; x &amp;gt;&lt;span&gt; y:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(x)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(y)
function(&lt;/span&gt;1,2)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2 关键字参数&lt;/h3&gt;
&lt;p&gt;需要注意的是&lt;/p&gt;
&lt;p&gt;位置参数和关键字参数，可以联合使用，遵循的原则是位置参数要写在关键字参数的左边，原因自己体会，不写几个bug，你一定理解不了&lt;/p&gt;
&lt;p&gt;上面的形参写作是一一对应的，其实根据我们的经验判断，关键词参数应该类似于字典的那种表达方式，没错，这也正是我们关键字参数的由来，看来你已经跟上了我的博客思路，关键字参数，函数写形参的时候还是不变的，def func(x,y,z):  ，调用函数时 func(x=1,y=2,z=3)，对于同一个形参不能重复传值，当然一般也没人这么做，这种方式又很像format的第三种用法的那种写作形式，python就是这么神奇，万变不离其宗，总会有一个本源，真的就像是一门语言，英语里面很多词的用法不是也是这样吗？机智的你是不是早就发现了，请看如下代码演示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; function(x,y):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; x &amp;gt;&lt;span&gt; y:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(x)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(y)
function(y&lt;/span&gt;=1,x=2)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3 默认参数&lt;/h3&gt;
&lt;p&gt;默认参数的，按道理讲，前面两种参数可以够用了，默认参数出现是为了让我们的对参数进行传值的时候有些实参经常变化，而有些参数基本不怎么需要变化，为了减少代码量我们有了默认参数，需要注意的是：&lt;/p&gt;
&lt;p&gt;（1）默认参数应该在位置参数的右边&lt;/p&gt;
&lt;p&gt;（2）默认参数通常应该定义成不可变类型&lt;/p&gt;
&lt;p&gt;请看如下代码演示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; info(name,age,gender=&lt;span&gt;female)
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
我们对一所大学外语系的学生信息进行统计，大部分学生都是女生&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name,age,gender)
info(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jerry&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,21&lt;span&gt;)
info(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Lisa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;，19&lt;span&gt;)
info(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sara&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,22&lt;span&gt;)
info(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Albert&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,20,‘male’)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上代码输出结果&lt;/p&gt;
&lt;p&gt;Jerry,21,female&lt;/p&gt;
&lt;p&gt;Lisa,19,female&lt;/p&gt;
&lt;p&gt;Sara,22,female&lt;/p&gt;
&lt;p&gt;Albert,20,male&lt;/p&gt;
&lt;h3&gt;4 可变长参数&lt;/h3&gt;
&lt;p&gt;当我们在写函数时，很多情况下并不知道实参需要传多少个值，为了能够使程序正常运行，我们的可变长参数就是针对位置参数也好，关键字参数也好，可以有对应的，可变长参数来辅助，分别是*args 和**kwagrs，*后面的几个字母龟叔并没有要求我们必须这样写，一方面是为了我们写的代码和硅谷哪些人写的一样，另外一方面是让了我们写的代码更好理解（argument 参数，keyword 关键字）,所以统一这样写就好了，如果你想做一个野生程序员，我的博客不适合你读，请看如下代码演示&lt;/p&gt;
&lt;p&gt;位置参数与*args联用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; function(x,y,*&lt;span&gt;args)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(x,y)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(args)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(*&lt;span&gt;args)
function(&lt;/span&gt;1,2,3,4,5,6,7,8,)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上代码输出结果&lt;/p&gt;
&lt;p&gt;(1,2)&lt;/p&gt;
&lt;p&gt;3 4 5 6 7 8 &lt;/p&gt;
&lt;p&gt;(3,4,5,6,7,8)&lt;/p&gt;
&lt;p&gt;从结果中看，和你预想的运行结果一样吗?&lt;/p&gt;
&lt;p&gt;*的作用是‘’打散‘’，print(args),会把多余的实参汇聚成一个元祖的输出，而print(*args)，会把这个元祖打散，就是这么简单&lt;/p&gt;
&lt;p&gt;关键字参数与**kwargs 联用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; foo(x, y, z, **&lt;span&gt;kwargs):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(x, y, z)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(*&lt;span&gt;kwargs)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(kwargs)
foo(y&lt;/span&gt;=1, z=2, x=3, m=[4, 5, 6,],k=22)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上代码输出结果&lt;/p&gt;
&lt;p&gt;3 1 2&lt;br/&gt;m k&lt;br/&gt;{'m': [4, 5, 6], 'k': 22}&lt;/p&gt;

</description>
<pubDate>Tue, 27 Mar 2018 07:31:00 +0000</pubDate>
<dc:creator>马一特</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mayite/p/8657738.html</dc:identifier>
</item>
<item>
<title>CAS 之 Hello World（二） - ljmatlight</title>
<link>http://www.cnblogs.com/ljmatlight/p/8657733.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljmatlight/p/8657733.html</guid>
<description>&lt;p&gt;标签（空格分隔）： CAS&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ljmatlight/sso-examples-guides&quot;&gt;sso-examples-guides源码&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;由上节可知&lt;code&gt;Apereo CAS&lt;/code&gt;官方推荐使用 WAR Overlay 的方式进行部署：&lt;br/&gt;It is recommended to deploy CAS locally using the WAR Overlay method.&lt;br/&gt;那么我们就使用这种方式进行的相关的构建和部署。&lt;/p&gt;
&lt;p&gt;好处：&lt;br/&gt;好处即 maven-war-plugin/overlays 插件的好处。&lt;/p&gt;
&lt;p&gt;思想：&lt;br/&gt;WAR Overlay 的方式是基于 maven-war-plugin/overlays 插件&lt;br/&gt;&lt;a href=&quot;http://maven.apache.org/plugins/maven-war-plugin/overlays.html&quot;&gt;maven-war-plugin/overlays&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;JDK 1.8 or later&lt;/li&gt;
&lt;li&gt;Maven 3.2+&lt;/li&gt;
&lt;li&gt;spring boot&lt;/li&gt;
&lt;li&gt;Spring Tool Suite (STS)&lt;/li&gt;
&lt;li&gt;IntelliJ IDEA&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;cas-overlay-template&quot;&gt;cas-overlay-template&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/apereo/cas-overlay-template&quot;&gt;官方Github&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;git&lt;/span&gt; clone https://github.com/apereo/cas-overlay-template.git&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;笔者使用的IDE 是 &lt;code&gt;idea&lt;/code&gt;。&lt;br/&gt;创建模块：&lt;br/&gt;&lt;img src=&quot;https://files.cnblogs.com/files/ljmatlight/2.1-1.gif&quot; alt=&quot;cas-server&quot;/&gt;&lt;br/&gt;步骤一：将&lt;code&gt;cas-overlay-template&lt;/code&gt;的内容拷贝到&lt;code&gt;cas-server&lt;/code&gt; 模块中，&lt;br/&gt;步骤二：然后创建 &lt;code&gt;src/main/java&lt;/code&gt; 和 &lt;code&gt;src/main/resources&lt;/code&gt; 目录，&lt;br/&gt;步骤三：将&lt;code&gt;etc/cas/config&lt;/code&gt;目录中的文件拷贝到 &lt;code&gt;src/main/resources&lt;/code&gt; 目录下，&lt;br/&gt;步骤四：然后删除&lt;code&gt;etc/cas/config&lt;/code&gt;目录。&lt;br/&gt;步骤五：修改日志路径&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;   &lt;span class=&quot;kw&quot;&gt;&amp;lt;Property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;cas.log.dir&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;.&lt;span class=&quot;kw&quot;&gt;&amp;lt;/Property&amp;gt;&lt;/span&gt;
   # 修改为
   &lt;span class=&quot;kw&quot;&gt;&amp;lt;Property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;cas.log.dir&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;./logs&lt;span class=&quot;kw&quot;&gt;&amp;lt;/Property&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤六： 由于&lt;code&gt;cas&lt;/code&gt;服务器端默认是开启https的，先关闭。&lt;br/&gt;在&lt;code&gt;application.yml&lt;/code&gt; 文件中添加：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 关闭https
server:
  ssl:
    enabled: false&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;进入&lt;code&gt;cas-server&lt;/code&gt;模块执行 &lt;code&gt;build run&lt;/code&gt; 命令。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sso-examples-guides&lt;/span&gt;\cas-server&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;build run&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;访问入口： &lt;a href=&quot;http://localhost:8443/cas/login&quot; class=&quot;uri&quot;&gt;http://localhost:8443/cas/login&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://files.cnblogs.com/files/ljmatlight/2.1-2login.bmp&quot; alt=&quot;运行效果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认的静态账户信息， 账号：&lt;code&gt;casuser&lt;/code&gt;, 密码: &lt;code&gt;Mellon&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认账户，内置账户： oracle 是不是也有内置的账户密码？！&lt;br/&gt;为了纪念他们在项目中的贡献，作为一种荣誉的存在。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;使用https&lt;/li&gt;
&lt;li&gt;禁用静态账户&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;blockquote readability=&quot;7.2166172106825&quot;&gt;
&lt;p&gt;作者：随风浮云&lt;br/&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/ljmatlight&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/ljmatlight&lt;/a&gt;&lt;br/&gt;本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明。&lt;br/&gt;文中有不妥或者错误的地方，欢迎勘误，如果你有更好的建议，可以给我留言讨论，共同进步。&lt;br/&gt;互联网技术时效性较强，引用请慎重。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;</description>
<pubDate>Tue, 27 Mar 2018 07:30:00 +0000</pubDate>
<dc:creator>ljmatlight</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljmatlight/p/8657733.html</dc:identifier>
</item>
<item>
<title>以太坊区块和交易存储 - 宁生信</title>
<link>http://www.cnblogs.com/gregoryli/p/8657618.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gregoryli/p/8657618.html</guid>
<description>&lt;h2 id=&quot;区块存储&quot;&gt;区块存储&lt;/h2&gt;
&lt;h3 id=&quot;区块block是以太坊的核心数据结构之一block包含header和body两部分区块的存储是由leveldb完成的leveldb的数据是以键值对存储的&quot;&gt;区块(Block)是以太坊的核心数据结构之一，Block包含Header和Body两部分。区块的存储是由leveldb完成的，leveldb的数据是以键值对存储的。&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// BlockChain 表示了一个规范的链,这个链通过一个包含了创世区块的数据库指定. BlockChain管理了链的插入,还原,重建等操作.
//插入一个区块需要通过一系列指定的规则指定的两阶段的验证器.
// 使用Processor来对区块的交易进行处理. 状态的验证是第二阶段的验证器. 错误将导致插入终止.
//需要注意的是GetBlock可能返回任意不在当前规范区块链中的区块,
//但是GetBlockByNumber总是返回当前规范区块链中的区块.
type BlockChain struct {
    chainConfig *params.ChainConfig // Chain &amp;amp; network configuration
    cacheConfig *CacheConfig        // Cache configuration for pruning

    db     ethdb.Database // Low level persistent database to store final content in
    triegc *prque.Prque   // Priority queue mapping block numbers to tries to gc
    gcproc time.Duration  // Accumulates canonical block processing for trie dumping

    hc            *HeaderChain //只包含了区块头的区块链
    rmLogsFeed    event.Feed   // 底层数据库
    chainFeed     event.Feed   // 下面是很多消息通知的组件
    chainSideFeed event.Feed
    chainHeadFeed event.Feed
    logsFeed      event.Feed
    scope         event.SubscriptionScope
    genesisBlock  *types.Block  // 创世区块

    mu      sync.RWMutex // global mutex for locking chain operations
    chainmu sync.RWMutex // blockchain insertion lock
    procmu  sync.RWMutex // block processor lock

    checkpoint       int          // checkpoint counts towards the new checkpoint
    currentBlock     *types.Block // Current head of the block chain 当前的区块头
    currentFastBlock *types.Block // Current head of the fast-sync chain (may be above the block chain!) 当前的快速同步的区块头

    stateCache   state.Database // State database to reuse between imports (contains state cache)
    bodyCache    *lru.Cache     // Cache for the most recent block bodies
    bodyRLPCache *lru.Cache     // Cache for the most recent block bodies in RLP encoded format
    blockCache   *lru.Cache     // Cache for the most recent entire blocks
    futureBlocks *lru.Cache     // future blocks are blocks added for later processing 暂时还不能插入的区块存放位置

    quit    chan struct{} // blockchain quit channel
    running int32         // running must be called atomically
    // procInterrupt must be atomically called
    procInterrupt int32          // interrupt signaler for block processing
    wg            sync.WaitGroup // chain processing wait group for shutting down

    engine    consensus.Engine  // 一致性引擎
    processor Processor // block processor interface    // 区块处理器接口
    validator Validator // block and state validator interface // 区块和状态验证器接口
    vmConfig  vm.Config //虚拟机的配置

    badBlocks *lru.Cache // Bad block cache 错误区块的缓存
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// Block represents an entire block in the Ethereum blockchain.
type Block struct {
   header       *Header
   uncles       []*Header
   transactions Transactions

   // caches
   hash atomic.Value
   size atomic.Value

   // Td is used by package core to store the total difficulty
   // of the chain up to and including the block.
   td *big.Int

   // These fields are used by package eth to track
   // inter-peer block relay.
   ReceivedAt   time.Time
   ReceivedFrom interface{}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// Header represents a block header in the Ethereum blockchain.
type Header struct {
   ParentHash  common.Hash    `json:&quot;parentHash&quot;       gencodec:&quot;required&quot;`
   UncleHash   common.Hash    `json:&quot;sha3Uncles&quot;       gencodec:&quot;required&quot;`
   Coinbase    common.Address `json:&quot;miner&quot;            gencodec:&quot;required&quot;`
   Root        common.Hash    `json:&quot;stateRoot&quot;        gencodec:&quot;required&quot;`
   TxHash      common.Hash    `json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;`
   ReceiptHash common.Hash    `json:&quot;receiptsRoot&quot;     gencodec:&quot;required&quot;`
   Bloom       Bloom          `json:&quot;logsBloom&quot;        gencodec:&quot;required&quot;`
   Difficulty  *big.Int       `json:&quot;difficulty&quot;       gencodec:&quot;required&quot;`
   Number      *big.Int       `json:&quot;number&quot;           gencodec:&quot;required&quot;`
   GasLimit    uint64         `json:&quot;gasLimit&quot;         gencodec:&quot;required&quot;`
   GasUsed     uint64         `json:&quot;gasUsed&quot;          gencodec:&quot;required&quot;`
   Time        *big.Int       `json:&quot;timestamp&quot;        gencodec:&quot;required&quot;`
   Extra       []byte         `json:&quot;extraData&quot;        gencodec:&quot;required&quot;`
   MixDigest   common.Hash    `json:&quot;mixHash&quot;          gencodec:&quot;required&quot;`
   Nonce       BlockNonce     `json:&quot;nonce&quot;            gencodec:&quot;required&quot;`
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;bitcoin&quot;&gt;bitcoin&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1230529/201803/1230529-20180327151644484-1676549934.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;ethereum&quot;&gt;ethereum&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1230529/201803/1230529-20180327151654351-349954582.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;以太坊的数据库体系-merkle-patricia-triempt-它是由一系列节点组成的二叉树在树底包含了源数据的大量叶子节点-父节点是两个子节点的hash值一直到根节点&quot;&gt;以太坊的数据库体系-Merkle-Patricia Trie(MPT)， 它是由一系列节点组成的二叉树，在树底包含了源数据的大量叶子节点， 父节点是两个子节点的Hash值，一直到根节点。&lt;/h4&gt;

&lt;h4 id=&quot;transaction是body的重要数据结构一个交易就是被外部拥有账户生成的加密签名的一段指令序列化然后提交给区块链&quot;&gt;Transaction是Body的重要数据结构，一个交易就是被外部拥有账户生成的加密签名的一段指令，序列化，然后提交给区块链。&lt;/h4&gt;
&lt;p&gt;在这里保存区块信息时，key一般是与hash相关的，value所保存的数据结构是经过RLP编码的。&lt;/p&gt;&lt;p&gt;在代码中，core/database_util.go中封装了区块存储和读取相关的代码。&lt;/p&gt;&lt;p&gt;在存储区块信息时，会将区块头和区块体分开进行存储。因此在区块的结构体中，能够看到Header和Body两个结构体。&lt;br/&gt;区块头（Header）的存储格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    headerPrefix + num (uint64 big endian) + hash -&amp;gt; rlpEncode(header)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;key是由区块头的前缀，区块号和区块hash构成。value是区块头的RLP编码。&lt;/p&gt;&lt;p&gt;区块体（Body）的存储格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    bodyPrefix + num (uint64 big endian) + hash -&amp;gt; rlpEncode(block body)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;key是由区块体前缀，区块号和区块hash构成。value是区块体的RLP编码。&lt;/p&gt;&lt;p&gt;在database_util.go中，key的前缀可以区分leveldb中存储的是什么类型的数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    var (
        headHeaderKey = []byte(&quot;LastHeader&quot;)
        headBlockKey  = []byte(&quot;LastBlock&quot;)
        headFastKey   = []byte(&quot;LastFast&quot;)
    
        // Data item prefixes (use single byte to avoid mixing data types, avoid `i`).
        headerPrefix        = []byte(&quot;h&quot;) // headerPrefix + num (uint64 big endian) + hash -&amp;gt; header
        tdSuffix            = []byte(&quot;t&quot;) // headerPrefix + num (uint64 big endian) + hash + tdSuffix -&amp;gt; td
        numSuffix           = []byte(&quot;n&quot;) // headerPrefix + num (uint64 big endian) + numSuffix -&amp;gt; hash
        blockHashPrefix     = []byte(&quot;H&quot;) // blockHashPrefix + hash -&amp;gt; num (uint64 big endian)
        bodyPrefix          = []byte(&quot;b&quot;) // bodyPrefix + num (uint64 big endian) + hash -&amp;gt; block body
        blockReceiptsPrefix = []byte(&quot;r&quot;) // blockReceiptsPrefix + num (uint64 big endian) + hash -&amp;gt; block receipts
        lookupPrefix        = []byte(&quot;l&quot;) // lookupPrefix + hash -&amp;gt; transaction/receipt lookup metadata
        bloomBitsPrefix     = []byte(&quot;B&quot;) // bloomBitsPrefix + bit (uint16 big endian) + section (uint64 big endian) + hash -&amp;gt; bloom bits
    
        preimagePrefix = &quot;secure-key-&quot;              // preimagePrefix + hash -&amp;gt; preimage
        configPrefix   = []byte(&quot;ethereum-config-&quot;) // config prefix for the db
    
        // Chain index prefixes (use `i` + single byte to avoid mixing data types).
        BloomBitsIndexPrefix = []byte(&quot;iB&quot;) // BloomBitsIndexPrefix is the data table of a chain indexer to track its progress
    
        // used by old db, now only used for conversion
        oldReceiptsPrefix = []byte(&quot;receipts-&quot;)
        oldTxMetaSuffix   = []byte{0x01}
    
        ErrChainConfigNotFound = errors.New(&quot;ChainConfig not found&quot;) // general config not found error
    
        preimageCounter    = metrics.NewCounter(&quot;db/preimage/total&quot;)
        preimageHitCounter = metrics.NewCounter(&quot;db/preimage/hits&quot;)
    )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;database_util.go最开始就定义了所有的前缀。这里的注释详细说明了每一个前缀存储了什么数据类型。&lt;/p&gt;&lt;p&gt;database_util.go中的其他方法则是对leveldb的操作。其中get方法是读取数据库中的内容，write则是向leveldb中写入数据。&lt;/p&gt;&lt;p&gt;要讲一个区块的信息写入数据库，则需要调用其中的WriteBlock方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// WriteBlock serializes a block into the database, header and body separately.
    func WriteBlock(db ethdb.Putter, block *types.Block) error {
        // Store the body first to retain database consistency
        if err := WriteBody(db, block.Hash(), block.NumberU64(), block.Body()); err != nil {
            return err
        }
        // Store the header too, signaling full block ownership
        if err := WriteHeader(db, block.Header()); err != nil {
            return err
        }
        return nil
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们看到，将一个区块信息写入数据库其实是分别将区块头和区块体写入数据库。&lt;/p&gt;&lt;p&gt;首先来看区块头的存储。区块头的存储是由WriteHeader方法完成的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // WriteHeader serializes a block header into the database.
    func WriteHeader(db ethdb.Putter, header *types.Header) error {
        data, err := rlp.EncodeToBytes(header)
        if err != nil {
            return err
        }
        hash := header.Hash().Bytes()
        num := header.Number.Uint64()
        encNum := encodeBlockNumber(num)
        key := append(blockHashPrefix, hash...)
        if err := db.Put(key, encNum); err != nil {
            log.Crit(&quot;Failed to store hash to number mapping&quot;, &quot;err&quot;, err)
        }
        key = append(append(headerPrefix, encNum...), hash...)
        if err := db.Put(key, data); err != nil {
            log.Crit(&quot;Failed to store header&quot;, &quot;err&quot;, err)
        }
        return nil
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里首先对区块头进行了RLP编码，然后将区块号转换成为byte格式，开始组装key。&lt;/p&gt;&lt;p&gt;这里首先向数据库中存储了一条区块hash-&amp;gt;区块号的键值对，然后才将区块头的信息写入数据库。&lt;/p&gt;&lt;p&gt;接下来是区块体的存储。区块体存储是由WriteBody方法实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// WriteBody serializes the body of a block into the database.
    func WriteBody(db ethdb.Putter, hash common.Hash, number uint64, body *types.Body) error {
        data, err := rlp.EncodeToBytes(body)
        if err != nil {
            return err
        }
        return WriteBodyRLP(db, hash, number, data)
    }

// WriteBodyRLP writes a serialized body of a block into the database.
    func WriteBodyRLP(db ethdb.Putter, hash common.Hash, number uint64, rlp rlp.RawValue) error {
        key := append(append(bodyPrefix, encodeBlockNumber(number)...), hash.Bytes()...)
        if err := db.Put(key, rlp); err != nil {
            log.Crit(&quot;Failed to store block body&quot;, &quot;err&quot;, err)
        }
        return nil
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;WriteBody首先将区块体的信息进行RLP编码，然后调用WriteBodyRLP方法将区块体的信息写入数据库。key的组装方法如之前所述。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;交易存储&quot;&gt;交易存储&lt;/h2&gt;
&lt;p&gt;交易主要在数据库中仅存储交易的Meta信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    txHash + txMetaSuffix -&amp;gt; rlpEncode(txMeta)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;交易的Meta信息结构体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// TxLookupEntry is a positional metadata to help looking up the data content of
// a transaction or receipt given only its hash.
    type TxLookupEntry struct {
        BlockHash  common.Hash
        BlockIndex uint64
        Index      uint64
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，meta信息会存储块的hash，块号和块上第几笔交易这些信息。&lt;/p&gt;&lt;p&gt;交易Meta存储是以交易hash加交易的Meta前缀为key，Meta的RLP编码为value。&lt;/p&gt;&lt;p&gt;交易写入数据库是通过WriteTxLookupEntries方法实现的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// WriteTxLookupEntries stores a positional metadata for every transaction from
// a block, enabling hash based transaction and receipt lookups.
    func WriteTxLookupEntries(db ethdb.Putter, block *types.Block) error {
        // Iterate over each transaction and encode its metadata
        for i, tx := range block.Transactions() {
            entry := TxLookupEntry{
                BlockHash:  block.Hash(),
                BlockIndex: block.NumberU64(),
                Index:      uint64(i),
            }
            data, err := rlp.EncodeToBytes(entry)
            if err != nil {
                return err
            }
            if err := db.Put(append(lookupPrefix, tx.Hash().Bytes()...), data); err != nil {
                return err
            }
        }
        return nil
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，在将交易meta入库时，会遍历块上的所有交易，并构造交易的meta信息，进行RLP编码。然后以交易hash为key，meta为value进行存储。&lt;/p&gt;&lt;p&gt;这样就将一笔交易写入数据库中。&lt;/p&gt;&lt;p&gt;从数据库中读取交易信息时通过GetTransaction方法获得的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// GetTransaction retrieves a specific transaction from the database, along with
// its added positional metadata.
    func GetTransaction(db DatabaseReader, hash common.Hash) (*types.Transaction, common.Hash, uint64, uint64) {
        // Retrieve the lookup metadata and resolve the transaction from the body
        blockHash, blockNumber, txIndex := GetTxLookupEntry(db, hash)
    
        if blockHash != (common.Hash{}) {
            body := GetBody(db, blockHash, blockNumber)
            if body == nil || len(body.Transactions) &amp;lt;= int(txIndex) {
                log.Error(&quot;Transaction referenced missing&quot;, &quot;number&quot;, blockNumber, &quot;hash&quot;, blockHash, &quot;index&quot;, txIndex)
                return nil, common.Hash{}, 0, 0
            }
            return body.Transactions[txIndex], blockHash, blockNumber, txIndex
        }
        // Old transaction representation, load the transaction and it's metadata separately
        data, _ := db.Get(hash.Bytes())
        if len(data) == 0 {
            return nil, common.Hash{}, 0, 0
        }
        var tx types.Transaction
        if err := rlp.DecodeBytes(data, &amp;amp;tx); err != nil {
            return nil, common.Hash{}, 0, 0
        }
        // Retrieve the blockchain positional metadata
        data, _ = db.Get(append(hash.Bytes(), oldTxMetaSuffix...))
        if len(data) == 0 {
            return nil, common.Hash{}, 0, 0
        }
        var entry TxLookupEntry
        if err := rlp.DecodeBytes(data, &amp;amp;entry); err != nil {
            return nil, common.Hash{}, 0, 0
        }
        return &amp;amp;tx, entry.BlockHash, entry.BlockIndex, entry.Index
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法会首先通过交易hash从数据库中获取交易的meta信息，包括交易所在块的hash，块号和第几笔交易。&lt;/p&gt;&lt;p&gt;接下来使用块号和块hash获取从数据库中读取块的信息。&lt;/p&gt;&lt;p&gt;然后根据第几笔交易从块上获取交易的具体信息。&lt;/p&gt;&lt;p&gt;这里以太坊将交易的存储换成了新的存储方式，即交易的具体信息存储在块上，交易hash只对应交易的meta信息，并不包含交易的具体信息。&lt;/p&gt;&lt;p&gt;而以前的交易存储则是需要存储交易的具体信息和meta信息。&lt;/p&gt;&lt;p&gt;因此GetTransaction方法会支持原有的数据存储方式。&lt;/p&gt;
</description>
<pubDate>Tue, 27 Mar 2018 07:17:00 +0000</pubDate>
<dc:creator>宁生信</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gregoryli/p/8657618.html</dc:identifier>
</item>
<item>
<title>GDB 调试多线程多进程 - 沐浴凌风</title>
<link>http://www.cnblogs.com/MaAce/p/8467182.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MaAce/p/8467182.html</guid>
<description>&lt;p&gt;GDB是linux下的调试利器，在c/c++程序开发过程中必不可少的。这里总结一下多进程和多线程的调试方法和技巧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多进程的调试：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#include &amp;lt;sys/mman.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/stat.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;fcntl.h&amp;gt;&lt;span&gt;  
#include &lt;/span&gt;&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; glob = &lt;span&gt;23&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; test()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;child pid: %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, getpid());
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        i&lt;/span&gt;++&lt;span&gt;;
        sleep(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);&lt;br/&gt;　　　　 printf(&quot;child running\n&quot;);
    }
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; pid =&lt;span&gt; fork();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(pid == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        test();
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(pid &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;father pid : %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, getpid());
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            n&lt;/span&gt;++&lt;span&gt;;
            sleep(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);&lt;br/&gt;　　　　　　　printf(&quot;father running\n&quot;);
        }
    }
    wait(pid);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译 gcc -g process.c -o process   -g一定要加上，否则没有调试信息。&lt;/p&gt;
&lt;p&gt;1. 如果我想要锁定子进程/父进程该怎样？&lt;/p&gt;
&lt;p&gt;这里在fork之后就会产生子进程， 如果我们要锁定子进程或者父进程可以使用  &lt;span&gt;set follow-fork-mode [parent|child]&lt;/span&gt; 来完成。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
(gdb) &lt;span&gt;set&lt;/span&gt; follow-fork-&lt;span&gt;mode child
(gdb) b &lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&lt;span&gt;
Note: breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; also &lt;span&gt;set&lt;/span&gt; at pc &lt;span&gt;0x4006e4&lt;/span&gt;&lt;span&gt;.
Breakpoint &lt;/span&gt;&lt;span&gt;2&lt;/span&gt; at &lt;span&gt;0x4006e4&lt;/span&gt;: file process.c, line &lt;span&gt;23&lt;/span&gt;&lt;span&gt;.
(gdb) info breakpoints 
Num     Type           Disp Enb Address            What
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;       breakpoint     keep y   &lt;span&gt;0x00000000004006e4&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; main 
                                                   at process.c:&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; inf &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    breakpoint already hit &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;       breakpoint     keep y   &lt;span&gt;0x00000000004006e4&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; main 
                                                   at process.c:&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; inf &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
(gdb) delete breakpoints &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
(gdb) r
Starting program: &lt;/span&gt;/home/cps/桌面/IPC/&lt;span&gt;process 

Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, main () at process.c:&lt;span&gt;23&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt; pid =&lt;span&gt; fork();
(gdb) n
[New process &lt;/span&gt;&lt;span&gt;37322&lt;/span&gt;&lt;span&gt;]
father pid : &lt;/span&gt;&lt;span&gt;37321&lt;/span&gt;&lt;span&gt;
[Switching to process &lt;/span&gt;&lt;span&gt;37322&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt;(pid == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
(gdb) sparent running

&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;            test();
(gdb)&lt;span&gt; parent running&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里可以看到父进程一直在running， 跟踪子进程并没有停止父进程。 如果想要让父进程处于等待状态可以设置 &lt;span&gt;set detach-on-fork [on | off]&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
(gdb) &lt;span&gt;set&lt;/span&gt; follow-fork-&lt;span&gt;mode child 
(gdb) b &lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&lt;span&gt;
Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; at &lt;span&gt;0x4006e4&lt;/span&gt;: file process.c, line &lt;span&gt;23&lt;/span&gt;&lt;span&gt;.
(gdb) &lt;/span&gt;set detach-on-&lt;span&gt;fork off
(gdb) r
Starting program: &lt;/span&gt;/home/cps/桌面/IPC/&lt;span&gt;process 

Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, main () at process.c:&lt;span&gt;23&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt; pid =&lt;span&gt; fork();
Missing separate debuginfos, use: debuginfo&lt;/span&gt;-install glibc-&lt;span&gt;2.17&lt;/span&gt;-&lt;span&gt;157&lt;/span&gt;&lt;span&gt;.el7.x86_64
(gdb) n
[New process &lt;/span&gt;&lt;span&gt;37548&lt;/span&gt;&lt;span&gt;]
child pid: &lt;/span&gt;&lt;span&gt;37548&lt;/span&gt;&lt;span&gt;
child running
child running
child running
child running&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到父进程并没有执行，而是暂停状态。 只有子进程处于运行状态。&lt;/p&gt;
&lt;p&gt;2. 如何跟踪一个正在运行的进程？&lt;/p&gt;
&lt;p&gt;这里就要说到attach一个进程， 可以使用gdb -p pid execfilepath 来跟踪一个进程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[cps@cps IPC]$ gdb -p &lt;span&gt;37682&lt;/span&gt;&lt;span&gt; process
GNU gdb (GDB) Red Hat Enterprise Linux &lt;/span&gt;&lt;span&gt;7.6&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;94&lt;/span&gt;&lt;span&gt;.el7
Missing separate debuginfos, use: debuginfo&lt;/span&gt;-install glibc-&lt;span&gt;2.17&lt;/span&gt;-&lt;span&gt;157&lt;/span&gt;&lt;span&gt;.el7.x86_64
(gdb) bt
#&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  &lt;span&gt;0x00007fb8d8fad650&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; __nanosleep_nocancel () &lt;span&gt;from&lt;/span&gt; /lib64/libc.so.&lt;span&gt;6&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;0x00007fb8d8fad504&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; sleep () &lt;span&gt;from&lt;/span&gt; /lib64/libc.so.&lt;span&gt;6&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;0x00000000004006d0&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; test () at process.c:&lt;span&gt;16&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;0x00000000004006fc&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; main () at process.c:&lt;span&gt;26&lt;/span&gt;&lt;span&gt;
(gdb) print i
No symbol &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; current context.
(gdb) frame &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;0x00000000004006d0&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; test () at process.c:&lt;span&gt;16&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;            sleep(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
(gdb) print i
$&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; = &lt;span&gt;8&lt;/span&gt;&lt;span&gt;
(gdb) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的第一个print i 并没有打印东西，原因是没有进入堆栈， 我们进入test的堆栈后就可以查看变量。同时在gdb中也可以attach到一个进程中attach pid。&lt;/p&gt;
&lt;p&gt;3. 进程异常crash 怎样查看？&lt;/p&gt;
&lt;p&gt;这种情况下要打开coredump， 使用命令ulimit -c 1024 设置coredump开启。最后将dump文件和可执行文件 一同加载到gdb。 gdb coredump execfile。 进入gdb后 执行bt 和where 查看出错的地方。但是一般情况下的段错误用这种方法可很难查到。一般做法就是一步一步的调试，这种情况一般都是非法访问内存造成的，在最有可能出错的地方打断点。这种情况并没有较为直接的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多线程调试：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 查看当前进程中的所有线程&lt;/p&gt;
&lt;p&gt;info threads  查看当前进程下的所有线程。前面有*代表当前处于的线程。&lt;/p&gt;
&lt;p&gt;thread id  可以切换当前处于的线程，bt查看线程的堆栈&lt;/p&gt;
&lt;p&gt;2. 锁定一个线程&lt;/p&gt;
&lt;p&gt;当我们在调试程序时， 若是想要调试某个线程，程序在执行过程中容易在线程之间来回切换， 我们可以选择一个线程后可以锁定它。&lt;/p&gt;
&lt;p&gt;thread id 选定这个线程&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot; hljs lasso&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;set scheduler&lt;span class=&quot;hljs-attribute&quot;&gt;-locking &lt;span class=&quot;hljs-keyword&quot;&gt;on 可以用来锁定这个线程 只观察这个线程的运行情况。 当锁定这个线程时， 其他线程就处于了暂停状态。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3. 锁定一个线程，让其他线程照常执行&lt;/p&gt;
&lt;p&gt;锁定一个线程让其他线程照常运行，这种用法在gdb 7.0以上的版本是支持的。可以如下设置gdb&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;set&lt;/span&gt; target-async &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;set&lt;/span&gt;&lt;span&gt; pagination off
&lt;/span&gt;&lt;span&gt;set&lt;/span&gt; non-stop on
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的几个命令要在程序运行之前运行这些。&lt;/p&gt;
&lt;p&gt;多进程和多线程的调试技巧还有很多， 这里只是说了一些常见的基本用法。 至于其他的一些gdb用法可以查看gdb help。&lt;/p&gt;

</description>
<pubDate>Tue, 27 Mar 2018 07:14:00 +0000</pubDate>
<dc:creator>沐浴凌风</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MaAce/p/8467182.html</dc:identifier>
</item>
<item>
<title>C#内存泄漏--event内存泄漏 - JAZzzzzzzz</title>
<link>http://www.cnblogs.com/jazzpop/p/8656081.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jazzpop/p/8656081.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;内存泄漏是指：当一块内存被分配后，被丢弃，没有任何实例指针指向这块内存， 并且这块内存不会被GC视为垃圾进行回收。这块内存会一直存在，直到程序退出。C#是托管型代码，其内存的分配和释放都是由CLR负责，当一块内存没有任何实例引用时，GC会负责将其回收。既然没有任何实例引用的内存会被GC回收，那么内存泄漏是如何发生的？&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;内存泄漏示例&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　为了演示内存泄漏是如何发生的，我们来看一段代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program 
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; Action TestEvent;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; memory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestAction();
        TestEvent &lt;/span&gt;+=&lt;span&gt; memory.Run;
        OnTestEvent();
        memory &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;强制垃圾回收&lt;/span&gt;
&lt;span&gt;        GC.Collect(GC.MaxGeneration);
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GC.Collect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试是否回收成功&lt;/span&gt;
&lt;span&gt;        OnTestEvent();
        Console.ReadLine();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnTestEvent() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (TestEvent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) TestEvent();
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test Event is null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestAction 
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Run() {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestAction Run.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　该例子中，memory.run订阅了TestEvent事件，引发事件后，会在屏幕上看到 TestAction Run。当memory =null 后，memory原来指向的内存就没有任何实例再引用该块内存了，这样的内存就是待回收的内存。GC.Collect(GC.MaxGeneration)语句会强制执行一次垃圾回收，再次引发事件，发现屏幕上还是会显示TestAction Run。该内存没有被GC回收，这就是内纯泄漏。这是由TestEvent+=memory.Run语句引起的，当GC.Collect执行的时候，当他看到该块内存还有TestEvent引用，就不会进行回收。但是该内存已经是“无法到达”的了，即无法调用该块内存，只有在引发事件的时候，才能执行该内存的Run方法。这显然不是我想要的效果，当memory = null执行时，我希望该内存在GC执行时被回收，并且当TestEvent被引发时，Run方法不会执行，因为我已经把该内存“解放”了。&lt;/p&gt;
&lt;p&gt;　　这里有一个问题，就是C#中如何“释放”一块内存。像C和C++这样的语言，内存的声明和释放都是开发人员负责的，一旦内存new了出来，就要delete，不然就会造成内存泄漏。这更灵活，也更麻烦，一不小心就会泄漏，忘记释放、线程异常而没有执行释放的代码...有手动分配内存的语言就有自动分配和释放的语言。最开始使用垃圾回收的语言是LISP，之后被用在Java和C#等托管语言中。像C#，CLR负责内存的释放，当程序执行一段时间后，CLR检测到垃圾内存已经值得进行一次垃圾回收时，会执行垃圾回收。至于如何判定一块内存是否为垃圾内存，比较著名的是计数法，即有一个实例引用了该内存后，就在该内存的计数上+1，改实例取消了对该内存的引用，计数就-1，当计数为0时，就被判定为垃圾。该种方法的问题是对循环引用束手无策，如A的某个字段引用了B，而B的某个字段引用了A，这样A和B的技术都不会降到0。CLR改用的方法是类似“标记引用法”（我自己的命名）：在执行GC时，会挂起全部线程，并将托管堆中所有的内存都打上垃圾的标记，之后遍历所有可到达的实例，这些实例如果引用了托管堆的内存，就将该内存的标记由垃圾变为被引用。当遇到A和B相互引用的时候，如果没有其他实例引用A或者B，虽然A和B相互引用，但是A和B都是不可到达的，即没办法引用A或者B，则A和B都会被判定为垃圾而被回收。讲解了这么一大堆，目的就是要说，在C#中，你想要释放一块内存，你只要让该块内存没有任何实例引用他，就可以了。那么当执行memory = null后，除了对TestEvent的订阅，没有任何实例再引用了该块内存，那么为什么订阅事件会阻止内存的释放？&lt;/p&gt;
&lt;p&gt;　　我们来看看TestEvent+=memory.Run()这句话都干了什么。我们利用IL反编译上面的dll，可以看到&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;IL_0000:  nop
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; IL_0001:  newobj     instance &lt;span&gt;void&lt;/span&gt; EventLeakMemory.Program/&lt;span&gt;TestAction::.ctor()
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; IL_0006:  stloc.&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; IL_0007:  ldloc.&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; IL_0008:  ldftn      instance &lt;span&gt;void&lt;/span&gt; EventLeakMemory.Program/&lt;span&gt;TestAction::Run()
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; IL_000e:  newobj     instance &lt;span&gt;void&lt;/span&gt; [mscorlib]System.Action::.ctor(&lt;span&gt;object&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;native &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;7 IL_0013:  call       &lt;span&gt;void&lt;/span&gt; EventLeakMemory.Program::add_TestEvent(&lt;span&gt;class&lt;/span&gt; [mscorlib]System.Action)&lt;br/&gt;...//其他部分
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　关键在5-7行。第5和6行，声明了一个System.Action型的委托，参数为TestAction.Run方法，第七行，执行了Program.add_TestEvent方法，参数是上面声明的委托。也就是说+=操作符相当于执行了Add_TestEvent（new Action(memory.Run)），就是这个new Action包含了对memory指向的内存的引用。而这个引用在CLR看来是可达的，可以通过引发事件来调用该内存。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;解决办法&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　我们已经找到了内存泄漏的元凶，就是订阅事件时，隐式声明的匿名委托对内存的引用。最简单的解决办法是手动取消订阅事件，只要TestEvent -= memory.Run就可以了。但如何实现一个不需要手动取消订阅的事件？该问题的解决办法是使用一种和普通的引用不同的方式来引用方法的实例对象：该引用不会影响垃圾回收，不会在GC时被判定为对该内存的引用，也就是“弱引用”。C#中，绝大部分的类型都是强引用。如何实现弱引用？来看一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; gcHandle =&lt;span&gt; GCHandle.Alloc(obj, GCHandleType.Weak);
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gcHandle.Target == null is :{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, gcHandle.Target == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    obj &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    GC.Collect();
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GC.Collect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gcHandle.Target == null is :{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, gcHandle.Target == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    Console.ReadLine();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当执行GC。Collect后，gcHandle.Target == null 由false 变成了true。这个gcHandle就是obj的一个弱引用。这个类的详细介绍见 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.gchandle?view=netframework-4.7.1&quot; target=&quot;_blank&quot;&gt;GCHandle&lt;/a&gt; 。比较关键的是GCHandle.Alloc方法的第二个参数，该参数接受一个枚举类型。我使用的是GCHandleType.Weak，表明该引用是个弱引用。利用这个方法，就可以封装一个自己的WeakReference类，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WeakReference&amp;lt;T&amp;gt; &lt;span&gt;where&lt;/span&gt; T : &lt;span&gt;class&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; GCHandle handle;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WeakReference(T obj) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        handle &lt;/span&gt;=&lt;span&gt; GCHandle.Alloc(obj, GCHandleType.Weak);
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 引用的目标是否还存活(没有被GC回收)
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; IsAlive {
        &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (handle == &lt;span&gt;default&lt;/span&gt;(GCHandle)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; handle.Target != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 引用的目标
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T Target {
        &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (handle == &lt;span&gt;default&lt;/span&gt;(GCHandle)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (T)handle.Target;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;利用该类，就可以写一个自己的弱事件封装器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WeakEventManager&amp;lt;T&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Dictionary&amp;lt;Delegate, WeakReference&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; delegateDictionary;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WeakEventManager() {
        delegateDictionary &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;Delegate, WeakReference&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt;();
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 订阅
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddHandler(Delegate handler) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (handler != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            delegateDictionary[handler] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; WeakReference&amp;lt;T&amp;gt;&lt;span&gt;(handler);
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 取消订阅
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RemoveHandler(Delegate handler) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (handler != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            delegateDictionary.Remove(handler);
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 引发事件
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Raise(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e) {
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; delegateDictionary.Keys) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delegateDictionary[key].IsAlive)
                key.DynamicInvoke(sender, e);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                delegateDictionary.Remove(key);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，就可以像下面这样定义自己的事件了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestEventClass {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; WeakEventManager&amp;lt;Action&amp;lt;&lt;span&gt;object&lt;/span&gt;, EventArgs&amp;gt;&amp;gt; _testEvent = &lt;span&gt;new&lt;/span&gt; WeakEventManager&amp;lt;Action&amp;lt;&lt;span&gt;object&lt;/span&gt;, EventArgs&amp;gt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; Action&amp;lt;&lt;span&gt;object&lt;/span&gt;, EventArgs&amp;gt;&lt;span&gt; TestEvent {
        add { _testEvent.AddHandler(value); }
        remove { _testEvent.RemoveHandler(value); }
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnEvent(EventArgs e) {
        _testEvent.Raise(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, e);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上就是我自己封装的简单的弱事件。C#提供了现成的WeakReference类，可以直接用。欢迎与我在评论区互动，欢迎转载。　　&lt;/p&gt;

</description>
<pubDate>Tue, 27 Mar 2018 06:46:00 +0000</pubDate>
<dc:creator>JAZzzzzzzz</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jazzpop/p/8656081.html</dc:identifier>
</item>
<item>
<title>MySQL优化小建议 - 悠悠i</title>
<link>http://www.cnblogs.com/youyoui/p/8657331.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youyoui/p/8657331.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;“那啥，你过来一下！”&lt;/p&gt;
&lt;p&gt;“怎么了，我代码都单元测试了的，没出问题啊！”我一脸懵逼跑到运维大佬旁边。&lt;/p&gt;
&lt;p&gt;“你看看！你看看！多少条报警，赶快优化一下！”&lt;br/&gt;运维大佬短信列表里面50多条MySQL CPU 100%报警短信。再看看项目名称不就是我前几天刚发布的项目吗！？&lt;/p&gt;
&lt;p&gt;我心底一沉，赶快赔上笑脸。“这个一定优化，马上优化！那个，能不能看下数据库监控日志...”&lt;/p&gt;
&lt;p&gt;运维大佬又数落了我几句，然后调开了数据库监控日志。&lt;/p&gt;
&lt;p&gt;那家伙...每秒300多的连接数，几乎快要封顶的全表扫描数，还有大红色CPU警报。。。&lt;/p&gt;
&lt;p&gt;“那个，能不能看看nginx访问日志...我看下访问量...”我弱弱地说到。&lt;/p&gt;
&lt;p&gt;运维大佬不情愿的跑了下下面的语句：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;grep -c come access.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;come这个接口是其中一个请求量比较大的接口，结果是600多万。那个时候才中午，周末高峰期估计一天得有上千万吧，&lt;/p&gt;
&lt;p&gt;我撇了撇嘴，心里想着这么高的请求量，当初那么抠门只给我一台低配数据库还好意思说，不过嘴上肯定是：“好好好，请求量不是很大，看来是数据库问题，我立刻去优化一下！”&lt;/p&gt;
&lt;p&gt;“给它弄一个读写分离不就行了吗！？”这时另外一个运维大佬凑了过来，随意地挥了挥手。。。&lt;/p&gt;
&lt;p&gt;你问我DBA去哪儿了？DBA当时有点忙，只说让我自己检查一下。。。&lt;/p&gt;
&lt;h2 id=&quot;优化思路&quot;&gt;优化思路&lt;/h2&gt;
&lt;p&gt;我这个项目由于上线之前比较赶，所以前期并没有管数据库设计方面的一些问题，如今随着游戏接入，请求量剧增才暴露出来。（其实是前期加班加烦了懒得搞）&lt;/p&gt;
&lt;p&gt;这个问题，并不需要增加数据库硬件配置和增加读写分离这种高端手段就能解决，我自个儿挖了多少坑，心里还是有点碧树的。&lt;/p&gt;
&lt;p&gt;详细的MySQL优化步骤如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检查数据表结构，改善不完善设计&lt;/li&gt;
&lt;li&gt;跑一遍主要业务，收集常用的数据库查询SQL&lt;/li&gt;
&lt;li&gt;分析查询SQL，适当拆分，添加索引等优化查询&lt;/li&gt;
&lt;li&gt;优化SQL的同时，优化代码逻辑&lt;/li&gt;
&lt;li&gt;添加本地缓存和redis缓存&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个项目是原生PHP写的，以上这些只能自己做了。&lt;/p&gt;
&lt;h2 id=&quot;检查数据表结构&quot;&gt;检查数据表结构&lt;/h2&gt;
&lt;p&gt;因为比较菜，回去看设计的表结构，真是惨不忍睹。&lt;/p&gt;
&lt;h3 id=&quot;尽可能不要使用null值&quot;&gt;尽可能不要使用NULL值&lt;/h3&gt;
&lt;p&gt;因为建表的时候，如果不对创建的值设置默认值，MySQL都会设置默认为&lt;code&gt;NULL&lt;/code&gt;。那么为啥用&lt;code&gt;NULL&lt;/code&gt;不好呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;NULL&lt;/code&gt;使得索引维护更加复杂，强烈建议对索引列设置&lt;code&gt;NOT NULL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NOT IN&lt;/code&gt;、&lt;code&gt;!=&lt;/code&gt;等负向条件查询在有&lt;code&gt;NULL&lt;/code&gt;值的情况下返回永远为空结果，查询容易出错&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NULL&lt;/code&gt;列需要一个额外字节作为判断是否为&lt;code&gt;NULL&lt;/code&gt;的标志位&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;NULL&lt;/code&gt;时和该列其他的值可能不是同种类型，导致问题。（在不同的语言中表现不一样）&lt;/li&gt;
&lt;li&gt;MySQL难以优化对可为&lt;code&gt;NULL&lt;/code&gt;的列的查询&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以对于那些以前偷懒的字段，手动设置一个默认值吧，空字符串呀，0呀补上。&lt;/p&gt;
&lt;p&gt;虽然这种方法对于MySQL的性能来说没有提升多少，但是这是一个好习惯，而且以小见大，不要忽略这些细节。&lt;/p&gt;
&lt;h3 id=&quot;添加索引&quot;&gt;添加索引&lt;/h3&gt;
&lt;p&gt;对于经常查询的字段，请加上索引，有索引和没有索引的查询速度相差十倍甚至更多。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一般来说，每张表都需要有一个主键&lt;code&gt;id&lt;/code&gt;字段&lt;/li&gt;
&lt;li&gt;常用于查询的字段应该设置索引&lt;/li&gt;
&lt;li&gt;&lt;code&gt;varchar&lt;/code&gt;类型的字段，在建立索引的时候，最好指定长度&lt;/li&gt;
&lt;li&gt;查询有多个条件时，优先使用具有索引的条件&lt;/li&gt;
&lt;li&gt;像&lt;code&gt;LIKE&lt;/code&gt;条件这样的模糊搜索对于字段索引是无效的，需要另外建立关键词索引来解决&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请尽量不要在数据库层面约束表和表之间的关系&lt;/strong&gt;，这些表之间的依赖应该在代码层面去解决&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当表和表之间有约束时，虽然增删查的SQL语句变简单了，但是带来的负面效果是插入等操作数据库都会去检查约束（虽然可以手动设置忽略约束），这样相当于把一些业务逻辑写到了数据库层，不便于维护。&lt;/p&gt;
&lt;h3 id=&quot;优化表字段结构&quot;&gt;优化表字段结构&lt;/h3&gt;
&lt;p&gt;数据库中那些可以用整形表示的数据就不要使用字符串类型，到底是用&lt;code&gt;varchar&lt;/code&gt;还是&lt;code&gt;char&lt;/code&gt;要看字段的可能值。&lt;/p&gt;
&lt;p&gt;这种优化往往在数据库中有大量数据以后是不可行的，最好在数据库设计之前就设计好。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于那些可能值很有限的列，使用&lt;code&gt;tinyint&lt;/code&gt;代替&lt;code&gt;VARCHAR&lt;/code&gt;，
&lt;ul&gt;&lt;li&gt;比如记录移动设备平台，只有两个值：android，ios，那么就可以使用0表示android，1表示ios，这种列一定要写好注释&lt;/li&gt;
&lt;li&gt;为什么不用&lt;code&gt;ENUM&lt;/code&gt;呢？&lt;code&gt;ENUM&lt;/code&gt;扩展困难，比如后来移动平台又增加了一个&lt;code&gt;ipad&lt;/code&gt;，那岂不是懵逼了，而&lt;code&gt;tinyint&lt;/code&gt;加个2就行，而且&lt;code&gt;ENUM&lt;/code&gt;在代码里面处理起来特别奇怪，是当成整形呢还是字符串，各个语言不一样。&lt;/li&gt;
&lt;li&gt;这种方式，一定要在数据库注释或者代码里面写明各个值的含义&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对于那些定长字符串，可以使用&lt;code&gt;char&lt;/code&gt;，比如邮编，总是5位&lt;/li&gt;
&lt;li&gt;对于那些长度未知的字符串，使用&lt;code&gt;varchar&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不要滥用&lt;code&gt;bigint&lt;/code&gt;，比如记录文章数目的表&lt;code&gt;id&lt;/code&gt;字段，用&lt;code&gt;int&lt;/code&gt;就行了，21亿篇文章上限够了&lt;/li&gt;
&lt;li&gt;适当打破数据库范式添加冗余字段，避免查询时的表连接&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;查询的时候，肯定&lt;code&gt;int&lt;/code&gt;类型比&lt;code&gt;varchar&lt;/code&gt;快，因为整数的比较直接调用底层运算器就可以实现，而字符串比较要逐个字符比较。&lt;/p&gt;
&lt;p&gt;定长数据比变长数据查询快，因为比较定长数据字节与字节之间的偏移是固定的，很容易计算下一个数据的偏移。而变长数据则还需要多一步去查询下一个数据的偏移量。不过。定长数据可能会浪费更多的存储空间。&lt;/p&gt;
&lt;h2 id=&quot;大表拆分&quot;&gt;大表拆分&lt;/h2&gt;
&lt;p&gt;对于那些数据量可能近期会超过500W或者增长很快的表，一定要提前做好垂直分表或者水平分表，当数据量超过百万以后，查询速度会明显下降。&lt;/p&gt;
&lt;p&gt;分库分表尽量在数据库设计初期敲定方案，否则后期会极大增加代码复杂性而且不易更改。&lt;/p&gt;
&lt;p&gt;垂直分表是按照日期等外部变量进行分表，水平分表是按照表中的某些字段关系，使用hash映射等分表。&lt;/p&gt;
&lt;p&gt;分库分表的前提条件是在执行查询语句之前，已经知道需要查询的数据可能会落在哪一个分库和哪一个分表中。&lt;/p&gt;
&lt;h2 id=&quot;优化查询语句&quot;&gt;优化查询语句&lt;/h2&gt;
&lt;p&gt;这个才是很多系统数据库瓶颈的始作俑者。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;请尽量使用简单的查询，避免使用表链接&lt;/li&gt;
&lt;li&gt;请尽量避免全表扫描，包括但不限于：
&lt;ul&gt;&lt;li&gt;where子句条件横真或为空&lt;/li&gt;
&lt;li&gt;使用LIKE&lt;/li&gt;
&lt;li&gt;使用不等操作符（&amp;lt;&amp;gt;、!=）&lt;/li&gt;
&lt;li&gt;查询含义is null的列&lt;/li&gt;
&lt;li&gt;在非索引列上使用or&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;多条件查询时，请把简单查询条件或则索引列查询置于前面&lt;/li&gt;
&lt;li&gt;请尽量指定需要查询的列，不要偷懒使用select *
&lt;ul&gt;&lt;li&gt;如果不指定，一方面会返回多余的数据，占用宽带等&lt;/li&gt;
&lt;li&gt;另一方面MySQL执行查询的时候，没有字段时会先去查询表结构有哪些字段&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;大些的查询关键字比小写快一点点&lt;/li&gt;
&lt;li&gt;使用子查询会创建临时表，会比链接（JOIN）和联合（UNION）稍慢&lt;/li&gt;
&lt;li&gt;在索引字段上查询尽量不要使用数据库函数，不便于缓存查询结果&lt;/li&gt;
&lt;li&gt;当只要一行数据时，请使用LIMIT 1，如果数据过多，请适当设定LIMIT，分页查询&lt;/li&gt;
&lt;li&gt;千万不要 ORDER BY RAND()，性能极低&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面是我总结的一些小tips，这些规则是死的，但是业务场景是活的，在实际使用的过程中，比如数据统计，可以适当牺牲性能换取便利。&lt;/p&gt;
&lt;h2 id=&quot;添加缓存&quot;&gt;添加缓存&lt;/h2&gt;
&lt;p&gt;使用redis等缓存，还有本地文件缓存等，可以极大地减少数据库查询次数。缓存这个东西，一定要分析自己系统的数据特点，适当选择。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于一些常用的数据，比如配置信息等，可以放在缓存中&lt;/li&gt;
&lt;li&gt;可以在本地缓存数据库的表结构&lt;/li&gt;
&lt;li&gt;缓存的数据一定要注意及时更新，还有设置有效期&lt;/li&gt;
&lt;li&gt;增加缓存务必会增加系统复杂性，一定要注意权衡&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;优化实例&quot;&gt;优化实例&lt;/h2&gt;
&lt;p&gt;下面举几个简单的优化查询例子。首先就是跑一下主要业务，把主要的查询语句打印到一个文件里面，然后分析这些语句。&lt;/p&gt;
&lt;p&gt;补充一下，在查询语句前使用关键字&lt;code&gt;explain&lt;/code&gt;可以查看查询执行的具体情况。&lt;/p&gt;
&lt;p&gt;看下面的这个查询语句&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * 
&lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;link&lt;/span&gt; 
&lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; player_id=&lt;span class=&quot;st&quot;&gt;'15298635'&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;AND&lt;/span&gt; gameid=&lt;span class=&quot;st&quot;&gt;'10389'&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;AND&lt;/span&gt; appid=&lt;span class=&quot;st&quot;&gt;'200'&lt;/span&gt; 
&lt;span class=&quot;kw&quot;&gt;AND&lt;/span&gt; action=&lt;span class=&quot;st&quot;&gt;'open'&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;AND&lt;/span&gt; creator=&lt;span class=&quot;st&quot;&gt;'android_sdk'&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;AND&lt;/span&gt; transport=&lt;span class=&quot;st&quot;&gt;'{&quot;name&quot;:&quot;uusama&quot;,&quot;age&quot;:20}'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这条语句毛病挺多的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;select * 没有指定查询列，这个表有20个字段，其实我用到的就几个&lt;/li&gt;
&lt;li&gt;查询列没有索引，造成全表扫描&lt;/li&gt;
&lt;li&gt;查询条件过于冗余，可以适当拆分&lt;/li&gt;
&lt;li&gt;只需要一条查询结果，但是没有限定查询结果大小&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;显然查询条件很多，而且很多列都是不定长的varchar类型，如果要建立索引，是不是要建立联合索引呢？&lt;/p&gt;
&lt;p&gt;显然没有必要，索引的字段越多，MySQL维护的时候越复杂，对性能也会有损耗，像这样的SQL查询语句，我们在主要字段上建立索引即可。比如在&lt;code&gt;player_id&lt;/code&gt;字段、&lt;code&gt;gameid&lt;/code&gt;字段、&lt;code&gt;appid&lt;/code&gt;字段上建立索引就够了。&lt;/p&gt;
&lt;p&gt;这样的查询语句要结合具体的业务场景来进行分析，比如在我当前的系统中，我是期望上面的语句能够查询相同的参数下是否有记录。其实没必要使用这么多条件的查询。&lt;/p&gt;
&lt;p&gt;我只需要使用下面的这条更简单的查询语句代替即可。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt;,player_id
&lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;link&lt;/span&gt; 
&lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; player_id=&lt;span class=&quot;st&quot;&gt;'15298635'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询到的记录条数在100条以下，大部分就只用几十条记录，我完全可以在代码里面在把查询结果遍历一遍判断即可。这样不知道有多快呢！&lt;/p&gt;
&lt;p&gt;再看下面的这个例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * 
&lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; browser 
&lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; device_id=&lt;span class=&quot;st&quot;&gt;'52'&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;AND&lt;/span&gt; created&amp;gt;=&lt;span class=&quot;st&quot;&gt;'1513735322'&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;desc&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我只是想查一下这个表里面某个时间以后的数据。问题大了！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;created&lt;/code&gt;字段是&lt;code&gt;timestamp&lt;/code&gt;类型，这样用是不对的，而且没有限定行数，这条语句会把数据库所有的device_id='52'的数据搞出来。&lt;/p&gt;
&lt;p&gt;还好&lt;code&gt;device_id&lt;/code&gt;字段设置了索引，要不然必然会导致全表扫描。&lt;/p&gt;
&lt;p&gt;修改后的查询如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; *
&lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; browser
&lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; device_id=&lt;span class=&quot;st&quot;&gt;'52'&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;AND&lt;/span&gt; created&amp;gt;=&lt;span class=&quot;st&quot;&gt;'2018-03-27 00:00:00'&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;desc&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我的系统总没有使用复杂的像表连接和联合这样的查询，这类查询一定要谨慎使用，能够拆分的话尽量拆分。&lt;/p&gt;
&lt;p&gt;记住下面的速度优先级，两两之间相差2个以上数量级&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU运行速度 &amp;gt; 内存访问速度 &amp;gt; 磁盘io访问速度 &amp;gt; 网络请求速度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步到&lt;a href=&quot;http://uusama.com/713.html&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 27 Mar 2018 06:36:00 +0000</pubDate>
<dc:creator>悠悠i</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youyoui/p/8657331.html</dc:identifier>
</item>
<item>
<title>不可思议的纯CSS导航栏下划线跟随效果 - ChokCoco</title>
<link>http://www.cnblogs.com/coco1s/p/8657192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coco1s/p/8657192.html</guid>
<description>&lt;p&gt;&lt;span&gt;先上张图，如何使用纯 CSS 制作如下效果？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/37917279-8f6fd236-3150-11e8-8b8d-fca96d1d6001.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/37917279-8f6fd236-3150-11e8-8b8d-fca96d1d6001.gif&quot; alt=&quot;underline&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在继续阅读下文之前，你可以先缓一缓。尝试思考一下上面的效果或者动手尝试一下，不借助 JS ，能否巧妙的实现上述效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OK，继续。这个效果是我在业务开发的过程中遇到的一个类似的小问题。其实即便让我借助 Javascript ，我的第一反应也是，感觉很麻烦啊。所以我一直在想，有没有可能只使用 CSS 完成这个效果呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;定义需求&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们定义一下简单的规则，要求如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;假设 HTML 结构如下：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;不可思议的CSS&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;导航栏&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;光标小下划线跟随&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;PURE CSS&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Nav Underline&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;导航栏目的 &lt;code&gt;li&lt;/code&gt; 的宽度是不固定的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当从导航的左侧 &lt;code&gt;li&lt;/code&gt; 移向右侧 &lt;code&gt;li&lt;/code&gt;，下划线从左往右移动。同理，当从导航的右侧 &lt;code&gt;li&lt;/code&gt; 移向左侧 &lt;code&gt;li&lt;/code&gt;，下划线从右往左移动。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;实现需求&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;第一眼看到这个效果，感觉这个跟随动画，仅靠 CSS 是不可能完成的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果想只用 CSS 实现，只能另辟蹊径，使用一些讨巧的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好，下面就借助一些奇技淫巧，使用 CSS 一步一步完成这个效果。分析一下难点：&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;宽度不固定&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;第一个难点， &lt;code&gt;li&lt;/code&gt; 的宽度是不固定的。所以，我们可能需要从 &lt;code&gt;li&lt;/code&gt; 本身的宽度上做文章。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然每个 &lt;code&gt;li&lt;/code&gt; 的宽度不一定，那么它对应的下划线的长度，肯定是是要和他本身相适应的。自然而然，我们就会想到使用它的 &lt;code&gt;border-bottom&lt;/code&gt; 。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
li {
    border-bottom: 2px solid #000;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;那么，可能现在是这样子的（li 之间是相连在一起的，li 间的间隙使用 &lt;code&gt;padding&lt;/code&gt; 产生）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/37945781-6fed50f0-31b4-11e8-9d32-6ea3f455ad6e.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/37945781-6fed50f0-31b4-11e8-9d32-6ea3f455ad6e.png&quot; alt=&quot;image&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;默认隐藏，动画效果&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;当然，这里一开始都是没有下划线的，所以我们可能需要把他们给隐藏起来。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
li {
    border-bottom: 0px solid #000;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;推翻重来，借助伪元素&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这样好像不行，因为隐藏之后，hover &lt;code&gt;li&lt;/code&gt; 的时候，需要下划线动画，而 &lt;code&gt;li&lt;/code&gt; 本身肯定是不能移动的。所以，我们考虑借助伪元素。将下划线作用到每个 &lt;code&gt;li&lt;/code&gt; 的伪元素之上。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
li::before {
    content: &quot;&quot;;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-bottom: 2px solid #000;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面考虑第一步的动画，hover 的时候，下划线要从一侧运动展开。所以，我们利用绝对定位，将 &lt;code&gt;li&lt;/code&gt; 的伪元素的宽度设置为0，在 hover 的时候，宽度从 &lt;code&gt;width: 0 -&amp;gt; width: 100%&lt;/code&gt;，CSS 如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
li::before {
    content: &quot;&quot;;
    position: absolute;
    top: 0;
    left: 0;
    width: 0;
    height: 100%;
    border-bottom: 2px solid #000;
}

li:hover::before {
    width: 100%;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;得到，如下效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/37947171-2a52c720-31bc-11e8-8791-dbe95b45cd6c.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/37947171-2a52c720-31bc-11e8-8791-dbe95b45cd6c.gif&quot; alt=&quot;navunderline&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;左移左出，右移右出&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;OK，感觉离成功近了一步。现在还剩下一个最难的问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如何让线条跟随光标的移动动作，实现当从导航的左侧 &lt;code&gt;li&lt;/code&gt; 移向右侧 &lt;code&gt;li&lt;/code&gt;，下划线从左往右移动。同理，当从导航的右侧 &lt;code&gt;li&lt;/code&gt; 移向左侧 &lt;code&gt;li&lt;/code&gt;，下划线从右往左移动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们仔细看看，现在的效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/37948755-3113c1c4-31c4-11e8-8472-2c85a645d56c.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/37948755-3113c1c4-31c4-11e8-8472-2c85a645d56c.gif&quot; alt=&quot;twounderline&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当从第一个 &lt;code&gt;li&lt;/code&gt; 切换到第二个 &lt;code&gt;li&lt;/code&gt; 的时候，第一个 &lt;code&gt;li&lt;/code&gt; 下划线收回的方向不正确。所以，可以能我们需要将下划线的初始位置位移一下，设置为 &lt;code&gt;left: 100%&lt;/code&gt;，这样每次下划线收回的时候，第一个 &lt;code&gt;li&lt;/code&gt; 就正确了：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
li::before {
    content: &quot;&quot;;
    position: absolute;
    top: 0;
    left: 100%;
    width: 0;
    height: 100%;
    border-bottom: 2px solid #000;
}

li:hover::before {
    left: 0;
    width: 100%;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;看看效果：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/37949000-421f606c-31c5-11e8-82c1-b200a7d5124f.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/37949000-421f606c-31c5-11e8-82c1-b200a7d5124f.gif&quot; alt=&quot;twounderline11&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;额，仔细对比两张图，第二种效果其实是捡了芝麻丢了西瓜。第一个 &lt;code&gt;li&lt;/code&gt; 的方向是正确了，但是第二个 &lt;code&gt;li&lt;/code&gt;下划线的移动方向又错误了。&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/37949063-9702bf2a-31c5-11e8-9faf-d2d3a6958833.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/37949063-9702bf2a-31c5-11e8-9faf-d2d3a6958833.jpg&quot; alt=&quot;fxxk&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;神奇的 ~ 选择符&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;所以，我们迫切需要一种方法，能够不改变当前 hover 的 &lt;code&gt;li&lt;/code&gt; 的下划线移动方式却能改变它下一个 &lt;code&gt;li&lt;/code&gt; 的下划线的移动方式（好绕口）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;没错了，这里我们可以借助 &lt;code&gt;~&lt;/code&gt; 选择符，完成这个艰难的使命，也是这个例子中，最最重要的一环。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于当前 hover 的 &lt;code&gt;li&lt;/code&gt; ，其对应伪元素的下划线的定位是 &lt;code&gt;left: 100%&lt;/code&gt;，而对于 &lt;code&gt;li:hover ~ li::before&lt;/code&gt;，它们的定位是 &lt;code&gt;left: 0&lt;/code&gt;。CSS 代码大致如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
li::before {
    content: &quot;&quot;;
    position: absolute;
    top: 0;
    left: 100%;
    width: 0;
    height: 100%;
    border-bottom: 2px solid #000;
    transition: 0.2s all linear;
}

li:hover::before {
    width: 100%;
    left: 0;
}

li:hover ~ li::before {
    left: 0;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;至此，我们想要的效果就实现拉！撒花。看看：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/37949493-802228ac-31c7-11e8-9343-6c1150827cba.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/37949493-802228ac-31c7-11e8-9343-6c1150827cba.gif&quot; alt=&quot;underlineawhere&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;效果不错，就是有点僵硬，我们可以适当改变缓动函数以及加上一个动画延迟，就可以实现上述开头里的那个效果了。当然，这些都是锦上添花的点缀。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;完整的DEMO可以戳这里: &lt;a href=&quot;https://codepen.io/Chokcoco/pen/PRJvLN&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;CodePen Demo -- 不可思议的CSS光标下划线跟随效果&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;本方法&lt;strong&gt;最大的瑕疵&lt;/strong&gt;在于一开始进入第一个 li 的时候，线条只能是从右往左，除此之外，都能很好的实现跟随效果。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;许久没更新了，最近沉迷学习区块链相关技术，譬如以太坊编程，智能合约的编写巴拉巴拉的。后面还是会把更多精力放在本行，多出一些前端文章，CSS 的魅力还是无法抵挡的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更多精彩 CSS 技术文章汇总在我的 &lt;a href=&quot;https://github.com/chokcoco/iCSS&quot;&gt;Github -- iCSS&lt;/a&gt; ，持续更新，欢迎点个 star 订阅收藏。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，本文到此结束，希望对你有帮助 :)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果还有什么疑问或者建议，可以多多交流，原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 27 Mar 2018 06:27:00 +0000</pubDate>
<dc:creator>ChokCoco</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coco1s/p/8657192.html</dc:identifier>
</item>
<item>
<title>SSE(Server-sent events)技术在web端消息推送和实时聊天中的使用 - RGC</title>
<link>http://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_624days.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_624days.html</guid>
<description>&lt;p&gt;最近在公司闲着没事研究了几天，终于搞定了SSE从理论到实际应用，中间还是有一些坑的。&lt;/p&gt;
&lt;p&gt;1.SSE简介&lt;/p&gt;
&lt;p&gt;SSE(Server-sent events)翻译过来为：服务器发送事件。是基于http协议，和WebSocket的全双工通道（web端和服务端相互通信）相比，SSE只是单通道（服务端主动推送数据到web端），但正是由于此特性，在不需要客户端频繁发送消息给服务端，客户端却需要实时或频繁显示服务端数据的业务场景中可以使用。如：新邮件提示，在浏览网页时提示有新信息或新博客，监控系统实时显示数据。。。&lt;/p&gt;
&lt;p&gt;在web端消息推送功能中，由于传统的http协议需要客户端主动发送请求，服务端才会响应;基本的ajax轮寻技术便是如此，但是此方法需要前端不停的发送ajax请求给后端服务，无论后端是否更新都要执行相应的查询，无疑会大大增加服务器压力，浪费不必要的资源。而SSE解决了这种问题，不需前端主动请求，后端如果有更新便会主动推送消息给web端。&lt;/p&gt;
&lt;p&gt;在SSE中，浏览器发送一个请求给服务端，通过响应头中的Content-Type&lt;span class=&quot;treeIcon&quot;&gt;&lt;span class=&quot;treeIcon&quot;&gt;&lt;span class=&quot;treeLabel stringLabel&quot; data-level=&quot;1&quot;&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;objectBox objectBox-string&quot;&gt;text/event-stream;等&lt;/span&gt; &lt;span class=&quot;objectBox objectBox-string&quot;&gt;向客户端证明这是一个长连接，发送的是流数据，这时客户端不会关闭连接，一直等待服务端发送数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;objectBox objectBox-string&quot;&gt;关于SSE的前端用法请自行百度或参考一下连接：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;Server-Sent Events 教程&quot; href=&quot;http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;objectBox objectBox-string&quot;&gt;http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;objectBox objectBox-string&quot;&gt;2.python框架flask中SSE的包flask_sse的使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;objectBox objectBox-string&quot;&gt;坑点：刚开始根据&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176050/201803/1176050-20180326161157264-717541211.png&quot; alt=&quot;&quot;/&gt;，自信的以为在服务器返回数据时只要是response头部添加这三个字段便实现了SSE功能，但是在flask启动自带服务器后，发现浏览器总是触发error事件，并且从新连接。这样的话和ajax轮询没有任何区别。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;objectBox objectBox-string&quot;&gt;后来找到flask框架的flask_sse文档 &lt;/span&gt;&lt;span class=&quot;objectBox objectBox-string&quot;&gt;&lt;a title=&quot;Flask-SSE&quot; href=&quot;http://flask-sse.readthedocs.io/en/latest/index.html&quot; target=&quot;_blank&quot;&gt;http://flask-sse.readthedocs.io/en/latest/quickstart.html&lt;/a&gt;  其中发现：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10.536585365854&quot;&gt;
&lt;p&gt;&lt;span class=&quot;objectBox objectBox-string&quot;&gt;&lt;a class=&quot;reference external&quot; href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;Server-sent events&lt;/a&gt; do &lt;em&gt;not&lt;/em&gt; work with Flask’s built-in development server, because it handles HTTP requests one at a time. The SSE stream is intended to be an infinite stream of events, so it will never complete. If you try to run this code on with the built-in development server, the server will be unable to take any other requests once you connect to this stream. Instead, you must use a web server with asychronous workers. &lt;a class=&quot;reference external&quot; href=&quot;http://gunicorn.org/&quot;&gt;Gunicorn&lt;/a&gt; can work with &lt;a class=&quot;reference external&quot; href=&quot;http://www.gevent.org/&quot;&gt;gevent&lt;/a&gt; to use asychronous workers: see &lt;a class=&quot;reference external&quot; title=&quot;(in Gunicorn v19.7.0)&quot; href=&quot;http://docs.gunicorn.org/en/latest/design.html#design&quot;&gt;&lt;span class=&quot;xref std std-ref&quot;&gt;gunicorn’s design documentation&lt;/span&gt;&lt;/a&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;objectBox objectBox-string&quot;&gt;　　flask内置服务器不适合SSE功能，一次只能处理一个请求。所以只能使用具有异步功能的服务器来完成此项功能。所以本人想在不引入任何包的情况下完成此功能是不可能的了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;objectBox objectBox-string&quot;&gt;在官方给出的flask_sse 文档中,使用 &lt;/span&gt;gunicorn（wsgi协议的一个容器，和uWSGI一样的功能） + gevent 作为异步功能的服务器。&lt;/p&gt;
&lt;p&gt;ubuntu系统中安装：pip install flask-sse gunicorn gevent&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;objectBox objectBox-string&quot;&gt;由于官方文档中给出的实例代码是MTV（model-template-view）模式,前后端代码杂糅在一起，看着不舒服，于是改成了restful风格的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;objectBox objectBox-string&quot;&gt;下面给出restful风格的flask_sse实现的实时聊天（消息推送）功能。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;objectBox objectBox-string&quot;&gt;后端主要文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;objectBox objectBox-string&quot;&gt;sse.py&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding:utf8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将程序转换成可以使用gevent框架的异步程序&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; gevent &lt;span&gt;import&lt;/span&gt;&lt;span&gt; monkey
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;monkey.patch_all()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; flask &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Flask, send_from_directory, redirect, url_for, request, jsonify
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; flask_sse &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sse
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; app = Flask(&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;redis路径&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; app.config[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;REDIS_URL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;redis://localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;app注册sse的蓝图,并且访问路由是/stream1&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; app.register_blueprint(sse, url_prefix=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/stream1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;重定向到发送消息页面&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; @app.route(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; index():
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; redirect(url_for(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, _external=True) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;upload/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;send_messages.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;接收send_messages.html文件中接口发送的数据，并且通过sse实时推送给用户&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; @app.route(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/messages&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,methods=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; send_messages():
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     channel=request.values.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;channel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     message=request.values.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;关于channel的使用==&amp;gt; http://flask-sse.readthedocs.io/en/latest/advanced.html&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如channel是channel_bob，则只有channel_bob.html才能接收数据&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;sse推送消息&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     sse.publish({&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: message}, type=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;social&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, channel=&lt;span&gt;channel)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; jsonify({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 200, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;errmsg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: None})
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; @app.route(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/upload/&amp;lt;path:path&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; send_file(path):
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; send_from_directory(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;upload/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, path)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     app.run()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;前端接收消息文件&lt;/p&gt;
&lt;p&gt;channel_bob.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Flask-SSE Quickstart&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Channel:channel_bob&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;get_message&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;jquery-3.1.1.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    $(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只接收channel为channel_bob的消息&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt;&lt;span&gt; source &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventSource(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/stream1?channel=channel_bob&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        source.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;social&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (event) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; data &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; JSON.parse(event.data);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#get_message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).append(data.message&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        source.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (event) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;reconnected service!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    })
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;前端发送消息文件&lt;/p&gt;
&lt;p&gt;send_messages.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; channel:&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;channel&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;You can choise these channels: channel_bob,channel_tom,channel_public&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; message:&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;message&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;send message&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;success&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;jquery-3.1.1.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;发送消息页面，发送给三个不同的channel,点击发送按钮后，对于的channel页面会接收到数据&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    $(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; channel &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#channel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).val();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; message &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).val();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; json_data &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;'&lt;/span&gt;&lt;span&gt;channel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: channel,
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;'&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: message
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; http_url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://127.0.0.1:5000/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            $.ajax({
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                url: http_url &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;messages&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                dataType: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                data: json_data,
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (data.code &lt;/span&gt;&lt;span&gt;==&lt;/span&gt; &lt;span&gt;200&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                        $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#success&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).text(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Send message success!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                },
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                error: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (jqXHR, textStatus, errorThrown) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                    console.log(textStatus)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                    hide_popover(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#user_deatil_submit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;程序错误,请联系管理员&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    })
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;项目上传到github上，有详细注释。&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;flask_sse实现&quot; href=&quot;https://github.com/Rgcsh/sse_chait&quot; target=&quot;_blank&quot;&gt;https://github.com/Rgcsh/sse_chait&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;坑点：&lt;/p&gt;
&lt;p&gt;1.uWSGI配置时，在sse_chait.ini配置文件中，socket参数是给在搭建nginx+uWSGI服务时用的，http参数是uWSGI服务（浏览器直接访问网址）时用的&lt;/p&gt;
&lt;p&gt;2.在服务启动时，如果使用uWSGI+gevent启动服务时，要在sse.py顶部添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; gevent &lt;span&gt;import&lt;/span&gt;&lt;span&gt; monkey
monkey.patch_all()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和sse_chait.ini添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
gevent = 100
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.真正的SSE长连接，是一个连接持续工作，并非http请求一样，收到回复就断开连接，如果每次收到响应后，便触发error事件，说明开发的SSE功能有问题。&lt;/p&gt;
&lt;p&gt;真正的SSE连接应该如下，响应时间和请求头，响应头如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176050/201803/1176050-20180327135218704-1730912497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176050/201803/1176050-20180327135513827-1591757071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;参考网址：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;Flask-SSE&quot; href=&quot;http://flask-sse.readthedocs.io/en/latest/index.html&quot; target=&quot;_blank&quot;&gt;http://flask-sse.readthedocs.io/en/latest/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;使用gevent提高IO繁忙型wsgi服务的并发量（转）&quot; href=&quot;https://www.cnblogs.com/ajianbeyourself/p/3970603.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/ajianbeyourself/p/3970603.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;python + flask + uwsgi + gevent + nginx 环境搭建（非阻塞）&quot; href=&quot;http://www.bubuko.com/infodetail-1028284.html&quot; target=&quot;_blank&quot;&gt;www.bubuko.com/infodetail-1028284.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;【Flask】 利用uWSGI和Nginx发布Flask应用&quot; href=&quot;https://www.cnblogs.com/franknihao/p/7202253.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/franknihao/p/7202253.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;gunicorn官方文档&quot; href=&quot;http://gunicorn.readthedocs.io/en/latest/getstart.html&quot; target=&quot;_blank&quot;&gt;http://gunicorn.readthedocs.io/en/latest/getstart.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;uWSGI参考资料（1.0版本的配置选项列表）&quot; href=&quot;http://heipark.iteye.com/blog/1847421&quot; target=&quot;_blank&quot;&gt;http://heipark.iteye.com/blog/1847421&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;Server-Sent Events 教程&quot; href=&quot;http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html&quot; target=&quot;_blank&quot;&gt;www.ruanyifeng.com/blog/2017/05/server-sent_events.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan&lt;/p&gt;
</description>
<pubDate>Tue, 27 Mar 2018 05:58:00 +0000</pubDate>
<dc:creator>RGC</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_624days.html</dc:identifier>
</item>
<item>
<title>用C#开发的一个通用的地铁换乘查询工具 - lovernet</title>
<link>http://www.cnblogs.com/myonly/p/subwaytool.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myonly/p/subwaytool.html</guid>
<description>&lt;p&gt;日常生活中，上班下班坐地铁已经是常事，每当我想去某一个远一点的地方，如果有地铁首选就是地铁，因为方便嘛！每次坐地铁，我们都是凭肉眼去得出我们心中最佳的换乘方案，但是，如果对于线路较少的城市来说，这个方法是最快的，但是如果对于线路较多的城市，例如北京或者上海，十几条线路交叉穿梭，我们可能看到都晕了，怎么坐才是时间最短路程最短的，我们要算出来不是不可以但是很麻烦，我们也可以想一想，百度地图的地铁换乘算法是怎么实现的，于是，闲着没事，我就想写一个通用的地铁换乘查询程序，想用计算机运算得出科学一点的换乘方案供自己参考，假设先不考虑站点间的距离差异，我们以乘坐站点数最少为最优方案，依照这个条件去编码实现查找的算法，其实也没用上什么高大上的算法，因为也不会哈哈，话不多说，先上效果图：&lt;/p&gt;&lt;div readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 初始化地铁线路数据
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;city&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;城市&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitSubwayLine(CityEnum city)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (AllSubwayLines != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; AllSubwayLines.Any() &amp;amp;&amp;amp; _currentCity == city) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             _currentCity =&lt;span&gt; city;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; xmlName = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xml/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + city.ToString() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             _doc =&lt;span&gt; XDocument.Load(xmlName);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             AllSubwayLines = _doc.Root.Elements().Select(x =&amp;gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; line = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubwayLine
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     No = x.Attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Value,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     Name = x.Attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Value,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     IsRound = x.Attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IsRound&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;false&lt;/span&gt; : &lt;span&gt;bool&lt;/span&gt;.Parse(x.Attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IsRound&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Value),
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     Stations = x.Elements().Select((y, i) =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Station
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                         Index =&lt;span&gt; i,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                         Name = y.Attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Value,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                         LineNo = x.Attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Value,
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                         CanTransfer = y.Attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CanTransfer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;false&lt;/span&gt; : &lt;span&gt;bool&lt;/span&gt;.Parse(y.Attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CanTransfer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Value),
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                         TransferNo = y.Attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TransferNo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt; : y.Attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TransferNo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Value
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                    }).ToList()
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                };
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; translines = line.GetTransStations().Select(z =&amp;gt; z.TransferNo.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)).ToList();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; transline &lt;span&gt;in&lt;/span&gt;&lt;span&gt; translines)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; li &lt;span&gt;in&lt;/span&gt;&lt;span&gt; transline)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                        line.TransferLines.Add(li);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 line.TransferLines =&lt;span&gt; line.TransferLines.Distinct().ToList();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; line;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }).ToList();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;341&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取地铁乘车信息
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;depStation&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;出发站&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;destStation&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;到达站&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;city&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;所在城市&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;返回各种换乘方案&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;QueryResult&amp;gt; GetRideSubwayInfo(&lt;span&gt;string&lt;/span&gt; depStation, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; destStation, CityEnum city)
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;            InitSubwayLine(city);
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrWhiteSpace(depStation) || &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(destStation)
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;                 || !AllSubwayLines.Exists(x =&amp;gt; x.Stations.Exists(y =&amp;gt;&lt;span&gt; y.Name.Equals(depStation)))
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;                 || !AllSubwayLines.Exists(x =&amp;gt; x.Stations.Exists(y =&amp;gt;&lt;span&gt; y.Name.Equals(destStation))))
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出发站或到达站在线路上不存在！
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;各种换乘提示
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;同一条线路&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; msg_oneline = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;在{0}【{1}】上车，经过{2}站到达目的站【{3}】。\r\n具体线路为：\r\n(出发){4}(到达)\r\n总搭乘站点数：{5}\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;换乘1次&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; msg_transOnce = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;在{0}【{1}】上车，经过{2}站在【{3}】下车，换乘{4}，经过{5}站到达目的站【{6}】。\r\n具体线路为：\r\n(出发){7}(此处换乘{4})--&amp;gt;{8}(到达)\r\n总搭乘站点数：{9}\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;换乘2次&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; msg_transTwice = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;在{0}【{1}】上车，经过{2}站在【{3}】下车，换乘{4}，经过{5}站在【{6}】下车，换乘{7}，经过{8}站到达目的站【{9}】。\r\n具体线路为：\r\n(出发){10}(此处换乘{4})--&amp;gt;{11}(此处换乘{7})--&amp;gt;{12}(到达)\r\n总搭乘站点数：{13}\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;换乘3次&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; msg_transThreetimes = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;在{0}【{1}】上车，经过{2}站在【{3}】下车，换乘{4}，经过{5}站在【{6}】下车，换乘{7}，经过{8}站在【{9}】下车，换乘{10}，经过{11}站到达目的站【{12}】。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;                 + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n具体线路为：\r\n(出发){13}(此处换乘{4})--&amp;gt;{14}(此处换乘{7})--&amp;gt;{15}(此处换乘{10})--&amp;gt;{16}(到达)\r\n总搭乘站点数：{17}\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;换乘4次&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; msg_transFourtimes = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;在{0}【{1}】上车，经过{2}站在【{3}】下车，换乘{4}，经过{5}站在【{6}】下车，换乘{7}，经过{8}站在【{9}】下车，换乘{10}，经过{11}站在【{12}】下车，换乘{13}，经过{14}站到达目的站【{15}】。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;                 + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n具体线路为：\r\n(出发){16}(此处换乘{4})--&amp;gt;{17}(此处换乘{7})--&amp;gt;{18}(此处换乘{10})--&amp;gt;{19}(此处换乘{13})--&amp;gt;{20}(到达)\r\n总搭乘站点数：{21}\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存各种换乘方案&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;new&lt;/span&gt; List&amp;lt;QueryResult&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一步：先查找始发站和到达站在哪一条线路&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; afterDepLines =&lt;span&gt; GetAcrossLines(depStation);
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; afterDestLines =&lt;span&gt; GetAcrossLines(destStation);
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据同一条线和不同线路展开分析&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (IsSameLine(depStation, destStation))
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;                 &lt;span&gt;#region&lt;/span&gt; 同一条线路
&lt;span&gt; 39&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; commLines = afterDepLines.Where(x =&amp;gt; afterDestLines.Select(y =&amp;gt;&lt;span&gt; y.No).Contains(x.No)).ToList();
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断线路是否相同，相同直接计算站点距离&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; depIndex =&lt;span&gt; GetIndexOnLine(depStation, commLines.First());
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; destIndex =&lt;span&gt; GetIndexOnLine(destStation, commLines.First());
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; crossStations = commLines.First().Stations.Between(depIndex, destIndex).Select(x =&amp;gt;&lt;span&gt; x.Name).ToList();
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; range = crossStations.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (depIndex &amp;gt;&lt;span&gt; destIndex) crossStations.Reverse();
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; rs =&lt;span&gt; msg_oneline.FormatTo(commLines.First().ToString(), depStation, range, destStation,
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;                         crossStations.ToJoinString(), range);
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;                 result.Add(&lt;span&gt;new&lt;/span&gt; QueryResult() { Description = rs, Range =&lt;span&gt; range });
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;                 &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                 &lt;span&gt;#region&lt;/span&gt; 不同线路
&lt;span&gt; 54&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!IsTransferStation(depStation) &amp;amp;&amp;amp; !IsTransferStation(destStation))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果始发站和终点站都不是换乘站，则表示始发站和到达站都是只有一条线路通过&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (afterDepLines.First().IsIntersect(afterDestLines.First()))
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;                         &lt;span&gt;#region&lt;/span&gt; 如果两条线路交叉，一定有换乘站点
&lt;span&gt; 59&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; clist = GetAcrossStations(afterDepLines.First(), afterDestLines.First()).Select(x =&amp;gt;&lt;span&gt; x.Name).ToList();
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; i =&lt;span&gt; GetIndexOnLine(depStation, afterDepLines.First());
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; j =&lt;span&gt; GetIndexOnLine(clist.First(), afterDepLines.First());
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; k =&lt;span&gt; GetIndexOnLine(destStation, afterDestLines.First());
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; l =&lt;span&gt; GetIndexOnLine(clist.First(), afterDestLines.First());
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; coss1 = afterDepLines.First().Stations.Between(i, j).Select(x =&amp;gt;&lt;span&gt; x.Name).ToList();
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; coss2 = afterDestLines.First().Stations.Between(k, l).Select(x =&amp;gt;&lt;span&gt; x.Name).ToList();
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (i &amp;gt;&lt;span&gt; j) coss1.Reverse();
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (k &amp;lt;&lt;span&gt; l) coss2.Reverse();
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; rang1 = coss1.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; rang2 = coss2.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; h = rang1 + rang2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;站点数&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; rs =&lt;span&gt; msg_transOnce.FormatTo(afterDepLines.First().ToString(), depStation, rang1, clist.First(),
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;                            afterDestLines.First().ToString(), rang2, destStation,
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                             coss1.ToJoinString(), coss2.Where(x =&amp;gt; x !=&lt;span&gt; clist.First()).ToJoinString(), h);
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;                         result.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryResult()
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                             Description =&lt;span&gt; rs,
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;                             Range =&lt;span&gt; h,
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;                             TransferStations = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;() { clist.First() },
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;                             TransferTimes = &lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;                        });
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;                         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;                         &lt;span&gt;#region&lt;/span&gt; 不交叉，需要通过第三条线路换乘，即多次换乘
&lt;span&gt; 86&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; depSta =&lt;span&gt; GetStation(depStation);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; destSta =&lt;span&gt; GetStation(destStation);
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找出两条线路的可换乘站点，找出可换乘相同线路的站点&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; trans1 =&lt;span&gt; afterDepLines.First().GetTransStations();
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; trans2 =&lt;span&gt; afterDestLines.First().GetTransStations();
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; trans3 = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Station&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; trans4 = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Station&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; expets = trans1.Join(trans2, x =&amp;gt; x.TransferNo, y =&amp;gt; y.TransferNo, (x, y) =&amp;gt;
&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;                            trans3.Add(x);
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;                            trans4.Add(y);
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                             &lt;span&gt;return&lt;/span&gt; x.Name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; y.Name;
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;                        }).ToList();
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (expets.Any())
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                             &lt;span&gt;#region&lt;/span&gt; 两次换乘
&lt;span&gt;102&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;trans3.Count和trans4.Count必定相等
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算最短距离，列出所有换乘方案&lt;/span&gt;
&lt;span&gt;104&lt;/span&gt;                             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; trans3.Count; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; tranLine =&lt;span&gt; GetLine(trans3[i].TransferNo);
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取这两个站点在此线路的索引                   &lt;/span&gt;
&lt;span&gt;108&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; ix1 =&lt;span&gt; depSta.Index;
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; ix2 =&lt;span&gt; destSta.Index;
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; iix1 =&lt;span&gt; GetIndexOnLine(trans3[i].Name, depSta.LineNo);
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; iix2 =&lt;span&gt; GetIndexOnLine(trans4[i].Name, destSta.LineNo);
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; tx1 =&lt;span&gt; GetIndexOnLine(trans3[i].Name, tranLine);
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; tx2 =&lt;span&gt; GetIndexOnLine(trans4[i].Name, tranLine);
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; depRange = afterDepLines.First().Stations.Between(ix1, iix1).Select(x =&amp;gt;&lt;span&gt; x.Name).ToList();
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; destRange = afterDestLines.First().Stations.Between(ix2, iix2).Select(x =&amp;gt;&lt;span&gt; x.Name).ToList();
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; transRange = tranLine.Stations.Between(tx1, tx2).Select(x =&amp;gt;&lt;span&gt; x.Name).ToList();
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (ix1 &amp;gt;&lt;span&gt; iix1) depRange.Reverse();
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (ix2 &amp;lt;&lt;span&gt; iix2) destRange.Reverse();
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (tx1 &amp;gt;&lt;span&gt; tx2) transRange.Reverse();
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; r1 = depRange.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; r2 = destRange.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; r3 = transRange.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; r = r1 + r2 +&lt;span&gt; r3;
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; rs =&lt;span&gt; msg_transTwice.FormatTo(afterDepLines.First().ToString(), depStation, r1,
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;                                    trans3[i].Name,
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;                                    tranLine.ToString(), r3, trans4[i].Name, afterDestLines.First().ToString(), r2,
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;                                    destStation, depRange.ToJoinString(),
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;                                         transRange.Where(x =&amp;gt; !x.IsSame(trans3[i].Name) &amp;amp;&amp;amp; !&lt;span&gt;x.IsSame(trans4[i].Name)).ToJoinString(),
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;                                     destRange.ToJoinString(), r);
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;                                 result.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryResult()
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;                                {
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;                                     Description =&lt;span&gt; rs,
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;                                     Range =&lt;span&gt; r,
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;                                     TransferTimes = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;                                     TransferStations = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;() { trans3[i].Name, trans4[i].Name }
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;                                });
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;                             &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;140&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;                         &lt;span&gt;#region&lt;/span&gt; 查找3次以上换乘的可能结果，寻求最短距离
&lt;span&gt;142&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; trlines1 =&lt;span&gt; afterDepLines.First().TransferLines.Select(GetLine).ToList();
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; trlines2 =&lt;span&gt; afterDestLines.First().TransferLines.Select(GetLine).ToList();
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; destss = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Station&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; 
&lt;span&gt;146&lt;/span&gt;                         &lt;span&gt;#region&lt;/span&gt; 换乘3次
&lt;span&gt;147&lt;/span&gt;                         &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; depline &lt;span&gt;in&lt;/span&gt;&lt;span&gt; trlines1)
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;                             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; destline &lt;span&gt;in&lt;/span&gt;&lt;span&gt; trlines2)
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; ss =&lt;span&gt; destline.GetAcrossStations(depline);
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (!ss.Any()) &lt;span&gt;continue&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3次换乘&lt;/span&gt;
&lt;span&gt;153&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; slist1 =&lt;span&gt; afterDepLines.First().GetAcrossStations(depline);
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (!slist1.Any()) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; s1 =&lt;span&gt; slist1.GetClosestStation(depSta.Name);
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; s1_ix1 =&lt;span&gt; depSta.Index;
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; s1_ix2 =&lt;span&gt; s1.Index;
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; s1_range =
&lt;span&gt;159&lt;/span&gt; &lt;span&gt;                                    afterDepLines.First()
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; &lt;span&gt;                                        .Stations.Between(s1_ix1, s1_ix2)
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;                                         .Select(x =&amp;gt;&lt;span&gt; x.Name)
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; &lt;span&gt;                                        .ToList();
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; s1_h = s1_range.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (s1_ix1 &amp;gt;&lt;span&gt; s1_ix2) s1_range.Reverse();
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; 
&lt;span&gt;166&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; s2_ix1 =&lt;span&gt; GetIndexOnLine(s1.Name, depline);
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; s2_ix2 =&lt;span&gt; GetIndexOnLine(ss.First().Name, depline);
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; s2_range = depline.Stations.Between(s2_ix1, s2_ix2).Select(x =&amp;gt;&lt;span&gt; x.Name).ToList();
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; s2_h = s2_range.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (s2_ix1 &amp;gt;&lt;span&gt; s2_ix2) s2_range.Reverse();
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; 
&lt;span&gt;172&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; slist3 =&lt;span&gt; destline.GetAcrossStations(afterDestLines.First());
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (!slist3.Any()) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; s3 =&lt;span&gt; slist3.GetClosestStation(ss.First().Name);
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; s3_ix1 =&lt;span&gt; s3.Index;
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; s3_ix2 =&lt;span&gt; ss.First().Index;
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; s3_range = destline.Stations.Between(s3_ix1, s3_ix2).Select(x =&amp;gt;&lt;span&gt; x.Name).ToList();
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; s3_h = s3_range.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (s3_ix1 &amp;lt;&lt;span&gt; s3_ix2) s3_range.Reverse();
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; 
&lt;span&gt;181&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; s4_ix1 =&lt;span&gt; GetIndexOnLine(s3.Name, afterDestLines.First());
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; s4_ix2 =&lt;span&gt; destSta.Index;
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; s4_range =
&lt;span&gt;184&lt;/span&gt; &lt;span&gt;                                    afterDestLines.First()
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; &lt;span&gt;                                        .Stations.Between(s4_ix1, s4_ix2)
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;                                         .Select(x =&amp;gt;&lt;span&gt; x.Name)
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt; &lt;span&gt;                                        .ToList();
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; s4_h = s4_range.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (s4_ix1 &amp;gt;&lt;span&gt; s4_ix2) s4_range.Reverse();
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt; 
&lt;span&gt;191&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; h = s1_h + s2_h + s3_h +&lt;span&gt; s4_h;
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; rs =&lt;span&gt; msg_transThreetimes.FormatTo(afterDepLines.First().ToString(), depStation,
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; &lt;span&gt;                                    s1_h, s1.Name,
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; &lt;span&gt;                                    depline.ToString(), s2_h, ss.First().Name,
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; &lt;span&gt;                                    GetLine(ss.First().LineNo).ToString(), s3_h, s3.Name,
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; &lt;span&gt;                                    afterDestLines.First().ToString(), s4_h, destStation, s1_range.ToJoinString(),
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;                                     s2_range.Where(x =&amp;gt; x !=&lt;span&gt; s1.Name).ToJoinString(),
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt;                                     s3_range.Where(x =&amp;gt; x !=&lt;span&gt; ss.First().Name).ToJoinString(),
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt;                                     s4_range.Where(x =&amp;gt; x !=&lt;span&gt; s3.Name).ToJoinString(), h);
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;                                 result.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryResult()
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt; &lt;span&gt;                                {
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;                                     Description =&lt;span&gt; rs,
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;                                     Range =&lt;span&gt; h,
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;                                     TransferTimes = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;                                     TransferStations =
&lt;span&gt;206&lt;/span&gt;                                         &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; &lt;span&gt;                                        {
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt; &lt;span&gt;                                                        s1.Name,
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt;                                                        ss.First().Name,
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt; &lt;span&gt;                                                        s3.Name
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; &lt;span&gt;                                        }
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; &lt;span&gt;                                });
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt; &lt;span&gt;                                destss.AddRange(ss);
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt;                         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;217&lt;/span&gt; 
&lt;span&gt;218&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (!destss.Any()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;换乘4次&lt;/span&gt;
&lt;span&gt;219&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt;                             &lt;span&gt;#region&lt;/span&gt; 换乘4次
&lt;span&gt;221&lt;/span&gt;                             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; depline &lt;span&gt;in&lt;/span&gt;&lt;span&gt; trlines1)
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;                                 &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; destline &lt;span&gt;in&lt;/span&gt;&lt;span&gt; trlines2)
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; &lt;span&gt;                                {
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; deptrlines =
&lt;span&gt;226&lt;/span&gt;                                         depline.TransferLines.Where(x =&amp;gt; x !=&lt;span&gt; afterDepLines.First().No)
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; &lt;span&gt;                                            .Select(GetLine)
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt; &lt;span&gt;                                            .ToList();
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt;                                     &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; deptrlines)
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; &lt;span&gt;                                    {
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; s1 =&lt;span&gt; line.GetAcrossStations(destline);
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt;                                         &lt;span&gt;if&lt;/span&gt; (!s1.Any()) &lt;span&gt;continue&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4次换乘&lt;/span&gt;
&lt;span&gt;233&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; trlist1 =&lt;span&gt; afterDepLines.First().GetAcrossStations(depline);
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;                                         &lt;span&gt;if&lt;/span&gt; (!trlist1.Any()) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; tr1 =&lt;span&gt; trlist1.GetClosestStation(depSta.Name);
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; s1_ix1 =&lt;span&gt; depSta.Index;
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; s1_ix2 =&lt;span&gt; tr1.Index;
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; s1_range =
&lt;span&gt;239&lt;/span&gt; &lt;span&gt;                                            afterDepLines.First()
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt; &lt;span&gt;                                                .Stations.Between(s1_ix1, s1_ix2)
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt;                                                 .Select(x =&amp;gt;&lt;span&gt; x.Name)
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt; &lt;span&gt;                                                .ToList();
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; h1 = s1_range.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt;                                         &lt;span&gt;if&lt;/span&gt; (s1_ix1 &amp;gt;&lt;span&gt; s1_ix2) s1_range.Reverse();
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt; 
&lt;span&gt;246&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; trlist2 =&lt;span&gt; GetLine(tr1.TransferNo).GetAcrossStations(line);
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt;                                         &lt;span&gt;if&lt;/span&gt; (!trlist2.Any()) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; tr2 =&lt;span&gt; trlist2.GetClosestStation(tr1.Name);
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; s2_ix1 =&lt;span&gt; GetIndexOnLine(tr1.Name, depline);
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; s2_ix2 =&lt;span&gt; tr2.Index;
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; s2_range =
&lt;span&gt;252&lt;/span&gt; &lt;span&gt;                                            depline.Stations.Between(s2_ix1, s2_ix2)
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;                                                 .Select(x =&amp;gt;&lt;span&gt; x.Name)
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt; &lt;span&gt;                                                .ToList();
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; h2 = s2_range.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt;                                         &lt;span&gt;if&lt;/span&gt; (s2_ix1 &amp;gt;&lt;span&gt; s2_ix2) s2_range.Reverse();
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt; 
&lt;span&gt;258&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; s3_ix1 =&lt;span&gt; GetIndexOnLine(tr2.Name, line);
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; s3_ix2 =&lt;span&gt; s1.First().Index;
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; s3_range =
&lt;span&gt;261&lt;/span&gt; &lt;span&gt;                                            line.Stations.Between(s3_ix1, s3_ix2)
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt;                                                 .Select(x =&amp;gt;&lt;span&gt; x.Name)
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt; &lt;span&gt;                                                .ToList();
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; h3 = s3_range.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt;                                         &lt;span&gt;if&lt;/span&gt; (s3_ix1 &amp;gt;&lt;span&gt; s3_ix2) s3_range.Reverse();
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt; 
&lt;span&gt;267&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; trlist3 =&lt;span&gt; destline.GetAcrossStations(afterDestLines.First());
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt;                                         &lt;span&gt;if&lt;/span&gt; (!trlist3.Any()) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;269&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; tr3 =&lt;span&gt; trlist3.GetClosestStation(s1.First().Name);
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; s4_ix1 =&lt;span&gt; GetIndexOnLine(s1.First().Name, destline);
&lt;/span&gt;&lt;span&gt;271&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; s4_ix2 =&lt;span&gt; tr3.Index;
&lt;/span&gt;&lt;span&gt;272&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; s4_range =
&lt;span&gt;273&lt;/span&gt; &lt;span&gt;                                            destline.Stations.Between(s4_ix1, s4_ix2)
&lt;/span&gt;&lt;span&gt;274&lt;/span&gt;                                                 .Select(x =&amp;gt;&lt;span&gt; x.Name)
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt; &lt;span&gt;                                                .ToList();
&lt;/span&gt;&lt;span&gt;276&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; h4 = s4_range.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;277&lt;/span&gt;                                         &lt;span&gt;if&lt;/span&gt; (s4_ix1 &amp;gt;&lt;span&gt; s4_ix2) s4_range.Reverse();
&lt;/span&gt;&lt;span&gt;278&lt;/span&gt; 
&lt;span&gt;279&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; s5_ix1 =&lt;span&gt; GetIndexOnLine(tr3.Name, afterDestLines.First());
&lt;/span&gt;&lt;span&gt;280&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; s5_ix2 =&lt;span&gt; destSta.Index;
&lt;/span&gt;&lt;span&gt;281&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; s5_range =
&lt;span&gt;282&lt;/span&gt; &lt;span&gt;                                            afterDestLines.First()
&lt;/span&gt;&lt;span&gt;283&lt;/span&gt; &lt;span&gt;                                                .Stations.Between(s5_ix1, s5_ix2)
&lt;/span&gt;&lt;span&gt;284&lt;/span&gt;                                                 .Select(x =&amp;gt;&lt;span&gt; x.Name)
&lt;/span&gt;&lt;span&gt;285&lt;/span&gt; &lt;span&gt;                                                .ToList();
&lt;/span&gt;&lt;span&gt;286&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; h5 = s5_range.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;287&lt;/span&gt;                                         &lt;span&gt;if&lt;/span&gt; (s5_ix1 &amp;gt;&lt;span&gt; s5_ix2) s5_range.Reverse();
&lt;/span&gt;&lt;span&gt;288&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; h = h1 + h2 + h3 + h4 +&lt;span&gt; h5;
&lt;/span&gt;&lt;span&gt;289&lt;/span&gt;                                         &lt;span&gt;var&lt;/span&gt; rs =
&lt;span&gt;290&lt;/span&gt; &lt;span&gt;                                            msg_transFourtimes.FormatTo(afterDepLines.First().ToString(),
&lt;/span&gt;&lt;span&gt;291&lt;/span&gt; &lt;span&gt;                                                depStation, h1, tr1.Name,
&lt;/span&gt;&lt;span&gt;292&lt;/span&gt; &lt;span&gt;                                                depline.ToString(), h2, tr2.Name,
&lt;/span&gt;&lt;span&gt;293&lt;/span&gt; &lt;span&gt;                                                line.ToString(), h3, s1.First().Name,
&lt;/span&gt;&lt;span&gt;294&lt;/span&gt; &lt;span&gt;                                                destline.ToString(), h4, tr3.Name,
&lt;/span&gt;&lt;span&gt;295&lt;/span&gt; &lt;span&gt;                                               afterDestLines.First().ToString(), h5, destStation,
&lt;/span&gt;&lt;span&gt;296&lt;/span&gt; &lt;span&gt;                                                s1_range.ToJoinString(),
&lt;/span&gt;&lt;span&gt;297&lt;/span&gt;                                                 s2_range.Where(x =&amp;gt; x !=&lt;span&gt; tr1.Name).ToJoinString(),
&lt;/span&gt;&lt;span&gt;298&lt;/span&gt;                                                 s3_range.Where(x =&amp;gt; x !=&lt;span&gt; tr2.Name).ToJoinString(),
&lt;/span&gt;&lt;span&gt;299&lt;/span&gt;                                                 s4_range.Where(x =&amp;gt; x != tr2.Name &amp;amp;&amp;amp; x !=&lt;span&gt; s1.First().Name).ToJoinString(),
&lt;/span&gt;&lt;span&gt;300&lt;/span&gt;                                                 s5_range.Where(x =&amp;gt; x !=&lt;span&gt; tr3.Name).ToJoinString(), h);
&lt;/span&gt;&lt;span&gt;301&lt;/span&gt;                                         result.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryResult()
&lt;/span&gt;&lt;span&gt;302&lt;/span&gt; &lt;span&gt;                                        {
&lt;/span&gt;&lt;span&gt;303&lt;/span&gt;                                             Description =&lt;span&gt; rs,
&lt;/span&gt;&lt;span&gt;304&lt;/span&gt;                                             Range =&lt;span&gt; h,
&lt;/span&gt;&lt;span&gt;305&lt;/span&gt;                                             TransferTimes = &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;306&lt;/span&gt;                                             TransferStations =
&lt;span&gt;307&lt;/span&gt;                                                 &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;308&lt;/span&gt; &lt;span&gt;                                                {
&lt;/span&gt;&lt;span&gt;309&lt;/span&gt; &lt;span&gt;                                                            tr1.Name,
&lt;/span&gt;&lt;span&gt;310&lt;/span&gt; &lt;span&gt;                                                            tr2.Name,
&lt;/span&gt;&lt;span&gt;311&lt;/span&gt; &lt;span&gt;                                                            s1.First().Name,
&lt;/span&gt;&lt;span&gt;312&lt;/span&gt; &lt;span&gt;                                                            tr3.Name
&lt;/span&gt;&lt;span&gt;313&lt;/span&gt; &lt;span&gt;                                                }
&lt;/span&gt;&lt;span&gt;314&lt;/span&gt; &lt;span&gt;                                        });
&lt;/span&gt;&lt;span&gt;315&lt;/span&gt; &lt;span&gt;                                        destss.AddRange(s1);
&lt;/span&gt;&lt;span&gt;316&lt;/span&gt; &lt;span&gt;                                    }
&lt;/span&gt;&lt;span&gt;317&lt;/span&gt; &lt;span&gt;                                }
&lt;/span&gt;&lt;span&gt;318&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;319&lt;/span&gt;                             &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;320&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;321&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (!destss.Any())&lt;span&gt;//&lt;/span&gt;&lt;span&gt;换乘4次以上&lt;/span&gt;
&lt;span&gt;322&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;323&lt;/span&gt; 
&lt;span&gt;324&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;325&lt;/span&gt;                         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;326&lt;/span&gt;                         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;327&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;328&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;329&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;始发站和到达站有其中一个是换乘站&lt;/span&gt;
&lt;span&gt;330&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;331&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找出到达站经过的路线和始发站所在路线的交叉线路&lt;/span&gt;
&lt;span&gt;332&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; crossLines =&lt;span&gt; GetAcrossLines(depStation, destStation);
&lt;/span&gt;&lt;span&gt;333&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分三种情况：1、始发站不是换乘站而到达站是换乘站；2、始发站是换乘站而到达站不是换乘站；3、始发站和到达站都是换乘站，根据情况展开分析&lt;/span&gt;
&lt;span&gt;334&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (!IsTransferStation(depStation) &amp;amp;&amp;amp;&lt;span&gt; IsTransferStation(destStation))
&lt;/span&gt;&lt;span&gt;335&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;336&lt;/span&gt;                         &lt;span&gt;#region&lt;/span&gt; 情况1：始发站不是换乘站而到达站是换乘站
&lt;span&gt;337&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (crossLines.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;依赖交叉线&lt;/span&gt;
&lt;span&gt;338&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;339&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; listTrans = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Station&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;340&lt;/span&gt;                             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; crossLines)
&lt;/span&gt;&lt;span&gt;341&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;342&lt;/span&gt;                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找出每条交叉线换乘到始发站线路的所有换乘站&lt;/span&gt;
&lt;span&gt;343&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; ss =&lt;span&gt; line.GetTransStations()
&lt;/span&gt;&lt;span&gt;344&lt;/span&gt;                                         .Where(x =&amp;gt;&lt;span&gt; x.TransferNo.IsSame(afterDepLines.First().No))
&lt;/span&gt;&lt;span&gt;345&lt;/span&gt; &lt;span&gt;                                        .ToList();
&lt;/span&gt;&lt;span&gt;346&lt;/span&gt; &lt;span&gt;                                listTrans.AddRange(ss);
&lt;/span&gt;&lt;span&gt;347&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;348&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; depIx =&lt;span&gt; GetIndexOnLine(depStation, afterDepLines.First());
&lt;/span&gt;&lt;span&gt;349&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; tranStas =
&lt;span&gt;350&lt;/span&gt; &lt;span&gt;                                listTrans.Select(
&lt;/span&gt;&lt;span&gt;351&lt;/span&gt;                                         s =&amp;gt; &lt;span&gt;new&lt;/span&gt; { sta = s, ix =&lt;span&gt; GetIndexOnLine(s.Name, afterDepLines.First()) })
&lt;/span&gt;&lt;span&gt;352&lt;/span&gt; &lt;span&gt;                                    .ToList();
&lt;/span&gt;&lt;span&gt;353&lt;/span&gt;                             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; sta &lt;span&gt;in&lt;/span&gt;&lt;span&gt; tranStas)
&lt;/span&gt;&lt;span&gt;354&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;355&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; destIx =&lt;span&gt; GetIndexOnLine(destStation, sta.sta.LineNo);
&lt;/span&gt;&lt;span&gt;356&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; tranIx =&lt;span&gt; GetIndexOnLine(sta.sta.Name, sta.sta.LineNo);
&lt;/span&gt;&lt;span&gt;357&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; coss1 =
&lt;span&gt;358&lt;/span&gt; &lt;span&gt;                                    afterDepLines.First()
&lt;/span&gt;&lt;span&gt;359&lt;/span&gt; &lt;span&gt;                                        .Stations.Between(depIx, sta.ix)
&lt;/span&gt;&lt;span&gt;360&lt;/span&gt;                                         .Select(x =&amp;gt;&lt;span&gt; x.Name)
&lt;/span&gt;&lt;span&gt;361&lt;/span&gt; &lt;span&gt;                                        .ToList();
&lt;/span&gt;&lt;span&gt;362&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; coss2 =
&lt;span&gt;363&lt;/span&gt; &lt;span&gt;                                    GetLine(sta.sta.LineNo)
&lt;/span&gt;&lt;span&gt;364&lt;/span&gt; &lt;span&gt;                                        .Stations.Between(destIx, tranIx)
&lt;/span&gt;&lt;span&gt;365&lt;/span&gt;                                         .Select(x =&amp;gt;&lt;span&gt; x.Name)
&lt;/span&gt;&lt;span&gt;366&lt;/span&gt; &lt;span&gt;                                        .ToList();
&lt;/span&gt;&lt;span&gt;367&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; rang1 = coss1.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;368&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; rang2 = coss2.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;369&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; h = rang1 + rang2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;站点数&lt;/span&gt;
&lt;span&gt;370&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (depIx &amp;gt;&lt;span&gt; sta.ix) coss1.Reverse();
&lt;/span&gt;&lt;span&gt;371&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (destIx &amp;lt;&lt;span&gt; tranIx) coss2.Reverse();
&lt;/span&gt;&lt;span&gt;372&lt;/span&gt; 
&lt;span&gt;373&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; rs =&lt;span&gt; msg_transOnce.FormatTo(afterDepLines.First().ToString(), depStation, rang1,
&lt;/span&gt;&lt;span&gt;374&lt;/span&gt; &lt;span&gt;                                    sta.sta.Name,
&lt;/span&gt;&lt;span&gt;375&lt;/span&gt; &lt;span&gt;                                    GetLine(sta.sta.LineNo).ToString(), rang2, destStation,
&lt;/span&gt;&lt;span&gt;376&lt;/span&gt;                                     coss1.ToJoinString(), coss2.Where(x =&amp;gt; x !=&lt;span&gt; sta.sta.Name).ToJoinString(), h);
&lt;/span&gt;&lt;span&gt;377&lt;/span&gt;                                 result.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryResult()
&lt;/span&gt;&lt;span&gt;378&lt;/span&gt; &lt;span&gt;                                {
&lt;/span&gt;&lt;span&gt;379&lt;/span&gt;                                     Description =&lt;span&gt; rs,
&lt;/span&gt;&lt;span&gt;380&lt;/span&gt;                                     Range =&lt;span&gt; h,
&lt;/span&gt;&lt;span&gt;381&lt;/span&gt;                                     TransferTimes = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;382&lt;/span&gt;                                     TransferStations = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;() { sta.sta.Name }
&lt;/span&gt;&lt;span&gt;383&lt;/span&gt; &lt;span&gt;                                });
&lt;/span&gt;&lt;span&gt;384&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;385&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;386&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找其他换乘可能&lt;/span&gt;
&lt;span&gt;387&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; depSta =&lt;span&gt; GetStation(depStation);
&lt;/span&gt;&lt;span&gt;388&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; trlinesDep =&lt;span&gt; afterDepLines.First().TransferLines.Select(GetLine).ToList();
&lt;/span&gt;&lt;span&gt;389&lt;/span&gt;                         &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; depline &lt;span&gt;in&lt;/span&gt;&lt;span&gt; afterDestLines)
&lt;/span&gt;&lt;span&gt;390&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;391&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; trlineItems =&lt;span&gt; depline.TransferLines.Select(GetLine).ToList();
&lt;/span&gt;&lt;span&gt;392&lt;/span&gt;                             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; iline &lt;span&gt;in&lt;/span&gt;&lt;span&gt; trlineItems)
&lt;/span&gt;&lt;span&gt;393&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;394&lt;/span&gt;                                 &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; destline &lt;span&gt;in&lt;/span&gt;&lt;span&gt; trlinesDep)
&lt;/span&gt;&lt;span&gt;395&lt;/span&gt; &lt;span&gt;                                {
&lt;/span&gt;&lt;span&gt;396&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; ss =&lt;span&gt; destline.GetAcrossStations(iline);
&lt;/span&gt;&lt;span&gt;397&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; (!ss.Any()) &lt;span&gt;continue&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3次换乘&lt;/span&gt;
&lt;span&gt;398&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; slist1 =&lt;span&gt; afterDepLines.First().GetAcrossStations(destline);
&lt;/span&gt;&lt;span&gt;399&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; (!slist1.Any()) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;400&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s1 =&lt;span&gt; slist1.GetClosestStation(depStation);
&lt;/span&gt;&lt;span&gt;401&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s1_ix1 =&lt;span&gt; depSta.Index;
&lt;/span&gt;&lt;span&gt;402&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s1_ix2 =&lt;span&gt; s1.Index;
&lt;/span&gt;&lt;span&gt;403&lt;/span&gt; 
&lt;span&gt;404&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s1_range =
&lt;span&gt;405&lt;/span&gt; &lt;span&gt;                                        afterDepLines.First()
&lt;/span&gt;&lt;span&gt;406&lt;/span&gt; &lt;span&gt;                                            .Stations.Between(s1_ix1, s1_ix2)
&lt;/span&gt;&lt;span&gt;407&lt;/span&gt;                                             .Select(x =&amp;gt;&lt;span&gt; x.Name)
&lt;/span&gt;&lt;span&gt;408&lt;/span&gt; &lt;span&gt;                                            .ToList();
&lt;/span&gt;&lt;span&gt;409&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s1_h = s1_range.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;410&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; (s1_ix1 &amp;gt;&lt;span&gt; s1_ix2) s1_range.Reverse();
&lt;/span&gt;&lt;span&gt;411&lt;/span&gt; 
&lt;span&gt;412&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s2 =&lt;span&gt; ss.GetClosestStation(s1.Name);
&lt;/span&gt;&lt;span&gt;413&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s2_ix1 =&lt;span&gt; GetIndexOnLine(s1.Name, destline);
&lt;/span&gt;&lt;span&gt;414&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s2_ix2 =&lt;span&gt; GetIndexOnLine(s2.Name, destline);
&lt;/span&gt;&lt;span&gt;415&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s2_range = destline.Stations.Between(s2_ix1, s2_ix2).Select(x =&amp;gt;&lt;span&gt; x.Name).ToList();
&lt;/span&gt;&lt;span&gt;416&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s2_h = s2_range.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;417&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; (s2_ix1 &amp;gt;&lt;span&gt; s2_ix2) s2_range.Reverse();
&lt;/span&gt;&lt;span&gt;418&lt;/span&gt; 
&lt;span&gt;419&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; slist3 =&lt;span&gt; iline.GetAcrossStations(depline);
&lt;/span&gt;&lt;span&gt;420&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; (!slist3.Any()) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;421&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s3 =&lt;span&gt; slist3.GetClosestStation(s2.Name);
&lt;/span&gt;&lt;span&gt;422&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s3_ix1 =&lt;span&gt; s3.Index;
&lt;/span&gt;&lt;span&gt;423&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s3_ix2 =&lt;span&gt; GetIndexOnLine(s2.Name, iline);
&lt;/span&gt;&lt;span&gt;424&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s3_range = iline.Stations.Between(s3_ix1, s3_ix2).Select(x =&amp;gt;&lt;span&gt; x.Name).ToList();
&lt;/span&gt;&lt;span&gt;425&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s3_h = s3_range.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;426&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; (s3_ix1 &amp;lt;&lt;span&gt; s3_ix2) s3_range.Reverse();
&lt;/span&gt;&lt;span&gt;427&lt;/span&gt; 
&lt;span&gt;428&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s4_ix1 =&lt;span&gt; GetIndexOnLine(s3.Name, depline);
&lt;/span&gt;&lt;span&gt;429&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s4_ix2 =&lt;span&gt; GetIndexOnLine(destStation, depline);
&lt;/span&gt;&lt;span&gt;430&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s4_range =&lt;span&gt; depline.Stations.Between(s4_ix1, s4_ix2)
&lt;/span&gt;&lt;span&gt;431&lt;/span&gt;                                         .Select(x =&amp;gt;&lt;span&gt; x.Name)
&lt;/span&gt;&lt;span&gt;432&lt;/span&gt; &lt;span&gt;                                        .ToList();
&lt;/span&gt;&lt;span&gt;433&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s4_h = s4_range.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;434&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; (s4_ix1 &amp;gt;&lt;span&gt; s4_ix2) s4_range.Reverse();
&lt;/span&gt;&lt;span&gt;435&lt;/span&gt; 
&lt;span&gt;436&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; h = s1_h + s2_h + s3_h +&lt;span&gt; s4_h;
&lt;/span&gt;&lt;span&gt;437&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; (s2_h == &lt;span&gt;0&lt;/span&gt; || s3_h == &lt;span&gt;0&lt;/span&gt; || s4_h == &lt;span&gt;0&lt;/span&gt; || destline.No.IsSame(iline.No)) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;438&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; rs =&lt;span&gt; msg_transThreetimes.FormatTo(afterDepLines.First().ToString(),
&lt;/span&gt;&lt;span&gt;439&lt;/span&gt; &lt;span&gt;                                        depStation,
&lt;/span&gt;&lt;span&gt;440&lt;/span&gt; &lt;span&gt;                                        s1_h, s1.Name,
&lt;/span&gt;&lt;span&gt;441&lt;/span&gt; &lt;span&gt;                                        destline.ToString(), s2_h, s2.Name,
&lt;/span&gt;&lt;span&gt;442&lt;/span&gt; &lt;span&gt;                                        iline.ToString(), s3_h, s3.Name,
&lt;/span&gt;&lt;span&gt;443&lt;/span&gt; &lt;span&gt;                                        depline.ToString(), s4_h, destStation, s1_range.ToJoinString(),
&lt;/span&gt;&lt;span&gt;444&lt;/span&gt;                                         s2_range.Where(x =&amp;gt; x !=&lt;span&gt; s1.Name).ToJoinString(),
&lt;/span&gt;&lt;span&gt;445&lt;/span&gt;                                         s3_range.Where(x =&amp;gt; x !=&lt;span&gt; s2.Name).ToJoinString(),
&lt;/span&gt;&lt;span&gt;446&lt;/span&gt;                                         s4_range.Where(x =&amp;gt; x !=&lt;span&gt; s3.Name).ToJoinString(), h);
&lt;/span&gt;&lt;span&gt;447&lt;/span&gt;                                     result.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryResult()
&lt;/span&gt;&lt;span&gt;448&lt;/span&gt; &lt;span&gt;                                    {
&lt;/span&gt;&lt;span&gt;449&lt;/span&gt;                                         Description =&lt;span&gt; rs,
&lt;/span&gt;&lt;span&gt;450&lt;/span&gt;                                         Range =&lt;span&gt; h,
&lt;/span&gt;&lt;span&gt;451&lt;/span&gt;                                         TransferTimes = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;452&lt;/span&gt;                                         TransferStations =
&lt;span&gt;453&lt;/span&gt;                                             &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;454&lt;/span&gt; &lt;span&gt;                                            {
&lt;/span&gt;&lt;span&gt;455&lt;/span&gt; &lt;span&gt;                                                    s1.Name,
&lt;/span&gt;&lt;span&gt;456&lt;/span&gt; &lt;span&gt;                                                    s2.Name,
&lt;/span&gt;&lt;span&gt;457&lt;/span&gt; &lt;span&gt;                                                    s3.Name
&lt;/span&gt;&lt;span&gt;458&lt;/span&gt; &lt;span&gt;                                            }
&lt;/span&gt;&lt;span&gt;459&lt;/span&gt; &lt;span&gt;                                    });
&lt;/span&gt;&lt;span&gt;460&lt;/span&gt; &lt;span&gt;                                }
&lt;/span&gt;&lt;span&gt;461&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;462&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;463&lt;/span&gt;                         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;464&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;465&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (IsTransferStation(depStation) &amp;amp;&amp;amp; !&lt;span&gt;IsTransferStation(destStation))
&lt;/span&gt;&lt;span&gt;466&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;467&lt;/span&gt;                         &lt;span&gt;#region&lt;/span&gt; 情况2：始发站是换乘站而到达站不是换乘站
&lt;span&gt;468&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; transLines =
&lt;span&gt;469&lt;/span&gt; &lt;span&gt;                            afterDepLines.Where(
&lt;/span&gt;&lt;span&gt;470&lt;/span&gt;                                     x =&amp;gt;
&lt;span&gt;471&lt;/span&gt; &lt;span&gt;                                        x.Stations.Exists(
&lt;/span&gt;&lt;span&gt;472&lt;/span&gt;                                             y =&amp;gt; y.CanTransfer &amp;amp;&amp;amp;&lt;span&gt; y.TransferNo.Contains(afterDestLines.First().No)))
&lt;/span&gt;&lt;span&gt;473&lt;/span&gt; &lt;span&gt;                                .ToList();
&lt;/span&gt;&lt;span&gt;474&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (transLines.Any())
&lt;/span&gt;&lt;span&gt;475&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;476&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; clist =
&lt;span&gt;477&lt;/span&gt; &lt;span&gt;                                GetAcrossStations(transLines.First(), afterDestLines.First())
&lt;/span&gt;&lt;span&gt;478&lt;/span&gt;                                     .Select(x =&amp;gt;&lt;span&gt; x.Name)
&lt;/span&gt;&lt;span&gt;479&lt;/span&gt; &lt;span&gt;                                    .ToList();
&lt;/span&gt;&lt;span&gt;480&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; i =&lt;span&gt; GetIndexOnLine(depStation, transLines.First());
&lt;/span&gt;&lt;span&gt;481&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; j =&lt;span&gt; GetIndexOnLine(clist.First(), transLines.First());
&lt;/span&gt;&lt;span&gt;482&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; k =&lt;span&gt; GetIndexOnLine(destStation, afterDestLines.First());
&lt;/span&gt;&lt;span&gt;483&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; l =&lt;span&gt; GetIndexOnLine(clist.First(), afterDestLines.First());
&lt;/span&gt;&lt;span&gt;484&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; coss1 = transLines.First().Stations.Between(i, j).Select(x =&amp;gt;&lt;span&gt; x.Name).ToList();
&lt;/span&gt;&lt;span&gt;485&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; coss2 = afterDestLines.First().Stations.Between(k, l).Select(x =&amp;gt;&lt;span&gt; x.Name).ToList();
&lt;/span&gt;&lt;span&gt;486&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; rang1 = coss1.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;487&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; rang2 = coss2.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;488&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; h = rang1 + rang2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;站点数&lt;/span&gt;
&lt;span&gt;489&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; (i &amp;gt;&lt;span&gt; j) coss1.Reverse();
&lt;/span&gt;&lt;span&gt;490&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; (k &amp;lt;&lt;span&gt; l) coss2.Reverse();
&lt;/span&gt;&lt;span&gt;491&lt;/span&gt; 
&lt;span&gt;492&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; rs =&lt;span&gt; msg_transOnce.FormatTo(transLines.First().ToString(), depStation, rang1,
&lt;/span&gt;&lt;span&gt;493&lt;/span&gt; &lt;span&gt;                                clist.First(),
&lt;/span&gt;&lt;span&gt;494&lt;/span&gt; &lt;span&gt;                                afterDestLines.First().ToString(), rang2, destStation,
&lt;/span&gt;&lt;span&gt;495&lt;/span&gt;                                 coss1.ToJoinString(), coss2.Where(x =&amp;gt; x !=&lt;span&gt; clist.First()).ToJoinString(), h);
&lt;/span&gt;&lt;span&gt;496&lt;/span&gt;                             result.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryResult()
&lt;/span&gt;&lt;span&gt;497&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;498&lt;/span&gt;                                 Description =&lt;span&gt; rs,
&lt;/span&gt;&lt;span&gt;499&lt;/span&gt;                                 Range =&lt;span&gt; h,
&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;                                 TransferTimes = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;501&lt;/span&gt;                                 TransferStations = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;() { clist.First() }
&lt;/span&gt;&lt;span&gt;502&lt;/span&gt; &lt;span&gt;                            });
&lt;/span&gt;&lt;span&gt;503&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;504&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;寻找其他换乘可能&lt;/span&gt;
&lt;span&gt;505&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; destSta =&lt;span&gt; GetStation(destStation);
&lt;/span&gt;&lt;span&gt;506&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; trlinesDest =&lt;span&gt; afterDestLines.First().TransferLines.Select(GetLine).ToList();
&lt;/span&gt;&lt;span&gt;507&lt;/span&gt;                         &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; depline &lt;span&gt;in&lt;/span&gt;&lt;span&gt; afterDepLines)
&lt;/span&gt;&lt;span&gt;508&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;509&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; trlineItems =&lt;span&gt; depline.TransferLines.Select(GetLine).ToList();
&lt;/span&gt;&lt;span&gt;510&lt;/span&gt;                             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; iline &lt;span&gt;in&lt;/span&gt;&lt;span&gt; trlineItems)
&lt;/span&gt;&lt;span&gt;511&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;512&lt;/span&gt;                                 &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; destline &lt;span&gt;in&lt;/span&gt;&lt;span&gt; trlinesDest)
&lt;/span&gt;&lt;span&gt;513&lt;/span&gt; &lt;span&gt;                                {
&lt;/span&gt;&lt;span&gt;514&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; ss =&lt;span&gt; iline.GetAcrossStations(destline);
&lt;/span&gt;&lt;span&gt;515&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; (!ss.Any()) &lt;span&gt;continue&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3次换乘&lt;/span&gt;
&lt;span&gt;516&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; slist1 =&lt;span&gt; depline.GetAcrossStations(iline);
&lt;/span&gt;&lt;span&gt;517&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; (!slist1.Any()) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;518&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s1 =&lt;span&gt; slist1.GetClosestStation(depStation);
&lt;/span&gt;&lt;span&gt;519&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s1_ix1 =&lt;span&gt; GetIndexOnLine(depStation, depline);
&lt;/span&gt;&lt;span&gt;520&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s1_ix2 =&lt;span&gt; s1.Index;
&lt;/span&gt;&lt;span&gt;521&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s1_range =
&lt;span&gt;522&lt;/span&gt; &lt;span&gt;                                        depline.Stations.Between(s1_ix1, s1_ix2)
&lt;/span&gt;&lt;span&gt;523&lt;/span&gt;                                             .Select(x =&amp;gt;&lt;span&gt; x.Name)
&lt;/span&gt;&lt;span&gt;524&lt;/span&gt; &lt;span&gt;                                            .ToList();
&lt;/span&gt;&lt;span&gt;525&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s1_h = s1_range.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;526&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; (s1_ix1 &amp;gt;&lt;span&gt; s1_ix2) s1_range.Reverse();
&lt;/span&gt;&lt;span&gt;527&lt;/span&gt; 
&lt;span&gt;528&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s2 =&lt;span&gt; ss.GetClosestStation(s1.Name);
&lt;/span&gt;&lt;span&gt;529&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s2_ix1 =&lt;span&gt; GetIndexOnLine(s1.Name, iline);
&lt;/span&gt;&lt;span&gt;530&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s2_ix2 =&lt;span&gt; GetIndexOnLine(s2.Name, iline);
&lt;/span&gt;&lt;span&gt;531&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s2_range = iline.Stations.Between(s2_ix1, s2_ix2).Select(x =&amp;gt;&lt;span&gt; x.Name).ToList();
&lt;/span&gt;&lt;span&gt;532&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s2_h = s2_range.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;533&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; (s2_ix1 &amp;gt;&lt;span&gt; s2_ix2) s2_range.Reverse();
&lt;/span&gt;&lt;span&gt;534&lt;/span&gt; 
&lt;span&gt;535&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; slist3 =&lt;span&gt; destline.GetAcrossStations(afterDestLines.First());
&lt;/span&gt;&lt;span&gt;536&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; (!slist3.Any()) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;537&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s3 =&lt;span&gt; slist3.GetClosestStation(ss.First().Name);
&lt;/span&gt;&lt;span&gt;538&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s3_ix1 =&lt;span&gt; s3.Index;
&lt;/span&gt;&lt;span&gt;539&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s3_ix2 =&lt;span&gt; GetIndexOnLine(s2.Name, destline);
&lt;/span&gt;&lt;span&gt;540&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s3_range = destline.Stations.Between(s3_ix1, s3_ix2).Select(x =&amp;gt;&lt;span&gt; x.Name).ToList();
&lt;/span&gt;&lt;span&gt;541&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s3_h = s3_range.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;542&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; (s3_ix1 &amp;lt;&lt;span&gt; s3_ix2) s3_range.Reverse();
&lt;/span&gt;&lt;span&gt;543&lt;/span&gt; 
&lt;span&gt;544&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s4_ix1 =&lt;span&gt; GetIndexOnLine(s3.Name, afterDestLines.First());
&lt;/span&gt;&lt;span&gt;545&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s4_ix2 =&lt;span&gt; destSta.Index;
&lt;/span&gt;&lt;span&gt;546&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s4_range =
&lt;span&gt;547&lt;/span&gt; &lt;span&gt;                                        afterDestLines.First()
&lt;/span&gt;&lt;span&gt;548&lt;/span&gt; &lt;span&gt;                                            .Stations.Between(s4_ix1, s4_ix2)
&lt;/span&gt;&lt;span&gt;549&lt;/span&gt;                                             .Select(x =&amp;gt;&lt;span&gt; x.Name)
&lt;/span&gt;&lt;span&gt;550&lt;/span&gt; &lt;span&gt;                                            .ToList();
&lt;/span&gt;&lt;span&gt;551&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; s4_h = s4_range.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;552&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; (s4_ix1 &amp;gt;&lt;span&gt; s4_ix2) s4_range.Reverse();
&lt;/span&gt;&lt;span&gt;553&lt;/span&gt; 
&lt;span&gt;554&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; h = s1_h + s2_h + s3_h +&lt;span&gt; s4_h;
&lt;/span&gt;&lt;span&gt;555&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; (s1_h == &lt;span&gt;0&lt;/span&gt; || s2_h == &lt;span&gt;0&lt;/span&gt; || s3_h == &lt;span&gt;0&lt;/span&gt; || iline.No.IsSame(destline.No)) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;556&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; rs =&lt;span&gt; msg_transThreetimes.FormatTo(depline.ToString(), depStation,
&lt;/span&gt;&lt;span&gt;557&lt;/span&gt; &lt;span&gt;                                        s1_h, s1.Name,
&lt;/span&gt;&lt;span&gt;558&lt;/span&gt; &lt;span&gt;                                        iline.ToString(), s2_h, s2.Name,
&lt;/span&gt;&lt;span&gt;559&lt;/span&gt; &lt;span&gt;                                        destline.ToString(), s3_h, s3.Name,
&lt;/span&gt;&lt;span&gt;560&lt;/span&gt; &lt;span&gt;                                        afterDestLines.First().ToString(), s4_h, destStation,
&lt;/span&gt;&lt;span&gt;561&lt;/span&gt; &lt;span&gt;                                        s1_range.ToJoinString(),
&lt;/span&gt;&lt;span&gt;562&lt;/span&gt;                                         s2_range.Where(x =&amp;gt; x !=&lt;span&gt; s1.Name).ToJoinString(),
&lt;/span&gt;&lt;span&gt;563&lt;/span&gt;                                         s3_range.Where(x =&amp;gt; x !=&lt;span&gt; s2.Name).ToJoinString(),
&lt;/span&gt;&lt;span&gt;564&lt;/span&gt;                                         s4_range.Where(x =&amp;gt; x !=&lt;span&gt; s3.Name).ToJoinString(), h);
&lt;/span&gt;&lt;span&gt;565&lt;/span&gt;                                     result.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryResult()
&lt;/span&gt;&lt;span&gt;566&lt;/span&gt; &lt;span&gt;                                    {
&lt;/span&gt;&lt;span&gt;567&lt;/span&gt;                                         Description =&lt;span&gt; rs,
&lt;/span&gt;&lt;span&gt;568&lt;/span&gt;                                         Range =&lt;span&gt; h,
&lt;/span&gt;&lt;span&gt;569&lt;/span&gt;                                         TransferTimes = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;570&lt;/span&gt;                                         TransferStations =
&lt;span&gt;571&lt;/span&gt;                                             &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;572&lt;/span&gt; &lt;span&gt;                                            {
&lt;/span&gt;&lt;span&gt;573&lt;/span&gt; &lt;span&gt;                                                    s1.Name,
&lt;/span&gt;&lt;span&gt;574&lt;/span&gt; &lt;span&gt;                                                    s2.Name,
&lt;/span&gt;&lt;span&gt;575&lt;/span&gt; &lt;span&gt;                                                    s3.Name
&lt;/span&gt;&lt;span&gt;576&lt;/span&gt; &lt;span&gt;                                            }
&lt;/span&gt;&lt;span&gt;577&lt;/span&gt; &lt;span&gt;                                    });
&lt;/span&gt;&lt;span&gt;578&lt;/span&gt; &lt;span&gt;                                }
&lt;/span&gt;&lt;span&gt;579&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;580&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;581&lt;/span&gt;                         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;582&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;583&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (IsTransferStation(depStation) &amp;amp;&amp;amp;&lt;span&gt; IsTransferStation(destStation))
&lt;/span&gt;&lt;span&gt;584&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;585&lt;/span&gt;                         &lt;span&gt;#region&lt;/span&gt; 情况3：始发站和到达站都是换乘站
&lt;span&gt;586&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (crossLines.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;依赖交叉线&lt;/span&gt;
&lt;span&gt;587&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;588&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; transStations = GetClosestStation(depStation, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;589&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;&lt;span&gt;590&lt;/span&gt;                                 !&lt;span&gt;transStations.Exists(
&lt;/span&gt;&lt;span&gt;591&lt;/span&gt;                                     x =&amp;gt;
&lt;span&gt;592&lt;/span&gt;                                         crossLines.Exists(y =&amp;gt; y.Stations.Exists(z =&amp;gt; x.TransferNo.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).Intersect(z.LineNo.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)).Any()))))
&lt;/span&gt;&lt;span&gt;593&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;594&lt;/span&gt;                                 transStations = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Station&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;595&lt;/span&gt;                                 afterDepLines.ForEach(x =&amp;gt;
&lt;span&gt;596&lt;/span&gt; &lt;span&gt;                                {
&lt;/span&gt;&lt;span&gt;597&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; ctrans =&lt;span&gt; x.GetTransStations();
&lt;/span&gt;&lt;span&gt;598&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; ctrans2 =
&lt;span&gt;599&lt;/span&gt; &lt;span&gt;                                        ctrans.Where(
&lt;/span&gt;&lt;span&gt;600&lt;/span&gt;                                                 y =&amp;gt;
&lt;span&gt;601&lt;/span&gt; &lt;span&gt;                                                    crossLines.Exists(
&lt;/span&gt;&lt;span&gt;602&lt;/span&gt;                                                         z =&amp;gt; z.Stations.Exists(zz =&amp;gt; y.TransferNo.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).Intersect(zz.LineNo.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)).Any())))
&lt;/span&gt;&lt;span&gt;603&lt;/span&gt; &lt;span&gt;                                            .ToList();
&lt;/span&gt;&lt;span&gt;604&lt;/span&gt; &lt;span&gt;                                    transStations.AddRange(ctrans2);
&lt;/span&gt;&lt;span&gt;605&lt;/span&gt; &lt;span&gt;                                });
&lt;/span&gt;&lt;span&gt;606&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;607&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; transLine =
&lt;span&gt;608&lt;/span&gt; &lt;span&gt;                                afterDestLines.Where(
&lt;/span&gt;&lt;span&gt;609&lt;/span&gt;                                         x =&amp;gt;
&lt;span&gt;610&lt;/span&gt;                                             x.Stations.Exists(y =&amp;gt; transStations.Exists(z =&amp;gt;&lt;span&gt; z.Name.IsSame(y.Name))))
&lt;/span&gt;&lt;span&gt;611&lt;/span&gt; &lt;span&gt;                                    .ToList();
&lt;/span&gt;&lt;span&gt;612&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; intersStas =
&lt;span&gt;613&lt;/span&gt; &lt;span&gt;                                transStations.Where(
&lt;/span&gt;&lt;span&gt;614&lt;/span&gt;                                         x =&amp;gt;
&lt;span&gt;615&lt;/span&gt; &lt;span&gt;                                            transLine.Exists(
&lt;/span&gt;&lt;span&gt;616&lt;/span&gt;                                                 y =&amp;gt;
&lt;span&gt;617&lt;/span&gt; &lt;span&gt;                                                    y.Stations.Exists(
&lt;/span&gt;&lt;span&gt;618&lt;/span&gt;                                                         z =&amp;gt; z.Name.IsSame(x.Name) &amp;amp;&amp;amp; x.TransferNo.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).Intersect(z.LineNo.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)).Any())))
&lt;/span&gt;&lt;span&gt;619&lt;/span&gt; &lt;span&gt;                                    .ToList();
&lt;/span&gt;&lt;span&gt;620&lt;/span&gt;                             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; transLine)
&lt;/span&gt;&lt;span&gt;621&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;622&lt;/span&gt;                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分别获取换乘站在换乘线上的索引&lt;/span&gt;
&lt;span&gt;623&lt;/span&gt;                                 &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; intersStas)
&lt;/span&gt;&lt;span&gt;624&lt;/span&gt; &lt;span&gt;                                {
&lt;/span&gt;&lt;span&gt;625&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; ix = GetIndexOnLine(destStation, line); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;目的站在换乘线上的索引&lt;/span&gt;
&lt;span&gt;626&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; iix = GetIndexOnLine(t.Name, line); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;换乘站在换乘线上的索引&lt;/span&gt;
&lt;span&gt;627&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; (iix == -&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;628&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; ix2 = GetIndexOnLine(depStation, t.LineNo); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;始发站在换乘站所在线路上的索引&lt;/span&gt;
&lt;span&gt;629&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; iix2 = GetIndexOnLine(t.Name, t.LineNo); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;换乘站在始发站所在线路上的索引&lt;/span&gt;
&lt;span&gt;630&lt;/span&gt; 
&lt;span&gt;631&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; ixRange = line.Stations.Between(ix, iix).Select(x =&amp;gt;&lt;span&gt; x.Name).ToList();
&lt;/span&gt;&lt;span&gt;632&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; ixRange2 = GetLine(t.LineNo).Stations.Between(ix2, iix2).Select(x =&amp;gt;&lt;span&gt; x.Name).ToList();
&lt;/span&gt;&lt;span&gt;633&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; ixh = ixRange.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;634&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; ixh2 = ixRange2.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;635&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; h = ixh +&lt;span&gt; ixh2;
&lt;/span&gt;&lt;span&gt;636&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; (ix &amp;lt;&lt;span&gt; iix) ixRange.Reverse();
&lt;/span&gt;&lt;span&gt;637&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; (ix2 &amp;gt;&lt;span&gt; iix2) ixRange2.Reverse();
&lt;/span&gt;&lt;span&gt;638&lt;/span&gt;                                     &lt;span&gt;var&lt;/span&gt; rs =&lt;span&gt; msg_transOnce.FormatTo(GetLine(t.LineNo).ToString(), depStation, ixh2, t.Name,
&lt;/span&gt;&lt;span&gt;639&lt;/span&gt; &lt;span&gt;                                        line.ToString(), ixh, destStation,
&lt;/span&gt;&lt;span&gt;640&lt;/span&gt; &lt;span&gt;                                        ixRange2.ToJoinString(),
&lt;/span&gt;&lt;span&gt;641&lt;/span&gt;                                         ixRange.Where(x =&amp;gt; !&lt;span&gt;x.IsSame(t.Name)).ToJoinString(), h);
&lt;/span&gt;&lt;span&gt;642&lt;/span&gt;                                     result.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryResult()
&lt;/span&gt;&lt;span&gt;643&lt;/span&gt; &lt;span&gt;                                    {
&lt;/span&gt;&lt;span&gt;644&lt;/span&gt;                                         Description =&lt;span&gt; rs,
&lt;/span&gt;&lt;span&gt;645&lt;/span&gt;                                         Range =&lt;span&gt; h,
&lt;/span&gt;&lt;span&gt;646&lt;/span&gt;                                         TransferTimes = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;647&lt;/span&gt;                                         TransferStations = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;() { t.Name }
&lt;/span&gt;&lt;span&gt;648&lt;/span&gt; &lt;span&gt;                                    });
&lt;/span&gt;&lt;span&gt;649&lt;/span&gt; &lt;span&gt;                                }
&lt;/span&gt;&lt;span&gt;650&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;651&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;652&lt;/span&gt;                         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;653&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;654&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;655&lt;/span&gt;                 &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;656&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;657&lt;/span&gt; 
&lt;span&gt;658&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找其他可能性&lt;/span&gt;
&lt;span&gt;659&lt;/span&gt;             &lt;span&gt;#region&lt;/span&gt; 深度挖掘其他方案
&lt;span&gt;660&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找出经过始发站和到达站的线路中共同穿过的公共线路，寻找换乘方案&lt;/span&gt;
&lt;span&gt;661&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; connLines =&lt;span&gt; GetCommonLines(depStation, destStation);
&lt;/span&gt;&lt;span&gt;662&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (connLines.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;663&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;664&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; transDep = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Station&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;665&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; transDest = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Station&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;666&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; depLine &lt;span&gt;in&lt;/span&gt;&lt;span&gt; afterDepLines)
&lt;/span&gt;&lt;span&gt;667&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;668&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在经过始发站的线路中的站点中找到可换乘到公共线路的站点&lt;/span&gt;
&lt;span&gt;669&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; trans =&lt;span&gt; depLine.GetTransStations()
&lt;/span&gt;&lt;span&gt;670&lt;/span&gt;                             .Where(x =&amp;gt; x.Name != depStation &amp;amp;&amp;amp; x.Name != destStation &amp;amp;&amp;amp; connLines.Exists(y =&amp;gt;&lt;span&gt; x.TransferNo.Contains(y.No)))
&lt;/span&gt;&lt;span&gt;671&lt;/span&gt; &lt;span&gt;                            .ToList();
&lt;/span&gt;&lt;span&gt;672&lt;/span&gt; &lt;span&gt;                    transDep.AddRange(trans);
&lt;/span&gt;&lt;span&gt;673&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;674&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; destLine &lt;span&gt;in&lt;/span&gt;&lt;span&gt; afterDestLines)
&lt;/span&gt;&lt;span&gt;675&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;676&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在经过到达站的线路中的站点中找到可换乘到公共线路的站点&lt;/span&gt;
&lt;span&gt;677&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; trans =&lt;span&gt; destLine.GetTransStations()
&lt;/span&gt;&lt;span&gt;678&lt;/span&gt;                             .Where(x =&amp;gt; x.Name != depStation &amp;amp;&amp;amp; x.Name != destStation &amp;amp;&amp;amp; connLines.Exists(y =&amp;gt;&lt;span&gt; x.TransferNo.Contains(y.No)))
&lt;/span&gt;&lt;span&gt;679&lt;/span&gt; &lt;span&gt;                            .ToList();
&lt;/span&gt;&lt;span&gt;680&lt;/span&gt; &lt;span&gt;                    transDest.AddRange(trans);
&lt;/span&gt;&lt;span&gt;681&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;682&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; d1 &lt;span&gt;in&lt;/span&gt;&lt;span&gt; transDep)
&lt;/span&gt;&lt;span&gt;683&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;684&lt;/span&gt;                     &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; d2 &lt;span&gt;in&lt;/span&gt;&lt;span&gt; transDest)
&lt;/span&gt;&lt;span&gt;685&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;686&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找出交叉站点，即可换乘同一条公共线路的站点&lt;/span&gt;
&lt;span&gt;687&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; inters = d1.TransferNo.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).Intersect(d2.TransferNo.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)).ToList();
&lt;/span&gt;&lt;span&gt;688&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (!inters.Any() || d1.Name.IsSame(d2.Name)) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;689&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; tranLine =&lt;span&gt; GetLine(inters.First());
&lt;/span&gt;&lt;span&gt;690&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; depLine =&lt;span&gt; GetLine(d1.LineNo);
&lt;/span&gt;&lt;span&gt;691&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; destLine =&lt;span&gt; GetLine(d2.LineNo);
&lt;/span&gt;&lt;span&gt;692&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; ix1 =&lt;span&gt; GetIndexOnLine(depStation, depLine);
&lt;/span&gt;&lt;span&gt;693&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; ix2 =&lt;span&gt; GetIndexOnLine(d1.Name, depLine);
&lt;/span&gt;&lt;span&gt;694&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; iix1 =&lt;span&gt; GetIndexOnLine(d1.Name, tranLine);
&lt;/span&gt;&lt;span&gt;695&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; iix2 =&lt;span&gt; GetIndexOnLine(d2.Name, tranLine);
&lt;/span&gt;&lt;span&gt;696&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; iiix1 =&lt;span&gt; GetIndexOnLine(d2.Name, destLine);
&lt;/span&gt;&lt;span&gt;697&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; iiix2 =&lt;span&gt; GetIndexOnLine(destStation, destLine);
&lt;/span&gt;&lt;span&gt;698&lt;/span&gt; 
&lt;span&gt;699&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; depRange = depLine.Stations.Between(ix1, ix2).Select(x =&amp;gt;&lt;span&gt; x.Name).ToList();
&lt;/span&gt;&lt;span&gt;700&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; transRange = tranLine.Stations.Between(iix1, iix2).Select(x =&amp;gt;&lt;span&gt; x.Name).ToList();
&lt;/span&gt;&lt;span&gt;701&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; destRange = destLine.Stations.Between(iiix1, iiix2).Select(x =&amp;gt;&lt;span&gt; x.Name).ToList();
&lt;/span&gt;&lt;span&gt;702&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; r1 = depRange.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;703&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; r2 = transRange.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;704&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; r3 = destRange.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;705&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; r = r1 + r2 +&lt;span&gt; r3;
&lt;/span&gt;&lt;span&gt;706&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (ix1 &amp;gt;&lt;span&gt; ix2) depRange.Reverse();
&lt;/span&gt;&lt;span&gt;707&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (iix1 &amp;gt;&lt;span&gt; iix2) transRange.Reverse();
&lt;/span&gt;&lt;span&gt;708&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (iiix1 &amp;gt;&lt;span&gt; iiix2) destRange.Reverse();
&lt;/span&gt;&lt;span&gt;709&lt;/span&gt;                         &lt;span&gt;string&lt;/span&gt;&lt;span&gt; rs;
&lt;/span&gt;&lt;span&gt;710&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (r1 &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; r2 &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; r3 &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;711&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;712&lt;/span&gt;                             rs =&lt;span&gt; msg_transTwice.FormatTo(depLine.ToString(), depStation, r1, d1.Name, tranLine.ToString(), r2,
&lt;/span&gt;&lt;span&gt;713&lt;/span&gt; &lt;span&gt;                                    d2.Name, destLine.ToString(), r3, destStation, depRange.ToJoinString(),
&lt;/span&gt;&lt;span&gt;714&lt;/span&gt;                                       transRange.Where(x =&amp;gt; !&lt;span&gt;x.IsSame(d1.Name)).ToJoinString(),
&lt;/span&gt;&lt;span&gt;715&lt;/span&gt;                                     destRange.Where(x =&amp;gt; !x.IsSame(d1.Name) &amp;amp;&amp;amp; !&lt;span&gt;x.IsSame(d2.Name)).ToJoinString(), r);
&lt;/span&gt;&lt;span&gt;716&lt;/span&gt;                             result.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryResult()
&lt;/span&gt;&lt;span&gt;717&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;718&lt;/span&gt;                                 Description =&lt;span&gt; rs,
&lt;/span&gt;&lt;span&gt;719&lt;/span&gt;                                 Range =&lt;span&gt; r,
&lt;/span&gt;&lt;span&gt;720&lt;/span&gt;                                 TransferTimes = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;721&lt;/span&gt;                                 TransferStations = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;() { d1.Name, d2.Name }
&lt;/span&gt;&lt;span&gt;722&lt;/span&gt; &lt;span&gt;                            });
&lt;/span&gt;&lt;span&gt;723&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;724&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (r1 &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; r2 == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; r3 &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;725&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;726&lt;/span&gt;                             rs =&lt;span&gt; msg_transOnce.FormatTo(GetLine(inters.First()).ToString(), depStation, r1, d2.Name,
&lt;/span&gt;&lt;span&gt;727&lt;/span&gt; &lt;span&gt;                                  destLine.ToString(), r3, destStation,
&lt;/span&gt;&lt;span&gt;728&lt;/span&gt; &lt;span&gt;                                  depRange.ToJoinString(),
&lt;/span&gt;&lt;span&gt;729&lt;/span&gt;                                  destRange.Where(x =&amp;gt; !&lt;span&gt;x.IsSame(d2.Name)).ToJoinString(), r);
&lt;/span&gt;&lt;span&gt;730&lt;/span&gt;                             result.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryResult()
&lt;/span&gt;&lt;span&gt;731&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;732&lt;/span&gt;                                 Description =&lt;span&gt; rs,
&lt;/span&gt;&lt;span&gt;733&lt;/span&gt;                                 Range =&lt;span&gt; r,
&lt;/span&gt;&lt;span&gt;734&lt;/span&gt;                                 TransferTimes = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;735&lt;/span&gt;                                 TransferStations = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;() { d2.Name }
&lt;/span&gt;&lt;span&gt;736&lt;/span&gt; &lt;span&gt;                            });
&lt;/span&gt;&lt;span&gt;737&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;738&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;739&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;740&lt;/span&gt;                             rs =&lt;span&gt; msg_transOnce.FormatTo(depLine.ToString(), depStation, r1, d1.Name, tranLine.ToString(), r2,
&lt;/span&gt;&lt;span&gt;741&lt;/span&gt; &lt;span&gt;                                    destStation, depRange.ToJoinString(),
&lt;/span&gt;&lt;span&gt;742&lt;/span&gt;                                     transRange.Where(x =&amp;gt; !&lt;span&gt;x.IsSame(d1.Name)).ToJoinString(), r);
&lt;/span&gt;&lt;span&gt;743&lt;/span&gt;                             result.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryResult()
&lt;/span&gt;&lt;span&gt;744&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;745&lt;/span&gt;                                 Description =&lt;span&gt; rs,
&lt;/span&gt;&lt;span&gt;746&lt;/span&gt;                                 Range =&lt;span&gt; r,
&lt;/span&gt;&lt;span&gt;747&lt;/span&gt;                                 TransferTimes = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;748&lt;/span&gt;                                 TransferStations = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;() { d1.Name }
&lt;/span&gt;&lt;span&gt;749&lt;/span&gt; &lt;span&gt;                            });
&lt;/span&gt;&lt;span&gt;750&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;751&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;752&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;753&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;754&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;755&lt;/span&gt; 
&lt;span&gt;756&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新组织数据&lt;/span&gt;
&lt;span&gt;757&lt;/span&gt;             result.ForEach(x =&amp;gt;
&lt;span&gt;758&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;759&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; desc = x.Description.Split(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }, StringSplitOptions.RemoveEmptyEntries);
&lt;/span&gt;&lt;span&gt;760&lt;/span&gt;                 x.Suggestion = desc[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;761&lt;/span&gt;                 x.Route = desc[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;762&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;763&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;去除重复方案，保留一个&lt;/span&gt;
&lt;span&gt;764&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; gyResult = result.GroupBy(x =&amp;gt; x.Route).Select(x =&amp;gt;&lt;span&gt; x.First()).ToList();
&lt;/span&gt;&lt;span&gt;765&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除逗逼方案，例如：A-B-A-C&lt;/span&gt;
&lt;span&gt;766&lt;/span&gt;             gyResult.RemoveAll(x =&amp;gt; x.Route.Split(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { depStation }, StringSplitOptions.RemoveEmptyEntries).Length &amp;gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;767&lt;/span&gt;             || x.Route.Split(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { destStation }, StringSplitOptions.RemoveEmptyEntries).Length &amp;gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;768&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; gyResult;
&lt;/span&gt;&lt;span&gt;769&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为只做了北京、上海、深圳、广州四个城市的站点数据，所以演示只能查询这四个城市的地铁换乘，大家可以补充自己想要的城市的地铁数据，格式请参照源码中上面四个城市的xml格式。&lt;/p&gt;&lt;p&gt;参数说明：dep为始发站，dest为到达站，city为所在城市拼音，这个是专门为其他程序调用开放的接口&lt;/p&gt;&lt;p&gt;有兴趣的朋友可以看看，欢迎大家提出改进意见，码个代码不容易，各位大哥大姐的点赞是我不断努力的动力&lt;img src=&quot;http://www.xiaoboke.net/Content/ueditor/dialogs/emotion/images/jx2/j_0063.gif&quot; alt=&quot;&quot;/&gt;​，谢谢！&lt;/p&gt;</description>
<pubDate>Tue, 27 Mar 2018 05:04:00 +0000</pubDate>
<dc:creator>lovernet</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/myonly/p/subwaytool.html</dc:identifier>
</item>
<item>
<title>详细分析SQL语句逻辑执行过程和相关语法 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/8656828.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/8656828.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a&gt;&lt;span&gt;本文目录：&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8656828.html#blog1.1&quot;&gt;&lt;span&gt;1.SQL语句的逻辑处理顺序&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8656828.html#blog1.2&quot;&gt;&lt;span&gt;1.2 各数据库系统的语句逻辑处理顺序&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8656828.html#blog1.2.1&quot;&gt;&lt;span&gt;1.2.1 SQL Server和Oracle的逻辑执行顺序&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8656828.html#blog1.2.2&quot;&gt;&lt;span&gt;1.2.2 MariaDB的逻辑执行顺序&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8656828.html#blog1.2.3&quot;&gt;&lt;span&gt;1.2.3 MySQL的逻辑执行顺序&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8656828.html#blog1.33333&quot;&gt;&lt;span&gt;1.3 关于表表达式和虚拟表&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8656828.html#blog1.3&quot;&gt;&lt;span&gt;1.4 关于表别名和列别名&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8656828.html#blog1.4&quot;&gt;&lt;span&gt;1.5 关于数据无序性和ORDER BY&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8656828.html#blog1.5&quot;&gt;&lt;span&gt;1.6 关于TOP(或LIMIT)和ORDER BY&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8656828.html#blog1.6&quot;&gt;&lt;span&gt;1.7 关于DISTINCT和GROUP BY&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8656828.html#blog1.7&quot;&gt;&lt;span&gt;1.8 关于DISTINCT和ORDER BY&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8656828.html#blog1.8&quot;&gt;&lt;span&gt;1.9 关于标准SQL的GROUP BY&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8656828.html#blog1.9&quot;&gt;&lt;span&gt;1.10 关于MySQL/MariaDB的GROUP BY&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8656828.html#blog1.10&quot;&gt;&lt;span&gt;1.11 关于OVER( )&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8656828.html#blog1.11&quot;&gt;&lt;span&gt;1.12 总结&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;1.1 SQL语句的逻辑处理顺序&lt;/h2&gt;
&lt;p class=&quot;01&quot;&gt;SQL语句的逻辑处理顺序，指的是SQL语句按照一定的规则，一整条语句应该如何执行，每一个关键字、子句部分在什么时刻执行。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;除了逻辑顺序，还有物理执行顺序。物理顺序是SQL语句真正被执行时的顺序(执行计划)，它是由各数据库系统的关系引擎中的语句分析器、优化器等等组件经过大量计算、分析决定的。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;很多时候因为优化的关系，使得语句最终的物理执行顺序和逻辑顺序不同。按照逻辑顺序，有些应该先执行的过程，可能优化器会指定它后执行。但不管是逻辑顺序还是物理顺序，设计了一条SQL语句，语句最后返回的结果不会也不能因为物理顺序改变了逻辑顺序而改变。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;其实，逻辑顺序只是为我们编写、理解SQL语句提供些帮助，除此之外，它毫无用处。而且，是不是真的存在一条严格且完整的执行顺序规则都是不确定的事情。虽然某些书上、网上给出了一些顺序(我个人所知道的比较权威的，是SQL Server的&quot;圣书&quot;技术内幕里介绍过)，但在任何一种数据库系统的官方手册上都没有关于这方面的介绍文档。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;SQL Server和Oracle在语句的逻辑处理顺序上是一致的，在这方面，它们严格遵守了标准SQL的要求，任何一个步骤都遵循了关系型数据库的范式要求。因为遵循了一些范式要求，导致标准SQL不允许使用某些语法。但是MySQL、MariaDB和它们小有不同，它们对标准SQL进行扩展，标准SQL中不允许使用的语法，在MySQL、MariaDB中可能可以使用，但很多时候这会违反关系模型的范式要求。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;虽然本文的最初目的是介绍MariaDB/MySQL语句的逻辑处理顺序，但在篇幅上对标准SQL介绍的更多，因为它们符合规范。理解这些规范，实际上是在理解关系模型和集合模型。本文也在多处通过这两个模型来分析&lt;strong&gt;&lt;span&gt;为什么标准SQL不允许某些语法，以及为什么MySQL可以支持这些&quot;不标准&quot;的语法&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;1.2 各数据库系统的语句逻辑处理顺序&lt;/h2&gt;
&lt;p&gt;以SELECT语句为例。&lt;/p&gt;

&lt;h3&gt;1.2.1 SQL Server和Oracle的逻辑执行顺序&lt;/h3&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180327112230198-1282730343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;&lt;strong&gt;&lt;span&gt;关于本图需要说明的是，虽然图中给出的顺序是DISTINCT比ORDER BY先执行，这也是网上流传的版本。但其实，在DISTINCT和ORDER BY之间的顺序没有严格的界限，甚至ORDER BY的顺序要优先于DISTINCT&lt;/span&gt;。&lt;/strong&gt;后文会分析为什么。而且刚刚去翻了下sql server技术内幕中关于逻辑处理顺序的内容，发现它没有对DISTINCT执行位置进行排序，只是在介绍ORDER BY时提了下DISTINCT，我想也是因为DISTINCT和ORDER BY之间没有严格的顺序。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;后面关于MySQL和mariadb的两张逻辑顺序图中，将会把DISTINCT和ORDER BY的顺序调换过来。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;以下是对上述逻辑执行顺序的描述：&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(1).首先从FROM语句中获取要操作的表并计算笛卡尔积。如果有要联接的表，则还获取联接表。对它们计算笛卡尔积，笛卡尔积的结果形成一张虚拟表vt1。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;这里就体现了物理顺序和逻辑顺序的一个不同点：按照逻辑顺序，在执行SQL语句之初总是会进行笛卡尔积的计算，如果是两张或多张非常大的表，计算笛卡尔积是非常低效的行为，这是不能容忍的。所以物理顺序会进行一些优化决定，比如使用索引跳过一部分或整个笛卡尔积让计算变得很小。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(2).对虚拟表vt1执行ON筛选语句，得到虚拟表vt2。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(3).根据联接类型，将保留表的外部行添加到vt2中得到虚拟表vt3。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(4).对vt3执行where条件筛选，得到虚拟表vt4。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(5).执行分组，得到虚拟表vt5。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;注意，分组之后，整个SQL的操作上下文就变成了分组列，而不再是表中的每一列，后续的一切操作都是围绕所分的组作为操作对象进行操作的。也就是说，不在分组列表中的列不能在后续步骤中使用。例如，使用&quot;group by a&quot;对a列分组，那么后续的select列表中就不能使用b列，除非是对b列进行分组聚合运算。SQL Server、Oracle和MariaDB、Mysql最大的区别就在于此步，后两者可以引用分组列以外的列。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(6).对vt5执行集合操作cube或者rollup，得到虚拟表vt6。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(7).对分组的最终结果vt6执行having筛选，得到虚拟表vt7。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(8).根据给定的选择列列表，将vt7中的选择列插入到虚拟表vt8中。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;注意，选择列是&quot;&lt;strong&gt;&lt;span&gt;同时性操作&lt;/span&gt;&quot;&lt;/strong&gt;，在选择列中不能使用列别名来引用列表中的其他列。例如 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;select&lt;/span&gt; col1&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; a,a&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; b &lt;span&gt;from&lt;/span&gt; t1&lt;/span&gt; 是错误的，因为&quot;col1+1&quot;和&quot;a+1&quot;之间没有执行上的先后顺序，所以它认为&quot;a+1&quot;中的a列是不存在的。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(9).对vt8进行窗口分组相关的计算，得到虚拟表vt9。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(10).对vt9按照指定的列去除重复行，得到虚拟表vt10。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;这一步是将数据复制到内存中相同的临时表结构中进行的，不过该临时表多出了一个唯一性索引列用来做重复消除。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(11).对vt10进行排序，排序后的表为虚拟表vt11。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;(12).从vt11中根据top条件挑出其中满足的行，得到虚拟表vt12。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;如果没有应用order by，则记录是无序的集合，top挑出的行可能是随机的。也因此top一般要和order by字句一起使用。&lt;/p&gt;
&lt;p&gt;(13).将vt12从服务端返回给客户端作为最终查询结果。&lt;/p&gt;

&lt;h3&gt;1.2.2 MariaDB的逻辑执行顺序&lt;/h3&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180327112447535-1536427748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;MariaDB中，使用的是LIMIT子句实现和TOP子句一样的功能：限制输出行数。且它不支持&quot;WITH CUBE&quot;(直接忽略该关键词)。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;但和SQL Server、Oracle最大的不同是对SELECT列表的处理。在MS SQL和Oracle中，select_list是在group by和having子句之后才进行的，这意味着group by分组后，不能在select_list中指定非分组列(除非聚合运算)，反过来看，在group by中不能使用select_list中的别名列。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;但在MariaDB和MySQL中，select_list是在group by之前进行的。在group by中能够引用select_list中的列，在select_list中也能指定非分组列。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;mariadb和mysql在这一点上实际上是&quot;不规范&quot;的，因为它违背了数据库的设计范式。详细内容在后文分析。&lt;/p&gt;

&lt;h3&gt;1.2.3 MySQL的逻辑执行顺序&lt;/h3&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180327112525416-1577287397.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;和MariaDB之间并没有什么区别，仅仅只是MySQL不支持开窗函数over()。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;但是注意，从mysql 5.7.5开始，已经默认设置了&lt;span class=&quot;cnblogs_code&quot;&gt;sql_mode&lt;span&gt;=&lt;/span&gt;ONLY_FULL_GROUP_BY&lt;/span&gt;，这意味着MySQL默认也将遵循&lt;span lang=&quot;EN-US&quot;&gt;SQL规范，对于那些非分组列又没有进行聚合的列，都不允许出现在select_list中，除非select_list中使用的列是主键或者唯一索引列，之所以允许这样的行为，是因为有功能依赖性决定了它可以这样做，由此保证&quot;规范性&quot;。同样的，为何不规范的问题见后文。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;1.3 关于表表达式和虚拟表&lt;/h2&gt;
&lt;p class=&quot;01&quot;&gt;派生表、CTE(公用表表达式，有的数据库系统支持)、视图和表函数都是表，我们常称之为&quot;表表达式&quot;，只不过它们是虚拟表(这里的虚拟表和上面逻辑执行过程中产生的虚拟表vt不是同一个概念)。它们都必须满足成为表的条件，这也是为什么定义表表达式的时候有些语法不能使用。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;从关系模型上去分析。表对应的是关系模型中的关系，表中的列对应的是关系模型中的元素。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;&lt;span&gt;&lt;strong&gt;一方面，关系和元素都需要有唯一标识的名称，因此表和列也要有名称，即使表表达式也如此&lt;/strong&gt;&lt;/span&gt;。像派生表是嵌套在语句中的，无法在外部给它指定表明，因此必须为它指定一个表别名。同理，表表达式中的别名也一样，必须唯一且必须要有。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;&lt;span&gt;&lt;strong&gt;另一方面，关系中的元素是无序的，因此表和表表达式中的数据也应当是无序的&lt;/strong&gt;&lt;/span&gt;。虽然有些表表达式中可以使用ORDER BY子句，但这时候的ORDER BY只是为了让TOP/LIMIT子句来挑选指定数量的行，并不是真的会对结果排序。也就是说表表达式挑选出来的行就像表一样，其内数据行仍然是无序的，以后访问它们的时候是按照物理存储顺序进行访问的，即使表表达式的定义语句中使用了ORDER BY子句。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;关于数据的无序性和随机性，见下文。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;这里还请区分表表达式(虚拟表)和逻辑执行过程中我们想象出来的虚拟表。表表达式是实实在在符合关系模型的表，即使它可能只是一条或几条语句，也不会将相关数据行进行物理的存储，但在关系引擎看来，它就是表。而逻辑执行过程中我们想象出来的虚拟表，只是为了方便理解而描述出来的，实际上不会有这样的表，它们只是按一定规则存放在内存中的一些数据行，虽然某些步骤中可能也会使用系统自建的临时表存放中途的数据，但它们不是表。&lt;/p&gt;

&lt;h2&gt;1.4 关于表别名和列别名&lt;/h2&gt;
&lt;p class=&quot;01&quot;&gt;在SQL语句中，我们避免不了要对表、列使用别名进行引用。关于别名，需要注意两点：&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;&lt;span&gt;&lt;strong&gt;(1).定义了表别名后，在语句中对该表的引用都必须使用别名，而不能使用原表名。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;&lt;span&gt;&lt;strong&gt;(2).引用别名时，注意查询的逻辑处理过程。在某一阶段只能引用该阶段前面阶段定义的别名，使用该阶段后才定义的别名将报错。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;例如下面的两个查询语句，第一个错误原因是不能引用原表名，第二个错误是因为WHERE阶段不能引用SELECT阶段定义的字段别名。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; Student.Name &lt;span&gt;FROM&lt;/span&gt; Student &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; 学生表
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; Name,Sex &lt;span&gt;AS&lt;/span&gt; 性别 &lt;span&gt;FROM&lt;/span&gt; Student &lt;span&gt;WHERE&lt;/span&gt; 性别 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;下面是正确的写法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 学生表.Name &lt;span&gt;FROM&lt;/span&gt; Student &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; 学生表
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; Name,Sex AS性别 &lt;span&gt;FROM&lt;/span&gt; Student &lt;span&gt;WHERE&lt;/span&gt; Sex &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;1.5 关于数据无序性和ORDER BY&lt;/h2&gt;
&lt;p class=&quot;01&quot;&gt;在关系型数据库中，必须时刻都铭记在心的是&quot;集合元素是无序&quot;的，体现在数据库中就是&quot;表中数据行是无序的&quot;，除非建立了相关索引。&lt;/p&gt;
&lt;p&gt;出于集合模型的考虑，像我们平时看到的有行、有列的二维表数据(下图左边)，更应该看作是下图右边的结合结构，因为集合是无序的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180327113120643-806202817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;由于数据无序，导致检索数据时都是按照存储时的物理顺序进行访问，如此检索得到的数据行都是随机而不保证任何顺序的，除非指定了&lt;span lang=&quot;EN-US&quot;&gt;ORDER BY子句。而使用&lt;span lang=&quot;EN-US&quot;&gt;ORDER BY查询得到的结果，它因为有序而不满足集合的概念。实际上&lt;span lang=&quot;EN-US&quot;&gt;ORDER BY生成的是一个游标结果。了解&lt;span lang=&quot;EN-US&quot;&gt;SQL的人，都知道能不用游标就尽量不用游标，因为它的效率相比符合集合概念的&lt;span lang=&quot;EN-US&quot;&gt;SQL语句来说，要慢很多个数量级。但也不能一棍子将其打死，因为有时候使用游标确实能比较容易达到查询目标。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;在&lt;span lang=&quot;EN-US&quot;&gt;SQL中没有使用&lt;span lang=&quot;EN-US&quot;&gt;ORDER BY时，有不少子句的返回结果&lt;span lang=&quot;EN-US&quot;&gt;(虚拟表&lt;span lang=&quot;EN-US&quot;&gt;)都是随机的，因为实在没办法去保证顺序，但却又要求返回数据。例如直接进行 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; t;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;，再例如&lt;span lang=&quot;EN-US&quot;&gt;TOP/LIMIT子句。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;&lt;strong&gt;&lt;span&gt;纵观整个&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;SQL的各个环节，不难发现很多时候获取随机行数据是不应该的，因为这种不确定性，让我们操作数据时显得更出乎意料、更危险&lt;/span&gt;。&lt;/span&gt;&lt;/strong&gt;因此，除非不得不显示随机数据，标准&lt;span lang=&quot;EN-US&quot;&gt;SQL都会通过一些手段让获取随机数据的行为失败，而且在可能获取随机数据的时候，一般都会给出相关的建议和提示。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;MySQL、&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;mariadb之所以和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;sql server、&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;oracle的语法相差那么大，归根结底就是对待关系型数据库的范式要求和随机数据的态度不同。&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;MySQL、&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;mariadb总是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&quot;偷奸耍滑&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&quot;，在本无法满足关系型数据库范式的时候，它们总是挑选一个随机单行数据出来，让返回结果满足范式要求，最典型的就是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;group by的处理方式&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;不过&lt;span lang=&quot;EN-US&quot;&gt;MySQL从&lt;span lang=&quot;EN-US&quot;&gt;5.7.5版本开始，已经逐渐走向规范化了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;这里并非是要否认&lt;span lang=&quot;EN-US&quot;&gt;mysql、&lt;span lang=&quot;EN-US&quot;&gt;mariadb的设计模式，正所谓每个数据库系统都有自己对标准&lt;span lang=&quot;EN-US&quot;&gt;SQL的扩展方式，&lt;span lang=&quot;EN-US&quot;&gt;MySQL只是走了一条和标准&lt;span lang=&quot;EN-US&quot;&gt;SQL不同的路而已。而且关系模型的范式本就是人为定义的，为何不能违反呢？甚至可以说，表所满足的范式越强，检索表时的性能越低，&lt;span lang=&quot;EN-US&quot;&gt;nosql就没有关系模型的范式要求。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;在后文，将在多处分析标准&lt;span lang=&quot;EN-US&quot;&gt;SQL为什么不允许某些语法，同时还会提到&lt;span lang=&quot;EN-US&quot;&gt;MySQL和&lt;span lang=&quot;EN-US&quot;&gt;mariadb是如何&lt;span lang=&quot;EN-US&quot;&gt;&quot;偷奸耍滑&lt;span lang=&quot;EN-US&quot;&gt;&quot;的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;1.6 关于TOP(或LIMIT)和ORDER BY&lt;/h2&gt;
&lt;p class=&quot;01&quot;&gt;TOP和LIMIT是限制输出行数量，它们挑选数据行时是随机的(根据物理访问顺序)，所以得到的结果也是随机的。因此，建议TOP/LIMIT和ORDER BY一起使用。但即使如此，仍是不安全的。例如，ORDER BY的列中有重复值，那么TOP/LIMIT的时候如何决定获取哪些行呢？见如下LIMIT的示例(TOP也一样)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
MariaDB &lt;span&gt;[&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; Student &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+----------+------+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; sid  &lt;span&gt;|&lt;/span&gt; name     &lt;span&gt;|&lt;/span&gt; age  &lt;span&gt;|&lt;/span&gt; class  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+----------+------+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;6&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; zhaoliu  &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;19&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; lisi     &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;20&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C#     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;8&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; sunba    &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;20&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C&lt;span&gt;++&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; zhangsan &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;21&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; wangwu   &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;21&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; chenyi   &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;22&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;7&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; qianqi   &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;22&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; huanger  &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;23&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;9&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; yangjiu  &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;24&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+----------+------+--------+&lt;/span&gt;
&lt;span&gt; 
MariaDB &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; Student &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; age limit &lt;span&gt;9&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+----------+------+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; sid  &lt;span&gt;|&lt;/span&gt; name     &lt;span&gt;|&lt;/span&gt; age  &lt;span&gt;|&lt;/span&gt; class  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+----------+------+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;6&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; zhaoliu  &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;19&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; lisi     &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;20&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C#     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;8&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; sunba    &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;20&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C&lt;span&gt;++&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; zhangsan &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;21&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; wangwu   &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;21&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; chenyi   &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;22&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;7&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; qianqi   &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;22&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; huanger  &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;23&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;9&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; yangjiu  &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;24&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+----------+------+--------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;从两次查询结果中看到，即使都是对age进行升序排列，但age=20的两行前后顺序不一致，age=22的行顺序也不一致。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;因此一般会给另一个建议，为了确保数据一定是符合预期的，在order by中应该再加一列(最好具有唯一性)作为决胜属性，例如对age排序后再按照sid排序，这样就能保证返回结果不是随机的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; Student &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; age,sid;
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; Student &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; age,sid limit &lt;span&gt;9&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;1.7 关于DISTINCT和GROUP BY&lt;/h2&gt;
&lt;p class=&quot;01&quot;&gt;DISTINCT子句用于消除select_list列的重复行，这很容易理解。&lt;span&gt;&lt;strong&gt;大多数情况下，DISTINCT子句在功能上都可以认为等价于group by子句。有些DISTINCT不适合做的操作，可以在GROUP BY中来完成。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;例如下面两个SQL语句是等价的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;distinct&lt;/span&gt; class,age &lt;span&gt;from&lt;/span&gt;&lt;span&gt; Student; 
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; class,age &lt;span&gt;from&lt;/span&gt; Student &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; class,age;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;正因为等价，很多时候对DISTINCT的优化行为总是和GROUP BY的优化行为一致。以下是sql server上对上述两条语句的执行计划：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;distinct&lt;/span&gt; class,age &lt;span&gt;from&lt;/span&gt;&lt;span&gt; Student;
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;Sort(DISTINCT ORDER BY:([test].[dbo].[Student].[class] ASC, [test].[dbo].[Student].[age] ASC))&lt;/span&gt;
       &lt;span&gt;|&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;Table Scan(OBJECT:([test].[dbo].[Student]))&lt;/span&gt;
 &lt;span&gt;select&lt;/span&gt; class,age &lt;span&gt;from&lt;/span&gt; Student &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; class,age;
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;Sort(DISTINCT ORDER BY:([test].[dbo].[Student].[class] ASC, [test].[dbo].[Student].[age] ASC))&lt;/span&gt;
       &lt;span&gt;|&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;Table Scan(OBJECT:([test].[dbo].[Student]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;从结果中看到，执行DISTINCT去除重复行时，默认就带有了排序过程。实际上，DISTINCT几乎总是会将数据复制到内存中的一张临时表中进行，该临时表的结构和前面得到的虚拟表字段结构几乎一致，但却多了一个唯一性索引列用来做重复消除。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;但如果DISTINCT结合GROUP BY子句呢？其实不建议这么做。这里也不讨论这种问题。&lt;/p&gt;

&lt;h2&gt;1.8 关于DISTINCT和ORDER BY&lt;/h2&gt;
&lt;p class=&quot;01&quot;&gt;既然DISTINCT默认就带了排序行为，那此时再指定ORDER BY会如何？例如下面的语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;distinct&lt;/span&gt; class,age &lt;span&gt;from&lt;/span&gt; Student &lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; age &lt;span&gt;desc&lt;/span&gt;; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;在SQL Server中的执行计划如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;distinct&lt;/span&gt; class,age &lt;span&gt;from&lt;/span&gt; Student &lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; age &lt;span&gt;desc&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;Sort(DISTINCT ORDER BY:([test].[dbo].[Student].[age] DESC, [test].[dbo].[Student].[class] ASC))&lt;/span&gt;
       &lt;span&gt;|&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;Table Scan(OBJECT:([test].[dbo].[Student]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;其实和前面没什么区别，无非是先对order by列进行排序而已。但是从这里能看出，&lt;span&gt;&lt;strong&gt;DISTINCT和ORDER BY字句其实没有严格的逻辑执行先后顺序，甚至ORDER BY指定的排序列还优先于DISTINCT的排序行为。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;但是，DISTINCT和ORDER BY结合时，order by的排序列是有要求的：排序列必须是select_list中的列(distinct很多时候都可以看作group by)。例如 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;distinct&lt;/span&gt; a,b &lt;span&gt;from&lt;/span&gt; t &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; c;&lt;/span&gt; 是错误的。但MySQL和mariadb又在这里进行了扩展，它们的排序列允许非select_list中的列。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;先说标准SQL为何不允许使用非select_list中的列，这归根结底还是关系型数据库的范式问题。假如DISTINCT消除了部分列的重复值，最终将只返回一条重复记录，而如果使用非select_list的列排序，将要求返回一条重复记录的同时还要返回每个重复值对应的多条记录以便排序，而在要求范式的关系表中是无法整合这样的结果。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;例如表中数据如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
MariaDB &lt;span&gt;[&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; sid,age,class &lt;span&gt;from&lt;/span&gt; Student &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; class;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+------+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; sid  &lt;span&gt;|&lt;/span&gt; age  &lt;span&gt;|&lt;/span&gt; class  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+------+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;7&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;22&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;20&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C#     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;8&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;20&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C&lt;span&gt;++&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;22&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;21&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;6&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;19&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;9&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;24&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;23&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;21&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+------+--------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;现在对class列进行去重。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
MariaDB &lt;span&gt;[&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;distinct&lt;/span&gt; class &lt;span&gt;from&lt;/span&gt; Student &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; class;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; class  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; C      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; C#     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; C&lt;span&gt;++&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;现在假设order by的排序列能使用sid进行排序。那么期待的结果将是根据如下数据进行返回的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;distinct&lt;/span&gt; class &lt;span&gt;from&lt;/span&gt; Student &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; sid;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; sid  &lt;span&gt;|&lt;/span&gt; class  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;7&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C#     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;8&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C&lt;span&gt;++&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;6&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;9&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+--------+ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;这样的结构已经违反了关系型数据库的范式要求。因此，sql server和oracle会直接对该语句报错。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;但是MySQL/mariadb就允许在order by中使用非select_list列进行排序。它们是如何&quot;偷奸耍滑&quot;的呢？还是上面违反关系模型范式的数据结构，MySQL和mariadb会从Java和Python对应的sid中挑选第一行(order by已经对其排序，因此不是随机数据)，然后和Java、Python分别组成一行，得到如下虚拟表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; sid  &lt;span&gt;|&lt;/span&gt; class  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;7&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C#     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;8&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C&lt;span&gt;++&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+--------+ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;然后将此虚拟表中非select_list中的列都去掉，得到最终结果。真的是最终结果吗？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
MariaDB &lt;span&gt;[&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;distinct&lt;/span&gt; class &lt;span&gt;from&lt;/span&gt; Student &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; sid; 
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; class  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; C#     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; C      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; C&lt;span&gt;++&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;虽然返回的结果内容上和前面分析的一致，但是顺序却不一致，影响因素就是&quot;order by sid&quot;。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;其实认真观察结果，很容易就发现它们是根据sid排序后再对class去重得到的结果。也就是说，&lt;span&gt;&lt;strong&gt;ORDER BY子句比DISTINCT子句先执行了&lt;/strong&gt;&lt;/span&gt;。稍稍分析一下，这里先以sid排序，得到如下虚拟结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------+------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; class  &lt;span&gt;|&lt;/span&gt; sid  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------+------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; C#     &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;6&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; C      &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;7&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; C&lt;span&gt;++&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;8&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;9&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------+------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;再对class去重，得到如下虚拟结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; sid  &lt;span&gt;|&lt;/span&gt; class  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;6&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;9&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C#     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;7&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;8&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C&lt;span&gt;++&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;最后去掉非select_list中的列sid，得到最终结果。&lt;/p&gt;

&lt;h2&gt;1.9 关于标准SQL的GROUP BY&lt;/h2&gt;
&lt;p class=&quot;01&quot;&gt;如果让我给SQL语句的逻辑执行顺序划分为两段式，我会将&quot;三八线&quot;划在GROUP BY这里。&lt;span&gt;&lt;strong&gt;因为在GROUP BY之前甚至完全没有GROUP BY子句的语句部分，操作的对象都是表中的每行数据，也就是说操作的上下文环境是表的数据行。而在GROUP BY之后，操作的对象是组而不再是行，也就是说操作的上下文将从表中的数据行变成组。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;直白一点说，GROUP BY之前，关系引擎的目光集中在数据行的细节上，GROUP BY之后，关系引擎的目光则集中在组上。至于每个分组中的行，对关系引擎来说是透明的，它不在乎组中行这种细节性的东西是否存在，而且按照关系模型的要求，也不应该认为它们存在。注意，这里说的是标准SQL，而MySQL和mariadb又&quot;偷奸耍滑&quot;去了。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;举个例子就很容易理解GROUP BY前后侧重点的变化过程。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;以下是Student表的内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
MariaDB &lt;span&gt;[&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; Student;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+----------+------+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; sid  &lt;span&gt;|&lt;/span&gt; name     &lt;span&gt;|&lt;/span&gt; age  &lt;span&gt;|&lt;/span&gt; class  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+----------+------+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; chenyi   &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;22&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; huanger  &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;23&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; zhangsan &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;21&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; lisi     &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;20&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C#     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; wangwu   &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;21&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;6&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; zhaoliu  &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;19&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;7&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; qianqi   &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;22&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;8&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; sunba    &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;20&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C&lt;span&gt;++&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;9&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; yangjiu  &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;24&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+----------+------+--------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在按照class进行分组。下面是分组后经过我加工的表结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180327114040772-1434829019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;其中第一列是分组得到的结果，我把它和原表的数据结合在一起了。注意，这是一个不符合关系模型范式要求的结构。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;在分组前，关系引擎会对sid、name、age和class列的每一行进行筛选。但是分组后，关系引擎只看得到第一列，也就是class列，而sid、name和age列被直接忽略，因此无法引用它们。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;关于GROUP BY，有以下两个问题：&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;&lt;span&gt;&lt;strong&gt;1.为什么分组之后涉及到对组的操作时只允许返回标量值？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;标量值即单个值，比如聚合函数返回的值就是标量值。在分组之后，组将成为表的工作中心，一个组将成为一个整体，所有涉及到分组的查询，将以组作为操作对象。组的整体是重要的，组中的个体不重要，甚至可以理解为分组后只有组的整体，即上图中左边加粗的部分，而组中的个体是透明的。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;以上图中的第一条记录举一个通俗的例子。在分组以前，知道了该学生的姓名&quot;chenyi&quot;之后，关注点可能要转化为它的主键列sid值&quot;1&quot;，因为主键列唯一标识每一行，知道了主键值就知道了该行的所有信息。而在分组之后，关注的中心只有分组列class，无论是知道姓名&quot;chenyi&quot;还是学号&quot;1&quot;都不是关注的重点，&lt;span&gt;&lt;strong&gt;重点是该行记录(集合的元素)是属于&quot;Java&quot;班级的&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;这就能解释为什么只能以组作为操作对象并返回标量值。例如，在分组之后进行SUM汇总，将以&quot;Java&quot;班作为一个汇总对象，以&quot;Python&quot;班作为另一个汇总对象，汇总的将是每个分组的总值，而不是整个表的总值，并且汇总的值是一个标量值，不会为组中的每行都返回这个汇总值。否则就违反了关系模型的范式。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;&lt;span&gt;&lt;strong&gt;2.为什么分组之后只能使用GROUP BY列表中的列，如果不在GROUP BY列表中，就必须进行聚合？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;分组后分组列成为表的工作中心，以后的操作都必须只能为组这个整体返回一个标量值。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;如果使用了非分组列表的列，将不能保证这个标量值。例如，分组后对&quot;Java&quot;班返回了一个汇总值，假如同时要使用sid列和name列，因为这两列没有被聚合或分组，因此只能为这两列的每个值返回一行，也就是说在返回汇总标量值的同时还要求返回&quot;Java&quot;班组中的每一行，要实现这样的结果，需要整合为如上图所示的结果，但在关系表中这是违反规范的。正如前文介绍的DISTINCT一样，ORDER BY的排序列只能使用DISTINCT去重的select_list列表。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;因此，分组后只能使用分组列表中的列。&lt;span&gt;&lt;strong&gt;如果要使用非分组列表中的列，应该让它们也返回一个标量值，只有这样才能实现分组列和非分组列结果的整合。&lt;/strong&gt;&lt;/span&gt;例如，下面的语句将会产生错误，因为select_list在GROUP BY阶段后执行，且select_list中的列没有包含在GROUP BY中，也没有使用聚合函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; sid,name &lt;span&gt;FROM&lt;/span&gt; Student &lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; class;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;事实上从严格意义上看待这条语句，它没有实现分组的意义：既然不返回分组列的分组结果，那为什么还要进行分组呢？&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;其实，&lt;span&gt;&lt;strong&gt;无论是标准SQL还是MySQL、mariadb，执行group by子句时都会表扫描并创建一个临时表(此处为了说明group by的特性，不考虑group by使用索引优化的情况)，这个临时表中只有group by的分组列，没有那些非分组列。这也是前面说group by之后，关系引擎的目光从行转为组的真正原因。&lt;/strong&gt;&lt;/span&gt;由此，已经足够说明为什么select_list中不能使用非group by的分组列。&lt;/p&gt;

&lt;h2&gt;1.10 关于MySQL/MariaDB的GROUP BY&lt;/h2&gt;
&lt;p class=&quot;01&quot;&gt;MySQL和mariadb的GROUP BY有几个扩展特性(都是标准SQL不支持的)：&lt;span&gt;&lt;strong&gt;(1).能够在group by中使用列别名;(2).可以在select_list中使用非分组列;(3).可以在group by子句中指定分组列的升序和降序排序&lt;/strong&gt;。&lt;/span&gt;下面分别说明这些特性。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;&lt;span&gt;&lt;strong&gt;(1).group by&lt;/strong&gt;&lt;strong&gt;中能够使用列别名。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;其实对于MySQL和mariadb而言，并非是有一个专门的select_list筛选过程，使得筛选完成后，后续的步骤就能使用这些筛选出来的列。而是&lt;span&gt;&lt;strong&gt;从WHERE子句筛选了行之后，后面所有的过程都可以对select_list进行检索扫描。其中ORDER BY子句扫描select_list的时候是先检索出列表达式，再检索所引用表中的列，直到找出所有的排序列；而GROUP BY和HAVING子句则是先检索表中的列，再检索列表达式，直到找出所有的分组列。&lt;/strong&gt;&lt;/span&gt;因此，MySQL、mariadb能够使用列别名。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;下面两个查询的例子很能说明问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
MariaDB &lt;span&gt;[&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; &lt;span&gt;@a&lt;/span&gt;:&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;select&lt;/span&gt; sid,name,class,&lt;span&gt;@a&lt;/span&gt;:&lt;span&gt;=&lt;/span&gt;&lt;span&gt;@a&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; class &lt;span&gt;from&lt;/span&gt; Student &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; class;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+----------+--------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; sid  &lt;span&gt;|&lt;/span&gt; name     &lt;span&gt;|&lt;/span&gt; class  &lt;span&gt;|&lt;/span&gt; class &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+----------+--------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; chenyi   &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; huanger  &lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; zhangsan &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; lisi     &lt;span&gt;|&lt;/span&gt; C#     &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; wangwu   &lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;6&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; zhaoliu  &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;6&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;7&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; qianqi   &lt;span&gt;|&lt;/span&gt; C      &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;7&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;8&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; sunba    &lt;span&gt;|&lt;/span&gt; C&lt;span&gt;++&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;8&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;9&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; yangjiu  &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;9&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+----------+--------+-------+&lt;/span&gt;
&lt;span&gt; 
MariaDB &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; &lt;span&gt;@a&lt;/span&gt;:&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;select&lt;/span&gt; sid,name,class,&lt;span&gt;@a&lt;/span&gt;:&lt;span&gt;=&lt;/span&gt;&lt;span&gt;@a&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; class &lt;span&gt;from&lt;/span&gt; Student &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; class;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+---------+--------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; sid  &lt;span&gt;|&lt;/span&gt; name    &lt;span&gt;|&lt;/span&gt; class  &lt;span&gt;|&lt;/span&gt; class &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+---------+--------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;7&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; qianqi  &lt;span&gt;|&lt;/span&gt; C      &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;7&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; lisi    &lt;span&gt;|&lt;/span&gt; C#     &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;8&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; sunba   &lt;span&gt;|&lt;/span&gt; C&lt;span&gt;++&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;8&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; chenyi  &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; huanger &lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+---------+--------+-------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;上面两个查询中，表达式 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;@a&lt;/span&gt;:&lt;span&gt;=&lt;/span&gt;&lt;span&gt;@a&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt; 的别名为class，和Student表中的class列重复。在第一个查询中，使用order by对class排序，由于order by先从select_list中的列表达式开始检索，因此这个排序列class是 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;@a&lt;/span&gt;:&lt;span&gt;=&lt;/span&gt;&lt;span&gt;@a&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt; 对应的列，结果也正符合此处的分析。第二个查询中，使用group by对class进行分组，因为它先检索表的字段名，因此这个分组列class是Student中的class列，结果也同样符合此处的分析。&lt;/p&gt;
&lt;p&gt;但是，在标准SQL中这是不允许的行为。虽然在select_list中出现两个同名的列名称是允许的，但是在引用列别名的时候，无论是group by还是order by子句或其他子句，都认为同列名会导致二义性。标准SQL严格遵循select_list是&quot;同时性的&quot;，引用列的时候无法像mysql/mariadb一样分先后顺序地检索select_list。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180327114436346-509362640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;&lt;span&gt;&lt;strong&gt;(2).&lt;/strong&gt;&lt;strong&gt;在group by子句中可以指定分组列的升序和降序排序。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;无论是标准SQL还是MySQL、mariadb，group by分组的时候，都会按照分组列升序排序。只不过标准SQL中只能使用默认的升序，而MySQL、mariadb可以自行指定排序方式。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
MariaDB &lt;span&gt;[&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; class &lt;span&gt;from&lt;/span&gt; Student &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; class;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; class  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; C      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; C#     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; C&lt;span&gt;++&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180327114532404-869559567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;很明显，结果中是按照分组列class进行升序排序的。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;在MySQL、mariadb中可以为group by子句指定排序方式。而MS SQL和Oracle不允许。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
MariaDB &lt;span&gt;[&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; class &lt;span&gt;from&lt;/span&gt; Student &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; class &lt;span&gt;desc&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; class  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; C&lt;span&gt;++&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; C#     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; C      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不过MS SQL和Oracle也能实现同样的功能，只需使用ORDER BY即可。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180327114558430-276018320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;请记住，GROUP BY子句默认会进行排序，这一点很重要。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;&lt;span&gt;&lt;strong&gt;(3).&lt;/strong&gt;&lt;strong&gt;在select_list中可以使用非分组列。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;MySQL和MariaDB在这里又&quot;偷奸耍滑&quot;了。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;如下查询：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
MariaDB &lt;span&gt;[&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; Student &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; class;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+---------+------+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; sid  &lt;span&gt;|&lt;/span&gt; name    &lt;span&gt;|&lt;/span&gt; age  &lt;span&gt;|&lt;/span&gt; class  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+---------+------+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;7&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; qianqi  &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;22&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; lisi    &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;20&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C#     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;8&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; sunba   &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;20&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C&lt;span&gt;++&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; chenyi  &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;22&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; huanger &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;23&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+---------+------+--------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上一小节分析了标准SQL的group by的特性，select_list中本无法使用非分组列，但这里却能使用，为什么呢？仍然使用上一小节加工后的数据结构来说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180327114640370-380333689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;标准SQL中之所以不能使用sid、name和age列，是因为group by的每个分组都是单行(标量)结果，如果使用了这些列，会违反关系模型的范式要求(一行对多行)。而MySQL、mariadb之所以允许，是因为它们会从重复的分组列中挑出一个随机行(注意随机这个字眼)，将它和分组列的单行组成一行，这样就满足范式要求了。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;例如上图中的Java组对应了4行记录，MySQL可能会挑sid=1(按照物理存储顺序挑，因此结果是随机的)的那行和Java组构成一行，Python组对应了2行记录，MySQL可能会挑sid=2的那行和Python构成一行。于是得到结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+---------+------+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; sid  &lt;span&gt;|&lt;/span&gt; name    &lt;span&gt;|&lt;/span&gt; age  &lt;span&gt;|&lt;/span&gt; class  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+---------+------+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;7&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; qianqi  &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;22&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; lisi    &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;20&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C#     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;8&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; sunba   &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;20&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C&lt;span&gt;++&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; chenyi  &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;22&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; huanger &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;23&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+---------+------+--------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;01&quot;&gt;MySQL和MariaDB用了一种不是办法的办法解决了关系模型的范式要求问题，使得select_list中能够使用非分组列。但因为挑选数据的时候具有随机性，因此不太建议如此使用。除非你知道自己在做什么，或者额外使用了ORDER BY子句保证挑选的数据是意料之中的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
MariaDB &lt;span&gt;[&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; Student1 &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; class &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; sid &lt;span&gt;desc&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+----------+------+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; sid  &lt;span&gt;|&lt;/span&gt; name     &lt;span&gt;|&lt;/span&gt; age  &lt;span&gt;|&lt;/span&gt; class  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+----------+------+--------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;8&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; sunba    &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;20&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C&lt;span&gt;++&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;7&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; qianqi   &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;22&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; lisi     &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;20&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; C#     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; zhangsan &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;21&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Java   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;    &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; huanger  &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;23&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Python &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----+----------+------+--------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;1.11 关于OVER( )&lt;/h2&gt;
&lt;p class=&quot;01&quot;&gt;想必写过GROUP BY子句的人都很恼火选择列中不能使用非分组列，明明很想查看分组后所有行的结果，GROUP BY却阻止了这样的行为。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;万幸，还有一个OVER()子句供我们实现目标。不过MySQL中不支持OVER()子句，ms sql、Oracle和mariaDB(MariaDB 10.2.0开始引入该功能)都支持，之所以MySQL不支持，我想是因为它的GROUP BY本就允许select_list中使用非分组列。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;over()子句常被称为窗口函数或开窗函数，其实它就是进行分组，分组后也能进行聚合运算。只不过在over()的世界里，组称为窗口。&lt;/p&gt;
&lt;p&gt;例如，以下是按照StudentID列进行分组。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180327114754989-2087249966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;其实从上面的分组形式上看，它和GROUP BY分组的不同之处在于GROUP BY要求每个分组必须返回单行，而开窗则可以将单行数据同时分配给多个行，从而构成一个窗口。group by的侧重点是组，而开窗的侧重点在于组中的每行。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;窗口函数很强大，强大到仅仅这一个专题就可以写成一本书。本文不会对其多做描述，而是围绕本文的主题&quot;语句的逻辑执行顺序&quot;稍作分析。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;over()子句是对数据行按照指定列进行开窗(划分窗口)，开窗后可以围绕每一组中的行进行操作，例如排序、聚合等等。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;假如先执行DISTINCT去重再执行OVER，那么去重后再对具有唯一值的列(或多列)进行开窗就没有任何意义。例如上图中，如果先对StudentID去重，那么去重后将只有3行，这3行都是唯一值，没必要再去开窗，而且这也不符合开窗的目的。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;&lt;span&gt;&lt;strong&gt;因此OVER()是在DISTINCT之前完成开窗的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;另外，建议DISTINCT不要和OVER()一起使用，因为这时候的DISTINCT根本没有任何作用，但却会消耗额外的资源。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;如果真的想对某些列去重后再开窗，可以借助GROUP BY。因为DISTINCT的功能基本等价于GROUP BY，但GROUP BY却先执行。&lt;/p&gt;

&lt;h2&gt;1.12 总结&lt;/h2&gt;
&lt;p class=&quot;01&quot;&gt;虽然SQL语句的逻辑处理过程和真正的执行计划在有些地方会有所不同。但是理解逻辑处理过程，对学习SQL很有帮助。&lt;/p&gt;
&lt;p class=&quot;01&quot;&gt;回顾全文，不难发现MySQL、MariaDB对SQL的扩展实现了不少标准SQL中不允许的语法。能够实现这样的行为，是因为MySQL/mariadb总是通过获取一个随机行的行为保证结果满足关系模型的范式要求。也正因为这样，使得看上去mysql/mariadb的语法和标准SQL的语法没什么大区别，连逻辑执行顺序都基本一致，但它们却会对其他子句产生连带反应，导致最终的执行结果不一致。&lt;/p&gt;
&lt;p&gt;虽然实际编写SQL语句的过程中，无需去在意这其中的为什么，但我个人觉得，理解它们很有帮助，毕竟关系型数据库的本质在于关系模型和集合模型。而且在我自己的体会中，在深入学习SQL的过程中，经常会感受到SQL和关系、集合之间的联系，这种感受可能不会立刻被自己发现，但回首一想，还真是那么回事。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8656828.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/8656828.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 27 Mar 2018 04:46:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/8656828.html</dc:identifier>
</item>
</channel>
</rss>