<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SpringBoot | 第十六章：web应用开发 - oKong_趔趄的猿</title>
<link>http://www.cnblogs.com/okong/p/springboot-sixteen.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/okong/p/springboot-sixteen.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;前面讲了这么多直接，都没有涉及到前端web和后端交互的部分。因为作者所在公司是采用&lt;code&gt;前后端分离&lt;/code&gt;方式进行&lt;code&gt;web&lt;/code&gt;项目开发了。所以都是后端提供&lt;code&gt;api&lt;/code&gt;接口，前端根据&lt;code&gt;api文档&lt;/code&gt;或者服务自行调用的。后台也有读者说为何没有关于web这部分的集成文章。本章节就主要讲解下如何渲染页面的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一点知识&quot;&gt;一点知识&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我们知道，在&lt;code&gt;web&lt;/code&gt;开发时，一般都会涉及到很多的静态资源，如&lt;code&gt;js&lt;/code&gt;、&lt;code&gt;image&lt;/code&gt;、&lt;code&gt;css&lt;/code&gt;文件等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;SpringBoot&lt;/code&gt;的默认的静态文件目录是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;/static&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/public&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/resources&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/META-INF/resources&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/13169342-7063316ce8e6364a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;默认静态文件目录&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以一般上我们只需要把静态文件放入前面的四个任一一个即可。默认都放在&lt;code&gt;static&lt;/code&gt;下，对应路径即为：&lt;code&gt;src/main/resources/static&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;而从官网文档里也可以获悉，为了实现动态的html，&lt;code&gt;SpringBoot&lt;/code&gt;是通过模版引擎进行页面结果渲染的，目前(1.5.15)版本的提供默认配置的模版引擎主要为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/13169342-ffb8dc5a8d8cf1da.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;模版引擎&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于模版引擎而言，&lt;code&gt;SpringBoot&lt;/code&gt;默认存放模版文件的路径为&lt;code&gt;src/main/resources/templates&lt;/code&gt;，当然也可以通过配置文件进行修改的。&lt;strong&gt;因为不同的模版引擎对应的配置属性是不一样，所以在具体讲解模版引擎时，会提到的。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;当然了，使用&lt;code&gt;jsp&lt;/code&gt;也是可以的，&lt;strong&gt;但官方已经不建议使用&lt;code&gt;JSP&lt;/code&gt;了&lt;/strong&gt;，本文也会讲解下&lt;code&gt;SpringBoot&lt;/code&gt;下&lt;code&gt;JSP&lt;/code&gt;的支持的，比较有很多老的项目还是使用&lt;code&gt;JSP&lt;/code&gt;居多的。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;知道了以上的一些默认配置和知识点后，就可以进行模版引擎的集成使用了。本章节主要讲解下常用的&lt;code&gt;FreeMarker&lt;/code&gt;、&lt;code&gt;Thymeleaf&lt;/code&gt;及&lt;code&gt;JSP&lt;/code&gt;三个的集成和使用，其他的基本用法都一样，就是各模版引擎的语法的差异了。&lt;/p&gt;
&lt;h2 id=&quot;freemarker支持&quot;&gt;FreeMarker支持&lt;/h2&gt;
&lt;p&gt;FreeMarker是一款模板引擎： 即一种基于模板和要改变的数据，并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/13169342-df314e6ef8edf6b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;示例&quot;/&gt;&lt;/p&gt;
&lt;p&gt;0.POM依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-freemarker&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.&lt;code&gt;application.properties&lt;/code&gt;配置加入相关配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 缓存配置 开发阶段应该配置为false 因为经常会改
spring.freemarker.cache=false

# 模版后缀名 默认为ftl
spring.freemarker.suffix=html

# 文件编码
spring.freemarker.charset=UTF-8

# 模版加载的目录
spring.freemarker.template-loader-path=classpath:/templates/

# 配置
# locale    该选项指定该模板所用的国家/语言选项
# number_format    指定格式化输出数字的格式：currency、
# boolean_format    指定两个布尔值的语法格式,默认值是true,false
# date_format,time_format,datetime_format    定格式化输出日期的格式
# time_zone    设置格式化输出日期时所使用的时区
# 数字 千分位标识
spring.freemarker.settings.number_format=,##0.00 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;题外话：详细的配置可参见&lt;code&gt;org.springframework.boot.autoconfigure.freemarker.FreeMarkerProperties&lt;/code&gt;类，或者直接IDE直接配置文件点击查看。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.编写控制层&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FreemarkerController.kava&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//因为是返回页面 所以不能是@RestController
@Controller
@RequestMapping(&quot;/freemarker&quot;)
public class FreemarkerController {
    
    //正常和springmvc设置返回参数是意义的用法了
    @GetMapping(&quot;/map&quot;)
    public String index(String name,ModelMap map) {
        map.addAttribute(&quot;name&quot;, name);
        map.addAttribute(&quot;from&quot;, &quot;lqdev.cn&quot;);
        //模版名称，实际的目录为：src/main/resources/templates/freemarker.html
        return &quot;freemarker&quot;;
    }
    
    @GetMapping(&quot;/mv&quot;)
    public String index(String name,ModelAndView mv) {
        mv.addObject(&quot;name&quot;, name);
        mv.addObject(&quot;from&quot;, &quot;lqdev.cn&quot;);
        //模版名称，实际的目录为：src/main/resources/templates/freemarker.html
        return &quot;freemarker&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.编写模版文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;freemarker.html&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head lang=&quot;en&quot;&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt;
    &amp;lt;title&amp;gt;freemarker简单示例&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Hello Freemarker&amp;lt;/h1&amp;gt;
&amp;lt;!-- 这里注意：默认变量都不能为null的， 当参数为null时，会发生异常的 --&amp;gt;
&amp;lt;!-- 这里后面几个&quot;!&quot;避免下，这样就是空白了 --&amp;gt;
&amp;lt;h2&amp;gt;名称：${name!}，来自：${from}&amp;lt;/h2&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.启动应用，访问：http://127.0.0.1:8080/freemarker/mv?name=oKong 或者 http://127.0.0.1:8080/freemarker/map?name=oKong 就能查看页面了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/13169342-12925d2d75c6d466.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;关于一些&lt;code&gt;Freemarker&lt;/code&gt;的语法这里就不说明了，大家可到官网查看下：&lt;a href=&quot;https://freemarker.apache.org/docs/index.html&quot; class=&quot;uri&quot; title=&quot;https://freemarker.apache.org/docs/index.html&quot;&gt;https://freemarker.apache.org/docs/index.html&lt;/a&gt;或者，中文参考(可能版本不是最新)：&lt;a href=&quot;http://freemarker.foofun.cn/toc.html&quot; class=&quot;uri&quot; title=&quot;http://freemarker.foofun.cn/toc.html&quot;&gt;http://freemarker.foofun.cn/toc.html&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;thymeleaf支持&quot;&gt;Thymeleaf支持&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;Thymeleaf&lt;/code&gt;是一个&lt;code&gt;XML/XHTML/HTML5&lt;/code&gt;模板引擎，可用于Web与非Web环境中的应用开发。&lt;code&gt;Thymeleaf&lt;/code&gt;的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。接下来，这些标签属性就会在DOM（文档对象模型）上执行预先制定好的逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;0.pom依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.&lt;code&gt;application.properties&lt;/code&gt;配置加入相关配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 启用缓存:建议生产开启
spring.thymeleaf.cache=false 
# 建议模版是否存在
spring.thymeleaf.check-template-location=true 
# Content-Type 值
spring.thymeleaf.content-type=text/html 
# 是否启用
spring.thymeleaf.enabled=true 
# 模版编码
spring.thymeleaf.encoding=UTF-8 
# 应该从解析中排除的视图名称列表（用逗号分隔）
spring.thymeleaf.excluded-view-names= 
# 模版模式
spring.thymeleaf.mode=HTML5 
# 模版存放路径
spring.thymeleaf.prefix=classpath:/templates/ 
# 模版后缀
spring.thymeleaf.suffix=.html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.编写控制层&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ThymeleafController.java&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Controller
@RequestMapping(&quot;/thymeleaf&quot;)
public class ThymeleafController {

    // 正常和springmvc设置返回参数是意义的用法了
    @GetMapping(&quot;/map&quot;)
    public String index(String name, ModelMap map) {
        map.addAttribute(&quot;name&quot;, name);
        map.addAttribute(&quot;from&quot;, &quot;lqdev.cn&quot;);
        // 模版名称，实际的目录为：src/main/resources/templates/thymeleaf.html
        return &quot;thymeleaf&quot;;
    }

    @GetMapping(&quot;/mv&quot;)
    public ModelAndView index(String name) {
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;name&quot;, name);
        mv.addObject(&quot;from&quot;, &quot;lqdev.cn&quot;);
        // 模版名称，实际的目录为：src/main/resources/templates/thymeleaf.html
        mv.setViewName(&quot;thymeleaf&quot;);
        return mv;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.编写模版文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;thymeleaf.html&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head lang=&quot;en&quot;&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt;
    &amp;lt;title&amp;gt;thymeleaf简单示例&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Hello thymeleaf&amp;lt;/h1&amp;gt;
&amp;lt;!-- 这里注意：拼接时 变量要单独使用${param}，其他的常量使用''包裹 --&amp;gt;
&amp;lt;h2 th:text=&quot;'名称：'+${name}+'，来自：'+${from}&quot;&amp;gt;默认值&amp;lt;/h2&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.启动应用，访问：http://127.0.0.1:8080/thymeleaf/mv?name=oKong 或者 http://127.0.0.1:8080/thymeleaf/map?name=oKong 就能查看页面了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/13169342-3d03066138982d1a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;jsp支持&quot;&gt;JSP支持&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;虽然&lt;code&gt;SpringBoot&lt;/code&gt;官方已经不建议使用&lt;code&gt;jsp&lt;/code&gt;了。但在一些老的项目迁移时，jsp的支持是毋庸置疑的。所以还是需要兼容的。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;0.pom依赖加入&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;!-- spring boot 内置tomcat jsp支持 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;tomcat-embed-jasper&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.&lt;code&gt;application.properties&lt;/code&gt;配置加入相关配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#jsp 支持
spring.mvc.view.suffix=.jsp
spring.mvc.view.prefix=/WEB-INF/jsp/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.编写控制层&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JspController.java&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Controller
@RequestMapping(&quot;/jsp&quot;)
public class JspController {
    
    //正常和springmvc设置返回参数是意义的用法了
        @GetMapping(&quot;/map&quot;)
        public String index(String name,ModelMap map) {
            map.addAttribute(&quot;name&quot;, name);
            map.addAttribute(&quot;from&quot;, &quot;lqdev.cn&quot;);
            //模版名称，实际的目录为：src/main/webapp/jsp/index.html
            return &quot;index&quot;;
        }
        
        @GetMapping(&quot;/mv&quot;)
        public ModelAndView index(String name) {
            ModelAndView mv = new ModelAndView();
            mv.addObject(&quot;name&quot;, name);
            mv.addObject(&quot;from&quot;, &quot;lqdev.cn&quot;);
            //模版名称，实际的目录为：src/main/webapp/jsp/index.html
            mv.setViewName(&quot;index&quot;);
            return mv;
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.&lt;code&gt;webapp/WEB-INF/jsp&lt;/code&gt;目录下编写jsp文件&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&amp;gt;
&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charsetUTF-8&quot;&amp;gt;
&amp;lt;title&amp;gt;jsp示例&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Hello Jsp&amp;lt;/h1&amp;gt;
&amp;lt;h2 &amp;gt;名称：${name}，来自：${from}&amp;lt;/h2&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.启动应用，访问：http://127.0.0.1:8080/jsp/mv?name=oKong 或者 http://127.0.0.1:8080/jsp/map?name=oKong 就能查看页面了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/13169342-bd7595d4950a888c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;这里需要注意&lt;/strong&gt;：在使用&lt;code&gt;spring-boot-maven-plugin&lt;/code&gt;打包插件时，默认情况下打包的应用时访问不了&lt;code&gt;jsp&lt;/code&gt;目录文件的，需要把版本修改为&lt;code&gt;1.4.2.RELEASE&lt;/code&gt;版本，同时&lt;code&gt;pom&lt;/code&gt;中加入&lt;code&gt;resource&lt;/code&gt;配置：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt; &amp;lt;resources&amp;gt;
    &amp;lt;!-- 打包时将jsp文件拷贝到META-INF目录下 --&amp;gt;
    &amp;lt;resource&amp;gt;
        &amp;lt;!-- 指定resources插件处理哪个目录下的资源文件 --&amp;gt;
        &amp;lt;directory&amp;gt;src/main/webapp&amp;lt;/directory&amp;gt;
        &amp;lt;!--注意此次必须要放在此目录下才能被访问到 --&amp;gt;
        &amp;lt;targetPath&amp;gt;META-INF/resources&amp;lt;/targetPath&amp;gt;
        &amp;lt;includes&amp;gt;
            &amp;lt;include&amp;gt;**/**&amp;lt;/include&amp;gt;
        &amp;lt;/includes&amp;gt;
    &amp;lt;/resource&amp;gt;
&amp;lt;!--     &amp;lt;resource&amp;gt;
          指定resources插件处理哪个目录下的资源文件
        &amp;lt;directory&amp;gt;src/main/resources/static&amp;lt;/directory&amp;gt;
        注意此次必须要放在此目录下才能被访问到
        &amp;lt;targetPath&amp;gt;META-INF/resources/static&amp;lt;/targetPath&amp;gt;
        &amp;lt;includes&amp;gt;
            &amp;lt;include&amp;gt;**/**&amp;lt;/include&amp;gt;
        &amp;lt;/includes&amp;gt;
    &amp;lt;/resource&amp;gt; --&amp;gt;
    &amp;lt;resource&amp;gt;
        &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
        &amp;lt;includes&amp;gt;
            &amp;lt;include&amp;gt;**/**&amp;lt;/include&amp;gt;
        &amp;lt;/includes&amp;gt;
&amp;lt;!--         &amp;lt;excludes&amp;gt;
           &amp;lt;exclude&amp;gt;src/main/resources/static/**&amp;lt;/exclude&amp;gt;
        &amp;lt;/excludes&amp;gt; --&amp;gt;
        &amp;lt;filtering&amp;gt;false&amp;lt;/filtering&amp;gt;
    &amp;lt;/resource&amp;gt;
&amp;lt;/resources&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;相关资料&quot;&gt;相关资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/1.5.14.RELEASE/reference/htmlsingle&quot; class=&quot;uri&quot; title=&quot;https://docs.spring.io/spring-boot/docs/1.5.14.RELEASE/reference/htmlsingle&quot;&gt;https://docs.spring.io/spring-boot/docs/1.5.14.RELEASE/reference/htmlsingle&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_34665539/article/details/74783910&quot; class=&quot;uri&quot; title=&quot;https://blog.csdn.net/qq_34665539/article/details/74783910&quot;&gt;https://blog.csdn.net/qq_34665539/article/details/74783910&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;本章节主要是讲解了利用模版引擎进行动态页面实现功能。对于有此需要的同学可以去看下使用的模版引擎的相关使用教程，这里就不多加阐述了，毕竟目前工作现在用这个的机会比较少了，也只是知道个大概使用，具体一些深入的使用还是看具体的官方文档吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;目前互联网上很多大佬都有&lt;code&gt;SpringBoot&lt;/code&gt;系列教程，如有雷同，请多多包涵了。本文是作者在电脑前一字一句敲的，每一步都是实践的。若文中有所错误之处，还望提出，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;老生常谈&quot;&gt;老生常谈&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;个人QQ：&lt;code&gt;499452441&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;微信公众号：&lt;code&gt;lqdevOps&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/13169342-66ff478ac30e6628.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
&lt;p&gt;个人博客：&lt;a href=&quot;http://blog.lqdev.cn/&quot; class=&quot;uri&quot; title=&quot;http://blog.lqdev.cn&quot;&gt;http://blog.lqdev.cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;完整示例：&lt;a href=&quot;https://github.com/xie19900123/spring-boot-learning/tree/master/chapter-16&quot; class=&quot;uri&quot;&gt;https://github.com/xie19900123/spring-boot-learning/tree/master/chapter-16&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://blog.lqdev.cn/2018/08/07/springboot/chapter-sixteen/&quot;&gt;http://blog.lqdev.cn/2018/08/07/springboot/chapter-sixteen/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Aug 2018 23:49:00 +0000</pubDate>
<dc:creator>oKong_趔趄的猿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/okong/p/springboot-sixteen.html</dc:identifier>
</item>
<item>
<title>CUBA与Spring相比，有很大的不同吗？ - CUBA-China</title>
<link>http://www.cnblogs.com/cubacn/p/CUBAvsSpring.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cubacn/p/CUBAvsSpring.html</guid>
<description>&lt;p&gt;原文：&lt;a href=&quot;https://www.cuba-platform.com/blog/developing-with-cuba-a-big-shift-from-spring&quot;&gt;Developing with CUBA - a big shift from Spring?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;翻译：&lt;/span&gt;CUBA China                                                         &lt;/p&gt;
&lt;p&gt;CUBA-Platform 官网 : &lt;a href=&quot;https://www.cuba-platform.com/&quot;&gt;https://www.cuba-platform.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CUBA China 官网 : &lt;a href=&quot;http://cuba-platform.cn/&quot;&gt;http://cuba-platform.cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎转载，转载请注明来源。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　企业级软件开发人员通常会面对如下需求组合（至少我经常遇到的是）：设计优良的数据存储结构（有时候是已有的旧数据库模型），大量的数据录入表单，非常复杂的业务逻辑、报表功能、与许多公司其他系统（财会、&lt;/span&gt;CRM等）集成，数千并发量。对此，你首先考虑的是什么？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　“首先，采用主流的关系数据数据库管理（RDBMS）、Hibernate / JPA + Spring Boot、REST API，并且使用我最喜欢的或者最新的JS框架来实现UI。”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　“嗯~，还需配置Spring Security ，也许还需要写一部分代码来实现行级别的数据保护功能。如何实现呢？也许会用到数据库视图或虚拟专用数据库。“&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　“所有这些DAO代码都非常相似且枯燥，但我还是需要一一实现。”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　“可以使用类似&lt;/em&gt;&lt;a href=&quot;http://modelmapper.org/&quot;&gt;&lt;em&gt;ModelMapper&lt;/em&gt;&lt;/a&gt;&lt;em&gt;&lt;span&gt;的东西将&lt;/span&gt;JPA实体转换为REST的DTO。”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　“别忘了跟实习生强调下懒加载和JPA关联查询。”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　“唉，其实都是雷同登录界面、千篇一律的实体到DTO的转换，有没有办法能让我摆脱所有这些乏味的东西 ，只需要专注于关键的业务逻辑实现呢？”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       本文适合使用&lt;/span&gt;Spring框架（包括Spring Boot）从头开始做过几个项目、并且正在考虑怎么提高自己工作效率的开发人员。在文章中，我将向您展示如何使用CUBA平台摆脱常见的耗时枯燥任务。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;又一个&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;新&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;框架？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438872/201808/1438872-20180803122425922-449810601.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　开发人员在听到新框架时提出的第一个问题往往是：&lt;/span&gt;“为什么我需要这个？Spring Boot就能很好地帮助我从头开始实现所有内容”。 没错，新平台意味着新的规则、新的限制，之前积累的其他框架的经验便失去了意义。就算是目前使用的框架不完美，但是对它足够了解，知道有哪些坑，和哪些变通的方法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但是，从&lt;/span&gt;Spring切换到CUBA，并不需要重头学习规则，甚至没有什么变化，只要稍微前进一步就可以摆脱枯燥的开发任务，摆脱数百行DTO架子代码和转换工具的困扰，摆脱实现数据分页或数据过滤组件、创建Spring Security配置文件（JPA，Cache，...）等等些基础功能的麻烦。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本文中，我们将从头开始展示&lt;/span&gt;CUBA如何遵循几乎所有基于Spring的开发模式，开发人员在Spring中积累的经验能被充分利用，同样的研发投入却能交付更多。为了使情景更清晰简洁，本文侧重于后端代码。&lt;/p&gt;


&lt;p&gt;　　Spring应用程序的典型架构可以很容易搜索到，很多情况下，它可以表示为具有一些交叉区域的典型三层应用程序。让我们来看看“经典”的Spring应用程序：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1438872/201808/1438872-20180803122505223-263385534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　领域模型（&lt;/span&gt;Domain Model）&lt;/strong&gt; - 通常需要手动创建。但是，有一些工具可基于数据存储结构创建领域模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　数据存储层（&lt;/span&gt;Repository Layer）&lt;/strong&gt; - 与数据存储一起使用的类。也称为“DAO”，“存储库（Repositories）”等。这块是ORM框架（及其兄弟姐妹们）的领地。它通常包含功能域模型中的一个实体执行CRUD操作的类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　服务层（&lt;/span&gt;Service Layer）&lt;/strong&gt; - 有时开发人员会创建一个额外的层来分离业务逻辑和数据CRUD操作。如果项目业务逻辑复杂，涉及不同类型的数据源，或者涉及外部服务集成，这一层会很有用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Web /控制器层（REST / MVC）&lt;/strong&gt; - 用来处理REST API（将由基于浏览器的应用程序使用）或使用JSP实现的视图，或是模板框架（thymeleaf, velocity）、JVM前端框架（GWT， Vaadin，Wicket等）。由于API结构&lt;span&gt;或前端界面展示不同，通常控制器是操作&lt;/span&gt;DTO而不是实体对象。因此，开发人员通常必须在实体模型和DTO模型之间实现双向转换。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1438872/201808/1438872-20180803122543675-1637494067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　如果您对以上描述很熟悉（甚至觉得是&lt;/em&gt;&lt;em&gt;显而易见&lt;/em&gt;&lt;em&gt;&lt;span&gt;）&lt;/span&gt; - 那么恭喜，您可以毫无障碍地开始使用CUBA。&lt;/em&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　话不多说，接下来看&lt;/span&gt;code怎么写。在GitHub上，有一个众所周知的Spring的“参考”应用程序 - &lt;a href=&quot;https://github.com/spring-projects/spring-petclinic&quot;&gt;&lt;span&gt;Pet Clinic&lt;/span&gt;&lt;span&gt;（宠物诊所）&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。下面我们将展示如何使用你的&lt;/span&gt;Spring技能加上CUBA框架开发一个新的宠物诊所程序。Antoine Rey的&lt;a href=&quot;http://fr.slideshare.net/AntoineRey/spring-framework-petclinic-sample-application&quot;&gt;参考程序&lt;/a&gt;&lt;span&gt;有非常好的、详细的说明&lt;/span&gt;; 我们将在本文中重复一些内容。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1438872/201808/1438872-20180803122605481-2100312301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据模型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　图中显示了数据库的&lt;/span&gt;ER图。应用程序代码中实际的对象域模型有点复杂并且包含一些继承，您可以在上面提到的&lt;a href=&quot;https://image.slidesharecdn.com/2017-01-springframeworkpetclinic-170209204315/95/spring-framework-petclinic-sample-application-5-638.jpg?cb=1486673606&quot;&gt;演示文稿&lt;/a&gt;&lt;span&gt;中找到&lt;/span&gt;UML模型。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;存储层&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　有四个&lt;/span&gt;Repository来处理主要实体：Owner（主人），Pet（宠物），Visit（拜访）和Vet（兽医）。这些Repository基于Spring JPA框架，由于Spring JPA的特性，这些Repository几乎不包含什么代码，但在Owner Repository里面有一个自定义的查询，用来获取宠物主人和他们各自的宠物。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;UI&lt;span&gt;界面&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　该应用程序包含九个界面，我们可以通过这些界面查看数据，并进行一些编辑：宠物主人，宠物和拜访。本文不讨论它们，但需要指出的是，这些界面都是面向数据的应用程序里常见的&lt;/span&gt;CRUD表单。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;附加功能&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　除了简单的&lt;/span&gt;CRUD功能外，该应用程序还包括一些能展示Spring Framework之强大的功能：&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;缓存（&lt;/span&gt;Caching） - 兽医列表已缓存，因此在刷新兽医列表时不会有DB读取。&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;验证器（&lt;/span&gt;Validator） - 检查在创建有关宠物的新记录时是否填写了所有字段。&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;格式化程序（&lt;/span&gt;Formatter） - 用于正确显示宠物类型。&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;多语言支持（&lt;/span&gt;i18n） - 该应用程序提供英语和德语版本。&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;事务管理&lt;/span&gt; - 某些数据库查询是只读的。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;感想&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438872/201808/1438872-20180803122716222-1033379979.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我非常喜欢这张图片，因为它精准表达了我的看法：要有效地使用任何框架，都需要了解它内部的工作原理。例如，&lt;/span&gt;Spring Boot隐藏了很多东西，如果你知道一个简单的JPA接口初始化背后有多少个类，你会吓一跳。以下是关于Spring Boot Pet Clinic应用程序中“神奇”的部分：&lt;/p&gt;
&lt;p&gt;　　l @Caсheable - 除了这个注解之外没有任何缓存配置代码，但Spring Boot“知道”如何设置缓存实现（在我们的例子中将是EhCache）。&lt;/p&gt;
&lt;p&gt;　　l @Transactional -  Repository没有这个注解（它们的父类&lt;a href=&quot;http://org.springframework.data.repository.Repository&quot;&gt;org.springframework.data.repository.Repository&lt;/a&gt;&lt;span&gt;也没有），但所有&lt;/span&gt;save()方法都可以正常工作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　虽然存在这么多隐晦的地方，但是由于&lt;/span&gt;Spring Boot的透明性和可预测性，Spring Boot还是一个非常流行的框架。Spring Boot还有非常详细的文档，而且是开源的，所以你可以深入研究它的原理和任何方法的实现，研究里面的逻辑。我想每个人都喜欢透明且易于管理的框架，因为它们可以使您的应用程序更加易于维护。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　现在，让我们看看使用&lt;/span&gt;CUBA平台的Pet Clinic，根据我们的Spring知识来审视它，并找出我们都能在哪些地方节约开发时间。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;/span&gt;GitHub上可以找到Pet Clinic实现的&lt;a href=&quot;https://github.com/belyaev-andrey/cuba-petclinic&quot;&gt;源代码&lt;/a&gt;&lt;span&gt;。&lt;/span&gt;CUBA平台有非常好的&lt;a href=&quot;https://doc.cuba-platform.com/manual-latest/manual.html&quot;&gt;&lt;span&gt;&lt;span&gt;文档&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，其中可以找到几乎有关&lt;/span&gt;CUBA的所有东西（&lt;a href=&quot;https://github.com/cuba-platform&quot;&gt;&lt;span&gt;&lt;span&gt;大多数情况都有代码&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;片&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;段或者代码实例&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;，都能在&lt;a href=&quot;https://github.com/cuba-platform&quot;&gt;GitHub&lt;/a&gt;&lt;span&gt;上找到）。在本文中，我们将更多的引用&lt;/span&gt;CUBA文档，以避免重复描述。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;CUBA&lt;span&gt;应用程序架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　 &lt;img src=&quot;https://images2018.cnblogs.com/blog/1438872/201808/1438872-20180803122853745-1741397461.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　CUBA应用程序包含以下&lt;a href=&quot;http://www.cnblogs.com/cubacn/p/CUBAvsSpring.html#app_modules&quot;&gt;&lt;span&gt;&lt;span&gt;模块&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;（请参见图表）。&lt;/p&gt;
&lt;p&gt;　　l Global - 包含可以在其他模块中使用的数据库实体、CUBA视图和服务接口。&lt;/p&gt;
&lt;p&gt;　　l Core - 所有与数据库一起工作并实现业务逻辑的服务实现都应该放在这里。需要注意的是，Core模块里面的类在其他模块中并不可用，这样设计的目的是，可以独立&lt;a href=&quot;https://doc.cuba-platform.com/manual-latest/manual.html#deployment_variants&quot;&gt;&lt;span&gt;&lt;span&gt;部署&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;Core和GUI模块到不同的服务器，给系统提供了很好的可扩展性。而想要将Core模块的服务注入其他模块，您应该使用Global模块中声明的接口。&lt;/p&gt;
&lt;p&gt;　　l GUI，Web，Desktop，Portal - 这些模块包含负责UI事件处理的GUI相关类（控制器，监听器等）。您可以在此处创建自定义REST控制器，以补全CUBA为您生成开箱即用的&lt;a href=&quot;http://files.cuba-platform.com/swagger/6.9/&quot;&gt;&lt;span&gt;REST API&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为了提高开发人员效率，&lt;/span&gt;CUBA提供了&lt;a href=&quot;https://www.cuba-platform.com/development-tools&quot;&gt;&lt;span&gt;Studio&lt;/span&gt;&lt;/a&gt; - 一个漂亮小巧的图形化工具，用于创建和注册实体，并且可以为您更新所有配置，帮助创建服务的架子代码，并具有功能界面的可视化编辑器。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因此，基于&lt;/span&gt;CUBA平台的应用程序包含两个（或更多）单独的模块：可以单独部署的Core和GUI，以及一个跨功能域的&lt;strong&gt;Global&lt;/strong&gt;&lt;span&gt;模块。下面我们详细介绍一下&lt;/span&gt;CUBA的&lt;strong&gt;Global&lt;/strong&gt;和&lt;strong&gt;Core&lt;/strong&gt;模块及其内容。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Global&lt;span&gt;模块&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;实体模型（&lt;/span&gt;Entity Model）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　任何使用过与&lt;/span&gt;JPA标准兼容的ORM框架或者Spring的开发人员都应该熟悉CUBA应用程序中的实体模型。同样是用@Table，@Entity等注释的类，并在persistence.xml文件中注册。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;/span&gt;Pet Clinic应用程序的实体模型中，您可以重用Spring版本中的代码，但您需要记住以下几点：&lt;/p&gt;
&lt;p&gt;　　1. CUBA 为使用此平台创建的每个&lt;a href=&quot;https://doc.cuba-platform.com/manual-latest/app_components.html&quot;&gt;&lt;span&gt;&lt;span&gt;组件&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;（&lt;/span&gt;Component）引入了一个“命名空间”，以防止不同组件之间的名称冲突。这就是为什么每个实体名称都有一个“petclinic$”前缀。&lt;/p&gt;
&lt;p&gt;　　2. 建议对实体使用@NamePattern注释，这样在界面可以得到实体更有意义命名。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　问题是，除了前缀和声明实体的&lt;/span&gt;“字符串式”表示之外，CUBA还提供了什么其他功能？其他功能包括：&lt;/p&gt;
&lt;p&gt;　　1. 支持ID生成功能的基类：从整数ID到UUID&lt;/p&gt;
&lt;p&gt;　　2. 一组有用（但可选）的接口：&lt;/p&gt;
&lt;p&gt;　　　　l Versioned - 支持实体版本。&lt;/p&gt;
&lt;p&gt;　　　　l SoftDelete - 支持实体的“软”删除，或者说是“逻辑”删除。&lt;/p&gt;
&lt;p&gt;　　　　l Updatable - 添加实体更新日志记录的字段。&lt;/p&gt;
&lt;p&gt;　　　　l Creatable - 添加实体创建日志记录的字段。&lt;/p&gt;
&lt;p&gt;　　　　您可以在&lt;a href=&quot;https://doc.cuba-platform.com/manual-latest/data_model.html&quot;&gt;&lt;span&gt;&lt;span&gt;文档&lt;/span&gt;&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;/a&gt;阅读有关这些接口的更多信息。&lt;/p&gt;
&lt;p&gt;　　3. CUBA Studio可以自动生成数据库创建和更新脚本。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　在应用程序开发期间，我只是从&lt;/span&gt;Spring版本复制了现有实体模型，并添加了上面提到的CUBA特定功能，从程序的参考版本中删除了BaseEntity类。&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;视图（&lt;/span&gt;Views）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　CUBA的“视图”概念可能令人困惑，但很容易解释。视图是一种声明性方法，用于指定应提取哪些数据（属性和嵌套实例/集合）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　让我们假设您需要获取&lt;/span&gt;Owner及其宠物或兽医的属性 - 用于在同一个界面上显示依赖的子实体和父实体。在纯Spring实现的情况下，您需要定义JPA关联查询：&lt;/p&gt;
&lt;p&gt;　　@Query(&quot;&lt;strong&gt;SELECT&lt;/strong&gt; owner &lt;strong&gt;FROM&lt;/strong&gt; Owner owner &lt;strong&gt;left&lt;/strong&gt; &lt;strong&gt;join&lt;/strong&gt; &lt;strong&gt;fetch&lt;/strong&gt; owner.pets &lt;strong&gt;WHERE&lt;/strong&gt; owner.id =:id&lt;strong&gt;&quot;) public Owner findById(@Param(&quot;&lt;/strong&gt;id&lt;strong&gt;&quot;) int id);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　...或定义正确的EAGER / LAZY FETCH类型以获取事务上下文中的实体的依赖集合。&lt;/p&gt;
&lt;p&gt;　　@&lt;strong&gt;ManyToMany(fetch&lt;/strong&gt; = FetchType.EAGER) @&lt;strong&gt;JoinTable&lt;/strong&gt;(name = &lt;strong&gt;&quot;vet_specialties&quot;&lt;/strong&gt;, joinColumns = @&lt;strong&gt;JoinColumn&lt;/strong&gt;(name = &lt;strong&gt;&quot;vet_id&quot;&lt;/strong&gt;), inverseJoinColumns = @&lt;strong&gt;JoinColumn&lt;/strong&gt;(name = &lt;strong&gt;&quot;specialty_id&quot;&lt;/strong&gt;)) private Set specialties;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;/span&gt;CUBA版本中，您可以使用EntityManager和JPQL或视图和DataManager：&lt;/p&gt;
&lt;p&gt;　　1. 定义一个指定我们想要提取的内容的视图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438872/201808/1438872-20180803123131785-1796543169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. 使用&lt;a href=&quot;https://doc.cuba-platform.com/manual-6.8/dataManager.html&quot;&gt;&lt;span&gt;DataManager&lt;/span&gt;&lt;/a&gt; bean获取此数据&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438872/201808/1438872-20180803123148839-419635969.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　您可以为不同的任务创建不同的视图，选择要获取的属性，是否获取集合以及定义对象树的深度。在&lt;/span&gt;Mario David的&lt;a href=&quot;https://www.road-to-cuba-and-beyond.com/&quot;&gt;&lt;span&gt;&lt;span&gt;博客&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;中有一篇关于视图的精彩&lt;a href=&quot;https://www.road-to-cuba-and-beyond.com/views-the-uncharted-mystery/&quot;&gt;&lt;span&gt;&lt;span&gt;文章&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在宠物诊所程序中，我们为不同的场景定义了六个视图。这些视图主要用于&lt;/span&gt;UI表单，其中之一是在服务中用来获取数据，上面显示了这个代码片段。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;服务接口&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　由于&lt;/span&gt;Global模块在CUBA的应用程序架构中属于交叉支撑的模块，因此您应该把服务的接口定义在Global模块中，以便能够通过使用Spring的注入在其他模块中使用服务。您需要做的就是在Web模块的“&lt;a href=&quot;http://web-spring.xml&quot;&gt;&lt;span&gt;web-spring.xml&lt;/span&gt;&lt;/a&gt;”文件中注册服务。CUBA平台在应用程序模块中创建代理，采用Spring配置XML文件的方法进行完全透明的实体序列化和反序列化。此功能使我们可以从其他模块调用Core模块中实现的服务，即使在分布式部署的情况下也只需要很少的额外工作。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　因此，在使用&lt;/span&gt;CUBA进行实体模型开发方面，它与纯Spring完全相同，但是在插入数据后你不需要关心实体和关联实体的ID是怎么生成的，也不需要写额外的代码去实现实体版本化，软删除和实体变更日志。相比较于JPA关联查询，您还可以利用创建CUBA视图来节省一些时间。&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Core&lt;span&gt;模块&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;/span&gt;Global模块中声明的服务接口都在Core模块实现。一般来说，CUBA应用程序中的每个服务都使用@Service注解，但您可以使用所有Spring里面可用的注解来处理bean。不过，由于CUBA的特殊架构，存在一些限制：&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;如果希望在&lt;/span&gt;Web模块中使用服务，则需要使用@Service做服务注解。&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;建议为服务创建服务名，以避免不同加载项中的&lt;/span&gt;Bean命名冲突。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　除此之外，您的&lt;/span&gt;Core模块代码库是一个“纯粹的”基于Spring的后端应用程序。您可以使用与以前相同的方式从数据存储中获取数据，调用第三方Web service等。唯一重要的区别是与数据库的交互：&lt;/p&gt;
&lt;p&gt;　　EntityManager和DataManager&lt;/p&gt;
&lt;p&gt;　　CUBA平台使用自己的&lt;a href=&quot;https://doc.cuba-platform.com/manual-latest/entityManager.html&quot;&gt;EntityManager&lt;/a&gt;，将其部分功能委托给实际的&lt;a href=&quot;http://javax.persistence.EntityManager&quot;&gt;javax.persistence.EntityManager&lt;/a&gt;&lt;span&gt;实例。&lt;/span&gt;CUBA的EntityManager主要提供低级别实体操作，不支持安全功能。所以在大多数情况下，还是推荐使用提供额外功能的&lt;a href=&quot;https://doc.cuba-platform.com/manual-latest/dataManager.html&quot;&gt;DataManager&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;　　1. 行级和属性级安全性支持。&lt;/p&gt;
&lt;p&gt;　　2. 可以采用CUBA的实体视图获取数据。&lt;/p&gt;
&lt;p&gt;　　3. &lt;span&gt;&lt;span&gt;支持&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://doc.cuba-platform.com/manual-latest/dynamic_attributes.html&quot;&gt;&lt;span&gt;&lt;span&gt;动态属性&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　有关&lt;/span&gt;DataManager和EntityManager的更多信息，请参阅&lt;a href=&quot;https://doc.cuba-platform.com/manual-latest/dm_vs_em.html&quot;&gt;&lt;span&gt;&lt;span&gt;文档&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。值得注意的是，您不需要在&lt;/span&gt;GUI中直接使用这些bean，而可以使用&lt;a href=&quot;https://doc.cuba-platform.com/manual-latest/datasources.html&quot;&gt;&lt;span&gt;&lt;span&gt;数据源&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　顺便谈谈&lt;/span&gt;PetClinic - 我（几乎）没有在Core模块中编写很多代码，因为没有特别复杂的业务逻辑。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　在上一节中，基于&lt;/span&gt;Spring的Pet Clinic应用程序中我们总结了一个额外功能列表，CUBA中也提供了相同的功能：&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;缓存（&lt;/span&gt;Caching&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　CUBA原生支持实体和查询缓存。这些缓存在&lt;a href=&quot;https://doc.cuba-platform.com/manual-6.8/entity_cache.html&quot;&gt;&lt;span&gt;&lt;span&gt;文档&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;中有详细描述，在使用时应首先考虑，因为它们支持分布式部署等所有平台功能。除此之外，您还可以使用&lt;/span&gt;Spring的@Cacheable启用缓存，并启用Spring &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-caching&quot;&gt;&lt;span&gt;&lt;span&gt;文档&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;中所述的&lt;/span&gt;cach provider。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;验证器（&lt;/span&gt;Validator&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　CUBA使用&lt;a href=&quot;https://doc.cuba-platform.com/manual-latest/bean_validation_running.html&quot;&gt;&lt;span&gt;BeanValidation&lt;/span&gt;&lt;/a&gt;作为标准验证引擎。如果内置验证不够，您可以定义&lt;a href=&quot;https://doc.cuba-platform.com/manual-latest/bean_validation_constraints.html#bean_validation_custom_constraints&quot;&gt;&lt;span&gt;&lt;span&gt;自定义验证代码&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。而且还可以通过描述定义&lt;/span&gt;Validator类来提供验证UI数据的选项&lt;a href=&quot;https://doc.cuba-platform.com/manual-latest/gui_validator.html&quot;&gt;&lt;span&gt;&lt;span&gt;在这里&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;格式化（&lt;/span&gt;Formatter&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　CUBA平台为GUI组件提供了几种&lt;a href=&quot;https://doc.cuba-platform.com/manual-latest/gui_formatter.html&quot;&gt;&lt;span&gt;&lt;span&gt;格式化&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;程序，但除标准格式化&lt;a href=&quot;https://doc.cuba-platform.com/manual-6.8/gui_formatter.html&quot;&gt;&lt;span&gt;&lt;span&gt;程序&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;外，您还可以&lt;a href=&quot;https://doc.cuba-platform.com/manual-6.8/gui_formatter.html&quot;&gt;&lt;span&gt;&lt;span&gt;定义自己的格式化&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;程序。对于默认实体命名的格式化，使用&lt;/span&gt;@NamePattern注释。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;国际化（&lt;/span&gt;I18n&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　CUBA平台支持&lt;a href=&quot;https://doc.cuba-platform.com/manual-6.8/localization.html&quot;&gt;&lt;span&gt;&lt;span&gt;国际化&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;的方式与其他&lt;/span&gt;java应用程序相同：使用&lt;a href=&quot;http://message.properties&quot;&gt;&lt;span&gt;message.properties&lt;/span&gt;&lt;/a&gt;文件，所以这里没什么新东西。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;事务管理&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　CUBA平台提供以下事务管理选项：&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;熟悉的&lt;/span&gt;Spring @Transactional注释&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;如果在某些复杂情况下需要细粒度的事务管理，那么可以采用&lt;/span&gt;CUBA的&lt;a href=&quot;https://doc.cuba-platform.com/manual-6.8/persistence.html&quot;&gt;&lt;span&gt;&lt;span&gt;持久层&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;接口。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　当我开发宠物诊所时，我只考虑过一次事&lt;/em&gt;&lt;em&gt;务&lt;/em&gt;&lt;em&gt;&lt;span&gt;：那就是在开发允许编辑&lt;/span&gt;Owner、Pet以及在同一屏幕上添加Visit的表单的时候。此时我需要了解何时提交事务并刷新界面然后统一的显示数据。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　我能够在不到一天的时间内使用&lt;/span&gt;“标准”CUBA UI创建一个与Spring的Pet Clinic具有相同功能的应用程序。我不会说我是CUBA的专家（自我开始以来仅仅几周），但我有很长的时间在使用Spring。脑海中回想一下Spring程序的架构，然后我们看一下基于CUBA的架构：&lt;/p&gt;
&lt;p&gt;　　l &lt;strong&gt;&lt;span&gt;领域模型&lt;/span&gt;&lt;/strong&gt; - &lt;strong&gt;Global&lt;/strong&gt;&lt;span&gt;模块中的实体。创建实体模型是每个程序中都需要的过程。由于使用&lt;/span&gt;BaseIntegerIdEntity类，在ID生成方面可以节省时间。&lt;/p&gt;
&lt;p&gt;　　l &lt;strong&gt;&lt;span&gt;数据存储层&lt;/span&gt;&lt;/strong&gt; - 我不需要Repository，甚至连一个接口也不需要。我只是使用CUBA Studio 创建了一些视图。通过使用这个工具，我也不需要在配置文件中编写XML。&lt;/p&gt;
&lt;p&gt;　　l &lt;strong&gt;服务层&lt;/strong&gt; - 在我们的应用程序中，我们只有两个服务用来导出JSON和XML格式的Vets，这些Vets是可缓存的。我根据文档将接口放到Global模块，将接口实现放到Core模块。除了阅读有关DataManager以熟悉其API之外，这基本只是一个“正常”的开发过程。&lt;/p&gt;
&lt;p&gt;　　l &lt;strong&gt;&lt;span&gt;控制器层&lt;/span&gt;&lt;/strong&gt; - CUBA Pet Clinic在Web模块中仅包含一个用于JSON和XML feed的自定义的REST控制器。这里没有特别要说的，只是一个采用了Spring注解的控制器。&lt;/p&gt;
&lt;p&gt;　　l &lt;strong&gt;&lt;span&gt;应用程序&lt;/span&gt;GUI&lt;/strong&gt; - 使用CUBA Studio创建“标准”CRUD表单非常简单。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　  在实现的过程中，我完全没有考虑如何将实体传递给&lt;/span&gt;Web UI，也没有考虑表单提交，也没有相关的控制器和Repository。CUBA为我提供了界面上一个比较好用的表格组件以及一个数据过滤组件，因此我不再需要解析查询语句，也不需要特意做分页。我花了大部分时间来实现界面的流程流转，以及调整页面样式。&lt;/p&gt;
&lt;p&gt;　　我的个人体验如下表所示：&lt;/p&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;bottom&quot; width=&quot;113&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;bottom&quot; width=&quot;266&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;CUBA中易于理解的部分&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;bottom&quot; width=&quot;266&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;CUBA中需要阅读文档的部分&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;113&quot;&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;实体&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;bottom&quot; width=&quot;266&quot;&gt;
&lt;p&gt;实体建模&lt;/p&gt;
&lt;p&gt;数据库创建脚本&lt;/p&gt;
&lt;p&gt;标准基类&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;bottom&quot; width=&quot;266&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;软删除等的附加功能&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;113&quot;&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;库&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;bottom&quot; width=&quot;266&quot;&gt;
&lt;p&gt;EntityManager&lt;/p&gt;
&lt;p&gt;视图&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;bottom&quot; width=&quot;266&quot;&gt;
&lt;p&gt;&lt;span&gt;DataManager&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;113&quot;&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;服务&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;bottom&quot; width=&quot;266&quot;&gt;
&lt;p&gt;Bean管理&lt;/p&gt;
&lt;p&gt;事务管理&lt;/p&gt;
&lt;p&gt;安全性和用户管理&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;bottom&quot; width=&quot;266&quot;&gt;
&lt;p&gt;&lt;span&gt;持久层接口&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;113&quot;&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;控制器&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;bottom&quot; width=&quot;266&quot;&gt;
&lt;p&gt;自定义REST控制器&lt;/p&gt;
&lt;p&gt;请求URL映射&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;bottom&quot; width=&quot;266&quot;&gt;
&lt;p&gt;&lt;span&gt;服务方法发布&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;113&quot;&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;UI&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;266&quot;&gt;
&lt;p&gt;标准表格&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;bottom&quot; width=&quot;266&quot;&gt;
&lt;p&gt;&lt;span&gt;自定义&lt;span&gt;UI&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;　　显然&lt;/span&gt;Pet Clinic程序没有使用所有CUBA提供的特性，可以在&lt;a href=&quot;https://www.cuba-platform.com/framework-features&quot;&gt;&lt;span&gt;&lt;span&gt;站点&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;上找到&lt;/span&gt;CUBA特性的完整列表，这里可以看到该平台可以怎样解决其他的一些常见任务。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　我的个人观点&lt;/span&gt; - 如果您使用企业软件的标准界面，CUBA可以简化后端实施并做得很好。如果你需要一个精美的界面，那么CUBA也会帮你节省在后端开发上的时间。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　好吧，我想在本节中提到一些问题，这些问题的存在不影响使用&lt;/span&gt;CUBA，但是我发现这些问题会给第一次接触CUBA的人带来不好印象：&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;在介绍部分，&lt;/span&gt;CUBA平台说自己带有IDE，能简化项目的创建和管理。但有时在Studio和IDE之间切换可能会有点烦人。CUBA平台现在正在重新开发它，因此Studio很快就会转变为IDEA的插件。&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;在&lt;/span&gt;CUBA中，我们使用了比典型的Spring Boot应用程序更多的XML配置文件，因为平台提供的服务更多，各个模块之间需要一些XML来作为连接。&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;应用程序的单个页面都没有&lt;/span&gt;“友好”的URL。您可以使用&lt;a href=&quot;https://doc.cuba-platform.com/manual-latest/link_to_screen.html&quot;&gt;&lt;span&gt;&lt;span&gt;屏幕链接&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;直接访问屏幕，但这也非常不直观。&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;您必须处理&lt;/span&gt;CUBA的DataManager和EntityManager并学习它们的API而不是Spring JPA或JDBC（但如果需要，仍然可以使用它们）。&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;使用关系数据库时，使用&lt;/span&gt;CUBA将达到开发的最佳效率。而如果要使用NoSQL，CUBA的表现和Spring一样，都有很多需要自己写代码的地方。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　如果您有一个需要以关系型数据库作为数据储存，并且以数据为中心的应用程序的需求，您可能需要尝试使用&lt;/span&gt;CUBA平台作为基础来开发，因为：&lt;/p&gt;
&lt;p&gt;　　1. CUBA是透明的。源代码可用，您可以调试所有内容。&lt;/p&gt;
&lt;p&gt;　　2. CUBA很灵活（但是也有一定限度）。您可以继承并注入自己的bean而不采用标准CUBA bean，也可以发布自定义REST API并使用您自己的前端框架实现与用户交互。&lt;/p&gt;
&lt;p&gt;　　3. CUBA就是Spring。80％的后端代码都是纯Spring应用程序。&lt;/p&gt;
&lt;p&gt;　　4. 使用CUBA可以加快项目启动。在第一个实体和UI屏幕创建之后，应用程序就可以使用了。&lt;/p&gt;
&lt;p&gt;　　5. CUBA为您完成了很多日常枯燥的工作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因此，通过使用&lt;/span&gt;CUBA，您将在枯燥的工作上节省不少时间，以便真正投入地处理复杂的业务相关逻辑，也可以实现与其他系统的无缝集成。&lt;/p&gt;

&lt;p&gt;CUBA-Platform 官网 :&lt;/p&gt;
&lt;p&gt;  　  &lt;a href=&quot;https://www.cuba-platform.com/&quot;&gt;&lt;span&gt;https://www.cuba-platform.com&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CUBA China 官网 :&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;http://cuba-platform.cn/&quot;&gt;&lt;span&gt;http://cuba-platform.cn&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438872/201808/1438872-20180803123436865-2054469240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Aug 2018 22:41:00 +0000</pubDate>
<dc:creator>CUBA-China</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cubacn/p/CUBAvsSpring.html</dc:identifier>
</item>
<item>
<title>[源码分析]StringBuilder - GoldArowana</title>
<link>http://www.cnblogs.com/noKing/p/jdk8_StringBuilder.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noKing/p/jdk8_StringBuilder.html</guid>
<description>&lt;h2&gt;[源码分析]StringBuilder&lt;/h2&gt;
&lt;p&gt;StringBuilder是继承自AbstractStringBuilder的.&lt;/p&gt;
&lt;p&gt;这里附上另外两篇文章的连接:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/noKing/p/9427967.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;AbstractStringBuilder : http://www.cnblogs.com/noKing/p/9427967.html &lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/noKing/p/9431618.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;StringBuffer : http://www.cnblogs.com/noKing/p/9431618.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180806094500159-1222751915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;构造器&lt;/h3&gt;
&lt;p&gt;我每篇文章都说. 请忽略我的&quot;My&quot;. 我copy了jdk的代码, 然后把StringBuilder改为了MyStringBuilder. 核心源码不会改动的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180806094659562-1651568148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;无参构造器是默认的大小为16.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180806094723412-1917444999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或者可以直接给定大小. 来规定初始化时的数组大小.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180806094752953-1988301147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果是根据传入字符串来构造的, 那么初始大小就是: 传入的字符串长度+16.&lt;/p&gt;
&lt;h3&gt;常用方法&lt;/h3&gt;
&lt;p&gt;可以看到, 下面这些方法, 都是直接调用了父类AbstractStringBuilder类的方法. 只是多加了一行return this. &lt;/p&gt;
&lt;p&gt;append(重载有很多, 挑了一个):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180806094941588-1434099487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;insert(重载有很多, 挑了一个):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180806095009092-1351744252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;reverse:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180806095026402-1835549961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;toString方法&lt;/h3&gt;
&lt;p&gt;AbstractStringBuilder类里的toString方法是抽象方法, 所以具体实现在子类里.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180806095252610-732152045.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;虽然很简单, 但还是总结一下吧.&lt;/p&gt;
&lt;p&gt;1. 构造的大小和16相关. 要么是16, 要么就是加16.(除非使用了定制数组大小的那个构造器, 也就是 本文中截图的第二个构造器. 那么就是指定多大, 初始数组就是多大了.)&lt;/p&gt;
&lt;p&gt;2. 实现了toString方法. 内部实现就是每次toString都是new一个String对象.&lt;/p&gt;
&lt;p&gt;3. 其他方法都是调用的父类的方法. 只是多加了一行return this;&lt;/p&gt;
&lt;p&gt;4. (区别于StringBuffer) , 明显StringBuilder线程不安全.&lt;/p&gt;
</description>
<pubDate>Mon, 06 Aug 2018 17:47:00 +0000</pubDate>
<dc:creator>GoldArowana</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noKing/p/jdk8_StringBuilder.html</dc:identifier>
</item>
<item>
<title>SpringMVC请求参数接收总结 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/9434436.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/9434436.html</guid>
<description>&lt;p&gt;在日常使用SpringMVC进行开发的时候，有可能遇到前端各种类型的请求参数，这里做一次相对全面的总结。SpringMVC中处理控制器参数的接口是HandlerMethodArgumentResolver，此接口有众多子类，分别处理不同(注解类型)的参数，下面只列举几个子类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RequestParamMethodArgumentResolver：解析处理使用了@RequestParam注解的参数、MultipartFile类型参数和Simple类型(如long、int)参数。&lt;/li&gt;
&lt;li&gt;RequestResponseBodyMethodProcessor：解析处理@RequestBody注解的参数。&lt;/li&gt;
&lt;li&gt;PathVariableMapMethodArgumentResolver：解析处理@PathVariable注解的参数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实际上，一般在解析一个控制器的请求参数的时候，用到的是HandlerMethodArgumentResolverComposite，里面装载了所有启用的HandlerMethodArgumentResolver子类。而HandlerMethodArgumentResolver子类在解析参数的时候使用到HttpMessageConverter(实际上也是一个列表，进行遍历匹配解析)子类进行匹配解析，常见的如MappingJackson2HttpMessageConverter。而HandlerMethodArgumentResolver子类到底依赖什么HttpMessageConverter实例实际上是由请求头中的ContentType(在SpringMVC中统一命名为MediaType，见org.springframework.http.MediaType)决定的，因此我们在处理控制器的请求参数之前必须要明确外部请求的ContentType到底是什么。上面的逻辑可以直接看源码&lt;code&gt;AbstractMessageConverterMethodArgumentResolver#readWithMessageConverters&lt;/code&gt;，思路是比较清晰的。在@RequestMapping注解中，produces和consumes就是和请求或者响应的ContentType相关的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;consumes：指定处理请求的提交内容类型(ContentType)，例如application/json, text/html，只有命中了才会接受该请求。&lt;/li&gt;
&lt;li&gt;produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回，如果返回的是JSON数据一般使用application/json;charset=UTF-8。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外提一点，SpringMVC中默认使用Jackson作为JSON的工具包，如果不是完全理解透整套源码的运作，一般不是十分建议修改默认使用的MappingJackson2HttpMessageConverter(例如有些人喜欢使用FastJson，实现HttpMessageConverter引入FastJson做转换器)。&lt;/p&gt;

&lt;p&gt;其实一般的表单或者JSON数据的请求都是相对简单的，一些复杂的处理主要包括URL路径参数、文件上传、数组或者列表类型数据等。另外，关于参数类型中存在日期类型属性(例如java.util.Date、java.sql.Date、java.time.LocalDate、java.time.LocalDateTime)，解析的时候一般需要自定义实现的逻辑实现String-&amp;gt;日期类型的转换。其实道理很简单，日期相关的类型对于每个国家、每个时区甚至每个使用者来说认知都不一定相同。在演示一些例子主要用到下面的模特类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
public class User {

    private String name;
    private Integer age;
    private List&amp;lt;Contact&amp;gt; contacts;
}

@Data
public class Contact {

    private String name;
    private String phone;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;表单参数&quot;&gt;表单参数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;非对象类型单个参数接收：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种是最常用的表单参数提交，ContentType指定为application/x-www-form-urlencoded，也就是会进行URL编码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/spmvc-p-1.png&quot; alt=&quot;spmvc-p-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对应的控制器如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/post&quot;)
public String post(@RequestParam(name = &quot;name&quot;) String name,
                   @RequestParam(name = &quot;age&quot;) Integer age) {
    String content = String.format(&quot;name = %s,age = %d&quot;, name, age);
    log.info(content);
    return content;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说实话，如果有毅力的话，所有的复杂参数的提交最终都可以转化为多个单参数接收，不过这样做会产生十分多冗余的代码，而且可维护性比较低。这种情况下，用到的参数处理器是RequestParamMapMethodArgumentResolver。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象类型参数接收：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们接着写一个接口用于提交用户信息，用到的是上面提到的模特类，主要包括用户姓名、年龄和联系人信息列表，这个时候，我们目标的控制器最终编码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/user&quot;)
public User saveUser(User user) {
    log.info(user.toString());
    return user;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还是指定ContentType为application/x-www-form-urlencoded，接着我们需要构造请求参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/spmvc-p-2.png&quot; alt=&quot;spmvc-p-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为没有使用注解，最终的参数处理器为ServletModelAttributeMethodProcessor，主要是把HttpServletRequest中的表单参数封装到MutablePropertyValues实例中，再通过参数类型实例化(通过构造反射创建User实例)，反射匹配属性进行值的填充。另外，请求复杂参数里面的列表属性请求参数看起来比较奇葩，实际上和在.properties文件中添加最终映射到Map类型的参数的写法是一致的。那么，能不能把整个请求参数塞在一个字段中提交呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/spmvc-p-3.png&quot; alt=&quot;spmvc-p-3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接这样做是不行的，因为实际提交的form表单，key是user，value实际上是一个字符串，缺少一个String-&amp;gt;User类型的转换器，实际上RequestParamMethodArgumentResolver依赖WebConversionService中Converter列表进行参数转换：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/spmvc-p-4.png&quot; alt=&quot;spmvc-p-4&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解决办法还是有的，添加一个org.springframework.core.convert.converter.Converter实现即可：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class StringUserConverter implements Converter&amp;lt;String, User&amp;gt; {

    private static final ObjectMapper MAPPER = new ObjectMapper();

    @Override
    public User convert(String source) {
        try {
            return MAPPER.readValue(source, User.class);
        } catch (IOException e) {
            throw new IllegalArgumentException(e);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这种做法属于曲线救国的做法，不推荐使用在生产环境，但是如果有些第三方接口的对接无法避免这种参数，可以选择这种实现方式。&lt;/p&gt;
&lt;h2 id=&quot;json参数&quot;&gt;JSON参数&lt;/h2&gt;
&lt;p&gt;一般来说，直接POST一个JSON字符串这种方式对于SpringMVC来说是比较友好的，只需要把ContentType设置为application/json，提交一个原始的JSON字符串即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/spmvc-p-5.png&quot; alt=&quot;spmvc-p-5&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后端控制器的代码也比较简单：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/user-2&quot;)
public User saveUser2(@RequestBody User user) {
    log.info(user.toString());
    return user;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为使用了@RequestBody注解，最终使用到的参数处理器为RequestResponseBodyMethodProcessor，实际上会用到MappingJackson2HttpMessageConverter进行参数类型的转换，底层依赖到Jackson相关的包。&lt;/p&gt;
&lt;h2 id=&quot;url参数&quot;&gt;URL参数&lt;/h2&gt;
&lt;p&gt;URL参数，或者叫请求路径参数是基于URL模板获取到的参数，例如/user/{userId}是一个URL模板(URL模板中的参数占位符是{})，实际请求的URL为/user/1，那么通过匹配实际请求的URL和URL模板就能提取到userId为1。在SpringMVC中，URL模板中的路径参数叫做PathVariable，对应注解@PathVariable，对应的参数处理器为PathVariableMethodArgumentResolver。&lt;strong&gt;注意一点是，@PathVariable的解析是按照value(name)属性进行匹配，和URL参数的顺序是无关的&lt;/strong&gt;。举个简单的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/spmvc-p-6.png&quot; alt=&quot;spmvc-p-6&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后台的控制器如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/user/{name}/{age}&quot;)
public String findUser1(@PathVariable(value = &quot;age&quot;) Integer age,
                        @PathVariable(value = &quot;name&quot;) String name) {
    String content = String.format(&quot;name = %s,age = %d&quot;, name, age);
    log.info(content);
    return content;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种用法被广泛使用于Representational State Transfer(REST)的软件架构风格，个人觉得这种风格是比较灵活和清晰的(从URL和请求方法就能完全理解接口的意义和功能)。下面再介绍两种相对特殊的使用方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;带条件的URL参数&lt;/strong&gt;&lt;br/&gt;其实路径参数支持正则表达式，例如我们在使用/sex/{sex}接口的时候，要求sex必须是F(Female)或者M(Male)，那么我们的URL模板可以定义为/sex/{sex:M|F}，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/sex/{sex:M|F}&quot;)
public String findUser2(@PathVariable(value = &quot;sex&quot;) String sex){
    log.info(sex);
    return sex;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只有/sex/F或者/sex/M的请求才会进入findUser2控制器方法，其他该路径前缀的请求都是非法的，会返回404状态码。这里仅仅是介绍了一个最简单的URL参数正则表达式的使用方式，更强大的用法可以自行摸索。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@MatrixVariable的使用&lt;/strong&gt;&lt;br/&gt;MatrixVariable也是URL参数的一种，对应注解@MatrixVariable，不过它并不是URL中的一个值(这里的值指定是两个&quot;/&quot;之间的部分)，而是值的一部分，它通过&quot;;&quot;进行分隔，通过&quot;=&quot;进行K-V设置。说起来有点抽象，举个例子：假如我们需要打电话给一个名字为doge，性别是男，分组是码畜的程序员，GET请求的URL可以表示为：&lt;code&gt;/call/doge;gender=male;group=programmer&lt;/code&gt;，我们设计的控制器方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/call/{name}&quot;)
public String find(@PathVariable(value = &quot;name&quot;) String name,
                   @MatrixVariable(value = &quot;gender&quot;) String gender,
                   @MatrixVariable(value = &quot;group&quot;) String group) {
    String content = String.format(&quot;name = %s,gender = %s,group = %s&quot;, name, gender, group);
    log.info(content);
    return content;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，如果你按照上面的例子写好代码，尝试请求一下该接口发现是报错的：400 Bad Request - Missing matrix variable 'gender' for method parameter of type String。这是因为@MatrixVariable注解的使用是不安全的，在SpringMVC中默认是关闭对其支持。要开启对@MatrixVariable的支持，需要设置RequestMappingHandlerMapping#setRemoveSemicolonContent方法为false：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
public class CustomMvcConfiguration implements InitializingBean {

    @Autowired
    private RequestMappingHandlerMapping requestMappingHandlerMapping;

    @Override
    public void afterPropertiesSet() throws Exception {
        requestMappingHandlerMapping.setRemoveSemicolonContent(false);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除非有很特殊的需要，否则不建议使用@MatrixVariable。&lt;/p&gt;
&lt;h2 id=&quot;文件上传&quot;&gt;文件上传&lt;/h2&gt;
&lt;p&gt;文件上传在使用POSTMAN模拟请求的时候需要选择form-data，POST方式进行提交：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/spmvc-p-8.png&quot; alt=&quot;spmvc-p-8&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设我们在D盘有一个图片文件叫doge.jpg，现在要通过本地服务接口把文件上传，控制器的代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/file1&quot;)
public String file1(@RequestPart(name = &quot;file1&quot;) MultipartFile multipartFile) {
    String content = String.format(&quot;name = %s,originName = %s,size = %d&quot;,
            multipartFile.getName(), multipartFile.getOriginalFilename(), multipartFile.getSize());
    log.info(content);
    return content;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台输出是：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;name = file1,originName = doge.jpg,size = 68727&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可能有点疑惑，参数是怎么来的，我们可以用Fildder抓个包看下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/spmvc-p-7.png&quot; alt=&quot;spmvc-p-7&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可知MultipartFile实例的主要属性分别来自Content-Disposition、content-type和content-length，另外，InputStream用于读取请求体的最后部分(文件的字节序列)。参数处理器用到的是RequestPartMethodArgumentResolver(记住一点，使用了@RequestPart和MultipartFile一定是使用此参数处理器)。在其他情况下，使用@RequestParam和MultipartFile或者仅仅使用MultipartFile(参数的名字必须和POST表单中的Content-Disposition描述的name一致)也可以接收上传的文件数据，主要是通过RequestParamMethodArgumentResolver进行解析处理的，它的功能比较强大，具体可以看其&lt;code&gt;supportsParameter&lt;/code&gt;方法，这两种情况的控制器方法代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/file2&quot;)
public String file2(MultipartFile file1) {
    String content = String.format(&quot;name = %s,originName = %s,size = %d&quot;,
                file1.getName(), file1.getOriginalFilename(), file1.getSize());
    log.info(content);
    return content;
}

@PostMapping(value = &quot;/file3&quot;)
public String file3(@RequestParam(name = &quot;file1&quot;) MultipartFile multipartFile) {
    String content = String.format(&quot;name = %s,originName = %s,size = %d&quot;,
            multipartFile.getName(), multipartFile.getOriginalFilename(), multipartFile.getSize());
    log.info(content);
    return content;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;其他参数&quot;&gt;其他参数&lt;/h2&gt;
&lt;p&gt;其他参数主要包括请求头、Cookie、Model、Map等相关参数，还有一些并不是很常用或者一些相对原生的属性值获取(例如HttpServletRequest、HttpServletResponse等)不做讨论。&lt;/p&gt;
&lt;h3 id=&quot;请求头&quot;&gt;请求头&lt;/h3&gt;
&lt;p&gt;请求头的值主要通过@RequestHeader注解的参数获取，参数处理器是RequestHeaderMethodArgumentResolver，需要在注解中指定请求头的Key。简单实用如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/spmvc-p-9.png&quot; alt=&quot;spmvc-p-9&quot;/&gt;&lt;/p&gt;
&lt;p&gt;控制器方法代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/header&quot;)
public String header(@RequestHeader(name = &quot;Content-Type&quot;) String contentType) {
   return contentType;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;cookie&quot;&gt;Cookie&lt;/h3&gt;
&lt;p&gt;Cookie的值主要通过@CookieValue注解的参数获取，参数处理器为ServletCookieValueMethodArgumentResolver，需要在注解中指定Cookie的Key。控制器方法代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/cookie&quot;)
public String cookie(@CookieValue(name = &quot;JSESSIONID&quot;) String sessionId) {
    return sessionId;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;model类型参数&quot;&gt;Model类型参数&lt;/h3&gt;
&lt;p&gt;Model类型参数的处理器是ModelMethodProcessor，实际上处理此参数是直接返回ModelAndViewContainer实例中的Model(ModelMap类型)，因为要桥接不同的接口和类的功能，因此回调的实例是BindingAwareModelMap类型，此类型继承自ModelMap同时实现了Model接口。举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/model&quot;)
public String model(Model model, ModelMap modelMap) {
    log.info(&quot;{}&quot;, model == modelMap);
    return &quot;success&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意调用此接口，控制台输出Info日志内容为：true。ModelMap或者Model中添加的属性项会附加到HttpRequestServlet中带到页面中进行渲染。&lt;/p&gt;
&lt;h3 id=&quot;modelattribute参数&quot;&gt;@ModelAttribute参数&lt;/h3&gt;
&lt;p&gt;@ModelAttribute注解处理的参数处理器为ModelAttributeMethodProcessor，@ModelAttribute的功能源码的注释如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Annotation that binds a method parameter or method return value to a named model attribute, exposed to a web view.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单来说，就是通过key-value形式绑定方法参数或者方法返回值到Model(Map)中，区别下面三种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、@ModelAttribute使用在方法(返回值)上，方法没有返回值(void类型)， Model(Map)参数需要自行设置。&lt;/li&gt;
&lt;li&gt;2、@ModelAttribute使用在方法(返回值)上，方法有返回值(非void类型)，返回值会添加到Model(Map)参数，key由@ModelAttribute的value指定，否则会使用返回值类型字符串(首写字母变为小写)。&lt;/li&gt;
&lt;li&gt;3、@ModelAttribute使用在方法参数中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在一个控制器(使用了@Controller)中，如果存在一到多个使用了@ModelAttribute的方法，这些方法总是在进入控制器方法之前执行，并且执行顺序是由加载顺序决定的(具体的顺序是带参数的优先，并且按照方法首字母升序排序)，举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
@RestController
public class ModelAttributeController {

    @ModelAttribute
    public void before(Model model) {
        log.info(&quot;before..........&quot;);
        model.addAttribute(&quot;before&quot;, &quot;beforeValue&quot;);
    }

    @ModelAttribute(value = &quot;beforeArg&quot;)
    public String beforeArg() {
        log.info(&quot;beforeArg..........&quot;);
        return &quot;beforeArgValue&quot;;
    }

    @GetMapping(value = &quot;/modelAttribute&quot;)
    public String modelAttribute(Model model, @ModelAttribute(value = &quot;beforeArg&quot;) String beforeArg) {
        log.info(&quot;modelAttribute..........&quot;);
        log.info(&quot;beforeArg..........{}&quot;, beforeArg);
        log.info(&quot;{}&quot;, model);
        return &quot;success&quot;;
    }

    @ModelAttribute
    public void after(Model model) {
        log.info(&quot;after..........&quot;);
        model.addAttribute(&quot;after&quot;, &quot;afterValue&quot;);
    }

    @ModelAttribute(value = &quot;afterArg&quot;)
    public String afterArg() {
        log.info(&quot;afterArg..........&quot;);
        return &quot;afterArgValue&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用此接口，控制台输出日志如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;after..........
before..........
afterArg..........
beforeArg..........
modelAttribute..........
beforeArg..........beforeArgValue
{after=afterValue, before=beforeValue, afterArg=afterArgValue, beforeArg=beforeArgValue}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以印证排序规则和参数设置、获取。&lt;/p&gt;
&lt;h3 id=&quot;errors或者bindingresult参数&quot;&gt;Errors或者BindingResult参数&lt;/h3&gt;
&lt;p&gt;Errors其实是BindingResult的父接口，BindingResult主要用于回调JSR参数校验异常的属性项，如果JSR校验异常，一般会抛出MethodArgumentNotValidException异常，并且会返回400(Bad Request)，见全局异常处理器DefaultHandlerExceptionResolver。Errors类型的参数处理器为ErrorsMethodArgumentResolver。举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/errors&quot;)
public String errors(@RequestBody @Validated ErrorsModel errors, BindingResult bindingResult) {
    if (bindingResult.hasErrors()) {
        for (ObjectError objectError : bindingResult.getAllErrors()) {
            log.warn(&quot;name={},message={}&quot;, objectError.getObjectName(), objectError.getDefaultMessage());
        }
    }
    return errors.toString();
}

//ErrorsModel
@Data
@NoArgsConstructor
public class ErrorsModel {
    @NotNull(message = &quot;id must not be null!&quot;)
    private Integer id;
    @NotEmpty(message = &quot;errors name must not be empty!&quot;)
    private String name;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用接口控制台Warn日志如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;name=errors,message=errors name must not be empty!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般情况下，不建议用这种方式处理JSR校验异常的属性项，因为会涉及到大量的重复的硬编码工作，建议直接继承ResponseEntityExceptionHandler，覆盖对应的方法。&lt;/p&gt;
&lt;h3 id=&quot;value参数&quot;&gt;@Value参数&lt;/h3&gt;
&lt;p&gt;控制器方法的参数可以是@Value注解修饰的参数，会从Environment中装配和转换属性值到对应的参数中(也就是参数的来源并不是请求体)，参数处理器为ExpressionValueMethodArgumentResolver。举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/value&quot;)
public String value(@Value(value = &quot;${spring.application.name}&quot;) String name) {
    log.info(&quot;spring.application.name={}&quot;, name);
    return name;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;map类型参数&quot;&gt;Map类型参数&lt;/h3&gt;
&lt;p&gt;Map类型参数的范围相对比较广，对应一系列的参数处理器，注意区别使用了上面提到的部分注解的Map类型和完全不使用注解的Map类型参数，两者的处理方式不相同。下面列举几个相对典型的Map类型参数处理例子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不使用任何注解的Map&amp;lt;String,Object&amp;gt;参数&lt;/strong&gt;&lt;br/&gt;这种情况下参数实际上直接回调ModelAndViewContainer中的ModelMap实例，参数处理器为MapMethodProcessor，往Map参数中添加的属性将会带到页面中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用@RequestParam注解的Map&amp;lt;String,Object&amp;gt;参数&lt;/strong&gt;&lt;br/&gt;这种情况下的参数处理器为RequestParamMapMethodArgumentResolver，使用的请求方式需要指定ContentType为x-www-form-urlencoded，不能使用application/json的方式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/spmvc-p-10.png&quot; alt=&quot;spmvc-p-10&quot;/&gt;&lt;/p&gt;
&lt;p&gt;控制器代码为：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/map&quot;)
public String mapArgs(@RequestParam Map&amp;lt;String, Object&amp;gt; map) {
    log.info(&quot;{}&quot;, map);
    return map.toString();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用@RequestHeader注解的Map&amp;lt;String,Object&amp;gt;参数&lt;/strong&gt;&lt;br/&gt;这种情况下的参数处理器为RequestHeaderMapMethodArgumentResolver，作用是获取请求的所有请求头的Key-Value。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用@PathVariable注解的Map&amp;lt;String,Object&amp;gt;参数&lt;/strong&gt;&lt;br/&gt;这种情况下的参数处理器为PathVariableMapMethodArgumentResolver，作用是获取所有路径参数封装为Key-Value结构。&lt;/p&gt;
&lt;h3 id=&quot;multipartfile集合-批量文件上传&quot;&gt;MultipartFile集合-批量文件上传&lt;/h3&gt;
&lt;p&gt;批量文件上传的时候，我们一般需要接收一个MultipartFile集合，可以有两种选择：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、使用MultipartHttpServletRequest参数，直接调用&lt;code&gt;getFiles&lt;/code&gt;方法获取MultipartFile列表。&lt;/li&gt;
&lt;li&gt;2、使用@RequestParam注解修饰MultipartFile列表，参数处理器是RequestParamMethodArgumentResolver，其实就是第一种的封装而已。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/spmvc-p-11.png&quot; alt=&quot;spmvc-p-11&quot;/&gt;&lt;/p&gt;
&lt;p&gt;控制器方法代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/parts&quot;)
public String partArgs(@RequestParam(name = &quot;file&quot;) List&amp;lt;MultipartFile&amp;gt; parts) {
    log.info(&quot;{}&quot;, parts);
    return parts.toString();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;日期类型参数处理&quot;&gt;日期类型参数处理&lt;/h2&gt;
&lt;p&gt;日期处理个人认为是请求参数处理中最复杂的，因为一般日期处理的逻辑不是通用的，过多的定制化处理导致很难有一个统一的标准处理逻辑去处理和转换日期类型的参数。不过，这里介绍几个通用的方法，以应对各种奇葩的日期格式。下面介绍的例子中全部使用Jdk8中引入的日期时间API，围绕java.util.Date为核心的日期时间API的使用方式类同。&lt;/p&gt;
&lt;h3 id=&quot;一统一以字符串形式接收&quot;&gt;一、统一以字符串形式接收&lt;/h3&gt;
&lt;p&gt;这种是最原始但是最奏效的方式，统一以字符串形式接收，然后自行处理类型转换，下面给个小例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/date1&quot;)
public String date1(@RequestBody UserDto userDto) {
    UserEntity userEntity = new UserEntity();
    userEntity.setUserId(userDto.getUserId());
    userEntity.setBirthdayTime(LocalDateTime.parse(userDto.getBirthdayTime(), FORMATTER));
    userEntity.setGraduationTime(LocalDateTime.parse(userDto.getGraduationTime(), FORMATTER));
    log.info(userEntity.toString());
    return &quot;success&quot;;
}

@Data
public class UserDto {

    private String userId;
    private String birthdayTime;
    private String graduationTime;
}

@Data
public class UserEntity {

    private String userId;
    private LocalDateTime birthdayTime;
    private LocalDateTime graduationTime;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/spmvc-p-12.png&quot; alt=&quot;spmvc-p-12&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二使用注解datetimeformat或者jsonformat&quot;&gt;二、使用注解@DateTimeFormat或者@JsonFormat&lt;/h3&gt;
&lt;p&gt;@DateTimeFormat注解配合@RequestBody的参数使用的时候，会发现抛出InvalidFormatException异常，提示转换失败，这是因为在处理此注解的时候，只支持form提交(ContentType为x-www-form-urlencoded)，例子如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/spmvc-p-13.png&quot; alt=&quot;spmvc-p-13&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
public class UserDto2 {

    private String userId;
    @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime birthdayTime;
    @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime graduationTime;
}


@PostMapping(value = &quot;/date2&quot;)
public String date2(UserDto2 userDto2) {
    log.info(userDto2.toString());
    return &quot;success&quot;;
}

//或者像下面这样
@PostMapping(value = &quot;/date2&quot;)
public String date2(@RequestParam(&quot;name&quot;=&quot;userId&quot;)String userId,
                    @RequestParam(&quot;name&quot;=&quot;birthdayTime&quot;) @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) LocalDateTime birthdayTime,
                    @RequestParam(&quot;name&quot;=&quot;graduationTime&quot;) @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) LocalDateTime graduationTime) {
    return &quot;success&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而@JsonFormat注解可使用在form或者Json请求参数的场景，因此更推荐使用@JsonFormat注解，不过注意需要指定时区(timezone属性，例如在中国是东八区&quot;GMT+8&quot;)，否则有可能导致出现&quot;时差&quot;，举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/date2&quot;)
public String date2(@RequestBody UserDto2 userDto2) {
    log.info(userDto2.toString());
    return &quot;success&quot;;
}

@Data
public class UserDto2 {

    private String userId;
    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)
    private LocalDateTime birthdayTime;
    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)
    private LocalDateTime graduationTime;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三jackson序列化和反序列化定制&quot;&gt;三、Jackson序列化和反序列化定制&lt;/h3&gt;
&lt;p&gt;因为SpringMVC默认使用Jackson处理@RequestBody的参数转换，因此可以通过定制序列化器和反序列化器来实现日期类型的转换，这样我们就可以使用application/json的形式提交请求参数。这里的例子是转换请求Json参数中的字符串为LocalDateTime类型，属于Json反序列化，因此需要定制反序列化器：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/date3&quot;)
public String date3(@RequestBody UserDto3 userDto3) {
    log.info(userDto3.toString());
    return &quot;success&quot;;
}

@Data
public class UserDto3 {

    private String userId;
    @JsonDeserialize(using = CustomLocalDateTimeDeserializer.class)
    private LocalDateTime birthdayTime;
    @JsonDeserialize(using = CustomLocalDateTimeDeserializer.class)
    private LocalDateTime graduationTime;
}

public class CustomLocalDateTimeDeserializer extends LocalDateTimeDeserializer {

    public CustomLocalDateTimeDeserializer() {
        super(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四最佳实践&quot;&gt;四、最佳实践&lt;/h3&gt;
&lt;p&gt;前面三种方式都存在硬编码等问题，其实最佳实践是直接修改MappingJackson2HttpMessageConverter中的ObjectMapper对于日期类型处理默认的序列化器和反序列化器，这样就能全局生效，不需要再使用其他注解或者定制序列化方案(当然，有些时候需要特殊处理定制)，或者说，在需要特殊处理的场景才使用其他注解或者定制序列化方案。使用钩子接口Jackson2ObjectMapperBuilderCustomizer可以实现ObjectMapper的属性定制：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Bean
public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer(){
    return customizer-&amp;gt;{
        customizer.serializerByType(LocalDateTime.class,new LocalDateTimeSerializer(
                DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)));
        customizer.deserializerByType(LocalDateTime.class,new LocalDateTimeDeserializer(
                DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)));
    };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就能定制化MappingJackson2HttpMessageConverter中持有的ObjectMapper，上面的LocalDateTime序列化和反序列化器对全局生效。&lt;/p&gt;
&lt;h2 id=&quot;请求url匹配&quot;&gt;请求URL匹配&lt;/h2&gt;
&lt;p&gt;前面基本介绍完了主流的请求参数处理，其实SpringMVC中还会按照URL的模式进行匹配，使用的是Ant路径风格，处理工具类为&lt;code&gt;org.springframework.util.AntPathMatcher&lt;/code&gt;，从此类的注释来看，匹配规则主要包括下面四点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、&lt;code&gt;?&lt;/code&gt;匹配1个字符。&lt;/li&gt;
&lt;li&gt;2、&lt;code&gt;*&lt;/code&gt;匹配0个或者多个&lt;strong&gt;字符&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;3、&lt;code&gt;**&lt;/code&gt;匹配路径中0个或者多个&lt;strong&gt;目录&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;4、&lt;code&gt;{spring:[a-z]+}&lt;/code&gt;将正则表达式[a-z]+匹配到的值，赋值给名为&lt;strong&gt;spring&lt;/strong&gt;的路径变量。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举些例子：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;?形式的URL&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/pattern?&quot;)
public String pattern() {
    return &quot;success&quot;;
}

/pattern  404 Not Found
/patternd  200 OK
/patterndd  404 Not Found
/pattern/  404 Not Found
/patternd/s  404 Not Found&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;*形式的URL&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/pattern*&quot;)
public String pattern() {
    return &quot;success&quot;;
}

/pattern  200 OK
/pattern/  200 OK
/patternd  200 OK
/pattern/a  404 Not Found&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;**形式的URL&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/pattern/**/p&quot;)
public String pattern() {
    return &quot;success&quot;;
}

/pattern/p  200 OK
/pattern/x/p  200 OK
/pattern/x/y/p  200 OK&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;{spring:[a-z]+}形式的URL&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/pattern/{key:[a-c]+}&quot;)
public String pattern(@PathVariable(name = &quot;key&quot;) String key) {
    return &quot;success&quot;;
}

/pattern/a  200 OK
/pattern/ab  200 OK
/pattern/abc  200 OK
/pattern  404 Not Found
/pattern/abcd  404 Not Found&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的四种URL模式可以组合使用，千变万化。&lt;/p&gt;
&lt;p&gt;URL匹配还遵循&lt;strong&gt;精确匹配原则&lt;/strong&gt;，也就是存在两个模式对同一个URL都能够匹配成功，则选取最精确的URL匹配，进入对应的控制器方法，举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/pattern/**/p&quot;)
public String pattern1() {
    return &quot;success&quot;;
}

@GetMapping(value = &quot;/pattern/p&quot;)
public String pattern2() {
    return &quot;success&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面两个控制器，如果请求URL为/pattern/p，最终进入的方法为&lt;code&gt;pattern2&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后，&lt;code&gt;org.springframework.util.AntPathMatcher&lt;/code&gt;作为一个工具类，可以单独使用，不仅仅可以用于匹配URL，也可以用于匹配系统文件路径，不过需要使用其带参数构造改变内部的pathSeparator变量，例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;AntPathMatcher antPathMatcher = new AntPathMatcher(File.separator);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;笔者在前一段时间曾经花大量时间梳理和分析过Spring、SpringMVC的源码，但是后面一段很长的时间需要进行业务开发，对架构方面的东西有点生疏了，毕竟东西不用就会生疏，这个是常理。这篇文章基于一些SpringMVC的源码经验总结了请求参数的处理相关的一些知识，希望帮到自己和大家。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;spring-boot-web-starter:2.0.3.RELEASE源码。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（本文完）&lt;/p&gt;
</description>
<pubDate>Mon, 06 Aug 2018 17:19:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/throwable/p/9434436.html</dc:identifier>
</item>
<item>
<title>LoRa硬件调试-前导码 - AnswerInTheWind</title>
<link>http://www.cnblogs.com/answerinthewind/p/9434288.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/answerinthewind/p/9434288.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;已知LoRa数据包在负载之前会有一段前导码，接收端是先检测前导码，收到前导码之后才认为有数据发送过来。&lt;/p&gt;
&lt;p&gt;那么不同的前导码的长度会有什么影响呢？&lt;/p&gt;
&lt;h2 id=&quot;前导码长短的优劣势&quot;&gt;前导码长短的优劣势&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;- 前导码实际上是占符号的，也就是说越长的前导码，发送的持续时间也会越久，相应的也越耗电，所以较短的签到码就可以省点，反之则耗电，同样也会影响信道资源的占用
- 加入前导码持续的时间较长，设备可以休眠一段时间再醒来，照常可以收到数据，那么接收设备就更省电，同时兼顾实时性&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;举个例子&quot;&gt;举个例子&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;加入一个前导码持续100ms，设备每80ms醒来一次，检测有没有数据包发过来，此时，只要有数据下发，那么设备醒来就一定能检测到前导码，因为设备可以休眠，而无需一直开着接收模式等待数据下发。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;上述情况如何设置&quot;&gt;上述情况如何设置&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;需要设置接收节点的RX_preamble    大于发送设备的tx_preamble


因为接收设备的检测原理不是收购足够的前导码才表示收到了数据，而是收到了前导码就并且不超过设置的最大前导码数据就可以了&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 06 Aug 2018 15:45:00 +0000</pubDate>
<dc:creator>AnswerInTheWind</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/answerinthewind/p/9434288.html</dc:identifier>
</item>
<item>
<title>spring集成Junit做单元测试及常见异常解决办法 - 孤城孤刀</title>
<link>http://www.cnblogs.com/xyhero/p/9434252.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xyhero/p/9434252.html</guid>
<description>&lt;p&gt;spring-test依赖包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;Spring-test &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; https://mvnrepository.com/artifact/org.springframework/spring-test &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.3.7.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1、简单单元测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ssm.test; 

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.ssm.dao.UserMngDao;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; wangxiangyu
 * @date：2017年7月18日 下午2:24:50 
 * 类说明：Spring单元测试
 * 1、导入spring-test单元测试的jar包
 * 2、@ContextConfiguration(locations={&quot;classpath:applicationContext.xml&quot;})指定Spring配置文件的位置
 * 3、@RunWith(SpringJUnit4ClassRunner.class)使用Spring单元测试
 * 3、直接autowired要使用的组件
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RunWith(SpringJUnit4ClassRunner.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@ContextConfiguration(locations&lt;/span&gt;={&quot;classpath:applicationContext.xml&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MapperTest {

    @Autowired
    UserMngDao userMngDao;
    
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
        
        List&lt;/span&gt;&amp;lt;Map&amp;gt; users =&lt;span&gt; userMngDao.findAll();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Map user : users){
            String staffName &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;==user.get(&quot;staffName&quot;)?&quot;&quot;:user.get(&quot;staffName&quot;&lt;span&gt;).toString();
            System.out.println(staffName);
        }
        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、模拟前端请求单元测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.atguigu.crud.test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Before;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.mock.web.MockHttpServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.web.WebAppConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.web.servlet.MockMvc;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.web.servlet.MvcResult;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.web.servlet.setup.MockMvcBuilders;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.context.WebApplicationContext;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.atguigu.crud.bean.Employee;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.github.pagehelper.PageInfo;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 使用Spring测试模块提供的测试请求功能，测试curd请求的正确性
 * Spring4测试的时候，需要servlet3.0的支持
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; lfy
 * 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RunWith(SpringJUnit4ClassRunner.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@WebAppConfiguration
@ContextConfiguration(locations &lt;/span&gt;= { &quot;classpath:applicationContext.xml&quot;, &quot;file:src/main/webapp/WEB-INF/dispatcherServlet-servlet.xml&quot;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MvcTest {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 传入Springmvc的ioc&lt;/span&gt;
&lt;span&gt;    @Autowired
    WebApplicationContext context;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 虚拟mvc请求，获取到处理结果。&lt;/span&gt;
&lt;span&gt;    MockMvc mockMvc;

    @Before
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initMokcMvc() {
        mockMvc &lt;/span&gt;=&lt;span&gt; MockMvcBuilders.webAppContextSetup(context).build();
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testPage() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟请求拿到返回值&lt;/span&gt;
        MvcResult result = mockMvc.perform(MockMvcRequestBuilders.get(&quot;/emps&quot;).param(&quot;pn&quot;, &quot;5&quot;&lt;span&gt;)).andReturn();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求成功以后，请求域中会有pageInfo；我们可以取出pageInfo进行验证&lt;/span&gt;
        MockHttpServletRequest request =&lt;span&gt; result.getRequest();
        PageInfo pi &lt;/span&gt;= (PageInfo) request.getAttribute(&quot;pageInfo&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;当前页码：&quot;+&lt;span&gt;pi.getPageNum());
        System.out.println(&lt;/span&gt;&quot;总页码：&quot;+&lt;span&gt;pi.getPages());
        System.out.println(&lt;/span&gt;&quot;总记录数：&quot;+&lt;span&gt;pi.getTotal());
        System.out.println(&lt;/span&gt;&quot;在页面需要连续显示的页码&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] nums =&lt;span&gt; pi.getNavigatepageNums();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i : nums) {
            System.out.print(&lt;/span&gt;&quot; &quot;+&lt;span&gt;i);
        }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取员工数据&lt;/span&gt;
        List&amp;lt;Employee&amp;gt; list =&lt;span&gt; pi.getList();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Employee employee : list) {
            System.out.println(&lt;/span&gt;&quot;ID：&quot;+employee.getEmpId()+&quot;==&amp;gt;Name:&quot;+&lt;span&gt;employee.getEmpName());
        }
        
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、Junit常见异常及解决办法&lt;/p&gt;
&lt;p&gt;异常：&lt;br/&gt;&lt;span&gt;java.lang.IllegalStateException: Failed to load ApplicationContext&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;解决方法：&lt;br/&gt;java1.8版本只支持spring4.0以上。所以解决方法有两种：1）把sping版本换成4.0以上；2）把jdk调低点。此处我选择把jdk调低点，再次运行。&lt;/p&gt;
&lt;p&gt;异常：&lt;br/&gt;&lt;span&gt;java.lang.NoClassDefFoundError: org/junit/runners/model/MultipleFailureException&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;解决方法：&lt;br/&gt;没有multipleFailureException类，可能是因为你的版本过低引起的，请更换最新版本。&lt;/p&gt;
&lt;p&gt;异常：&lt;br/&gt;&lt;span&gt;java.lang.Exception: No tests found matching [{ExactMatcher:fDisplayName=test_sayHello4]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;解决方法：&lt;br/&gt;Spring-test版本与junit版本不兼容导致的，可以多试几个版本。&lt;/p&gt;
</description>
<pubDate>Mon, 06 Aug 2018 15:35:00 +0000</pubDate>
<dc:creator>孤城孤刀</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xyhero/p/9434252.html</dc:identifier>
</item>
<item>
<title>Spring_总结_04_高级配置(三)之处理歧义 - shirayner</title>
<link>http://www.cnblogs.com/shirui/p/9427869.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shirui/p/9427869.html</guid>
<description>&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;本文承接上一节：&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/shirui/p/9427045.html&quot; target=&quot;_blank&quot;&gt;Spring_总结_04_高级配置(二)之条件注解@Conditional&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们前面装配bean时，在Spring容器中，都是只有一个bean能匹配所需的结果。&lt;/p&gt;
&lt;p&gt;如果有多个bean能匹配结果的话，Spring就将无法做出选择，这就是自动装配的歧义性。&lt;/p&gt;
&lt;p&gt;这一节我们将解决自动装配的歧义性&lt;/p&gt;

&lt;h2&gt;二、歧义实例&lt;/h2&gt;
&lt;h3&gt;1.实体类&lt;/h3&gt;
&lt;p&gt;如下，有三个类都继承自Dessert&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cake &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Dessert {...}

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cookies &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Dessert {...}

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; IceCream &lt;span&gt;implements&lt;/span&gt; Dessert {...}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2.注入bean&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Autowired
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDessert(Dessert dessert){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dessert =&lt;span&gt; dessert;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3.异常&lt;/h3&gt;
&lt;p&gt;Spring有选择困难症，当Spring尝试自动装配 setDessert() 中的 Dessert 参数时，发现有三个选择，这时它会抛出一个NoUniqueBeanDefinitionException异常，来表示自己无从选择。&lt;/p&gt;




&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;可用 @Primary 和 @Qualifier 来解决歧义问题。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;三、@Primary&lt;/h2&gt;
&lt;p&gt; 在声明Bean的时候，通过将其中一个可选的bean设置为首选（primary）Bean，能够避免自动装配的歧义性。&lt;/p&gt;
&lt;p&gt;被@Primary注解的bean即可首选Bean。&lt;/p&gt;
&lt;h3&gt;1.配置首选Bean&lt;/h3&gt;
&lt;p&gt;配置首选Bean有如下两种方式：&lt;/p&gt;
&lt;p&gt;（1）在组件类中配合@Component使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
@Primary
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; IceCream &lt;span&gt;implements&lt;/span&gt; Dessert {...}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（2）在配置类中配合@Bean使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Bean
@Primary
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dessert iceCream(){
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IceCream();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2.注入bean&lt;/h3&gt;
&lt;p&gt;注入bean时，Spring会找到三个可选bean，其中一个是首选bean，因此会选择首选bean进行注入。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Autowired
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDessert(Dessert dessert){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dessert =&lt;span&gt; dessert;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：Spring 有选择困难症，若配置了两个及以上的首选Bean，则Spring有无从选择了。&lt;/p&gt;

&lt;h2&gt;四、@Qualifier&lt;/h2&gt;
&lt;p&gt;Spring 的限定符能够将bean限定到唯一一个满足要求的bean.&lt;/p&gt;
&lt;h3&gt;1. 基于ID的限定符&lt;/h3&gt;
&lt;p&gt; 为@Qualifier注解所设置的参数就是想要注入的bean的 ID&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Autowired
@Qualifier(&lt;/span&gt;&quot;iceCream&quot;)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在注入的时候，指定注入的bean为 iceCream&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDessert(Dessert dessert){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dessert =&lt;span&gt; dessert;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2. 面向特性的限定符&lt;/h3&gt;
&lt;p&gt;我们可以为bean设置自己的限定符，而不是依赖于将 bean ID 作为限定符。&lt;/p&gt;
&lt;p&gt;可在声明Bean或配置Bean时，使用@Qualifier注解设置限定符。&lt;/p&gt;
&lt;h4&gt;2.1 设置限定符&lt;/h4&gt;
&lt;p&gt;（1）在声明Bean时，设置限定符&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
@Qualifier(&lt;/span&gt;&quot;cold&quot;)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置限定符为 cold&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; IceCream &lt;span&gt;implements&lt;/span&gt; Dessert {...}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（2）在配置Bean时，设置限定符&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Bean
@Qualifier(&lt;/span&gt;&quot;cold&quot;)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置限定符为 cold&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dessert iceCream(){ 
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IceCream(); 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.2 使用限定符&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Autowired
@Qualifier(&lt;/span&gt;&quot;cold&quot;)   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注入限定符为 cold 的bean&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDessert(Dessert dessert){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dessert =&lt;span&gt; dessert;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;3 自定义限定符注解&lt;/h3&gt;
&lt;p&gt;有时，我们想为bean设置多个限定符，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
@Qualifier(&lt;/span&gt;&quot;cold&quot;)       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置限定符为 cold&lt;/span&gt;
@Qualifier(&quot;creamy&quot;)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置限定符为 creamy&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Popsicle &lt;span&gt;implements&lt;/span&gt; Dessert {...}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而，&lt;span&gt;Java不允许在同一个条目上重复出现相同类型的多个注解&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;为了解决这个问题，我们可以创建自定义的限定符注解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）自定限定符注解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;@Cold&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target({
        ElementType.TYPE,
        ElementType.CONSTRUCTOR,
        ElementType.FIELD,
        ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt; Cold{ }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;@Creamy&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target({
        ElementType.TYPE,
        ElementType.CONSTRUCTOR,
        ElementType.FIELD,
        ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt; Creamy{ }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;（2）为bean设置多个限定符&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
@Cold
@Creamy 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; IceCream &lt;span&gt;implements&lt;/span&gt; Dessert {...}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;（3）注入bean时，使用多个限定符来限定&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Autowired
@Cold
@Creamy
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDessert(Dessert dessert){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dessert =&lt;span&gt; dessert;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 06 Aug 2018 15:06:00 +0000</pubDate>
<dc:creator>shirayner</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shirui/p/9427869.html</dc:identifier>
</item>
<item>
<title>mybatis递归，一对多代码示例 - 陈灬大灬海</title>
<link>http://www.cnblogs.com/c-h-y/p/9434126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c-h-y/p/9434126.html</guid>
<description>&lt;p&gt;今天需要做一个功能，根据专业，有不同的章节，章节下面有对应的习题，&lt;/p&gt;
&lt;p&gt;由于只有这么两级，可以不用使用递归，直接查询父集，之后foreach查询子集放入对应的list集合。&lt;/p&gt;
&lt;p&gt;虽然实现了，感觉毕竟，太low。&lt;/p&gt;
&lt;p&gt;有同事跟我说可以使用mybatis的递归实现，就学习了下。&lt;/p&gt;
&lt;p&gt;对应的bean里面需要有对应的list&amp;lt;bean&amp;gt; lists的引用。&lt;/p&gt;
&lt;p&gt;直接上代码&lt;/p&gt;
&lt;p&gt;对应的sql语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;117&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `goods_category` (
  `goodscateid` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
  `name` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `parentid` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `description` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `displayorder` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `commissionrate` &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `enabled` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`goodscateid`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB AUTO_INCREMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;&lt;span&gt;utf8;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Data for the table `goods_category` &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;insert&lt;/span&gt;  &lt;span&gt;into&lt;/span&gt; `goods_category`(`goodscateid`,`name`,`parentid`,`description`,`displayorder`,`commissionrate`,`enabled`) &lt;span&gt;values&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;),(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;spring&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;),(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;springmvc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;333&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;),(&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;struts&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;444&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;),(&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jdbc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;555&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;),(&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hibernate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;666&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;),(&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mybatis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;777&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;),(&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jdbctemplate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;888&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;),(&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;beanfactory&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;999&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;),(&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;factorybean&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 实体类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
@JsonIgnoreProperties({&quot;displayorder&quot;,&quot;commissionrate&quot;,&quot;enabled&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GoodsCategoryVo {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer goodscateid;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer parentid;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String description;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer displayorder;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Double commissionrate;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer enabled;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;GoodsCategoryVo&amp;gt;&lt;span&gt; catelist;
get 。。。 set。。。 tostring。。。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;dao层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; GoodsMapper {
    List&lt;/span&gt;&amp;lt;GoodsCategoryVo&amp;gt;&lt;span&gt; getCategory(Integer pid);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;mapper.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;resultMap id&lt;span&gt;=&lt;/span&gt;&quot;getSelf&quot; type&lt;span&gt;=&lt;/span&gt;&quot;com.bscc.beans.GoodsCategoryVo&quot;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;id &lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;goodscateid&quot; property&lt;span&gt;=&lt;/span&gt;&quot;goodscateid&quot;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;id&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;result &lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;name&quot; property&lt;span&gt;=&lt;/span&gt;&quot;name&quot;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;result&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;collection property&lt;span&gt;=&lt;/span&gt;&quot;catelist&quot; &lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;getCategory&quot;
            &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;goodscateid&quot;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;collection&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;!&lt;span&gt;--&lt;/span&gt;&lt;span&gt;查到的cid作为下次的pid --&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;resultMap&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; id&lt;span&gt;=&lt;/span&gt;&quot;getCategory&quot; resultMap&lt;span&gt;=&lt;/span&gt;&quot;getSelf&quot;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; goods_category &lt;span&gt;where&lt;/span&gt;  parentid&lt;span&gt;=&lt;/span&gt;&lt;span&gt;#{pid}
        &lt;/span&gt;&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt;&lt;span&gt; displayorder,goodscateid
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;之后直接访问对应的方法，即可查询出来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@RequestMapping(&quot;/getGoodsList&quot;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;GoodsCategoryVo&amp;gt;&lt;span&gt; getGoodsList(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; pid指定为0&lt;/span&gt;
        List&amp;lt;GoodsCategoryVo&amp;gt; list = goodsMapper.getCategory(0&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果，可以使用&lt;a href=&quot;https://www.sojson.com/&quot; target=&quot;_blank&quot;&gt;json在线工具&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[
    {
        &lt;/span&gt;&quot;goodscateid&quot;: 1&lt;span&gt;,
        &lt;/span&gt;&quot;name&quot;: &quot;java&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;parentid&quot;: 0&lt;span&gt;,
        &lt;/span&gt;&quot;description&quot;: &quot;111&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;catelist&quot;&lt;span&gt;: [
            {
                &lt;/span&gt;&quot;goodscateid&quot;: 2&lt;span&gt;,
                &lt;/span&gt;&quot;name&quot;: &quot;spring&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;parentid&quot;: 1&lt;span&gt;,
                &lt;/span&gt;&quot;description&quot;: &quot;222&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;catelist&quot;&lt;span&gt;: []
            },
            {
                &lt;/span&gt;&quot;goodscateid&quot;: 3&lt;span&gt;,
                &lt;/span&gt;&quot;name&quot;: &quot;springmvc&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;parentid&quot;: 1&lt;span&gt;,
                &lt;/span&gt;&quot;description&quot;: &quot;333&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;catelist&quot;&lt;span&gt;: [
                    {
                        &lt;/span&gt;&quot;goodscateid&quot;: 9&lt;span&gt;,
                        &lt;/span&gt;&quot;name&quot;: &quot;beanfactory&quot;&lt;span&gt;,
                        &lt;/span&gt;&quot;parentid&quot;: 3&lt;span&gt;,
                        &lt;/span&gt;&quot;description&quot;: &quot;999&quot;&lt;span&gt;,
                        &lt;/span&gt;&quot;catelist&quot;&lt;span&gt;: []
                    },
                    {
                        &lt;/span&gt;&quot;goodscateid&quot;: 10&lt;span&gt;,
                        &lt;/span&gt;&quot;name&quot;: &quot;factorybean&quot;&lt;span&gt;,
                        &lt;/span&gt;&quot;parentid&quot;: 3&lt;span&gt;,
                        &lt;/span&gt;&quot;description&quot;: &quot;000&quot;&lt;span&gt;,
                        &lt;/span&gt;&quot;catelist&quot;&lt;span&gt;: []
                    }
                ]
            },
            {
                &lt;/span&gt;&quot;goodscateid&quot;: 4&lt;span&gt;,
                &lt;/span&gt;&quot;name&quot;: &quot;struts&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;parentid&quot;: 1&lt;span&gt;,
                &lt;/span&gt;&quot;description&quot;: &quot;444&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;catelist&quot;&lt;span&gt;: []
            }
        ]
    },
    {
        &lt;/span&gt;&quot;goodscateid&quot;: 5&lt;span&gt;,
        &lt;/span&gt;&quot;name&quot;: &quot;jdbc&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;parentid&quot;: 0&lt;span&gt;,
        &lt;/span&gt;&quot;description&quot;: &quot;555&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;catelist&quot;&lt;span&gt;: [
            {
                &lt;/span&gt;&quot;goodscateid&quot;: 6&lt;span&gt;,
                &lt;/span&gt;&quot;name&quot;: &quot;hibernate&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;parentid&quot;: 5&lt;span&gt;,
                &lt;/span&gt;&quot;description&quot;: &quot;666&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;catelist&quot;&lt;span&gt;: []
            },
            {
                &lt;/span&gt;&quot;goodscateid&quot;: 7&lt;span&gt;,
                &lt;/span&gt;&quot;name&quot;: &quot;mybatis&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;parentid&quot;: 5&lt;span&gt;,
                &lt;/span&gt;&quot;description&quot;: &quot;777&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;catelist&quot;&lt;span&gt;: []
            },
            {
                &lt;/span&gt;&quot;goodscateid&quot;: 8&lt;span&gt;,
                &lt;/span&gt;&quot;name&quot;: &quot;jdbctemplate&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;parentid&quot;: 5&lt;span&gt;,
                &lt;/span&gt;&quot;description&quot;: &quot;888&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;catelist&quot;&lt;span&gt;: []
            }
        ]
    }
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;mybatis递归就是这么的简单。&lt;/p&gt;

&lt;p&gt;说下mybatis一对多实现&lt;/p&gt;
&lt;p&gt;对应的bean&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dept {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String deptName;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String locAdd;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Emp&amp;gt; emps
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@JsonIgnoreProperties(&quot;dept&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Emp {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Dept dept;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;dao层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; DeptMapper {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dept getDeptById(Integer id);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; EmpMapper {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Emp getEmpByDeptId(Integer deptId); 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;mapper.xml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;com.bscc.mapper.DeptMapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;DeptResultMap&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;com.bscc.beans.Dept&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;deptName&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;deptName&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;locAdd&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;locAdd&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; private List&amp;lt;Emp&amp;gt; emps; column=&quot;id&quot;写被集合对象主键，select按照外键键查询，通过deptid查出emp给dept&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;   
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;collection &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;emps&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; ofType&lt;/span&gt;&lt;span&gt;=&quot;Emp&quot;&lt;/span&gt;&lt;span&gt; select&lt;/span&gt;&lt;span&gt;=&quot;com.bscc.mapper.EmpMapper.getEmpByDeptId&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;getDeptById&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;Integer&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;DeptResultMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        select * from tbl_dept where id=#{id}
 &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;com.bscc.mapper.EmpMapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap  &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;EmpResultMap&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;com.bscc.beans.Emp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;getEmpByDeptId&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;Integer&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;EmpResultMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
   select * from tbl_emp where deptId=#{deptId}
 &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对应的controller方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@RequestMapping(&quot;/getDeptById&quot;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dept getDeptById() {
        Dept deptById &lt;/span&gt;= deptMapper.getDeptById(1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; deptById;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;无非就是比简单查询复杂一些罢了。&lt;/p&gt;
&lt;p&gt;代码目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1158451/201808/1158451-20180806225548878-78371061.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK！！！&lt;/p&gt;
&lt;p&gt; 对应的github地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chywx/MavenProject6oneToMany&quot; target=&quot;_blank&quot;&gt;https://github.com/chywx/MavenProject6oneToMany&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Aug 2018 15:05:00 +0000</pubDate>
<dc:creator>陈灬大灬海</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/c-h-y/p/9434126.html</dc:identifier>
</item>
<item>
<title>2018年8月6日博客之旅真正开始 - 炎寒</title>
<link>http://www.cnblogs.com/xiayongming/p/9434054.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiayongming/p/9434054.html</guid>
<description>&lt;p&gt;&lt;span&gt;　&lt;strong&gt;恒，厚，勤，学，俭&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;&lt;strong&gt;怕什么真理无穷，进一寸有进一寸的欢喜！&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;      &lt;span&gt;这篇文章写给自己！这篇文章写给自己！这篇文章写给自己！这篇文章写给自己！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      以前总是在写的时候越写越纠结，考虑怎么让看得人理解，怎么让看的人明白，怎么让自己装一波逼。这篇文章写给自己，从现在开始，开始自己的博客之旅。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、自己的小总结——教育、工作（流水账）：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　 1）教育：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　2010年高中毕业就开始工作，至今有8年了，从刚毕业到现在心理变化很大，知识确实是十分重要的，不是美丽人生的敲门砖，也不是进步的阶梯，没有这些高大上的说法；我真心的认为，知识改变你对这个世界的认知，知识让你可以追求你想要的，理解你想知道的。工作时间越久越是能感到这条陌生人看来不明显的残腿对我人生征途的限制。限制不在于找工作与物质，在于对我人格发展、知识追求的限制。开篇写这些希望未来感觉不想学习、不想接触新东西的自己能重新找回一个谦虚爱学的自己。&lt;/p&gt;
&lt;p&gt;       另外，也提一个疯狂的想法，为什么一定就要是数理化史地生语文英语，数学、语文、英语、体育必修没有问题，可是物理、化学、历史、生物、政治这些，是否必须要像古诗一样背诵，一定要像数学一样背公式，是否应该追求的是意识层面上的理解而不是求某一个方程的解？背过元素周期表是否真的有意义。我不聪明也不笨，若是有人能告诉我为什么而学习\如何去真正的学习让我找到背书、背题、刷题的意义，若是家庭关系没有那么多的事情，或许我也会考个还算不错的大学，找到一份还算不错的工作吧。中考是相对公平的，是突破阶级屏障的一个非常明晰和正确的路线；但，这个公平若只是说“最后大家都是通过分数检测是否合格”这就最不合理的，出身不只影响一个人的生活基础、物质基础，还影响一个人的性格、情绪，有了这些作为底层基础，才有后续的发展、性格、培养这些上层建筑。都说寒门出贵子，这个“贵”也是“寒”比出来的罢，起始豪门的贵子多了去了，如果统计出来比例肯定也更高。说一千道一万，现在我也是个父亲了，拼命工作，为我的孩子找一个人数尽量少的班级，让老师可以把更多的精力放在因材施教上；让我的孩子尽早接触那些更高级、更新颖的东西，哪怕很贵很难，哪怕他现在并不会，只要他感兴趣我就想培养他，孩子越小的时候对这个世界的认知越重要，这些认知潜移默化的影响他以后的人生道路，我更不想让他以后跟他爸一样，上学买个橡皮泥都会很头痛。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　&lt;span&gt;　2）工作：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　工作8年，前一年在一家日企中国合作公司实习，做数据筛查和梳理，做了时间不长。一是那时候很年轻，对工作没有概念；二是也受不了日企的工作氛围（上班不能说中文，早晨7.30到，早晨早会，晚上晚会，每天报日清到每15分钟）；后来离职了。&lt;/p&gt;
&lt;p&gt;　    紧接着找了个培训学校学习.NET。（原因是本身自己对计算机感兴趣，从小喜欢研究些乱七八糟的东西，初三的时候开始“玩”灰鸽子啊（真的是玩，只是用工具）、上兴啊、加花加壳啊，过免杀啊这些，没有什么实在的技术但对计算机整体认识提升了不少。）&lt;/p&gt;
&lt;p&gt;　　学费4700，四个月，全日制加周六，早九晚八，那阵子学习的很刻苦，也算是从一群大专学生中“脱颖而出”？这个时候是第一次有一种感觉，学历不是最重要的，因为我看到太多人交了学费在玩着上学，然后毕业找不到工作回老家去的，我其实这时候感觉自己底子不算差。&lt;/p&gt;
&lt;p&gt;　　四个月后，去了三家公司面试，都收到了offer，选了一家规模大、工资相对高的（11年，多300块钱？税前2800？）。印象最深的是其他家都是面试官问问题，唯独我选的这家公司面试有卷子，让写快速排序和冒泡排序，现在回想起来就想笑，我写出来了，而且连大括号、类名、引用、注释都用笔写上了。现在自己也面试了不少别人，也出过类似的问题，相比之下，当年我写的答卷的仔细程度可能就是这家公司收留我一个中专文凭的弱鸡的原因吧？？&lt;/p&gt;
&lt;p&gt;   　入职以后懵逼状态，团队12人，平均年龄30岁，很不适应，加上维护一个零几年的老系统，有一次年终奖只发了167块？最后离职了。&lt;/p&gt;
&lt;p&gt;　　紧接着，12年到了我现在这家公司，刚来的时候只有6个人，开始实际上还是没有进入状态，而且对当时直线很看不惯（总是觉得这不好那不好的，都不好为啥不撤退在这赖着干啥），现在回想太年轻了。后来公司开展新业务，急需快速的搭建功能，对于善于“搬砖”的我意识到，机会来了。在那个技术氛围还相对不浓厚的时候，较快的开发速度加上彻夜加班的忙碌，奋斗了3年，业务上带领一个10个人的小团队为公司运营着一个年收300万左右的信息化系统，个人上也成熟了许多。这里说一点题外话，国内目前大型非科技企业对于技术的认知和要求会弱很多，相较于技术他们更在意成本和时间，这也是我现在感觉到最大的瓶颈。（中间还有一个关于团队的小插曲，对我影响很大，若有人感兴趣的话再聊。）&lt;/p&gt;
&lt;p&gt;　　慢慢在这个公司一直待到现在，管理着一个30多人的团队，也为公司培养了需求中流砥柱，职位上也从项目经理向总监方向提升，公司规模也从起初的6人发展到现在130多人。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、为何写博客？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　写博客是为了记录自己学习的点滴，另外也希望在自己积累的过程中有一个平台将自己呈现出来，说不定有1/1000000000的几率可以将自己在这个市场中被人所关注，也可以让自己以后的路越走越宽。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、未来的规划？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　1）不继续做.NET？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　.NET做了5年，经历了由盛到衰，现在自己的能力大概就是像ABP这些框架拿过来能看明白其中的原理，识别出其中的组件这样，知识面并不是很广，但对技术的理解和计算机思维培养的不错，新的技术通过学习上手也不难。&lt;/p&gt;
&lt;p&gt;　　接下来的规划考虑了很久，首先是要不要继续在高级编程语言上发展？&lt;/p&gt;
&lt;p&gt;　　　　我觉得先不要，原因是：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;第一、&lt;/strong&gt;高级编程语言总是会建立在某个或开原或闭源或免费或收费的服务商之上，所谓“高级”就是提供商对底层知识的封装和集成，我从这个角度理解高级语言总是会被热捧或被冷漠，因为其有一套封装好的底层支持库。不管这个库是采用什么模式、什么语言风格、什么技术，终归有他的长处和他的短处，总是会有所限制。知识面广可能会对垃圾回收或者缓存处理机制有深刻的理解，可这些理解却又是建立在这套基础库之上，有一天这个语言不在时兴，我又会受到挤压，所以我断定这条路不是长远的道路。   &lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;第二、&lt;/strong&gt;高级编程语言迭代太快，不说各种语言，就说一个.NET每一个大版本的升级又有多少API和数据结构变更的血和泪，又有多少兼容性和环境冲突的血和泪。如果加上多个语言，我的天，那真身无尽的浩劫。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;第三、&lt;/strong&gt;只掌握高级编程语言在国内应用场景相对固化，这个引入一个问题，设计出高级程序语言目的是什么？ 我的理解是抽象和封装底层，让开发更加方便和快捷。  为什么要让开发更加方便快捷？因为我们要来造轮子、造工具、造产值，我们需要的是效率。一个巨型系统需要写核心技术实现的可能只占团队人数的10%？占整个项目工作量的20%？更多的还是需要搬砖的人，什么搬砖？就是按固有的模式去把功能实现过程写出来。内存管理？底层有了，都实现了。数据结构？虚拟类、抽象类、接口……够用了。硬件对接，Excuse Me?&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;综合上述思考，在某一个特定语言领域取得成绩需要投入大量的时间精力，然而得到的成果却有十分大的局限性和不稳定性，受影响的因素太多，很可能会变成现在的VB程序员。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　   　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、新的方向：底层+电路+硬件+网络+高级编程语言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;&lt;span&gt;　1）为自己新方向的考虑做如下的定义和思考：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　   前瞻思考：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　目前最火的技术领域：&lt;strong&gt;AI、3D打印、IoT、区块链、大数据、自动驾驶&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　目前这些技术领域都在从两大入手：&lt;strong&gt;算法、硬件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　&lt;strong&gt;为什么？——我的思考：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　1、从零几年开始，国内开始企业信息化的大潮，就此诞生出无数的弄潮儿金蝶、用友……数不胜数，然而时至今日，大海早已变红，随着信息化市场的成熟发展变得越来越慢，效益也变得越来越难，市场上的竞争对手也越来越多，技术也变得越来越成熟。在需求的催化下、大型技术企业的布局需求、设备成本越来越低、新技术突破、资本涌入信息技术的催化之下原来不可能的事变得可能，原来不敢想的事儿现在敢想。&lt;/p&gt;
&lt;p&gt;　　　　　　　2、本身整个发展也遵循着：基础设施层面——基础应用层面——高级应用层面    轨道发展，网络通信相关的建设、基础设备技术的突破、最小企事业个人单位的信息化普及率的提升、集成化信息产品的普及的盛行也都酝酿着这些高级技术应用的诞生。&lt;/p&gt;
&lt;p&gt;　　　　　　　3、整个市场大环境的变化，更加开放，更加进步，更容易接受新生事物，这些事情也在不断的让更多更新、更好的想法在市场上得到认证。&lt;/p&gt;
&lt;p&gt;　　　　　　　4、资本在驱动让市场更加活跃，更加敢于试错，重金之下必有勇夫，在资本的驱动下国内电商/信息化市场异常的活跃。（当然也有不少泡沫，总体上来说比房地产小多了吧。）&lt;/p&gt;
&lt;p&gt;　　　　　　   5、上述的发展让更多的资源投入到这个行业中，就好像烧开的热水，下面的升上来，上面的往两边去。&lt;/p&gt;
&lt;p&gt;　　　　　　　&lt;span&gt;现在这些名词总是单独被提起，但很快他们将串联在一起形成一波新的基础设施的升级和迭代，这将会成为新的一波技术红利。而在他们基础之上将会百花齐放，诞生出更多的新商业应用和技术应用，不断的迭代和升级。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　   我觉得这样真的很好，我相信，&lt;span&gt;未来很快就会一种新的力量打破现在的格局，就是真的是为了改变世界而做事的人不断的涌现上来、受到每个人的支持和青睐，提供给大家像苹果4一样跨时代的产品，将大家的生活进行一次又一次的革命&lt;/span&gt;。十年后可能将会是与普通大众关系最密切的技术更新最频发的时代，技术会快速的改变你的生活，你的习惯和你一切的一切。&lt;/p&gt;
&lt;p&gt;　　　　　　　 从个人角度考虑，我试想若是以后对电路基础、硬件、网络、高级编程语言都有深刻认识的人才是真正的高级人才，对通体掌握和熟悉的人在技术管理上才有前瞻性，才有更高的统御能力；作为普通技术人员来说，未来的市场发展一家独大的可能性低之又低，因为产品的技术栈会变得很大，更加依赖于整个供应链的支持和管理，供应链会被细分的更细。加工制造型的不太了解，但在技术研发领域需要更多想小微团队深钻某个技术领域或某个技术应用，也就是未来的高竞争力企业的人数反而不一定会很多，但技术资产一定是最丰富的。在我假想的这个前提下，我希望我有条件有能力加入到一个这样的团队中或在一个企业的技术研发团队中有一席之地，有一言之地。&lt;/p&gt;

&lt;p&gt;　　  &lt;strong&gt;&lt;span&gt;高级编程语言——》高级软件设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　高级编程语言除了效率上的提升带来更大的好处是“面向对象”，从更高维度对编码工作进行了抽象，更好的将程序思维和业务思维进行结合。同时，衍生出不同的设计模式、不同的架构，从技术层面解决对象关系/认知上与技术上的冲突，最终得到一个功能完备、设计合理、维护简单的软件产品或者是代码包。我认为这才是高级编程语言所带来的最大的好处。 至于什么语法糖、声明方式、自动实现什么的都是锦上添花的东西、提升效率的工具，真正编程思想的提升和与现实的融会贯通才是最大的优势。&lt;/p&gt;
&lt;p&gt;　　　　　　　所以，未来在高级语言上的规划从涉猎“新技术”（新轮子）转向高级软件设计方向，更好的理解和领悟如何设计出一个更加完美的软件工程，如何将业务思想与编码更好的结合，如何设计出可以更加适应变化的软件产品。&lt;/p&gt;

&lt;p&gt;　　  &lt;strong&gt;&lt;span&gt;底层、电路、硬件、网络通信&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　与第一条相同，这或将成为未来知识体系中的基础知识。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总的来说涉及知识面很多、很广；学海无涯苦作舟，若想做条舟将这片大海都翱翔一遍估计此生时间不够用，所以对于技术学习做以下定义：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;1）涉及到科研、计算、推导领域的知识内容了解即可&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　数学公式、推导过程、计算公式这些了解即可，重要的公式背过。因为整个技术发展有一个重要的底层基础就是基础工作的自动化和智能化，现在有许多的软件可以让你快速的进行电路设计，模拟电路参数，可以让你不用电流表就将电路每个环节的参数模拟清楚，所以这些内容了解如何应用即可。&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;2）涉及到计算机底层知识必须熟练掌握&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　包括：二进制、汇编、编译链接、信号控制、ECF、虚拟内存、网络编程等内容必须熟练掌握，所谓熟练掌握即书本上的知识要了解，也能结合实际案例自己动手做出样例，能反编译看懂代码，对不同操作系统的特性和文件结构进行掌握。&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;3）涉及到的知识点必须可以动手实践并阶段性输出汇总性的成果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　成果包括：博客、产品、硬件模型、代码等内容&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;4）数学和英语知识必须提升&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　上学的时候没有好好学，但底子没有太差，对于离散数学、微积分方面还要深造，英语持续背单词，目的是能看懂国外的文献作品不断汲取知识。&lt;/p&gt;

&lt;p&gt;　　　　5）后续想到什么再补充&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、时间上的规划&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　今年26岁，再给自己2-3年的时间，将上述内容完全掌握并选择合适的证书考出来。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;&lt;span&gt;目前的行动：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　已购买图书十册，其中已粗度两册，精细阅读两册，理论结合实际1册，正在精度1.5册。&lt;/p&gt;
&lt;p&gt;　　　　此贴立FLAG，这些书一年之内学完，部分章节粗度后续备查，部分章节细读理论结合实际掌握清楚。&lt;/p&gt;
&lt;p&gt;　　　　这将作为我未来五年的人生导向，与工作尽量协作避免冲突。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1126312/201808/1126312-20180806224119915-676112459.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



</description>
<pubDate>Mon, 06 Aug 2018 14:50:00 +0000</pubDate>
<dc:creator>炎寒</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiayongming/p/9434054.html</dc:identifier>
</item>
<item>
<title>网络传输与加密 (2) - kid551</title>
<link>http://www.cnblogs.com/kid551/p/9434055.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kid551/p/9434055.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kid551/p/9409861.html&quot; target=&quot;_blank&quot;&gt;网络传输与加密&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;让我们先回顾一下上次的验证过程，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201808/672506-20180806225149467-1667267795.png&quot; alt=&quot;&quot; width=&quot;683&quot; height=&quot;330&quot;/&gt;&lt;/p&gt;

&lt;p&gt;有了“原信息”和它对应的“md5签名字符串”，我们就可以做最基本的信息验证：通过md5签名字符串的一致性，来保障我们收到的信息没有受到更改。&lt;/p&gt;
&lt;p&gt;P.S.：由于签名signature在后续文章中会另有所指，为区分md5签名字符串，我们将md5签名字符串的叫法，更改为&lt;strong&gt;md5指纹字符串&lt;/strong&gt;。意思同签名是一样的，就是A之所以是A的证据、特征，可以用签名来表示，也可以用指纹来表示。这里，我们开始将md5字符串对应的这个特征，称作md5指纹。&lt;/p&gt;
&lt;p&gt;但一个容易发现的漏洞是，如果“原信息”和“md5指纹字符串”同时被修改了该怎么办？原信息被代提成了伪信息，而md5指纹字符串也被替换成了伪信息所生成的md5码，这时候，原有的验证过程都可以走通，根本无法发现信息被修改了或者替换了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201808/672506-20180806225226680-101466601.png&quot; alt=&quot;&quot; width=&quot;672&quot; height=&quot;332&quot;/&gt;&lt;/p&gt;

&lt;p&gt;为了解决这个问题，在工业实践中便会将验证和加密进行组合使用。除了单纯的组合，还会引入一些基本的小技巧。&lt;/p&gt;
&lt;p&gt;例如，因为md5的验证算法是公开的，所以很容易生成一份信息的md5指纹字符串，从而对原信息进行伪造。那么，可以不可以让人无法或者说难于伪造这份信息的md5指纹字符串呢？&lt;/p&gt;
&lt;p&gt;一个小技巧是：并不提供原信息的md5验证码，而是提供“原信息+a key”的md5指纹字符串：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201808/672506-20180806225309929-634466494.png&quot; alt=&quot;&quot; width=&quot;681&quot; height=&quot;560&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个key，就是一串如“2d2316235b41924ac7c4b194661d2984”这样的随机字符串，它由“发信人”和“收信人”分别单独保存。&lt;/p&gt;
&lt;p&gt;这时候，我们的验证流程就变成了：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;发件人将“原信息”和“key”一起打包，生成一个md5指纹字符串。再将原信息和md5指纹字符串发送出去。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;收件人收到信息后，将“接受信息”和“key”一起打包，生成一个md5字符串，再与接收到的md5字符串比较，看它们是否一致。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这样的情况下，即便是原信息和md5字符串同时被修改了，但因为伪造者并不知道这个md5字符串是在原有信息的基础上，增加了什么样的一个key字符串来生成的，他就几乎不可能提供一个“原信息+key”的md5字符串。因为他无法逆向推导出那个key长成什么样。而这个“几乎不可能”，是由md5加密算法所保证的。&lt;/p&gt;
&lt;p&gt;另一种保障“原信息”和“md5指纹字符串”的方式，是直接考虑把md5验证码做加密。这种方式并不同上面的小技巧相冲突，事实上它完全可以和上面的技巧结合，构造出更安全的方式。但为了降低理解的困难程度，让我们先暂时抛开上面的小技巧，只是单纯地考虑“原信息”“md5指纹字符串”和“md5字符串加密”这三样东西。&lt;/p&gt;
&lt;p&gt;还是回到刚开头提到的核心想法，为什么仅有“原信息”和“md5指纹字符串”是不安全的？因为这两者的对应关系是由一个已知的算法连通的。之前的小技巧，是把这个用于连通的“已知”算法，通过一个私密的key，巧妙地把这个公开的“已知”算法变成了一个“未知”的算法，从而无法制造出对应的md5指纹字符串。&lt;/p&gt;
&lt;p&gt;所以，这里的重点其实是，你没办法去伪造md5指纹字符串。&lt;/p&gt;
&lt;p&gt;基于这样的考虑，我们还可以用别的方式，让其他人依旧无法伪造出md5指纹字符串，例如，你根本就不知道这个md5指纹字符串长什么样！&lt;/p&gt;
&lt;p&gt;怎么做呢？那就是，我不再提供“原信息和md5指纹”的组合，而是提供“原信息”和“用私钥加密后的md5指纹”，也即是把md5指纹又做了一次乱码。&lt;/p&gt;
&lt;p&gt;你或许会问，加密了md5有什么用？不是照样可以直接把信息和md5指纹同时换掉吗？&lt;/p&gt;
&lt;p&gt;没错，你是可以这样做，但是，这时候作为接收方来讲，他的接受验证过程，已经变成了：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;用公钥解密，得到一串字符串，当作原信息的md5指纹。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将md5函数作用在接收到的信息，得到一个本地生成的md5指纹。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将本地生成的md5指纹和原md5指纹做比较。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以，即便是你替换了原信息和md5指纹，但如果这个md5指纹没有被私钥加密过，那么按照上述步骤，通过公钥解密出来的字符串，便不会是相应的md5指纹，而是一串不知所云的乱码。从而，你必须通过私钥加密，才可以伪造md5指纹来欺骗接收方。&lt;/p&gt;
&lt;p&gt;这个被加密了的md5指纹，也被称作数字签名（digital signature）。&lt;/p&gt;
&lt;p&gt;此时，所有的安全问题，便落在了这个“私钥”上。只要它不被窃取，你发送的信息便是安全的、可以得到验证的。&lt;/p&gt;
&lt;p&gt;那么，如何保证你的“私钥”不被窃取呢？使用网络传输吗？万一在半路上被劫走篡改怎么办？基于此，更为安全妥当的办法，便是使用物理传输，直接在现实中，手把手的将秘钥给发送方。&lt;/p&gt;
&lt;p&gt;我们在生活中遇到过这样的情况吗？当然！还记得银行的网银盾么？为什么银行要煞费苦心地给你一个U盘？因为里面存放着你用来加密的私钥啊！（以及之后我们会谈到的证书）相比于通过网络连接将私钥发放给客户，直接通过现实中的实物来传递私钥，是更加可靠的。&lt;/p&gt;





&lt;p&gt;&lt;strong&gt;近期回顾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484405&amp;amp;idx=1&amp;amp;sn=3883a0c8e3fe64edbde89f016dcfa76f&amp;amp;chksm=ec20e449db576d5f0e4d91af261b301518e8db03703e312e6928d3349a3a47292b34931af44f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;不是不屑，而是自保&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484401&amp;amp;idx=1&amp;amp;sn=20a47961a9276d16bfe22e6c5dc344a5&amp;amp;chksm=ec20e44ddb576d5bbc43c038e4cbcc9ca5058c176eb990a23c7f3a6e904fa8f7372a8c5b141b&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;网络传输与加密&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484395&amp;amp;idx=1&amp;amp;sn=c771c70a46a0d6839d3095035a148084&amp;amp;chksm=ec20e457db576d41f711af590b530043ed709da5e9ef99e360200ddf1afdee12a5a6b4c9dd4a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;为什么需要提前撰写Spec文档&lt;/a&gt;》&lt;/p&gt;

&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如果你喜欢我的文章或分享，请长按下面的二维码关注我的微信公众号，谢谢！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201808/672506-20180806224857049-1573969108.jpg&quot; alt=&quot;&quot; width=&quot;688&quot; height=&quot;344&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;h3&gt;   &lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;更多信息交流和观点分享，可加入知识星球：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201808/672506-20180806224924884-705487720.png&quot; alt=&quot;&quot; width=&quot;676&quot; height=&quot;417&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Aug 2018 14:50:00 +0000</pubDate>
<dc:creator>kid551</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kid551/p/9434055.html</dc:identifier>
</item>
</channel>
</rss>