<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>linux ubuntu 远程ssh登录 - 冰叔博客</title>
<link>http://www.cnblogs.com/bingshu/p/8387858.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bingshu/p/8387858.html</guid>
<description>
&lt;p&gt;    &lt;span&gt;     当我们有一个Linux系统的时候，可能用到远程ssh登录，当你是没有界面的系统的时候也会用到，远程操作起来比较方便。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 首先我们的电脑默认是不安装ssh的，就是无法通过ssh远程连接，所以要安装shh.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（1）检查是否开启SSH服务 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　命令：dpkg -l | grep ssh  查看SSH服务是否开启，或者通过命令：service sshd status 可以查看某个服务的状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      &lt;img src=&quot;http://images2017.cnblogs.com/blog/1080989/201801/1080989-20180130232030828-896173707.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（2）安装SSH服务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　  通过apt-get 安装，命令：apt-get install ssh &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（3）启动SSH服务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　  命令：sudo /etc/init.d/ssh start&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（4）修改SSH配置文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 　&lt;/strong&gt;命令：sudo vim /etc/ssh/sshd_config，找到PermitRootLogin without-password 修改为PermitRootLogin yes&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（5）重启SSH服务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　命令：service ssh restart &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（6）连接&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt; 发现出现了入下问题。&lt;/strong&gt;&lt;/span&gt;REMOTE HOST IDENTIFICATION HAS CHANGED &lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1080989/201801/1080989-20180130232152687-1622513427.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;（7）解决问题&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;   命令：ssh-keygen -R  ip&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1080989/201801/1080989-20180130232549515-108715822.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（8）成功登陆&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1080989/201801/1080989-20180130232706250-1080284451.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;如果有问题可以联系我的qq1058179540 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;微信&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1080989/201801/1080989-20180130233106453-1118011803.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 30 Jan 2018 15:33:00 +0000</pubDate>
<dc:creator>冰叔博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bingshu/p/8387858.html</dc:identifier>
</item>
<item>
<title>IronFort---基于Django和Websocket的堡垒机 - 刘江liujiangblog.com</title>
<link>http://www.cnblogs.com/feixuelove1009/p/8387774.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixuelove1009/p/8387774.html</guid>
<description>&lt;p&gt;WebSSH有很多，基于Django的Web服务也有很多，使用Paramiko在Python中进行SSH访问的就更多了。但是通过gevent将三者结合起来，实现通过浏览器访问的堡垒机就很少见了。本文将简要介绍下我开发的IronFort堡垒机，其详细内容在我的官方网站liujiangblog.com的视频教程中。&lt;/p&gt;
&lt;h2 id=&quot;一堡垒机概述&quot;&gt;一、堡垒机概述&lt;/h2&gt;
&lt;p&gt;百度百科：堡垒机，在一个特定的网络环境下，为了保障网络和数据不受来自外部和内部用户的入侵和破坏，而运用各种技术手段实时收集和监控网络环境中每一个组成部分的系统状态、安全事件、网络活动，以便集中报警、及时处理及审计定责。&lt;/p&gt;
&lt;p&gt;对于一个中型以上的公司，当用户和职员人数较多，公司所属服务器也数量较大的情况下，其服务器上的帐号管理难度将急剧增加，参考下面的图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/wguf60ojd3huwzxcvtfi4iri/1.png&quot; alt=&quot;1.png-153.5kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这其中必然存在很多问题，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户、主机、账号数量太多，工作量大，管理混乱；&lt;/li&gt;
&lt;li&gt;每个人员的权限和可使用账号没有系统管理，等级区分不明；&lt;/li&gt;
&lt;li&gt;用户直接掌握主机的帐号密码；&lt;/li&gt;
&lt;li&gt;密码可能交叉使用；&lt;/li&gt;
&lt;li&gt;离职人员可能还可以使用公司的帐号；&lt;/li&gt;
&lt;li&gt;内部人员可以跳过防火墙，直接使用帐号在机房内访问；&lt;/li&gt;
&lt;li&gt;内部人员离职前设下木马或暗门，一段时间后再爆发；&lt;/li&gt;
&lt;li&gt;对人员的访问记录、过往操作没有日志和审计，缺乏事后追踪手段；&lt;/li&gt;
&lt;li&gt;其它风险&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在运行初期，公司可能采取Excel表格等工具，使用人工管理的方式，靠‘人治’和道德水平约束，但当公司体量逐渐变大的时候，这种方式必然遭到淘汰，于是就出现了堡垒机的概念，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/es1zf4ojya05hcgidxpdqz12/2.png&quot; alt=&quot;2.png-148.7kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种架构带来如下的好处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户不能直接访问远程主机，而是需要通过堡垒机跳转；&lt;/li&gt;
&lt;li&gt;用户不再掌握远程主机的帐号密码，只有访问堡垒机的帐号；&lt;/li&gt;
&lt;li&gt;限制用户登录远程主机后的修改密码能力，不允许修改；&lt;/li&gt;
&lt;li&gt;堡垒机的用户、远程主机的用户、用户密码、用户权限等等都被统一集中管理，大量节省人工成本；&lt;/li&gt;
&lt;li&gt;用户在登录堡垒机后所进行的一切操作将被记录下来，用于后期的行为审计；&lt;/li&gt;
&lt;li&gt;由于没有远程主机帐号密码，即使进入机房也无法直连主机；&lt;/li&gt;
&lt;li&gt;还可以实现批量命令执行、文件分发等附带功能；&lt;/li&gt;
&lt;li&gt;其它收益。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;堡垒机的核心概念是用户不再掌握帐号密码，用户的行为被记录用于审计。堡垒机主要针对的是内部网络和内部人员，对于人员流动性较强、体量大、行业风险高的企业需求特别强烈，比如金融行业。&lt;/p&gt;
&lt;p&gt;堡垒机已经拥有商业产品，多数以硬件服务器为载体进行销售，价格几十万不等。也有开源的解决方案，但这些方案有的不是基于浏览器，界面不够友好，日志记录困难；有的基于Tornado，并且只能进行简单的命令执行功能，而公司使用的是Django；更多的情况是与公司需求不一致，需要二次开发，维护和升级困难，等等不一而足。&lt;/p&gt;
&lt;p&gt;‘授人以鱼不如授人以渔’，自己掌握了开发堡垒机的核心技能，就可以快速、方便、灵活的针对公司具体需求进行定制开发，既为公司节省了购置硬件经费，又利于维护升级。&lt;/p&gt;
&lt;h2 id=&quot;二-ironfort堡垒机体系架构&quot;&gt;二、 IronFort堡垒机体系架构&lt;/h2&gt;
&lt;p&gt;IronFort堡垒机的体系架构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/qaqurkzm1y750i3rjmemsciz/3.png&quot; alt=&quot;3.png-78.4kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个完整的通信过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户通过使用支持HTML5的浏览器，在HTTP的基础上，向堡垒机发送websocket请求；&lt;/li&gt;
&lt;li&gt;堡垒机上使用gevent接收websocket请求并转发给Django；&lt;/li&gt;
&lt;li&gt;Django接收请求后，调用paramiko建立与远程主机的ssh通道；&lt;/li&gt;
&lt;li&gt;远程主机执行用户的命令后，通过ssh返回数据给Django；&lt;/li&gt;
&lt;li&gt;Django通过gevent以websocket的形式返回给用户浏览器；&lt;/li&gt;
&lt;li&gt;用户浏览器使用term.js插件模拟Linux终端，显示远程主机返回的结果。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;核心机制就是这样，下面我们来看下开发过程。&lt;/p&gt;
&lt;h2 id=&quot;三开发简介&quot;&gt;三、开发简介&lt;/h2&gt;
&lt;h3 id=&quot;项目创建&quot;&gt;1. 项目创建&lt;/h3&gt;
&lt;p&gt;堡垒机本身通常是布置在Linux主机上的，比ubuntu16.04，对外以HTTP的形式提供服务。&lt;/p&gt;
&lt;p&gt;首先需要建立虚拟环境，并安装Python3.6以及Django2.0，不再赘述。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;django-admin startproject&lt;/code&gt;和&lt;code&gt;python manage.py startapp app_name&lt;/code&gt;分别创建项目和app。&lt;/p&gt;
&lt;p&gt;此时，可以尝试运行Django服务，如果看到下面的页面，表示Ok。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/q4ichkxxbnj492uh7k59lmmz/QQ%E6%88%AA%E5%9B%BE20180130104720.jpg&quot; alt=&quot;QQ截图20180130104720.jpg-35.9kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Django2.0的欢迎界面比以前漂亮了一点，还带链接，与时俱进呀。&lt;/p&gt;
&lt;h3 id=&quot;orm模型&quot;&gt;2. ORM模型&lt;/h3&gt;
&lt;p&gt;任何一个Web项目都必须在深入分析项目需求的情况下，首先设计好ORM模型，也就是数据库的表结构。&lt;/p&gt;
&lt;p&gt;IronFort中设计了六个模型，分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;远程主机&lt;/li&gt;
&lt;li&gt;远程主机用户&lt;/li&gt;
&lt;li&gt;远程主机绑定的用户&lt;/li&gt;
&lt;li&gt;堡垒机用户&lt;/li&gt;
&lt;li&gt;堡垒机用户组&lt;/li&gt;
&lt;li&gt;日志&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里需要提醒的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个远程主机账户可以绑定多个远程主机，两者实际是多对多的关系；&lt;/li&gt;
&lt;li&gt;堡垒机用户不能直接绑定远程主机；&lt;/li&gt;
&lt;li&gt;堡垒机用户绑定的实际是一个主机+主机账户的对象；&lt;/li&gt;
&lt;li&gt;考虑账户是否激活或者被经用的enabled属性；&lt;/li&gt;
&lt;li&gt;考虑某些字段的unique_together属性；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于模型设计，每个人有每个人的需求和想法，这其中有很多坑和需要注意的地方，限于篇幅，无法展开论述。在我的个人网站liujiangblog.com的视频教程中有详细的讲解。&lt;/p&gt;
&lt;p&gt;模型设计好了，可以同时注册Django的admin后台。然后makemigrations、migrate和createsuperuser，重启服务器后就可以在admin中创建测试用例了，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/bmsqqq9yykvbwvr2ny73ndj7/9-admin%E5%90%8E%E5%8F%B0.jpg&quot; alt=&quot;9-admin后台.jpg-127.8kB&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;url和路由&quot;&gt;3. url和路由&lt;/h3&gt;
&lt;p&gt;url的设计并不复杂，没有太多的复杂页面，下面是项目中使用的一些url：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.contrib &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; admin
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.urls &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; path, re_path
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; fort &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; views

urlpatterns &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [
    path(&lt;span class=&quot;st&quot;&gt;'admin/'&lt;/span&gt;, admin.site.urls),
    path(&lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;, views.login),
    path(&lt;span class=&quot;st&quot;&gt;'login/'&lt;/span&gt;, views.login),
    path(&lt;span class=&quot;st&quot;&gt;'logout/'&lt;/span&gt;, views.logout),
    path(&lt;span class=&quot;st&quot;&gt;'index/'&lt;/span&gt;, views.index),
    path(&lt;span class=&quot;st&quot;&gt;'log/'&lt;/span&gt;, views.get_log),
    path(&lt;span class=&quot;st&quot;&gt;'host/&amp;lt;int:user_bind_host_id&amp;gt;/'&lt;/span&gt;, views.&lt;span class=&quot;ex&quot;&gt;connect&lt;/span&gt;),
]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Django2.0的url语法向flask等框架靠拢了，但依然可以使用正则模式。关于2.0和之前版本的区别，可以查看我曾经写过的一篇博文&lt;a href=&quot;http://www.liujiangblog.com/blog/8/&quot;&gt;Django 2.0 新特性 抢先看！&lt;/a&gt;。其实不是重度使用者，基本感受不出变化来，该怎么用还是怎么用。最大的区别也就在url编写，和Python2及3的支持。&lt;/p&gt;
&lt;h3 id=&quot;前端框架adminlte&quot;&gt;4. 前端框架AdminLTE&lt;/h3&gt;
&lt;p&gt;为了让用户界面美观，我这里使用了基于bootstrap的开源框架AdminLTE。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/6rf43qdduu1alob82g3b2h1p/adminlet.png&quot; alt=&quot;adminlet.png-668.8kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AdminLTE托管在GitHub上，可以通过下面的地址下载：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/almasaeed2010/AdminLTE/releases&quot; class=&quot;uri&quot;&gt;https://github.com/almasaeed2010/AdminLTE/releases&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;AdminLTE自带JQuery和Bootstrap3，无需另外下载。&lt;/p&gt;
&lt;p&gt;AdminLTE自带多种配色皮肤，可根据需要实时调整。&lt;/p&gt;
&lt;p&gt;AdminLTE是移动端自适应的，无需单独考虑。&lt;/p&gt;
&lt;p&gt;AdminLTE自带大量插件，比如datatables，可根据需要载入。&lt;/p&gt;
&lt;p&gt;但是AdminLTE的源文件包内，缺少font-awesome-4.6.3和ionicons-2.0.1这两个图标插件，它是通过CDN的形式加载的，如果网络不太好，加载可能比较困难或者缓慢，最好用本地静态文件的形式，请自定下载并引入项目内。&lt;/p&gt;
&lt;p&gt;我们不需要AdminLTE那么多的功能，只需要它的基本框架。在其源码包内，对index文件进行裁剪和静态文件导入处理，形成一个基本的base.html用于拓展，在它的基础上，我们可以扩展出index和log页面。&lt;/p&gt;
&lt;h3 id=&quot;堡垒机用户登录页面&quot;&gt;5. 堡垒机用户登录页面&lt;/h3&gt;
&lt;p&gt;堡垒机用户登录页面不需要使用AdminLTE，最好是单独一个简单的页面，展示的内容越少越好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/3nij6dl0tht5ud1wsaibvkd5/1-%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2.jpg&quot; alt=&quot;1-登录界面.jpg-108.6kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而用户登录的处理视图就很简单了，直接使用Django内置的Auth认证系统。&lt;/p&gt;
&lt;p&gt;使用Django自带的authenticate和login方法就可以完成用户验证和登录会话。&lt;/p&gt;
&lt;p&gt;既然有了登录，必然就要有登出。为了限制未登录用户访问堡垒机系统，所有的相关视图都必须先使用装饰器进行是否登录验证。&lt;/p&gt;
&lt;p&gt;通常而言，堡垒机不需要提供面向用户的注册页面。堡垒机用户的注册都是超级管理员掌控的，在后台进行！&lt;/p&gt;
&lt;h3 id=&quot;主机帐号页面&quot;&gt;6. 主机帐号页面&lt;/h3&gt;
&lt;p&gt;也就是我们堡垒机用户登录进系统后，显示的默认页面index。这里将通过表格的形式，列出当前堡垒机用户可以使用的远程主机帐号。视图很简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@login_required(login_url='/login/')
def index(request):
    # ...通过ORM的API查询可使用的帐号
    return render(request, 'fort/index.html', locals())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主机账户的前端页面index基于base.html，使用datatable插件，提供搜索、排序和分页等高级功能，其展示效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/62j1753qsrihvvzarbcrd3mv/2-%E4%B8%BB%E6%9C%BA%E5%B8%90%E5%8F%B7%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2.jpg&quot; alt=&quot;2-主机帐号显示页面.jpg-255kB&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;在浏览器中打开websocket通道&quot;&gt;7. 在浏览器中打开websocket通道&lt;/h3&gt;
&lt;p&gt;百度百科：WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。&lt;/p&gt;
&lt;p&gt;本文不打算成为一篇websocket的科普文，有兴趣深入研究的可以查看博客园的精华博文&lt;a href=&quot;https://www.cnblogs.com/chyingp/p/websocket-deep-in.html&quot;&gt;WebSocket协议：5分钟从入门到精通&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单的说，有以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HTTP本身是无状态连接，不支持实时通信；&lt;/li&gt;
&lt;li&gt;websocket基于HTML5，需要浏览器支持；&lt;/li&gt;
&lt;li&gt;通过在http报头中添加upgrade属性，申请通信协议升级为websocket；&lt;/li&gt;
&lt;li&gt;升级成为websocket通信后，可以实现浏览器和远程服务器之间的全双工实时通信。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于websocket的使用教程，可以参考阮一峰专家的博文&lt;a href=&quot;http://www.ruanyifeng.com/blog/2017/05/websocket.html&quot;&gt;WebSocket 教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其具体API如下图所示（图片来自菜鸟教程）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/0y4p79f9wj58bjy5lytucq26/image.png&quot; alt=&quot;image.png-74.8kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/wtpvdtyphltytyrz7kpj92s1/image.png&quot; alt=&quot;image.png-92.7kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要简单的创建并使用一个websocket，按下面的套路就可以了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用&lt;code&gt;new WebSocket(url, [protocol] );&lt;/code&gt;创建ws对象&lt;/li&gt;
&lt;li&gt;使用ws，调用onopen、onmessage、onerror和onclose方法处理通信过程中的数据&lt;/li&gt;
&lt;li&gt;使用ws，调用send方法发送数据给后端服务器&lt;/li&gt;
&lt;li&gt;使用ws，调用close方法，关闭websocket连接。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们在主机帐号表格中隐藏一个主机帐号id的字段，通过js代码获取该字段的值，然后启动websocket通信，传递这个id作为参数之一，用于构造websocket通信使用的url。&lt;/p&gt;
&lt;p&gt;在浏览器模拟Linux终端方面，我使用的是term.js插件。这是一个开源在github上的浏览器模拟Linux终端的js插件，地址为：&lt;code&gt;https://github.com/chjj/term.js&lt;/code&gt;。其官方文档比较简单，有兴趣的同学可以深入研读其源代码，或者使用xterm作为替代。&lt;/p&gt;
&lt;p&gt;最终效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/7mi7c899koh0raxzfcpn1g2j/%E6%97%A0%E6%95%88%E8%BF%9E%E6%8E%A5.jpg&quot; alt=&quot;无效连接.jpg-98.6kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为此时后端还没有完成，所以是连接不上任何主机的。&lt;/p&gt;
&lt;h3 id=&quot;创建websocket服务器&quot;&gt;8. 创建websocket服务器&lt;/h3&gt;
&lt;p&gt;Django本身是一个同步Web框架，也不支持websocket。所以你使用它的runserver，是无法接收和处理websocket请求的。为了解决这个问题，可以使用gevent这个Python的第三方异步网络框架。&lt;/p&gt;
&lt;p&gt;gevent基于greelet协程库，自带有WSGI服务器，并且其扩展库gevent-websocket支持websocket通信。&lt;/p&gt;
&lt;p&gt;请先用&lt;code&gt;pip install gevent gevent-websocket&lt;/code&gt;安装这两个库。&lt;/p&gt;
&lt;p&gt;在IronFort项目根目录下创建一个&lt;code&gt;start_ironfort.py&lt;/code&gt;脚本，以后这就是我们的服务启动脚本了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from gevent import monkey
monkey.patch_all()

from gevent.pywsgi import WSGIServer
from geventwebsocket.handler import WebSocketHandler
from ironfort.wsgi import application

print('ironfort is running ......')

ws_server = WSGIServer(
    (host, port),
    application,
    log=None,
    handler_class=WebSocketHandler
)

try:
    ws_server.serve_forever()
except KeyboardInterrupt:
    print('服务器关闭......')
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;核心要点是，使用gevent的WSGIServer服务器代替DJango的runserver，使用geventwebsocket的WebSocketHandler来处理浏览器发送过来的websocket通信请求，并将其转发到Django的application。&lt;/p&gt;
&lt;p&gt;我们知道Django的通信入口就存在于&lt;code&gt;from ironfort.wsgi import application&lt;/code&gt;中的这个方法。通过gevent的帮助，我们让Django具备了接收websocket通信请求的能力。&lt;/p&gt;
&lt;p&gt;运行&lt;code&gt;python start_ironfort&lt;/code&gt;可以启动新的服务器，在浏览器验证一下，都可以正常访问。&lt;/p&gt;
&lt;h3 id=&quot;在django中创建视图处理websocket请求&quot;&gt;9. 在Django中创建视图处理websocket请求&lt;/h3&gt;
&lt;p&gt;我们前面的根路由中已经写了相关的url，这里再贴出来：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;path('host/&amp;lt;int:user_bind_host_id&amp;gt;/', views.connect),&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，以&lt;code&gt;ws://ip:port/host/15/&lt;/code&gt;形式的url请求，将被转发到connect视图进行处理，这其中传递了‘15’这个主机帐号id的参数。具体connect视图局部代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;at&quot;&gt;@login_required&lt;/span&gt;(login_url&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'/login/'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;ex&quot;&gt;connect&lt;/span&gt;(request, user_bind_host_id):
    &lt;span class=&quot;co&quot;&gt;#　如果当前请求不是websocket请求则退出&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;# ...省略&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;# 获取remote_user_bind_host&lt;/span&gt;

    bridge &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; WSSHBridge(request.environ.get(&lt;span class=&quot;st&quot;&gt;'wsgi.websocket'&lt;/span&gt;), request.user)

    &lt;span class=&quot;cf&quot;&gt;try&lt;/span&gt;:
        bridge.&lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(
            host_ip&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;remote_user_bind_host.host.ip,
            port&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;remote_user_bind_host.host.port,
            username&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;remote_user_bind_host.remote_user.remote_user_name,
            password&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;remote_user_bind_host.remote_user.password
        )
    &lt;span class=&quot;cf&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;pp&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; e:
        message &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'尝试连接&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;{0}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;的过程中发生错误：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;{1}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(
            remote_user_bind_host.remote_user.remote_user_name, e)
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(message)
        add_log(request.user, message, log_type&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'2'&lt;/span&gt;)
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; HttpResponse(&lt;span class=&quot;st&quot;&gt;&quot;错误！无法建立SSH连接！&quot;&lt;/span&gt;)

    bridge.shell()

    request.environ.get(&lt;span class=&quot;st&quot;&gt;'wsgi.websocket'&lt;/span&gt;).close()
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'用户断开连接.....'&lt;/span&gt;)
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; HttpResponse(&lt;span class=&quot;st&quot;&gt;&quot;200, ok&quot;&lt;/span&gt;) &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取id对应的远程帐号；&lt;/li&gt;
&lt;li&gt;调用WSSHBridge()方法，传入websocket对象和当前用户，创建一个websocket和ssh通信的桥接类，这个类一会我们会介绍。&lt;/li&gt;
&lt;li&gt;调用open方法启动ssh通信；&lt;/li&gt;
&lt;li&gt;调用shell方法启动终端环境；&lt;/li&gt;
&lt;li&gt;通信结束后调用close方法，关闭通道。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么这里的WSSHBridge类是什么呢？&lt;/p&gt;
&lt;h3 id=&quot;wsshbridge桥接通信类&quot;&gt;10. WSSHBridge桥接通信类&lt;/h3&gt;
&lt;p&gt;WSSHBridge：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import gevent
from gevent.socket import wait_read, wait_write
import paramiko
import json


class WSSHBridge:
    &quot;&quot;&quot;
    桥接websocket和SSH的核心类
    &quot;&quot;&quot;

    def __init__(self, websocket, user):
        self.user = user
        self._websocket = websocket
        self._tasks = []
        #...

    def open(self, host_ip, port=22, username=None, password=None):
        &quot;&quot;&quot;        建立SSH连接        &quot;&quot;&quot;
        pass

    def _forward_inbound(self, channel):
        &quot;&quot;&quot;        正向数据转发，websocket -&amp;gt;  ssh        &quot;&quot;&quot;
        pass

    def _forward_outbound(self, channel):
        &quot;&quot;&quot;        反向数据转发，ssh -&amp;gt; websocket        &quot;&quot;&quot;
        pass

    def _bridge(self, channel):
        &quot;&quot;&quot;        桥接websocket和ssh        &quot;&quot;&quot;
        pass

    def close(self):
        &quot;&quot;&quot;        结束桥接会话        &quot;&quot;&quot;
        pass

    def shell(self):
        &quot;&quot;&quot;        启动一个shell通信界面        &quot;&quot;&quot;
       pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先需要&lt;code&gt;pip install paramiko&lt;/code&gt;安装模块。&lt;/p&gt;
&lt;p&gt;WSSHBridge类，本质上就是桥接websocket通道和paramiko打开的ssh通道，进行数据双向转发。&lt;/p&gt;
&lt;p&gt;open方法调用paramiko的相关API，传入主机ip、port、用户名和密码，打开ssh通道，&lt;code&gt;_forward_inbound&lt;/code&gt;和&lt;code&gt;_forward_outbound&lt;/code&gt;方法分别实现数据的正向和反向转发。&lt;/p&gt;
&lt;p&gt;核心的关键是&lt;code&gt;_bridge&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;self._tasks = [
            gevent.spawn(self._forward_inbound, channel),
            gevent.spawn(self._forward_outbound, channel),
        ]
        gevent.joinall(self._tasks)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用gevent的spawn方法创建了两个协同任务，然后调用joinall方法等待它们任务结束。这样就实现了数据在websocket通道和ssh通道之间的一发一收，一收一发的通信机制。&lt;/p&gt;
&lt;p&gt;这一步完成后，重启服务器，我们就可以来展示整个通信过程了。&lt;/p&gt;
&lt;p&gt;首先是，连接成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/kdzf0apx4wvx0bgwv7hbcbd4/4-%E5%9F%BA%E4%BA%8Ewebsocket%E7%9A%84%E5%A0%A1%E5%9E%92%E6%9C%BAssh%E8%BF%9E%E6%8E%A5.jpg&quot; alt=&quot;4-基于websocket的堡垒机ssh连接.jpg-188.4kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其次是类似Python这种交互式命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/7bnojzd5vaarlyc8g10ryhtt/5-%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%8E%AF%E5%A2%83%E5%91%BD%E4%BB%A4.jpg&quot; alt=&quot;5-交互式环境命令.jpg-266.9kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后是top这种动态命令结果返回：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/8kpl2fq9o93gpifgoxhvb4k2/6-%E5%8A%A8%E6%80%81%E5%86%85%E5%AE%B9%E4%BC%A0%E8%BE%93%E5%91%BD%E4%BB%A4%EF%BC%88%E6%AF%94%E5%A6%82top%EF%BC%89.jpg&quot; alt=&quot;6-动态内容传输命令（比如top）.jpg-386.9kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后是vim这种编辑环境：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/9ch5obdo6enpbs4mkyn6yzpp/7-vim%E7%AD%89%E7%BC%96%E8%BE%91%E7%8E%AF%E5%A2%83.jpg&quot; alt=&quot;7-vim等编辑环境.jpg-133.5kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，我们是支持彩色输出的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/1wfy4ricvjw59vasj6i65bi2/8-%E6%94%AF%E6%8C%81%E5%BD%A9%E8%89%B2%E8%BE%93%E5%87%BA.jpg&quot; alt=&quot;8-支持彩色输出.jpg-194kB&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;日志记录和行为审计&quot;&gt;11. 日志记录和行为审计&lt;/h3&gt;
&lt;p&gt;关于用户操作，在数据由websocket往ssh发送过程中，可以保存用户通过前端Linux模拟器终端所敲击的所有按键记录，并且很规整的以回车键进行分隔，非常容易判别。&lt;/p&gt;
&lt;p&gt;我们只需要创建一个日志模型，编写一个保存日志的方法，然后在需要的位置保存日志即可。&lt;/p&gt;
&lt;p&gt;日志展示页面非常类似主机账户的页面，同样使用datatable插件进行处理，最终效果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/eezlnc7dtc137y822uowfify/3-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E9%A1%B5%E9%9D%A2.jpg&quot; alt=&quot;3-日志系统页面.jpg-270kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，基于Webssh的堡垒机核心功能就开发完毕了。限于篇幅，不可能点点滴滴、枝叶不漏的全部叙述，我这里也只是一个抛砖引玉的过程。&lt;/p&gt;
&lt;h2 id=&quot;四总结&quot;&gt;四、总结&lt;/h2&gt;
&lt;p&gt;远程主机的创建、主机账号的管理、堡垒机用户和用户组的管理，这一系列的工作，目前我还是放在admin后台中进行。后期，大家可以将它迁移到堡垒机页面中一起管理。如果将IronFort用于生产环境，添加批量命令执行、文件分发功能，进行系统部署上线、结合Linux运维等等，必然需要大量的额外工作和安全机制，这些就留给大家自己去研究了。&lt;/p&gt;
&lt;p&gt;另外，我在官方主页&lt;a href=&quot;http://www.liujiangblog.com/&quot;&gt;刘江的博客和教程&lt;/a&gt;中，还有一个关于CMDB主机管理系统的教程，将它结合到堡垒机项目中来，一个运维管理平台的核心底层功能就基本具备了，在此基础上进行扩展，大有可为！&lt;/p&gt;
&lt;p&gt;最后，个人技术和能力有限，必然存在不足之处，请大家轻喷，多提宝贵意见，谢谢！&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jan 2018 15:19:00 +0000</pubDate>
<dc:creator>刘江liujiangblog.com</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feixuelove1009/p/8387774.html</dc:identifier>
</item>
<item>
<title>深入理解final关键字以及一些建议 - Chan'sBlog</title>
<link>http://www.cnblogs.com/chansblogs/p/8387801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chansblogs/p/8387801.html</guid>
<description>&lt;p&gt;引子：一说到final关键字，相信大家都会立刻想起一些基本的作用，那么我们先稍微用寥寥数行来回顾一下。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、final关键字的含义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;final是Java中的一个保留关键字，它可以标记在成员变量、方法、类以及本地变量上。一旦我们将某个对象声明为了final的，那么我们将不能再改变这个对象的引用了。如果我们尝试将被修饰为final的对象重新赋值，编译器就会报错。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、用法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.修饰变量&lt;/p&gt;
&lt;p&gt;final修饰在成员变量或者局部变量上，那么我们可以称这个变量是final变量，这可能使我们用到最多的地方，举个栗子：常量(虽然现在建议使用枚举类来代替常量)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/872578/201801/872578-20180130213206609-353674850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们将被final修饰的变量重新赋值，编译器就会报出如图：cannot assign a value to final variable.(不能给final变量赋值)&lt;/p&gt;

&lt;p&gt;2.修饰方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;被final所修饰的方法将无法被子类重写。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“&lt;strong&gt;使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。&lt;/strong&gt;” -- 摘自《Java编程思想》&lt;/p&gt;
&lt;p&gt;因此如果你认为一个方法的功能已经足够完整了，子类中不需要改变的话，你可以声明此方法为final。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定(正如编程思想中所提到的，在现在几版较新的JDK中，已经几乎没有性能差别了)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/872578/201801/872578-20180130214946171-730300605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(当我们尝试重写的时候编译器就会报错)。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：类的private方法会隐式地被指定为final方法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;3.修饰类&lt;/p&gt;
&lt;p&gt;如果某个类被final所修饰，那么表明这个的功能通常是完整的；&lt;strong&gt;该类将不能被继承&lt;/strong&gt;。并且&lt;span&gt;final类的所有方法都会被隐式的修饰成final&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;4.ps：&lt;span&gt;匿名类中的所有变量都必须是final的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、关键字final的好处小结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;final关键字提高了性能。JVM和Java应用都会缓存final变量。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用final关键字，JVM会对方法、变量及类进行优化。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对于不可变类，它的对象是只读的，可以在多线程环境下安全的共享，不用额外的同步开销。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、来自《Effective Java》中的一些建议&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;该书的第17条：&lt;span&gt;&lt;strong&gt;要么为了继承而设计，并提供文档说明，要么就禁止继承&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;该条目提醒我们，如果类不是被设计用来继承的，那么这个类就应该被禁止继承(听起来有点绕，但细想下来的设计思想是很好的)，否则就应该提供足够的文档及注释(具体可参考java.util.AbstractCollection这个骨架实现里的注释文档规范)。&lt;/p&gt;
&lt;p&gt;而禁止类被子类化的方法通常有两个：&lt;/p&gt;
&lt;p&gt;1.将所有的构造器设为私有的(private)或者包级私有的(default)，并使用静态工厂方法来代替构造器；&lt;/p&gt;
&lt;p&gt;2.将类标记为final。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、思考&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.一些思考回头再来审视我们日常中的程序，我们可能已经习惯了不去那么刻意的使用final，顶多在写常量的时候用一用，但实际上我们很多的类，方法或者变量是不需要被改变的，或者说不会被继承的。比如我在刚读到《Effective Java》中的这个条目后，回首自己正在做的一个项目中审视了一下，我首先将自己的domain层中的一些类标为了final，因为我觉得这些类是不可能被继承的，如果继承了是不太符合设计的，并且程序运行没有异常，同时修改的还有我的依赖注入方式(参考我的上一篇博客：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/chansblogs/p/8343930.html&quot;&gt;Spring注解依赖注入的三种方式的优缺点以及优先选择&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;我重新纠正了一下自己在设计类的时候的思想顺序：之前自己在准备写一个类的时候(虽然通常我是不给类加final的= =)，可能觉得这个类(变量或者方法)不能被改变，有很强烈的这种想法时才会加上final，但现在是：这个类需不需要使他可以被子类化？如果在以后的项目更新，迭代中，并不需要，那么我会毫不犹豫的给他加上final。&lt;/p&gt;

&lt;p&gt;2.&lt;em&gt;&quot;final关键字能提升性能&quot;？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;当时发现这一点之后，我可能是中毒了，给能加上final的地方都加上了，自以为改善了性能心里还美滋滋呢。其实对这个“提升性能”一点一直还有一丝的疑问，于是我回头就去了Stack Overflow上转了一圈，找到了我想要的答案：&lt;a class=&quot;question-hyperlink&quot; href=&quot;https://stackoverflow.com/questions/4279420/does-use-of-final-keyword-in-java-improve-the-performance&quot;&gt;Does use of final keyword in Java improve the performance?&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;大佬指出，&lt;span&gt;通常是不会的&lt;/span&gt;，对于方法，HotPot会跟踪看它是否真的被重写了，并且能够优化没有被重写的内敛方法，直到它加载到了一个类复写了这个方法，这时它可以撤销(或部分撤销)这些优化。(当然,这是假设您使用的是HotPot,但到目前为止这是最常见的JVM,所以…)&lt;/p&gt;
&lt;p&gt;之后大佬指出了我们不应该为了这么丝许的性能而绞尽脑汁，建议我们应该明确设计，写出好的结构的代码以及可读性优良的代码。(在此又应证了《Effective Java》中的第55条：&lt;strong&gt;谨慎地进行优化中所指出的核心：优化的格言就是：不要进行优化&lt;/strong&gt;) （也验证了上面《Java编程思想》中最后的那句话）&lt;/p&gt;

&lt;p&gt; 3.关于局部变量以及参数中的final&lt;/p&gt;
&lt;p&gt;接着我尝试将我的局部变量以及方法中的参数都标记为final的，同2一样，已经中毒颇深了。但是我对此同时也存在着同样的疑问，然后在Stack Overflow中得到了经验证的又一个结论：局部变量以及参数中的final，同样不能提升我们的性能，它&lt;span&gt;甚至不会被写进字节码中&lt;/span&gt;。于是我操起了键盘啪啪啪一顿敲了几行代码编译了一下，并用反编译工具(如JD-GUI)打开：&lt;/p&gt;
&lt;p&gt;先来看我们的源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FinalTest {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; say(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; number) {
        System.out.println(&lt;/span&gt;&quot;number: &quot; +&lt;span&gt; number);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; num = 0&lt;span&gt;;
        say(num);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来看看编译后的.class文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FinalTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FinalTest() {
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; say(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; number) {
        System.out.println(&lt;/span&gt;&quot;number: &quot; +&lt;span&gt; number);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        say(&lt;/span&gt;0&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到在写入字节码的时候就被优化掉了，final只是编译时静态限制我们不能再赋值(改变引用)。&lt;/p&gt;

</description>
<pubDate>Tue, 30 Jan 2018 15:09:00 +0000</pubDate>
<dc:creator>Chan&amp;#39;sBlog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chansblogs/p/8387801.html</dc:identifier>
</item>
<item>
<title>postgres的initdb解析——从一次插件升级失败说起 - 非我在</title>
<link>http://www.cnblogs.com/flying-tiger/p/8385208.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-tiger/p/8385208.html</guid>
<description>&lt;p&gt;我们公司基于postgres开发了一款数据库产品，不用说我们对OSS的源码做了改动，并且也集成和自己编写了一些插件。因此，当postgresql和相关插件升级时，我们也需要将升级反应到自己的产品中去，这是背景。&lt;/p&gt;
&lt;p&gt;这次的问题是在我们升级postgresql的插件orafce(3.2.0--&amp;gt;3.6.0)时发生的。按照往常惯例我们将该插件升级后，组织源码进行编译，OK编译通过。&lt;/p&gt;
&lt;p&gt;然而，在我们进行测试时，程序在initdb时就报错停止了。报错如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[postgres@localhost data]$ initdb -D `pwd`
The files belonging to this database system will be owned by user &quot;postgres&quot;.
This user must also own the server process.

The database cluster will be initialized with locale &quot;en_US.UTF-8&quot;.
The default database encoding has accordingly been set to &quot;UTF8&quot;.
The default text search configuration will be set to &quot;english&quot;. (15541)

Data page checksums are disabled. (18153)

fixing permissions on existing directory /data ... ok (15516)
creating subdirectories ... ok (15516)
selecting default max_connections ... 100
selecting default shared_buffers ... 128MB
selecting dynamic shared memory implementation ... posix
creating configuration files ... ok (15516)
creating template1 database in /data/base/1 ... ok (15516)
initializing pg_authid ... ok (15516)
initializing dependencies ... ok (15516)
creating information schema ... FATAL: relation &quot;information_schema.columns&quot; does not exist (10414)
......
(以下省略)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;众人费解。只是升级了插件，怎么会导致无法创建initdb呢？&lt;/p&gt;
&lt;p&gt;我注意到报错中的这行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;creating information schema ... FATAL: relation &quot;information_schema.columns&quot; does not exist (10414)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;似乎挺熟悉？我看看了orafce最新的升级文件。发现在文件中有以下SQL文：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-- Oracle system views
create view oracle.user_tab_columns as
    select table_name,
           column_name,
           data_type,
           coalesce(character_maximum_length, numeric_precision) AS data_length,
           numeric_precision AS data_precision,
           numeric_scale AS data_scale,
           is_nullable AS nullable,
           ordinal_position AS column_id,
           is_updatable AS data_upgraded,
           table_schema
    from information_schema.columns;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;似乎对上了，真的是升级惹的祸？不应该啊，社区应该没这么蠢啊，再说只是个插件，怎么会影响postgres呢？这个时候还没导入插件呢，怎么会存在这个错误？&lt;/p&gt;
&lt;p&gt;困惑。&lt;/p&gt;
&lt;p&gt;因为我们产品中的postgresql的代码也有我们自己添加的代码，为了确定错误来源，我先取了一份postgresql的source，在contrib目录下放入最新的orafce代码。然后make world。&lt;/p&gt;
&lt;p&gt;在运行initdb命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(以上省略)
copying template1 to postgres ... ok (15516)
syncing data to disk ... ok (15516)

WARNING: enabling &quot;trust&quot; authentication for local connections
You can change this by editing pg_hba.conf or using the option -A, or
--auth-local and --auth-host, the next time you run initdb.

Success. You can now start the database server using:

    pg_ctl -D /data -l logfile start
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功了！说明不是OSS的问题。&lt;/p&gt;
&lt;p&gt;很好，那么就是我们的修正代码的问题了。然而initdb这一块代码不是我们team维护的，我不知道我们的产品修改了什么。好的，老老实实看看差分代码吧。&lt;/p&gt;
&lt;p&gt;结果差分代码一看，initdb.c文件我们就修改了两行代码，看了看，也只是改善性代码，和本次的问题毫无关系。费解。。。。&lt;/p&gt;
&lt;p&gt;好吧，既然是initdb出了问题，我看看initdb的代码，理理思路吧。跑过去看看抛出出错信息的代码。再加上自己的整理。大概搞清楚了原因。&lt;/p&gt;
&lt;p&gt;具体是什么原因先卖个关子。我们先看看postgresql在initdb时会执行哪些操作(缩进代表调用关系)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;main
    确保stdout和stderr的缓冲行为与交互式使用中的行为相匹配
    设置特定于应用程序的区域设置和服务目录
    process command-line options
    sync_only模式
    密码与服务器认证相关
    setup_pgdata()设置pgdata环境
    setup_bin_paths()获取postgres命令的路径，判断是否与initdb版本匹配
    set_info_version()提取信息模式所需的版本号
    setup_data_file_paths() check初始化脚本和配置文件模板
    setup_locale_encoding()设置编码方式
    setup_text_search()根据encoding设置text search方式
    do_sync模式
    initialize_data_directory
        create_data_directory()创建数据库目录pgdata
        create_xlog_or_symlink()创建pgdata下的pg_xlog目录
        创建其他子目录
        创建并配置postgresql.conf文件
        bootstrap_template1()调用postgres在Bootstrap模式下创建模板数据库template1
        (以下的配置均针对模板数据库template1)
        setup_auth()设置template1的密码表
        setup_depend()建立系统表pg_depend，该表描述了数据库对象之间的依赖关系
        setup_sysviews()运行脚本system_views.sql创建系统视图★
        setup_description()创建系统表pg_description和pg_shdescription
        setup_collation()创建系统表pg_collation，该表描述了可用的排序规则，其本质是从一个SQL名字到操作系统locale分类的映射
        setup_conversion()运行脚本conversion_create.sql创建系统表pg_conversion，该表描述编码转换过程
        setup_dictionary()运行脚本snowball_create.sql创建一些额外的目录
        setup_privileges()为postgres内置的一些object设置默认权限
        setup_schema()运行脚本information_schema.sql创建模式information_schema★
        load_plpgsql()加载plpgsql服务端编程语言
        vacuum_db()清理template1
        make_template0()根据做好的template1，拷贝复制一份作为template0
        make_postgres()根据做好的template1，拷贝复制一份作为postgres
    告诉用户initdb执行结束&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是initdb的执行过程。很清晰也很简单。其中最重要的是initialize_data_directory()函数。正是该函数一步步地建立起了数据库的基本元素。因此，出问题的地方就在这个函数&quot;内部&quot;。&lt;/p&gt;
&lt;p&gt;聪明的朋友可能看出来了，我在上面打了两处&quot;★&quot;。是的，没有错，正是这两块代码的问题，哦不，确切的说是sql的问题。&lt;/p&gt;
&lt;p&gt;下面来说。&lt;/p&gt;
&lt;p&gt;我们可爱的开发人员在&lt;strong&gt;system_views.sql&lt;/strong&gt;中加入了以下两行(询问发现是客户希望使用orafce功能，但又不想手动创建，想&quot;透明&quot;地使用)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE EXTENSION orafce;
SET search_path TO DEFAULT;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们知道orafce的初始化引用了 information_schema.columns这个视图,而这个视图在&lt;strong&gt;information_schema.sql&lt;/strong&gt;中被创建。&lt;/p&gt;
&lt;p&gt;而由上面的initdb执行过程可以看到：system_views.sql的执行顺序在information_schema.sql之前，也是就说：&lt;br/&gt;我们在初始化 orafce的时候，information_schema.columns还不存在，因此，会在执行system_views.sql时，报以上错误。&lt;/p&gt;
&lt;p&gt;知道了原因就很好改了，只要保证加入的那两行sql代码在创建information_schema之后即可~&lt;/p&gt;
&lt;p&gt;以上&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jan 2018 15:01:00 +0000</pubDate>
<dc:creator>非我在</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-tiger/p/8385208.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——28. 列表优于数组 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8387084.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8387084.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数组在两个重要方面与泛型不同。 首先，数组是协变的（covariant）。 这个吓人的单词意味着如果&lt;code&gt;Sub&lt;/code&gt;是&lt;code&gt;Super&lt;/code&gt;的子类型，则数组类型&lt;code&gt;Sub []&lt;/code&gt;是数组类型&lt;code&gt;Super []&lt;/code&gt;的子类型。 相比之下，泛型是不变的（invariant）：对于任何两种不同的类型&lt;code&gt;Type1&lt;/code&gt;和&lt;code&gt;Type2&lt;/code&gt;，&lt;code&gt;List&amp;lt;Type1&amp;gt;&lt;/code&gt;既不是&lt;code&gt;List &amp;lt;Type2&amp;gt;&lt;/code&gt;的子类型也不是父类型。[JLS，4.10; Naftalin07,2.5]。 你可能认为这意味着泛型是不足的，但可以说是数组缺陷。 这段代码是合法的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Fails at runtime!
Object[] objectArray = new Long[1];
objectArray[0] = &quot;I don't fit in&quot;; // Throws ArrayStoreException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但这个不是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Won't compile!
List&amp;lt;Object&amp;gt; ol = new ArrayList&amp;lt;Long&amp;gt;(); // Incompatible types
ol.add(&quot;I don't fit in&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无论哪种方式，你不能把一个String类型放到一个Long类型容器中，但是用一个数组，你会发现在运行时产生了一个错误；对于列表，可以在编译时就能发现错误。 当然，你宁愿在编译时找出错误。&lt;/p&gt;
&lt;p&gt;数组和泛型之间的第二个主要区别是数组被具体化了（reified）[JLS，4.7]。 这意味着数组在运行时知道并强制执行它们的元素类型。 如前所述，如果尝试将一个String放入Long数组中，得到一个ArrayStoreException异常。 相反，泛型通过擦除（erasure）来实现[JLS，4.6]。 这意味着它们只在编译时执行类型约束，并在运行时丢弃（或擦除）它们的元素类型信息。 擦除是允许泛型类型与不使用泛型的遗留代码自由互操作（条目 26），从而确保在Java 5中平滑过渡到泛型。&lt;/p&gt;
&lt;p&gt;由于这些基本差异，数组和泛型不能很好地在一起混合使用。 例如，创建泛型类型的数组，参数化类型的数组，以及类型参数的数组都是非法的。 因此，这些数组创建表达式都不合法：&lt;code&gt;new List &amp;lt;E&amp;gt; []&lt;/code&gt;，&lt;code&gt;new List &amp;lt;String&amp;gt; []&lt;/code&gt;，&lt;code&gt;new E []&lt;/code&gt;。 所有将在编译时导致泛型数组创建错误。&lt;/p&gt;
&lt;p&gt;为什么创建一个泛型数组是非法的？ 因为它不是类型安全的。 如果这是合法的，编译器生成的强制转换程序在运行时可能会因为ClassCastException异常而失败。 这将违反泛型类型系统提供的基本保证。&lt;/p&gt;
&lt;p&gt;为了具体说明，请考虑下面的代码片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Why generic array creation is illegal - won't compile!
List&amp;lt;String&amp;gt;[] stringLists = new List&amp;lt;String&amp;gt;[1];  // (1)
List&amp;lt;Integer&amp;gt; intList = List.of(42);               // (2)
Object[] objects = stringLists;                    // (3)
objects[0] = intList;                              // (4)
String s = stringLists[0].get(0);                  // (5)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;让我们假设第1行创建一个泛型数组是合法的。第2行创建并初始化包含单个元素的&lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt;。第3行将&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;数组存储到Object数组变量中，这是合法的，因为数组是协变的。第4行将&lt;code&gt;List &amp;lt;Integer&amp;gt;&lt;/code&gt;存储在Object数组的唯一元素中，这是因为泛型是通过擦除来实现的：&lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt;实例的运行时类型仅仅是List，而&lt;code&gt;List&amp;lt;String&amp;gt; []&lt;/code&gt;实例是&lt;code&gt;List []&lt;/code&gt;，所以这个赋值不会产生ArrayStoreException异常。现在我们遇到了麻烦。将一个&lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt;实例存储到一个声明为仅保存&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;实例的数组中。在第5行中，我们从这个数组的唯一列表中检索唯一的元素。编译器自动将检索到的元素转换为String，但它是一个Integer，所以我们在运行时得到一个ClassCastException异常。为了防止发生这种情况，第1行（创建一个泛型数组）必须产生一个编译时错误。&lt;/p&gt;
&lt;p&gt;类型&lt;code&gt;E&lt;/code&gt;，&lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt;和&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;等在技术上被称为不可具体化的类型（nonreifiable types）[JLS，4.7]。 直观地说，不可具体化的类型是其运行时表示包含的信息少于其编译时表示的类型。 由于擦除，可唯一确定的参数化类型是无限定通配符类型，如&lt;code&gt;List &amp;lt;?&amp;gt;&lt;/code&gt;和&lt;code&gt;Map &amp;lt;?, ?&amp;gt;&lt;/code&gt;（条目 26）。 尽管很少有用，创建无限定通配符类型的数组是合法的。&lt;/p&gt;
&lt;p&gt;禁止泛型数组的创建可能会很恼人的。 这意味着，例如，泛型集合通常不可能返回其元素类型的数组（但是参见条目 33中的部分解决方案）。 这也意味着，当使用可变参数方法（条目 53）和泛型时，会产生令人困惑的警告。 这是因为每次调用可变参数方法时，都会创建一个数组来保存可变参数。 如果此数组的元素类型不可确定，则会收到警告。 &lt;code&gt;SafeVarargs&lt;/code&gt;注解可以用来解决这个问题（条目 32）。&lt;/p&gt;
&lt;p&gt;当你在强制转换为数组类型时，得到泛型数组创建错误，或是未经检查的强制转换警告时，最佳解决方案通常是使用集合类型&lt;code&gt;List &amp;lt;E&amp;gt;&lt;/code&gt;而不是数组类型&lt;code&gt;E []&lt;/code&gt;。 这样可能会牺牲一些简洁性或性能，但作为交换，你会获得更好的类型安全性和互操作性。&lt;/p&gt;
&lt;p&gt;例如，假设你想用带有集合的构造方法来编写一个&lt;code&gt;Chooser&lt;/code&gt;类，并且有个方法返回随机选择的集合的一个元素。 根据传递给构造方法的集合，可以使用选择器作为游戏模具，魔术8球或数据源进行蒙特卡罗模拟。 这是一个没有泛型的简单实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Chooser - a class badly in need of generics!
public class Chooser {
    private final Object[] choiceArray;


    public Chooser(Collection choices) {
        choiceArray = choices.toArray();
    }


    public Object choose() {
        Random rnd = ThreadLocalRandom.current();
        return choiceArray[rnd.nextInt(choiceArray.length)];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要使用这个类，每次调用方法时，都必须将Object的&lt;code&gt;choose&lt;/code&gt;方法的返回值转换为所需的类型，如果类型错误，则转换在运行时失败。 我们先根据条目 29的建议，试图修改Chooser类，使其成为泛型的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// A first cut at making Chooser generic - won't compile
public class Chooser&amp;lt;T&amp;gt; {
    private final T[] choiceArray;

    public Chooser(Collection&amp;lt;T&amp;gt; choices) {
        choiceArray = choices.toArray();
    }

    // choose method unchanged
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你尝试编译这个类，会得到这个错误信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Chooser.java:9: error: incompatible types: Object[] cannot be
converted to T[]
        choiceArray = choices.toArray();
                                     ^
  where T is a type-variable:
    T extends Object declared in class Chooser&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没什么大不了的，将Object数组转换为T数组：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;choiceArray = (T[]) choices.toArray();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这没有了错误，而是得到一个警告：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Chooser.java:9: warning: [unchecked] unchecked cast
        choiceArray = (T[]) choices.toArray();
                                           ^
  required: T[], found: Object[]
  where T is a type-variable:
T extends Object declared in class Chooser&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译器告诉你在运行时不能保证强制转换的安全性，因为程序不会知道T代表什么类型——记住，元素类型信息在运行时会被泛型删除。 该程序可以正常工作吗？ 是的，但编译器不能证明这一点。 你可以证明这一点，在注释中提出证据，并用注解来抑制警告，但最好是消除警告的原因（条目 27）。&lt;/p&gt;
&lt;p&gt;要消除未经检查的强制转换警告，请使用列表而不是数组。 下面是另一个版本的Chooser类，编译时没有错误或警告：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// List-based Chooser - typesafe
public class Chooser&amp;lt;T&amp;gt; {
    private final List&amp;lt;T&amp;gt; choiceList;


    public Chooser(Collection&amp;lt;T&amp;gt; choices) {
        choiceList = new ArrayList&amp;lt;&amp;gt;(choices);
    }


    public T choose() {
        Random rnd = ThreadLocalRandom.current();
        return choiceList.get(rnd.nextInt(choiceList.size()));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个版本有些冗长，也许运行比较慢，但是值得一提的是，在运行时不会得到&lt;code&gt;ClassCastException&lt;/code&gt;异常。&lt;/p&gt;
&lt;p&gt;总之，数组和泛型具有非常不同的类型规则。 数组是协变和具体化的; 泛型是不变的，类型擦除的。 因此，数组提供运行时类型的安全性，但不提供编译时类型的安全性，反之亦然。 一般来说，数组和泛型不能很好地混合工作。 如果你发现把它们混合在一起，得到编译时错误或者警告，你的第一个冲动应该是用列表来替换数组。&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jan 2018 12:16:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8387084.html</dc:identifier>
</item>
<item>
<title>在单体应用的一些DDD实践经验 - ShiningRush</title>
<link>http://www.cnblogs.com/RobotZero/p/8304980.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RobotZero/p/8304980.html</guid>
<description>&lt;p&gt;阅读此文需要一定的DDD基础，如果你是第一次接触DDD读者，建议先去阅读一些DDD相关的书籍或者文章之后再来阅读本文。&lt;/p&gt;

&lt;h2&gt;背景&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;自从我在团队中推行DDD以来，我们团队经历了一系列的磨难——先是把核心项目重构，接着又在一些衍生项目中尝试全面落地DDD, 最终探索了一些经验出来，特此记录一下。&lt;/p&gt;
&lt;p&gt;本文采用语言无关的角度陈述，无论你是Java或者c#的开发同学相信都可以无障碍阅读。&lt;/p&gt;
&lt;p&gt;请注意本文并不是介绍如何实现DDD，因为这个话题实在太大了。&lt;/p&gt;
&lt;p&gt;这次的主题是分享一些我们团队在实践DDD过程中碰到问题和如何克服它们，以及介绍一下我们所使用的架构体系。&lt;/p&gt;

&lt;p&gt;先说说为什么标题限定在“单体应用”这个范围内，&lt;/p&gt;
&lt;ol readability=&quot;0.96021220159151&quot;&gt;&lt;li&gt;我们团队这次实践的应用全是单体应用&lt;/li&gt;
&lt;li readability=&quot;4.7692307692308&quot;&gt;
&lt;p&gt;如果是分布式的应用，那么拆分限界上下文（BoundedContext）的最佳实践是什么？当然是微服务！&lt;/p&gt;
&lt;p&gt;我相信现在讨论微服务的文章肯定不在少数，微软也专门出过容器化微服务架构的电子书。&lt;span&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/container-docker-introduction/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;传送门点我&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;资源如此丰富，当然就不需要我画蛇添足了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;领域模型&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;领域模型的分析可以说是DDD当中最为核心的部分，因为你整个系统的业务逻辑代码都是基于领域模型而构成的。&lt;/p&gt;
&lt;p&gt;而要将业务逻辑转换成领域模型除了对业务的熟悉外还需要极高的抽象能力，所以一般需要业务专家和建模专家共同完成。&lt;/p&gt;
&lt;p&gt;怎样提炼一个好的领域模型是一个非常大的话题，推荐你阅读以下书籍：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;《领域&lt;span&gt;驱动设计：软件核心复杂性应对之道&lt;/span&gt;》&lt;span&gt;Eric Evans&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;《实现领域驱动设计》&lt;/span&gt;Vaughn Vernon&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;《&lt;span data-bm=&quot;119&quot;&gt;领域驱动设计与模式实战&lt;/span&gt;》Jimmy Nilsson&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外微软架构电子书上还有推荐其他几本DDD的书籍，遗憾的是，JD和TB都没搜到。&lt;/p&gt;

&lt;p&gt;在团队刚开始分析领域模型时，对所有相关者都是一个极大的挑战，我这里分享几点经验帮助团队更好地度过这段时期：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不要想着能够一次提炼出完美的领域模型（除非团队中有着经验丰富的DDD实践者），通常来说，我们会在会议上决定一个粗略的模型，然后在开发过程中你会发现有一些不自然的地方，比如某些上下文频繁地与其他上文通信，或者某个实体的行为不是很恰当，这个时候再去修正领域模型，这样演进式的过程可以大大降低你们在初期的压力。&lt;/li&gt;
&lt;li&gt;如果你的团队整体能力不足以支撑领域模型的推行，或者他们在初期的配合度不高时，你可以选择把你的项目中业务逻辑最为复杂的部分使用弱化的领域模型拆解，比如仅使用充血模型和领域服务，这样至少你可以对最为复杂的部分引入一些DDD战术模式或设计模式。&lt;/li&gt;
&lt;li&gt;就算你的团队能力够了，但大部分人都没有DDD的经验的话，我也建议先只引入部分模式（比如只引入实体，值对象和仓储这类比较容易理解的模式）来提高团队的敏感度之后再采用完整的领域模型。&lt;/li&gt;
&lt;li&gt;领域模型会对查询带来一定的复杂性，这种时候你可以采用CQRS来分离Query和Command，只有在Cammand的时候你才需要发挥领域模型的威力，至于Query，SQL语句显然是更好选择。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;基础架构&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;了解DDD的同学都应该知道，DDD当中最为重要的部分就是限界上下文(BoundedContext)，在领域模型中我们区分好了上下文之后，下一步就是选择一种技术手段来确保每个上下都是低耦合高内聚且自治的。&lt;/p&gt;
&lt;p&gt;在分布式应用中，多数设计者和包括微软架构的电子书都会推荐使用一个上下文对应一个微服务的方式来实现（确实微服务和上下文的设计需求不谋而合）。&lt;/p&gt;
&lt;p&gt;但单体应用该怎么办呢？&lt;/p&gt;
&lt;p&gt;有同学说，我们可以通过命名空间来隔离它们啊。&lt;/p&gt;
&lt;p&gt;不错，我们可以这样做，但是有以下几个缺点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在使用IDE的智能引用时，你得确认你引用的实体究竟是位于当前上下文之内还是之外。&lt;/li&gt;
&lt;li&gt;会导致你的项目结构层次过深，不便于查看。（至于过深的标准是多少，看个人了，对于我来说，5层是可以接受的上限，理想是控制在4层以内）&lt;/li&gt;
&lt;li&gt;不便于向微服务架构迁移&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以我们选择了使用程序集（java是使用jar包）的方式来隔离每个上下文，这样做克服了以上的缺点，但却带来了新的问题：动态加载这些上下文。&lt;/p&gt;
&lt;p&gt;不过这种程度的问题比起带来的收益几乎可以忽视。&lt;/p&gt;
&lt;p&gt;我们团队使用一个基础平台来动态加载这些上下文，&lt;/p&gt;
&lt;p&gt;我们采用了 &lt;span&gt;&lt;a href=&quot;https://github.com/aspnetboilerplate/aspnetboilerplate&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Abp&lt;/span&gt;&lt;/a&gt; &lt;/span&gt;框架提供的插件功能来实现，如果你也是.net 的使用者，也可以采用 Abp 来构建这个应用。&lt;/p&gt;
&lt;p&gt;当然自己写一个动态加载功能也并不困难。&lt;/p&gt;
&lt;p&gt;基础架构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/950752/201801/950752-20180130152838671-524891946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可是我们的平台要承担很多功能，比如开放RESTful的API与Webservice(为了兼容老的接口), 同时还要提供授权(使用了基于Oauth2.0协议的三种模式)、数据库初始化、处理请求上下文等等，我就不一一列出来了。&lt;/p&gt;
&lt;p&gt;我们希望BC(BoundedContext，后文都会简写为BC)里不需要关注网络层面的东西而只聚焦于应用，所以很多通用的事情都由平台来承担， 而且有时还会有一些交互，比如在验证权限时你得跟用户权限上下文通信。&lt;/p&gt;
&lt;p&gt;在这种前提下，我们抽出了一个用于连接平台和这些BC的交互层，我们把它称作——桥接组件（BrigeComponent），它负责联系起平台和这些BC，外加上一些共用的基础设施，我们的架构图变成了这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/950752/201801/950752-20180130153129375-1910101225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这样一来，你可以把每个BC都当作微服务来处理，每一个BC内的分层结构你可以按你的喜欢的来，如果你喜欢标准的三层架构（UI + BLL + DAL），你可以将BC设计那样。&lt;/p&gt;
&lt;p&gt;你甚至可以每个BC都采用不同的风格，比如一个采用N层架构，而另一个采用事件驱动架构（EDA）。&lt;/p&gt;
&lt;p&gt;这里我们的BC都用了相同的DDD推荐分层架构（这里省去了 表现层， 因为现代应用大多都是前后端分离了的），如下图所示：&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/950752/201801/950752-20180130153340984-104098734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;好了，现在整体架构和领域模型都已经确定下来后，我们开始编码了，但很快我们就遇到了阻碍。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“结算上下文需要访问用户权限上下文，它需要知道这个用户的机构信息，我可以直接引用吗？”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;“帐户上下文这里输出的数据需要通用上下文提供一些有效性校验，我可以直接引用吗？”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;“我这里也需要访问通用上下文！”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;……&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;好吧，如果我们直接提供引用，会有以下问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;由于我们采用了程序集分割上下文，所以相互引用是不被允许的。&lt;/li&gt;
&lt;li&gt;就算克服了相互引用的问题，最终也会导致引用拓扑图混乱不堪。&lt;/li&gt;
&lt;li&gt;强耦合，这会直接影响到以后的拓展性。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在微服务中，为了克服服务间的互相通信问题，目前我了解的有两类解决方案，&lt;/p&gt;
&lt;p&gt;一是类似于ESB（企业服务总线）的中心化通信模式，比如大名鼎鼎的SprinCloud。&lt;/p&gt;
&lt;p&gt;二是现在微服务界炒得沸沸腾腾的ServiceMesh(服务网格)，比如 Linkerd 和 Istio。&lt;/p&gt;

&lt;p&gt;我们项目选择了前者，使用了类似于ESB中心化通信方式来解决，简单来说，你需要一个通信中介者(Mediator)来负责BC之间的交互，结构图如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/950752/201801/950752-20180130154239453-402094616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果你是 .Net 的开发者，请容许我给你安利一下我们在项目中使用的，自己开发的组件——&lt;span&gt;&lt;a href=&quot;https://github.com/ShiningRush/ServiceAnt&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;ServiceAnt&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，它目前只支持进程内的通信，但不久后会开发分布式的。&lt;/p&gt;
&lt;p&gt;详细情况你可以点击上面的连接进去查看，也可以查看我写的  &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/RobotZero/p/8360973.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;另一篇博客&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;  了解ServiceAnt是做什么的，当然你也可以选择 Mediator 来实现这个通信中间件。&lt;/p&gt;
&lt;p&gt;Java的话，由于经验较少，没有发现类似的项目，Mule ESB什么的就跟 NServiceBus 一样是重量级的组件，不适用我们这样的场景。&lt;/p&gt;

&lt;p&gt;以上就是我们用于实现DDD的基础架构，基于这样的架构我们可以很轻松地将现有应用向微服务拆分。&lt;/p&gt;
&lt;p&gt;当然，上面的架构隐藏了很多细节，比如大量的基础设施（Ioc,Aop, Logger, cache等等），&lt;/p&gt;
&lt;p&gt;原因之一是因为这些东西的设计都很常见，网上你随便就可以搜到相关设计的文章，&lt;/p&gt;
&lt;p&gt;原因之二是因为我不想这些细节影响到了读者的关注点，我希望我们可以聚焦于如何实现DDD而不是系统的其他部分。&lt;/p&gt;

&lt;h2&gt;其他的一些话&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;在推行DDD过程中，总会有一些成员会问我，DDD给我们带来的好处是什么。&lt;/p&gt;
&lt;p&gt;我总会不厌其烦地告诉他们，为了降低系统的维护成本和更合理地去解决系统业务的复杂性。&lt;/p&gt;
&lt;p&gt;但后来我渐渐发现，实现DDD本身就不是一件容易的事情，它会对项目引入新的复杂性，有时候你会发现你团队花上大量时间去建模之后，在开发过程中却依然需要不断修正模型。&lt;/p&gt;
&lt;p&gt;这很容易让整个团队士气变低，并且让开发人员有挫败感，这种时候我经常会怀疑DDD对我们而言是否真的有价值。&lt;/p&gt;
&lt;p&gt;不过坚持下去，在你使用DDD完成一到两个项目之后，你会发现建模是一件非常有意思的事情——提炼业务并将其转换为一个无关技术的模型，这就跟搭积木一样。&lt;/p&gt;

&lt;p&gt;最后给所有希望通过DDD来改善项目，并且提升自己的同学说以下两点：&lt;/p&gt;
&lt;p&gt;1，不要奢望光通过阅读就能充分地理解DDD，你需要真正去实践（当然，框架和架构设计也是一样的，不要做象牙塔里的架构师）&lt;/p&gt;
&lt;p&gt;2，实践的过程你总会碰见疑惑和挫折，比如完全不知道如何拆分上下文，也不知道该如何使用那些战术模式，这个时候再把那几本书拿出来翻翻，你就会发出“啊，原来这种场景还可以这样处理”的感概。&lt;/p&gt;

&lt;p&gt;那句话怎么说来着，&lt;/p&gt;
&lt;p&gt;The one trying to wear the crown must withstand the weight.&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jan 2018 11:22:00 +0000</pubDate>
<dc:creator>ShiningRush</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/RobotZero/p/8304980.html</dc:identifier>
</item>
<item>
<title>UWP: 实现 UWP 应用自启动 - WPInfo</title>
<link>http://www.cnblogs.com/wpinfo/p/uwp_auto_startup.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wpinfo/p/uwp_auto_startup.html</guid>
<description>&lt;p&gt;在&lt;a href=&quot;http://www.cnblogs.com/wpinfo/p/uwp_commandline_launch.html&quot; target=&quot;_blank&quot;&gt;上一篇文章&lt;/a&gt;中，我们实现了使用命令行来启动 UWP 应用，在这一篇文章中，我们会实现 UWP 应用自启用的实现，也即开机后或用户登陆后，应用自己启动。这些特性原来都是 Win32 程序所具备的，UWP 能够支持这些特性使得它和 Win32 程序的行为进一步相同。 &lt;/p&gt;
&lt;h2&gt;实现&lt;/h2&gt;
&lt;p&gt;与实现命令行启动一样，实现自启动也大体上分为两步：首先，在 Package.appxmanifest 中添加 windows.startupTask 扩展(Extension)；然后，在 App 类中处理 OnActivated 事件。事实上，除了这两步外，我们还需要增加检查 StartupTask 的状态并允许用户控制自启动的逻辑。&lt;/p&gt;
&lt;h3&gt;1. 修改 Package.appxmanifest &lt;/h3&gt;
&lt;p&gt;右击项目中的 Package.appxmanifest 文件，在快捷菜单中选择“打开方式“-&amp;gt;”XML 文本编辑器“。打开后，对它的内容按以下修改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Package
  &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/appx/manifest/foundation/windows10&quot;&lt;/span&gt;&lt;span&gt;
  xmlns:mp&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/appx/2014/phone/manifest&quot;&lt;/span&gt;&lt;span&gt;
  xmlns:uap&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/appx/manifest/uap/windows10&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
  xmlns:uap5&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/appx/manifest/uap/windows10/5&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
  IgnorableNamespaces&lt;/span&gt;&lt;span&gt;=&quot;uap mp &lt;strong&gt;uap5&lt;/strong&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  ...
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Applications&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Application 
      &lt;/span&gt;&lt;span&gt;...
     &lt;strong&gt; &amp;lt;Extensions&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;uap5:Extension &lt;/span&gt;&lt;span&gt;Category&lt;/span&gt;&lt;span&gt;=&quot;windows.startupTask&quot;&lt;/span&gt;&lt;span&gt; EntryPoint&lt;/span&gt;&lt;span&gt;=&quot;AppAutoRun.App&quot;&lt;/span&gt;&lt;span&gt; Executable&lt;/span&gt;&lt;span&gt;=&quot;AppAutoRun.exe&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;uap5:StartupTask &lt;/span&gt;&lt;span&gt;DisplayName&lt;/span&gt;&lt;span&gt;=&quot;AppAutoRun&quot;&lt;/span&gt;&lt;span&gt; Enabled&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; TaskId&lt;/span&gt;&lt;span&gt;=&quot;AppAutoRun&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;uap5:Extension&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Extensions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/strong&gt;    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Application&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Applications&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Package&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述加粗的部分就是添加的扩展 windows.startupTask，其 EntryPoint 和 Executable 属性分别指明 App 类的完整名称以及当前应用的 exe 名称。&lt;/p&gt;
&lt;p&gt;在 Extension 节点中，添加了一个节点 StartupTask，它有三个属性，说明如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TaskId：任务Id，必填，在所有的 UWP 应用中，它必须是唯一的，不能和其它应用的 TaskId 相同；&lt;/li&gt;
&lt;li&gt;Enabled：是否启用，必填，指明是否启用当前应用为自启动行为；&lt;/li&gt;
&lt;li&gt;DisplayName：显示名称，可选，在“任务管理器”中“启动”选项卡中的显示名称；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要说明的是，Enabled 属性应该设置为 false；事实上这个属性会被忽略；因为 UWP 要实现自启动，至少需要启动一次，并且向用户请求同意才行。另外目前只能添加一个 StartupTask 节点。&lt;/p&gt;
&lt;p&gt;此时，可以将应用部署(Deploy)到本机上，然后，在“任务管理器”中“启动”选项卡上，我们就可以看到了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/676860/201801/676860-20180130151808484-1501973341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里，右击每个任务，可以对它的状态进行控制（启用/禁用），可以看到当前应用的状态是“已禁用”。注意，在设置它的状态之前，App 需要至少被启动过一次。否则这里的设置是不起作用的。&lt;/p&gt;
&lt;h3&gt; 2. 查看并更改任务状态&lt;/h3&gt;
&lt;p&gt;除了在 Package.appxmanifest 中增加扩展外，我们还需要使用相关的 API 来查看所添加的 StartupTask 的状态，以及对它的更改。在 MainPage.xaml 中增加以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{ThemeResource ApplicationPageBackgroundThemeBrush}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;12&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;tbState&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button
                    &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;btnSetState&quot;&lt;/span&gt;&lt;span&gt;
                    Margin&lt;/span&gt;&lt;span&gt;=&quot;0,4,0,0&quot;&lt;/span&gt;&lt;span&gt;
                    Click&lt;/span&gt;&lt;span&gt;=&quot;btnSetState_Click&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 MainPage.xaml.cs 中增加以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; MainPage_Loaded(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; LoadState();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task LoadState()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; task = &lt;span&gt;await&lt;/span&gt; StartupTask.GetAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppAutoRun&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.tbState.Text = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Status: {task.State}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (task.State)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; StartupTaskState.Disabled:
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 禁用状态&lt;/span&gt;
                    &lt;span&gt;this&lt;/span&gt;.btnSetState.Content = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;启用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnSetState.IsEnabled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; StartupTaskState.DisabledByPolicy:
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 由管理员或组策略禁用&lt;/span&gt;
                    &lt;span&gt;this&lt;/span&gt;.btnSetState.Content = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;被系统策略禁用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnSetState.IsEnabled = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; StartupTaskState.DisabledByUser:
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 由用户手工禁用&lt;/span&gt;
                    &lt;span&gt;this&lt;/span&gt;.btnSetState.Content = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;被用户禁用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnSetState.IsEnabled = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; StartupTaskState.Enabled:
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前状态为已启用&lt;/span&gt;
                    &lt;span&gt;this&lt;/span&gt;.btnSetState.Content = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已启用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btnSetState.IsEnabled = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; btnSetState_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; task = &lt;span&gt;await&lt;/span&gt; StartupTask.GetAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppAutoRun&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (task.State ==&lt;span&gt; StartupTaskState.Disabled)
            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; task.RequestEnableAsync();
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重新加载状态&lt;/span&gt;
            &lt;span&gt;await&lt;/span&gt;&lt;span&gt; LoadState();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们通过 StartupTask 类（位于 Windows.ApplicationModel 命名空间下）的 GetAsync 来获取指定 TaskId 的自启动任务（StartupTask）。StartupTask 类具有一个 State 的枚举属性，用于表示其状态。它们的值及其意义，在注释中已经说明。&lt;/p&gt;
&lt;p&gt;补充说明以下几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;最开始时，任务的 State 是 Disabled；&lt;/li&gt;
&lt;li&gt;唯有当其 State 是 Disabled 时，才能以编程的方式使用启动；&lt;/li&gt;
&lt;li&gt;当其 State 是 DisabledByUser 或 DisabledByPolicy，需要经由用户手工启动；&lt;/li&gt;
&lt;li&gt;不支持以编程的方式使其 State 成为 Disabled；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过 StartupTask 类的 RequestEnableAsync 方法，可以向用户请求将其启动，调用这个方法后，会弹出如下窗口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/676860/201801/676860-20180130151832000-1645433237.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;205&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当用户选择“启用”后，下次系统启动后它就会自动启动，反之，如果选择”禁用“，那么它的状态会是 DisabledByUser。要想启用它，就需要打开”任务管理器“，在”启动“选项卡上右击它，选择“启用”。&lt;/p&gt;
&lt;h3&gt;3. 处理 OnActivated 事件&lt;/h3&gt;
&lt;p&gt;然后，在 App 类的 OnActivated 事件上增加对 ActivationKind 类的判断，并作相应的处理即可。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnActivated(IActivatedEventArgs args)
        {
            Frame rootFrame &lt;/span&gt;= Window.Current.Content &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Frame;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rootFrame == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                rootFrame &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Frame();
                Window.Current.Content &lt;/span&gt;=&lt;span&gt; rootFrame;
            }
            
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args.Kind ==&lt;span&gt; ActivationKind.StartupTask)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; startupArgs = args &lt;span&gt;as&lt;/span&gt;&lt;span&gt; StartupTaskActivatedEventArgs;
            }

            rootFrame.Navigate(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(MainPage), args.Kind);
            Window.Current.Activate();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，要注意的是：如果启用了自启动，当系统启动后，应用会以最小化的方式启动。 &lt;/p&gt;
</description>
<pubDate>Tue, 30 Jan 2018 11:03:00 +0000</pubDate>
<dc:creator>WPInfo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wpinfo/p/uwp_auto_startup.html</dc:identifier>
</item>
<item>
<title>用Express、MySQL搭建项目（接口以及静态文件获取、文件上传等） - 黄大渣渣</title>
<link>http://www.cnblogs.com/superSmile/p/8377171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/superSmile/p/8377171.html</guid>
<description>&lt;p&gt;一、简介&lt;/p&gt;
&lt;p&gt;    本文将主要基于node.js使用express框架搭建一个后台环境，包括如何自定义项目目录、所用依赖以及中间件、路由以及模板引擎、接口数据获取以及文件上传等内容。&lt;/p&gt;
&lt;p&gt;二、后台环境搭建   &lt;/p&gt;
&lt;p&gt;    1、新建一个目录node，然后在目录下跑命令：npm init,然后输入一些版本信息；&lt;/p&gt;
&lt;p&gt;    2、安装Express&lt;/p&gt;
&lt;p&gt;    运行指令：npm install express --save&lt;/p&gt;
&lt;p&gt;    3、在根目录下新建一个server.js文件，然后在建立服务器然后监听9999端口，输出hello world！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; express = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;express&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app =&lt;span&gt; express()

app.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,function(req,res){
    res.send(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello world!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
})

app.listen(&lt;/span&gt;&lt;span&gt;9999&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在浏览器输入http://localhost:9999就会显示hello world！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1240403/201801/1240403-20180129163314250-1262797830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三、数据准备，登录注册&lt;/p&gt;
&lt;p&gt;　　1、这里使用MySQL数据库与node.js链接。我用的是Navicat图形化工具，当然用其他工具也可以，这里将做登录、get列表数据、post文件上传，分页等功能。先在建立数据库然后创建相应的表。&lt;/p&gt;
&lt;p&gt;　　2、创建一个数据库叫node，然后创建一个表user_table，有三个字段ID，username，password。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1240403/201801/1240403-20180129183509421-1053691640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3、做一个注册登录功能&lt;/p&gt;
&lt;p&gt;　　根目录下新建一个route文件夹，便于管理路由路径模块管理，然后新建一个regLogin.js文件，然后定义router，引入MySQL，建立连接池，然后定义登录跟注册路由，然后导出路由；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
const express = require('express'&lt;span&gt;);
const router &lt;/span&gt;=&lt;span&gt; express.Router();
const mysql &lt;/span&gt;= require('mysql'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接池&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; db = mysql.createPool({host:'localhost',user:'root',password:'*******',database:'node'&lt;span&gt;})


  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义网站主页的路由&lt;/span&gt;
  router.use('/login', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req, res) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; username =&lt;span&gt; req.body.username;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; password =&lt;span&gt; req.body.password;
    db.query(`SELECT &lt;/span&gt;* FROM user_table WHERE username='${username}'`,(err,data)=&amp;gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
            console.log(err);
            res.status(&lt;/span&gt;500).send('database error'&lt;span&gt;).end()
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data[0].password==&lt;span&gt;password) {
                res.send(&lt;/span&gt;'登录成功！'&lt;span&gt;)
            }
        }
    })
  });
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义 about 页面的路由&lt;/span&gt;
  router.use('/register', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req, res) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; username =&lt;span&gt; req.body.username;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; password =&lt;span&gt; req.body.password;
    db.query(`insert into user_table(username,password) values (&lt;/span&gt;'${username}','${password}')`,(err,data)=&amp;gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
            console.log(err);
            res.status(&lt;/span&gt;500).send('database error'&lt;span&gt;).end()
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            res.send(&lt;/span&gt;'注册成功'&lt;span&gt;)
        }
    })
  });
  
  module.exports &lt;/span&gt;= router;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、在server.js里边引入body-parser，body-parser可以自动转换req数据为对象格式，然后使用express.static静态文件托管&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
const express = require('express'&lt;span&gt;)
const regLogin &lt;/span&gt;=require('./route/regLogin');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入路由&lt;/span&gt;
const bodyParser = require('body-parser'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app =&lt;span&gt; express()
app.use(bodyParser.urlencoded({ extended: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt; }))

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用路由&lt;/span&gt;
app.use('/'&lt;span&gt;, regLogin)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态文件托管&lt;/span&gt;
app.use(express.static('static'&lt;span&gt;));

app.listen(&lt;/span&gt;9999)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.在static静态文件夹下新建以下文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1240403/201801/1240403-20180129184720781-1120071300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;login.html对注册跟登录的post请求，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;IE=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Login&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;jquery.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        window.onload&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册&lt;/span&gt;
&lt;span&gt;            $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#register&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).val();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; pass &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).val();
                $.ajax({
                    type:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                    url:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/register&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                    data:{username:name,password:pass},
                    success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(res){
                        alert(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;注册成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                    }
                })
            })
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;登录&lt;/span&gt;
&lt;span&gt;            $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).val();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; pass &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).val();
                $.ajax({
                    type:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                    url:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                    data:{username:name,password:pass},
                    success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(res){
                        alert(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;登录成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                    }
                })
            })
        }
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        用户名：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        密码：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;登录&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;register&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;注册&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.校验&lt;/p&gt;
&lt;p&gt;当输入用户名密码，点击注册，则显示注册成功，数据库多了一条用户数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1240403/201801/1240403-20180129185016156-1231552544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1240403/201801/1240403-20180129185139187-1679973482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击登录则显示登录成功。&lt;/p&gt;
&lt;p&gt;四、文件上传功能&lt;/p&gt;
&lt;p&gt; 1、文件上传功能需要依赖第三方中间件multer，当然multer有一些参数，可以选择一次上传单个文件，也可以上传多个或者不限制，定义相应的输出路径等参数，详情可以看下官方文档https://www.npmjs.com/package/multer。这里首先在server.js里引入multer并设置参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const multer = require('multer'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出文件路径&lt;/span&gt;
const multerObj = multer({dest:'./static/upload'&lt;span&gt;});

app.use(multerObj.any())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、新建路由upload.js文件以及static目录下的upload.html上传文件，并在server.js中引入upload路由。&lt;/p&gt;
&lt;p&gt;upload.js代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
const express = require('express'&lt;span&gt;);
const mysql &lt;/span&gt;= require('mysql'&lt;span&gt;);
const pathLib &lt;/span&gt;= require('path'&lt;span&gt;)
const fs &lt;/span&gt;= require('fs'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; router =&lt;span&gt; express.Router();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接池&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; db = mysql.createPool({host:'localhost',user:'root',password:'*******',database:'node'&lt;span&gt;});

router.post(&lt;/span&gt;'/',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; title =&lt;span&gt; req.body.title;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (req.files[0&lt;span&gt;]) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; extName = pathLib.parse(req.files[0&lt;span&gt;].originalname).ext;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oldName = req.files[0&lt;span&gt;].path;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newName = req.files[0].path+&lt;span&gt;extName;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newFileName = req.files[0].filename +&lt;span&gt; extName;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重命名加上后缀&lt;/span&gt;
        fs.rename(oldName,newName,(err)=&amp;gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
                console.log(err);
                res.status(&lt;/span&gt;500&lt;span&gt;).end();
            }
        })

        db.query(`INSERT INTO upload_table (title,src) VALUES (&lt;/span&gt;'${title}','${newFileName}')`,(err,data)=&amp;gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
                console.log(err);
                res.status(&lt;/span&gt;500).send('err'&lt;span&gt;).end()
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                res.send(&lt;/span&gt;'上传成功'&lt;span&gt;).end()
            }
        })
    }
})

module.exports &lt;/span&gt;= router;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、当选择文件上传，数据库中就会多一天记录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1240403/201801/1240403-20180130145631046-1374808491.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1240403/201801/1240403-20180130145656671-605093418.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;五、模板引擎&lt;/p&gt;
&lt;p&gt;　　nodejs模板引擎比较常用的有jade跟ejs,jade跟我们平常时的HTML模板不兼容，而ejs跟我们平时所用的前端代码而已结合使用，所以这里将介绍使用ejs，对jade感兴趣的话也可以去了解了解。&lt;/p&gt;
&lt;p&gt;1、首先，引入依赖consolidate，consolidate集成了很多模板引擎，可以选择其中的某个模板引擎来使用，包括jade和ejs都在里边。&lt;/p&gt;
&lt;p&gt;2、在server.js引入consolidate然后定义相应渲染为HTML，然后在定义路径渲染&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
const consolidate = require('consolidate'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app =&lt;span&gt; express()

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模板&lt;/span&gt;
app.engine('html'&lt;span&gt;,consolidate.ejs);
app.set(&lt;/span&gt;'view engine','html'&lt;span&gt;);
app.set(&lt;/span&gt;'views',__dirname + '/template'&lt;span&gt;);

app.get(&lt;/span&gt;'/index',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
    res.render(&lt;/span&gt;'index.ejs',{name:'smile',text:'这是后台返回渲染数据',flag:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;});
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;res.send('index')&lt;/span&gt;
})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、在template文件夹中新建一个index.ejs，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;index&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;warp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt; include components&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;header.ejs&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            这是首页
            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;名称：&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;text:&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(flag){ &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这是flag等于true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt; } &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1240403/201801/1240403-20180130171344593-606597479.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、最后渲染出来的页面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1240403/201801/1240403-20180130171417812-1456883137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;六、cookie跟session&lt;/p&gt;
&lt;p&gt;　　1、要使用cookie以及session，得引入两个依赖，cookie-parser,cookie-session,&lt;/p&gt;
&lt;p&gt;　　2、使用cookie&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; express      = require('express'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cookieParser = require('cookie-parser'&lt;span&gt;)
 
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app =&lt;span&gt; express()
app.use(cookieParser())
 
app.get(&lt;/span&gt;'/cookie', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req, res) {
  console.log(&lt;/span&gt;'Cookies: ', '这是返回的cookie'&lt;span&gt;)
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、使用session&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; cookieSession = require('cookie-session'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; express = require('express'&lt;span&gt;)
 
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app =&lt;span&gt; express()
 
app.use(cookieSession({
  name: &lt;/span&gt;'session'&lt;span&gt;,
  keys: [&lt;/span&gt;'key1','key2','key3'],&lt;span&gt;//&lt;/span&gt;&lt;span&gt;secret keys&lt;/span&gt;
 
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cookie Options&lt;/span&gt;
  maxAge: 24 * 60 * 60 * 1000 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 24 hours&lt;/span&gt;
}))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;七、express生成器&lt;/p&gt;
&lt;p&gt;　　如果不愿意自己搭建项目架构，可以使用express生成器来快速创建一个应用的骨架。首先全局安装 express-generator，再跑一些初始命令然后下载一些依赖就可以了，也是比较简单，具体步骤参照下文档就可以http://www.expressjs.com.cn/starter/generator.html。&lt;/p&gt;


</description>
<pubDate>Tue, 30 Jan 2018 09:40:00 +0000</pubDate>
<dc:creator>黄大渣渣</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/superSmile/p/8377171.html</dc:identifier>
</item>
<item>
<title>单词拼写检查之cutoff距离 - 震灵</title>
<link>http://www.cnblogs.com/zhenlingcn/p/8386214.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenlingcn/p/8386214.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;cutoff是一个比较冷门的概念，相比于DP经典算法的编辑距离，cutoff距离只局限于自然语言处理领域。提出cutoff距离的起因很简单，因为经典的编辑距离无法很好地衡量在字符串搜索过程中的编辑距离。&lt;br/&gt;比如我们要对一个错误的字符串进行纠正，我们会用编辑距离去衡量可能正确字符串和错误字符串之间的差异。但是编辑距离有一个很大的问题就是对于自动机匹配过程存在缺陷，在自动机匹配的过程中编辑距离会变得很大。（很明显对于词库比较大的情况，必须要使用自动机）比如hello很有可能是hellx的正确单词，但是h和hellx的编辑距离是4，很明显就会存在自动机匹配难以进行的问题。&lt;/p&gt;
&lt;h3 id=&quot;什么是cutoff&quot;&gt;什么是cutoff？&lt;/h3&gt;
&lt;p&gt;针对上面提出的问题，kemal oflazer提出了cutoff算法。对于问题串stra和预测串strb，我们首先需要设置一个阈值，这个阈值作为编辑距离的限制条件。（也就是说符合编辑距离多少的为可能正确的单词）&lt;br/&gt;定义strb的长度为blen，stra的长度为alen。l = max(1, blen - t)，作为cutoff距离计算的下边界,u = min(alen, blen + t),作为cutoff距离计算的上边界。我们在计算cutoff距离的时候，就只需要计算min(ed(substr(stra,0,x),strb))(x&amp;gt;=l&amp;amp;&amp;amp;x&amp;lt;=u)即可。（此处substr表示截取0到x的字符为子串，包含x。ed表示编辑距离。min表示取最小值。）&lt;br/&gt;例如reprter和repo的cutoff距离，计算过程如下：&lt;br/&gt;&lt;img src=&quot;http://on2oj7i3h.bkt.clouddn.com/2018-01-30-17-10-33.png&quot; alt=&quot;2018-01-30-17-10-33&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何实现&quot;&gt;如何实现？&lt;/h3&gt;
&lt;p&gt;这里给出cutoff算法的Python实现。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; ed_dis(stra, strb):
    alen &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(stra)
    blen &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(strb)
    dp &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;)] &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; y &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;)]
    dp[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(alen):
        dp[i &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;][&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(alen):
        dp[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;][j &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; j &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(alen):
        &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(blen):
            &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; stra[i] &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; strb[j]:
                dp[i &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;][j &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;min&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;min&lt;/span&gt;(dp[i &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;][j] &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, dp[i][j &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;), dp[i][j])
            &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
                dp[i &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;][j &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;min&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;min&lt;/span&gt;(dp[i &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;][j] &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, dp[i][j &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;), dp[i][j] &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; dp[alen][blen]


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; cutoff_dis(stra, strb):
    &lt;span class=&quot;co&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    :param stra: 错误串&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    :param strb: 预测串&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    :return: CUTOFF距离&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    &quot;&quot;&quot;&lt;/span&gt;
    t &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;# threshold&lt;/span&gt;
    alen &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(stra)
    blen &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(strb)
    l &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;max&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, blen &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; t)
    u &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;min&lt;/span&gt;(alen, blen &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; t)
    min_ed &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;1e10&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(l, u &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;):
        suba &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; stra[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:i &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]
        min_ed &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;min&lt;/span&gt;(min_ed, ed_dis(suba, strb))
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; min_ed


&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(cutoff_dis(&lt;span class=&quot;st&quot;&gt;'reprter'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'repo'&lt;/span&gt;))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;cutoff距离如何使用&quot;&gt;cutoff距离如何使用？&lt;/h3&gt;
&lt;p&gt;计算出cutoff距离以后，究竟如何在自动机上使用cutoff距离？&lt;br/&gt;&lt;img src=&quot;http://on2oj7i3h.bkt.clouddn.com/2018-01-30-17-16-06.png&quot; alt=&quot;2018-01-30-17-16-06&quot;/&gt;&lt;br/&gt;具体的流程可以参考作者官方论文中给出的流程图。这个流程图是针对ababa这个问题串，对于aba和bab串形成的闭包进行单词推测。自动机的具体流程就不再详细描述了，一个很基础的自动机匹配流程，每次计算cutoff值作为权值即可。在大于阈值的权值结点处停止。&lt;br/&gt;匹配的过程中对于一些特殊节点需要特殊标记，这种节点要求权值==阈值，且所有子节点无法继续扩展，也就是所有子节点权值大于阈值。可以看到图中有三个权值为1的结点符合这种要求。&lt;br/&gt;对于这三个节点所对应的字符串，我们需要再次进行编辑距离计算，如果编辑距离恰好符合阈值，则该字符串是符合条件的字符串，也就是可能正确的字符串。&lt;/p&gt;
&lt;h3 id=&quot;参考论文&quot;&gt;参考论文&lt;/h3&gt;
&lt;p&gt;Oflazer K. Error-tolerant finite-state recognition with applications to morphological analysis and spelling correction[J]. Computational Linguistics, 1996, 22(1): 73-89.&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jan 2018 09:31:00 +0000</pubDate>
<dc:creator>震灵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenlingcn/p/8386214.html</dc:identifier>
</item>
<item>
<title>MVVM探索：从ViewModel关闭Window的最佳实践 - Zeek</title>
<link>http://www.cnblogs.com/SilveryBullet/p/8384919.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SilveryBullet/p/8384919.html</guid>
<description>&lt;p&gt;在WPF里使用MVVM开发的时候，似乎总是不可避免的会遇到这样一个问题：ViewModel在处理完业务之后需要关闭这个Window，这时候要怎么处理？&lt;/p&gt;
&lt;p&gt;网上有很多解决方案：有的在ViewModel抛出一个事件，在View端使用（XXXViewModel）this.DataContext的方式去响应事件；有的通过Trigger、Behavior、Action之类的方式曲线救国；还有的使用了其他的第三方框架。&lt;/p&gt;
&lt;p&gt;这些操作从某个层面上来说确实能实现这个功能，但是有的操作起来过于麻烦，有的实现功能了但是大大的违反了MVVM的原则，有的则有很多局限性（比如只能针对关闭了Window之后什么都不做，或者必须要求Window有无参的构造函数）。直到我发现了还可以有这样一种操作之后，我觉得这应该处理这个问题的最佳实践了：优雅，简洁，符合MVVM的思想还没有局限性。&lt;/p&gt;
&lt;p&gt;在MVVM里，View和ViewModel之间通过绑定完成了大部分的操作，这也是MVVM最为推荐的做法。那么，为什么View的关闭这个事情不能通过绑定来实现呢？是因为Window没有控制关闭这个操作的属性么？不，在没有使用MVVM，直接在后台写代码创建了一个Window的时候，我们只需要将这个Window的DialogResult属性赋值（不管是true还是false）就可以将这个窗口关闭。那么我们为什么不直接将Window的DialogResult属性在ViewModel绑定呢？&lt;/p&gt;
&lt;p&gt;秉着这样的思想我去做了这个实验，编译通过，运行的时候得到了这样的异常提示：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;“不能在“ChildWindow”类型的“DialogResult”属性上设置“Binding”。只能在 DependencyObject 的 DependencyProperty 上设置“Binding”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个提示已经很明显了：为什么不能直接对Window的DialogResult做绑定，因为DialogResult这个属性不是依赖属性，WPF里面所有的绑定都必须只能绑定依赖属性，而WPF里绝大部分的属性都是依赖属性，但是DialogResult恰恰不是依赖属性，所以不能绑定。&lt;/p&gt;
&lt;p&gt;此路不通之后就有了上面的各种解决方法，但是为什么不这样想：DialogResult不是依赖属性，那我注册一个依赖属性不就完了么？WPF又不是不让注册。&lt;/p&gt;
&lt;p&gt;注册依赖属性代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DialogCloser
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; DependencyProperty DialogResultProperty =&lt;span&gt;
            DependencyProperty.RegisterAttached(
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DialogResult&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;bool&lt;/span&gt;?&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(DialogCloser),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertyMetadata(DialogResultChanged));

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DialogResultChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; window = d &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Window;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (window != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                window.DialogResult &lt;/span&gt;= e.NewValue &lt;span&gt;as&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;?&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetDialogResult(Window target, &lt;span&gt;bool&lt;/span&gt;?&lt;span&gt; value)
        {
            target.SetValue(DialogResultProperty, value);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在View端绑定这个依赖属性DialogResult：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Window &lt;/span&gt;&lt;span&gt;x:Class&lt;/span&gt;&lt;span&gt;=&quot;mvvm_demo_close_window.ChildWindow&quot;&lt;/span&gt;&lt;span&gt;
        ...
        xmlns:xc&lt;/span&gt;&lt;span&gt;=&quot;clr-namespace:mvvm_demo_close_window&quot;&lt;/span&gt;&lt;span&gt;
        xc:DialogCloser.DialogResult&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding DialogResult}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在ViewModel端将这个当做正常的依赖属性去操作就行了,当this.DialogResult=true的时候就自动在ViewModel关闭了子窗口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ChildWindowViewModel : ViewModelBase
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;?&lt;span&gt; dialogResult;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;?&lt;span&gt; DialogResult
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dialogResult; }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dialogResult =&lt;span&gt; value;
                RaisePropertyChanged(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DialogResult&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来接收关闭按钮的Command&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ICommand CloseCmd
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DelegateCommand((obj) =&amp;gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.DialogResult = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                });
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是我目前发现的最优雅的解决方案，DialogCloser也完全可以复用，如果大家还有更好的方案，欢迎提出来一起讨论。源代码已在下方给出，需要的自行下载。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/SilveryBullet/mvvm_demo_close_window.rar&quot;&gt;点击下载源代码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jan 2018 09:18:00 +0000</pubDate>
<dc:creator>Zeek</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SilveryBullet/p/8384919.html</dc:identifier>
</item>
</channel>
</rss>