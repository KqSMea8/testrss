<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Docker 生态概览 - sparkdev</title>
<link>http://www.cnblogs.com/sparkdev/p/8998546.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sparkdev/p/8998546.html</guid>
<description>&lt;p&gt;&lt;span&gt;Docker 和容器技术的发展可谓是日新月异，本文试图以全局的视角来梳理一下 docker 目前的生态圈。既然是概览，所以不会涉及具体的技术细节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Docker 自从发布以来发生了很多的变化，并且有些方面的变化还非常大。对于技术爱好者来说，我们喜欢酷毙新的功能，喜欢旧功能的改善。但对于生产环境中的使用者来说，其实不太喜欢这种频繁的变化！不管怎样，我们都有必要理清 docker 生态系统中的众多概念及它们之间的关系，以及 docker 自诞生至今(2018 年)的里程碑性事件。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;虽然 docker 把容器技术推向了巅峰，但容器技术却不是从 docker 诞生的。实际上，容器技术连新技术都算不上，因为它的诞生和使用确实有些年头了。下面的一串名称肯能有的你都没有听说过，但它们的确都是容器技术的应用：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Chroot Jail&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;FreeBSD Jails&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Linux VServer&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Solaris Containers&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;OpenVZ&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Process Containers&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;LXC&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Warden&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;LMCTFY&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Docker&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;RKT&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Chroot Jail&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;就是我们常见的 chroot 命令的用法。它在 1979 年的时候就出现了，被认为是最早的容器化技术之一。它可以把一个进程的文件系统隔离起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;The FreeBSD Jail&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;Freebsd Jail 实现了操作系统级别的虚拟化，它是操作系统级别虚拟化技术的先驱之一。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Linux VServer&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;使用添加到 Linux 内核的系统级别的虚拟化功能实现的专用虚拟服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Solaris Containers&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;它也是操作系统级别的虚拟化技术，专为 X86 和 SPARC 系统设计。Solaris 容器是系统资源控制和通过 &quot;区域&quot; 提供边界隔离的组合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;OpenVZ&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;OpenVZ 是一种 Linux 中操作系统级别的虚拟化技术。 它允许创建多个安全隔离的 Linux 容器，即 VPS。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Process Containers&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;Process 容器由 Google 的工程师开发，一般被称为 cgroups。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;LXC&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;LXC 又叫 Linux 容器，这也是一种操作系统级别的虚拟化技术，允许使用单个 Linux 内核在宿主机上运行多个独立的系统。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Warden&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;在最初阶段，Warden 使用 LXC 作为容器运行时。 如今已被 CloudFoundy 取代。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;LMCTFY&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;LMCTY 是 Let me contain that for you 的缩写。它是 Google 的容器技术栈的开源版本。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Google 的工程师一直在与 docker 的 libertainer 团队合作，并将 libertainer 的核心概念进行抽象并移植到此项目中。该项目的进展不明，估计会被 libcontainer 取代。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Docker&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;Docker 是一个可以将应用程序及其依赖打包到几乎可以在任何服务器上运行的容器的工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;RKT&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;RKT 是 Rocket 的缩写，它是一个专注于安全和开放标准的应用程序容器引擎。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正如我们所看到的，docker 并不是第一个容器化技术，但它的确是最知名的一个。Docker 诞生于 2013 年，并获得了快速的发展，下图展示了当前 docker 平台中的组成部分(此图来自互联网)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201805/952033-20180506161404132-2044228888.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;390&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Docker 立于系统基础架构之上并为应用程序提供支撑。它由称为 containerd 的行业标准容器运行时组件，称为 docker swarm 的本地编排工具，以及开源的 docker community 版本和提供商业管理服务的 docker enterprise 版组成。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Docker &amp;amp; LXC&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;Docker 的第一个执行环境是 LXC，但从版本 0.9 开始 LXC 被 libcontainer 取代。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Docker &amp;amp; libcontainer&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;Libcontainer 为 docker 封装了 Linux 提供的基础功能，如 cgroups，namespaces，netlink 和 netfilter 等，如下图所示(此图来自互联网)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201805/952033-20180506161604802-519268400.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;645&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2015 - Docker ＆ runC&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;2015 年，docker 发布了 runC，一个轻量级的跨平台的容器运行时。 这基本上就是一个命令行小工具，可以直接利用 libcontainer 运行容器，而无需通过 docker engine。runC 的目标是使标准容器在任何地方都可用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Docker &amp;amp; The Open Containers Initiative(OCI)&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;OCI 是一个轻量级的开放式管理架构，由 docker，CoreOS 和容器行业的其他领导厂商于 2015 年建立。它维护一些项目，如 runC ，还有容器运行时规范和镜像规范。&lt;/span&gt;&lt;span&gt;OCI 的目的是围绕容器行业制定标准，比如使用 docker 创建的容器可以在任何其他容器引擎上运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2016 - Docker &amp;amp; containerd&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;2016年，Docker 分拆了 containerd，并将其捐赠给了社区。将这个组件分解为一个单独的项目，使得 docker 将容器的管理功能移出 docker 的核心引擎并移入一个单独的守护进程(即 containerd)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Docker Components&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;分拆完 containerd 后，docker 各组件的关系如下图所示(此图来自互联网)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201805/952033-20180506161733019-302685852.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此，docker 从一个单一的软件演变成了一套相互独立的组件和项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Docker 如何运行一个容器？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;Docker 引擎创建容器映像&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将容器映像传递给 containerd&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;containerd 调用 containerd-shim&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;containerd-shim 使用 runC 来运行容器&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;containerd-shim 允许运行时(本例中为 runC)在启动容器后退出&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;该模型带来的最大好处是在升级 docker 引擎时不会中断容器的运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2017 - 容器成为主流&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;2017 年是容器成为主流技术的一年，这就是为什么 docker 在 Linux 之外支持众多平台的原因（Docker for Mac，Docker for Windows，Docker for AWS，GCP 等）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当容器技术被大众接受后，Docker 公司意识到需要新的生产模型，这就是为什么它开始 Moby 项目。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Moby 项目开启了实现协作和生产的新篇章。它是一个开源项目，旨在推进软件的容器化。Moby 项目提供了数十个乐高积木一样的组件以及将它们组装成定制的基于容器的系统的框架。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Docker 生产模型像任何其他常见的单个开源项目一样开始(此图来自互联网)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201805/952033-20180506161953590-1198283921.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;393&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进而将单个项目拆分为不同的开放组件(此图来自互联网)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201805/952033-20180506162030145-1664272291.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;392&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后进化到可以共享这些组件以及组件集合(assembly)的模型(此图来自互联网)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201805/952033-20180506162057003-1056638649.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;393&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终达到能够提供更多关于组件和通用组件集合的协作的模型(此图来自互联网)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201805/952033-20180506162131635-436116215.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;392&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面我们就来介绍一些 Moby 项目中的组件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Containerd&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;Containerd 是 docker 基于行业标准创建的核心容器运行时。它可以用作 Linux 和 Windows 的守护进程，并管理整个容器生命周期。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Linuxkit&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;Linuxkit 是 Moby 项目中的另一个组件，它是为容器构建安全、跨平台、精简系统的工具。目前已经支持的本地 hypervisor 有 hyper-v 和 vmware。支持的云平台有 AWS、Azure 等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Infrakit&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;Infrakit 也是 Moby 项目的一部分。它是创建和管理声明式、不可变和自我修复基础架构的工具包。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Infrakit 旨在自动化基础架构的设置和管理，以支持分布式系统和更高级别的容器编排系统。Infrakit 对于像 Docker Swarm 和 Kubernetes 这样的编排工具或跨越 AWS 等公共云创建自动缩放群集的用例很有用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Libnetwork&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;Libnetwork 是用 Go 语言实现的容器网络管理项目。它的目标是定义一个容器网络模型(CNM)，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;并为应用程序提供一致的编程接口以及网络抽象。这样就可以满足容器网络的 &quot;可组合&quot; 需求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Docker &amp;amp; Docker Swarm&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;Docker Swarm 是一个在 docker 引擎中构建的编排工具。从 docker 1.12 开始它就作为一个独立的工具被原生包含在 docker engine 中。我们可以使用 docker cli 通过 docker swarm 创建群集，并部署和管理应用程序和服务。下图描述了 docker swarm 在 docker 体系中的作用(此图来自互联网)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201805/952033-20180506162317442-1116217226.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;418&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Docker＆Kubernetes&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;在 docker swarm 与 kubernetes 的竞争中，显然是 kubernetes 占据了优势。所以 docker 紧急掉头，开始原生的支持与 kubernetes 的集成。这可是 2017 年容器界的一大新闻啊！至此，docker 用户和开发人员可以自由地选择使用 kubernetes 或是 swarm 执行容器的编排工作。我们可以认为 docker 与 kubernetes 联姻了(此图来自互联网)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201805/952033-20180506162351968-1460613952.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;234&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新的支持 kubernetes 集成的 docker 版本将允许用户把他们的 docker compose 应用程序部署为 kubernetes 本地 pod 和服务。Kubernetes 是一款非常强大且逐渐被大众认可的本地编排工具(此图来自互联网)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201805/952033-20180506162422186-2036947839.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;391&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;希望大家没有被文中众多的名称和概念搞糊涂，让我们以下图来结束本文，它展示了从 2013 年到 2017 年从 docker hub 拉取镜像次数的趋势：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201805/952033-20180506162456326-1601155581.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;412&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://medium.com/devopslinks/an-overall-view-on-docker-ecosystem-containers-moby-swarm-linuxkit-containerd-kubernetes-5e4972a6a1e8&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;An Overall View On Docker Ecosystem — Containers, Moby, Swarm, Linuxkit, containerd, Kubernetes&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 06 May 2018 23:08:00 +0000</pubDate>
<dc:creator>sparkdev</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sparkdev/p/8998546.html</dc:identifier>
</item>
<item>
<title>R实战 第七篇：网格（grid） - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/5042002.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/5042002.html</guid>
<description>&lt;p&gt;grid包是R底层的图形系统，可以绘制几乎所有的图形。除了绘制图形之外，grid包还能对图形进行布局。在绘图时，有时候会遇到这样一种情景，客户想把多个代表不同KPI的图形分布到同一个画布(Page)上，而且每一个图形都是单独绘制的。对于这种需求，可以使用grid包来实现，grid包能把图形逐个地添加到画布中，并按照业务的需求，把图形摆放到合适的位置上去。在布局完成之后，把图形绘制出来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一，grid包概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;grid包不仅可以输出图形，还可以产生可编辑的图形组件，这些图形组件可以被复用和重组，并能把图形输出到指定的位置上。在使用grid包之前，需要安装和载入grid包：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
install.packages(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
library(grid)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;1，绘图原语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常用的绘图原语的明明格式是grid.**，用于输出图形：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;grid.rect(...)   
grid.lines(...)  
grid.polygon(...)
grid.circle(...)
grid.text(...)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用户可以通过参数修改绘图函数输出的图形：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
grid.rect(x = unit(&lt;span&gt;0&lt;/span&gt;, “native&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;), y = unit(1.5, “npc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), height = unit(&lt;span&gt;0.5&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inches&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), width = unit(&lt;span&gt;0.8&lt;/span&gt;&lt;span&gt;, “lines”),
    gp&lt;/span&gt;=gpar(col=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, lwd=&lt;span&gt;2&lt;/span&gt;, fill=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yellow&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, lty=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dotted&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2，Grob对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每一个绘图原语都对应一个Grob，grob的命名格式是**Grob，Grob对象是一个可编辑的图形组件，该组件保留图形的所有属性，但不会立即输出图形：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;rectGrob(...)
linesGrob(...)
polygonGrob(...)
circleGrob(...)
textGrob(..)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要输出Grob表示的图形，可以使用grid.draw()函数绘制图形：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rect &amp;lt;-&lt;span&gt; rectGrob(...) 
grid.draw(rect)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;二，&lt;/strong&gt;&lt;strong&gt;核心对象viewport&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;绘制图形需要画布，是R的绘图设备，在grid包中，画布被定义为page，通过函数newpage()创建一个新的画布：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
grid.newpage()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;viewport是grid包的核心对象，简单来说，它就是画布中的一个矩形的绘图区域，直译为视口，通过viewport()函数新建一个viewport对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
viewport(x = unit(&lt;span&gt;0.5&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;npc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), y = unit(&lt;span&gt;0.5&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;npc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
         width &lt;/span&gt;= unit(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;npc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), height = unit(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;npc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
         &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;.units = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;npc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, just = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;centre&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
         gp &lt;/span&gt;= gpar(), clip = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inherit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
         xscale &lt;/span&gt;= c(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;), yscale = c(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;),
         angle &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
         layout &lt;/span&gt;=&lt;span&gt; NULL, 
         layout.pos.row &lt;/span&gt;= NULL, layout.pos.col =&lt;span&gt; NULL,
         name &lt;/span&gt;= NULL)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;x&lt;/strong&gt;：视口的几何中心点相对页面左下角原点的x坐标轴，默认单位是npc&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;y&lt;/strong&gt;：视口的几何中心点相对页面左下角原点的y坐标轴，默认单位是npc&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;width&lt;/strong&gt;：视口的宽度（x轴方向）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;height&lt;/strong&gt;：视口的高度（y轴方向）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;default.units&lt;/strong&gt;：默认单位为npc (Normalised Parent Coordinates)，含义是规范化化的父区域坐标&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;just&lt;/strong&gt;：x和y所指的位置，默认为矩形中心位置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gp&lt;/strong&gt;：gpar对象，用于设置图形参数；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;clip&lt;/strong&gt;：裁剪区域，有效值是“on”，“inherit”或“off”，指示剪裁到视口范围内，从父视口继承剪裁区域，或者完全关闭剪裁。 为了后向兼容性，逻辑值TRUE对应于“on”，而FALSE对应于“inherit”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;xscale，yscale&lt;/strong&gt;：两个数值元素的向量，用于表示坐标轴的最小值和最大值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;angle&lt;/strong&gt;：把视口逆时针旋转的角度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;layout&lt;/strong&gt;：布局（&lt;strong&gt;grid.layout&lt;/strong&gt;）对象，用于把视口划分为多个子区域&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;layout.pos.row，layout.pos.col&lt;/strong&gt;：子区域在父布局中的行位置和列位置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;name&lt;/strong&gt;：此视口的名字，用于搜索和定位&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;viewport是绘图的基础，创建一个viewport：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
vp &amp;lt;- viewport(x = &lt;span&gt;0.5&lt;/span&gt;, y = &lt;span&gt;0.5&lt;/span&gt;, width = &lt;span&gt;0.5&lt;/span&gt;, height = &lt;span&gt;0.25&lt;/span&gt;, angle=&lt;span&gt;45&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过函数grid.show.viewport()查看创建的视口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
grid.show.viewport(viewport(x=&lt;span&gt;0.6&lt;/span&gt;, y=&lt;span&gt;0.6&lt;/span&gt;, width=unit(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inches&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), height=unit(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inches&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), angle=&lt;span&gt;30&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;height和width是矩形的长和宽，x和y是视口中心点（也就是，矩形的几何中心点）距离x坐标抽和y坐标轴的距离：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/628084/201805/628084-20180506151222887-1121357571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三，基于viewport绘制图形&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用grid包绘图时，首先要创建一个空的画布：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
grid.newpage()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在画布中创建viewport对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
vp &amp;lt;- viewport(x = &lt;span&gt;0.5&lt;/span&gt;, y = &lt;span&gt;0.5&lt;/span&gt;, width = &lt;span&gt;0.5&lt;/span&gt;, height = &lt;span&gt;0.25&lt;/span&gt;, angle=&lt;span&gt;45&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，画布中是空的，需要把viewport推到画布中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pushViewport(vp)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;viewport是绘图的区域，也就是说，基于viewport绘制图形，在视口规定的范围内作图，例如，向视口中绘制矩形。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
grid.rect()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/628084/201805/628084-20180506152304947-2024402997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四，viewport树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;grid包为每一个画布维护了一个由viewport构成的树，树的根节点是由系统创建的，名字是ROOT的viewport，每一个节点都是一个viewport。活跃viewport是树的当前位置，在树中是唯一的，用户只能向活跃viewport中绘图，所有的操作都是基于活跃viewport。viewport()函数用于创建viewport，而一个viewport只有被push到viewport树中，才能在其区域中绘图。&lt;/p&gt;
&lt;p&gt;通过5个函数实现对viewport树的遍历和更新：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;pushViewport()函数&lt;/strong&gt;：向活跃viewport中添加一个viewport，作为树中的活跃viewport，原活跃viewport变成父viewport，这意味着，当一个viewport被push到树中时，该viewport变成活跃viewport，是原活跃viewport的子viewport。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;popViewport()函数&lt;/strong&gt;：把活跃viewport从树中删除，其父viewport变成活跃viewport。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;upViewport()函数&lt;/strong&gt;：导航到活跃viewport的父viewport，当前viewport变成活跃viewport，原viewport不会被删除；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;downViewport()函数&lt;/strong&gt;：导航到活跃viewport的父viewport，当前viewport变成活跃viewport，原viewport不会被删除；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;searchViewport()函数&lt;/strong&gt;：根据viewport的名字，导航到任意viewport，当前viewport变成活跃viewport，原viewport不会被删除。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：当向树中push一个viewport时，如果树中存在一个级别（level）相同，名字相同的viewport，那么push操作会把该viewport替换掉。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;There is only ever one current viewport, which is the current position within the viewport tree. All drawing and viewport operations are relative to the current viewport. When a viewport is pushed it becomes the current viewport. When a viewport is popped, the parent viewport becomes the current viewport. Use upViewport to navigate to the parent of the current viewport, without removing the current viewport from the viewport tree. Use downViewport to navigate to a viewport further down the viewport tree and seekViewport to navigate to a viewport anywhere else in the tree.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查看当前的viewport树结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
current.vpTree()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如，下面我们连续push三个viewport到一个图形中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;grid.newpage()
colvec &lt;/span&gt;&amp;lt;- c(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
xvec &lt;/span&gt;&amp;lt;- c(&lt;span&gt;0.3&lt;/span&gt;, &lt;span&gt;0.4&lt;/span&gt;, &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; : &lt;span&gt;3&lt;/span&gt;&lt;span&gt;) {
  vp &lt;/span&gt;&amp;lt;- viewport(x = xvec[i], y = &lt;span&gt;0.5&lt;/span&gt;, width = &lt;span&gt;0.4&lt;/span&gt;, height = &lt;span&gt;0.4&lt;/span&gt;&lt;span&gt;,
                 gp &lt;/span&gt;= gpar(col =&lt;span&gt; colvec[i]))
  pushViewport(vp)
  grid.rect()
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;绘制的图形依次嵌套，这说明，每push一次，原活跃viewport都变成父节点，把当前的veiwport作为子viewport：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/628084/201805/628084-20180506161743732-938999514.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五，布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;grid包中定义了布局对象，布局是矩形的子分区，也就是说，布局（layout）把一个矩形区域细分为更小的分区。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
grid.layout(nrow = &lt;span&gt;1&lt;/span&gt;, ncol = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
    widths &lt;/span&gt;= unit(rep_len(&lt;span&gt;1&lt;/span&gt;, ncol), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;), heights &lt;/span&gt;= unit(rep_len(&lt;span&gt;1&lt;/span&gt;, nrow), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;    default&lt;/span&gt;.units = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, respect =&lt;span&gt; FALSE, just&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;centre&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;nrow,ncol&lt;/strong&gt;：布局分为多少个行和列，每一个行和列构成的单元叫做分区（subdivision）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;widths，heights&lt;/strong&gt;：每一个分区的宽和高&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;default.units&lt;/strong&gt;：默认单位&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;respect&lt;/strong&gt;：逻辑值，如果为true，指定行高度和列宽度都遵守。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;just&lt;/strong&gt;：指定对齐方式，有效的值是：&quot;left&quot;, &quot;right&quot;, &quot;centre&quot;, &quot;center&quot;, &quot;bottom&quot;, 和 &quot;top&quot;.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1，创建布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把top.vp视口分割为3X3的分区，使用函数grid.show.layout()查看布局，创建的布局如下图所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
layout &amp;lt;- grid.layout(nrow=&lt;span&gt;3&lt;/span&gt;, ncol=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
                   widths&lt;/span&gt;=unit(c(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;), c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lines&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lines&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)),
                   heights&lt;/span&gt;=unit(c(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;), c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lines&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lines&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)))

top.vp &lt;/span&gt;&amp;lt;-viewport(layout=layout, name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;top&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

grid.show.layout(layout)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/628084/201805/628084-20180506165827059-1572754940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 创建一系列的viewport，占用布局的各个分区，由于没有push任何viewport，因此画布中没有绘制任何图形。在为每个视口命名时，使用统一的格式：margin+数值，如下代码所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
margin1 &amp;lt;- viewport(layout.pos.col = &lt;span&gt;2&lt;/span&gt;, layout.pos.row = &lt;span&gt;3&lt;/span&gt;, name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;margin1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) #(3,2)
margin2 &lt;/span&gt;&amp;lt;- viewport(layout.pos.col = &lt;span&gt;1&lt;/span&gt;, layout.pos.row = &lt;span&gt;2&lt;/span&gt;, name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;margin2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) #(2,1)
margin3 &lt;/span&gt;&amp;lt;- viewport(layout.pos.col = &lt;span&gt;2&lt;/span&gt;, layout.pos.row = &lt;span&gt;1&lt;/span&gt;, name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;margin3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) #(1,2)
margin4 &lt;/span&gt;&amp;lt;- viewport(layout.pos.col = &lt;span&gt;3&lt;/span&gt;, layout.pos.row = &lt;span&gt;2&lt;/span&gt;, name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;margin4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) #(2,3)
plot &lt;/span&gt;&amp;lt;- viewport(layout.pos.col = &lt;span&gt;2&lt;/span&gt;, layout.pos.row = &lt;span&gt;2&lt;/span&gt;, name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)       #(2,2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;R用数字来表示位置，数值代表的含义是：1=Buttom，2=Left，3=Top，4=Right，视口被布局分割的分区如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/628084/201805/628084-20180506180459093-1814039748.png&quot; alt=&quot;&quot; width=&quot;266&quot; height=&quot;256&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2，创建viewport树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用vpList()把视口排列成一个树形结构，并把top.vp作为视图的父节点，把所有其他视口作为子节点，使用vpTree()创建一个viewport树：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 splot &amp;lt;- vpTree(top.vp, vpList(margin1, margin2, margin3, margin4, plot))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把整个viewport树push到活跃视口中，这样，在绘图区域中，我们可以在不同的散点视口中绘制图形。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
 pushViewport(splot)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在把整个树push到活跃视口之后，就可以在不同的区域内绘制图形，使用seekViewport()函数按照视口名称切换到指定的视口，并把当前视口激活。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
seekViewport(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
grid.xaxis()
grid.yaxis()
grid.rect()
grid.points(x, y)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9d21fd26-9c3d-471b-b102-711321e30230')&quot; readability=&quot;51.5&quot;&gt;&lt;img id=&quot;code_img_closed_9d21fd26-9c3d-471b-b102-711321e30230&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9d21fd26-9c3d-471b-b102-711321e30230&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9d21fd26-9c3d-471b-b102-711321e30230',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9d21fd26-9c3d-471b-b102-711321e30230&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;98&quot;&gt;
&lt;pre&gt;
&lt;span&gt;library(grid)

layout &lt;/span&gt;&amp;lt;- grid.layout(nrow=&lt;span&gt;3&lt;/span&gt;, ncol=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
                      widths&lt;/span&gt;=unit(c(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;), c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lines&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lines&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)),
                      heights&lt;/span&gt;=unit(c(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;), c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lines&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lines&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)))
#grid.show.layout(layout)

top.vp &lt;/span&gt;&amp;lt;-viewport(layout=layout,name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;top&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
#grid.show.viewport(top.vp)

x &lt;/span&gt;&amp;lt;- runif(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
y &lt;/span&gt;&amp;lt;- runif(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
xscale &lt;/span&gt;&amp;lt;-&lt;span&gt; extendrange(x)
yscale &lt;/span&gt;&amp;lt;-&lt;span&gt; extendrange(y)

margin1 &lt;/span&gt;&amp;lt;- viewport(layout.pos.col = &lt;span&gt;2&lt;/span&gt;, layout.pos.row = &lt;span&gt;3&lt;/span&gt;, name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;margin1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
margin2 &lt;/span&gt;&amp;lt;- viewport(layout.pos.col = &lt;span&gt;1&lt;/span&gt;, layout.pos.row = &lt;span&gt;2&lt;/span&gt;, name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;margin2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
margin3 &lt;/span&gt;&amp;lt;- viewport(layout.pos.col = &lt;span&gt;2&lt;/span&gt;, layout.pos.row = &lt;span&gt;1&lt;/span&gt;, name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;margin3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
margin4 &lt;/span&gt;&amp;lt;- viewport(layout.pos.col = &lt;span&gt;3&lt;/span&gt;, layout.pos.row = &lt;span&gt;2&lt;/span&gt;, name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;margin4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plot &lt;/span&gt;&amp;lt;- viewport(layout.pos.col = &lt;span&gt;2&lt;/span&gt;, layout.pos.row = &lt;span&gt;2&lt;/span&gt;, name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,xscale = xscale, yscale =&lt;span&gt; yscale)

splot &lt;/span&gt;&amp;lt;-&lt;span&gt; vpTree(top.vp, vpList(margin1, margin2, margin3, margin4, plot))
#grid.show.viewport(splot)

pushViewport(splot)

seekViewport(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
grid.xaxis()
grid.yaxis()
grid.rect()
grid.points(x, y,pch&lt;/span&gt;=&lt;span&gt;20&lt;/span&gt;&lt;span&gt;)

seekViewport(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;margin1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
grid.text(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Random X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, y = unit(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lines&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

seekViewport(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;margin2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
grid.text(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Random Y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, x = unit(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lines&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), rot = &lt;span&gt;90&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3，把图形逐个打印到视口中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用布局在同一个画布中绘制多个图形的另外一种方法是使用print()函数，代码摘抄于《&lt;a href=&quot;https://segmentfault.com/a/1190000007955532&quot; target=&quot;_blank&quot;&gt;R统计绘图（2）：grid布局&lt;/a&gt;》。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step1，创建多个图形&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;library(grid)
library(ggplot2)
# prepare ggplot charts
p.hist.len &lt;/span&gt;&amp;lt;- ggplot(iris) + geom_histogram(aes(x=&lt;span&gt;Sepal.Length))
p.hist.wid &lt;/span&gt;&amp;lt;- ggplot(iris) + geom_histogram(aes(x=Sepal.Width)) +&lt;span&gt; coord_flip()
p.scatter &lt;/span&gt;&amp;lt;- ggplot(iris) + geom_point(aes(x=Sepal.Length, y=Sepal.Width))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;step2，创建布局，分割视口，并push当前视口&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;grid.newpage()
pushViewport(viewport(layout &lt;/span&gt;= grid.layout(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;step3，把图形输出到布局的不同区域中&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
print(p.scatter, vp=viewport(layout.pos.row=&lt;span&gt;2&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;, layout.pos.col=&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;))
print(p.hist.len, vp&lt;/span&gt;=viewport(layout.pos.row=&lt;span&gt;1&lt;/span&gt;, layout.pos.col=&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;))
print(p.hist.wid, vp&lt;/span&gt;=viewport(layout.pos.row=&lt;span&gt;2&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;, layout.pos.col=&lt;span&gt;3&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;六，unit对象和gpar对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在grid包中，unit对象用于表示：长度和单位，gpar对象用于设置：图形参数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，unit对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用unit对象表示长度的大小和单位：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
unit(x, units, data=NULL)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;x：数值向量&lt;/li&gt;
&lt;li&gt;units：单位向量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2，gpar对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用gapr对象表示图形参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;col&lt;/strong&gt;: Colour for lines and borders.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fill&lt;/strong&gt;: Colour for filling rectangles, polygons, ...&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;alpha&lt;/strong&gt;: Alpha channel for transparency&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lty&lt;/strong&gt;: Line type&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lwd&lt;/strong&gt;: Line width&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lex&lt;/strong&gt;: Multiplier applied to line width&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lineend&lt;/strong&gt;: Line end style (round, butt, square)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;linejoin&lt;/strong&gt;: Line join style (round, mitre, bevel)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;linemitre&lt;/strong&gt;: Line mitre limit (number greater than 1)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fontsize&lt;/strong&gt;: The size of text (in points)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cex&lt;/strong&gt;: Multiplier applied to fontsize&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fontfamily&lt;/strong&gt;: The font family&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fontface&lt;/strong&gt;: The font face (bold, italic, ...)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lineheight&lt;/strong&gt;: The height of a line as a multiple of the size of text&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;font&lt;/strong&gt;: Font face (alias for fontface; for backward compatibility)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stat.ethz.ch/R-manual/R-patched/library/grid/doc/viewports.pdf&quot; target=&quot;_blank&quot;&gt;Working with grid Viewports&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.rdocumentation.org/packages/grid/versions/3.5.0&quot; target=&quot;_blank&quot;&gt;R Document: grid&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000007955532&quot; target=&quot;_blank&quot;&gt;R统计绘图（2）：grid布局&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/vivihe0/article/details/47188329&quot; target=&quot;_blank&quot;&gt;R语言grid包使用笔记——viewport&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stat.ethz.ch/R-manual/R-patched/library/grid/html/00Index.html&quot; target=&quot;_blank&quot;&gt;The Grid Graphics Package&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 06 May 2018 23:05:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljhdo/p/5042002.html</dc:identifier>
</item>
<item>
<title>chart 目录结构 - 每天5分钟玩转 Docker 容器技术（164） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8997225.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8997225.html</guid>
<description>&lt;p&gt;&lt;span&gt;chart 是 Helm 的应用打包格式。chart 由一系列文件组成，这些文件描述了 Kubernetes 部署应用时所需要的资源，比如 Service、Deployment、PersistentVolumeClaim、Secret、ConfigMap 等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单个的 chart 可以非常简单，只用于部署一个服务，比如 Memcached；chart 也可以很复杂，部署整个应用，比如包含 HTTP Servers、 Database、消息中间件、cache 等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;chart 将这些文件放置在预定义的目录结构中，通常整个 chart 被打成 tar 包，而且标注上版本信息，便于 Helm 部署。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面我们将详细讨论 chart 的目录结构以及包含的各类文件。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;chart 目录结构&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;以前面 MySQL chart 为例。一旦安装了某个 chart，我们就可以在 ~/.helm/cache/archive 中找到 chart 的 tar 包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180506074314016-513669487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解压后，MySQL chart 目录结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180506074324033-1748204722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;目录名就是 chart 的名字（不带版本信息），这里是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，包含如下内容：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Chart.yaml&lt;/span&gt;&lt;span&gt; &lt;br/&gt;YAML 文件，描述 chart 的概要信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180506074333630-1263572057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;name&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;version&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是必填项，其他都是可选。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;README.md&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; &lt;br/&gt;Markdown 格式的 README 文件，相当于 chart 的使用文档，此文件为可选。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180506074348602-92346043.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;LICENSE&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; &lt;br/&gt;文本文件，描述 chart 的许可信息，此文件为可选。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;requirements.yaml&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;br/&gt;chart 可能依赖其他的 chart，这些依赖关系可通过 requirements.yaml 指定，比如：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180506074403040-1139547443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在安装过程中，依赖的 chart 也会被一起安装。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;values.yaml&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;br/&gt;chart 支持在安装的时根据参数进行定制化配置，而 values.yaml 则提供了这些配置参数的默认值。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180506074411864-1600196288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;templates 目录&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;br/&gt;各类 Kubernetes 资源的配置模板都放置在这里。Helm 会将 values.yaml 中的参数值注入到模板中生成标准的 YAML 配置文件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模板是 chart 最重要的部分，也是 Helm 最强大的地方。模板增加了应用部署的灵活性，能够适用不同的环境，我们后面会详细讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;templates/NOTES.txt&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;br/&gt;chart 的简易使用文档，chart 安装成功后会显示此文档内容。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180506074422631-1646027115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与模板一样，可以在 NOTE.txt 中插入配置参数，Helm 会动态注入参数值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下一节我们详细讨论 chart 模板的用法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;书籍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.《每天5分钟玩转Kubernetes》&lt;br/&gt;&lt;a href=&quot;https://item.jd.com/26225745440.html&quot;&gt;https://item.jd.com/26225745440.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.《每天5分钟玩转Docker容器技术》&lt;br/&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 06 May 2018 22:23:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8997225.html</dc:identifier>
</item>
<item>
<title>排序算法的C语言实现(下 线性时间排序：计数排序与基数排序) - IDreamo</title>
<link>http://www.cnblogs.com/idreamo/p/8978469.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/idreamo/p/8978469.html</guid>
<description>&lt;h3&gt;计数排序&lt;/h3&gt;
&lt;p&gt;计数排序是一种&lt;strong&gt;高效的线性排序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;它&lt;strong&gt;通过计算一个集合中元素出现的次数&lt;/strong&gt;来确定集合如何排序。不同于插入排序、快速排序等基于元素比较的排序，计数排序是不需要进行元素比较的，而且它的运行效率要比效率为O（nlgn）的比较排序高。&lt;/p&gt;
&lt;p&gt;计数排序有一定的局限性，其中&lt;strong&gt;最大的局限就是它只能用于整型或那么可以用整型来表示的数据集合&lt;/strong&gt;。原因是&lt;strong&gt;计数排序利用一个数据的索引来记录元素出现的次数，而这个数组的索引就是元素的数值&lt;/strong&gt;。例如，如果整数3出现过4次，那么4将存储到数组索引为3的位置上。同时，我们还需要知道集合中最大整数的值，以便于为数组分配足够的空间。&lt;/p&gt;
&lt;p&gt;除了速度之外，&lt;strong&gt;计数排序的另一个优点就是非常稳定&lt;/strong&gt;。&lt;strong&gt;稳定的排序能使具有相同数值的元素具有相同的顺序，就像它们在原始集合中表现出来的一样&lt;/strong&gt;。在某些情况下这是一个重要的特性，可以在基数排序中看到这一点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 计数排序的接口定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ctsort&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;int ctsort(int *data, int size, int k);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：如果排序成功，返回0；否则，返回-1；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：   利用计数排序将数组data中的整数进行排序。data中的元素个数由size决定。参数k为data中最大的整数加1。当ctsort返回时，data中包含已经排序的元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O（n+k），n为要排序的元素个数，k为data中最大的整数加1。&lt;/p&gt;
&lt;h4&gt;计数排序的实现与分析&lt;/h4&gt;
&lt;p&gt;计数排序&lt;strong&gt;本质上是通过计算无序集合中整数出现的次数来决定集合应该如何排序的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在以下说明的实现方法中，data初始包含size个无序整型元素，并存放在单块连续的存储空间中。另外需要分配存储空间来临时存放已经排序的元素。在ctsort返回时，得到的有序集合将拷贝加data。&lt;/p&gt;
&lt;p&gt;分配了存储空间以后，首先计算data中每个元素出现的次数。这些结果将存储到计数数组counts中，并且数组的索引值就是元素本身。一旦data中每个元素的出现次数都统计出来后，就要调整计数值，使元素在进入有序集合之前，清楚每个元素插入的次数。用元素本身的次数加上它前一个元素的次数。&lt;strong&gt;事实上，此时counts包含每个元素在有序集合temp中的偏移量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1281268/201805/1281268-20180504062456734-200073757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要完成排序，还必须按照元素在temp中的偏移量放置元素。当temp更新时，每个元素的计数要减1，这样，在data中出现不止一次的元素在temp中也会出现不止一次，这样保持同步。&lt;/p&gt;
&lt;p&gt;计数排序的时间复杂度为O（n+k），其中n为要排序的元素个数，k为data中最大的整数加1。这是由于计数排序包含三个循环，其中两个的运行时间正比于n，另一个的运行时间正比于k。对于空间上来说，计数排序需要两个大小为n的数组，一个大小为k的数组。&lt;/p&gt;
&lt;h4&gt;示例：计数排序的实现&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;ctsort.c&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sort.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;ctsort  计数排序函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; ctsort(&lt;span&gt;int&lt;/span&gt; *data, &lt;span&gt;int&lt;/span&gt; size, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; k)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *&lt;span&gt;counts,
        &lt;/span&gt;*&lt;span&gt;temp;
        
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j;
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;为计数器数组分配空间&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;((counts = (&lt;span&gt;int&lt;/span&gt; *)&lt;span&gt;malloc&lt;/span&gt;(k * &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;))) ==&lt;span&gt; NULL)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;为已排序元素临时存放数组分配空间&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;((temp = (&lt;span&gt;int&lt;/span&gt; *)&lt;span&gt;malloc&lt;/span&gt;(size * &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;))) ==&lt;span&gt; NULL)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;初始化计数数组&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; k; i++&lt;span&gt;)
    {
        counts[i] &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;        
    }
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;统计每个元素出现的次数（counts的下标索引即是要统计的元素本身）&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;0&lt;/span&gt;; j&amp;lt;size; j++&lt;span&gt;)
        counts[data[j]]&lt;/span&gt;=counts[data[j]] + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将元素本身的次数加上它前一个元素的次数(得到元素偏移量)&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; k; i++&lt;span&gt;)
        counts[i]&lt;/span&gt;=counts[i] + counts[i-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;关键代码：使用上面得到的计数数组去放置每个元素要排序的位置&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(j = size -&lt;span&gt;1&lt;/span&gt;; j &amp;gt;= &lt;span&gt;0&lt;/span&gt;; j--&lt;span&gt;)
    {
        temp[counts[data[j]]&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;] = data[j];      &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;counts的值是元素要放置到temp中的偏移量&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        counts[data[j]] &lt;/span&gt;= counts[data[j]] - &lt;span&gt;1&lt;/span&gt;;  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;counts的计数减1&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    }
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将ctsort已排序的元素从temp拷贝回data&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    memcpy(data,temp,size &lt;/span&gt;* &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;));
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;释放前面分配的空间&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(counts);
    &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(temp);
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;基数排序&lt;/h3&gt;
&lt;p&gt;基数排序是另外一种&lt;strong&gt;高效的线性排序算法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其方法是&lt;strong&gt;将数据按位分开，并从数据的最低有效位到最高有效位进行比较，依次排序，从而得到有序数据集合&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们来看一个例子，用基数排序对十进制数据{15，12，49，16，36，40}进行排序。在对个位进行排序之后，其结果为{40，12，15，16，36，49}，在对十位进行排序之后，其结果为{12，15，16，36，40，49}。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有一点非常重要，在对每一位进行排序时其排序过程必须是稳定的&lt;/strong&gt;。&lt;strong&gt;一旦一个数值通过较低有效位的值进行排序之后，此数据的位置不应该改变，除非通过较高有效位的值进行比较后需要调整它的位置&lt;/strong&gt;。例如，在上述的例子中，12和15的十位都是1，当对其十位进行排序时，一个不稳定的排序算法可能不会维持其在个数排序过程中的顺序。而一个稳定的排序算法可以保证它们不重新排序。&lt;strong&gt;基数排序会用到计数排序，对于基数排序来说，除了稳定性，它还是一种线性算法，且必须知道每一位可能的最大整数值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基数排序并不局限于对整数进行排序，只要能把元素分割成整型数，就可以使用基数排序&lt;/strong&gt;。例如，可以对一个以2&lt;sup&gt;8&lt;/sup&gt;为基数字符串进行基数排序；或者，可以对一个64位的整数，按4位以2&lt;sup&gt;16&lt;/sup&gt;为基数的值进行排序。具体该选择什么值作为基数取决于数据本身，同时考虑到空间的限制，需要将pn+pk最小化。（其中p为每个元素的位数，n为元素的个数，k为基数）。一般情况下，通常使k小于等于n。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;基数排序的接口定义&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;rxsort&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;int rxsort(int *data, int size, int p, int k);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：如果排序成功，返回0；否则返回-1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：利用计数排序将数组data中的整数进行排序。数组data中整数的个数由size决定。参数p指定每个整数包含的位数，k指定基数。当rxsort返回时，data包含已经排序的整数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O（pn+pk），n为要排序的元素个数，k为基数，p为位的个数。&lt;/p&gt;
&lt;h4&gt;基数排序的实现与分析&lt;/h4&gt;
&lt;p&gt;基数排序实质上是在元素每一位上应用计数排序来对数据集合排序。在以下介绍的实现方法中，data初始包含size个无序整型元素，并存放在单块连续的存储空间中。当rxsort返回时，data中的数据集完全有序。&lt;/p&gt;
&lt;p&gt;如果我们理解了计数排序的方法，那么基数排序也就非常简单了。单个循环控制正在进行排序的位置。从最低位开始一个位置一个位置地应用计数排序来不断调整元素。一旦调整完了最高有效位的数值，排序过程就完成了。&lt;/p&gt;
&lt;p&gt;获取每位数值的简单方法就是使用幂运算和模运算。这对整数来说特别有效，但不同的数据类型需要使用不同的方法。有一些方法可能需要考虑机器具体细节，例如字节顺序和字对齐等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1281268/201805/1281268-20180507060949104-1326842403.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;毫无疑问，基数排序的时间复杂度取决于它选择哪种稳定排序来对数值进行排序。由于基数排序对每个p位置的位数值使用计数排序，因此基数排序消耗的运行时间是计数排序的p倍，即O（pn+pk）。其对空间的要求与计数排序一样：两个大小为n的数组，一个大小为k的数组。&lt;/p&gt;
&lt;h4&gt;示例：基数排序的实现&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;rxsort.c&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;limits.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;math.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sort.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;rxsort&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; rxsort(&lt;span&gt;int&lt;/span&gt; *data, &lt;span&gt;int&lt;/span&gt; size, &lt;span&gt;int&lt;/span&gt; p, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; k)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *counts, *&lt;span&gt;temp;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, pval, i, j, n;
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;为计数器数组分配空间&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;((counts = (&lt;span&gt;int&lt;/span&gt; *)&lt;span&gt;malloc&lt;/span&gt;(k * &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;))) ==&lt;span&gt; NULL)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;为已排序元素集分配空间&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;((temp = (&lt;span&gt;int&lt;/span&gt; *)&lt;span&gt;malloc&lt;/span&gt;(size * &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;))) ==&lt;span&gt; NULL)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;从元素的最低位到最高位开始排序&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(n=&lt;span&gt;0&lt;/span&gt;; n&amp;lt;p; n++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;初始化计数器&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;k; i++&lt;span&gt;)
            count[i] &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;计算位置值（幂运算k的n次方）&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        pval &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;)pow((&lt;span&gt;double&lt;/span&gt;)k,(&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)n);
        
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;统计当前位上每个数值出现的次数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;0&lt;/span&gt;; j&amp;lt;size; j++&lt;span&gt;)
        {
            index &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;)(data[j] / pval) %&lt;span&gt; k;
            counts[index] &lt;/span&gt;= counts[index]+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;计算偏移量（本身的次数加上前一个元素次数）&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;1&lt;/span&gt;; i&amp;lt;k; i++&lt;span&gt;)
            counts[i] &lt;/span&gt;= counts[i] + counts[i-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;使用计数器放置元素位置&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(j=size-&lt;span&gt;1&lt;/span&gt;; j&amp;gt;=&lt;span&gt;0&lt;/span&gt;; j--&lt;span&gt;)
        {
            index &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;)(data[j] / pval) %&lt;span&gt; k;
            temp[counts[index]&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; data[j];
            counts[index] &lt;/span&gt;= counts[index] - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
        
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将已排序元素拷贝回data&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        memcpy(data, temp, size&lt;/span&gt;*&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;));
        
    }
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;释放已排序空间&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(counts);
    &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(temp);
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 06 May 2018 21:57:00 +0000</pubDate>
<dc:creator>IDreamo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/idreamo/p/8978469.html</dc:identifier>
</item>
<item>
<title>我们为什么要学习？写给我的组员们 - 喜欢天黑却怕鬼</title>
<link>http://www.cnblogs.com/songwenjie/p/9000713.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songwenjie/p/9000713.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://files.cnblogs.com/files/songwenjie/%E8%B7%91%E9%81%93.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;半个月之前，和大学篮球队的兄弟们约定一起回一次母校。大家毕业之后各奔东西，天南海北，想要再聚一次真的很不容易。昨天终于实现了。看着曾经并肩作战了四年的兄弟们，心中思绪万千，努力回忆着大学里的那些人和事。晚上和大家伙吃了饭道别已经快0点了，打车回高新。雨后的空气格外清新，景色也别有一番风味。我借着酒劲打开车窗望向窗外，夜风迎面而来。脑子里突然冒出一句话：我现在其实不太愿意回来，因为感觉毕业之后物是人非，回来也不知道能干嘛，这里没有了你们也没有了她（女朋友）。这是我到母校之后和伦伦（好兄弟）说的，一下子警醒了我，我毕业的这一年好像失去了很多东西。很久没有好好打过球了（因为没有人一起打），很久没有好好陪女朋友了（因为时间都分给了技术）。我反思毕业这一年我到底得到了啥？想了想可能只有自己技术上的提升、思想上的改变和影响了你们。相对于前两者我觉得影响了你们这件事给我带来的成就感最大。有些话可能当面讲不出来，所以有了这篇文章。&lt;/p&gt;
&lt;p&gt;首先我要向你们道个歉，因为我工作到现在满打满算1年8个月，负责小组10个月。我在管理经验上缺失有所欠缺，这个我也在努力学习，但是这一点我觉得是可以通过别的方式来弥补的。不知道你们还能不能记得，我跟你们说过的。我做研发小组长有两个目标：第一是负责的项目一定要努力做好，这个是责任。第二是小组内的每个人能力都要有提升，这个是义务。走到现在第一点虽然没有出现什么问题，但是我们的项目还是有很多需要优化的地方，很大的提升空间。第二点我觉得你们每个人能力上都有提升，这些能力不只是技术能力，还有沟通表达能力、思考能力、解决问题的能力等等。对于飞、财、悦你们三个人，我觉得你们的提升最大，甚至可以说给了我惊喜。您们的进步我看在眼里，公司其他同事更看在眼里。他们向我夸你们的时候，我比你们还要高兴。对于其他人也是一样。&lt;/p&gt;
&lt;p&gt;这里还需要跟你们道个歉，因为你们每个人应该都挨过我的熊，可能因为各个方面。都说控制不住情绪是情商不高的表现，我情商的确不高。但是我觉得在一些事情上我必须表明我的态度。比如说你们在项目中遇到的问题，第一次第二次问我，我都会告诉你，帮助你解决，当然我只会告诉你们解决的思路，因为在你们成长的过程中不能太过于依赖任何一个人。同一个问题问我第三次，我是绝对不会告诉你的，等待你的也只能是一顿熊，这个你们都知道的。玉的这个问题已经基本没有了，焕征也在慢慢改正。我觉得你们对于这个问题也是印象深刻的。再比如，我这个人对于代码比较有追求，基本上不会容忍新开发的烂代码出现在项目中，当然也领着你们对旧的烂代码做过重构。我对你们的代码审查大多数是在代码规范，实现思路和可能隐藏的bug层面上的。你们中的一些人可能有过这样的经历，一个功能让你们改了四五遍代码，一次一次的修改，一次一次的被打回，直到没有问题为止。那么为什么我对代码审查要求这么严格呢？一是因为要对项目负责，二是想要你们在职业生涯初期养成对代码有追求的好习惯，要对代码有一颗敬畏之心。而且我也发现通过这种方式，你们的提升最快，同样的问题下次基本不会再犯。所以这里要感谢你们忍受我的坏脾气这么久，还是那句话，我不针对任何人，我只针对事情表明我的态度。&lt;/p&gt;
&lt;p&gt;再来说说我们的技术分享，之前我一直给你们做技术分享。分享的主要是项目中会用到的或者是我感觉你们应该知道却不知道的东西。其实我感觉这种分享效率并不高，每一次分享都是我在讲，你们也很少和我互动，所以每一次分享之后我都感觉没有达到我的预期。每一次分享之后我都想放弃，因为一次分享我要认真准备好久，但是效果却不明显。这对我来说有种很强的挫败感，但是每一次还是坚持了下来，因为我发现每次分享后，我们的团队氛围都要好了许多。后来我看到一篇关于团队分享的文章，对我的触动很大。加上玉的推动，我们确定了每周三下班之后的时间是我们的自愿分享时间。鼓励每个人都站出来做分享，可以是技术上的，也可以是公司业务上的。到目前为止，已经有一大半人做过了分享。其实这种分享能带来技术上的提升还是有限的，技术的提升应该是自己主动地学习，而不是被动地接受。这种分享更多带来的是分享人的沟通表达能力上的提升，相比于埋头写代码，沟通表达能力也非常重要。我一直认为沟通表达能力是很多能力的支点，你的沟通表达能力提升了，文档能力也会相应的提升、自信心会提升、解决问题的能力会提升。这也是为什么要极力鼓励大家站出来分享的原因。现在，我们组内的学习氛围浓厚，每个人都对技术充满了热情，每个人都在向我要推荐书单，每个人也都在买书看书，每个人也都在下班之后默默充电。这种氛围让我非常有成就感，甚至非常感动，至少证明了我们的技术分享是有价值的，是成功的。但是我也发现了一些问题，这些问题也是我带给你们的，为了避免你们走弯路，我必须站出来说一说这个问题。&lt;/p&gt;
&lt;p&gt;这个问题是我们为什么要学习？你们现在对技术的热情太高，而没有思考一下我们为什么要学习。这里引用极客邦科技创始人兼CEO霍泰稳的原话，你们感受一下：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;为了学习而学习，可能会适得其反。我认为最重要的，还是要和公司当下的业务相结合，在促进业务快速发展的过程中，让认知自然地提升。为什么有些大公司出来的同学，就给人感觉视野很开阔，能力也很好，主要原因并不是说它们在大公司里很努力地学习，而是因为它们参与了很多实际的有挑战的问题，攀登了一座又一座技术的高山，然后回头看，就有一种&quot;不畏浮云遮望眼&quot;的感觉。所以，第一点就是我们脑袋里面要始终想着业务，如何通过技术的努力，让业务得到快速发展，而不是一味地埋头于自己的技术三分地。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以你们学习要有一个方向，明白自己为什么要学习。学习一项技术之前要想一想我为什么要学习它，它有什么值得我学习的。否则的话，这个世界上要学习的技术太多了，技术更新迭代又很快，我们只会淹死在技术的海洋里。然后就是一定要重视业务，技术一定是和业务结合，解决业务上的问题，才能发挥出技术的价值。你们一定有这种体会，很多Bug其实因为自己对业务理解不到位导致的。所以我们现阶段要做好的是利用技术解决好业务中出现的问题难题，最终实现技术反推业务发展。其实我们学习最终要提升的是什么呢？是解决问题的能力。这也是一个企业最需要的能力，而往往解决问题能力高的人，对业务的理解也比较到位。所以归根结底，学习技术还是要结合业务，这也是我们为什么一直在说，做项目提升技术最快。&lt;/p&gt;
&lt;p&gt;其实写到这里，我最想表达的已经表达完成了。但是还是有一些东西想要和你们分享，可能有一些已经和你们提过了，但是我觉得还是有必要再提一下。因为这些东西对你们现阶段的帮助应该会比较大。&lt;/p&gt;
&lt;h2 id=&quot;年轻人要延迟满足&quot;&gt;年轻人要延迟满足&lt;/h2&gt;
&lt;p&gt;张一鸣有一句话说的特别对：所谓成功，就是延迟满足。试想谁不想享受现在，对以后不管不顾，但是纵观那些成功人士，他们无非是延迟满足。现在逼自己学习，逼自己吃苦，是为了以后的满足。年轻人不要选择被安排好的人生，不要过那种一眼望到头的人生。趁着年轻，多挑战，多试错。如果你懂得延迟满足，那你在同龄人中多半是优秀的。&lt;/p&gt;
&lt;h2 id=&quot;扎的越深浮的越高&quot;&gt;扎的越深，浮的越高&lt;/h2&gt;
&lt;p&gt;要重视基础。在技术这条道路上能走多远，多半取决于你的基础。真正的基础是计算机专业的那几门专业课，计算机操作系统、计算机网络、编译原理、数据库、计算机组成原理 和 数据结构和算法。这些只能自己花时间去了解去学习。另一方面就是工作中遇到了某些知识点，也要去看这个知识点相关的资料，不要停留在使用层面上，好奇心驱使向深处挖掘。&lt;/p&gt;
&lt;h2 id=&quot;业务代码不简单&quot;&gt;业务代码不简单&lt;/h2&gt;
&lt;p&gt;工作中都是写业务代码，刚开始还有新鲜感，熟练了以后就觉得无聊了。关于这点，我觉得码农翻身刘欣老师总结的非常好，平常一定要多向自己身上靠一靠，看一下哪些做的还不够，差距在哪里？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;7&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;我是否对系统的业务有了整体的了解？&lt;br/&gt;我能不能对其他人（例如面试官）描述下该系统实现的业务：&lt;br/&gt;系统有哪些角色，这些角色如何与系统交互；&lt;br/&gt;系统有哪些主要流程，次要流程，都有哪些角色参与其中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;系统的整体架构是什么样子？&lt;br/&gt;系统都分为哪些组件，这些组件是如何部署在服务器/客户端的？&lt;br/&gt;他们之间是怎么交互的？用的什么协议？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;系统用到了哪些技术和框架，我是不是都已经精通了？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于系统的非功能需求，我是不是已经掌握了？&lt;br/&gt;安全是怎么做的？&lt;br/&gt;如何做的性能测试？&lt;br/&gt;高可用性、可扩展性是怎么实现的？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;我是不是已经了解、甚至掌握了系统使用的工程实践？&lt;br/&gt;系统怎么做的build ？ 用到了哪些工具？&lt;br/&gt;系统怎么做的测试？ 如何自动化？&lt;br/&gt;系统是怎么部署的？&lt;br/&gt;系统是怎么监控的？&lt;br/&gt;现在还有什么问题？ 我能不能改进它？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;我在团队的地位如何？&lt;br/&gt;大家有了业务或技术问题，第一时间会不会想到找我来帮忙？&lt;br/&gt;我能不能在团队的讨论中发出自己的声音和见解， 并且被别人尊重？&lt;br/&gt;我是不是经常可以给大家做技术分享？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;要怀有感恩之心&quot;&gt;要怀有感恩之心&lt;/h2&gt;
&lt;p&gt;人要懂得感恩。人的一生可能会在一些关键的节点上遇到对你帮助很大的人们，要对他们怀有一颗感恩之心。以我个人举例，我感恩的人比较多。首先要感谢文宾哥，当初我选择走程序员这条路，也是因为他给我问题的回答让我无比坚定。我问他，程序员真的是青春饭吗？他说，不是。然后要感谢领我入门的德进哥，一直忘不了您的谆谆教诲，文杰啊，你要努力！还有您鼓励我的那500块钱工资。还要感谢我在公司的第一个师傅潇哥，感谢你没有嫌弃那么菜的我，还给我在书上画重点，让我重点学习哪一块技术。感谢我的老组长峰哥，现在不在一个项目组了，还给我的分享用心提出了整整两屏幕半的建议，每一条都非常诚恳，说实话我当时很意外很感动，以后的分享要注意这些建议的地方。感谢我的领导东哥，一年半前的那次谈话改变了我，也感谢你对我的信任和鼓励。感谢我的同事和好朋友法师，一位优秀的有追求的程序员，我在公司和法师的交流是最多的，在他身上学习到了不少东西。在他们身上我感受到了无数的正能量。我现在想尽最大能力帮助你们提升的原因，一是因为大家都比较年轻，刚进公司的你们或者现在的你们，很像那时候的我，懵懂无知，但是却苛求进步。二是因为正能量是可以“传染”的，他们“传染“给我，我”传染“给你们，你们可能要”传染“给将来的新人。最后应该感恩的是我的家人和我的女朋友。我的父母都是农民，但是他们在教育这件事上一点都不马虎，当年我的父亲想尽一切办法让我去了市里数一数二的初中高中读书，我从13岁到现在在外地上班就没怎么在家住过。直到现在他们还在为我操劳着，我亏欠父母的确实太多了。我的姐姐从7岁开始带我，以至于现在叫自己孩子名字都经常叫成我的名字。我的女朋友和我相恋5年了，这5年来无论我做什么决定，她都在背后默默支持。开始工作到现在，我的时间都分给了工作和研究技术，她从来没有和我抱怨过，虽然我陪她的时间少的过分。你轻松的生活工作背后一定有人在替你负重前行，对于我来说就是我的家人和我的女朋友。可能这个主题我跟你们讲不太合适，但是这个真的很重要。在你比较困难的时候，只要想起他们，你的心中就会充满了正能量。毕竟他们是希望你好的人，不能让他们失望。常怀感恩之心，你会走的更远。&lt;/p&gt;
&lt;p&gt;写了四个小时，该结束了。本篇文章纯属有感而发，写给我的组员们（和曾经的组员们）。希望你们看过之后有收获。&lt;/p&gt;

&lt;div class=&quot;content&quot; readability=&quot;26.253521126761&quot;&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;

&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div readability=&quot;7.9328063241107&quot;&gt;&lt;strong&gt;来源：&lt;a href=&quot;http://songwenjie.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;http://songwenjie.cnblogs.com/&lt;/a&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;p&gt;&lt;strong&gt;声明：本文为博主学习感悟总结，水平有限，如果不当，欢迎指正。如果您认为还不错，不妨点击一下下方的&lt;span onclick=&quot;Digg();&quot;&gt;【&lt;span&gt;推荐&lt;/span&gt;】&lt;/span&gt;按钮，谢谢支持。转载与引用请注明出处。&lt;/strong&gt;&lt;/p&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;



</description>
<pubDate>Sun, 06 May 2018 18:07:00 +0000</pubDate>
<dc:creator>喜欢天黑却怕鬼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songwenjie/p/9000713.html</dc:identifier>
</item>
<item>
<title>数据结构复习 - 少年天团</title>
<link>http://www.cnblogs.com/1024Community/p/9000710.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1024Community/p/9000710.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;什么是软件的基础？万年不变的公式：数据结构+算法=软件设计。走过了11年的计算机生涯，还记得，那时第二年，在那本白色的，还有点蓝色的教科书上面，首次接触到了这个公式，从此，就再也没放手。遥想当年，c++没学好，很是头疼那本书中的这个结构那个结构，链表是啥？还有，递归怎么去想？好吧，那一年玩魔兽去了，根本也没想多少，科是一定挂了的。兜兜转转这些年，从考研死扣了严蔚敏，到后来入手了Java，从这个框架转站了那个框架，从学校到公司，从一个公司又到另一个公司，大理石的《算法与数据结构》已经刷2遍，橙色Java算法接触宝典《算法》也是看了一遍，就连《c++11 primer》都从头到尾看了一遍。记得研三看primer的时候，边看就边想：特么的C++就这么个语法，当年怎么就学不进去，没学好呢？相当悔恨。同理，再《数据结构》上面也是一样。如果再让我来一遍，特么绝壁完爆期末考试。可是，人生已经回不去了。人就是这样，往往失去了，才懂得珍惜。对于《数据结构》的情感，我一直是这种内心情景，这次也算是描述清了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一学习数据结构的意义&quot;&gt;一、学习数据结构的意义&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;你要走技术路线，不是混吃等死的话，上升必须要有个好的数据结构功底&lt;/li&gt;
&lt;li&gt;锻炼思维&lt;/li&gt;
&lt;li&gt;所有底层框架和系统的基础，不要被整天的api调用和crud所迷惑&lt;/li&gt;
&lt;li&gt;算法的基础&lt;/li&gt;
&lt;li&gt;不要说工作中碰不到，我在前前后后的两个工作中都碰到了。碰到了，你不会和你会，效率是不一样的！&lt;/li&gt;
&lt;li&gt;想走业务线、管理线、老板线、我党线、人生赢家线、产品线等请无视上面BB，下面的也不用看了！&lt;/li&gt;
&lt;li&gt;最后安利一句：技术就是苦逼，借用网易游戏宣传片中的一句话：用职业、生意、市场定义游戏的人，永远不懂得热爱的意义。扪心自问：你热爱技术吗？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;整个数据结构的过程，大概是这样的：先理解概念，甚至可以看一遍实现，然后自己不看源码自己实现一遍。这个文章我主要介绍一下各个结构主要的注意点，具体的实现，我会上传github，链接再文末发出来。&lt;/p&gt;
&lt;p&gt;对于算法部分，我们主要使用大名鼎鼎的&lt;a href=&quot;https://leetcode-cn.com/problemset/all/&quot;&gt;leetcode&lt;/a&gt;进行跟踪与学习。本文会涉及到几个，不过不多，以为会慢慢的补全，也会继续出文章解说，大家也可以一起刷题，然后放上来。&lt;/p&gt;
&lt;p&gt;另外，针对多线程的考虑，本文暂不涉及，要涉及这一点，可能不适合数据结构的入门与深入，咱们要一步步来。&lt;/p&gt;
&lt;h2 id=&quot;二链表栈&quot;&gt;二、链表、栈&lt;/h2&gt;
&lt;p&gt;对链表和栈的抽象主要是下面的接口：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; List&amp;lt;E&amp;gt; {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;();

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;resize&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; resizeNum);

    &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;();

    &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isContained&lt;/span&gt;(E e);

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addFirst&lt;/span&gt;(E e);

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addLast&lt;/span&gt;(E e);

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index, E e);

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(E e);

    E &lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index);

    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;find&lt;/span&gt;(E e);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重点要注意点在于：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;链表的存储结果，可以有两种：数组和链式&lt;/li&gt;
&lt;li&gt;链表可以进行任意节点的插入、删除、访问&lt;/li&gt;
&lt;li&gt;栈的插入必须要在第一个元素前进行插入（栈顶），删除也只能删除最上面的（出栈），正所谓的先进后出（LIFO）&lt;/li&gt;
&lt;li&gt;注意对resize的实现，考虑好扩容的时机&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;链表（数组）具体的实现类为：struct.impl.ArrayList&lt;/li&gt;
&lt;li&gt;链表（链式）具体的实现类为：struct.impl.LinkedList&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;三-队列&quot;&gt;三、 队列&lt;/h2&gt;
&lt;p&gt;对于队列的抽闲接口如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; Queue&amp;lt;E&amp;gt; {

    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;();

    &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;();

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;enQueue&lt;/span&gt;(E e);

    E &lt;span class=&quot;fu&quot;&gt;deQueue&lt;/span&gt;();

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;resize&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; num);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重点的注意点在于：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我们实现的是循环队列，使用数组进行存储&lt;/li&gt;
&lt;li&gt;有两个指向收尾的index标示指针：first，last&lt;/li&gt;
&lt;li&gt;队列空的情况为：&lt;code&gt;first==last&lt;/code&gt;，队列为满的情况为：&lt;code&gt;(last+1)%size==first&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;队列的入队是将元素放到队尾，出队是将队头的元素出队，这就是(FIFO)&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;主要实现类为：struct.impl.ArrayQueue&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;四优先队列堆重点&quot;&gt;四、优先队列（堆，重点）&lt;/h2&gt;
&lt;p&gt;对于堆的抽象接口如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; Queue&amp;lt;E&amp;gt; {

    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;();

    &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;();

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;enQueue&lt;/span&gt;(E e);

    E &lt;span class=&quot;fu&quot;&gt;deQueue&lt;/span&gt;();

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;resize&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; num);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现重点在：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;注意堆的概念：一个树的树顶一定大于（小于）两个孩子，所以整个树，root就是最大（最小）的值&lt;/li&gt;
&lt;li&gt;堆是一个完全二叉树，所以我们可以使用数组进行实现，按照层序遍历的序号，对应数组的具体index&lt;/li&gt;
&lt;li&gt;实现难点在于删除与插入&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;插入：放到整个数组的最后一个元素里面，然后执行上浮（shiftUp）操作&lt;/li&gt;
&lt;li&gt;删除：将最后一个元素与root交换，然后针对最新root元素进行下沉（shiftDown）操作&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;我们使用root编号为0，root的两个孩子节点编号为1、2，以此类推&lt;/li&gt;
&lt;li&gt;获取当前index的孩子节点的操作为：index *2+1、index*2+2&lt;/li&gt;
&lt;li&gt;获取当前index的父亲节点操作为：(index-1)/2&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;实现类为：struct.impl.PriorityQueue&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;五二叉搜索树bst&quot;&gt;五、二叉搜索树（BST）&lt;/h2&gt;
&lt;p&gt;基本实现接口为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; BST&amp;lt;E &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Comparable&amp;lt;E&amp;gt;&amp;gt; {
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addValue&lt;/span&gt;(E value);

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;fu&quot;&gt;findMin&lt;/span&gt;();
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;fu&quot;&gt;findMax&lt;/span&gt;();

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;fu&quot;&gt;deleteMin&lt;/span&gt;();
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;fu&quot;&gt;deleteMax&lt;/span&gt;() ;
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;deleteNode&lt;/span&gt;(E value);

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;inOrder&lt;/span&gt;();

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;levelOrder&lt;/span&gt;();


}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意点在于：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;搜索树是一颗完全二叉树&lt;/li&gt;
&lt;li&gt;所有非叶子节点的数值，都大于左孩子，都小于右孩子&lt;/li&gt;
&lt;li&gt;主要注意删除最小值和删除最大值操作，因为可能涉及到删除节点孩子的保存问题&lt;/li&gt;
&lt;li&gt;删除任意节点操作是重点，麻蛋，被头条考了，让我写&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;实现类为：struct.impl.BST&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;六-二叉平衡树avl&quot;&gt;六、 二叉平衡树（AVL）&lt;/h2&gt;
&lt;p&gt;基本实现接口为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; BST&amp;lt;E &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Comparable&amp;lt;E&amp;gt;&amp;gt; {
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addValue&lt;/span&gt;(E value);

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;fu&quot;&gt;findMin&lt;/span&gt;();
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;fu&quot;&gt;findMax&lt;/span&gt;();

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;fu&quot;&gt;deleteMin&lt;/span&gt;();
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;fu&quot;&gt;deleteMax&lt;/span&gt;() ;
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;deleteNode&lt;/span&gt;(E value);

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;inOrder&lt;/span&gt;();

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;levelOrder&lt;/span&gt;();


}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;AVL本身是一个BST&lt;/li&gt;
&lt;li&gt;AVL对BST的优化点在于：所有节点的左右子树的高度差，不大于1，防止BST退化成链表的问题&lt;/li&gt;
&lt;li&gt;重点来了，思考好左旋右旋：如果是左左的情况，要进行右旋；如果是右右的情况，要进行左旋；如果是左右的情况，要进行先左旋再右旋；如果是右左的情况，要进行先右旋再左旋&lt;/li&gt;
&lt;li&gt;下面是四种不平衡情况的图例：1：左左；2：左右；3：右左；4：右右&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1344248/201805/1344248-20180507015621650-169224651.jpg&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;具体的实现代码为：struct.impl.AVL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;七结尾&quot;&gt;七、结尾&lt;/h2&gt;
&lt;p&gt;我的上传地址是：&lt;a href=&quot;https://github.com/JCAndWHTForPro/AlgorithmAndDataStruct&quot;&gt;AlgorithmAndDataStruct&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 06 May 2018 17:57:00 +0000</pubDate>
<dc:creator>少年天团</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1024Community/p/9000710.html</dc:identifier>
</item>
<item>
<title>JAVA学习总结-面向对象 - Kingram</title>
<link>http://www.cnblogs.com/Kingram/p/9000705.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Kingram/p/9000705.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言:&lt;/strong&gt;java面向对象中的知识可以说是整个java基础最核心的部分,不知不觉已经学完快2个月了,是时候复习一波了,刚开始学习的时候被绕的很懵逼,这次总结完毕之后有了很多新的感悟,这就是所谓的每有会意,便欣然忘食吧!哈哈~&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------&amp;gt;&amp;gt;&amp;gt;&amp;gt;华丽的分割线&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1,什么是类?什么是对象?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单来说,类是抽象出某一类事物的行为和特征,并进行的封装,特征称之为属性,行为称之为方法;&lt;/p&gt;
&lt;p&gt;对象就是这一类的具体实例,对象拥有这个类的所有属性和方法&lt;/p&gt;

&lt;p&gt;举个例子:&lt;/p&gt;
&lt;p&gt;所有的人是一个类,人所具有的属性:身高和体重...,人具有的方法:吃饭,睡觉..&lt;/p&gt;
&lt;p&gt;具体到某一个人是一个对象,比如小明就是一个对象,小明有身高,体重,可以吃饭,可以睡觉..&lt;/p&gt;

&lt;p&gt;java编程思想中是这么描述对象的:&lt;/p&gt;
&lt;p&gt;对象具有&lt;span&gt;状态,行为&lt;/span&gt;,和&lt;span&gt;标识&lt;/span&gt;.这意味着每一个对象都可以拥有内部数据(它们给出了该对象的状态)和方法(它们产生行为),并且每一个对象都可以与其他对象区分开来,具体来说,就是每一个对象在内存中都有一个唯一的地址.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2,什么是面向对象?为什么要面向对象?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;官方话:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面向对象（Object Oriented）是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计。从现实世界中客观存在的事物（即对象）出发来构造软件系统，并且在系统构造中尽可能运用人类的自然思维方式。面向对象是为了解决系统的&lt;span&gt;可维护性，可扩展性，可重用性....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的理解:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先,面向对象是一种设计程序的方式,是一种设计思想.&lt;/p&gt;
&lt;p&gt;其次,面向对象节省代码,思路清晰,便于扩展.你所创建出的对象就是给你提供服务的.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3,面向对象的三大特征:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、封装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　 封装是实现面向对象程序设计的第一步，封装就是将属性和方法放在一个类中。对外提供服务时尽可能的隐藏对象内部细节，只保留有限的接口和方法;&lt;/p&gt;
&lt;p&gt;　　封装的意义：&lt;br/&gt;　　封装的意义在于保护或者防止代码（数据）被我们无意中破坏。在面向对象程序设计中属性被看作是一个中心的元素并且和使用它的方法结合的很密切，从而保护　　它不被其它的方法意外的修改。&lt;/p&gt;
&lt;p&gt;　　可以通过对类的成员设置一定的访问权限，实现类中成员的信息隐藏。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;private：类中限定为private的成员，只能被这个&lt;span&gt;类本身&lt;/span&gt;访问。如果一个类的构造方法声明为private,则其它类不能生成该类的一个实例。&lt;/li&gt;
&lt;li&gt;default：类中不加任何访问权限限定的成员属于缺省的（default）访问状态，可以被这个&lt;span&gt;类本身和同一个包中的类&lt;/span&gt;所访问。&lt;/li&gt;
&lt;li&gt;protected：类中限定为protected的成员，可以被这个&lt;span&gt;类本身、它的子类（包括同一个包中以及不同包中的子类）和同一个包&lt;/span&gt;中的所有其他的类访问。&lt;/li&gt;
&lt;li&gt;public：类中限定为public的成员，可以被&lt;span&gt;所有的类&lt;/span&gt;访问。
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1383283/201805/1383283-20180506235601752-2147177471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;二, 继承&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Java的类可以分为三类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类：使用class定义，没有抽象方法&lt;/li&gt;
&lt;li&gt;抽象类：使用abstract class定义，&lt;span&gt;可以有也可以没有抽象方法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;接口：使用inerface定义，只能有抽象方法,(也可以没有),接口里的变量默认使用public static final修饰&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这三个类型之间存在如下关系：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类可以extends：类、抽象类（必须实现所有抽象方法），但只能extends一个，可以implements多个接口（必须实现所有接口方法）---&amp;gt;&lt;span&gt;单继承多实现&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;抽象类可以extends：类，抽象类（可全部、部分、或者完全不实现父类抽象方法），可以implements多个接口（可全部、部分、或者完全不实现接口方法）&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个接口可以继承多个接口&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;继承以后子类可以得到什么：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;子类直接拥有父类&lt;span&gt;非private&lt;/span&gt;的属性和方法&lt;/li&gt;
&lt;li&gt;子类可以添加自己的属性和方法，即对父类进行&lt;span&gt;扩展&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;子类可以&lt;span&gt;重写&lt;/span&gt;父类的方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于构造方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;构造方法不能被继承&lt;/span&gt;，子类可以通过super()显式调用父类的构造方法&lt;/li&gt;
&lt;li&gt;创建子类对象时，编译器会自动调用父类的无参构造方法&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果父类没有定义无参构造方法，子类必须在构造方法的第一行代码使用super()显式调用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;类默认拥有无参构造方法，如果定义了其他有参构造方法，则无参构造方法失效，所以父类没有定义无参构造方法，不是指父类没有写无参构造方法。　&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Java中通过super来实现对父类成员的访问，&lt;span&gt;super用来引用当前对象的父类&lt;/span&gt;。super 的使用有三种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;访问父类被隐藏的成员变量&lt;/li&gt;
&lt;li&gt;调用父类中被重写的方法&lt;/li&gt;
&lt;li&gt;调用父类的构造函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;继承的意义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码重用是一点，最重要的还是向上转型，即父类的引用变量可以指向子类对象，这是Java面向对象最重要特性多态的基础&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;span&gt;三, 多态&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;在了解多态之前，先了解以下几点:&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;什么是相同的方法：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个方法可以由：修饰符+返回值+方法名+参数+throw的异常+方法体6部分组成&lt;/li&gt;
&lt;li&gt;其中只有&lt;span&gt;方法名和参数&lt;/span&gt;是唯一性标识，意即&lt;span&gt;只要方法名和参数相同那他们就是相同的方法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;所谓参数相同，是指参数的个数，类型，顺序一致，其中任何一项不同都是不同的方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;什么是重载：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;重载是指一个类里面（包括父类的方法）存在方法名相同，但是参数不一样的方法，参数不同可以是不同的参数个数、类型或顺序&lt;/li&gt;
&lt;li&gt;如果仅仅是修饰符、返回值、throw的异常不同，那这是2个相同的方法，编译都通不过，更不要说重载了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;什么是重写:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;子类中存在和父类&lt;span&gt;相同的方法&lt;/span&gt;即为重写，何谓相同方法请牢记前面的描述，方法名和参数相同，包括参数个数、类型、顺序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;重写的规则：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;子&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;类不能覆盖父类private的方法&lt;/strong&gt;&lt;strong&gt;，private对子类不可见，如果子类定义了一个和父类private方法相同的方法，实为新增方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重写方法的修饰符权限一定要&lt;span&gt;大于或等于&lt;/span&gt;被重写方法的修饰符权限(public &amp;gt; protected &amp;gt; default &amp;gt; private)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重写抛出的异常需与父类相同或是父类异常的子类，或者重写方法干脆不写throws&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重写方法&lt;span&gt;的返回值必须与被重写方法一致，&lt;/span&gt;否则编译报错&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;静态方法不能被重写为非静态方法&lt;/span&gt;，否则编译出错&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;什么是多态?&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同一操作作用于不同的对象，可以产生不同的执行结果，这就是多态性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Java的多态性体现在两个方面：由方法重载实现的静态多态性（编译时多态）和方法重写实现的动态多态性（运行时多态）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编译时多态：在编译阶段，具体调用哪个被重载的方法，编译器会根据&lt;span&gt;参数的不同&lt;/span&gt;来调用相应的方法。&lt;/li&gt;
&lt;li&gt;运行时多态：&lt;span&gt;当父类引用引用指向子类对象时，&lt;span&gt;被引用的对象的类型&lt;/span&gt;决定了调用谁的方法，这个被调用的方法必须是在父类中定义过的，也就是说被子类重写的方法&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Animal {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; speak() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         System.out.println(&quot;我是动物&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Dog &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Animal {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; speak() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         System.out.println(&quot;汪汪...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cat &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Animal {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; speak() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         System.out.println(&quot;喵喵...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]) {&lt;br/&gt;&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         Animal animal = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dog();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         animal.speak(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 汪汪...&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         animal = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cat(); 
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         animal.speak();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 喵喵...&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;稍微复杂一点的案例:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Animal {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; speak1() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         System.out.println(&quot;我是动物..&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        speak2();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; speak2() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         System.out.println(&quot;我是一只凶猛的动物&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Dog &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Animal {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; speak1(String name) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         System.out.println(&quot;汪汪...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; speak2() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         System.out.println(&quot;我是一只泰迪&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         Animal animal = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dog();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        animal.speak1(); 
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我是动物..
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我是一只泰迪&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 06 May 2018 17:46:00 +0000</pubDate>
<dc:creator>Kingram</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Kingram/p/9000705.html</dc:identifier>
</item>
<item>
<title>《你必须掌握的Entity Framework 6.x与Core 2.0》书籍出版 - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/8655069.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/8655069.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;到目前为止写过刚好两百来篇博客，看过我博客的读者应该大概知道我每一篇博客都沿袭着一贯的套路，从前言到话题最终到总结，本文依然是一如既往的套路，但是不是介绍技术，也可说是介绍技术，不过是介绍书中的技术以及我对写作的态度，作为对本书的宣传，本书在最近即将出版，到时会在博客公告栏中放出购买链接。&lt;/p&gt;
&lt;h2&gt;写作初衷&lt;/h2&gt;
&lt;p&gt;之前有过出版社的编辑找我写书，我当时看了看也没回复最终当然也就是不了了之了，最主要的是觉得自己资历尚浅，写书和写博客有很大不同，写博客在言语上可以略微随意，而写书需要的是严谨同时在表达上也应言简意赅，后来怎么又写上了呢，看了看自己写的博客当属EF最多，记得在我初次学习EF时，我还特意搜索了下有没有相关中文的书籍作为参考资料，然而几乎一本都没有，后来我只能看看园中前辈们的博客和老外的文章来学习，最终也就写了一部分不算完整的EF系列，这个时候我想到是不是可以写一本EF 6.x和EF Core 2.0的书籍呢？作为EF 6.x和EF Core 2.0系统性学习的参考资料，若能帮助到初学和想继续深入的同行将再好不过了，也算是我对.NET作出的一份努力，同时也希望通过本书让您重新拾起对EF和EF Core的正确认知。&lt;/p&gt;
&lt;h2&gt;写作态度&lt;/h2&gt;
&lt;p&gt;从选题材到写完书大概耗时半年多的时间，在写EF篇章时脚步稍微快些，因为之前写过，只是在其过程中EF更新了一点点内容就花了一点时间去看文档，所以相对来说比较熟练一点，到了EF Core篇章脚步放缓了很多，虽然我也有写过，但是还不够深入，所以相当于写本书我从头又学习了EF和EF Core并深入探索到一些不为人知的秘密。写完后不久就开始了审稿，接着编辑那边将问题统一归纳交由我修改，同时我也秉着对自己负责和对读者负责的态度认真去修正文档中的错误，丝毫不敢懈怠，修改了有问题的地方以及添加了部分内容，都是在凌晨发给了编辑（【捂脸】），在这里要对编辑说声抱歉。以下是我从写作开始到书正式出版的详细记录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201804/589642-20180407004825038-168787051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;你必须掌握的Entity Framework 6.x和Core 2.0&lt;/h2&gt;
&lt;p&gt;书籍名称如博客标题所言，您也可将本书看做是您所不知道的Entity Framework 6.x和 Core 2.0，比如您是否知道EF 6.0如何创建索引呢？比如您又是否知道在EF 6.x中如何正确更新数据呢？比如您又是否知道在EF Core中何种情况下即通过lambda表达式使用Include来进行饥饿加载不好使呢？比如您又是否知道在EF Core中通过Find或者FindAsync方法如何进行饥饿加载呢？比如您又是否知道EF Core上下文实例池本质是什么呢？这样的疑问还有太多太多，本书如管中窥豹，带您一探究竟。本书既面向基础学习者也面向进阶学习者，无论您是自学还是在项目中用到了EF 6.x抑或是EF Core 2.0，本书将对您或许有一定帮助。&lt;/p&gt;
&lt;h2&gt;推荐致谢&lt;/h2&gt;
&lt;p&gt;只见过张善友大哥，与其他几位大佬素未谋面，不知是否能够得到大佬们的认可，怀着忐忑的心情去找大佬们写推荐，结果大佬们很快写完就交给我了，在此表示感谢，感谢dudu老大、何镇汐大哥，张善友大哥，赵培（好基友），邹琼俊大哥，感谢大佬们在百忙之中抽空为本书做推荐，感谢大佬们对本书的认可和支持。这里额外打个小广告：何镇汐大哥现作为.NET Core中国项目成员之一，以一己之力开发.NET Core平台下的应用框架（https://github.com/dotnetcore/Util），感谢何镇汐大哥对.NET Core所作出的贡献，同时也期待有志之士能够参与进来。&lt;/p&gt;
&lt;h2&gt;写作目录&lt;/h2&gt;
&lt;p&gt;第一篇 1&lt;br/&gt;第 1 章 7&lt;br/&gt;EntityFramework历史 7&lt;br/&gt;1.1 EntityFramework版本介绍 7&lt;br/&gt;1.2 EntityFramework 领域建模方式 9&lt;br/&gt;1.2.1 Code First 9&lt;br/&gt;1.2.2 Model First 10&lt;br/&gt;1.2.3 Database First 10&lt;br/&gt;1.3 使用EntityFramework Code First 6.x 或Core 2.0的原因 10&lt;br/&gt;1.4 小结 11&lt;br/&gt;第 2 章 12&lt;br/&gt;数据库表创建和迁移 12&lt;br/&gt;2.1 数据库连接和初始化策略 12&lt;br/&gt;2.1.1 数据库连接 12&lt;br/&gt;2.1.2 数据库初始化策略 15&lt;br/&gt;2.2 约定 17&lt;br/&gt;2.2.1 类型发现 17&lt;br/&gt;2.2.2 主键约定 17&lt;br/&gt;2.2.3 关系约定 19&lt;br/&gt;2.2.4 复杂类型约定 20&lt;br/&gt;2.2.5 自定义约定 21&lt;br/&gt;2.3 基于代码配置（Code-based Configuration Settings） 29&lt;br/&gt;2.4 配置属性映射和关系映射 32&lt;br/&gt;2.4.1 属性映射 32&lt;br/&gt;2.4.2 关系映射 50&lt;br/&gt;2.4.3 私有化属性映射 67&lt;br/&gt;2.5 继承映射策略 69&lt;br/&gt;2.5.1 Table per Hierarchy (TPH) 70&lt;br/&gt;2.5.2 Table per Type (TPT) 70&lt;br/&gt;2.5.3 Table per Concrete class (TPC) 73&lt;br/&gt;2.5.4 Entity Splitting 77&lt;br/&gt;2.5.5 Table Splitting 80&lt;br/&gt;2.6 代码迁移 82&lt;br/&gt;2.6.1 迁移命令 82&lt;br/&gt;2.6.2 迁移本质 91&lt;br/&gt;第 3 章 102&lt;br/&gt;实体状态和数据操作 102&lt;br/&gt;3.1 实体状态 102&lt;br/&gt;3.2 数据操作 105&lt;br/&gt;3.2.1 数据查询 105&lt;br/&gt;3.2.2 数据保存 124&lt;br/&gt;3.2.3 自动生成存储过程 135&lt;br/&gt;3.3 避免陷阱&lt;br/&gt;3.3.1 导航属性查询&lt;br/&gt;3.3.2 分页查询&lt;br/&gt;3.3.3 语义可空&lt;br/&gt;3.3.4 表值函数&lt;br/&gt;3.3.5 日期操作&lt;br/&gt;3.4 基础篇实战 138&lt;br/&gt;3.4.1 复杂属性作为JSON存储数据库表列 138&lt;br/&gt;第二篇 153&lt;br/&gt;第 4 章 155&lt;br/&gt;上下文管理和变更追踪原理 155&lt;br/&gt;4.1 上下文生命周期管理 155&lt;br/&gt;4.1.1 基础模式追溯 155&lt;br/&gt;4.1.2 生命周期追溯 157&lt;br/&gt;4.1.3 进化模式追溯 160&lt;br/&gt;4.2 变更追踪原理 163&lt;br/&gt;4.2.1 快照式变更追踪（Snapshot based Change Tracking） 163&lt;br/&gt;4.2.2 代理式变更追踪（Notification based Change Tracking with Proxies） 165&lt;br/&gt;第 5 章 175&lt;br/&gt;变更追踪原理和日志管理 175&lt;br/&gt;5.1 DetectChanges原理 175&lt;br/&gt;5.1.1 DetectChanges用途 175&lt;br/&gt;5.1.2 调用DetectChanges方法时机 177&lt;br/&gt;5.1.3 关闭自动调用DetectChanges方法 180&lt;br/&gt;5.1.4 遗忘的二进制属性和复杂类型 182&lt;br/&gt;5.2 日志记录 186&lt;br/&gt;5.2.1 ToString打印 186&lt;br/&gt;5.2.2 简单日志打印 187&lt;br/&gt;5.2.3 结构化日志输出 190&lt;br/&gt;5.2.4 构造块拦截 192&lt;br/&gt;5.2.5 拦截器异常性能监控 197&lt;br/&gt;5.2.6 拦截器解决EF 6.1忽略字符串空格历史遗留问题 211&lt;br/&gt;5.3 事务 215&lt;br/&gt;5.4 连接弹性 240&lt;br/&gt;第 6 章 246&lt;br/&gt;并发冲突 246&lt;br/&gt;6.1 初级版解析 246&lt;br/&gt;6.2 中级版解析 252&lt;br/&gt;6.2.1 客户端获胜 253&lt;br/&gt;6.2.2 数据库获胜 254&lt;br/&gt;6.2.3 客户端和数据库合并获胜 255&lt;br/&gt;6.3 高级版解析 256&lt;br/&gt;6.3.1简单重试策略 257&lt;br/&gt;6.3.2 Polly重试策略 257&lt;br/&gt;第 7 章 262&lt;br/&gt;性能优化实践 262&lt;br/&gt;7.1 优化一：预编译视图 262&lt;br/&gt;7.2 优化二：减少首次与数据库交互代码 266&lt;br/&gt;7.3 优化三：NGen安装EntityFramework程序集 269&lt;br/&gt;7.4 优化四：AsNoTracking 271&lt;br/&gt;7.5 优化五：DbFunctions/SqlFunctions 271&lt;br/&gt;7.6 优化六：缓存 276&lt;br/&gt;7.7 优化七：重新编译查询 282&lt;br/&gt;7.8 优化八：避免’N+1’ Select查询 287&lt;br/&gt;7.9 优化九：添加索引 289&lt;br/&gt;7.10 优化十：关闭回调DetectChanges方法 293&lt;br/&gt;7.11 优化十一：使用异步查询 296&lt;br/&gt;第 8 章 297&lt;br/&gt;EntityFramework 6.x实战 297&lt;br/&gt;8.1 工作单元泛型仓储模式（Generic Repository and a Unit of Work） 297&lt;br/&gt;8.2 依赖注入泛型仓储模式（Generic Repository Pattern and Dependency Injection） 321&lt;br/&gt;第三篇 338&lt;br/&gt;第 9 章 340&lt;br/&gt;数据库表创建和迁移 340&lt;br/&gt;9.1 数据库初始化策略 340&lt;br/&gt;9.2 配置属性映射和关系映射 344&lt;br/&gt;9.2.1 属性映射 345&lt;br/&gt;9.2.2 Backing Fields 357&lt;br/&gt;9.2.3 Alternate Keys 362&lt;br/&gt;9.2.4. Shadow Property 363&lt;br/&gt;9.2.5 Owned Entities 368&lt;br/&gt;9.2.6 HasQueryFilter 369&lt;br/&gt;9.2.7 关系映射 371&lt;br/&gt;9.2.8 继承映射 393&lt;br/&gt;9.3 代码迁移 398&lt;br/&gt;9.3.1 控制台程序迁移 398&lt;br/&gt;9.3.2 Web应用程序迁移 400&lt;br/&gt;9.3.3 多个上下文迁移 413&lt;br/&gt;9.3.4 脚手架逆向迁移 417&lt;br/&gt;第 10 章 422&lt;br/&gt;数据操作和初始化数据 422&lt;br/&gt;10.1 实体状态 422&lt;br/&gt;10.2 数据操作 423&lt;br/&gt;10.2.1 数据查询 423&lt;br/&gt;10.2.2 数据保存 446&lt;br/&gt;10.3 无连接实体 452&lt;br/&gt;10.4 初始化数据 455&lt;br/&gt;第四篇 459&lt;br/&gt;第 11 章 461&lt;br/&gt;性能优化实践 461&lt;br/&gt;11.1 AsNoTracking 461&lt;br/&gt;11.2 EF.Functions.Like 463&lt;br/&gt;11.3 自定义标量函数 466&lt;br/&gt;11.4 显式编译查询 470&lt;br/&gt;11.5 上下文实例池 473&lt;br/&gt;第 12 章 479&lt;br/&gt;查询实体元数据和模型数据验证 479&lt;br/&gt;12.1 查询元数据 479&lt;br/&gt;12.2 内置模型验证 481&lt;br/&gt;12.3 第三方扩展模型验证 484&lt;br/&gt;第 13 章 488&lt;br/&gt;上下文实例创建方式 488&lt;br/&gt;13.1 显式创建上下文实例 488&lt;br/&gt;13.1.1 带有构造函数的OnConfiguring方法 488&lt;br/&gt;13.1.2 传递连接字符串参数到构造函数 489&lt;br/&gt;13.1.3 使用不带依赖注入的DbContextOptions 489&lt;br/&gt;13.2 依赖注入容器创建上下文实例 490&lt;br/&gt;13.2.1 带有无参构造函数的DI 490&lt;br/&gt;13.2.2 带DbContextOptions的DI 491&lt;br/&gt;13.3.3 使用泛型DbContextOptions 491&lt;br/&gt;13.3.4 使用AddDbContext/AddDbContextPool 492&lt;br/&gt;第 14 章 494&lt;br/&gt;实现多租户 494&lt;br/&gt;第 15 章 504&lt;br/&gt;捕获审计数据 504&lt;br/&gt;第 16 章 510&lt;br/&gt;变更追踪策略和日志管理 510&lt;br/&gt;16.1 变更追踪策略 510&lt;br/&gt;16.1.1 INotifyPropertyChanged 511&lt;br/&gt;16.1.2 INotifyPropertyChanging 514&lt;br/&gt;16.2 日志管理 516&lt;br/&gt;16.2.1 添加控制台包输出 516&lt;br/&gt;16.2.2 自定义日志输出 517&lt;br/&gt;第 17 章 521&lt;br/&gt;xUnit单元测试 521&lt;br/&gt;17.1 控制台单元测试 522&lt;br/&gt;17.2 NET Core Web应用程序单元测试 524&lt;br/&gt;第 18 章 527&lt;br/&gt;事务和并发冲突 527&lt;br/&gt;18.1 事务 527&lt;br/&gt;18.2 并发冲突 533&lt;br/&gt;18.2.1 初级版解析 534&lt;br/&gt;18.2.2 中级版解析 538&lt;br/&gt;18.2.3 高级版解析 543&lt;br/&gt;第 19 章 550&lt;br/&gt;EntityFramework Core 2.1待发布 550&lt;br/&gt;19.1 新特性实现目标 550&lt;/p&gt;
&lt;h2&gt;总结 &lt;/h2&gt;
&lt;p&gt;本书是我所理解的EF 6.x和EF Core 2.0，也有我个人的一些思考，若本书能够对您有所帮助，那么如我写博客一样成就感就在于此了，期待本书能够得到您的认可，我会一如既往和大家分享我所得。&lt;/p&gt;
</description>
<pubDate>Sun, 06 May 2018 17:29:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CreateMyself/p/8655069.html</dc:identifier>
</item>
<item>
<title>NewLife.Net——开始网络编程 - 大石头</title>
<link>http://www.cnblogs.com/nnhy/p/newlife_net_echo.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnhy/p/newlife_net_echo.html</guid>
<description>&lt;p&gt;网络编程的重要性就不说了，先上源码：&lt;a href=&quot;https://github.com/nnhy/NewLife.Net.Tests&quot; target=&quot;_blank&quot;&gt;https://github.com/nnhy/NewLife.Net.Tests&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个服务端，就是监听一些端口，接收客户端连接和数据，进行处理，然后响应。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;span&gt;定义服务端，用于管理所有网络会话&lt;/span&gt;&lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; MyNetServer : NetServer&amp;lt;MyNetSession&amp;gt;&lt;span&gt;
{
}

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;span&gt;定义会话。每一个远程连接唯一对应一个网络会话，再次重复收发信息&lt;/span&gt;&lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; MyNetSession : NetSession&amp;lt;MyNetServer&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;span&gt;客户端连接&lt;/span&gt;&lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start()
    {
        &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.Start();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 欢迎语&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; str = String.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Welcome to visit {1}!  [{0}]\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Remote, Environment.MachineName);
        Send(str);
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;span&gt;收到客户端数据&lt;/span&gt;&lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;e&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnReceive(ReceivedEventArgs e)
    {
        WriteLog(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;收到：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e.Packet.ToStr());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把收到的数据发回去&lt;/span&gt;
&lt;span&gt;        Send(e.Packet);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;服务端核心类是NetServer，一般来说，每个网络服务端都会写一个自己的类来继承NetServer，以方便编写自己的NetSession会话逻辑。&lt;/p&gt;
&lt;p&gt;实在简单的应用，也可以直接实例化NetServer，然后通过事件来处理收到的连接和数据。&lt;/p&gt;
&lt;p&gt;这里我们写了个MyNetServer，没有任何代码，仅仅是为了指定使用哪个网络会话类。&lt;/p&gt;
&lt;p&gt;网络会话NetSession非常重要，每一个Tcp连接就对应一个会话，对Udp来说同一个远端套接字（IP+端口）就是一个会话。&lt;/p&gt;
&lt;p&gt;网络会话最重要的有几块：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Start会话开始，Tcp三次握手之后，双方还没有发送数据包之前，此时可以做一些准备工作，或者向客户端发送欢迎语。Udp会话开始在第一个数据包达到时。&lt;/li&gt;
&lt;li&gt;OnReceive接收，每次收到数据包以后，都会触发该方法，数据包位于e.Packet。Tcp默认同步处理，未完成当前数据包处理之前，不会接收本连接的下一个数据包。&lt;/li&gt;
&lt;li&gt;Send发送。发送Packet数据包给本会话连接的客户端，扩展方法支持发送字符串或数据流。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;！！！注意：粘包问题在OnReceive之前处理，下回有专门文章分析，接收数据的ReceivedEventArgs里面还有个Message，支持编码器对数据包进行解码成为消息。&lt;/p&gt;

&lt;p&gt;本例程是Echo回声程序，因此OnReceive把收到的数据包原样发回去。&lt;/p&gt;
&lt;p&gt;服务端用法很简单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt;&lt;span&gt; NetServer _server;
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestServer()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例化服务端，指定端口，同时在Tcp/Udp/IPv4/IPv6上监听&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; svr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyNetServer
    {
        Port &lt;/span&gt;= &lt;span&gt;1234&lt;/span&gt;&lt;span&gt;,
        Log &lt;/span&gt;=&lt;span&gt; XTrace.Log
    };
    svr.Start();

    _server &lt;/span&gt;=&lt;span&gt; svr;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;指定端口和日志，然后就可以开始服务了。&lt;/p&gt;
&lt;p&gt;默认在Tcp/Udp/IPv4/IPv6上监听，客户端爱用哪个协议来连接都行。&lt;/p&gt;
&lt;p&gt;当然，NetServer还可以支持多个端口同时监听，共用数据处理代码。&lt;/p&gt;

&lt;p&gt;客户端用法更简单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; uri = &lt;span&gt;new&lt;/span&gt; NetUri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp://127.0.0.1:1234&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; client =&lt;span&gt; uri.CreateRemote();
client.Log &lt;/span&gt;=&lt;span&gt; XTrace.Log;
client.Received &lt;/span&gt;+= (s, e) =&amp;gt;&lt;span&gt;
{
    XTrace.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;收到：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e.Packet.ToStr());
};
client.Open();

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i++&lt;span&gt;)
{
    Thread.Sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; str = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你好&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    client.Send(str);
}

client.Dispose();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的NetUri直接从字符串里面解析协议、地址、端口，然后CreateRemote建立客户端。这里会自动识别Tcp/Udp。&lt;/p&gt;
&lt;p&gt;也是指定日志，方便我们查看工作过程。还有两个开关 LogSend/LogReceive能输出更详细的数据包日志。&lt;/p&gt;
&lt;p&gt;Received事件里面处理收到的数据包。&lt;/p&gt;
&lt;p&gt;Open开始连接服务端，如果网络不同，这里会抛出异常。Tcp客户端有断线重连机制。&lt;/p&gt;
&lt;p&gt;发送数据包也很简单，直接Send就好，高级应用需要在发送后等待响应数据，可以用 await SendAsync。&lt;/p&gt;

&lt;p&gt;因为程序很简单，也可以用telnet命令来测试该服务端。&lt;/p&gt;

</description>
<pubDate>Sun, 06 May 2018 16:29:00 +0000</pubDate>
<dc:creator>大石头</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnhy/p/newlife_net_echo.html</dc:identifier>
</item>
<item>
<title>Spring温故而知新 - bean的装配(续) - 仍是少年</title>
<link>http://www.cnblogs.com/ashleyboy/p/9000436.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ashleyboy/p/9000436.html</guid>
<description>&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;按条件装配&lt;/strong&gt;&lt;strong&gt;bean&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;就是当满足特定的条件时Spring容器才创建Bean,Spring中通过@Conditional注解来实现条件化配置bean&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sl.ioc;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Conditional;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;

@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnimalConfig {
    
    @Bean(&lt;/span&gt;&quot;dog&quot;&lt;span&gt;)
    @Conditional(DogCondition.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dog DogInstance() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dog();
    }
    
    @Bean(&lt;/span&gt;&quot;cat&quot;&lt;span&gt;)
    @Conditional(CatCondition.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Cat CatInstance() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cat();
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;@Conditional和 ：Condition接口的实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Conditional {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * All {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Condition}s that must {&lt;/span&gt;&lt;span&gt;@linkplain&lt;/span&gt;&lt;span&gt; Condition#matches match}
     * in order for the component to be registered.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Condition&amp;gt;&lt;span&gt;[] value();

}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Condition {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Determine if the condition matches.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; context the condition context
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; metadata metadata of the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; org.springframework.core.type.AnnotationMetadata class}
     * or {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; org.springframework.core.type.MethodMetadata method} being checked
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; true} if the condition matches and the component can be registered,
     * or {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; false} to veto the annotated component's registration
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; matches(ConditionContext context, AnnotatedTypeMetadata metadata);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Conditional注解通过value传入一个类，实现Condition接口，通过实现Condition接口中matches方法决定是否需要装配Bean，如果满足条件需要创建bean则返回true，否则返回false&lt;/p&gt;
&lt;p&gt;自己定义两个继承Condition接口的类：通过ConditionContext查找当前环境中是否存在dog或者cat属性，如果存在，则创建对应的bean对象，具体实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sl.ioc;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Condition;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.ConditionContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.core.env.Environment;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.core.type.AnnotatedTypeMetadata;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DogCondition &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Condition {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; matches(ConditionContext context, AnnotatedTypeMetadata metadata) {       
        Environment environment &lt;/span&gt;=&lt;span&gt; context.getEnvironment();        
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; flag= environment.containsProperty(&quot;dog&quot;&lt;span&gt;);        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; flag;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sl.ioc;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Condition;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.ConditionContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.core.env.Environment;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.core.type.AnnotatedTypeMetadata;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CatCondition &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Condition {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        
        Environment environment &lt;/span&gt;=&lt;span&gt; context.getEnvironment();
        
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; flag= environment.containsProperty(&quot;cat&quot;&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; flag;
        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sl.ioc;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Animal {
    
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Say();
    
}

&lt;/span&gt;&lt;span&gt;package&lt;/span&gt; com.sl.ioc;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cat &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Animal {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Say() {
        System.out.println(&lt;/span&gt;&quot;I am a cat&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sl.ioc;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Dat &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Animal {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Say() {
        System.out.println(&lt;/span&gt;&quot;I am a dog&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestClass {

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestGetDoInstance() {
        
        System.setProperty(&lt;/span&gt;&quot;dog&quot;,&quot;&quot;&lt;span&gt;);    
    ApplicationContext context &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AnnotationConfigApplicationContext(AnimalConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        
        String[] beanNames &lt;/span&gt;=&lt;span&gt; context.getBeanDefinitionNames();

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String bean : beanNames) {

                System.out.println(bean);

        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行测试可以看到输出的beanname中会包含dog的bean:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201805/577318-20180506234859179-1278460244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;自动装配的歧义处理&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Spring自动装配时如果存在多个bean能够匹配的话，那么这种情况会阻碍Spring通过属性、构造函数或方法进行装配。针对这种情况，Spring提供了多种 可选方案来解决这个问题，可以选择一个bean作为首选的bean,或者使用限定符来确定唯一bean&lt;/p&gt;
&lt;h3&gt;1:使用首选Bean&lt;/h3&gt;
&lt;p&gt;Spring提供@Primary注解来设置首选Bean,当初选自动装配歧义时，会选择装配带有@Primary的bean&lt;/p&gt;
&lt;p&gt;沿用上面的示例代码，尝试装载animal&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnimalInstance {

    @Autowired
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Animal animal;
       
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;当Spring尝试注入animal实例时，由于Dog和Cat都继承自Animal,所以此处产生了歧义，下面通过使用@Primary指定首选bean&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
@Primary   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定首选bean&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cat &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Animal {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Say() {
        System.out.println(&lt;/span&gt;&quot;I am a cat&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;同样也可以使用XML配置来实现：&amp;lt;bean&amp;gt;元素提供了primary属性来设置首选bean&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;cat&quot;&lt;/span&gt;&lt;span&gt;  class&lt;/span&gt;&lt;span&gt;=&quot;com.sl.ioc.Cat&quot;&lt;/span&gt;&lt;span&gt; primary &lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestClass {
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestGetDoInstance() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;应用上下文&lt;/span&gt;
&lt;span&gt;        
        ApplicationContext context &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AnnotationConfigApplicationContext(AnimalConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        
        AnimalInstance animalInstance &lt;/span&gt;= context.getBean(AnimalInstance.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        animalInstance.animal.Say();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;运行结果：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201805/577318-20180506235148788-1081024093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;首选项只是标识一个优先选择装载的bean,如果配置了多个@Primary，那么将带来新的歧义，Spring依然无法完成自动装配，可以通过下面限定符来解决这个问题&lt;/p&gt;
&lt;h3&gt;2:使用限定符&lt;/h3&gt;
&lt;p&gt;Spring提供@Qualifier注解来指定想要注入的具体bean。例如上面的示例，如果指定注入dog：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sl.ioc;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Qualifier;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnimalInstance {

    @Autowired
    @Qualifier(&lt;/span&gt;&quot;dog&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Animal animal;
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;解释一下：@Qualifier(&quot;dog&quot;)表示指定的bean具有”dog”限定符，spring中bean如果没有指定限定符，会使用默认限定符，即使用beanID作为限定符。所以上面是恰好使用了dog bean的ID作为了限定符。也可以写成如下方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
@Qualifier(&lt;/span&gt;&quot;specialdog&quot;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为bean指定限定符&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Dog &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Animal
{
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Say() {
        System.out.println(&lt;/span&gt;&quot;I am a dog&quot;&lt;span&gt;);
    }    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnimalInstance {

    @Autowired
    @Qualifier(&lt;/span&gt;&quot;specialdog&quot;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用上面定义的限定符&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Animal animal; 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 align=&quot;left&quot;&gt;&lt;strong&gt;Bean&lt;/strong&gt;&lt;strong&gt;的作用域&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;Spring容器在创建bean实例的同时，还允许指定bean实例的作用域，常见作用域有一下几种：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1：单例作用域（Singleton）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2：原型作用域（Prototype）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3：会话作用域（Session）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;4：请求作用域（Request）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;5：全局会话作用域（globalSession）&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;Singleton作用域&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;在整个应用中，Spring IOC容器为使用singleton模式的bean只创建一个实例，Spring将会缓存Bean实例，任何对该类型beand请求都会返回该实例。单例也是Spring默认的作用域。具体使用如下，通过XML配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;beanid&quot;&lt;/span&gt;&lt;span&gt;  class&lt;/span&gt;&lt;span&gt;=&quot;com.sl.ioc.xxx&quot;&lt;/span&gt;&lt;span&gt; scope&lt;/span&gt;&lt;span&gt;=&quot;singleton&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&amp;lt;bean&amp;gt;元素提供了scope属性来设置singleton作用域&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;对应的注解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Prototype原型作用域&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;每次注入或者从Spring容器中获取时都创建一个新的bean实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;beanid&quot;&lt;/span&gt;&lt;span&gt;  class&lt;/span&gt;&lt;span&gt;=&quot;com.sl.ioc.xxx&quot;&lt;/span&gt;&lt;span&gt; scope&lt;/span&gt;&lt;span&gt;=&quot;prototype&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&amp;lt;bean&amp;gt;元素提供了scope属性来设置singleton作用域&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;对应的注解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;Session会话作用域&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;在web应用中，针对每个会话，Spring容器根据bean定义创建的bean实例，只在当前会话Session中有效，XML配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;beanid&quot;&lt;/span&gt;&lt;span&gt;  class&lt;/span&gt;&lt;span&gt;=&quot;com.sl.ioc.xxx&quot;&lt;/span&gt;&lt;span&gt; scope&lt;/span&gt;&lt;span&gt;=&quot;session&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;针对某个HTTP Session，Spring容器会根据bean定义创建一个新的bean实例，该bean仅在当前HTTP Session内有效。所以可以根据需要放心的更改bean实例的内部状态，而不影响其他Http Session中bean实例。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被销毁掉。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;Request 请求作用域&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;beanid&quot;&lt;/span&gt;&lt;span&gt;  class&lt;/span&gt;&lt;span&gt;=&quot;com.sl.ioc.xxx&quot;&lt;/span&gt;&lt;span&gt; scope&lt;/span&gt;&lt;span&gt;=&quot;globalSession&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;在web应用中，针对每次请求，Spring容器根据bean定义创建新的bean实例，只在当前请求内有效&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;beanid&quot;&lt;/span&gt;&lt;span&gt;  class&lt;/span&gt;&lt;span&gt;=&quot;com.sl.ioc.xxx&quot;&lt;/span&gt;&lt;span&gt; scope&lt;/span&gt;&lt;span&gt;=&quot;request&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;该bean实例只在当前请求内有效，在请求处理完成之后bean也会被销毁掉&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;globalSession&lt;strong&gt;全局会话作用域&lt;/strong&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;类似于session作用域，只是其用于portlet环境的web应用。如果在非portlet环境将视为session作用域。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

</description>
<pubDate>Sun, 06 May 2018 15:57:00 +0000</pubDate>
<dc:creator>仍是少年</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ashleyboy/p/9000436.html</dc:identifier>
</item>
</channel>
</rss>