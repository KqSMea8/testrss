<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>AspectCore中的IoC容器和依赖注入 - Lemon丶</title>
<link>http://www.cnblogs.com/liuhaoyang/p/dependencyinjection-in-aspectcore.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuhaoyang/p/dependencyinjection-in-aspectcore.html</guid>
<description>&lt;p&gt;IOC模式和依赖注入是近年来非常流行的一种模式，相信大家都不陌生了，在Asp.Net Core中提供了依赖注入作为内置的基础设施，如果仍不熟悉依赖注入的读者，可以看看由我们翻译的Asp.Net Core中文文档中依赖注入的相关章节: &lt;a href=&quot;http://www.cnblogs.com/dotNETCoreSG/p/aspnetcore-3_10-dependency-injection.html&quot;&gt;ASP.NET Core 中文文档 第三章 原理（10）依赖注入&lt;/a&gt;。基于IoC的重要性，AspectCore在提供Aop特性的同时，同样提供了可以和Aop无缝集成使用的轻量级、高性能IoC容器&lt;code&gt;AspectCore.Injector&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;开始使用&quot;&gt;开始使用&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;AspectCore.Injector&lt;/code&gt;内置在AspectCore.Core包中，我们可以通过nuget获取&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   Install-Package AspectCore.Core -pre&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;容器和服务注册&quot;&gt;容器和服务注册&lt;/h3&gt;
&lt;p&gt;在AspectCore.Injector中容器命名为&lt;code&gt;IServiceContainer&lt;/code&gt;，使用容器的默认实现来创建一个容器，并且提供了类型，实例，和工厂三种方式来注册服务：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;IServiceContainer services = new ServiceContainer();

//使用类型注册服务
services.AddType&amp;lt;ILogger, Logger&amp;gt;();

//使用实例注册服务，服务的生命周期限定为单例
services.AddInstance&amp;lt;ITaskService&amp;gt;(new TaskService());

//使用委托工厂注册服务
services.AddDelegate&amp;lt;ITaskService, TaskService&amp;gt;(resolver =&amp;gt; new TaskService());&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;服务解析&quot;&gt;服务解析&lt;/h3&gt;
&lt;p&gt;AspectCore.Injector通过IServiceResolver来解析服务：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//创建服务解析器
IServiceResolver serviceResolver = services.Build();

//解析单个服务
ISampleService sampleService = serviceResolver.Resolve&amp;lt;ISampleService&amp;gt;();

//解析单个服务，并且验证是否为null，为null则抛出异常
ISampleService sampleServiceRequired = serviceResolver.ResolveRequired&amp;lt;ISampleService&amp;gt;();

//解析服务集合，如果未注册，则为空集合
IEnumerable&amp;lt;ISampleService&amp;gt; sampleServices = serviceResolver.ResolveMany&amp;lt;ISampleService&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;依赖注入&quot;&gt;依赖注入&lt;/h3&gt;
&lt;p&gt;AspectCore.Injector提供构造器注入和属性两种方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface ISampleService
{
}

public class SampleService : ISampleService
{
    private readonly ISampleRepository _sampleRepository;
    private readonly ILogger _logger;
    
    //构造器注入
    public SampleService(ISampleRepository sampleRepository, ILogger logger)
    {
        _sampleRepository = sampleRepository;
        _logger = logger;
    }
}

public interface ISampleRepository
{
}

public class SampleRepository : ISampleRepository
{
    //属性注入。属性注入的条件为标记FromContainer特性，并且允许set。满足条件的属性自动注入
    [FromContainer]
    public ILogger Logger { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;生命周期&quot;&gt;生命周期&lt;/h3&gt;
&lt;p&gt;AspectCore.Injector提供以下生命周期：&lt;/p&gt;
&lt;p&gt;瞬时&lt;br/&gt;瞬时（Transient）生命周期服务在它们每次请求时被创建。这一生命周期适合轻量级的，无状态的服务。&lt;/p&gt;
&lt;p&gt;作用域&lt;br/&gt;作用域（Scoped）生命周期服务在每个作用域内被创建一次。&lt;/p&gt;
&lt;p&gt;单例&lt;br/&gt;单例（Singleton）生命周期服务在它们第一次被解析时创建，并且每个后续解析将使用相同的实例。如果你的应用程序需要单例行为，建议让服务容器管理服务的生命周期而不是在自己的类中实现单例模式和管理对象的生命周期。&lt;/p&gt;
&lt;h3 id=&quot;aop集成&quot;&gt;Aop集成&lt;/h3&gt;
&lt;p&gt;在AspectCore.Injector中默认开启在AspectCore.DynamicProxy的Aop集成，并可通过IServiceContainer的Configure方法进行Aop的配置。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services.Configure(config =&amp;gt;
{
    config.Interceptors.AddTyped&amp;lt;SampleInterceptor&amp;gt;();
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在asp.net-core中使用aspectcore.injector&quot;&gt;在Asp.Net Core中使用AspectCore.Injector&lt;/h3&gt;
&lt;p&gt;安装AspectCore.Extensions.DependencyInjection nuget包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Install-Package AspectCore.Extensions.DependencyInjection -pre&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在修改ConfigureServices：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public IServiceProvider ConfigureServices(IServiceCollection services)
{
    //添加你的服务...

    //将IServiceCollection的服务添加到ServiceContainer容器中
    var container = services.ToServiceContainer();
    return container.Build();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只需要两行代码即可在Asp.Net Core中使用AspectCore.Injector替换默认的DependencyInjection。&lt;/p&gt;
&lt;h3 id=&quot;性能&quot;&gt;性能&lt;/h3&gt;
&lt;p&gt;Autofac是目前.net/.net core较为流行的IoC容器之一，我们把Autofac(4.6.2版本)作为性能对比目标。分别从解析简单对象，属性注入和构造器注入三个方面对比性能。&lt;br/&gt;Benckmark类编写如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[AllStatisticsColumn]
[MemoryDiagnoser]
public class Benckmarks
{
    private readonly IServiceResolver serviceResolver;
    private readonly IContainer container;

    public Benckmarks()
    {
        var containerBuilder = new ContainerBuilder();
        containerBuilder.RegisterType&amp;lt;Logger&amp;gt;().As&amp;lt;ILogger&amp;gt;().InstancePerDependency();
        containerBuilder.RegisterType&amp;lt;TaskService&amp;gt;().As&amp;lt;ITaskService&amp;gt;().InstancePerDependency();
        containerBuilder.RegisterType&amp;lt;SampleRepository&amp;gt;().As&amp;lt;ISampleRepository&amp;gt;().InstancePerDependen
        containerBuilder.RegisterType&amp;lt;SampleService2&amp;gt;().As&amp;lt;ISampleService&amp;gt;().InstancePerDependency();
        container = containerBuilder.Build();

        var serviceContainer = new ServiceContainer();
        serviceContainer.AddType&amp;lt;ILogger, Logger&amp;gt;(Lifetime.Transient);
        serviceContainer.AddType&amp;lt;ITaskService, TaskService&amp;gt;(Lifetime.Transient);
        serviceContainer.AddType&amp;lt;ISampleRepository, SampleRepository&amp;gt;(Lifetime.Transient);
        serviceContainer.AddType&amp;lt;ISampleService, SampleService2&amp;gt;(Lifetime.Transient);
        serviceResolver = serviceContainer.Build();
    }

    [Benchmark]
    public object Autofac_Sample_Resolve()
    {
        return container.Resolve&amp;lt;ITaskService&amp;gt;();
    }

    [Benchmark]
    public object AspectCore_Sample_Resolve()
    {
        return serviceResolver.Resolve&amp;lt;ITaskService&amp;gt;();
    }

    [Benchmark]
    public object Autofac_PropertyInjection()
    {
        return container.Resolve&amp;lt;ISampleRepository&amp;gt;();
    }

    [Benchmark]
    public object AspectCore_PropertyInjection()
    {
        return serviceResolver.Resolve&amp;lt;ISampleRepository&amp;gt;();
    }

    [Benchmark]
    public object Autofac_ConstructorInjection()
    {
        return container.Resolve&amp;lt;ISampleService&amp;gt;();
    }

    [Benchmark]
    public object AspectCore_ConstructorInjection()
    {
        return serviceResolver.Resolve&amp;lt;ISampleService&amp;gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Release模式运行Benchmark：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BenchmarkDotNet=v0.10.8, OS=Windows 10 Threshold 2 (10.0.10586)
Processor=Intel Core i5-4590 CPU 3.30GHz (Haswell), ProcessorCount=4
Frequency=3215206 Hz, Resolution=311.0221 ns, Timer=TSC
dotnet cli version=2.0.0
  [Host]     : .NET Core 4.6.00001.0, 64bit RyuJIT
  DefaultJob : .NET Core 4.6.00001.0, 64bit RyuJIT

 |                          Method |        Mean |         Min |         Max |         Op/s |  Gen 0 | Allocated |
 |-------------------------------- |------------:|------------:|------------:|-------------:|-------:|----------:|
 |          Autofac_Sample_Resolve |   494.83 ns |   482.52 ns |   506.58 ns |  2,020,908.9 | 0.2384 |     752 B |
 |       AspectCore_Sample_Resolve |    88.52 ns |    87.92 ns |    89.31 ns | 11,296,837.3 | 0.0279 |      88 B |
 |       Autofac_PropertyInjection | 2,014.46 ns | 2,004.18 ns | 2,028.83 ns |    496,411.0 | 0.5875 |    1856 B |
 |    AspectCore_PropertyInjection |   307.55 ns |   303.61 ns |   310.74 ns |  3,251,544.6 | 0.1063 |     336 B |
 |    Autofac_ConstructorInjection | 1,465.71 ns | 1,454.43 ns | 1,480.38 ns |    682,263.5 | 0.6084 |    1920 B |
 | AspectCore_ConstructorInjection |   284.94 ns |   283.55 ns |   286.05 ns |  3,509,500.8 | 0.0987 |     312 B |
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;有问题反馈&quot;&gt;有问题反馈&lt;/h3&gt;
&lt;p&gt;Sample：&lt;a href=&quot;https://github.com/AspectCore/IoC-Sample&quot;&gt;IoC-Sample&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果您有任何问题，请提交 &lt;a href=&quot;https://github.com/dotnetcore/AspectCore-Framework/issues/new&quot;&gt;Issue&lt;/a&gt; 给我们。&lt;br/&gt;Github : &lt;a href=&quot;https://github.com/dotnetcore/AspectCore-Framework&quot; class=&quot;uri&quot;&gt;https://github.com/dotnetcore/AspectCore-Framework&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 19 Oct 2017 07:45:00 +0000</pubDate>
<dc:creator>Lemon丶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuhaoyang/p/dependencyinjection-in-aspectcore.html</dc:identifier>
</item>
<item>
<title>设计模式之visitor模式,人人能懂的有趣实例 - 南城草</title>
<link>http://www.cnblogs.com/nanchengcao/p/7692782.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nanchengcao/p/7692782.html</guid>
<description>&lt;p&gt;设计模式，现在在网上随便搜都一大堆，为什么我还要写“设计模式”的章节呢？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两个原因&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;1.本人觉得这是一个有趣的设计模式使用实例，所以记下来；&lt;/p&gt;
&lt;p&gt;2.看着设计模式很牛逼，却不知道怎么在实战中应用出来。希望这个实例能给学习者一个参考，一点启发。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意&lt;/span&gt;：本文是个人对设计模式的见解，不会出现大家常见的设计模式的概念。此文只作为一个实例。建议初学者参杂着别人博文一起读。&lt;/p&gt;
&lt;p&gt;在此，向《大话设计模式》作者吴强前辈致敬&lt;/p&gt;
&lt;h2&gt;一、 Visitor（访问者）模式&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;关键词&lt;/span&gt;：访问者， 被访问者（元素），元素群，双重注入，操作&lt;/p&gt;
&lt;p&gt;&lt;span&gt;访问者模式的作用&lt;/span&gt;：对【元素】、【访问者】和【对元素的操作】进行单独抽象和封装，一旦这些【访问者】的增加或者是【对元素的操作】发生变化，不需要修改【元素】。&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;二、故事背景&lt;/h2&gt;
&lt;p&gt;程序员小明到了新的软件园，呆了半个月之后，发现附近没有快餐店，人流特别多。于是决定投资开一家快餐店，参考&quot;某乐园&quot;的运营模式。快餐店很快就装修好了。小明参考各路快餐店，很快就设计出了几款菜式。经过深思熟虑，小明对点餐计费环节，用了Visitor模式。&lt;/p&gt;
&lt;h2&gt;三、设计分析&lt;/h2&gt;
&lt;p&gt;每道菜（为了直观，这里没用商品，而是把汤和饭也作为菜品之一）作为最小的单元（元素）；&lt;/p&gt;
&lt;p&gt;每个点餐的客户作为访问者；&lt;/p&gt;
&lt;p&gt;每一份快餐的菜单，则归类为对菜的操作。&lt;/p&gt;
&lt;h2&gt;四、参考事例&lt;/h2&gt;
&lt;p&gt;1.菜的抽象父类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Element {
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; String name; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;菜名&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; price; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;价格&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; weight;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;份量&lt;/span&gt;
    &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; 供给(Visitor visitor);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; getPrice() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; price;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setPrice(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; price) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price =&lt;span&gt; price;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getWeight() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; weight;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setWeight(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight =&lt;span&gt; weight;
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.食客接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Visitor {
    &lt;/span&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; 选菜( Element element );
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.各种菜品继承菜的父类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 卷心菜
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 南城草
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cabbage &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Element {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Cabbage(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;();&lt;br/&gt;this.weight = weight;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price = price*&lt;span&gt;weight;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Cabbage() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name = &quot;卷心菜&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price = 2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight = 1&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; 供给(Visitor visitor) {
        visitor.选菜(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 饭
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 南城草
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Meal &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Element {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Meal(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;();&lt;br/&gt;　　　　　this.weight = weight;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price = price*&lt;span&gt;weight;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Meal() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name = &quot;饭&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price = 2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight = 1&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; 供给(Visitor visitor) {
        visitor.选菜(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 烧鸭
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 南城草
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RoastDuck &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Element {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RoastDuck(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;();&lt;br/&gt;this.weight = weight;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price = price*&lt;span&gt;weight;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RoastDuck() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name = &quot;烧鸭&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price = 8&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight = 1&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; 供给(Visitor visitor) {
        visitor.选菜(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 叉烧
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 南城草
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RoastPork &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Element {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RoastPork(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;();&lt;br/&gt;this.weight = weight;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price = price*&lt;span&gt;weight;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RoastPork() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name = &quot;叉烧&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price = 8&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight = 1&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; 供给(Visitor visitor) {
        visitor.选菜(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 汤
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 南城草
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Soup &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Element {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Soup(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;();&lt;br/&gt;this.weight = weight;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price = price*&lt;span&gt;weight;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Soup() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name = &quot;汤&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price = 3&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight = 1&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; 供给(Visitor visitor) {
        visitor.选菜(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;……后面省略了快餐店多种菜式&lt;/p&gt;
&lt;p&gt;4.普通客户 实现访客者（Visitor）接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 普通客户
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 南城草
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NormalVisitor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Visitor {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; 选菜(Element element) {
        Element food &lt;/span&gt;=&lt;span&gt; ((Element) element);
        System.out.println(food.getName() &lt;/span&gt;+food.getWeight()+ &quot;份!&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;……后面省略多种不同客户的优惠实现（什么会员用户打折，会员积分都在这里拓展）&lt;/p&gt;
&lt;p&gt;5.下单类 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 普通菜单
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 南城草
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Lunchbox {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; HashMap&amp;lt;String, Element&amp;gt;&lt;span&gt; elements;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; allPrice = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Lunchbox() {
        elements &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashMap();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Attach(Element element) {
        elements.put(element.getName(), element);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Detach(Element element) {
        elements.remove(element);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Element getElemente(String name) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; elements.get(name);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Accept(Visitor visitor) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Element e : elements.values()) {
            e.供给(visitor);
            allPrice &lt;/span&gt;+= e.getPrice() *&lt;span&gt; e.getWeight();
        }
        System.out.print(&lt;/span&gt;&quot;总价:&quot;+&lt;span&gt;allPrice);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;……这里省略了多种点餐单，什么节日满减，都可以在这里拓展&lt;/p&gt;
&lt;p&gt;5.测试类——一个普通用户过来，要点菜啦&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Lunchbox lunchbox &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Lunchbox();

        lunchbox.Attach(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; RoastDuck(1&lt;span&gt;));
        lunchbox.Attach(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Meal(2&lt;span&gt;));
        lunchbox.Attach(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Soup(1&lt;span&gt;));

        lunchbox.Accept(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; NormalVisitor());
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.测试结果&lt;/p&gt;
&lt;p&gt;饭1份!&lt;br/&gt;烧鸭1份!&lt;br/&gt;汤1份!&lt;br/&gt;总价:15.0&lt;/p&gt;
&lt;h2&gt;三、总结&lt;/h2&gt;
&lt;p&gt;访客模式的优缺点：这里不做总结，百度很多。&lt;/p&gt;
&lt;p&gt;事例中的优缺点：&lt;/p&gt;
&lt;p&gt;优点：菜品的新增，直接增加类就可以了；&lt;/p&gt;
&lt;p&gt;          访客的变化，直接增加类实现接口就可以了；&lt;/p&gt;
&lt;p&gt;          制定新的销售手段，直接增加下单类就可以了；&lt;/p&gt;
&lt;p&gt;          这符合“开闭原则”。&lt;/p&gt;
&lt;p&gt;缺点：很明显，不能对菜品进行修改。&lt;/p&gt;
&lt;h2&gt;四、与本章节无关&lt;/h2&gt;
&lt;p&gt;本人技术有限，如果错误或者不合理的地方，欢迎联系我整改。&lt;/p&gt;
&lt;p&gt;突然写此章节，是一个偶然的机会，想到了这个有趣的设计模式例子，就写了下来。后续如果生活中发现符合其它设计模式的有趣例子，会持续增加。&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 19 Oct 2017 07:38:00 +0000</pubDate>
<dc:creator>南城草</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nanchengcao/p/7692782.html</dc:identifier>
</item>
<item>
<title>flying-saucer + iText +  Freemarker实现pdf的导出， 支持中文、css以及图片 - youzhibing2904</title>
<link>http://www.cnblogs.com/youzhibing/p/7692366.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youzhibing/p/7692366.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;      项目中有个需求，需要将合同内容导出成pdf。上网查阅到了 iText ， iText 是一个生成PDF文档的开源Java库，能够动态的从XML或者数据库生成PDF，同时还可以对文档进行加密，权限控制，并且还支持Java/C#等，但是iText本身提供的HTML解析器还是不够强大，许多HTML标签和属性无法识别，更悲催的是简单的CSS它不认识，排版调整样式让人头大。那么有没有什么方式能够支持css呢，又查阅到了 flying-saucer， flying-saucer也是导出PDF的一种解决方案，并且是基于iText的开源API，并且实现了CSS解析器，能够很好的支持CSS2.1，以及少量的CSS。最终解决方案定为： flying-saucer + iText +  Freemarker。&lt;/p&gt;
&lt;h2&gt;具体实现&lt;/h2&gt;
&lt;p&gt;　　流程如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/747662/201710/747662-20171019143455865-357160075.png&quot; alt=&quot;&quot;/&gt;　　pom.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;groupId&amp;gt;com.yzb.lee&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;itextpdf&amp;lt;/artifactId&amp;gt;
    &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;itextpdf Maven Webapp&amp;lt;/name&amp;gt;
    &amp;lt;url&amp;gt;http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;maven.apache.org&amp;lt;/url&amp;gt;&lt;/span&gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.freemarker&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;freemarker&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.3.20&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.itextpdf.tool&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;xmlworker&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.5.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        
        &amp;lt;!-- 支持中文 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.itextpdf&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;itext-asian&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.2.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- 支持css样式渲染 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.xhtmlrenderer&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;flying-saucer-pdf-itext5&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;9.0.3&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&amp;gt;&lt;/span&gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;commons-lang3&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.4&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
    &amp;lt;build&amp;gt;
        &amp;lt;finalName&amp;gt;itextpdf&amp;lt;/finalName&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　1、html内容的输出&lt;/h3&gt;
&lt;p&gt;　　　　模版文件fileTemplate.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_ef58ae32-6599-4c3a-ad6a-131aae8b300d&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ef58ae32-6599-4c3a-ad6a-131aae8b300d&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ef58ae32-6599-4c3a-ad6a-131aae8b300d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${title}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; link链接应该写文件服务器地址， 出于演示，这里用的localhost &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt; rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://localhost:8080/itextpdf/css/pdf.css&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
@page &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 8.5in 11in&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    @
    bottom-center
    {
        content
        &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;
        &quot;page &quot;
        counter(
        page
        )
        &quot; of  &quot;
        counter(
        pages
        )&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Just a blank page.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;page-break-before: always;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;align&lt;/span&gt;&lt;span&gt;=&quot;center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${title}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; src链接应该写文件服务器地址， 出于演示，这里用的localhost &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;alt&lt;/span&gt;&lt;span&gt;=&quot;加载中...&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;http://localhost:8080/itextpdf/images/aloner.jpg&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Name&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Age&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Sex&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;#list &lt;/span&gt;&lt;span&gt;userList as user&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${user.name}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${user.age}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;#if &lt;/span&gt;&lt;span&gt;user.sex &lt;/span&gt;&lt;span&gt;= 1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; male &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;#else&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; female &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;#list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;https://www.baidu.com/&quot;&lt;/span&gt;&lt;span&gt; target&lt;/span&gt;&lt;span&gt;=&quot;_blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;百度&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;       　　动态数据的获取&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; getContent() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从数据库中获取数据， 出于演示目的， 这里数据不从数据库获取， 而是直接写死&lt;/span&gt;
&lt;span&gt;        
        Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; variables = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;(3&lt;span&gt;);

        List&lt;/span&gt;&amp;lt;User&amp;gt; userList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;User&amp;gt;&lt;span&gt;();

        User tom &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;Tom&quot;, 19, 1&lt;span&gt;);
        User amy &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;Amy&quot;, 28, 0&lt;span&gt;);
        User leo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;Leo&quot;, 23, 1&lt;span&gt;);

        userList.add(tom);
        userList.add(amy);
        userList.add(leo);

        variables.put(&lt;/span&gt;&quot;title&quot;, &quot;用户列表&quot;&lt;span&gt;);
        variables.put(&lt;/span&gt;&quot;userList&quot;&lt;span&gt;, userList);
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; variables;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　动态数据的绑定，html内容的输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Generate html string.
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; template
     *            the name of freemarker teamlate.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; variables
     *            the data of teamlate.
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; htmlStr
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String generate(String template, Map&amp;lt;String, Object&amp;gt;&lt;span&gt; variables)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Configuration config &lt;/span&gt;=&lt;span&gt; FreemarkerConfiguration.getConfiguation();
        Template tp &lt;/span&gt;=&lt;span&gt; config.getTemplate(template);
        StringWriter stringWriter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringWriter();
        BufferedWriter writer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedWriter(stringWriter);
        tp.setEncoding(&lt;/span&gt;&quot;UTF-8&quot;&lt;span&gt;);
        tp.process(variables, writer);
        String htmlStr &lt;/span&gt;=&lt;span&gt; stringWriter.toString();
        writer.flush();
        writer.close();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; htmlStr;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2、pdf的导出&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; generatePdf(String htmlStr, OutputStream out)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, DocumentException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;final ServletContext servletContext = getServletContext();&lt;/span&gt;
&lt;span&gt;
        Document document &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Document(PageSize.A4, 30, 30, 30, 30&lt;span&gt;);
        document.setMargins(&lt;/span&gt;30, 30, 30, 30&lt;span&gt;);
        PdfWriter writer &lt;/span&gt;=&lt;span&gt; PdfWriter.getInstance(document, out);
        document.open();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; html内容解析&lt;/span&gt;
        HtmlPipelineContext htmlContext = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HtmlPipelineContext(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; CssAppliersImpl(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLWorkerFontProvider() {
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Font getFont(String fontname, String encoding,
                            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; size, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; style) {
                        Font font &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fontname == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字体  &lt;/span&gt;
                            String fontCn =&lt;span&gt; getChineseFont();  
                            BaseFont bf;
                            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意这里有一个,1 &lt;/span&gt;
                                bf = BaseFont.createFont(fontCn+&quot;,1&quot;&lt;span&gt;, 
                                         BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED);
                                font &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Font(bf, size, style);
                            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (DocumentException e) {
                                e.printStackTrace();
                            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                                e.printStackTrace();
                            }  
                            
                        }
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; font;
                    }
                })) {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HtmlPipelineContext clone()
                    &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException {
                HtmlPipelineContext context &lt;/span&gt;= &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    ImageProvider imageProvider &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getImageProvider();
                    context.setImageProvider(imageProvider);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoImageProviderException e) {
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; context;
            }
        };

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图片解析&lt;/span&gt;
        htmlContext.setImageProvider(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AbstractImageProvider() {

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; String rootPath = servletContext.getRealPath(&quot;/&quot;);&lt;/span&gt;
&lt;span&gt;
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getImageRootPath() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;&quot;&lt;span&gt;;
            }

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Image retrieve(String src) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(src)) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; String imageFilePath = new File(rootPath, src).toURI().toString();&lt;/span&gt;
                    Image image =&lt;span&gt; Image.getInstance(src);
                    image.setAbsolutePosition(&lt;/span&gt;400, 400&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (image != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        store(src, image);
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; image;
                    }
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
                    e.printStackTrace();
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.retrieve(src);
            }
        });
        htmlContext.setAcceptUnknown(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;).autoBookmark(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                .setTagFactory(Tags.getHtmlTagProcessorFactory());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; css解析&lt;/span&gt;
        CSSResolver cssResolver =&lt;span&gt; XMLWorkerHelper.getInstance()
                .getDefaultCssResolver(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        cssResolver.setFileRetrieve(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileRetrieve() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processFromStream(InputStream in,
                    ReadingProcessor processor) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt; (InputStreamReader reader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(in,
                        CHARSET_NAME)) {
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = -1&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (-1 != (i =&lt;span&gt; reader.read())) {
                        processor.process(i);
                    }
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
                }
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析href&lt;/span&gt;
&lt;span&gt;            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processFromHref(String href, ReadingProcessor processor)
                    &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; InputStream is = servletContext.getResourceAsStream(href);&lt;/span&gt;
                URL url = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; URL(href);
                HttpURLConnection conn &lt;/span&gt;=&lt;span&gt; (HttpURLConnection) url.openConnection();
                conn.setRequestMethod(&lt;/span&gt;&quot;GET&quot;&lt;span&gt;);
                conn.setConnectTimeout(&lt;/span&gt;5 * 1000&lt;span&gt;);
                InputStream is &lt;/span&gt;=&lt;span&gt; conn.getInputStream();

                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt; (InputStreamReader reader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(is,
                        CHARSET_NAME)) {
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = -1&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (-1 != (i =&lt;span&gt; reader.read())) {
                        processor.process(i);
                    }
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
                    e.printStackTrace();
                }
            }
        });

        HtmlPipeline htmlPipeline &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HtmlPipeline(htmlContext,
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PdfWriterPipeline(document, writer));
        Pipeline&lt;/span&gt;&amp;lt;?&amp;gt; pipeline = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CssResolverPipeline(cssResolver,
                htmlPipeline);
        XMLWorker worker &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        worker &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; XMLWorker(pipeline, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        XMLParser parser &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; XMLParser(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, worker,
                Charset.forName(CHARSET_NAME));
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt; (InputStream inputStream = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayInputStream(
                htmlStr.getBytes())) {
            parser.parse(inputStream, Charset.forName(CHARSET_NAME));
        }
        document.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3、生成的pdf&lt;/h3&gt;
&lt;p&gt;　　　&lt;span&gt;&lt;a href=&quot;https://files.cnblogs.com/files/youzhibing/1508383793597.pdf&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;1508383793597.pdf&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;注意点&lt;/h2&gt;
&lt;p&gt;　　1、博客中的代码不是一个完整工程，只依赖博客中的代码是运行不起来的；　　&lt;/p&gt;
&lt;p&gt;　　2、文件路径的获取，本地文件与远程文件的获取是有区别的， 另外本地文件的获取又存在多种方式；&lt;/p&gt;
&lt;p&gt;　　3、完整工程地址：&lt;span&gt;&lt;a href=&quot;https://github.com/youzhibing/itextpdf&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;itextpdf&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，仔细阅读readme.txt， 工程中存在多个版本， 而本博客对应的是版本4；&lt;/p&gt;
&lt;p&gt;　　4、推荐将SIMSUN.TTC放到工程中， 这就不依赖操作系统了， 可移植性更强；&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;　　&lt;a href=&quot;http://blog.csdn.net/mydreamongo/article/details/8220577&quot; target=&quot;_blank&quot;&gt;获取java项目根目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;http://jeemiss.iteye.com/blog/1112765&quot; target=&quot;_blank&quot;&gt;freemarker+Flying sauser +Itext 整合生成PDF&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 19 Oct 2017 07:16:00 +0000</pubDate>
<dc:creator>youzhibing2904</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youzhibing/p/7692366.html</dc:identifier>
</item>
<item>
<title>chromium源码阅读--进程的Message Loop - 丹西</title>
<link>http://www.cnblogs.com/danxi/p/7691206.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/danxi/p/7691206.html</guid>
<description>&lt;p&gt;上一篇总结了chromium进程的启动，接下来就看线程的消息处理，这里的线程包含进程的主进程。&lt;/p&gt;
&lt;p&gt;消息处理是由base::MessageLoop中实现，消息中的任务和定时器都是异步事件的。&lt;/p&gt;
&lt;p&gt;主要如下几点：&lt;/p&gt;
&lt;p&gt;1、消息的类型分类&lt;/p&gt;
&lt;p&gt;2、延时处理的消息是如何实现&lt;/p&gt;

&lt;p&gt;一、消息分类&lt;/p&gt;
&lt;p&gt;     chromium主要将消息类型如下定义：（&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a class=&quot;packageName&quot; href=&quot;https://cs.chromium.org/chromium/&quot;&gt;chromium&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;//&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/&quot;&gt;src&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/base/&quot;&gt;base&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/base/message_loop/&quot;&gt;message_loop&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;a class=&quot;v-f&quot; href=&quot;https://cs.chromium.org/chromium/src/base/message_loop/message_loop.h&quot;&gt;message_loop.h&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;  112行）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Type {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    TYPE_DEFAULT,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    TYPE_UI,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    TYPE_CUSTOM,
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    TYPE_IO,
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; defined(OS_ANDROID)
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    TYPE_JAVA,
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; defined(OS_ANDROID)&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt;   };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.TYPE_DEFAULT：&lt;/p&gt;
&lt;p&gt;      处理chromium定义的Task（闭包代码块）和定时器任务&lt;/p&gt;
&lt;p&gt;2.TYPE_UI：&lt;/p&gt;
&lt;p&gt;     除了TYPE_DEFAULT定义的范围，还支持原生的UI事件消息（比如用户操作的窗口消息），MessageLoopForUI类&lt;/p&gt;
&lt;p&gt;3.TYPE_IO:&lt;/p&gt;
&lt;p&gt;     除了TYPE_DEFAULT定义的范围，还支持异步IO的事件消息，MessageLoopForIO类&lt;/p&gt;
&lt;p&gt;4.TYPE_JAVA&lt;/p&gt;
&lt;p&gt;    是Android平台的特有的消息消息，因为Android里，有java消息和native消息分层，native消息与java消息交互，java消息与应用程序交互，可以看做java消息接管了native消息。&lt;/p&gt;
&lt;p&gt;5.TYPE_CUSTOM&lt;/p&gt;
&lt;p&gt;    定制消息，比较少见使用。&lt;/p&gt;

&lt;p&gt;消息类型的不同也就会创建不同的MessagePump。对于UI消息，不同的平台也会有不同的实现。在&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a class=&quot;packageName&quot; href=&quot;https://cs.chromium.org/chromium/&quot;&gt;chromium&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;//&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/&quot;&gt;src&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/base/&quot;&gt;base&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/base/message_loop/&quot;&gt;message_loop&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;a class=&quot;v-f&quot; href=&quot;https://cs.chromium.org/chromium/src/base/message_loop/message_loop.cc&quot;&gt;message_loop.cc&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 166行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_f1381794-a6ea-4c70-807a-8087a5c41bf9&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f1381794-a6ea-4c70-807a-8087a5c41bf9&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f1381794-a6ea-4c70-807a-8087a5c41bf9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; static&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; std::unique_ptr&amp;lt;MessagePump&amp;gt;&lt;span&gt; MessageLoop::CreateMessagePumpForType(Type type) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO(rvargas): Get rid of the OS guards.&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; defined(USE_GLIB) &amp;amp;&amp;amp; !defined(OS_NACL)
&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;using&lt;/span&gt; MessagePumpForUI =&lt;span&gt; MessagePumpGlib;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#elif&lt;/span&gt; (defined(OS_LINUX) &amp;amp;&amp;amp; !defined(OS_NACL)) || defined(OS_BSD)
&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;using&lt;/span&gt; MessagePumpForUI =&lt;span&gt; MessagePumpLibevent;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#elif&lt;/span&gt; defined(OS_FUCHSIA)
&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;using&lt;/span&gt; MessagePumpForUI =&lt;span&gt; MessagePumpFuchsia;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; defined(OS_IOS) || defined(OS_MACOSX)
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; MESSAGE_PUMP_UI std::unique_ptr&amp;lt;MessagePump&amp;gt;(MessagePumpMac::Create())
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#elif&lt;/span&gt; defined(OS_NACL) || defined(OS_AIX)
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Currently NaCl and AIX don't have a UI MessageLoop.
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO(abarth): Figure out if we need this.&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; MESSAGE_PUMP_UI std::unique_ptr&amp;lt;MessagePump&amp;gt;()
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; MESSAGE_PUMP_UI std::unique_ptr&amp;lt;MessagePump&amp;gt;(new MessagePumpForUI())
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; defined(OS_MACOSX)
&lt;span&gt;23&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use an OS native runloop on Mac to support timer coalescing.&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; MESSAGE_PUMP_DEFAULT \
&lt;span&gt;25&lt;/span&gt;   std::unique_ptr&amp;lt;MessagePump&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessagePumpCFRunLoop())
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; MESSAGE_PUMP_DEFAULT \
&lt;span&gt;28&lt;/span&gt;   std::unique_ptr&amp;lt;MessagePump&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessagePumpDefault())
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (type ==&lt;span&gt; MessageLoop::TYPE_UI) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (message_pump_for_ui_factory_)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; message_pump_for_ui_factory_();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; MESSAGE_PUMP_UI;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (type ==&lt;span&gt; MessageLoop::TYPE_IO)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; std::unique_ptr&amp;lt;MessagePump&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessagePumpForIO());
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; defined(OS_ANDROID)
&lt;span&gt;40&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (type ==&lt;span&gt; MessageLoop::TYPE_JAVA)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; std::unique_ptr&amp;lt;MessagePump&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessagePumpForUI());
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;  DCHECK_EQ(MessageLoop::TYPE_DEFAULT, type);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; MESSAGE_PUMP_DEFAULT;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;二、延时消息如何处理&lt;/p&gt;
&lt;p&gt;消息的处理与消息队列密不可分，internal::&lt;span class=&quot;f-b&quot;&gt;IncomingTaskQueue&lt;/span&gt;实现了一个线程安全的消息队列。 MessageLoop里定义了（&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a class=&quot;packageName&quot; href=&quot;https://cs.chromium.org/chromium/&quot;&gt;chromium&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;//&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/&quot;&gt;src&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/base/&quot;&gt;base&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/base/message_loop/&quot;&gt;message_loop&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;a class=&quot;v-f&quot; href=&quot;https://cs.chromium.org/chromium/src/base/message_loop/message_loop.h&quot;&gt;message_loop.h&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 392行）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; scoped_refptr&amp;lt;&lt;span&gt;internal&lt;/span&gt;::IncomingTaskQueue&amp;gt; incoming_task_queue_;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接收到的消息就缓存在这个队列里。那么我们先看看这个类的构造函数。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; IncomingTaskQueue::IncomingTaskQueue(MessageLoop*&lt;span&gt; message_loop)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     : always_schedule_work_(AlwaysNotifyPump(message_loop-&amp;gt;&lt;span&gt;type())),
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;       triage_tasks_(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       delayed_tasks_(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;       deferred_tasks_(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;      message_loop_(message_loop) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The constructing sequence is not necessarily the running sequence in the
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; case of base::Thread.&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  DETACH_FROM_SEQUENCE(sequence_checker_);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构造函数里通过MessageLoop的类型来初始化bool成员 always_schedule_work_ ，来判断是否对消息进行调度， 并保存了message_loop指针。&lt;/p&gt;
&lt;p&gt;继续分析代码，前面看到消息队列已经初始化了，那接下来我们看看是怎么往队列里添加任务的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bool&lt;/span&gt; IncomingTaskQueue::AddToIncomingQueue(&lt;span&gt;const&lt;/span&gt; Location&amp;amp;&lt;span&gt; from_here,
                                           OnceClosure task,
                                           TimeDelta delay,
                                           Nestable nestable) {
  ......

  PendingTask pending_task(from_here, std::move(task),
                           CalculateDelayedRuntime(delay), nestable);
  ......
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; PostPendingTask(&amp;amp;&lt;span&gt;pending_task);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用了PendingTask对象，并计算了延迟的时间和是否是嵌套任务。那么看PostPendingTask函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IncomingTaskQueue::PostPendingTask(PendingTask*&lt;span&gt; pending_task) {&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; accept_new_tasks;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   &lt;span&gt;bool&lt;/span&gt; schedule_work = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    AutoLock auto_lock(incoming_queue_lock_);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     accept_new_tasks =&lt;span&gt; accept_new_tasks_;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (accept_new_tasks)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       schedule_work =&lt;span&gt; PostPendingTaskLockRequired(pending_task);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;accept_new_tasks) {&lt;br/&gt;&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     pending_task-&amp;gt;&lt;span&gt;task.Reset();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (schedule_work) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ensures |message_loop_| isn't destroyed while running.&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    AutoLock auto_lock(message_loop_lock_);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (message_loop_)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;       message_loop_-&amp;gt;&lt;span&gt;ScheduleWork();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里已经开始给线程加锁了，那么继续看&lt;span&gt;PostPendingTaskLockRequired&lt;/span&gt;函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IncomingTaskQueue::PostPendingTaskLockRequired(PendingTask*&lt;span&gt; pending_task) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  incoming_queue_lock_.AssertAcquired();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  ......
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   
&lt;span&gt; 7&lt;/span&gt;   pending_task-&amp;gt;sequence_num = next_sequence_num_++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;   task_annotator_.DidQueueTask(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MessageLoop::PostTask&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *&lt;span&gt;pending_task);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;bool&lt;/span&gt; was_empty =&lt;span&gt; incoming_queue_.empty();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   incoming_queue_.push(std::move(*&lt;span&gt;pending_task));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (is_ready_for_scheduling_ &amp;amp;&amp;amp;
&lt;span&gt;15&lt;/span&gt;       (always_schedule_work_ || (!message_loop_scheduled_ &amp;amp;&amp;amp;&lt;span&gt; was_empty))) {&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     message_loop_scheduled_ = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里看到pending_task是保存在incoming_queue_ 这里使用了std::queue容器(一个FIFO的数据结构），这个队列里面的任务还没有添加到MessageLoop中，也可以看到这里还没有明确任务的执行方式，使用的是FIFO队列。&lt;/p&gt;
&lt;p&gt;下面的几个成员变量，则就是在MessageLoop中使用了。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a class=&quot;packageName&quot; href=&quot;https://cs.chromium.org/chromium/&quot;&gt;chromium&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;//&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/&quot;&gt;src&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/base/&quot;&gt;base&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/base/message_loop/&quot;&gt;message_loop&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;a class=&quot;v-f&quot; href=&quot;https://cs.chromium.org/chromium/src/base/message_loop/incoming_task_queue.h&quot;&gt;incoming_task_queue.h&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 217行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Queue for initial triaging of tasks on the |sequence_checker_| sequence.&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  TriageQueue triage_tasks_;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Queue for delayed tasks on the |sequence_checker_| sequence.&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;  DelayedQueue delayed_tasks_;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Queue for non-nestable deferred tasks on the |sequence_checker_| sequence.&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;   DeferredQueue deferred_tasks_;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1、TriageQueue&lt;/p&gt;
&lt;p&gt;     这是第一个按默认的任务处理顺序（FIFO）接受所有任务的队列，这个队列的任务要马上执行或者放到下面的&lt;span&gt;DelayedQueue&lt;/span&gt; 或者 DeferredQueue。&lt;/p&gt;
&lt;p&gt;     triage_tasks_队列的任务是通过 &lt;span class=&quot;f-b&quot;&gt;IncomingTaskQueue&lt;/span&gt;::&lt;span class=&quot;f-b&quot;&gt;ReloadWorkQueue(&lt;span class=&quot;f-b&quot;&gt;TaskQueue&lt;/span&gt;&lt;a class=&quot;f-b&quot; href=&quot;https://cs.chromium.org/chromium/src/out/Debug/GENERATED/figments/cpp/PointerTo/start-with-ba/base/TaskQueue.cc?l=3&amp;amp;ct=xref_jump_to_def&amp;amp;gsn=*&quot;&gt;*&lt;/a&gt; &lt;span class=&quot;f-b&quot;&gt;work_queue&lt;/span&gt;)来实现切换的，可以将 incoming_queue_ 和 triage_tasks_看成冷热备份的缓存，在triage_tasks_队列的任务执行完了，即为空时，就将待执行的incoming_queue_队列的任务与之交换。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; IncomingTaskQueue::TriageQueue::ReloadFromIncomingQueueIfEmpty() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (queue_.empty()) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO(robliao): Since these high resolution tasks aren't yet in the
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; delayed queue, they technically shouldn't trigger high resolution timers
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; until they are.&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     outer_-&amp;gt;pending_high_res_tasks_ += outer_-&amp;gt;ReloadWorkQueue(&amp;amp;&lt;span&gt;queue_);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、&lt;span&gt;DelayedQueue&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     这个队列是存放延迟执行的任务，并且按期望时间排序的&lt;/p&gt;
&lt;p&gt;     delayed_tasks_是一个优先级队列，按delayed_run_time排序，&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a class=&quot;packageName&quot; href=&quot;https://cs.chromium.org/chromium/&quot;&gt;chromium&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;//&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/&quot;&gt;src&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/base/&quot;&gt;base&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;a class=&quot;v-f&quot; href=&quot;https://cs.chromium.org/chromium/src/base/pending_task.h&quot;&gt;pending_task.h 63行&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; PendingTasks are sorted by their |delayed_run_time| property.&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; DelayedTaskQueue = std::priority_queue&amp;lt;&lt;span&gt;base&lt;/span&gt;::PendingTask&amp;gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、DeferredQueue&lt;/p&gt;
&lt;p&gt;     这个队列通常是存放哪些因为MessageLoop嵌套而不能执行的任务，这些任务通常会在空闲的时候执行。&lt;/p&gt;
&lt;p&gt;OK，看到这里，我们回顾一下MessageLoop的执行流程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; MessageLoop::Run() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   DCHECK_EQ(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, current());
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   pump_-&amp;gt;Run(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由MessagePump来执行，那么我们选择默认的MessagePump来看Run的流程，&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a class=&quot;packageName&quot; href=&quot;https://cs.chromium.org/chromium/&quot;&gt;chromium&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;//&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/&quot;&gt;src&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/base/&quot;&gt;base&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/base/message_loop/&quot;&gt;message_loop&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;a class=&quot;v-f&quot; href=&quot;https://cs.chromium.org/chromium/src/base/message_loop/message_pump_default.cc&quot;&gt;message_pump_default.cc&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 29行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_d375565b-0bf2-44c2-8c81-cf18b3a00cee&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d375565b-0bf2-44c2-8c81-cf18b3a00cee&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d375565b-0bf2-44c2-8c81-cf18b3a00cee&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; MessagePumpDefault::Run(Delegate* &lt;span&gt;delegate&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   AutoReset&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt; auto_reset_keep_running(&amp;amp;keep_running_, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; defined(OS_MACOSX)
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    mac::ScopedNSAutoreleasePool autorelease_pool;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; did_work = &lt;span&gt;delegate&lt;/span&gt;-&amp;gt;&lt;span&gt;DoWork();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;keep_running_)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     did_work |= &lt;span&gt;delegate&lt;/span&gt;-&amp;gt;DoDelayedWork(&amp;amp;&lt;span&gt;delayed_work_time_);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;keep_running_)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (did_work)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     did_work = &lt;span&gt;delegate&lt;/span&gt;-&amp;gt;&lt;span&gt;DoIdleWork();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;keep_running_)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;       &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (did_work)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;       &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    ThreadRestrictions::ScopedAllowWait allow_wait;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delayed_work_time_.is_null()) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;      event_.Wait();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;      event_.TimedWaitUntil(delayed_work_time_);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;其中的流程是，delegate-&amp;gt;DoWork()， delegate-&amp;gt;DoDelayedWork(&amp;amp;delayed_work_time_)，delegate-&amp;gt;DoIdleWork()。&lt;/p&gt;
&lt;p&gt;也可以看其他平台的MessagePump，主要的流程是一致的，都是&lt;span&gt;delegate&lt;/span&gt;的函数，而&lt;span&gt;delegate&lt;/span&gt;指向一个MessageLoop指针，那么又回到MessageLoop中。&lt;/p&gt;
&lt;p&gt;上面具体的DoWork就不详述了，接下来看看延迟任务是如何实现的：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a class=&quot;packageName&quot; href=&quot;https://cs.chromium.org/chromium/&quot;&gt;chromium&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;//&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/&quot;&gt;src&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b v-i&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/base/&quot;&gt;base&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;span class=&quot;v-b&quot;&gt;&lt;a href=&quot;https://cs.chromium.org/chromium/src/base/message_loop/&quot;&gt;message_loop&lt;/a&gt;&lt;span class=&quot;v-j&quot;&gt;/&lt;a class=&quot;v-f&quot; href=&quot;https://cs.chromium.org/chromium/src/base/message_loop/message_loop.cc&quot;&gt;message_loop.cc 473行&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
TimeTicks next_run_time =&lt;span&gt;
      incoming_task_queue_&lt;/span&gt;-&amp;gt;&lt;span&gt;delayed_tasks().Peek().delayed_run_time;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next_run_time &amp;gt;&lt;span&gt; recent_time_) {
    recent_time_ &lt;/span&gt;= TimeTicks::Now();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Get a better view of Now();&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (next_run_time &amp;gt;&lt;span&gt; recent_time_) {
      &lt;/span&gt;*next_delayed_work_time =&lt;span&gt; next_run_time;
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
  }

  PendingTask pending_task &lt;/span&gt;= incoming_task_queue_-&amp;gt;&lt;span&gt;delayed_tasks().Pop();

  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (incoming_task_queue_-&amp;gt;&lt;span&gt;delayed_tasks().HasTasks()) {
    &lt;/span&gt;*next_delayed_work_time =&lt;span&gt;
        incoming_task_queue_&lt;/span&gt;-&amp;gt;&lt;span&gt;delayed_tasks().Peek().delayed_run_time;
  }

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; DeferOrRunPendingTask(std::move(pending_task));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在下一个可执行时间到来了，就会从incoming_task_queue_-&amp;gt;&lt;span&gt;delayed_tasks().Pop() 出来一个task， 如果incoming_task_queue_-&amp;gt;&lt;span&gt;delayed_tasks()&lt;/span&gt;里还有延迟任务，就取里面优先级最高的任务的延迟时间作为下次判断的时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到这里，消息的处理和延迟任务的执行都完成了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，回到上面的Run（）函数流程，在&lt;span class=&quot;f-b f-L&quot;&gt;DoIdleWork&lt;/span&gt;()完成之后，当前线程开始休眠，直到有新的任务来会重新唤醒。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;嗯，这篇就到这里了，下面一篇会总结IPC消息声明和IPC channel的创建。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 19 Oct 2017 07:15:00 +0000</pubDate>
<dc:creator>丹西</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/danxi/p/7691206.html</dc:identifier>
</item>
<item>
<title>【计算机网络】聊一聊那些常见的网络通信的性能指标 - 外婆的彭湖湾</title>
<link>http://www.cnblogs.com/penghuwan/p/7692573.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/penghuwan/p/7692573.html</guid>
<description>&lt;h2&gt;&lt;span&gt;带宽&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;信道传输的是电磁波信号，而电磁波是有一定的频率范围，带宽指的就是这段有效的频率范围的值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即：带宽 = 最高有效频率 - 最低有效频率&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好比我们人的耳朵能听见一定频率范围内的声音（20 -20000Hz）,那么19000Hz就是我们耳朵的“带宽”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不同的信道，其带宽（频率范围）是不一样的，根据带宽的不同，可将信道划分为窄带信道（0 - 300Hz）, 音频信道（300 - 3400Hz）和宽带信道（带宽为3400Hz以上）。我们平常说的“装宽带”，意思就是安装3400Hz以上带宽的信道的意思&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;数据传输速率&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据传输速率信道每秒能传输的比特数，所以它的单位自然就是bps(比特每秒)，除此外还有Kbps,Mbps等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;【注意】理论分析证明，信道的最大数据传输速率和带宽有直接联系，信道带宽越宽，数据传输速率就越大，因此在许多情况下，“带宽”和“传输速率”是可以互换的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;时延&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以&lt;strong&gt;分组交换网络&lt;/strong&gt;的时延为例（因为当前因特网和计算机网络主要采用的数据交换技术是分组交换）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;时延&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当一个分组在节点间传输时，主要的时延分为四种类型： &lt;strong&gt;节点处理时延&lt;/strong&gt;（nodal processing delay），&lt;strong&gt;排队时延&lt;/strong&gt;(queuing delay)，&lt;strong&gt;传输时延&lt;/strong&gt;(transmission delay)和&lt;strong&gt;传播时延&lt;/strong&gt;(propagation delay)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果将这四种类型的时延分别表示为d(proc),  d(queue),d(trans), d(prop)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;则&lt;strong&gt;对一个分组&lt;/strong&gt;而言，&lt;strong&gt;两个节点间&lt;/strong&gt;的总时延d = d(proc) + d(queue)  + d(trans) + d(prop)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设发送端到接收端间有&lt;strong&gt;N条链路&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;则对一个分组而言，&lt;span&gt;忽略其他因素&lt;/span&gt;，端到端总时延d(end-end) = N × (   d(proc) + d(queue)  + d(trans) + d(prop)  )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面我将从单个分组从路由器A到相邻的路由器B的传输的情况入手，分别介绍这四种不同类型的时延&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图示如下：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/898ee65b31604005b358e2322a6d3cc0/jf4%2560d19%257Bzja@%257B6a%2529%2528ibpw5p.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;00794917BB3A4775B3496B316082657D&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201710/1060770-20171019145617865-158660760.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;处理时延&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;当分组到达路由器A时，首先要做的是检查分组首部并决定将该分组导向何处，并检查比特级差错，这部分的时间消耗叫做处理时延。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;排队时延&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;分组在经过路由器A的处理后，下一步就是传输出去。一个分组的排队时延取决于&lt;strong&gt;先到达的，正在排队&lt;/strong&gt;等待向链路传输的分组的&lt;strong&gt;数量&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.&lt;/strong&gt;如果前面没有分组正在从路由器A向链路传输的话，排队时延为0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.&lt;/strong&gt;如果流量很大，前面有很多分组正在传输或也在等待传输，那么就要消耗很大的排队时延了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;传输时延&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;传输时延是路由器A将分组的所有比特推出路由器A，推向链路所需要的时间。传输时延取决于两个因素：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.&lt;/strong&gt; 单个分组长度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.&lt;/strong&gt; 数据传输速率&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设分组的长度为L比特，数据传输速率为R (bps) 那么  传输时延 = L/R&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【注意】传输时延又叫做存储转发时延&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;传播时延&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（这个概念听起来和传输时延很相似，区别我下面会讲）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;传播时延指的是分组的一个比特从路由器A到达到路由器B所需要的时间，传播时延取决于两个因素：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.&lt;/strong&gt;链路介质（双绞线，光纤）的传播速率&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.&lt;/strong&gt; 节点间的距离（两个路由器间的距离）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设路由A，B距离为d, 链路介质传播速率为s，那么传播时延 = d/s&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;传输时延和传播时延的比较&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们把一个分组从路由器A传输到路由器B的过程，比作一批车队（10辆汽车）， 全部从收费站A行驶到收费站B的过程（&lt;strong&gt;中间经过高速公路&lt;/strong&gt;）&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201710/1060770-20171019145658271-1703830330.png&quot; alt=&quot;&quot; width=&quot;470&quot; height=&quot;147&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/833701b562a54ad3bd51a9363bdbc21c/blnnwiba278tjfzs%255Do4dkcf.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;663839A70EED4EC4BF82A0BACD818611&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一批车队 == 一个分组&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一辆汽车 == 一个比特&lt;/strong&gt; （暂时不管分组长度是否合理）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;收费站A，B == 路由器A，B&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这批车队&lt;span&gt;遵守一个“奇怪”的规则&lt;/span&gt;，那就是无论哪一辆汽车先到达收费站Ａ，&lt;strong&gt;它都必须等待其他９辆汽车也都尾随其后到达了Ａ，才带领这批车队依次驶出收费站Ａ&lt;/strong&gt;。（这就是&lt;strong&gt;存储转发机制&lt;/strong&gt;，只有&lt;strong&gt;当一个分组的所有比特都到达了路由器，“存储完毕“后，才能转发整个分组&lt;/strong&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;传输时延&lt;/strong&gt;就是这批车队依次（前后紧跟）地驶出收费站Ａ所用的时间（将分组的所有比特推出路由器A，推向链路所用的时间）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;传播时延&lt;/strong&gt;就是每辆汽车经过高速公路，从收费站Ａ到达收费站Ｂ所用的时间（分组的一个比特从路由器A到达到路由器B所需要的时间）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设收费站办理手续，通过汽车的效率是 5 （辆/每分钟），而汽车在高速公路上行驶速度是100km/h。那么，因为两个收费站间距离为100km，一批汽车有10辆&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以得出，这批汽车通过收费站所用的时间为10辆 ÷ 5（辆/每分钟） = 2分 （传输时延）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;汽车在高速公路上行驶所用的时间为100km ÷  100km/h = 1h （传播时延）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总共用时62分钟&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;丢包率&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;丢包意为分组丢失，什么原因会导致分组丢失呢？ 这和我们上面所说的”排队时延“有关，我们说到：当大量分组在短时间内到达路由器的时候，因为无法一次性处理完毕，分组需要”排队“，但是基于路由器的设计和成本，分组队列的长度是有限的&lt;strong&gt;。所以，当队列满了的时候，下一个分组到达的时候，路由器会选择丢弃（drop）该分组&lt;/strong&gt;, 这个分组便丢失了（lost），这就是所谓的丢包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;丢包率与&lt;strong&gt;分组长度&lt;/strong&gt;以及&lt;strong&gt;分组发送频率&lt;/strong&gt;相关。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;吞吐量&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;吞吐量的单位和数据传输速率一样，也是bps，&lt;span&gt;所以它虽然名为“量”，其实也还是一种“速率”&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;瞬时吞吐量和平均吞吐量&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;从服务器到客户机通过计算机网络传送一个大文件，任意时刻客户机接收该文件的速率叫做瞬时吞吐量（instantaneous throughput）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设客户机接收该文件的所有F比特用了T秒，那么 F/T就叫做平均吞吐量（average throughput）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;吞吐量 == 瓶颈链路的传输速率&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;吞吐量等于瓶颈链路（bottle link）的传输速率&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们考虑下图中尽可能简单的情况，R(s)表示服务器和路由器之间的链路速率，R(c)表示路由器和客户机之间的链路速率，显然，该服务器不能以快于R(s)的速率向链路中输送比特，路由器也不能以快于R(c)的速率转发比特。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/3aed6215791649f2b1ee2e6022d60f98/ctn)ies76(2poib_1lq)s%25c.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;01120D387FCC4725988DC263BA63A0F0&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201710/1060770-20171019145735740-1398177016.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果R(s) &amp;lt; R(c),那么服务器输送的比特能够&quot;畅快地&quot;通过路由器和客户机间的链路到达客户机。速率为R(s)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果R(s) &amp;gt; R(c) 则因为路由器将不能以接收的速率转发比特，所以链路速率为R(c)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以 上图中吞吐量为min{ Rc, Rs } bps&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同样的，对下面这n条链路&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201710/1060770-20171019145751084-306040298.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/c0bbe8cb192c4427ab1c85a57fd9ee28/9j%7Bpli0bz%5Dgw%60sl$5$bj%7Bzu.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;9E07E26D18B849E6A9DFD1EE6634B37F&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;吞吐量为min{ R1, R2, ... Rn }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;误码率&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;误码率是衡量通信系统传输可靠性的指标，它指的是错误接收的码元数在所传输的总码元数的比例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计算公式： &lt;strong&gt;误码率=错误码元数/传输总码元数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;参考书籍&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;《计算机网络-自顶向下》  作者 James F. Kurose&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《计算机网络技术基础教程》作者 刘四清&lt;/span&gt;&lt;/p&gt;



&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201710/1060770-20171019145940849-1453018301.jpg&quot; alt=&quot;&quot; width=&quot;410&quot; height=&quot;379&quot;/&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 19 Oct 2017 07:03:00 +0000</pubDate>
<dc:creator>外婆的彭湖湾</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/penghuwan/p/7692573.html</dc:identifier>
</item>
<item>
<title>JavaScript适配器模式 - 与你在巅峰相会</title>
<link>http://www.cnblogs.com/bfwbfw/p/7692437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bfwbfw/p/7692437.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;&lt;span&gt;适配模式可用来在现有接口和不兼容的类之间进行适配，使用这种模式的对象又叫包装器（wrapper），因为它们是在用一个新的接口包装另一个对象。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;基本理论&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;适配器模式：将一个接口转换成客户端需要的接口而不需要去修改客户端代码，使得不兼容的代码可以一起工作。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;适配器主要有3个角色组成：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（1）客户端：调用接口的类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（2）适配器：用来连接客户端接口和提供服务的接口的类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（3）适配者：提供服务，但是却与客户端接口需求不兼容服务类。&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&lt;span&gt;此处 有一个实例是关于两个数的加法的。&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;一，先有一个能够实现，两个数加法的服务和客户端。&lt;br/&gt;（1）先引入接口检验类----检查实现该接口的类是否实现了接口中所用方法。&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(定义一个静态方法来实现接口与实现类的直接检验
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态方法不要写出Interface.prototype ,因为这是写到接口的原型链上的
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们要把静态的函数直接写到类层次上
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个接口类&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; Interface=function (name,methods) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;name：接口名字&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(arguments.length&amp;lt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;){
        alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;必须是两个参数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.methods=[];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个空数组装载函数名&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;methods.length;i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt;  methods[i]!=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;){
            alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;函数名必须是字符串类型&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.methods.push( methods[i]);
        }
    }
};
Interface.ensureImplement&lt;/span&gt;=function (&lt;span&gt;object&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arguments.length&amp;lt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;参数必须不少于2个&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;arguments.length;i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; inter=&lt;span&gt;arguments[i];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是接口就必须是Interface类型&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(inter.constructor!=&lt;span&gt;Interface){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;如果是接口类的话，就必须是Interface类型&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断接口中的方法是否全部实现
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历函数集合&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;inter.methods.length;j++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; method=inter.methods[j];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接口中所有函数

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;object[method]传入的函数
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最终是判断传入的函数是否与接口中所用函数匹配&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;object&lt;/span&gt;[method]||&lt;span&gt;typeof&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[method]!=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现类中必须有方法名字与接口中所用方法名相同&lt;/span&gt;
                &lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;实现类中没有完全实现接口中的所有方法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;（2）使用接口类同一接口&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; InterfaceResult=&lt;span&gt;new&lt;/span&gt; Interface(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InterfaceResult&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  （3）服务端两个数的加法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function First() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.add=&lt;span&gt;function (x,y) {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x+&lt;span&gt;y;
        }
        Interface.ensureImplement(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,InterfaceResult);//接口检验
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; （4）客户端调用服务端代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; first=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; First();
   alert(first.add(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;)) ;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;二，现在有一个要求就是，需要换一个类库，但是客户端的程序不希望有大的改动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）依然继承相同接口的基础上，类库为&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function Second() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.add=&lt;span&gt;function (numberList) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[1,2,3]  &quot;1+2+3&quot;  eval(&quot;1+2+3&quot;)&lt;/span&gt;
           &lt;span&gt;return&lt;/span&gt; eval(numberList.join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        }
        Interface.ensureImplement(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,InterfaceResult);//检验当前类是否完全实现接口中的方法
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们如果需要使用该类库的话，客户端又不能该，那么用和之前的调用方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; second=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Second();
alert(second.add(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;));//已经不能这样使用了
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是完全不符合客户端的要求的。为了在保证客户端不变的情况下，又能使用新的类库，我们需要使用适配器模式。&lt;span&gt;现在接口发生了变化，使用适配器兼容，以便适应客户端的不变&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;使客户端与新的接口相会兼容。&lt;br/&gt;&lt;span&gt;（2）适配器&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  function ThirdWarpper() {
             &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.add=&lt;span&gt;function (x,y) {
                 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array();
                 arr.push(x);
                 arr.push(y);
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;  Second().add(arr);
             }
             Interface.ensureImplement(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,InterfaceResult);
         }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;（3）客户端代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户端&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; third=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThirdWarpper();
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result= third.add(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传递数&lt;/span&gt;
     alert(result);
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&lt;span&gt;针对上述的使用新的类库后的图解为：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/860581/201710/860581-20171019150333334-1749081114.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;br/&gt;总结，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;从表面上看，适配器模式很像外观模式。它们都要对别的对象进行包装并改变其呈现的接口。二者的差别在于它们如何改变接口。外观元素展现的是一个简化的接口，它并不提供&lt;span&gt;额外&lt;/span&gt;的选择，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;而且有时为了方便完成常见任务它还会做出一些假定。而适配器则要把一个接口转换为另一个接口，它并不会滤除某些能力，也不会简化接口。&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 19 Oct 2017 06:57:00 +0000</pubDate>
<dc:creator>与你在巅峰相会</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bfwbfw/p/7692437.html</dc:identifier>
</item>
<item>
<title>机器翻译评测——评测集的艰难制作分析过程 - 胖喵~</title>
<link>http://www.cnblogs.com/by-dream/p/7683126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/by-dream/p/7683126.html</guid>
<description>&lt;p&gt;　　◆&lt;strong&gt;版权声明：本文出自胖喵~的博客，转载必须注明出处。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　转载请注明出处：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 机器翻译评测——评测集的艰难制作分析过程&quot; href=&quot;http://www.cnblogs.com/by-dream/p/7683126.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/by-dream/p/7683126.html&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　机器翻译的评测，很大程度上会依赖评测集。制作一份好的评测集，远远没有我们想象的那么简单。&lt;/p&gt;
&lt;p&gt;　　今天我就将自己制作评测集的经验分享给大家。以一个制作“几十句口语关于天气的英中评测集”为例。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;收集原句&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;首先收集指定数量的讨论天气的口语句子。这些句子都是都是通过花钱，找国外的朋友帮忙收集来的，因此这些英文句子非常的native。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;人工评价&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;将收集来的原句用目前当下比较流行的翻译引擎翻译了一遍。这里选取了百度、有道、搜狗、google、腾讯翻译君nmt2.0，然后将机器翻译结果生成一个评测问卷，针对译文的质量进行一个1—5分的打分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/626346/201710/626346-20171017180228177-505110643.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　一般打分需要专业的人士来打，并且对他们的结果进行一个相关度的计算，剔除非法的数据，这个过程我就不细说了。这是打分后的一个统计结果如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/626346/201710/626346-20171019102825271-1256018936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到腾讯翻译君的翻译质量是最高的，人工可接受度达到了91%，其次分别是百度、有道、搜狗和google。因此我们的评测集在BLEU上的相关性也需要和这个结果保持一致。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;译文制作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　接下来了解了各个翻译引擎的好坏后，我们就可以开始制作评测集了，首先找专业的译员对原句进行翻译制作评测集，这里我找了英语专业的学生对原文进行了翻译。然后我们用她翻译的结果做为译文，进行制作参考答案，这里需要注意的是，由于BLEU算法的特性，因此中文的译文需要按单字切词：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
例如：“这个月的18号，我要去一趟Atlanta。” 转化后为 “这 个 月 的 18 号 ，我 要 去 一 趟 Atlanta 。 ”
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后针对翻译结果进行BLEU值的计算。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/626346/201710/626346-20171019103344834-1768308428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　很明显这个结果和人工评价的结果相差过大，那么究竟问题出在哪里了呢？&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;译文分析、修改、迭代&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　根据BLEU算法的特性，我们知道BLEU的分值高低取决于翻译译文和参考译文之间的相似度。于是我简单看了一下，发现可能是句子过于短，ref的答案过于单一，不够丰富导致的分值上有所差异，因此又增加了几个ref的制作，具体是在各个翻译引擎翻译的基础上，又进行修改，得到高质量的译文。总共下来一共制作了9分ref。&lt;/p&gt;
&lt;p&gt;　　此时得到的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/626346/201710/626346-20171019103452506-986902728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　可以看到，和之前相比较分值虽然高了，但是和人工评价的一致性还是比较差，因此我们就需要对单句进行分析，看看具体是哪些句子造成了影响。&lt;br/&gt;　　这里我用python的nltk实现了一个BLEU单句分析的脚本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;-*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; nltk
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; codecs

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 功能：传入计算译文单句BLEU的功能&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 调用方式：python 脚本.py 参考答案1+参考答案2 要分析的译文 &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 参数一：可以是多份译文例如 t_tmq_ref0+t_tmq_ref1 用+连接即可&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 参数二：要计算的译文&lt;/span&gt;

&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
nltk 简单用法
print nltk.translate.bleu_score.corpus_bleu(['把 卷 子 往 后 传'], ['把 这 些 纸 往 后 传 。'],['把 这 些 床 单 递 回 去 。'] )
print nltk.translate.bleu_score.corpus_bleu(['天 气 很 好'], ['天 气 很 不 错'])
print nltk.translate.bleu_score.sentence_bleu('天 气 非 常 不 错', '天 气 很 不 错' )
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

reffiles &lt;/span&gt;= sys.argv[1&lt;span&gt;]
file2 &lt;/span&gt;= sys.argv[2&lt;span&gt;]

list_all_ref &lt;/span&gt;=&lt;span&gt; []
list2 &lt;/span&gt;=&lt;span&gt; []

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取译文&lt;/span&gt;
i =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; sen &lt;span&gt;in&lt;/span&gt;&lt;span&gt; open(file2):
    sen &lt;/span&gt;=&lt;span&gt; sen.strip()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; sen:
        list2.append(sen)
        i &lt;/span&gt;= i+1
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; i, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取ref&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; reffile &lt;span&gt;in&lt;/span&gt; reffiles.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
    list_ref &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; open(reffile):
        line &lt;/span&gt;=&lt;span&gt; line.strip()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; line:
            list_ref.append(line)
    list_all_ref.append(list_ref)
    
setnum &lt;/span&gt;=&lt;span&gt; len(list_all_ref)
sentencenum &lt;/span&gt;=&lt;span&gt; len(list_all_ref[0])

log &lt;/span&gt;= codecs.open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;res_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+file2 , &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 单句计算&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(0, sentencenum):
    refs &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(0, setnum):
        refs.append(list_all_ref[i][j])
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print refs&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print list2[j]&lt;/span&gt;
        BLEUscore =&lt;span&gt; nltk.translate.bleu_score.corpus_bleu([refs], [list2[j]])

        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; j, BLEUscore
        log.write(str(BLEUscore)&lt;/span&gt;+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;except!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,e
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　利用脚本计算结果，如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/626346/201710/626346-20171019104135365-784134633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第一列是百度的译文，第二列是百度单句的一个BLEU得分，第三列是腾讯翻译君nmt2.0的BLEU得分，第四列是翻译君的译文。我们可以通过看句子找到一些分值不合理的句子，用红色标注。&lt;/p&gt;
&lt;p&gt;　　例如下面这句，很明显百度的翻译没有翻译君的好，但是BLEU分值却高。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/626346/201710/626346-20171019104745443-1552615464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　经过检查参考译文，发现有一份参考译文中有低质量的翻译句子。于是我们需要对这些句子再进行修改。当然如果人力不足和时间不足的情况下，这种现象无法避免。虽然可以通过要求第一遍制作就不出这些问题，但是真的很难。这里之所以列出这个方法，也是想说明，如果遇到这样的问题，可以通过这样一种方法来分析并且可以知道译文是否的可靠。&lt;/p&gt;
&lt;p&gt;　　好，我们根据刚才所说的方法，修正完所有的译文后，再次重新计算bleu。&lt;/p&gt;
&lt;p&gt;　　修正后的 百度和nmt2.0的分值对比为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;p&gt;nmt2.0&lt;br/&gt;BLEU = 77.71, 93.4/84.5/76.0/64.9 (BP=0.984, ratio=0.984, hyp_len=364, ref_len=370)&lt;br/&gt;baidu&lt;br/&gt;BLEU = 76.96, 92.4/82.4/73.1/64.4 (BP=0.995, ratio=0.995, hyp_len=369, ref_len=371)&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; 　　从分值排名来看，这次更符合实际了，因此用同样的方法处理了剩余的，最终得到了如下结果（注意这里的结果采取的是去掉和引擎相关的ref计算的BLEU，因此是两两比较）：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/626346/201710/626346-20171019141355631-536582223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　根据分值，我们简单看下和人工评价的相关性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/626346/201710/626346-20171018142255052-133042511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　很明显，在百度和nmt2.0的比较重相关性不是高，于是我在想，是不是当时在中文分词的时候影响了最终的数据结果，于是我决定用分词代替中文单词切词的方式，再计算一次BLEU。&lt;/p&gt;
&lt;p&gt;　　这次分词效果和之前不一样的是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
例如：“这个月的18号，我要去一趟Atlanta。” 转化后为 “ 这个月 的 18号 ， 我 要去 一趟 Atlanta 。 ”
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　计算的BLEU结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/626346/201710/626346-20171019141455927-1184603421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这次可以看到nmt2.0和百度的分值已经稍微有些拉开了，但是有道和百度的排名却换了一个位置。于是针对有道和百度，我对每个句子又进行了单句BLEU的分析，以及将人工评价的打分也列到这里进行对比：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/626346/201710/626346-20171019141737802-1772289094.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我们单看上图中标注的这句话，这句话应该被正确翻译为 “ 我希望天气能一直保持温暖 ” ，因此人工评价的时候，考虑到“天气”这个重要的词没有被翻译出来，因此给打了2分，但是BLEU算法匹配到了大部分的词，只是少了天气，因此BLEU给出的分值不会很低，要比人工评价的结果高。因此我们看出BLEU算法针对翻译的流畅度评价是一个比较好的打分，但是对于一些核心词语的翻译的重视度，BLEU算法却忽略了，因此我觉得百度和有道的差距应该就在这里了 。&lt;/p&gt;
&lt;p&gt;　　至此我们就算完成了一份偏流畅度的关于天气口语评测的评测集。&lt;span&gt;&lt;em&gt;（&lt;a href=&quot;https://share.weiyun.com/9ecb0e88196f424e7b2e46614b210dd6&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;所有数据&lt;/span&gt;&lt;/a&gt;）&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 19 Oct 2017 06:45:00 +0000</pubDate>
<dc:creator>胖喵~</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/by-dream/p/7683126.html</dc:identifier>
</item>
<item>
<title>WebApi系列~HttpClient的性能隐患 - 张占岭</title>
<link>http://www.cnblogs.com/lori/p/7692152.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lori/p/7692152.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/lori/p/4500882.html&quot; target=&quot;_blank&quot;&gt;回到目录&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最近在进行开发过程中，基于都是接口开发，A站接口访问B接口接口来请求数据，而在这个过程中我们使用的是HttpClient这个框架，当然也是微软自己的框架，性能当前没有问题，但如果你直接使用官方的写法，在高并发时候，会有很大的性能隐患，因为它官方使用的是using的方式，而对于请求量比较大时，这种方法对TCP建立也会过高，即使用完马上释放也会有很多time_out的请求，所有决定把某个用到httpclient的组件做成静态化的！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;明细&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/118538/201710/118538-20171019135023271-435057086.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;统计&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/118538/201710/118538-20171019135112974-235290420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用，中规中矩的写法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; http = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient())
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; json = JsonConvert.SerializeObject(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;
                    {
                        target_index &lt;/span&gt;=&lt;span&gt; projectName,
                        timestamp &lt;/span&gt;= DateTime.Now.ToUniversalTime().ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-ddTHH:mm:ss.fffZ&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                        Level &lt;/span&gt;=&lt;span&gt; level.ToString(),
                        Message &lt;/span&gt;=&lt;span&gt; message
                    });
                    json &lt;/span&gt;= json.Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;target_index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@target_index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@timestamp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; httpContent = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringContent(json, Encoding.UTF8);
                    httpContent.Headers.ContentType &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MediaTypeHeaderValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; http.PostAsync(apiLoggerUri, httpContent).Result;
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 优化它，做成TCP长链接，所以请求走一个通道&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; HttpClient _httpClient;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ApiLoggerOptions _config;

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; ApiLogger()
        {
            _httpClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
            _httpClient.Timeout &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TimeSpan(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
            _httpClient.DefaultRequestHeaders.Connection.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;keep-alive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;keep-alive&lt;/span&gt;关键字可以理解为一个长链接，超时时间也可以在上面进行设置，例如10秒的超时时间，当然并发量太大，这个10秒应该会抛弃很多请求&lt;/p&gt;
&lt;p&gt;发送请求的代码没有了using，即这个httpclient不会被手动dispose，而是由系统控制它，当然你的程序重启时，这也就被回收了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;var&lt;/span&gt; json = JsonConvert.SerializeObject(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;
                {
                    target_index &lt;/span&gt;=&lt;span&gt; projectName,
                    timestamp &lt;/span&gt;= DateTime.Now.ToUniversalTime().ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-ddTHH:mm:ss.fffZ&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                    Level &lt;/span&gt;=&lt;span&gt; level.ToString(),
                    Message &lt;/span&gt;=&lt;span&gt; message
                });
                json &lt;/span&gt;= json.Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;target_index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@target_index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@timestamp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; httpContent = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringContent(json, Encoding.UTF8);
                httpContent.Headers.ContentType &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MediaTypeHeaderValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                _httpClient.PostAsync(apiLoggerUri, httpContent).Wait();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面的改造，我们我系统性能得到了改善，TCP的连接数也降下来了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/118538/201710/118538-20171019140007787-599137492.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以对于长链接的多路复用技术，相对于请求过多的情况还是最省资源的！&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://www.cnblogs.com/lori/p/4500882.html&quot; target=&quot;_blank&quot;&gt;回到目录&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 19 Oct 2017 06:03:00 +0000</pubDate>
<dc:creator>张占岭</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lori/p/7692152.html</dc:identifier>
</item>
<item>
<title>使用WinDBG调试查看C#内存转储文件 - asml</title>
<link>http://www.cnblogs.com/DragonStart/p/7692102.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DragonStart/p/7692102.html</guid>
<description>&lt;p&gt;有时候我们想查看一个正在运行的程序内存中的数据,可以在任务管理器将内存状态保存为转储文件,并使用WinDBG验证,这里我们来试试:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201710/481370-20171019113822646-914061404.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;一个class&quot;&gt;一个class&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class MyClass
{
    public int AintValue = 123;
    public static int BintValue = 456;
    public string AstringValue = &quot;AAA&quot;;
    public static string BstringValue = &quot;BBB&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;在main中引用&quot;&gt;在main中引用&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Console.WriteLine($&quot;ret={d1(1)}&quot;);
MyClass MC = new MyClass();
MC.AstringValue = &quot;SuperAAAA&quot;;
Console.ReadKey(true);//程序会停在这,这时候保存文件
Console.Write(MC.AstringValue);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201710/481370-20171019114341599-1111509094.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点这里:&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201710/481370-20171019114637521-901173438.png&quot;/&gt;&lt;br/&gt;这里,然后选文件:&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201710/481370-20171019114653974-1590486991.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里需要注意的是:&lt;br/&gt;32位的WinDBG用来调试32位的程序dump文件,&lt;br/&gt;64位的WInDBG用来调试64位的程序dump文件,&lt;br/&gt;如果你跟我一样用的是UWP版的WinDBG,那只能调试64位的(一定有办法能调32位的,但我不知道,如果你知道,请回复,感谢~)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201710/481370-20171019115025209-442280676.png&quot;/&gt;&lt;br/&gt;我们可以看到中间有个命令输入框:&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201710/481370-20171019115123615-843364910.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先输入两个命令,加载两个.net调试相关文件:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.load C:\Windows\Microsoft.NET\Framework64\v4.0.30319\SOS.dll
.load C:\Windows\Microsoft.NET\Framework64\v4.0.30319\clr.dll&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;notice:中间有个目录是Framework64,如果是调试32位程序,改为Framework&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201710/481370-20171019115239865-1505691001.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加载成功.&lt;br/&gt;在上面的C#代码中,我们声明了一个类 &lt;em&gt;MyClass&lt;/em&gt; ,并实例化了它,现在我们要找到它,在windbg里,搜索类有两种方式:&lt;br/&gt;1:根据类名 (有可能重复)&lt;br/&gt;2:根据MT(Methot Table,唯一)&lt;br/&gt;刚开始是不知道MT的,所以根据类名搜索:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;!dumpheap -type MyClass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;notice:&quot;!dumpheap -type&quot;这部分不验证大小写,后面类名会验证大小写&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201710/481370-20171019115713224-1803723034.png&quot;/&gt;&lt;br/&gt;返回的内容,第一块是类的实例列表,第二块是对象列表(有时候名字很像的对象也会在这里)&lt;br/&gt;可以看到我们的对象只有一个,第一列是MT,如果你搜索出了多个,可以根据MT搜索:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;!DumpHeap -mt 00007ff9fc0a7488&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;从实例列表中可以看到这个类只有1个实例,数据格式是:&lt;br/&gt;内存地址 MT 占用内存长度&lt;br/&gt;我们可以从内存地址,查看这个实例的详细信息:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;!DumpObj /d 000002331f11bed0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;notice:DumpObj 可以简写为do&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201710/481370-20171019120228631-884598170.png&quot;/&gt;&lt;br/&gt;可以看到下面列出了对象的所有属性.包括静态的,动态的.&lt;/p&gt;
&lt;p&gt;值类型的属性直接显示了值&lt;br/&gt;引用类型的属性给出了引用地址&lt;/p&gt;
&lt;p&gt;对于string类型,我们还要再进一步:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;!DumpObj 000002331f112f18&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201710/481370-20171019133856834-105492911.png&quot;/&gt;&lt;br/&gt;就可以看到字符串值了,如果是byte[]数据,可以直接用 &quot;dd 内存起点 内存终点&quot; 进行查看,如果想解析成字符串可以用du命令(u表示按unicode解析)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dd 000002331f112f18+c 000002331f112f18+c+53
du 000002331f112f18+c 000002331f112f18+c+8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字符串数据前12个字节是字符串的属性,所以要过掉&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201710/481370-20171019134049709-1889750462.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 19 Oct 2017 05:54:00 +0000</pubDate>
<dc:creator>asml</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DragonStart/p/7692102.html</dc:identifier>
</item>
<item>
<title>设计模式(2)：观察者模式-2 （委托、事件） - 张居斜</title>
<link>http://www.cnblogs.com/yaolin1228/p/7690014.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaolin1228/p/7690014.html</guid>
<description>&lt;p&gt;一： 基本概念&lt;/p&gt;
&lt;p&gt;1、委托（Delegate)&lt;/p&gt;
&lt;p&gt;概念：对某个方法引用的一种引用类型变量。注意看概念， 委托是一种引用类型变量， 类型变量，因此可以将委托当作方法的参数进行传递。 通俗点来讲，委托有点像&lt;strong&gt;方法的快捷方式，&lt;/strong&gt; 通过委托可以执行方法。&lt;/p&gt;
&lt;p&gt;声明： 在类中声明， 其声明决定了该委托可用的方法。也就是说，委托只可指向具有相同标签（参数、返回值）的方法。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 声明委托&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; MyDelegate(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; s);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建方法&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; GetStart(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; testString);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例化委托, 调用的方法需与委托有相同的参数、返回值&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; MyDelegate &lt;span&gt;delegate&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; MyDelegate(GetStart);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、事件(Event)&lt;/p&gt;
&lt;p&gt;概念： 当某个类(&lt;strong&gt;发布者 Publisher&lt;/strong&gt;)的某些特定状态改变时，发送通知给所有关心它这个变化的其它类(&lt;strong&gt;订阅者 Subscriber&lt;/strong&gt;），并触发相关类中的相关函数。如按键、点击等都是事件。&lt;/p&gt;
&lt;p&gt;发布者： 决定什么时候触发事件。包含事件与委托的定义与声明，执行绑定了事件的方法（订阅者类中方法）。&lt;/p&gt;
&lt;p&gt;订阅者： 决定做什么事（提供具体方法）。 接受事件并提供事件处理程序的对象。&lt;/p&gt;
&lt;p&gt;事件声明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先声明事件的委托类型， 事件在生成时会调用委托&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; MyDelegateEventHandler(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; MyDelegateEventHandler MyEvent;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;二、事件在观察者模式中的应用&lt;/p&gt;
&lt;p&gt;举一个《Head First 设计模式》 上的经典应用，附件上有完整的代码。&lt;/p&gt;
&lt;p&gt;需求如下： 建立一个气象观测站，该气象站建立在 WeatherData 对象上， 由 WeatherData 对象负责追踪目前的天气状况（温度、湿度、气压）。我们要建立一个应用，有三种（或更多）布告板， 分别显示目前的状况、气象统计以及简单的预报。当 WeatherDataObject 对象获得最新的测量数据时， 三种布告板必须实时更新。并且希望这个气象站的扩展性良好。&lt;/p&gt;
&lt;p&gt;1、创建发布者类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发布者类&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WeatherData
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 声明事件&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; WeatherChangeEventHandler(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, WeatherChangeArgs e);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; WeatherChangeEventHandler WeatherChange;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 虚函数，使得派生类可重写触发事件的标准&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt;  &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onWeatherChange(WeatherChangeArgs e)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             WeatherChange?.Invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 事件一定要在方法中执行&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RaiseWeatherChange(WeatherChangeArgs e)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            onWeatherChange(e);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个事件类， 提供我们关心的数据的值&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WeatherChangeArgs : EventArgs
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; temperature;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; humidity;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; pressure;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; WeatherChangeArgs(&lt;span&gt;double&lt;/span&gt; temperature, &lt;span&gt;double&lt;/span&gt; humidity, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; pressure)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.temperature =&lt;span&gt; temperature;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.humidity =&lt;span&gt; humidity;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.pressure =&lt;span&gt; pressure;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;2、创建订阅者类&lt;/p&gt;
&lt;p&gt;订阅者数量众多，为了统一管理，需创建一个统一的接口，这也符合 OO 的原则， 面向接口编程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建订阅者统一接口 &lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IWeatherStationSubject
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; Display(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, WeatherChangeArgs e);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前状况显示面板&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CurrentConditionDisplay : IWeatherStationSubject
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; Display(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, WeatherChangeArgs e)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Current conditons:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + e.temperature + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;degreees and &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + e.humidity + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;% humidity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 未来预测天气状况显示面板&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ForecastDisplay : IWeatherStationSubject
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Display(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, WeatherChangeArgs e)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tomorrow weather condition: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + e.temperature*&lt;span&gt;1.1&lt;/span&gt; + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; degree ,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + e.humidity*&lt;span&gt;0.9&lt;/span&gt; + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;% humidity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 个人情绪状态预测&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ForecastDisplay : IWeatherStationSubject
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Display(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, WeatherChangeArgs e)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tomorrow weather condition: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + e.temperature*&lt;span&gt;1.1&lt;/span&gt; + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; degree ,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + e.humidity*&lt;span&gt;0.9&lt;/span&gt; + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;% humidity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、为了实现订阅系统与主控制系统松耦合， 创建订阅系统&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WeatherSubscriberSystem
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; WeatherSubscriberSystem(WeatherData weatherData, WeatherChangeArgs e)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             weatherData.WeatherChange += &lt;span&gt;new&lt;/span&gt; WeatherData.WeatherChangeEventHandler((&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CurrentConditionDisplay()).Display);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             weatherData.WeatherChange += (&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ForecastDisplay()).Display;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;             weatherData.WeatherChange += (&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FeelingToneDisplay()).Display;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;            weatherData.RaiseWeatherChange(e);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 4、 主控制系统&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             WeatherSubscriberSystem sys_1 = &lt;span&gt;new&lt;/span&gt; WeatherSubscriberSystem(&lt;span&gt;new&lt;/span&gt; WeatherData(), &lt;span&gt;new&lt;/span&gt; WeatherChangeArgs(&lt;span&gt;20&lt;/span&gt;, &lt;span&gt;18.6&lt;/span&gt;, &lt;span&gt;55&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             WeatherSubscriberSystem sys_2 = &lt;span&gt;new&lt;/span&gt; WeatherSubscriberSystem(&lt;span&gt;new&lt;/span&gt; WeatherData(), &lt;span&gt;new&lt;/span&gt; WeatherChangeArgs(&lt;span&gt;35&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;38&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            Console.ReadKey();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;至此整个系统完成了。我们可以发现，用 .net 内置的事件来实现观察者模式，比自己实现更简单，控制起来也更方便。&lt;/p&gt;

</description>
<pubDate>Thu, 19 Oct 2017 05:32:00 +0000</pubDate>
<dc:creator>张居斜</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaolin1228/p/7690014.html</dc:identifier>
</item>
</channel>
</rss>