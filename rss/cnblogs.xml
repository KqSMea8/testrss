<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Vue.js—组件快速入门以及Vue路由实例应用 - chuanbao</title>
<link>http://www.cnblogs.com/lgc-17862800193/p/7817993.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lgc-17862800193/p/7817993.html</guid>
<description>&lt;p&gt;上次我们学习了Vue.js的基础，并且通过综合的小实例进一步的熟悉了Vue.js的基础应用。今天我们就继续讲讲Vue.js的组件，更加深入的了解Vue,js的使用。首先我们先了解一下什么是Vue.js的组件，组件其实就是页面组成的一部分，它是一个具有独立的逻辑和功能或页面，组件可以扩展 HTML 元素，封装可重用的代码。组件系统让我们可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1206165/201711/1206165-20171110223344372-226624189.png&quot; alt=&quot;&quot; width=&quot;726&quot; height=&quot;281&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们就仔细讲讲组件的使用吧。&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1 全局组件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt; 以下就是我们注册的第一个简单的全局组件my-Com。所有实例都能用全局组件，组件在注册之后，便可以作为自定义元素&lt;span class=&quot;Apple-converted-space&quot;&gt; &amp;lt;my-Com&amp;gt;&amp;lt;/my-Com&amp;gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 在一个实例的模板中使用。但是要注意全局组件必须写在vue实例之前，才会在跟元素 下面生效，模板里面第一级只能有一个标签，不能并行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;my-Com&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;my-Com&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;js/vue.js&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        Vue.component(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;myCom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;          template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;h1&amp;gt;自定义组件!&amp;lt;/h1&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建根实例&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;          el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1206165/201711/1206165-20171110233443450-1072993586.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2 局部组件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt; 以下就是我们注册的第一个简单的局部组件。其实可以不必把每个组件都注册到全局的，局部组件可以直接在vue实例里，使用components注册&lt;span class=&quot;Apple-converted-space&quot;&gt;，这种封装也适用于其它可注册的 Vue 功能，比如指令。我们建议将模板定义在全局变量。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mycom&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mycom&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;js/vue.js&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt;&lt;span&gt; Child &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;          template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;h1&amp;gt;自定义组件!&amp;lt;/h1&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建根实例&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;          el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;          components: {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; mycom  将只在父模板可用&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mycom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: Child
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1206165/201711/1206165-20171110233503138-1067655466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3 使用Prop传递数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;组件设计初衷就是要配合使用的，最常见的就是形成父子组件的关系：组件 A 在它的模板中使用了组件 B。在 Vue 中，父子组件的关系可以总结为&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;strong&gt;prop 向下传递，事件向上传递&lt;/strong&gt;。父组件通过&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;strong&gt;prop&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 给子组件下发数据，子组件通过&lt;strong&gt;事件&lt;/strong&gt;给父组件发送消息。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;组件实例的作用域是&lt;strong&gt;孤立的&lt;/strong&gt;。这意味着不可以 在子组件的模板内直接引用父组件的数据。prop 是父组件用来传递数据的一个自定义属性。父组件的数据需要通过 props 把数据传给子组件，子组件需要显式地用 props 选项声明 &quot;prop&quot;。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com &lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;=&quot;hello!&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;js/vue.js&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        Vue.component(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 声明 props&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;          props: [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;          template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;span&amp;gt;{{ message }}&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建根实例&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;          el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1206165/201711/1206165-20171110233524606-771457703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4 动态Prop&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;动态Prop 类似于用 v-bind 绑定 HTML 特性到一个表达式，也可以用 v-bind 动态绑定 props 的值到父组件的数据中。每当父组件的数据变化时，该变化也会传导给子组件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;parent&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;child &lt;/span&gt;&lt;span&gt;v-bind:message&lt;/span&gt;&lt;span&gt;=&quot;parent&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;js/vue.js&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        Vue.component(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 声明 props&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;          props: [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;          template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;span&amp;gt;{{ message }}&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建根实例&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;          el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;          data: {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            parent: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;父组件内容&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1206165/201711/1206165-20171110233612763-983436353.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然我们也能可以使用&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;&lt;span&gt;v-bind&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 的缩写语法：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;child &lt;/span&gt;&lt;span&gt;:my-message&lt;/span&gt;&lt;span&gt;=&quot;parentMsg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 以下实例中将 v-bind 指令将com传到每一个重复的组件中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ol&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;item &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;item in sites&quot;&lt;/span&gt;&lt;span&gt; v-bind:com&lt;/span&gt;&lt;span&gt;=&quot;item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;           &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ol&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;js/vue.js&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        Vue.component(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;          props: [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;          template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;li&amp;gt;{{ com.text }}&amp;lt;/li&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;          el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;          data: {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            sites: [
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;              { text: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Vue.js&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;              { text: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;BootStrap&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;              { text: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;JQuery&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            ]
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1206165/201711/1206165-20171110235000747-1922469830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意: prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意间修改了父组件的状态，来避免应用的数据流变得难以理解。但是，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着&lt;strong&gt;不可以&lt;/strong&gt;在子组件内部改变 prop。如果这么做了的话，Vue 会在控制台出现警告。&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5 使用 v-on 绑定自定义事件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，就需要使用自定义事件，父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。&lt;/p&gt;
&lt;p&gt;我们可以使用 v-on 绑定自定义事件, 每个 Vue 实例都实现了事件接口，即：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;$on(eventName)&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 监听事件&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;$emit(eventName)&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 触发事件&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;example&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ num }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button-counter &lt;/span&gt;&lt;span&gt;v-on:vue&lt;/span&gt;&lt;span&gt;=&quot;com&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button-counter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;js/vue.js&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        Vue.component(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;button-counter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;          template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;button v-on:click=&quot;vue&quot;&amp;gt;{{ counter }}&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;          data: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;              counter: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;          },
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;          methods: {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            vue: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;               &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.counter &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;               &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$emit(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;vue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;          },
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;          el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#example&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;          data: {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            num: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;          },
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;          methods: {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            com: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;               &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.num &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1206165/201711/1206165-20171111000654778-1672207236.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6 给组件绑定原生事件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;如果想在某个组件的根元素上监听一个原生事件。可以使用&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;&lt;span&gt;v-on&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 的修饰符&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;&lt;span&gt;.native&lt;/span&gt;&lt;/code&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;comv-on:click&lt;/span&gt;&lt;span&gt;.native&lt;/span&gt;&lt;span&gt;=&quot;something&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7 自定义指令&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;默认情况下，一个组件的&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 会使用&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;&lt;span&gt;value&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; prop 和&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;&lt;span&gt;input&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 事件。Vue 也允许注册自定义指令。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;以下例子就是我们注册的一个全局指令 v-focus, 该指令的功能就是在页面加载时，元素会自动获得焦点。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;页面载入时，input 元素会自动获取焦点：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-focus&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;js/vue.js&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        Vue.directive(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;focus&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;          inserted: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (el) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 聚焦元素&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            el.focus()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建根实例&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;          el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8 Vue 路由实例应用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;Vue框架的兼容性非常好，可以很好的跟其他第三方的路由框架进行结合。Vue官方给出了路由的方案  ---   &lt;code&gt;vue-router。下面我们就使用Vue的路由实现简单的单页应用。&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;8.1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;引入vue和vue-router&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;js/vue.js&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;8.2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;定义路由跳转的组件&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;使用 router-link 组件来导航.，通过传入 `to` 属性指定链接，&amp;lt;router-link&amp;gt; 默认会被渲染成一个 `&amp;lt;a&amp;gt;` 标签。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&quot;/Vue&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;路由&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&quot;/BootStrap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;栅格&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;8.3&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;定义（路由）组件&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;定义（路由）组件，可以从其他文件 import 进来。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;const Foo = {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             template: '&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Vue&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        const Bar = {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             template: '&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;BootStrap&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;8.4&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;定义路由&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;定义路由，每个路由应该映射一个组件。 其中&quot;component&quot; 可以是通过 Vue.extend() 创建的组件构造器，或者只是一个组件配置对象。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;const routes = [{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;                path: '/Vue',
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;                component: Foo
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;            },
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;                path: '/BootStrap',
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;                component: Bar
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;         ]
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;8.5&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;创建 router 实例&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;const router = new VueRouter({
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;            routes 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         })
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;8.6&lt;/span&gt; &lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;创建和挂载根实例。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;要通过 router 配置参数注入路由，从而让整个应用都有路由功能。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;const app = new Vue({
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;            router
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         }).$mount('#app')
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;8.7&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;具体代码&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Vue 路由实例&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;           
&lt;span&gt;11&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&quot;/Vue&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;路由&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&quot;/BootStrap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;栅格&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;           &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;           &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 路由出口 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 路由匹配到的组件将渲染在这里 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;js/vue.js&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        const Foo &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;Vue&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        const Bar &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;BootStrap&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        const routes &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; [{
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                path: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/Vue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                component: Foo
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            },
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                path: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/BootStrap&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                component: Bar
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        ]
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        const router &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            routes 
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        const app &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            router
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        }).$mount(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         
&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1206165/201711/1206165-20171111012714294-1359310283.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;9   综合实例应用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;上边已经了解了Vue路由，下边就是一个小小的综合实例，通过点击按钮，在当前页面切换不同的组件。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;综合实例&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/vue/dist/vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;            ul,
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;            li &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;                list-style&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; none&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;             &lt;span&gt;}&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;             
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;            ul &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;                overflow&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; hidden&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;             &lt;span&gt;}&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt;             
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;            li &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;                float&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; left&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;                width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;             &lt;span&gt;}&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;             
&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;            h1 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;                background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #98D361&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;             &lt;span&gt;}&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;             
&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;            h2 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;                background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #FF9209&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;             &lt;span&gt;}&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;             
&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;            h3 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;                background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #D84C29&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;             &lt;span&gt;}&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;hr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;buttons: {{ buttons }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;items&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;footer-bar&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;footer-bar&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; topbarTemp &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; `
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;nav&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li v&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item in list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;link :to&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item.url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;{{ item.name }}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;router-link&amp;gt;&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;li&amp;gt;&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;ul&amp;gt;&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;nav&amp;gt;        &lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;    `;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义组件：topbar&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;            Vue.component(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;                template: topbarTemp,
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;                data: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;                        list: [{
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;                                name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;小说&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;                                url: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/story&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;                            },
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;                                name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;动漫&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;                                url: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/carton&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;                            },
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;                                name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;绘画&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;                                url: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/draw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;                            },
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;                        ]
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;            Vue.component(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;footer-bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;                template: `
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;footer&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;Vue 路由&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;footer&amp;gt;&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;      `
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; 
&lt;span&gt; 86&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; story &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;                template: `&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;{{ msg }}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;div&amp;gt;`,&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;                data: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;                        msg: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Vue 基础&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; carton &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;                template: `&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;{{ msg }}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;div&amp;gt;`,&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;                data: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;                        msg: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Vue 组件&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; draw &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;                template: `&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;{{ msg }}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;div&amp;gt;`,&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt; &lt;span&gt;                data: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;                        msg: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Vue 路由实例&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; 
&lt;span&gt;113&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义路由对象&lt;/span&gt;
&lt;span&gt;114&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; router &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;                routes: [{
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;                        path: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/story&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;                        component: story
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;                    },
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;                        path: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/carton&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;                        component: carton
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;                    },
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;                        path: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/draw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;                        component: draw
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;                ]
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; 
&lt;span&gt;130&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化一个Vue实例&lt;/span&gt;
&lt;span&gt;131&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;                el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;                data: {
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;                    buttons: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;点击按钮，切换不同组件&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;135&lt;/span&gt; &lt;span&gt;                },
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; &lt;span&gt;                router: router
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;139&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1206165/201711/1206165-20171111020943356-1032476747.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div readability=&quot;8&quot;&gt;
&lt;h4 class=&quot;135brush&quot;&gt;编者按&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　Vue知识还有很多，希望通过对Vue一些基础知识的学习，对于正在学习前端的知识的你可以有所帮助。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 10 Nov 2017 18:21:00 +0000</pubDate>
<dc:creator>chuanbao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lgc-17862800193/p/7817993.html</dc:identifier>
</item>
<item>
<title>初学者易上手的SSH-spring 01控制反转(IOC) - 柯一</title>
<link>http://www.cnblogs.com/lzx2509254166/p/7817987.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lzx2509254166/p/7817987.html</guid>
<description>&lt;p&gt;这章开始学习SSH中最后的一个框架spring。Spring是一个开放源代码的设计层面框架，他解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。&lt;/p&gt;
&lt;p&gt;首先就来学习一下IOC,它的好处就是降低了耦合，主要是通过bean之间的依赖关系尽可能地抓换为关联关系。&lt;/p&gt;
&lt;p&gt;那么来基于maven项目来配置一个spring吧。&lt;/p&gt;
&lt;p&gt;首先可以下载一个spring的插件:可在eclipse-&amp;gt;Help-&amp;gt;Eclipse Marketplace中搜索spring,然后找到spring tools进行下载即可，其它下载方式就不过多介绍了。&lt;/p&gt;
&lt;p&gt;第一步:maven项目中的pom.xml中导入spring的依赖:spring-context,我以4.3.10版本为例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- spring-context 依赖 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;10&lt;/span&gt;.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二步:在src/main/resources文件夹下建立一个xml,取名为applicationContext.xml。在里面加上spring表头文件，如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;
&amp;lt;beans xmlns=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
xmlns:xsi&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.w3.org/2001/XMLSchema-instance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 
xmlns:aop&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/aop&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
xmlns:tx&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/tx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 
xmlns:context&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/context&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
xsi:schemaLocation&lt;/span&gt;=&lt;span&gt;&quot;
&lt;/span&gt;http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans/spring-beans-4.3.xsd&lt;/span&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/aop/spring-aop-4.3.xsd&lt;/span&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/context/spring-context-4.3.xsd&lt;/span&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/tx/spring-tx-4.3.xsd&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&lt;/span&gt;

&amp;lt;/beans&amp;gt;&lt;span&gt;


标签的解释:
xmlns&lt;/span&gt;=&lt;span&gt;XML Name space
xmlns： 关于初始化bean的格式文件地址
xmlns:xsi： 辅助初始化bean
xsi:context： 关于spring上下文，包括加载资源文件
xmlns:tx 事务标签的约束
xmlns:aop    aop(面向切面)标签的约束
xsi:schemaLocation： 用于声明了目标名称空间的模式文档&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三步:新建一个人的类,给上name，age属性，封装构造，tostring即可。&lt;/p&gt;
&lt;p&gt;第四步:开始配置一个bean，来实现IOC。在applicationContext.xml，配置如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;person&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.entity.Person&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;//id为这个bean的名称自己定义就好，class为要配置类的全限定路径&lt;br/&gt;//当然也可以使用name属性来代替id属性，name属性可以使用特殊符号来定义名称
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第五步:再建立一个类，用main方法或者用junit的@Test来进行测试，测试代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    //&lt;/span&gt;&lt;span&gt; 延时加载(懒加载) 返回的对象只有一个 单列模式
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载文件
        &lt;/span&gt;&lt;span&gt; BeanFactory factory = new XmlBeanFactory(new
        &lt;/span&gt;&lt;span&gt; ClassPathResource(&quot;applicationContext.xml&quot;));
        &lt;/span&gt;&lt;span&gt; 获取bean对象
        &lt;/span&gt;&lt;span&gt; Person p = (Person) factory.getBean(&quot;person&quot;);
        &lt;/span&gt;&lt;span&gt; System.out.println(p);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 及时加载   一个bean能够创建多个对象&lt;/span&gt;
        ApplicationContext aContext = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;applicationContext.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取bean对象&lt;/span&gt;
        Person p = (Person) aContext.getBean(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;person&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(p);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样一个简单的bean就配置完了。&lt;/p&gt;
&lt;p&gt;我们可以在bean后面加上一个属性scope以及init-method属性。&lt;/p&gt;
&lt;p&gt;scope属性值:&lt;/p&gt;
&lt;p&gt;singleton(默认值) &lt;/p&gt;
&lt;p&gt;在每个Spring Ioc容器中一个bean定义对应一个对象实例(单例模式)&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt; prototype&lt;br/&gt;一个bean定义对应多个对象实例.&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt; request&lt;br/&gt;在一次HTTP请求中，一个bean定义对应一个实例；即每次HTTP请求将会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效.&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt; session&lt;br/&gt;在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。&lt;br/&gt;global session&lt;br/&gt;在一个全局的HTTP Session中，一个bean定义对应一个实例。典型情况下，仅在使用portlet context的时候有效。该作用域仅在基于web的Spring ApplicationContext情形下有效.&lt;/p&gt;

&lt;p&gt;init-method属性的意思是这个bean初始化的时候调用哪个方法，属性值为bean对应这个类中的方法名即可。&lt;/p&gt;
&lt;p&gt;接下来看下注入方式:&lt;/p&gt;
&lt;p&gt; 首先bean标签里面添加property标签，name对应属性名称，value对应属性值&lt;/p&gt;
&lt;p&gt;1.比如给这个对象的属性设置默认值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;person&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.entity.Person&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;!--属性设置默认值 --&amp;gt;
        &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;哈哈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.注入一个集合(set,list)，以list为例&lt;/p&gt;
&lt;p&gt;在persion类中加上一个lsit&amp;lt;string&amp;gt;的属性，封装&lt;/p&gt;
&lt;p&gt;注入:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;person&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.entity.Person&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ls为list&amp;lt;string&amp;gt;的变量名&lt;/span&gt;
    &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;list&amp;gt;
                &amp;lt;value&amp;gt;谷歌&amp;lt;/value&amp;gt;
                &amp;lt;value&amp;gt;呵呵&amp;lt;/value&amp;gt;
                &amp;lt;value&amp;gt;嘻嘻&amp;lt;/value&amp;gt;
            &amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.构造注入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
//构造注入时，实体类中需存在相应的构造方法&lt;br/&gt;&amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;person&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.entity.Person&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;constructor-arg name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
        &amp;lt;constructor-arg name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.注入对象&lt;/p&gt;
&lt;p&gt;新建实体类card,给上cid,cname两个属性，封装构造。&lt;/p&gt;
&lt;p&gt;在applicationContext.xml中增加一个bean&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;card&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.entity.Card&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;card类中加上persion对象属性，封装。&lt;/p&gt;
&lt;p&gt;然后在card的bean中注入&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 &amp;lt;bean id=&quot;card&quot; class=&quot;com.entity.Card&quot; &amp;gt;   
//name 对象变量名
    &amp;lt;property name=&quot;person&quot;&amp;gt;
//ref对应属性类在bean的标签ID
            &amp;lt;ref bean=&quot;person&quot; /&amp;gt;&lt;br/&gt;//idref元素的功能与&amp;lt;value&amp;gt;类似，只是idref多了验证的功能&lt;br/&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt; &amp;lt;!-- &amp;lt;idref bean=&quot;&lt;/span&gt;person&lt;span class=&quot;Apple-tab-span&quot;&gt;&quot; /&amp;gt; --&amp;gt;&lt;/span&gt;
        &amp;lt;/property&amp;gt;
 &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试我这里就没试了。除了上面这几种注入，还可以百度看看静态工厂的方法注入以及实例工厂的方法注入。&lt;/p&gt;
&lt;p&gt;本章结束!&lt;/p&gt;

</description>
<pubDate>Fri, 10 Nov 2017 17:46:00 +0000</pubDate>
<dc:creator>柯一</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lzx2509254166/p/7817987.html</dc:identifier>
</item>
<item>
<title>Web桌面应用框架3：Web桌面应用开发的N种Style - windfic</title>
<link>http://www.cnblogs.com/windfic/p/7811464.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/windfic/p/7811464.html</guid>
<description>&lt;p&gt;研究Web桌面应用开发有一段时间了，总结了Web桌面应用开发的一些主流方式。&lt;/p&gt;

&lt;p&gt;一、前端Style&lt;/p&gt;
&lt;p&gt;这种方式的就是直接实现一个Web程序，再封装一个浏览器展示，相当粗暴和有效。著名的框架就是Electron和NW.js了。&lt;/p&gt;
&lt;p&gt;代表应用程序是atom。&lt;/p&gt;
&lt;p&gt;一般是基于node.js。也有其它语言的。&lt;/p&gt;
&lt;p&gt;各种前端框架的拥趸是这种Style的狂热粉丝。这里就不放Demo了。贴段代码就可以感受到它的霸气侧漏。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
app.on('ready', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建浏览器窗口。&lt;/span&gt;
  mainWindow = &lt;span&gt;new&lt;/span&gt; BrowserWindow({width: 800, height: 600&lt;span&gt;});

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载应用的 index.html&lt;/span&gt;
  mainWindow.loadURL('file://' + __dirname + '/index.html'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当 window 被关闭，这个事件会被发出&lt;/span&gt;
  mainWindow.on('closed', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;    mainWindow = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  });
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;二、炫酷Style&lt;/p&gt;
&lt;p&gt;这种方式就是在应用界面上嵌入多个Web页面，一般都是效果炫酷的Flash或动画。&lt;/p&gt;
&lt;p&gt;代表应用程序就是QQ了。&lt;/p&gt;
&lt;p&gt;各种DirectUI或换肤框架的用户都是这种模式的真爱粉。&lt;/p&gt;
&lt;p&gt;所谓尺有所短，寸有所长。把脏活累活甩锅给Web页面真是英明。各种不明觉厉的玩意儿能上的都给上了。&lt;/p&gt;
&lt;p&gt;这里我用WxPython和tornado实现了一个小小的代码编辑器的Demo。颜值担当：zTree.js和codemirror.js。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyHtmlFrame(wx.Frame): 
   
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, parent, title):
        wx.Frame.&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;(self, parent, -1, title, size = (800,600&lt;span&gt;))
        self.create_menu()
        self.Bind(wx.EVT_CLOSE, self.OnClose)

        self.statusbar &lt;/span&gt;= self.CreateStatusBar(2&lt;span&gt;)
        self.statusbar.SetStatusText(u&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;status&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 0)
        self.statusbar.SetStatusText(u&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 1&lt;span&gt;)

        self.splitter &lt;/span&gt;= wx.SplitterWindow(self, style=&lt;span&gt;wx.SP_LIVE_UPDATE)
        self.tree &lt;/span&gt;=&lt;span&gt; wx.html2.WebView.New(self.splitter)
&lt;/span&gt;&lt;span&gt;
        self.html &lt;/span&gt;=&lt;span&gt; wx.html2.WebView.New(self.splitter)

        self.splitter.SetMinimumPaneSize(&lt;/span&gt;200&lt;span&gt;)
        self.splitter.SplitVertically(self.tree, self.html, &lt;/span&gt;300&lt;span&gt;)

        self.tree.LoadURL(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://localhost:8888/tree?v=%d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;time.time())
        self.html.LoadURL(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://localhost:8888?v=%d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;time.time())
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/569097/201711/569097-20171109212329559-1030756177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;三、嵌入Style&lt;/p&gt;
&lt;p&gt;有人说所有Web项目都是开源的：（。Web的特性决定了，它的安全性（对于程序本身）很差。同时体验上也有一些限制性。&lt;/p&gt;
&lt;p&gt;所以，嵌入Style放弃了纯粹的Web程序，采取了宿主语言与JavaScript双向绑定的方式，直接操作Web页面，来换取安全性和体验上的提升。&lt;/p&gt;
&lt;p&gt;这种Style带来的开发难度的提升，使得它的狂热爱好者不多，暂时没有发现纯粹的代表应用程序 。大多是框架在做的事情。&lt;/p&gt;
&lt;p&gt;下面是我用cef-python实现的一个Demo。颜值担当：GooFlow.js。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    check_versions()
    sys.excepthook &lt;/span&gt;= cef.ExceptHook  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; To shutdown all CEF processes on error&lt;/span&gt;
&lt;span&gt;
    settings &lt;/span&gt;=&lt;span&gt; {
         &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;product_version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyProduct/10.00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
         &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user_agent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyAgent/20.00 MyProduct/10.00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    }
    cef.Initialize(settings&lt;/span&gt;=&lt;span&gt;settings)

    browser &lt;/span&gt;= cef.CreateBrowserSync(url=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file:///html/flow.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                    window_title&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tutorial&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    set_javascript_bindings(browser)

    cef.MessageLoop()
    cef.Shutdown()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/569097/201711/569097-20171110195509341-1701246545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;四、组件Style&lt;/p&gt;
&lt;p&gt;WEB组件，是一种由来已久的技术。最出名的就是.net平台WebForm技术，还有Java平台JSF、Tapestry等。&lt;/p&gt;
&lt;p&gt;组件式开发的优点是简单直观，开发迅速。缺点是封装严重，界面呆板。一个字：丑。相对来说，是一种被认为相当落后和有缺陷的技术。&lt;/p&gt;
&lt;p&gt;但是有意思的地方来了，&lt;/p&gt;
&lt;p&gt;如果使用Web组件开发Web桌面应用，先忽略中间过程，只看组件…桌面应用，这却是一个相当正常和悠久的技术体系了。&lt;/p&gt;
&lt;p&gt;负负得正，螺旋式上升，组件Style一下子变得高大上起来。&lt;/p&gt;
&lt;p&gt;相对于传统组件式应用，新的组件style的优势在于跨平台GUI开发成本大大降低。相当于把浏览器当成GUI Render。&lt;/p&gt;
&lt;p&gt;而且相比其它Style，安全性，炫酷度，体验度都大大增强。开发难度也不太大。&lt;/p&gt;
&lt;p&gt;但这种Style还没有发现有人公开使用。&lt;/p&gt;
&lt;p&gt;不过我发现了一款相当有潜力的Golang框架：github.com/zserge/webview&lt;/p&gt;
&lt;p&gt;可以做一些组件Style的尝试。。。&lt;/p&gt;

&lt;p&gt;五、终极Style&lt;/p&gt;
&lt;p&gt;终极Style并非一种开发方式，而是评分标准，每项五颗星，总分共十五颗星。&lt;/p&gt;
&lt;p&gt;终极的Web应用框架必须完美解决界面、成本、限制这三个方面的问题。大家可以自己来评评看。&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;界面&lt;/td&gt;
&lt;td&gt;成本&lt;/td&gt;
&lt;td&gt;限制&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt; 标准 高级 定制 皮肤 动画&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/569097/201711/569097-20171110205644591-820511038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt; 学习 流行 开发 继承 前途&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/569097/201711/569097-20171110205644591-820511038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt; 平台 体积 流畅 安全 开源&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/569097/201711/569097-20171110205644591-820511038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt; 图例&lt;/p&gt;
&lt;p&gt; 满意 符合 不符&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/569097/201711/569097-20171110210352450-732991934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;源码：&lt;a href=&quot;https://files.cnblogs.com/files/windfic/cool_style.zip&quot; target=&quot;_blank&quot;&gt;cool style&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（完）&lt;/p&gt;

</description>
<pubDate>Fri, 10 Nov 2017 14:00:00 +0000</pubDate>
<dc:creator>windfic</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/windfic/p/7811464.html</dc:identifier>
</item>
<item>
<title>Tinyhttpd精读解析 - nengm</title>
<link>http://www.cnblogs.com/nengm1988/p/7816618.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nengm1988/p/7816618.html</guid>
<description>&lt;p&gt;       首先，本人刚刚开始开源代码精读，写的不对的地方，大家轻拍，一起进步。本文是对Tinyhttpd的一次精读，大家每天都在用着http服务，很多人也一直活跃在上层，使用IIS、Apache等，大家是否想看看http服务器大概是怎么运作的，通过一个500多行的源码加上完整的注释，和大家逛一逛http服务器。Tinyhttpd真的非常适合阅读尤其是刚入门的，清晰的代码，简单的makefile...其实有很多分析tinyghttpd的，这边抱着人家写的是人家，自己写的才是自己的态度，写的尽量详细，尽量简单，很多都写在代码注释里面，也把学习中的一些坑翻出来和大家一起读读，吸取将近20年前的大神通过500行代码带给我们的财富。不管你是写c的，或者C#，js亦或java，只要用到http的都欢迎读读。&lt;br/&gt;大家看后如果觉得我有写的不对的地方，欢迎指出~~&lt;/p&gt;&lt;p&gt;1.首先是一张图 全解了Tinyhttp是如何运作的，我觉得图说明比我用文字描述的要清晰，语言功底不太给力。&lt;/p&gt;&lt;p&gt; 2. 主要函数简略说明，代码中进行了详细注释。&lt;/p&gt;&lt;p&gt;main   　　　　　　 主函数&lt;br/&gt;startup 　　　 　　  绑定监听套接字&lt;br/&gt;accept_request 　   每次收到请求，创建一个线程来处理接受到的请求&lt;br/&gt;serve_file 　　　　 接读取文件返回给请求的http客户端&lt;br/&gt;execute_cgi 　　　 执行cgi文件&lt;/p&gt;&lt;p&gt;index.html必须没有执行权限，否则看不到内容，并且会产生Program received signal SIGPIPE, Broken pipe，因为程序中如果有可执行权限会当cgi脚本处理。所以假如html有执行权限先把它去除了，chmod 600 index.html&lt;/p&gt;&lt;p&gt;color.cgi是用perl写的，相信大家很少接触了。所以可以引用网上一个简单的例子，换成一个shell写的cgi测试&lt;/p&gt;&lt;p&gt;#!/bin/bash&lt;br/&gt;echo &quot;Content-Type: text/html&quot;&lt;br/&gt;echo&lt;br/&gt;echo &quot;&amp;lt;HTML&amp;gt;&amp;lt;BODY&amp;gt;&quot;&lt;br/&gt;echo &quot;&amp;lt;CENTER&amp;gt;Today is:&amp;lt;/CENTER&amp;gt;&quot;&lt;br/&gt;echo &quot;&amp;lt;CENTER&amp;gt;&amp;lt;B&amp;gt;&quot;&lt;br/&gt;date&lt;br/&gt;echo &quot;&amp;lt;/B&amp;gt;&amp;lt;/CENTER&amp;gt;&quot;&lt;br/&gt;echo &quot;&amp;lt;/BODY&amp;gt;&amp;lt;/HTML&amp;gt;&quot;&lt;/p&gt;&lt;div readability=&quot;307&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; J. David's webserver &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; This is a simple webserver.
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt; * Created November 1999 by J. David Blackstone.
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt; * CSE 4344 (Network concepts), Prof. Zeigler
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt; * University of Texas at Arlington
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; This program compiles for Sparc Solaris 2.6.
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt; * To compile for Linux:
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt; *  1) Comment out the #include &amp;lt;pthread.h&amp;gt; line.
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt; *  2) Comment out the line that defines the variable newthread.
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt; *  3) Comment out the two lines that run pthread_create().
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt; *  4) Uncomment the line that runs accept_request().
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt; *  5) Remove -lsocket from the Makefile.
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 16&lt;/span&gt; #include &amp;lt;sys/socket.h&amp;gt;
&lt;span&gt; 17&lt;/span&gt; #include &amp;lt;sys/types.h&amp;gt;
&lt;span&gt; 18&lt;/span&gt; #include &amp;lt;netinet/&lt;span&gt;in&lt;/span&gt;.h&amp;gt;
&lt;span&gt; 19&lt;/span&gt; #include &amp;lt;arpa/inet.h&amp;gt;
&lt;span&gt; 20&lt;/span&gt; #include &amp;lt;unistd.h&amp;gt;
&lt;span&gt; 21&lt;/span&gt; #include &amp;lt;ctype.h&amp;gt;
&lt;span&gt; 22&lt;/span&gt; #include &amp;lt;strings.h&amp;gt;
&lt;span&gt; 23&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt; 24&lt;/span&gt; #include &amp;lt;sys/stat.h&amp;gt;
&lt;span&gt; 25&lt;/span&gt; #include &amp;lt;pthread.h&amp;gt;
&lt;span&gt; 26&lt;/span&gt; #include &amp;lt;sys/wait.h&amp;gt;
&lt;span&gt; 27&lt;/span&gt; #include &amp;lt;stdlib.h&amp;gt;
&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;宏定义，是否是空格&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; ISspace(x) isspace((int)(x))
&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; SERVER_STRING &quot;Server: jdbhttpd/0.1.0\r\n&quot;
&lt;span&gt; 33&lt;/span&gt; 
&lt;span&gt; 34&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次收到请求，创建一个线程来处理接受到的请求
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把client_sock转成地址作为参数传入pthread_create&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; accept_request(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;arg);
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误请求&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; bad_request(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取文件&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; cat(&lt;span&gt;int&lt;/span&gt;, FILE *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;无法执行&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; cannot_execute(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误输出&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; error_die(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; 
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行cig脚本&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; execute_cgi(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到一行数据,只要发现c为\n,就认为是一行结束，如果读到\r,再用MSG_PEEK的方式读入一个字符，如果是\n，从socket用读出
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是下个字符则不处理，将c置为\n，结束。如果读到的数据为0中断，或者小于0，也视为结束，c置为\n&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; get_line(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;char&lt;/span&gt; *, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回http头&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; headers(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; 
&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有发现文件&lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; not_found(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是CGI文件，直接读取文件返回给请求的http客户端&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; serve_file(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启tcp连接，绑定端口等操作&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; startup(u_short *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是Get或者Post，就报方法没有实现&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; unimplemented(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; 
&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Http请求，后续主要是处理这个头
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET / HTTP/1.1
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Host: 192.168.0.23:47310
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Connection: keep-alive
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Upgrade-Insecure-Requests: 1
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*; q = 0.8
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Accept - Encoding: gzip, deflate, sdch
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Accept - Language : zh - CN, zh; q = 0.8
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cookie: __guid = 179317988.1576506943281708800.1510107225903.8862; monitor_count = 5
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; POST / color1.cgi HTTP / 1.1
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Host: 192.168.0.23 : 47310
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Connection : keep - alive
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Content - Length : 10
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cache - Control : max - age = 0
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Origin : http :&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.0.23:40786
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Upgrade - Insecure - Requests : 1
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; User - Agent : Mozilla / 5.0 (Windows NT 6.1; WOW64) AppleWebKit / 537.36 (KHTML, like Gecko) Chrome / 55.0.2883.87 Safari / 537.36
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Content - Type : application / x - www - form - urlencoded
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Accept : text / html, application / xhtml + xml, application / xml; q = 0.9, image / webp, */*;q=0.8
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Referer: &lt;/span&gt;&lt;span&gt;http://192.168.0.23&lt;/span&gt;&lt;span&gt;:47310/
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Accept-Encoding: gzip, deflate
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Accept-Language: zh-CN,zh;q=0.8
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cookie: __guid=179317988.1576506943281708800.1510107225903.8862; monitor_count=281
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Form Data
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; color=gray&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; A request has caused a call to accept() on the server port to
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt; * return.  Process the request appropriately.
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt; * Parameters: the socket connected to the client &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;107&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; accept_request(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;arg)
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;socket&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; client =&lt;span&gt; (intptr_t)arg;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt;&lt;span&gt; numchars;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; method[&lt;span&gt;255&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; url[&lt;span&gt;255&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; path[&lt;span&gt;512&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt; size_t i, j;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;  &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; stat st;
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; cgi = &lt;span&gt;0&lt;/span&gt;;      &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; becomes true if server decides this is a CGI
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;                    * program &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;120&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; *query_string =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据上面的Get请求，可以看到这边就是取第一行
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这边都是在处理第一条http信息
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;GET / HTTP/1.1\n&quot;&lt;/span&gt;
&lt;span&gt;124&lt;/span&gt;  numchars = get_line(client, buf, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf));
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;  i = &lt;span&gt;0&lt;/span&gt;; j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一行字符串提取Get&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt;  &lt;span&gt;while&lt;/span&gt; (!ISspace(buf[j]) &amp;amp;&amp;amp; (i &amp;lt; &lt;span&gt;sizeof&lt;/span&gt;(method) - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;   method[i] =&lt;span&gt; buf[j];
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;   i++; j++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt;  method[i] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; 
&lt;span&gt;136&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是Get还是Post&lt;/span&gt;
&lt;span&gt;137&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (strcasecmp(method, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;amp;&amp;amp; strcasecmp(method, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt;  unimplemented(client);
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; 
&lt;span&gt;143&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是POST，cgi置为1&lt;/span&gt;
&lt;span&gt;144&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (strcasecmp(method, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;   cgi = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; 
&lt;span&gt;147&lt;/span&gt;  i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳过空格&lt;/span&gt;
&lt;span&gt;149&lt;/span&gt;  &lt;span&gt;while&lt;/span&gt; (ISspace(buf[j]) &amp;amp;&amp;amp; (j &amp;lt; &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf)))
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;   j++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; 
&lt;span&gt;152&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到 &quot;/&quot;   注意：如果你的http的网址为http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.0.23:47310/index.html
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;               那么你得到的第一条http信息为GET /index.html HTTP/1.1，那么
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;               解析得到的就是/index.html&lt;/span&gt;
&lt;span&gt;155&lt;/span&gt;  &lt;span&gt;while&lt;/span&gt; (!ISspace(buf[j]) &amp;amp;&amp;amp; (i &amp;lt; &lt;span&gt;sizeof&lt;/span&gt;(url) - &lt;span&gt;1&lt;/span&gt;) &amp;amp;&amp;amp; (j &amp;lt; &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf)))
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;   url[i] =&lt;span&gt; buf[j];
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;   i++; j++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;  url[i] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; 
&lt;span&gt;162&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断Get请求&lt;/span&gt;
&lt;span&gt;163&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (strcasecmp(method, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;   query_string =&lt;span&gt; url;
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;   &lt;span&gt;while&lt;/span&gt; ((*query_string != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &amp;amp;&amp;amp; (*query_string != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;    query_string++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (*query_string == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;    cgi = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;    *query_string = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;    query_string++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; 
&lt;span&gt;176&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;路径&lt;/span&gt;
&lt;span&gt;177&lt;/span&gt;  sprintf(path, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;htdocs%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, url);
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; 
&lt;span&gt;179&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认地址，解析到的路径如果为/，则自动加上index.html&lt;/span&gt;
&lt;span&gt;180&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (path[strlen(path) - &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;   strcat(path, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt; 
&lt;span&gt;183&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得文件信息&lt;/span&gt;
&lt;span&gt;184&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (stat(path, &amp;amp;st) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把所有http信息读出然后丢弃&lt;/span&gt;
&lt;span&gt;186&lt;/span&gt;   &lt;span&gt;while&lt;/span&gt; ((numchars &amp;gt; &lt;span&gt;0&lt;/span&gt;) &amp;amp;&amp;amp; strcmp(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, buf))  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; read &amp;amp; discard headers &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;187&lt;/span&gt;    numchars = get_line(client, buf, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf));
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt; 
&lt;span&gt;189&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有找到&lt;/span&gt;
&lt;span&gt;190&lt;/span&gt; &lt;span&gt;  not_found(client);
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;  &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;193&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; ((st.st_mode &amp;amp; S_IFMT) ==&lt;span&gt; S_IFDIR)
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;    strcat(path, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/index.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果你的文件默认是有执行权限的，自动解析成cgi程序，如果有执行权限但是不能执行，会接受到报错信号&lt;/span&gt;
&lt;span&gt;197&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; ((st.st_mode &amp;amp; S_IXUSR) ||
&lt;span&gt;198&lt;/span&gt;       (st.st_mode &amp;amp; S_IXGRP) ||
&lt;span&gt;199&lt;/span&gt;       (st.st_mode &amp;amp;&lt;span&gt; S_IXOTH)    )
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;    cgi = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cgi)
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接读取文件返回给请求的http客户端&lt;/span&gt;
&lt;span&gt;203&lt;/span&gt; &lt;span&gt;   serve_file(client, path);
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;   &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;205&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行cgi文件&lt;/span&gt;
&lt;span&gt;206&lt;/span&gt; &lt;span&gt;   execute_cgi(client, path, method, query_string);
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行完毕关闭socket&lt;/span&gt;
&lt;span&gt;209&lt;/span&gt; &lt;span&gt; close(client);
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; 
&lt;span&gt;212&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;213&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Inform the client that a request it has made has a problem.
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt; &lt;span&gt; * Parameters: client socket &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;215&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;216&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; bad_request(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; client)
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt; 
&lt;span&gt;220&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HTTP/1.0 400 BAD REQUEST\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt;  send(client, buf, &lt;span&gt;sizeof&lt;/span&gt;(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-type: text/html\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;  send(client, buf, &lt;span&gt;sizeof&lt;/span&gt;(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt;  send(client, buf, &lt;span&gt;sizeof&lt;/span&gt;(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;P&amp;gt;Your browser sent a bad request, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt;  send(client, buf, &lt;span&gt;sizeof&lt;/span&gt;(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;such as a POST without a Content-Length.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt;  send(client, buf, &lt;span&gt;sizeof&lt;/span&gt;(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt; 
&lt;span&gt;232&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;233&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Put the entire contents of a file out on a socket.  This function
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt; &lt;span&gt; * is named after the UNIX &quot;cat&quot; command, because it might have been
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt; &lt;span&gt; * easier just to do something like pipe, fork, and exec(&quot;cat&quot;).
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; &lt;span&gt; * Parameters: the client socket descriptor
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt; &lt;span&gt; *             FILE pointer for the file to cat &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;238&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;239&lt;/span&gt; 
&lt;span&gt;240&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到文件内容，发送&lt;/span&gt;
&lt;span&gt;241&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; cat(&lt;span&gt;int&lt;/span&gt; client, FILE *&lt;span&gt;resource)
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt; 
&lt;span&gt;245&lt;/span&gt;  fgets(buf, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf), resource);
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环读&lt;/span&gt;
&lt;span&gt;247&lt;/span&gt;  &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;feof(resource))
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt;   send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;   fgets(buf, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf), resource);
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt; 
&lt;span&gt;254&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;255&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Inform the client that a CGI script could not be executed.
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt; &lt;span&gt; * Parameter: the client socket descriptor. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;257&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;258&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; cannot_execute(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; client)
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;261&lt;/span&gt; 
&lt;span&gt;262&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HTTP/1.0 500 Internal Server Error\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-type: text/html\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;267&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;P&amp;gt;Error prohibited CGI execution.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;269&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;271&lt;/span&gt; 
&lt;span&gt;272&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;273&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Print out an error message with perror() (for system errors; based
&lt;/span&gt;&lt;span&gt;274&lt;/span&gt; &lt;span&gt; * on value of errno, which indicates system call errors) and exit the
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt; &lt;span&gt; * program indicating an error. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;276&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;277&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; error_die(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;sc)
&lt;/span&gt;&lt;span&gt;278&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;279&lt;/span&gt; &lt;span&gt; perror(sc);
&lt;/span&gt;&lt;span&gt;280&lt;/span&gt;  exit(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;281&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;282&lt;/span&gt; 
&lt;span&gt;283&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;284&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Execute a CGI script.  Will need to set environment variables as
&lt;/span&gt;&lt;span&gt;285&lt;/span&gt; &lt;span&gt; * appropriate.
&lt;/span&gt;&lt;span&gt;286&lt;/span&gt; &lt;span&gt; * Parameters: client socket descriptor
&lt;/span&gt;&lt;span&gt;287&lt;/span&gt; &lt;span&gt; *             path to the CGI script &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;288&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;289&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; execute_cgi(&lt;span&gt;int&lt;/span&gt; client, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;path,
&lt;/span&gt;&lt;span&gt;290&lt;/span&gt;                  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *method, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;query_string)
&lt;/span&gt;&lt;span&gt;291&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;292&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓冲区&lt;/span&gt;
&lt;span&gt;293&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;294&lt;/span&gt; 
&lt;span&gt;295&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2根管道&lt;/span&gt;
&lt;span&gt;296&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; cgi_output[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;297&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; cgi_input[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;298&lt;/span&gt; 
&lt;span&gt;299&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进程pid和状态&lt;/span&gt;
&lt;span&gt;300&lt;/span&gt; &lt;span&gt; pid_t pid;
&lt;/span&gt;&lt;span&gt;301&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt;&lt;span&gt; status;
&lt;/span&gt;&lt;span&gt;302&lt;/span&gt; 
&lt;span&gt;303&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;304&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt;&lt;span&gt; c;
&lt;/span&gt;&lt;span&gt;305&lt;/span&gt;  
&lt;span&gt;306&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取的字符数&lt;/span&gt;
&lt;span&gt;307&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; numchars = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;308&lt;/span&gt; 
&lt;span&gt;309&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;http的content_length&lt;/span&gt;
&lt;span&gt;310&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; content_length = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;311&lt;/span&gt; 
&lt;span&gt;312&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认字符&lt;/span&gt;
&lt;span&gt;313&lt;/span&gt;  buf[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; buf[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;314&lt;/span&gt; 
&lt;span&gt;315&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;忽略大小写比较字符串&lt;/span&gt;
&lt;span&gt;316&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (strcasecmp(method, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;317&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取数据，把整个header都读掉，以为Get写死了直接读取index.html，没有必要分析余下的http信息了&lt;/span&gt;
&lt;span&gt;318&lt;/span&gt;   &lt;span&gt;while&lt;/span&gt; ((numchars &amp;gt; &lt;span&gt;0&lt;/span&gt;) &amp;amp;&amp;amp; strcmp(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, buf))  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; read &amp;amp; discard headers &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;319&lt;/span&gt;    numchars = get_line(client, buf, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf));
&lt;/span&gt;&lt;span&gt;320&lt;/span&gt;  &lt;span&gt;else&lt;/span&gt;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; POST &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;321&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;322&lt;/span&gt;   numchars = get_line(client, buf, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf));
&lt;/span&gt;&lt;span&gt;323&lt;/span&gt;   &lt;span&gt;while&lt;/span&gt; ((numchars &amp;gt; &lt;span&gt;0&lt;/span&gt;) &amp;amp;&amp;amp; strcmp(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, buf))
&lt;/span&gt;&lt;span&gt;324&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;325&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是POST请求，就需要得到Content-Length，Content-Length：这个字符串一共长为15位，所以
&lt;/span&gt;&lt;span&gt;326&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出头部一句后，将第16位设置结束符，进行比较
&lt;/span&gt;&lt;span&gt;327&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第16位置为结束&lt;/span&gt;
&lt;span&gt;328&lt;/span&gt;    buf[&lt;span&gt;15&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;329&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (strcasecmp(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Length:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;330&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;内存从第17位开始就是长度，将17位开始的所有字符串转成整数就是content_length&lt;/span&gt;
&lt;span&gt;331&lt;/span&gt;     content_length = atoi(&amp;amp;(buf[&lt;span&gt;16&lt;/span&gt;&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt;332&lt;/span&gt;    numchars = get_line(client, buf, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf));
&lt;/span&gt;&lt;span&gt;333&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;334&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (content_length == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;335&lt;/span&gt; &lt;span&gt;   bad_request(client);
&lt;/span&gt;&lt;span&gt;336&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;337&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;338&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;339&lt;/span&gt; 
&lt;span&gt;340&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HTTP/1.0 200 OK\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;341&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;342&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立output管道&lt;/span&gt;
&lt;span&gt;343&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (pipe(cgi_output) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;344&lt;/span&gt; &lt;span&gt;  cannot_execute(client);
&lt;/span&gt;&lt;span&gt;345&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;346&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;347&lt;/span&gt; 
&lt;span&gt;348&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立input管道&lt;/span&gt;
&lt;span&gt;349&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (pipe(cgi_input) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;350&lt;/span&gt; &lt;span&gt;  cannot_execute(client);
&lt;/span&gt;&lt;span&gt;351&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;352&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;353&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;       fork后管道都复制了一份，都是一样的
&lt;/span&gt;&lt;span&gt;354&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;       子进程关闭2个无用的端口，避免浪费             
&lt;/span&gt;&lt;span&gt;355&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;       ×&amp;lt;-------------------------&amp;gt;1    output
&lt;/span&gt;&lt;span&gt;356&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;       0&amp;lt;--------------------------&amp;gt;×   input 
&lt;/span&gt;&lt;span&gt;357&lt;/span&gt; 
&lt;span&gt;358&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;       父进程关闭2个无用的端口，避免浪费             
&lt;/span&gt;&lt;span&gt;359&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;       0&amp;lt;--------------------------&amp;gt;×   output
&lt;/span&gt;&lt;span&gt;360&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;       ×&amp;lt;-------------------------&amp;gt;1    input
&lt;/span&gt;&lt;span&gt;361&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;       此时父子进程已经可以通信
&lt;/span&gt;&lt;span&gt;362&lt;/span&gt; 
&lt;span&gt;363&lt;/span&gt; 
&lt;span&gt;364&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;fork进程，子进程用于执行CGI
&lt;/span&gt;&lt;span&gt;365&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;父进程用于收数据以及发送子进程处理的回复数据&lt;/span&gt;
&lt;span&gt;366&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; ( (pid = fork()) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;367&lt;/span&gt; &lt;span&gt;  cannot_execute(client);
&lt;/span&gt;&lt;span&gt;368&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;369&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;370&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (pid == &lt;span&gt;0&lt;/span&gt;)  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; child: CGI script &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;371&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;372&lt;/span&gt;   &lt;span&gt;char&lt;/span&gt; meth_env[&lt;span&gt;255&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;373&lt;/span&gt;   &lt;span&gt;char&lt;/span&gt; query_env[&lt;span&gt;255&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;374&lt;/span&gt;   &lt;span&gt;char&lt;/span&gt; length_env[&lt;span&gt;255&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;375&lt;/span&gt; 
&lt;span&gt;376&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;子进程输出重定向到output管道的1端&lt;/span&gt;
&lt;span&gt;377&lt;/span&gt;   dup2(cgi_output[&lt;span&gt;1&lt;/span&gt;], &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;378&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;子进程输入重定向到input管道的0端&lt;/span&gt;
&lt;span&gt;379&lt;/span&gt;   dup2(cgi_input[&lt;span&gt;0&lt;/span&gt;], &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;380&lt;/span&gt; 
&lt;span&gt;381&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭无用管道口&lt;/span&gt;
&lt;span&gt;382&lt;/span&gt;   close(cgi_output[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;383&lt;/span&gt;   close(cgi_input[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;384&lt;/span&gt; 
&lt;span&gt;385&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CGI环境变量&lt;/span&gt;
&lt;span&gt;386&lt;/span&gt;   sprintf(meth_env, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;REQUEST_METHOD=%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, method);
&lt;/span&gt;&lt;span&gt;387&lt;/span&gt; &lt;span&gt;  putenv(meth_env);
&lt;/span&gt;&lt;span&gt;388&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (strcasecmp(method, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;389&lt;/span&gt;    sprintf(query_env, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QUERY_STRING=%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, query_string);
&lt;/span&gt;&lt;span&gt;390&lt;/span&gt; &lt;span&gt;   putenv(query_env);
&lt;/span&gt;&lt;span&gt;391&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;392&lt;/span&gt;   &lt;span&gt;else&lt;/span&gt; {   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; POST &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;393&lt;/span&gt;    sprintf(length_env, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CONTENT_LENGTH=%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, content_length);
&lt;/span&gt;&lt;span&gt;394&lt;/span&gt; &lt;span&gt;   putenv(length_env);
&lt;/span&gt;&lt;span&gt;395&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;396&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;替换执行path&lt;/span&gt;
&lt;span&gt;397&lt;/span&gt; &lt;span&gt;  execl(path, path, NULL);
&lt;/span&gt;&lt;span&gt;398&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;int m = execl(path, path, NULL);
&lt;/span&gt;&lt;span&gt;399&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果path有问题，例如将html网页改成可执行的，但是执行后m为-1
&lt;/span&gt;&lt;span&gt;400&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;退出子进程，管道被破坏，但是父进程还在往里面写东西，触发Program received signal SIGPIPE, Broken pipe.&lt;/span&gt;
&lt;span&gt;401&lt;/span&gt;   exit(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;402&lt;/span&gt;  } &lt;span&gt;else&lt;/span&gt; {    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; parent &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;403&lt;/span&gt; 
&lt;span&gt;404&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭无用管道口&lt;/span&gt;
&lt;span&gt;405&lt;/span&gt;   close(cgi_output[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;406&lt;/span&gt;   close(cgi_input[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;407&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (strcasecmp(method, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;408&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; content_length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;409&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到post请求数据，写到input管道中，供子进程使用&lt;/span&gt;
&lt;span&gt;410&lt;/span&gt;     recv(client, &amp;amp;c, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;411&lt;/span&gt;     write(cgi_input[&lt;span&gt;1&lt;/span&gt;], &amp;amp;c, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;412&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;413&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从output管道读到子进程处理后的信息，然后send出去&lt;/span&gt;
&lt;span&gt;414&lt;/span&gt;   &lt;span&gt;while&lt;/span&gt; (read(cgi_output[&lt;span&gt;0&lt;/span&gt;], &amp;amp;c, &lt;span&gt;1&lt;/span&gt;) &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;415&lt;/span&gt;    send(client, &amp;amp;c, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;416&lt;/span&gt; 
&lt;span&gt;417&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;完成操作后关闭管道&lt;/span&gt;
&lt;span&gt;418&lt;/span&gt;   close(cgi_output[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;419&lt;/span&gt;   close(cgi_input[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;420&lt;/span&gt; 
&lt;span&gt;421&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待子进程返回&lt;/span&gt;
&lt;span&gt;422&lt;/span&gt;   waitpid(pid, &amp;amp;status, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;423&lt;/span&gt; 
&lt;span&gt;424&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;425&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;426&lt;/span&gt; 
&lt;span&gt;427&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;428&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Get a line from a socket, whether the line ends in a newline,
&lt;/span&gt;&lt;span&gt;429&lt;/span&gt; &lt;span&gt; * carriage return, or a CRLF combination.  Terminates the string read
&lt;/span&gt;&lt;span&gt;430&lt;/span&gt; &lt;span&gt; * with a null character.  If no newline indicator is found before the
&lt;/span&gt;&lt;span&gt;431&lt;/span&gt; &lt;span&gt; * end of the buffer, the string is terminated with a null.  If any of
&lt;/span&gt;&lt;span&gt;432&lt;/span&gt; &lt;span&gt; * the above three line terminators is read, the last character of the
&lt;/span&gt;&lt;span&gt;433&lt;/span&gt; &lt;span&gt; * string will be a linefeed and the string will be terminated with a
&lt;/span&gt;&lt;span&gt;434&lt;/span&gt; &lt;span&gt; * null character.
&lt;/span&gt;&lt;span&gt;435&lt;/span&gt; &lt;span&gt; * Parameters: the socket descriptor
&lt;/span&gt;&lt;span&gt;436&lt;/span&gt; &lt;span&gt; *             the buffer to save the data in
&lt;/span&gt;&lt;span&gt;437&lt;/span&gt; &lt;span&gt; *             the size of the buffer
&lt;/span&gt;&lt;span&gt;438&lt;/span&gt; &lt;span&gt; * Returns: the number of bytes stored (excluding null) &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;439&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;440&lt;/span&gt; 
&lt;span&gt;441&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到一行数据,只要发现c为\n,就认为是一行结束，如果读到\r,再用MSG_PEEK的方式读入一个字符，如果是\n，从socket用读出
&lt;/span&gt;&lt;span&gt;442&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是下个字符则不处理，将c置为\n，结束。如果读到的数据为0中断，或者小于0，也视为结束，c置为\n&lt;/span&gt;
&lt;span&gt;443&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; get_line(&lt;span&gt;int&lt;/span&gt; sock, &lt;span&gt;char&lt;/span&gt; *buf, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size)
&lt;/span&gt;&lt;span&gt;444&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;445&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;446&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; c = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;447&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;448&lt;/span&gt; 
&lt;span&gt;449&lt;/span&gt;  &lt;span&gt;while&lt;/span&gt; ((i &amp;lt; size - &lt;span&gt;1&lt;/span&gt;) &amp;amp;&amp;amp; (c != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;450&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;451&lt;/span&gt;   n = recv(sock, &amp;amp;c, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;452&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; DEBUG printf(&quot;%02X\n&quot;, c); &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;453&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (n &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;454&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;455&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;456&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;457&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;偷窥一个字节，如果是\n就读走&lt;/span&gt;
&lt;span&gt;458&lt;/span&gt;     n = recv(sock, &amp;amp;c, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, MSG_PEEK);
&lt;/span&gt;&lt;span&gt;459&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; DEBUG printf(&quot;%02X\n&quot;, c); &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;460&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((n &amp;gt; &lt;span&gt;0&lt;/span&gt;) &amp;amp;&amp;amp; (c == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;461&lt;/span&gt;      recv(sock, &amp;amp;c, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;462&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;463&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是\n（读到第一行的字符）或者没读到，置c为\n 跳出循环,完成一行读取&lt;/span&gt;
&lt;span&gt;464&lt;/span&gt;      c = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;465&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;466&lt;/span&gt;    buf[i] =&lt;span&gt; c;
&lt;/span&gt;&lt;span&gt;467&lt;/span&gt;    i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;468&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;469&lt;/span&gt;   &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;470&lt;/span&gt;    c = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;471&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;472&lt;/span&gt;  buf[i] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;473&lt;/span&gt;  
&lt;span&gt;474&lt;/span&gt;  &lt;span&gt;return&lt;/span&gt;&lt;span&gt;(i);
&lt;/span&gt;&lt;span&gt;475&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;476&lt;/span&gt; 
&lt;span&gt;477&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;478&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Return the informational HTTP headers about a file. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;479&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Parameters: the socket to print the headers on
&lt;/span&gt;&lt;span&gt;480&lt;/span&gt; &lt;span&gt; *             the name of the file &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;481&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;482&lt;/span&gt; 
&lt;span&gt;483&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入http的headers&lt;/span&gt;
&lt;span&gt;484&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; headers(&lt;span&gt;int&lt;/span&gt; client, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;filename)
&lt;/span&gt;&lt;span&gt;485&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;486&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;487&lt;/span&gt;  (&lt;span&gt;void&lt;/span&gt;)filename;  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; could use filename to determine file type &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;488&lt;/span&gt; 
&lt;span&gt;489&lt;/span&gt;  strcpy(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HTTP/1.0 200 OK\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;490&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;491&lt;/span&gt; &lt;span&gt; strcpy(buf, SERVER_STRING);
&lt;/span&gt;&lt;span&gt;492&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;493&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type: text/html\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;494&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;495&lt;/span&gt;  strcpy(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;496&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;497&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;498&lt;/span&gt; 
&lt;span&gt;499&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;500&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Give a client a 404 not found status message. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;501&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;502&lt;/span&gt; 
&lt;span&gt;503&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果资源没有找到得返回给客户端下面的信息&lt;/span&gt;
&lt;span&gt;504&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; not_found(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; client)
&lt;/span&gt;&lt;span&gt;505&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;506&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;507&lt;/span&gt; 
&lt;span&gt;508&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HTTP/1.0 404 NOT FOUND\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;509&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;510&lt;/span&gt; &lt;span&gt; sprintf(buf, SERVER_STRING);
&lt;/span&gt;&lt;span&gt;511&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;512&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type: text/html\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;513&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;514&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;515&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;516&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;HTML&amp;gt;&amp;lt;TITLE&amp;gt;Not Found&amp;lt;/TITLE&amp;gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;517&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;518&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;BODY&amp;gt;&amp;lt;P&amp;gt;The server could not fulfill\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;519&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;520&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;your request because the resource specified\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;521&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;522&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is unavailable or nonexistent.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;523&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;524&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/BODY&amp;gt;&amp;lt;/HTML&amp;gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;525&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;526&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;527&lt;/span&gt; 
&lt;span&gt;528&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;529&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Send a regular file to the client.  Use headers, and report
&lt;/span&gt;&lt;span&gt;530&lt;/span&gt; &lt;span&gt; * errors to client if they occur.
&lt;/span&gt;&lt;span&gt;531&lt;/span&gt; &lt;span&gt; * Parameters: a pointer to a file structure produced from the socket
&lt;/span&gt;&lt;span&gt;532&lt;/span&gt; &lt;span&gt; *              file descriptor
&lt;/span&gt;&lt;span&gt;533&lt;/span&gt; &lt;span&gt; *             the name of the file to serve &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;534&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;535&lt;/span&gt; 
&lt;span&gt;536&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是CGI文件，直接读取文件返回给请求的http客户端&lt;/span&gt;
&lt;span&gt;537&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; serve_file(&lt;span&gt;int&lt;/span&gt; client, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;filename)
&lt;/span&gt;&lt;span&gt;538&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;539&lt;/span&gt;  FILE *resource =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;540&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; numchars = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;541&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;542&lt;/span&gt; 
&lt;span&gt;543&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认字符&lt;/span&gt;
&lt;span&gt;544&lt;/span&gt;  buf[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; buf[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;545&lt;/span&gt;  &lt;span&gt;while&lt;/span&gt; ((numchars &amp;gt; &lt;span&gt;0&lt;/span&gt;) &amp;amp;&amp;amp; strcmp(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, buf))  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; read &amp;amp; discard headers &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;546&lt;/span&gt;   numchars = get_line(client, buf, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf));
&lt;/span&gt;&lt;span&gt;547&lt;/span&gt; 
&lt;span&gt;548&lt;/span&gt;  resource = fopen(filename, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;549&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (resource ==&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt;550&lt;/span&gt; &lt;span&gt;  not_found(client);
&lt;/span&gt;&lt;span&gt;551&lt;/span&gt;  &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;552&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;553&lt;/span&gt; &lt;span&gt;  headers(client, filename);
&lt;/span&gt;&lt;span&gt;554&lt;/span&gt; &lt;span&gt;  cat(client, resource);
&lt;/span&gt;&lt;span&gt;555&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;556&lt;/span&gt; &lt;span&gt; fclose(resource);
&lt;/span&gt;&lt;span&gt;557&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;558&lt;/span&gt; 
&lt;span&gt;559&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;560&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; This function starts the process of listening for web connections
&lt;/span&gt;&lt;span&gt;561&lt;/span&gt; &lt;span&gt; * on a specified port.  If the port is 0, then dynamically allocate a
&lt;/span&gt;&lt;span&gt;562&lt;/span&gt; &lt;span&gt; * port and modify the original port variable to reflect the actual
&lt;/span&gt;&lt;span&gt;563&lt;/span&gt; &lt;span&gt; * port.
&lt;/span&gt;&lt;span&gt;564&lt;/span&gt; &lt;span&gt; * Parameters: pointer to variable containing the port to connect on
&lt;/span&gt;&lt;span&gt;565&lt;/span&gt; &lt;span&gt; * Returns: the socket &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;566&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;567&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; startup(u_short *&lt;span&gt;port)
&lt;/span&gt;&lt;span&gt;568&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;569&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; httpd = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;570&lt;/span&gt;  &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in name;
&lt;/span&gt;&lt;span&gt;571&lt;/span&gt; 
&lt;span&gt;572&lt;/span&gt;  httpd = socket(PF_INET, SOCK_STREAM, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;573&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (httpd == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;574&lt;/span&gt;   error_die(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;socket&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;575&lt;/span&gt;  memset(&amp;amp;name, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(name));
&lt;/span&gt;&lt;span&gt;576&lt;/span&gt;  name.sin_family =&lt;span&gt; AF_INET;
&lt;/span&gt;&lt;span&gt;577&lt;/span&gt;  name.sin_port = htons(*&lt;span&gt;port);
&lt;/span&gt;&lt;span&gt;578&lt;/span&gt;  name.sin_addr.s_addr =&lt;span&gt; htonl(INADDR_ANY);
&lt;/span&gt;&lt;span&gt;579&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定socket&lt;/span&gt;
&lt;span&gt;580&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (bind(httpd, (&lt;span&gt;struct&lt;/span&gt; sockaddr *)&amp;amp;name, &lt;span&gt;sizeof&lt;/span&gt;(name)) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;581&lt;/span&gt;   error_die(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bind&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;582&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果端口没有设置，提供个随机端口&lt;/span&gt;
&lt;span&gt;583&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (*port == &lt;span&gt;0&lt;/span&gt;)  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; if dynamically allocating a port &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;584&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;585&lt;/span&gt;   socklen_t  namelen = &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(name);
&lt;/span&gt;&lt;span&gt;586&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (getsockname(httpd, (&lt;span&gt;struct&lt;/span&gt; sockaddr *)&amp;amp;name, &amp;amp;namelen) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;587&lt;/span&gt;    error_die(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getsockname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;588&lt;/span&gt;   *port =&lt;span&gt; ntohs(name.sin_port);
&lt;/span&gt;&lt;span&gt;589&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;590&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;监听&lt;/span&gt;
&lt;span&gt;591&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (listen(httpd, &lt;span&gt;5&lt;/span&gt;) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;592&lt;/span&gt;   error_die(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;listen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;593&lt;/span&gt;  &lt;span&gt;return&lt;/span&gt;&lt;span&gt;(httpd);
&lt;/span&gt;&lt;span&gt;594&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;595&lt;/span&gt; 
&lt;span&gt;596&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;597&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Inform the client that the requested web method has not been
&lt;/span&gt;&lt;span&gt;598&lt;/span&gt; &lt;span&gt; * implemented.
&lt;/span&gt;&lt;span&gt;599&lt;/span&gt; &lt;span&gt; * Parameter: the client socket &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;600&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;601&lt;/span&gt; 
&lt;span&gt;602&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果方法没有实现，就返回此信息&lt;/span&gt;
&lt;span&gt;603&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; unimplemented(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; client)
&lt;/span&gt;&lt;span&gt;604&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;605&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;606&lt;/span&gt; 
&lt;span&gt;607&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HTTP/1.0 501 Method Not Implemented\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;608&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;609&lt;/span&gt; &lt;span&gt; sprintf(buf, SERVER_STRING);
&lt;/span&gt;&lt;span&gt;610&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;611&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type: text/html\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;612&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;613&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;614&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;615&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;HTML&amp;gt;&amp;lt;HEAD&amp;gt;&amp;lt;TITLE&amp;gt;Method Not Implemented\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;616&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;617&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/TITLE&amp;gt;&amp;lt;/HEAD&amp;gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;618&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;619&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;BODY&amp;gt;&amp;lt;P&amp;gt;HTTP request method not supported.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;620&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;621&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/BODY&amp;gt;&amp;lt;/HTML&amp;gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;622&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;623&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;624&lt;/span&gt; 
&lt;span&gt;625&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;626&lt;/span&gt; 
&lt;span&gt;627&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;628&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;629&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; server_sock = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;630&lt;/span&gt;  u_short port = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;631&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; client_sock = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;632&lt;/span&gt;  &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in client_name;
&lt;/span&gt;&lt;span&gt;633&lt;/span&gt; 
&lt;span&gt;634&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这边要为socklen_t类型&lt;/span&gt;
&lt;span&gt;635&lt;/span&gt;  socklen_t client_name_len = &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(client_name);
&lt;/span&gt;&lt;span&gt;636&lt;/span&gt; &lt;span&gt; pthread_t newthread;
&lt;/span&gt;&lt;span&gt;637&lt;/span&gt; 
&lt;span&gt;638&lt;/span&gt;  server_sock = startup(&amp;amp;&lt;span&gt;port);
&lt;/span&gt;&lt;span&gt;639&lt;/span&gt;  printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;httpd running on port %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, port);
&lt;/span&gt;&lt;span&gt;640&lt;/span&gt; 
&lt;span&gt;641&lt;/span&gt;  &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;642&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;643&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接受请求，函数原型
&lt;/span&gt;&lt;span&gt;644&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;#include &amp;lt;sys/types.h&amp;gt;
&lt;/span&gt;&lt;span&gt;645&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;#include &amp;lt;sys/socket.h&amp;gt;  
&lt;/span&gt;&lt;span&gt;646&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);&lt;/span&gt;
&lt;span&gt;647&lt;/span&gt;   client_sock =&lt;span&gt; accept(server_sock,
&lt;/span&gt;&lt;span&gt;648&lt;/span&gt;                        (&lt;span&gt;struct&lt;/span&gt; sockaddr *)&amp;amp;&lt;span&gt;client_name,
&lt;/span&gt;&lt;span&gt;649&lt;/span&gt;                        &amp;amp;&lt;span&gt;client_name_len);
&lt;/span&gt;&lt;span&gt;650&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (client_sock == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;651&lt;/span&gt;       error_die(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;accept&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;652&lt;/span&gt;  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; accept_request(client_sock); &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;653&lt;/span&gt; 
&lt;span&gt;654&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次收到请求，创建一个线程来处理接受到的请求
&lt;/span&gt;&lt;span&gt;655&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把client_sock转成地址作为参数传入pthread_create&lt;/span&gt;
&lt;span&gt;656&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (pthread_create(&amp;amp;newthread, NULL, (&lt;span&gt;void&lt;/span&gt; *)accept_request, (&lt;span&gt;void&lt;/span&gt; *)(intptr_t)client_sock) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;657&lt;/span&gt;       perror(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pthread_create&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;658&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;659&lt;/span&gt; 
&lt;span&gt;660&lt;/span&gt; &lt;span&gt; close(server_sock);
&lt;/span&gt;&lt;span&gt;661&lt;/span&gt; 
&lt;span&gt;662&lt;/span&gt;  &lt;span&gt;return&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;663&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Fri, 10 Nov 2017 13:38:00 +0000</pubDate>
<dc:creator>nengm</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nengm1988/p/7816618.html</dc:identifier>
</item>
<item>
<title>图解常用算法 - Amedeo</title>
<link>http://www.cnblogs.com/Amedeo/p/7816215.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Amedeo/p/7816215.html</guid>
<description>&lt;p&gt;我们经常会用到一些算法，而大部分算法过于抽象，记忆起来比较困难，而使用图解可以帮助我们更好地理解和记忆这些算法。&lt;/p&gt;
&lt;h2&gt;一、深度优先搜索算法（DFS）&lt;/h2&gt;
&lt;p&gt;深度优先搜索算法（Depth-First-Search），是搜索算法的一种。它是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。一般用堆数据结构来辅助实现 DFS 算法。DFS 属于盲目搜索。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深度优先遍历图算法步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 访问顶点 v；&lt;/p&gt;
&lt;p&gt;2. 依次从 v 的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和 v 有路径相通的顶点都被访问；&lt;/p&gt;
&lt;p&gt;3. 若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。&lt;/p&gt;
&lt;p&gt;上述描述可能比较抽象，举个实例：&lt;/p&gt;
&lt;p&gt;DFS 在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点 w1；再从 w1 出发，访问与 w1 邻接但还没有访问过的顶点 w2；然后再从 w2 出发，进行类似的访问，…如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 u 为止。&lt;/p&gt;
&lt;p&gt;接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问；如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。&lt;/p&gt;

&lt;h2&gt;二、广度优先搜索算法（BFS）&lt;/h2&gt;
&lt;p&gt;广度优先搜索算法（Breadth-First-Search），是一种图形搜索算法。简单的说，BFS 是从根节点开始，沿着树 (图) 的宽度遍历树 (图) 的节点。如果所有节点均被访问，则算法中止。BFS 同样属于盲目搜索。一般用队列数据结构来辅助实现 BFS 算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 首先将根节点放入队列中。&lt;/p&gt;
&lt;p&gt;2. 从队列中取出第一个节点，并检验它是否为目标。&lt;/p&gt;
&lt;p&gt;如果找到目标，则结束搜寻并回传结果。&lt;/p&gt;
&lt;p&gt;否则将它所有尚未检验过的直接子节点加入队列中。&lt;/p&gt;
&lt;p&gt;3. 若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传「找不到目标」。&lt;/p&gt;
&lt;p&gt;4. 重复步骤 2。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img1.tuicool.com/rEZbMnj.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、归并排序算法&lt;/h2&gt;
&lt;p&gt;归并排序（Mergesort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（DivideandConquer）的一个非常典型的应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列&lt;/p&gt;
&lt;p&gt;2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置&lt;/p&gt;
&lt;p&gt;3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置&lt;/p&gt;
&lt;p&gt;4. 重复步骤 3 直到某一指针达到序列尾&lt;/p&gt;
&lt;p&gt;5. 将另一序列剩下的所有元素直接复制到合并序列尾&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/KfLGF0ibu6cKjBVIUxr7VmibY5YwUMxXicHRzyjT6hk4MfZsGrINyPuaialyK14ib6atVfmCkiaibqjT3zjoZNkgrHicpw/0?wx_fmt=gif&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; width=&quot;auto&quot; data-ratio=&quot;0.8464285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/KfLGF0ibu6cKjBVIUxr7VmibY5YwUMxXicHRzyjT6hk4MfZsGrINyPuaialyK14ib6atVfmCkiaibqjT3zjoZNkgrHicpw/0?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;280&quot; data-order=&quot;3&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;四、Dijkstra算法&lt;/h2&gt;
&lt;p&gt;戴克斯特拉算法（Dijkstra算法）是由荷兰计算机科学家艾兹赫尔·戴克斯特拉提出。迪科斯彻算法使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。&lt;/p&gt;
&lt;p&gt;该算法的输入包含了一个有权重的有向图 G，以及 G 中的一个来源顶点 S。我们以 V 表示 G 中所有顶点的集合。每一个图中的边，都是两个顶点所形成的有序元素对。(u,v) 表示从顶点 u 到 v 有路径相连。我们以 E 表示 G 中所有边的集合，而边的权重则由权重函数 w:E→[0,∞] 定义。因此，w(u,v) 就是从顶点 u 到顶点 v 的非负权重（weight）。边的权重可以想像成两个顶点之间的距离。任两点间路径的权重，就是该路径上所有边的权重总和。已知有 V 中有顶点 s 及 t，Dijkstra 算法可以找到 s 到 t 的最低权重路径 (例如，最短路径)。这个算法也可以在一个图中，找到从一个顶点 s 到任何其他顶点的最短路径。对于不含负权的有向图，Dijkstra 算法是目前已知的最快的单源最短路径算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 初始时令 S={V0},T={其余顶点}，T 中顶点对应的距离值&lt;/p&gt;
&lt;p&gt;若存在，d(V0,Vi) 为弧上的权值&lt;/p&gt;
&lt;p&gt;若不存在，d(V0,Vi) 为∞&lt;/p&gt;
&lt;p&gt;2. 从 T 中选取一个其距离值为最小的顶点 W 且不在 S 中，加入 S&lt;/p&gt;
&lt;p&gt;3. 对其余 T 中顶点的距离值进行修改：若加进 W 作中间顶点，从 V0 到 Vi 的距离值缩短，则修改此距离值&lt;/p&gt;
&lt;p&gt;重复上述步骤 2、3，直到 S 中包含所有顶点，即 W=Vi 为止&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/KfLGF0ibu6cKjBVIUxr7VmibY5YwUMxXicHM8Jz7498EXKGRU7U8Ekribmau1vwgjG6XYJwJ2p6lt3wXeEIC40yuuQ/0?wx_fmt=gif&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;retryload=1&quot; alt=&quot;&quot; width=&quot;auto&quot; data-ratio=&quot;0.784452296819788&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/KfLGF0ibu6cKjBVIUxr7VmibY5YwUMxXicHM8Jz7498EXKGRU7U8Ekribmau1vwgjG6XYJwJ2p6lt3wXeEIC40yuuQ/0?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;283&quot; data-order=&quot;5&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;五、Bellman-Ford算法&lt;/h2&gt;
&lt;p&gt;Bellman-Ford算法能在更普遍的情况下（存在负权边）解决单源点最短路径问题。对于给定的带权（有向或无向）图 G=(V , E)，其源点为 s，加权函数 w 是边集 E 的映射。对图 G 运行Bellman-Ford算法的结果是一个布尔值，表明图中是否存在着一个从源点 s 可达的负权回路。若不存在这样的回路，算法将给出从源点 s 到图 G 的任意顶点 v 的最短路径d[v]。Bellman-Ford算法是在带权图中计算从单一源点出发到其他节点的最短路径的算法。&lt;span&gt;尽管算法复杂度大于 Dijkstra 算法，但是它适用于包含了负值边的图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img2.tuicool.com/jEfMnqZ.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;六、Prim算法&lt;/h2&gt;
&lt;p&gt;普里姆算法（Prim算法），图论中一种重要的算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点（英语：Vertex (graph theory)），且其所有边的权值之和亦为最小。Prim算法是用于在带权无向图中计算最小生成树的贪婪算法。换言之，它能够在图中抽取出连接所有节点的边的最小代价子集。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img1.tuicool.com/nMnu2mi.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;七、Kruskal算法&lt;/h2&gt;
&lt;p&gt;克鲁斯卡尔算法（ruskal算法）同样是计算图的最小生成树的算法，&lt;span&gt;跟 Prim 算法的区别在于Kruskal算法不需要图是连通的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img1.tuicool.com/aMj2qqJ.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;作者：耑新新，发布于  &lt;a title=&quot;博客园&quot; href=&quot;https://home.cnblogs.com/u/Amedeo/&quot; target=&quot;_blank&quot;&gt;博客园&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载请注明出处，欢迎邮件交流：&lt;a title=&quot;给我写信&quot; href=&quot;http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;amp;email=VC48ITU6LD06LD06FDI7LDk1PTh6Nzs5&quot; target=&quot;_blank&quot;&gt;zhuanxinxin@foxmail.com&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 10 Nov 2017 12:49:00 +0000</pubDate>
<dc:creator>Amedeo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Amedeo/p/7816215.html</dc:identifier>
</item>
<item>
<title>28.Linux-IIC驱动(详解) - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/7816324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/7816324.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;上一节&lt;/span&gt; 我们学习了:  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;IIC接口下的24C02 驱动分析:&lt;/span&gt; &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/lifexy/p/7793686.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.cnblogs.com/lifexy/p/7793686.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来本节, 学习Linux下如何利用linux下I2C驱动体系结构来操作24C02&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. I2C体系结构分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.1首先进入linux内核的driver/i2c目录下,如下图所示:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194402075-2024973640.png&quot; alt=&quot;&quot; width=&quot;476&quot; height=&quot;138&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中重要的文件介绍如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1)&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;algos文件夹&lt;/span&gt;(algorithms)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;里面保存I2C的通信方面的算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2)&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;busses文件夹&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;里面保存I2C总线驱动相关的文件,比如i2c-omap.c、 i2c-versatile.c、 i2c-s3c2410.c等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;3)&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;chips文件夹&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;里面保存I2C设备驱动相关的文件,如下图所示,比如m41t00,就是RTC实时钟&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194416216-654621318.png&quot; alt=&quot;&quot; width=&quot;369&quot; height=&quot;174&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;4)&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;i2c-core.c&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这个文件实现了I2C核心的功能(I2C总线的初始化、注册和适配器添加和注销等相关工作)以及/proc/bus/i2c*接口。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;5)&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;i2c-dev.c&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;提供了通用的read（ ） 、 write（ ） 和ioctl（ ） 等接口，实现了I2C适配器设备文件的功能，其中I2C设备的主设备号都为89， 次设备号为0~255。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;应用层可以借用这些接口访问挂接在适配器上的I2C设备的存储空间或寄存器， 并控制I2C设备的工作方&lt;/span&gt;&lt;span&gt;式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然,它和前几次驱动类似， I2C也分为总线驱动和设备驱动,总线就是协议相关的，它知道如何收发数据，但不知道数据含义，设备驱动却知道数据含义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.2 I2C驱动架构,如下图所示:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194431294-567878229.png&quot; alt=&quot;&quot; width=&quot;274&quot; height=&quot;494&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上图所示,每一条I2C对应一个adapter适配器,在kernel中, adapter适配器是通过struct adapter结构体定义,主要是通过i2c core层将i2c设备与i2c adapter关联起来.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在kernel中提供了&lt;span&gt;两个adapter注册接口&lt;/span&gt;,分别为i2c_add_adapter()和i2c_add_numbered_adapter().由于在系统中可能存在多个adapter,因为将每一条I2C总线对应一个编号,下文中称为I2C总线号.这个总线号的PCI中的总线号不同.它和硬件无关,只是软件上便于区分而已.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于i2c_add_adapter()而言,它使用的是动态总线号,即由系统给其分析一个总线号,而i2c_add_numbered_adapter()则是自己指定总线号,如果这个总线号非法或者是被占用,就会注册失败.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.接下来便来分析I2C总线驱动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考 drivers/i2c/busses/i2c-s3c2410.c&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先进入init入口函数,如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194447059-1799759547.png&quot; alt=&quot;&quot; width=&quot;435&quot; height=&quot;304&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在init函数中,注册了一个 &lt;span&gt;“s3c2440-i2c”&lt;/span&gt;的platform_driver平台驱动,我们来看看probe函数做了些什么&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.进入s3c24xx_i2c_probe函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; i2c_adapter  adap;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; s3c24xx_i2c_probe(&lt;span&gt;struct&lt;/span&gt; platform_device *&lt;span&gt;pdev)
{
　　　　&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; s3c24xx_i2c *i2c = &amp;amp;&lt;span&gt;s3c24xx_i2c;
       ... ...

       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;获取,使能I2C时钟&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       i2c&lt;/span&gt;-&amp;gt;clk = clk_get(&amp;amp;pdev-&amp;gt;dev, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i2c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取i2c时钟&lt;/span&gt;&lt;span&gt;
       clk_enable(i2c&lt;/span&gt;-&amp;gt;clk);                                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使能i2c时钟&lt;/span&gt;
&lt;span&gt;
       ... ....
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;获取资源&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       res &lt;/span&gt;= platform_get_resource(pdev, IORESOURCE_MEM, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
       i2c&lt;/span&gt;-&amp;gt;regs = ioremap(res-&amp;gt;start, (res-&amp;gt;end-res-&amp;gt;start)+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

       ... ....

       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置i2c_adapter适配器结构体, 将i2c结构体设为adap的私有数据成员&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
　　　　i2c&lt;/span&gt;-&amp;gt;adap.algo_data = i2c;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;i2c_adapter适配器指向s3c24xx_i2c;&lt;/span&gt;&lt;span&gt;
       i2c&lt;/span&gt;-&amp;gt;adap.dev.parent = &amp;amp;pdev-&amp;gt;&lt;span&gt;dev;

 
　　　　&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; initialise the i2c controller &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;初始化2440的I2C相关的寄存器&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       ret &lt;/span&gt;=&lt;span&gt; s3c24xx_i2c_init(i2c);
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ret != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
              &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; err_iomap;

       ... ...
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;注册中断服务函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       ret &lt;/span&gt;= request_irq(res-&amp;gt;start, s3c24xx_i2c_irq, IRQF_DISABLED,pdev-&amp;gt;&lt;span&gt;name, i2c);
       ... ...

       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;注册i2c_adapter适配器结构体&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       ret &lt;/span&gt;= i2c_add_adapter(&amp;amp;i2c-&amp;gt;&lt;span&gt;adap);
       ... ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中i2c_adapter结构体是放在s3c24xx_i2c-&amp;gt;adap下,如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194502481-835272550.png&quot; alt=&quot;&quot; width=&quot;317&quot; height=&quot;300&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.接下来我们进入i2c_add_adapter()函数看看,到底如何注册的&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; i2c_add_adapter(&lt;span&gt;struct&lt;/span&gt; i2c_adapter *&lt;span&gt;adapter)
{
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;   id, res = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

retry:
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (idr_pre_get(&amp;amp;i2c_adapter_idr, GFP_KERNEL) == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用idr_pre_get()为i2c_adapter预留内存空间&lt;/span&gt;
              &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;ENOMEM;

       mutex_lock(&lt;/span&gt;&amp;amp;&lt;span&gt;core_lists);

       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; &quot;above&quot; here means &quot;above or equal to&quot;, sigh &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       res &lt;/span&gt;= idr_get_new_above(&amp;amp;i2c_adapter_idr, adapter,__i2c_first_dynamic_bus_num, &amp;amp;&lt;span&gt;id);
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用idr_get_new_above()将结构插入i2c_adapter_idr中,并将插入的位置赋给id,以后可以通过id在i2c_adapter_idr中找到相应的i2c_adapter结构体&lt;/span&gt;
&lt;span&gt;
       mutex_unlock(&lt;/span&gt;&amp;amp;&lt;span&gt;core_lists);

       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (res &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (res == -&lt;span&gt;EAGAIN)
                    &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; retry;
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
       }
       adapter&lt;/span&gt;-&amp;gt;nr =&lt;span&gt; id;
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; i2c_register_adapter(adapter);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用i2c_register_adapter()函数进一步来注册.&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中i2c_register_adapter()函数代码如下所示:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i2c_register_adapter(&lt;span&gt;struct&lt;/span&gt; i2c_adapter *&lt;span&gt;adap)
{
       &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; list_head  *item;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;链表头,用来存放i2c_driver结构体的表头&lt;/span&gt;
       &lt;span&gt;struct&lt;/span&gt; i2c_driver *driver;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;i2c_driver,用来描述一个IIC设备驱动&lt;/span&gt;&lt;span&gt;
        list_add_tail(&lt;/span&gt;&amp;amp;adap-&amp;gt;list, &amp;amp;adapters);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加到内核的adapter链表中&lt;/span&gt;&lt;span&gt;
        ... ...
       list_for_each(item,&lt;/span&gt;&amp;amp;drivers) {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;for循环,从drivers链表里找到i2c_driver结构体的表头&lt;/span&gt;&lt;span&gt;
              driver &lt;/span&gt;= list_entry(item, &lt;span&gt;struct&lt;/span&gt; i2c_driver, list); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过list_head表头,找到i2c_driver结构体&lt;/span&gt;
              &lt;span&gt;if&lt;/span&gt; (driver-&amp;gt;&lt;span&gt;attach_adapter)  
                     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; We ignore the return code; if it fails, too bad &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                     driver&lt;/span&gt;-&amp;gt;&lt;span&gt;attach_adapter(adap);    &lt;br/&gt;　　　　　　　　　　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用i2c_driver的attach_adapter函数来看看,这个新注册的设配器是否支持i2c_driver&lt;/span&gt;&lt;span&gt; }&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在i2c_register_adapter()函数里主要执行以下几步:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;①&lt;/strong&gt;&lt;/span&gt;将adapter放入i2c_bus_type的&lt;span&gt;adapter链表&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;②&lt;/span&gt;&lt;/strong&gt;将所有的i2c设备调出来,执行i2c_driver设备的attach_adapter函数来匹配&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中, i2c_driver结构体会在后面讲述到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;而i2c_adapter适配器结构体的成员结构,如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; i2c_adapter {  

 &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; module *owner;　　　　　　　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;所属模块  &lt;/span&gt;&lt;span&gt;
 unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; id;　　　　　　　　　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;algorithm的类型，定义于i2c-id.h,  &lt;/span&gt;&lt;span&gt;
 unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;      
 &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; i2c_algorithm *algo; 　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;总线通信方法结构体指针  &lt;/span&gt;
 &lt;span&gt;void&lt;/span&gt; *algo_data;   　　　　　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;algorithm数据  &lt;/span&gt;
 &lt;span&gt;struct&lt;/span&gt; rt_mutex bus_lock;　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;控制并发访问的自旋锁  &lt;/span&gt;
 &lt;span&gt;int&lt;/span&gt;&lt;span&gt; timeout;     
 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; retries;　　　　　　　　　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重试次数  &lt;/span&gt;
 &lt;span&gt;struct&lt;/span&gt; device dev; 　　　　　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;适配器设备   &lt;/span&gt;
 &lt;span&gt;int&lt;/span&gt; nr;                  　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放在i2c_adapter_idr里的位置号&lt;/span&gt;
 &lt;span&gt;char&lt;/span&gt; name[&lt;span&gt;48&lt;/span&gt;];　　　　　　　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;适配器名称  &lt;/span&gt;
 &lt;span&gt;struct&lt;/span&gt; completion dev_released;　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于同步  &lt;/span&gt;
 &lt;span&gt;struct&lt;/span&gt; list_head userspace_clients;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;client链表头  &lt;/span&gt;
&lt;span&gt;
};  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;i2c_adapter表示物理上的一个i2C设备(适配器), 在i2c-s3c2410.c中,是存放在s3c24xx_i2c结构体下的(struct  i2c_adapter  adap)成员中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.其中s3c24xx_i2c的结构体成员如下所示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; i2c_algorithm s3c24xx_i2c_algorithm =&lt;span&gt; {            
       .master_xfer          &lt;/span&gt;= s3c24xx_i2c_xfer,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主机传输&lt;/span&gt;&lt;span&gt;
       .functionality          &lt;/span&gt;=&lt;span&gt; s3c24xx_i2c_func,                    
};

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; s3c24xx_i2c s3c24xx_i2c =&lt;span&gt; {
       .&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;              = __SPIN_LOCK_UNLOCKED(s3c24xx_i2c.&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;),
       .wait              &lt;/span&gt;=&lt;span&gt; __WAIT_QUEUE_HEAD_INITIALIZER(s3c24xx_i2c.wait),
       .tx_setup &lt;/span&gt;= &lt;span&gt;50&lt;/span&gt;,                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来延时,等待SCL被释放&lt;/span&gt;&lt;span&gt;
       .adap             &lt;/span&gt;= {                                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; i2c_adapter适配器结构体&lt;/span&gt;&lt;span&gt;
              .name                   &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s3c2410-i2c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
              .owner                  &lt;/span&gt;=&lt;span&gt; THIS_MODULE,
              .algo                     &lt;/span&gt;= &amp;amp;s3c24xx_i2c_algorithm,           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放i2c_algorithm算法结构体&lt;/span&gt;&lt;span&gt;
              .retries           &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;,                                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重试次数&lt;/span&gt;&lt;span&gt;
              .&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;                    =&lt;span&gt; I2C_CLASS_HWMON,
       },
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;显然这里是直接设置了i2c_adapter结构体,所以在s3c24xx_i2c_probe ()函数中没有分配i2c_adapter适配器结构体,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中, i2c_adapter结构体的名称等于&quot;s3c2410-i2c&quot;,它的通信方式等于s3c24xx_i2c_algorithm,重试次数等于2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;PS:如果缺少i2c_algorithm的i2c_adapter什么也做不了，就只是个I2C设备,而没有通信方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;s3c24xx_i2c_algorithm中的关键函数master_xfer()就是用于产生i2c访问周期需要的&lt;span&gt;start stop ack&lt;/span&gt;等信号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如,在s3c24xx_i2c_algorithm中的关键函数master_xfer()里,调用了:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;s3c24xx_i2c_xfer -&amp;gt; s3c24xx_i2c_doxfer()-&amp;gt;s3c24xx_i2c_message_start()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;来启动传输message信息, 其中&lt;span&gt;s3c24xx_i2c_message_start()&lt;/span&gt;函数代码如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; s3c24xx_i2c_message_start(&lt;span&gt;struct&lt;/span&gt; s3c24xx_i2c *i2c, &lt;span&gt;struct&lt;/span&gt; i2c_msg *&lt;span&gt;msg)
{

 unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; addr = (msg-&amp;gt;addr &amp;amp; &lt;span&gt;0x7f&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IIC从设备地址的最低位为读写标志位&lt;/span&gt;&lt;span&gt;
       ... ...

       stat &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
       stat &lt;/span&gt;|=  S3C2410_IICSTAT_TXRXEN;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置标志位启动IIC收发使能&lt;/span&gt;

       &lt;span&gt;if&lt;/span&gt; (msg-&amp;gt;flags &amp;amp; I2C_M_RD) {                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是读,还是写&lt;/span&gt;&lt;span&gt;
              stat &lt;/span&gt;|=&lt;span&gt; S3C2410_IICSTAT_MASTER_RX;       
              addr &lt;/span&gt;|= &lt;span&gt;1&lt;/span&gt;;                                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置从IIC设备地址为读标志&lt;/span&gt;&lt;span&gt;
       } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
              stat &lt;/span&gt;|=&lt;span&gt; S3C2410_IICSTAT_MASTER_TX;

       s3c24xx_i2c_enable_ack(i2c);                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使能ACK信号&lt;/span&gt;
&lt;span&gt;
　　　　iiccon &lt;/span&gt;= readl(i2c-&amp;gt;regs + S3C2410_IICCON);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读出IICCON寄存器&lt;/span&gt;
&lt;span&gt;
       writel(stat, i2c&lt;/span&gt;-&amp;gt;regs + S3C2410_IICSTAT);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入IICSTAT寄存器,使能IIC的读或写标志&lt;/span&gt;
&lt;span&gt;
       dev_dbg(i2c&lt;/span&gt;-&amp;gt;dev, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;START: %08lx to IICSTAT, %02x to DS\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, stat, addr);

       writeb(addr, i2c&lt;/span&gt;-&amp;gt;regs + S3C2410_IICDS);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将IIC从设备地址写入IICDS寄存器&lt;/span&gt;

       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; delay here to ensure the data byte has gotten onto the bus
        * before the transaction is started &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

       ndelay(i2c&lt;/span&gt;-&amp;gt;tx_setup);         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时,等待SCL被释放,下面便可以发送起始信号+IIC设备地址值&lt;/span&gt;
&lt;span&gt;

       dev_dbg(i2c&lt;/span&gt;-&amp;gt;dev, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;iiccon, %08lx\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, iiccon);
       writel(iiccon, i2c&lt;/span&gt;-&amp;gt;regs +&lt;span&gt; S3C2410_IICCON);            

       stat &lt;/span&gt;|=&lt;span&gt;  S3C2410_IICSTAT_START;              
       writel(stat, i2c&lt;/span&gt;-&amp;gt;regs +&lt;span&gt; S3C2410_IICSTAT); 
　　　　　　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置IICSTAT寄存器的bit5=1,开始发送起始信号+IIC从设备地址值,并回应ACK&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过上面的代码和注释,发现主要是写入IIC从设备地址,然后发送起始信号+IIC从设备地址值,并回应ACK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然IIC总线驱动i2c-s3c2410.c,主要设置适配器adapter,里面帮我们做好了IIC通信的架构,就是不知道发什么内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;我们进入driver/i2c/chips中,看看eeprom设备驱动是如何写的&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考: driver/i2c/chips/eeprom.c&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.还是首先来看它的init入口函数:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194519716-1730511691.png&quot; alt=&quot;&quot; width=&quot;504&quot; height=&quot;147&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中struct  i2c_driver  eeprom_driver的成员如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; i2c_driver eeprom_driver =&lt;span&gt; {
       .driver &lt;/span&gt;=&lt;span&gt; {
              .name     &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eeprom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;名称&lt;/span&gt;&lt;span&gt;
        },
       .id           &lt;/span&gt;= I2C_DRIVERID_EEPROM,           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IIC设备标识ID&lt;/span&gt;&lt;span&gt;
       .attach_adapter     &lt;/span&gt;=&lt;span&gt; eeprom_attach_adapter,  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来与总线驱动的适配器匹配,匹配成功添加到适配器adapter中&lt;/span&gt;&lt;span&gt;
       .detach_client &lt;/span&gt;= eeprom_detach_client,      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;与总线驱动的适配器解绑,分离这个IIC从设备&lt;/span&gt;&lt;span&gt;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如下图所示, eeprom_driver结构体的ID成员在i2c-id.h中,里面还定义了大部分常用I2C设备驱动的设备ID&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194533466-969534257.png&quot; alt=&quot;&quot; width=&quot;287&quot; height=&quot;298&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然,在init函数中通过i2c_add_driver()注册i2c_driver结构体,然后通过i2c_driver -&amp;gt;attach_adapter来匹配内核中的各个总线驱动的适配器, 发送这个设备地址,若有ACK响应,表示匹配成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7.接下来,我们进入i2c_add_driver()来看看是不是这样的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; i2c_add_driver(&lt;span&gt;struct&lt;/span&gt; module *owner, &lt;span&gt;struct&lt;/span&gt; i2c_driver *&lt;span&gt;driver)
{
       driver&lt;/span&gt;-&amp;gt;driver.owner =&lt;span&gt; owner;
       driver&lt;/span&gt;-&amp;gt;driver.bus = &amp;amp;i2c_bus_type;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将i2c_driver放在i2c_bus_type链表中&lt;/span&gt;&lt;span&gt;   

       res &lt;/span&gt;= driver_register(&amp;amp;driver-&amp;gt;driver); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册一个i2c_driver&lt;/span&gt;&lt;span&gt;
       ... ...

       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (driver-&amp;gt;&lt;span&gt;attach_adapter) {
              &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; i2c_adapter *adapter;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个i2c_adapter适配器&lt;/span&gt;&lt;span&gt;
          list_for_each_entry(adapter, &lt;/span&gt;&amp;amp;&lt;span&gt;adapters, list)  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;for循环提取出adapters链表中所有的i2c_adapter适配器,放入到adapter结构体中&lt;/span&gt;&lt;span&gt;
 　　　　　{
          driver&lt;/span&gt;-&amp;gt;attach_adapter(adapter); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;来匹配取出来的i2c_adapter适配器&lt;/span&gt;&lt;span&gt;
          }
  }
      ... ...
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在i2c_add_driver ()函数里主要执行以下几步:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;①&lt;/strong&gt;&lt;/span&gt;放入到&lt;span&gt;i2c_bus_type链表&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;②&lt;/strong&gt;&lt;/span&gt;取出&lt;span&gt;adapters链表&lt;/span&gt;中所有的i2c_adapter,然后执行&lt;span&gt;i2c_driver-&amp;gt;attach_adapter()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;所以i2c_adapter适配器和i2c_driver设备驱动注册框架如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194549372-635602878.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 这里调用了i2c_driver -&amp;gt;attach_adapter(adapter),我们看看里面是不是通过发送IIC设备地址，等待ACK响应来匹配的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8.以struct i2c_driver eeprom_driver 为例,进入i2c_driver -&amp;gt;eeprom_attach_adapter()函数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194557138-2076450775.png&quot; alt=&quot;&quot; width=&quot;446&quot; height=&quot;154&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示,里面调用了i2c_probe(adapter, &amp;amp;addr_data, eeprom_detect)函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194605794-2061351036.png&quot; alt=&quot;&quot; width=&quot;551&quot; height=&quot;75&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图的&lt;span&gt;第1个参数&lt;/span&gt;就是i2c_adapter适配器,&lt;span&gt;第2个参数&lt;/span&gt;addr_data变量,里面存放了IIC设备地址的信息,&lt;span&gt;第3个参数&lt;/span&gt;eeprom_detect就是具体的设备探测回调函数&lt;/span&gt;&lt;span&gt;i2c_probe()函数,会通过adapter适配器发送IIC设备地址addr_data,如果收到ACK信号,就调用eeprom_detect()回调函数来注册i2c_client结构体,该结构体对应真实的物理从设备,而i2c_driver对应的是设备驱动,也就是说,只有当适配器支持这个设备驱动,才会注册i2c_client从设备,后面会讲这个回调函数如何注册i2c_client&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而在i2c_driver -&amp;gt;detach_client()中,则注销i2c_client结构体&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中addr_data变量是&lt;span&gt;struct i2c_client_address_data&lt;/span&gt;&lt;strong&gt;结构体&lt;/strong&gt;,它的成员如下所示:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; i2c_client_address_data {
       unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; *normal_i2c;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放正常的设备高7位地址数据&lt;/span&gt;&lt;span&gt;
       unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; *probe;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放不受*ignore影响的高7位设备地址数据&lt;/span&gt;&lt;span&gt;
       unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; *ignore;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放*ignore的高7位设备地址数据&lt;/span&gt;&lt;span&gt;
       unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; **forces;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;forces表示适配器匹配不了该设备,也要将其放入适配器中&lt;/span&gt;
&lt;span&gt;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当上面结构体的数组成员以I2C_CLIENT_END结尾,则表示地址已结束,&lt;span&gt;比如at24c02设备为例&lt;/span&gt;,看这个结构体如何定义的:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt;  AT24C02_ADDR           (0xA0&amp;gt;&amp;gt;1)           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;AT24C02地址&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;short&lt;/span&gt;  ignore[] =&lt;span&gt; { I2C_CLIENT_END };
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;short&lt;/span&gt;  normal_addr[] =&lt;span&gt; { AT24C02_ADDR, I2C_CLIENT_END };
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;short&lt;/span&gt;   force_addr[] =&lt;span&gt; {ANY_I2C_BUS, AT24C02_ADDR ,2C_CLIENT_END};
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;short&lt;/span&gt;   * forces[] =&lt;span&gt; {force_addr, NULL};&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　　　　　　　　　　　//&lt;/span&gt;&lt;span&gt;ANY_I2C_BUS:表示支持所有适配器总线,若填指定的适配器总线ID,则表示该设备只支持指定的那个适配器&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; i2c_client_address_data  addr_data =&lt;span&gt; {
       .normal_i2c     &lt;/span&gt;= normal_addr,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放at24c02地址&lt;/span&gt;&lt;span&gt;
       .probe           &lt;/span&gt;= ignore,        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示无地址&lt;/span&gt;&lt;span&gt;
       .ignore           &lt;/span&gt;= ignore,        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示无地址&lt;/span&gt;&lt;span&gt;
       . forces          &lt;/span&gt;= forces,        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放强制的at24c02地址,表示强制支持&lt;/span&gt;
&lt;span&gt;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;一般而言,都不会设置.forces成员,这里只是打个比方&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;8.1接下来继续进入i2c_probe()函数继续分析,如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; i2c_probe(&lt;span&gt;struct&lt;/span&gt; i2c_adapter *&lt;span&gt;adapter,&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; i2c_client_address_data *&lt;span&gt;address_data,&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; (*found_proc) (&lt;span&gt;struct&lt;/span&gt; i2c_adapter *, &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;))
{
       ... ...
       err &lt;/span&gt;=&lt;span&gt; i2c_probe_address(adapter,forces[kind][i &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;&lt;span&gt;],kind, found_proc);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;里面调用了i2c_probe_address()函数,从名称上来看,显然它就是用来发送起始信号+设备地址,来探测IIC设备地址用的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8.2进入i2c_probe_address()函数:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i2c_probe_address(&lt;span&gt;struct&lt;/span&gt; i2c_adapter *adapter, &lt;span&gt;int&lt;/span&gt; addr, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; kind,&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; (*found_proc) (&lt;span&gt;struct&lt;/span&gt; i2c_adapter *, &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;))
{

       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;判断设备地址是否有效,addr里存放的是设备地址前7位,比如AT24C02=0xA0,那么addr=0x50&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;if&lt;/span&gt; (addr &amp;lt; &lt;span&gt;0x03&lt;/span&gt; || addr &amp;gt; &lt;span&gt;0x77&lt;/span&gt;&lt;span&gt;) {
              dev_warn(&lt;/span&gt;&amp;amp;adapter-&amp;gt;dev, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invalid probe address 0x%02x\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,addr);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印地址无效,并退出&lt;/span&gt;
              &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;EINVAL;
       }

       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;查找链表中其它IIC设备的设备地址,若这个设备地址已经被使用,则return&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (i2c_check_addr(adapter, addr))
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; 

       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (kind &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i2c_smbus_xfer(adapter, addr, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,I2C_SMBUS_QUICK, NULL) &lt;/span&gt;&amp;lt; &lt;span&gt;0&lt;/span&gt;)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进入I2C传输函数&lt;/span&gt;
　　　　　　　　 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
       ... ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8.3 其中i2c_smbus_xfer()传输函数如下:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
s32 i2c_smbus_xfer(&lt;span&gt;struct&lt;/span&gt; i2c_adapter * adapter, u16 addr, unsigned &lt;span&gt;short&lt;/span&gt;&lt;span&gt; flags,&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; read_write, u8 command, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size,union i2c_smbus_data &lt;/span&gt;*&lt;span&gt; data)
{
       s32 res;

       flags &lt;/span&gt;&amp;amp;= I2C_M_TEN |&lt;span&gt; I2C_CLIENT_PEC;

       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (adapter-&amp;gt;algo-&amp;gt;smbus_xfer) {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果adapter适配器有smbus_xfer这个函数&lt;/span&gt;&lt;span&gt;
              mutex_lock(&lt;/span&gt;&amp;amp;adapter-&amp;gt;bus_lock);                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加互斥锁&lt;/span&gt;&lt;span&gt;
              res &lt;/span&gt;= adapter-&amp;gt;algo-&amp;gt;&lt;span&gt;smbus_xfer(adapter,addr,flags,read_write,command,size,data);  &lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　//&lt;/span&gt;&lt;span&gt;调用adapter适配器里的传输函数&lt;/span&gt;&lt;span&gt;
              mutex_unlock(&lt;/span&gt;&amp;amp;adapter-&amp;gt;bus_lock);                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解互斥锁&lt;/span&gt;&lt;span&gt;
       } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则使用默认函数传输设备地址&lt;/span&gt;&lt;span&gt;
              res &lt;/span&gt;=&lt;span&gt; i2c_smbus_xfer_emulated(adapter,addr,flags,read_write,command,size,data);
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;看了上面代码后,显然我们的s3c2410-i2c适配器没有algo-&amp;gt;smbus_xfer函数,而是使用&lt;span&gt;i2c_smbus_xfer_emulated()&lt;/span&gt;函数,如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194624247-1622232895.png&quot; alt=&quot;&quot; width=&quot;438&quot; height=&quot;221&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;PS:通常适配器都是不支持的,使用默认的i2c_smbus_xfer_emulated()函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8.4 接下来看i2c_smbus_xfer_emulated()函数如何传输的:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; s32 i2c_smbus_xfer_emulated(&lt;span&gt;struct&lt;/span&gt; i2c_adapter *&lt;span&gt; adapter, u16 addr,unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt;&lt;span&gt; flags,&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; read_write, u8 command, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size, union i2c_smbus_data &lt;/span&gt;*&lt;span&gt; data)
{
       unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; msgbuf0[I2C_SMBUS_BLOCK_MAX+&lt;span&gt;3&lt;/span&gt;];              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;属于 msg[0]的buf成员&lt;/span&gt;&lt;span&gt;
       unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; msgbuf1[I2C_SMBUS_BLOCK_MAX+&lt;span&gt;2&lt;/span&gt;];              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;属于 msg[1]的buf成员&lt;/span&gt;
       &lt;span&gt;int&lt;/span&gt; num = read_write == I2C_SMBUS_READ?&lt;span&gt;2&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果为读命令,就等于2,表示要执行两次数据传输&lt;/span&gt;
       &lt;span&gt;struct&lt;/span&gt; i2c_msg msg[&lt;span&gt;2&lt;/span&gt;] = { { addr, flags, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, msgbuf0 },
　　　　　　　　　　　　　　　　　　　　{ addr, flags &lt;/span&gt;| I2C_M_RD, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, msgbuf1 }};           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个i2c_msg结构体,&lt;/span&gt;
&lt;span&gt;

       msgbuf0[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = command;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IIC设备地址最低位为读写命令&lt;/span&gt;&lt;span&gt;
       ... ...&lt;br/&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i2c_transfer(adapter, msg, num) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置i2c_msg结构体成员&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
              &lt;span&gt;if&lt;/span&gt; (read_write ==&lt;span&gt; I2C_SMBUS_READ)
              &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(size) {
              ... ...
              &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; I2C_SMBUS_BYTE_DATA:              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是读字节&lt;/span&gt;
              &lt;span&gt;if&lt;/span&gt; (read_write ==&lt;span&gt; I2C_SMBUS_READ)
                     msg[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;].len = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
              &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                     msg[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].len = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
                     msgbuf0[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = data-&amp;gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;;
              }
              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
              ... ...
              }
       ... ...

       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i2c_transfer(adapter, msg, num) &amp;lt; &lt;span&gt;0&lt;/span&gt;)             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将 i2c_msg结构体的内容发送给I2C设备&lt;/span&gt;
              &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
       ... ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中i2c_msg结构体的结构,如下所示:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; i2c_msg {
       __u16 addr;    　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;I2C从机的设备地址&lt;/span&gt;&lt;span&gt;
       __u16 flags;     　　    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当flags=0表示写, flags= I2C_M_RD表示读&lt;/span&gt;&lt;span&gt;
       __u16 len;              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传输的数据长度,等于buf数组里的字节数&lt;/span&gt;&lt;span&gt;
       __u8 &lt;/span&gt;*buf;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放数据的数组&lt;/span&gt;&lt;span&gt;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面代码中之所以&lt;span&gt;读操作&lt;/span&gt;需要两个i2c_msg,&lt;span&gt;写操作&lt;/span&gt;需要一个i2c_msg,是因为读IIC设备是两个流程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上一节&lt;/span&gt;&lt;span&gt;&lt;span&gt;IIC接口下的24C02 驱动分析:&lt;/span&gt; &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/lifexy/p/7793686.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.cnblogs.com/lifexy/p/7793686.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;里就已经分析到了,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只要发送一个S起始信号则就是一个i2c_msg,如下两个读写操作图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194638622-994179422.png&quot; alt=&quot;&quot; width=&quot;450&quot; height=&quot;153&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194645528-2046926273.png&quot; alt=&quot;&quot; width=&quot;439&quot; height=&quot;141&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而在i2c_transfer()函数中,最终又是调用了之前分析的i2c_adapter-&amp;gt;algo-&amp;gt;master_xfer()发送函数,如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194708669-885477807.png&quot; alt=&quot;&quot; width=&quot;528&quot; height=&quot;250&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中&lt;span&gt;i2c_transfer()&lt;/span&gt;的参数*adap表示通过哪个适配器传输出去,msgs表示I2C消息,num表示msgs的数目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内核每发送一个Msg都会先发出S开始信号和设备地址.直到所有Msg传输完毕，最后发出P停止信号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当&lt;span&gt;i2c_transfer()&lt;/span&gt;返回值为正数,表示已经传输正数个数据,当返回负数,说明I2C传输出错&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8.5 所以在i2c_driver -&amp;gt;attach_adapter(adapter)函数里主要执行以下几步:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1)&lt;/span&gt;&lt;/strong&gt; 调用 &lt;span&gt;i2c_probe(&lt;/span&gt;adap, &lt;span&gt;i2c_client_address_data&lt;/span&gt;&lt;strong&gt;设备地址结构体&lt;/strong&gt;, 回调函数&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2)&lt;/span&gt;&lt;/strong&gt; 将要发的&lt;span&gt;设备地址结构体&lt;/span&gt;打包成&lt;span&gt;i2c_msg&lt;/span&gt;,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3)&lt;/span&gt;&lt;/strong&gt; 然后执行&lt;span&gt;i2c_transfer()&lt;/span&gt;来调用i2c_adapter-&amp;gt;algo-&amp;gt;master_xfer()将i2c_msg发出去&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4)&lt;/span&gt;&lt;/strong&gt;若收到ACK回应,便进入回调函数,&lt;span&gt;注册i2c_client&lt;/span&gt;从设备,使该设备与适配器联系在一起&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;所以适配器和iic设备驱动最终注册框架图如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194722247-1723647250.png&quot; alt=&quot;&quot; width=&quot;659&quot; height=&quot;411&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;9.接下来便来分析回调函数如何注册i2c_client从设备的&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先来看看i2c_client结构体:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; i2c_client {  

 unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; flags；&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标志    &lt;/span&gt;
&lt;span&gt;
 unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; addr; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该i2c从设备的设备地址,存放地址高7位  &lt;/span&gt;

 &lt;span&gt;char&lt;/span&gt; name[I2C_NAME_SIZE];   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备名字&lt;/span&gt;

 &lt;span&gt;struct&lt;/span&gt; i2c_adapter *adapter;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;依附的i2c_adapter,表示该IIC设备支持哪个适配器  &lt;/span&gt;

 &lt;span&gt;struct&lt;/span&gt; i2c_driver *driver;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;依附的i2c_driver ,表示该IIC从设备的驱动是哪个&lt;/span&gt;

 &lt;span&gt;struct&lt;/span&gt; device dev;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备结构体    &lt;/span&gt;

 &lt;span&gt;int&lt;/span&gt; irq;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备所使用的结构体    &lt;/span&gt;

 &lt;span&gt;struct&lt;/span&gt; list_head detected;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;链表头  &lt;/span&gt;
&lt;span&gt;
 };  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;还是以driver/i2c/chips/eeprom.c为例,如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194741044-298465589.png&quot; alt=&quot;&quot; width=&quot;489&quot; height=&quot;77&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;9.1这里的回调函数是eeprom_detect()函数,代码如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; eeprom_detect(&lt;span&gt;struct&lt;/span&gt; i2c_adapter *adapter, &lt;span&gt;int&lt;/span&gt; address, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; kind)
{
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; i2c_client *new_client;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个i2c_client结构体局部变量&lt;/span&gt;
&lt;span&gt;
new_client &lt;/span&gt;=kzalloc(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt; i2c_client), GFP_KERNEL);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分配i2c_client结构体为全局变量&lt;/span&gt;


&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置i2c_client结构体&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
new_client&lt;/span&gt;-&amp;gt;addr = address;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置设备地址&lt;/span&gt;&lt;span&gt;
new_client&lt;/span&gt;-&amp;gt;adapter = adapter;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置依附的i2c_adapter&lt;/span&gt;&lt;span&gt;
new_client&lt;/span&gt;-&amp;gt;driver = &amp;amp;eeprom_driver;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置依附的i2c_driver&lt;/span&gt;&lt;span&gt;
new_client&lt;/span&gt;-&amp;gt;flags = &lt;span&gt;0&lt;/span&gt;;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置标志位为初始值&lt;/span&gt;&lt;span&gt;
strlcpy(new_client&lt;/span&gt;-&amp;gt;name, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eeprom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, I2C_NAME_SIZE);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置名字&lt;/span&gt;


 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;注册i2c_client&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
 &lt;span&gt;if&lt;/span&gt; ((err =&lt;span&gt; i2c_attach_client(new_client)))
        &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; exit_kfree;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册失败,便释放i2c_client这个全局变量&lt;/span&gt;&lt;span&gt;
 ... ...&lt;br/&gt;exit_kfree:
       kfree(new_client);
exit:
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; err;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当注册了i2c_client从设备后,便可以使用&lt;span&gt;i2c_transfer()&lt;/span&gt;来实现与设备传输数据了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;10.接下来,我们便参考driver/i2c/chips/eeprom.c驱动,来写出24C02驱动以及测试程序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;驱动代码步骤如下:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;定义&lt;span&gt;file_operations&lt;/span&gt;结构体 ,设置字符设备的读写函数(实现对24C02的读写操作)&lt;br/&gt;&lt;span&gt;//构造i2c_msg结构体, 使用i2c_transfer()来实现与设备传输数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;定义&lt;span&gt;i2c_client_address_data&lt;/span&gt;结构体,里面保存24C02的设备地址&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; 定义一个&lt;span&gt;i2c_driver&lt;/span&gt;驱动结构体&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;   3.1&lt;/strong&gt;&lt;/span&gt; 设置i2c_driver-&amp;gt; attach_adapter&lt;br/&gt;　　　　 &lt;span&gt;// 里面直接调用 i2c_probe(adap, i2c_client_address_data结构体, 回调函数);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　 &lt;span&gt;&lt;strong&gt;  3.2&lt;/strong&gt;&lt;/span&gt; 设置i2c_driver-&amp;gt; detach_client&lt;br/&gt;　   &lt;span&gt;        //里面卸载i2c_client, 字符设备&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.&lt;/strong&gt;&lt;/span&gt;写&lt;span&gt;回调函数&lt;/span&gt;,里面注册i2c_client,字符设备( 字符设备用来实现读写24C02里的数据)&lt;br/&gt;      &lt;strong&gt;&lt;span&gt;4.1&lt;/span&gt;&lt;/strong&gt; 分配并设置i2c_client&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;&lt;span&gt;4.2&lt;/span&gt;&lt;/strong&gt; 使用i2c_attach_client()将i2c_client与适配器进行连接&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;&lt;span&gt;4.3&lt;/span&gt;&lt;/strong&gt; 注册字符设备&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.&lt;/span&gt;&lt;/strong&gt; 写init入口函数,exit出口函数&lt;br/&gt;init: 使用i2c_add_driver()注册i2c_driver&lt;br/&gt;exit: 使用i2c_del_driver ()卸载i2c_driver&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;具体驱动代码如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;90&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 *  I2C-24C02
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/kernel.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/init.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/module.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/slab.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/jiffies.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/i2c.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/mutex.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/fs.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;asm/uaccess.h&amp;gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; i2c_client *at24c02_client;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从设备结构体&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; *at24c02_class;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;类结构体&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; at24c02_major;                 

&lt;/span&gt;&lt;span&gt; /*&lt;/span&gt;&lt;span&gt;1.定义file_operations结构体 ,
  *  设置字符设备的读写函数(实现对24C02的读写操作)
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; ssize_t at24c02_read(&lt;span&gt;struct&lt;/span&gt; file *file, &lt;span&gt;char&lt;/span&gt; __user *buf, size_t size, loff_t *&lt;span&gt; offset)
{
       &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; i2c_msg msg[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
       u8 addr;
       u8 data;
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ret;
       
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(size!=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;EINVAL;

       copy_from_user(&lt;/span&gt;&amp;amp;addr,buf,&lt;span&gt;1&lt;/span&gt;);                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取读地址&lt;/span&gt;
&lt;span&gt;
        msg[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].addr=at24c02_client-&amp;gt;&lt;span&gt;addr;
        msg[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].flags=&lt;span&gt;0&lt;/span&gt;;                                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写标志&lt;/span&gt;
        msg[&lt;span&gt;0&lt;/span&gt;].len  =&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        msg[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].buf  =&amp;amp;addr;                                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入要读的地址&lt;/span&gt;
&lt;span&gt;
        msg[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;].addr=at24c02_client-&amp;gt;&lt;span&gt;addr;
        msg[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;].flags=I2C_M_RD;                               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读标志&lt;/span&gt;
        msg[&lt;span&gt;1&lt;/span&gt;].len  =&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        msg[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;].buf  =&amp;amp;data;                                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读出数据 &lt;/span&gt;
&lt;span&gt;
        ret&lt;/span&gt;=i2c_transfer(at24c02_client-&amp;gt;adapter, msg, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);     
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ret==&lt;span&gt;2&lt;/span&gt;)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示2个msg传输成功&lt;/span&gt;
&lt;span&gt;        {
             copy_to_user(buf,&lt;/span&gt;&amp;amp;data,&lt;span&gt;1&lt;/span&gt;);                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传数据       &lt;/span&gt;
             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;EAGAIN;
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; ssize_t at24c02_write(&lt;span&gt;struct&lt;/span&gt; file *file, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; __user *buf, size_t size, loff_t *&lt;span&gt;offset)
{
       &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; i2c_msg msg[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
       u8 val[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];      
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ret;
       
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(size!=&lt;span&gt;2&lt;/span&gt;)         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;地址   数据&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;EINVAL;

        copy_from_user(val,buf,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;);                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取 地址   数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;
        msg[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].addr=at24c02_client-&amp;gt;&lt;span&gt;addr;
        msg[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].flags=&lt;span&gt;0&lt;/span&gt;;                                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写标志&lt;/span&gt;
        msg[&lt;span&gt;0&lt;/span&gt;].len  =&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
        msg[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].buf  =val;                                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入要写的地址   数据&lt;/span&gt;
&lt;span&gt;
        ret&lt;/span&gt;=i2c_transfer(at24c02_client-&amp;gt;adapter, msg, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);     
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ret==&lt;span&gt;1&lt;/span&gt;)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示1个msg传输成功&lt;/span&gt;
&lt;span&gt;        {           
             &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;EAGAIN;
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;  file_operations at24c02_fops=&lt;span&gt;{
        .owner &lt;/span&gt;=&lt;span&gt; THIS_MODULE,
    .read  &lt;/span&gt;=&lt;span&gt; at24c02_read,
    .write &lt;/span&gt;=&lt;span&gt; at24c02_write,
};


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;2.定义i2c_client_address_data结构体,保存24C02的设备地址&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;short&lt;/span&gt; ignore[] =&lt;span&gt; { I2C_CLIENT_END };
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;short&lt;/span&gt; normal_addr[] = {&lt;span&gt;0X50&lt;/span&gt;&lt;span&gt;,  I2C_CLIENT_END };
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;short&lt;/span&gt;   force_addr[] = {ANY_I2C_BUS, &lt;span&gt;0x60&lt;/span&gt;&lt;span&gt;, I2C_CLIENT_END};
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;short&lt;/span&gt;   * forces[] =&lt;span&gt;     {force_addr, NULL};    &lt;br/&gt;&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; i2c_client_address_data   at24c02_addr=&lt;span&gt;{
            .normal_i2c&lt;/span&gt;=&lt;span&gt;normal_addr,
            .probe&lt;/span&gt;=&lt;span&gt;ignore,
            .ignore&lt;/span&gt;=&lt;span&gt;ignore,
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  .forces=forces,                  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 强制地址&lt;/span&gt;
&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;3. 定义一个i2c_driver驱动结构体&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;   at24c02_attach_adapter(&lt;span&gt;struct&lt;/span&gt; i2c_adapter *&lt;span&gt;adapter);
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;   at24c02_detach_client(&lt;span&gt;struct&lt;/span&gt; i2c_client *&lt;span&gt;client);
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; at24c02_detect(&lt;span&gt;struct&lt;/span&gt; i2c_adapter *adap, &lt;span&gt;int&lt;/span&gt; addr, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; kind);

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; This is the driver that will be inserted &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; i2c_driver at24c02_driver =&lt;span&gt; {
    .driver &lt;/span&gt;=&lt;span&gt; {
        .name    &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;at24c02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    },
    
    .attach_adapter    &lt;/span&gt;= at24c02_attach_adapter,       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定回调函数&lt;/span&gt;
    .detach_client    = at24c02_detach_client,                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解绑回调函数&lt;/span&gt;
&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;3.1 设置i2c_driver-&amp;gt; attach_adapter&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;   at24c02_attach_adapter(&lt;span&gt;struct&lt;/span&gt; i2c_adapter *&lt;span&gt;adapter)
{
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; i2c_probe(adapter,&amp;amp;&lt;span&gt;at24c02_addr, at24c02_detect);
}


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;3.2 设置i2c_driver-&amp;gt; detach_client&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;   at24c02_detach_client(&lt;span&gt;struct&lt;/span&gt; i2c_client *&lt;span&gt;client)
{
    printk(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;at24c02_detach_client\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    i2c_detach_client(at24c02_client) ;   
    kfree(at24c02_client);&lt;br/&gt;class_device_destroy(at24c02_class,MKDEV(at24c02_major, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;));
    class_destroy(at24c02_class);
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;4.写回调函数,里面注册i2c_client,字符设备&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; at24c02_detect(&lt;span&gt;struct&lt;/span&gt; i2c_adapter *adap, &lt;span&gt;int&lt;/span&gt; addr, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; kind)
{
   printk(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;at24c02_detect\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 4.1 分配并设置i2c_client &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    at24c02_client&lt;/span&gt;= kzalloc(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; i2c_client), GFP_KERNEL);
   
    at24c02_client&lt;/span&gt;-&amp;gt;addr =&lt;span&gt; addr;
    at24c02_client&lt;/span&gt;-&amp;gt;adapter =&lt;span&gt; adap;
    at24c02_client&lt;/span&gt;-&amp;gt;driver = &amp;amp;&lt;span&gt;at24c02_driver;
    at24c02_client&lt;/span&gt;-&amp;gt;flags = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    strlcpy(at24c02_client&lt;/span&gt;-&amp;gt;name, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;at24c02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, I2C_NAME_SIZE);

   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;4.2 使用i2c_attach_client()将i2c_client与适配器进行连接&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    i2c_attach_client(at24c02_client) ;
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;4.3 注册字符设备&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    at24c02_major&lt;/span&gt;= register_chrdev(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;at24c02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;at24c02_fops);  
    at24c02_class&lt;/span&gt;=class_create(THIS_MODULE, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;at24c02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);   
    class_device_create(at24c02_class,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, MKDEV(at24c02_major, &lt;span&gt;0&lt;/span&gt;),&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;at24c02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;5. 写init入口函数,exit出口函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; at24c02_init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    i2c_add_driver(&lt;/span&gt;&amp;amp;&lt;span&gt;at24c02_driver);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; at24c02_exit(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    i2c_del_driver(&lt;/span&gt;&amp;amp;&lt;span&gt;at24c02_driver);
}&lt;br/&gt;module_init(at24c02_init);
module_exit(at24c02_exit);
MODULE_LICENSE(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GPL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;11.测试运行&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194801809-125890547.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 10 Nov 2017 12:33:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/7816324.html</dc:identifier>
</item>
<item>
<title>机器学习数学|微积分梯度jensen不等式 - cloud&amp;ken</title>
<link>http://www.cnblogs.com/cloud-ken/p/7816129.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cloud-ken/p/7816129.html</guid>
<description>&lt;h3 id=&quot;觉得有用的话欢迎一起讨论相互学习follow-me&quot;&gt;觉得有用的话,欢迎一起讨论相互学习~&lt;a href=&quot;https://github.com/Asurada2015&quot;&gt;Follow Me&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;原创文章,如需转载请保留出处&lt;br/&gt;本博客为七月在线邹博老师机器学习数学课程学习笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;索引&quot;&gt;索引&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;微积分,梯度和Jensen不等式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Taylor展开及其应用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常见概率分布和推导&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指数族分布&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共轭分布&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;统计量&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;矩估计和最大似然估计&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;区间估计&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Jacobi矩阵&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;矩阵乘法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;矩阵分解RQ和SVD&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对称矩阵&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;凸优化&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;常数e的计算过程&lt;/li&gt;
&lt;li&gt;常见函数的导数&lt;/li&gt;
&lt;li&gt;分部积分法及其应用&lt;/li&gt;
&lt;li&gt;梯度&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;上升/下降最快方向&lt;/li&gt;
&lt;li&gt;凸函数&lt;/li&gt;
&lt;li&gt;Jensen不等式&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;自然常数e&quot;&gt;&lt;span&gt;自然常数e&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;引入&quot;&gt;&lt;span&gt;引入&lt;/span&gt;&lt;/h4&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;我们知道对于公式&lt;span class=&quot;math inline&quot;&gt;\(y=log_{a}x\)&lt;/span&gt;,x=1时,y=0.&lt;mark&gt;则我们是否能找一点a值,使得y函数在(1,0)点的导数为1呢?&lt;/mark&gt;&lt;/p&gt;
&lt;h4 id=&quot;利用导数公式对ylog_ax求导&quot;&gt;&lt;span&gt;利用导数公式对&lt;span class=&quot;math inline&quot;&gt;\(y=log_{a}x\)&lt;/span&gt;求导&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a05462597cc2.png&quot; alt=&quot;2017-11-10_141323&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;定理一极限存在定理&quot;&gt;定理一:极限存在定理&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;单调有界函数必有极限&lt;/li&gt;
&lt;li&gt;单调数列有上线,必有其极限&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;构造数列xn证明其单调有上界&quot;&gt;&lt;span&gt;构造数列Xn证明其单调有上界&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a054a689914a.png&quot; alt=&quot;2017-11-10_143058&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;又因为其有(1+1)项,则其必比2要大然而又比3要小,则&lt;mark&gt;&lt;span class=&quot;math inline&quot;&gt;\(2&amp;lt;X_n&amp;lt;3\)&lt;/span&gt;&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;定理二两边夹定理&quot;&gt;定理二:两边夹定理&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a05349d2f788.png&quot; alt=&quot;2017-11-10_115840.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;自然常数e的推导&quot;&gt;&lt;span&gt;自然常数e的推导&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a054b914f52a.png&quot; alt=&quot;2017-11-10_144733&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span class=&quot;math display&quot;&gt;\[自然常数e可以看做e=1+\frac{1}{1!}+\frac{1}{2!}+\frac{1}{3!}+\frac{1}{4!}+...+\frac{1}{n!}\]&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;微分与积分&quot;&gt;&lt;span&gt;&lt;span&gt;微分与积分&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;常用函数的导数公式&quot;&gt;&lt;span&gt;常用函数的导数公式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/11/10/5a054d74797e3.png&quot; alt=&quot;2017-11-10_145545&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;分部积分法&quot;&gt;&lt;span&gt;分部积分法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a054e9e4437f.png&quot; alt=&quot;2017-11-10_145853&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;方向导数与梯度&quot;&gt;&lt;span&gt;方向导数与梯度&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a055131df111.png&quot; alt=&quot;2017-11-10_151133&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;对于方向导数我们也可以视为&lt;span class=&quot;math display&quot;&gt;\[(\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}).(cos\varphi.sin\varphi)^{T}\]&lt;/span&gt;方向导数顾名思义既是复合函数在某一方向上的导数，表示函数在某一方向上的变化趋势。&lt;strong&gt;当在某一方向上的方向导数最大时，即是梯度&lt;/strong&gt; 当 &lt;span class=&quot;math display&quot;&gt;\[cos\varphi =\frac{\partial f}{\partial x}\\sin\varphi = \frac{\partial f}{\partial y}\]&lt;/span&gt; 时,这是方向导数取最大值,即是梯度&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;mark&gt;对于梯度我们有&lt;/mark&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;方向导数是各个方向上的导数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;偏导数连续才有梯度存在&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;梯度的方向是方向导数中取到最大值的方向，梯度的值是方向导数的最大值&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a055929ddf84.png&quot; alt=&quot;2017-11-10_154534&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;凸函数与jsnsen不等式&quot;&gt;&lt;span&gt;&lt;span&gt;凸函数与Jsnsen不等式&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;简而言之,即是&lt;span&gt;函数的割线永远位于函数图像的上方&lt;/span&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a055e71d9c21.png&quot; alt=&quot;2017-11-10_160805&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;一阶可微&quot;&gt;&lt;span&gt;一阶可微&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;简而言之,即是&lt;span&gt;函数如果是一个凸函数,且一阶可微,则过函数任意一点做函数的切线,函数的切线永远在函数的下方&lt;/span&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/11/10/5a055f745187f.png&quot; alt=&quot;2017-11-10_161216&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;二阶可微&quot;&gt;&lt;span&gt;二阶可微&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a05615240126.png&quot; alt=&quot;2017-11-10_162000&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;凸函数举例&quot;&gt;&lt;span&gt;凸函数举例&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a056197af9f1.png&quot; alt=&quot;2017-11-10_162139&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;jensen不等式&quot;&gt;&lt;span&gt;Jensen不等式&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Jensen不等式相当于把凸函数的概念反过来说,即是如果f是一个凸函数,任意取一个在f定义域上的(x,y)点,&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;属于[0,1].&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当只有x,y两个参数,即是使用 &lt;strong&gt;基本Jensen不等式&lt;/strong&gt; ,然而当推广到k个参数时, &lt;strong&gt;即是表示参数的线性加权的函数值总要小于函数值的线性加权&lt;/strong&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;可以将其推广到概率密度分布上,假设&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;表示是事件的概率密度K点分布即所加和为1,则函数值的期望大于期望的函数值&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a056ce0691ec.png&quot; alt=&quot;2017-11-10_162630&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a056f123599a.jpg&quot; alt=&quot;IMG_20171110_171715&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;PS:这都是在f是凸函数的状况下!&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;Jensen不等式是所有不等式的基础,所有不等式都能看做是Jensen不等式利用不同的凸函数推导出来的.&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/11/10/5a05881205891.jpg&quot; alt=&quot;IMG_20171110_190429&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.julyedu.com/video/play/38&quot;&gt;课程传送门&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 10 Nov 2017 11:25:00 +0000</pubDate>
<dc:creator>cloud&amp;amp;ken</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cloud-ken/p/7816129.html</dc:identifier>
</item>
<item>
<title>一款特好用的JavaScript框架——JQuery - 榆木疙瘩ii</title>
<link>http://www.cnblogs.com/wuhao752718372/p/7816080.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhao752718372/p/7816080.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  了解了解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;                &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　   &lt;span&gt;jQuery是一个快速，小巧，功能丰富的JavaScript库。&lt;/span&gt;&lt;span&gt;它使诸如HTML文档遍历和操纵，事件处理，动画和Ajax等事情变得简单得多，而且易于使用的API可以在多种浏览器中使用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、 什么是JQuery？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;jQuery是一个JavaScript函数库。&lt;/p&gt;
&lt;p&gt;jQuery是一个轻量级的&quot;写的少，做的多&quot;的JavaScript库。　　&lt;/p&gt;
&lt;p&gt;jQuery 的功能概括&lt;/p&gt;
&lt;p&gt;　　1、html 的元素选取&lt;/p&gt;
&lt;p&gt;　　2、html的元素操作&lt;/p&gt;
&lt;p&gt;　　3、html dom遍历和修改&lt;/p&gt;
&lt;p&gt;　　4、js特效和动画效果&lt;/p&gt;
&lt;p&gt;　　5、css操作&lt;/p&gt;
&lt;p&gt;　　6、html事件操作&lt;/p&gt;
&lt;p&gt;　　7、ajax异步请求方式&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、 JQuery基础中的基础&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;2-1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;JQuery基本语法&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;jQuery 语法是通过选取 HTML 元素，并对选取的元素执行某些操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，在使用JQuery之前要先导入JQuery文件。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;script src=&quot;js/jquery-3.1.1.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;JQuery中的选择器&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$(&quot;选择器&quot;).函数();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;　　① $是JQuery的缩写，即可以使用JQuery(&quot;选择器&quot;).函数()；&lt;/p&gt;
&lt;p&gt;　　② 选择器，可以是任何的CSS支持的选择符；&lt;/p&gt;
&lt;p&gt;小实例：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;$(this).hide() - 隐藏当前元素&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;$(&quot;p&quot;).hide() - 隐藏所有 &amp;lt;p&amp;gt; 元素&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;$(&quot;p.test&quot;).hide() - 隐藏所有 class=&quot;test&quot; 的 &amp;lt;p&amp;gt; 元素&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;$(&quot;#test&quot;).hide() - 隐藏所有 id=&quot;test&quot; 的元素&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;2-2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;文档就绪函数&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;文档就绪函数就是指防止在文档未完全加载完成之前，运行JQuery代码；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
 
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; JQuery 代码...&lt;/span&gt;
&lt;span&gt; 
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它的简写形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
 
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; JQuery 代码...&lt;/span&gt;
&lt;span&gt; 
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div readability=&quot;14&quot;&gt;
&lt;h3&gt;文档就绪函数和window.onload的区别[还是比较重要的！！]&lt;/h3&gt;
&lt;p&gt;① window.onload必须等到网页中的所有内容加载完成之后，才会执行代码(包括图片、视频等资源)；&lt;/p&gt;
&lt;p&gt;　 文档就绪函数，只需要在网页DOM结构加载完成之后，就可以执行代码；&lt;/p&gt;
&lt;p&gt;② window.onload只能写一个，写多个只会执行最后一个；&lt;/p&gt;
&lt;p&gt;　 文档就绪函数，可以写多个，并且不会被覆盖；&lt;/p&gt;
&lt;/div&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、 JQuery中的常用函数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;JQuery中的函数实在是太多，在这就不一一解释了，我在下面列举了一些常用的，后面都跟着一个小例子，非常简单，各位博友们一看就懂~~~&lt;/h4&gt;
&lt;h3&gt;内部插入&lt;/h3&gt;
&lt;p&gt;append：将创建好的节点，插入到指定位置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$(&quot;#div1&quot;).append(&quot;&amp;lt;p&amp;gt;这是被插入的p标签&amp;lt;/p&amp;gt;&quot;);　　　　//在#div1内部的最后，直接插入一个节点。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;appendTo：&lt;/span&gt;把所有匹配的元素追加到另一个指定的元素元素集合中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;&amp;lt;p&amp;gt;这是被插入的p标签&amp;lt;/p&amp;gt;&quot;).appendTo(&quot;#div1&quot;);　　　　//把新节点插入到#div1中
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; prepend：把每个匹配的元素插入到指定元素的开头&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$(&quot;#div1&quot;).prepend(&quot;&amp;lt;p&amp;gt;这是被插入的p标签&amp;lt;/p&amp;gt;&quot;);　　　　//在#div1内部的开头，直接插入一个节点。
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;外部插入&lt;/h3&gt;
&lt;p&gt;after：在每个匹配的元素之后插入内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$(&quot;#div1&quot;).after(&quot;&amp;lt;p&amp;gt;这是被插入的p标签&amp;lt;/p&amp;gt;&quot;);　　　　//在div1后面插入一个新节点
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;insertBefore：把所有匹配的元素插入到另一个、指定的元素元素集合的前面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$(&quot;&amp;lt;p&amp;gt;这是被插入的p标签&amp;lt;/p&amp;gt;&quot;).insertBefore(&quot;#div1&quot;);　　　　//把p标签插入到div1前面
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;包裹&lt;/h3&gt;
&lt;p&gt;wrap：把所有匹配的元素用其他元素的结构化标记包裹起来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;p&quot;).wrap(&quot;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&quot;);　　　　//把每个p标签外面，都包裹一层div
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;wrapAll：将所有匹配的元素用单个元素包裹起来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;p&quot;).wrapAll(&quot;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&quot;);　　　　//把所有的p标签，包裹在同一个div中
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;wrapInner：将每一个匹配的元素的子内容(包括文本节点)用一个HTML结构包裹起来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$(&quot;#div1&quot;).wrapInner(&quot;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&quot;);　　　　//把#div1里面的所有子元素，用&amp;lt;div&amp;gt;包裹起来
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;替换&lt;/h3&gt;
&lt;p&gt;replaceWith：将所有匹配的元素替换成指定的HTML或DOM元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$(&quot;p&quot;).replaceWith(&quot;&amp;lt;span&amp;gt;111&amp;lt;/span&amp;gt;&quot;);　　　　//将所有匹配的p标签，全部换为span标签
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;replaceAll：用匹配的元素替换掉所有 selector匹配到的元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;&amp;lt;span&amp;gt;111&amp;lt;/span&amp;gt;&quot;).replaceAll(&quot;p&quot;);　　　　//用span元素，替换掉所有p标签
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;删除&lt;/h3&gt;
&lt;p&gt;empty：删除匹配的元素集合中所有的子节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$(&quot;#div1&quot;).empty();　　　　//删除#div1中的所有子元素。 但是#div1依然保留空标签
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;remove：从DOM中删除所有匹配的元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;#div1&quot;).remove();　　　　//直接从DOM中，删除#div1以及所有子元素
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;detach：从DOM中删除所有匹配的元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;#div1&quot;).detach();　　　　//直接从DOM中，删除#div1以及所有子元素
&lt;/pre&gt;&lt;/div&gt;

&lt;div readability=&quot;16&quot;&gt;
&lt;h2&gt;&lt;span&gt;remove和detach的异同点&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1、相同点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　① 都会把当前标签，以及当前标签的所有子节点，全部删除；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　② 都可以在删除时，把当前节点返回。并可以使用变量接受返回的节点，以便后期恢复；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、不同点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用接受的节点，恢复原节点时&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　remove只能恢复节点的内容，但是事件绑定，不能再恢复；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　detach不但恢复节点的内容，还能再恢复 事件的绑定；&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h3&gt;复制（克隆）&lt;/h3&gt;
&lt;p&gt;clone：克隆匹配的DOM元素并且选中这些克隆的副本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;#div1&quot;).clone(&lt;span&gt;true&lt;/span&gt;).empty().insertBefore(&quot;button:eq(0)&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;div readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;span&gt;JS中.cloneNode() 和 JQ中 .clone()的区别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　两者都接受传入true/false的参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　.cloneNode() 不传参数或传入参数false，表示只克隆当前节点，而不克隆子节点。 传入true表示可隆全部子节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　.clone() 无论传入哪个参数，都会克隆所有子节点。但是，不传参数或者传入false，表示只克隆节点，不克隆节点绑定的事件。 传入true表示同时克隆及诶单绑定的事件。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、JQuery中的事件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;4-1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;绑定事件的方式&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt; 1、事件绑定的快捷方式&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;button&quot;).eq(0).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){&lt;br/&gt;　　　　alert(&lt;/span&gt;1&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; 2、使用on()绑定事件&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;① 使用on进行单事件绑定&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$(&quot;button:eq(0)&quot;).on(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
　　　　alert(&lt;/span&gt;1&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　&lt;strong&gt;② 使用on，一次性给同一节点添加多个事件执行同一函数，多个事件之间空格分隔&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
$(&quot;button:eq(0)&quot;).on(&quot;click mouseover dblclick&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
　　　　console.log(&lt;/span&gt;&quot;触发了事件&quot;&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　&lt;strong&gt;③ 一次性给同一节点添加多个事件，分别执行不同函数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
$(&quot;button:eq(0)&quot;&lt;span&gt;).on({
　　　　&lt;/span&gt;&quot;click&quot;:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
　　　　　　　　console.log(&lt;/span&gt;&quot;执行了click事件&quot;&lt;span&gt;);
　　　　},
　　　　&lt;/span&gt;&quot;mouseover&quot;:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
　　　　　　　　console.log(&lt;/span&gt;&quot;执行了mouseover事件&quot;&lt;span&gt;);
　　　　}
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　&lt;strong&gt;④ 调用函数时，同时给函数传入指定参数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
$(&quot;button:eq(0)&quot;).on(&quot;click&quot;,{&quot;name&quot;:&quot;jredu&quot;,&quot;age&quot;:14},&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(evn){
　　　　console.log(evn);
　　　　console.log(evn.data.name);
　　　　console.log(evn.data.age);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　&lt;strong&gt;⑤使用 on 进行事件委派（非常非常非常非常的重要！）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将原本需要绑定在本元素上的事件，改为绑定到祖先节点乃至根节点上，然后委派给当前节点生效&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
$(&quot;p&quot;).on(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){});　　&lt;br/&gt;//委派如下↓
$(document).on(&lt;/span&gt;&quot;click&quot;,&quot;p&quot;,&lt;span&gt;function&lt;/span&gt;(){});
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;　　使用事件委派的作用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　不使用事件委派的绑定方式，只能绑定到页面初始化时的标签上，当页面新增同类型标签，这些新增的标签，不能绑定上事件；但如果使用事件委派，当页面新增同类型标签时，这些新增的标签也能够绑定已有的事件。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;五、 JQuery中的动画&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt; JQuerey中的动画也是非常多的，在这就给大家列举几个，大家如果觉得不详细的话，可以去菜鸟教程或是查看JQuery的帮助文档！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、.show()  让隐藏的元素显示&lt;/p&gt;
&lt;p&gt;　　效果为：同事修改元素的宽度、高度、opacity属性&lt;/p&gt;
&lt;p&gt;　　①不传参：直接显示，不进行动画&lt;/p&gt;
&lt;p&gt;　　②传参时间毫秒数，表示多少毫米内完成函数&lt;/p&gt;
&lt;p&gt;　　③传入(时间，函数)表示动画完成之后，执行回调函数&lt;/p&gt;
&lt;p&gt;2、.hide()  让显示的元素隐藏，与show相反。&lt;/p&gt;
&lt;p&gt;3、.slideDown()  让隐藏的元素显示，效果为从上往下，增加高度&lt;/p&gt;
&lt;p&gt;　  .slideUp()   让显示的元素隐藏，效果为从下往上，减小高度&lt;/p&gt;
&lt;p&gt;　  .slideToggle()   让现实的元素隐藏，让隐藏的元素显示&lt;/p&gt;
&lt;p&gt;4、.fadeIn()   让隐藏的元素淡入显示&lt;/p&gt;
&lt;p&gt;　  .fadeOut()  让显示的元素淡出隐藏&lt;/p&gt;
&lt;p&gt;　  .fadeTogle()  让显示的元素隐藏，让隐藏的元素显示&lt;/p&gt;
&lt;p&gt;　  .fadeTo(时间，最终透明度，函数)  同fadeToggle，接受第二个参数，表示最终达到的透明度&lt;/p&gt;
&lt;p&gt;5、.animate({最终的样式属性，键值对对象}，动画时间，动画效果(&quot;linear&quot;或&quot;swing&quot;),动画执行完后的回调函数)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;给大家举个小例子吧&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js&quot;&amp;gt;
&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt; 
$(document).ready(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
  $(&lt;/span&gt;&quot;button&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    $(&lt;/span&gt;&quot;div&quot;&lt;span&gt;).animate({
      left:&lt;/span&gt;'250px'&lt;span&gt;,
      opacity:&lt;/span&gt;'0.5'&lt;span&gt;,
      height:&lt;/span&gt;'150px'&lt;span&gt;,
      width:&lt;/span&gt;'150px'&lt;span&gt;
    });
  });
});
&lt;/span&gt;&amp;lt;/script&amp;gt; 
&amp;lt;/head&amp;gt;
 
&amp;lt;body&amp;gt;
&amp;lt;button&amp;gt;开始动画&amp;lt;/button&amp;gt;
&amp;lt;p&amp;gt;&lt;span&gt;默认情况下，所有的 HTML 元素有一个静态的位置，且是不可移动的。 
如果需要改变为，我们需要将元素的 position 属性设置为 relative, fixed, 或 absolute&lt;/span&gt;!&amp;lt;/p&amp;gt;
&amp;lt;div style=&quot;background:#98bf21;height:100px;width:100px;position:absolute;&quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;他的运行结果： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1207274/201711/1207274-20171110183740888-1351410051.gif&quot; alt=&quot;&quot; width=&quot;737&quot; height=&quot;140&quot;/&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;六、JQuery中的AJAX&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。&lt;/p&gt;
&lt;p&gt;简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;6-1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;JQuery  load()方法&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;jQuery load() 方法是简单但强大的 AJAX 方法。&lt;/p&gt;
&lt;p&gt;load() 方法从服务器加载数据，并把返回的数据放入被选元素中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加载远程的HTML文件代码，并插入到指定的DOM节点中。可以只传入一个参数，表示加载一个静态的HTML代码片段。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;#div1&quot;).load(&quot;load.html&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;6-2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;$.ajax()&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; $.ajax():是JQuery最底层的ajax函数，参数接收一个大对象。对象里面的属性和方法，表示ajax请求的相关设置：&lt;/p&gt;
&lt;p&gt;　　① url : 请求远程文件的路径&lt;/p&gt;
&lt;p&gt;　　② type： Ajax请求的类型，可选值 get/post&lt;/p&gt;
&lt;p&gt;　　③ data: 对象格式。向后台发送一个对象，表示传递的数据。&lt;/p&gt;
&lt;p&gt;　　　　　   常用与type为&quot;post&quot;的请求方式；&lt;/p&gt;
&lt;p&gt;　　　　　   如果type为&quot;get&quot;，可以直接使用？追加在URL的后面。&lt;/p&gt;
&lt;p&gt;　　④ dataType ：预期后台返回什么类型的数据。 &quot;text&quot;-字符串   &quot;json&quot;-JSON对象&lt;/p&gt;
&lt;p&gt;　　⑤ success: 请求成功的回调函数。参数接受一个data，表示后台返回的数据。&lt;/p&gt;
&lt;p&gt;　　⑥ error : 请求失败的时候的回调函数&lt;/p&gt;
&lt;p&gt;　　⑦ statusCode ： 接受一个对象，对象的键值对是status状态码和对应的回调函数，表示当请求状态码是对应数字时，执行具体的操作函数。&lt;/p&gt;
&lt;p&gt;　　　　200-正常请求成功     404-页面没有找到    500-服务器内部错误。具体的状态码见下图&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1207274/201711/1207274-20171110184510216-2120939750.png&quot; alt=&quot;&quot; width=&quot;451&quot; height=&quot;1430&quot;/&gt;&lt;/p&gt;
&lt;p&gt;$.get();  $.post(); 这两个函数，是在$.ajax()的基础上进行封装而来。可以直接默认发送get请求或post请求；&lt;/p&gt;
&lt;p&gt;接受四个参数：&lt;/p&gt;
&lt;p&gt;　　① 请求的URL路径。 相当于$.ajax()里面的url；&lt;/p&gt;
&lt;p&gt;　　② 向后台传递的数据。 相当于$.ajax()里面的data；&lt;/p&gt;
&lt;p&gt;　　③ 请求成功的回调函数。 相当于$.ajax()里面的success；&lt;/p&gt;
&lt;p&gt;　　④ 预期返回的数据类型。 相当于$.ajax()里面的dataType；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
$.post(&quot;http://localhost/json.php&quot;,{data:&quot;aaa&quot;},&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
　　　　console.log(data);
},&lt;/span&gt;&quot;json&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; 给大家举上两个栗子&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c89956df-3418-4f46-a03e-e2d68102915b')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_c89956df-3418-4f46-a03e-e2d68102915b&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c89956df-3418-4f46-a03e-e2d68102915b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c89956df-3418-4f46-a03e-e2d68102915b',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c89956df-3418-4f46-a03e-e2d68102915b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;小栗子&amp;lt;/title&amp;gt;
&amp;lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js&quot;&amp;gt;
&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
$(document).ready(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    $(&lt;/span&gt;&quot;button&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        $.post(&lt;/span&gt;&quot;/try/ajax/demo_test_post.php&quot;&lt;span&gt;,{
            name:&lt;/span&gt;&quot;小栗子&quot;&lt;span&gt;,
            url:&lt;/span&gt;&quot;http://www.baidu.com&quot;&lt;span&gt;
        },
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data,status){
            alert(&lt;/span&gt;&quot;数据: \n&quot; + data + &quot;\n状态: &quot; +&lt;span&gt; status);
        });
    });
});
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;button&amp;gt;点击发送一个POST请求&amp;lt;/button&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;POST&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1207274/201711/1207274-20171110185235075-2115189974.png&quot; alt=&quot;&quot; width=&quot;312&quot; height=&quot;129&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('330443a7-5d0a-47e7-82d5-0d321c026b3a')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_330443a7-5d0a-47e7-82d5-0d321c026b3a&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_330443a7-5d0a-47e7-82d5-0d321c026b3a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('330443a7-5d0a-47e7-82d5-0d321c026b3a',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_330443a7-5d0a-47e7-82d5-0d321c026b3a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;小栗子&amp;lt;/title&amp;gt;
&amp;lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js&quot;&amp;gt;
&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
$(document).ready(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    $(&lt;/span&gt;&quot;button&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        $.get(&lt;/span&gt;&quot;/try/ajax/demo_test.php&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data,status){
            alert(&lt;/span&gt;&quot;数据: &quot; + data + &quot;\n状态: &quot; +&lt;span&gt; status);
        });
    });
});
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;button&amp;gt;点击发送GET请求&amp;lt;/button&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;GET&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1207274/201711/1207274-20171110185338888-1040910979.png&quot; alt=&quot;&quot; width=&quot;306&quot; height=&quot;105&quot;/&gt;&lt;/p&gt;


&lt;p&gt;
&lt;h5 class=&quot;135brush&quot;&gt;&lt;span&gt;好了，今天就给大家分享到这儿吧，大家如果觉得我漏了点什么，可以去菜鸟教程或查看JQuery帮助文档，如果觉得哪个地方需要改进的，请大家给我留言，谢谢大家了！！！！&lt;/span&gt;&lt;/h5&gt;
&lt;/p&gt;
</description>
<pubDate>Fri, 10 Nov 2017 11:07:00 +0000</pubDate>
<dc:creator>榆木疙瘩ii</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhao752718372/p/7816080.html</dc:identifier>
</item>
<item>
<title>【持续更新】JavaScript常见面试题整理 - 卡尔西法calcifer</title>
<link>http://www.cnblogs.com/wq1994/p/7816020.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wq1994/p/7816020.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;&lt;span&gt;【重点提前说&lt;span&gt;】这篇博客里的问题涉及到了JS中常见的的基础知识点，也是面试中常见的一些问题，建议初入职场的园友Mark收藏，本文会持续更新~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110185707044-723103091.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;1、 &lt;span&gt;引入&lt;span&gt;JS&lt;span&gt;的三种方式&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1、在HTML标签中直接使用，直接内嵌JS（但是不提倡使用）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;不符合W3C关于内容和行为分离的要求；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、在HTML页面中使用&amp;lt;scrip&amp;gt; &amp;lt;/script&amp;gt;标签包裹JS代码；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;script标签可以放到页面的各种位置；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、引入外部的JS文件使用&amp;lt;script&amp;gt; &amp;lt;/script&amp;gt;标签；&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;2、 &lt;span&gt;JS&lt;span&gt;中的变量声明&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181117825-442842401.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;3、 &lt;span&gt;JS&lt;span&gt;中变量的数据类型&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181144466-689623326.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;4、 &lt;span&gt;常用的数值函数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div readability=&quot;8&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181213044-867342328.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;parseInt()只能转字符串，转其他的类型都是NAN；而Number（）能转所有的数据类型；&lt;/p&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;5、 &lt;span&gt;运算符注意事项&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181247122-1828925804.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;6、 &lt;span&gt;判断水仙花数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181329669-548886598.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;7、 I&lt;span&gt;f&lt;span&gt;结构，循环结构，支持的判断结果：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181401075-227665399.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;8、 &lt;span&gt;循环控制语句：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181424872-1877408493.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;9、 &lt;span&gt;斐波那契数列&lt;span&gt;:1,1,2,3,5,8,13,21&lt;span&gt;……&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181451356-1246058895.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;10、 &lt;span&gt;JS&lt;span&gt;中函数的调用方式/事件的绑定方式&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181513731-48145763.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;11、 &lt;span&gt;window&lt;span&gt;对象的常用方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181533794-1399602152.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181920309-636385506.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181947903-1666312487.png&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;328&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;12、 DOM&lt;span&gt;操作的相关方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181614559-619921419.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;13、 &lt;span&gt;键盘事件&lt;span&gt;&amp;amp;&lt;span&gt;确定键盘按键&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182043559-116687543.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;14、 DOM2 &lt;span&gt;兼容写法：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182115294-584653886.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;15、 &lt;span&gt;事件冒泡&lt;span&gt;&amp;amp;&lt;span&gt;事件捕获&lt;span&gt;&amp;amp;&lt;span&gt;阻止默认事件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182141497-1621523934.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;16、 &lt;span&gt;数组常用方法：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182206372-137276246.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;17、 &lt;span&gt;引用数据类型&lt;span&gt;&amp;amp;&lt;span&gt;基本数据类型：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182230216-2025554138.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;18、 &lt;span&gt;Number&lt;span&gt;类常用方法：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182256856-1282631291.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;19、 &lt;span&gt;String&lt;span&gt;类常用方法：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182324888-1207515199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;20、 &lt;span&gt;Date&lt;span&gt;类：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182352528-61077849.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;21、 &lt;span&gt;杨辉三角：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182433794-2058005383.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;22、 &lt;span&gt;正则表达式声明：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182458700-476495782.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;23、 &lt;span&gt;正则表达式常用规则：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182533122-941116292.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;24、 &lt;span&gt;正则中的&lt;span&gt;test&lt;span&gt;与&lt;span&gt;exec&lt;span&gt;方法：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182618075-1319868680.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;25、 foreach与each的区别？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;forEach是js中的方法&lt;span&gt;（针对数组），而&lt;span&gt;each是jquery中的方法&lt;span&gt;（针对jquery对象，即$( )；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.forEach方法：如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182653466-2144947337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182719231-342986209.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;span&gt;2.each方法：如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182747325-368877856.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182810559-1048920153.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;26、document load 和document ready的区别&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Document.onload &lt;span&gt;是在结构和样式加载完才执行&lt;span&gt;js&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;window.onload&lt;span&gt;：不仅仅要在结构和样式加载完，还要执行完所有的样式、图片这些资源文件，全部加载完才会触发&lt;span&gt;window.onload&lt;span&gt;事件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Document.ready原生种没有这个方法，jquery中有 $().ready(function)&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;27、什么是CSS Hack？怎么表示？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;CSS hack由于不同厂商的&lt;span&gt;浏览器，比如Internet Explorer,Safari,&lt;span&gt;Mozilla Firefox,Chrome等，或者是同一厂商的浏览器的不同版本，如IE6和IE7，对CSS的解析认识不完全一样，因此会导致生成的页面效果不一样，得不到我们所需要的页面效果。 这个时候我们就需要针对不同的浏览器去写不同的CSS，让它能够同时兼容不同的浏览器，能在不同的浏览器中也能得到我们想要的页面效果。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;简单的说，CSS hack的目的就是使你的CSS代码兼容不同的浏览器。当然，我们也可以反过来利用CSS hack为不同版本的浏览器定制编写不同的CSS效果。&lt;/p&gt;
&lt;p&gt;方式一 条件注释法 方法二 类内属性前缀法 方式三：选择器前缀法&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;28、Javascript中callee和caller的作用？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;arguments.callee&lt;span&gt;：获得当前函数的引用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;caller是返回一个对函数的引用，该函数调用了当前函数；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;callee是返回正在被执行的function函数，也就是所指定的function对象的正文。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;29、简述创建函数的几种方式&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;第一种（函数声明）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; sum1(num1,num2){
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1+&lt;span&gt;num2;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;第二种（函数表达式）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; sum2 = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(num1,num2){
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1+&lt;span&gt;num2;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;匿名函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;function(){}:&lt;span&gt;只能自己执行自己&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;第三种（函数对象方式）：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; sum3 = &lt;span&gt;new&lt;/span&gt; Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1+num2&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;30、把 &lt;span&gt;Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;如果说放在&lt;span&gt;body&lt;span&gt;的封闭之前，将会阻塞其他资源的加载&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果放在&lt;span&gt;body&lt;span&gt;封闭之后，不会影响&lt;span&gt;body&lt;span&gt;内元素的加载&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;31、iframe的优缺点？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 解决加载缓慢的第三方内容如图标和广告等的加载问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. Security sandbox安全沙盒&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 并行加载脚本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. iframe会阻塞主页面的Onload事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 即使内容为空，加载也需要时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 没有语意&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;32、请你谈谈&lt;span&gt;Cookie的弊端？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.`Cookie`数量和长度的限制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.安全性问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.有些状态不可能保存在客户端。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;33、js延迟加载的方式有哪些？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1. defer和async&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 按需异步载入js&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;34、documen.write和 innerHTML 的区别？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;document.write 只能重绘整个页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;innerHTML 可以重绘页面的一部分&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;35、哪些操作会造成内存泄漏？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 &lt;span&gt;0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 闭包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 控制台日志&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;36、JS是一门什么类型的语言?&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;JS可以模拟实现继承和封装，但是不能模拟实现多态，故js是基于事件的，基于对象的轻量级脚本语言。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;37、语言有哪几种类型？各有什么特点？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1、语言的分类：&lt;/p&gt;
&lt;p&gt;①、面向机器：汇编语言。&lt;/p&gt;
&lt;p&gt;②、面向过程：C语言&lt;/p&gt;
&lt;p&gt;③、面向对象：Java、C++、PHP等。&lt;/p&gt;
&lt;p&gt;2、面向过程与面向对象：&lt;/p&gt;
&lt;p&gt;①、面向过程：专注于如何去解决一个问题的过程步骤，编程的特点是由一个个的函数去实现每一步的过程步骤，没有类和对象的概念。&lt;/p&gt;
&lt;p&gt;②、面向对象：专注于由哪一个对象来解决这个问题，编程特点是出现了一个个的类，从类中拿到对象&lt;/p&gt;
&lt;p&gt;【面向对象的三大特征】 继承、封装、多态&lt;/p&gt;
&lt;p&gt;【区别】&lt;/p&gt;
&lt;p&gt;对于调用者来说，面向过程需要调用者自己去实现各种函数，&lt;/p&gt;
&lt;p&gt;而面向对象，只需要告诉调用者对象中具体方法的功能，不需要调用者去了解方法中的实现细节。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;38、JavaScript中类和对象的关系：&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;类是抽象的，对象是具体的&lt;/p&gt;
&lt;p&gt;类是对象的抽象化，对象是类的具体化；&lt;/p&gt;
&lt;p&gt;★类是一个抽象的概念，只能说类有属性和方法，但是不能给属性和方法赋具体的值。&lt;/p&gt;
&lt;p&gt;例如:人类有身高，但是不能说出具体数值&lt;/p&gt;
&lt;p&gt;★对象是一个具体的个例，是将类中的属性进行具体赋值而来的个体；&lt;/p&gt;
&lt;p&gt;例如：张三是人类中的一个个体，身高180cm。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;39、实现继承的三种方式？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1、使用call bind apply来实现继承。&lt;/p&gt;
&lt;p&gt;2、通过扩展object来实现继承。&lt;/p&gt;
&lt;p&gt;3、使用原型实现继承。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;40、 什么叫封装？有什么方法和特点？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;① 方法的封装： 将类内部的函数进行私有化处理，不对外提供调用接口，无法在类外部使用的方法，称为私有方法，即方法的封装。&lt;/p&gt;
&lt;p&gt;② 属性的封装： 将类中的属性进行私有化处理，对外不能直接使用对象名访问(私有属性)。 同时，需要提供专门用于设置和读取私有属性的set/get方法，让外部使用我们提供的方法，对属性进行操作。 这就叫属性的封装。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;封装不是拒绝访问，而是限制访问。 要求调用者，必须使用我们提供的set/get方法进行属性的操作，而不是直接拒绝操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因此，单纯的属性私有化，不能称为封装！必须要私有化之后，提供对应的set/get方法。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;41、 原生JS对象与JQuery对象之间的相互转化方式有哪些？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;① 使用$(&quot;&quot;)选中的是JQuery对象，只能调用JQuery函数，而不能使用元素的JS事件与函数；&lt;/p&gt;
&lt;p&gt;② 原生的JS对象转为 JQuery对象&lt;/p&gt;
&lt;p&gt;可以使用$() 包裹即可以转为JQuery对象&lt;/p&gt;
&lt;p&gt;var p = document.getElementsByTagName(&quot;p&quot;);&lt;/p&gt;
&lt;p&gt;$(&quot;p&quot;).click(); √ 原生的JS对象已经转为 JQuery对象；&lt;/p&gt;
&lt;p&gt;③ JQuery转为原生JS对象：&lt;/p&gt;
&lt;p&gt;使用get(index)或者[index]&lt;/p&gt;
&lt;p&gt;$(&quot;#p&quot;).get(0).onclick() = function () {}; √&lt;/p&gt;
&lt;p&gt;$(&quot;#p&quot;).[0].onclick() = function () {}; √&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;42、JS常用的内置对象有哪些？它们各自的一些方法有哪些？：&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1、Boolean类、Number类:、String类、Date日期类、&lt;/p&gt;
&lt;p&gt;2、常用方法：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Number类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;.toString() 将数值类型转换成字符串类型；&lt;/p&gt;
&lt;p&gt;.toLocaleString()将数值按照本地格式顺序转换成字符串，一般从右开始，三个一组加都好分隔开；&lt;/p&gt;
&lt;p&gt;.toFixed(n)；将数字保留n位小数，并将其转换为字符串格式；&lt;/p&gt;
&lt;p&gt;.toPrecision(n):将数字格式化为指定长度。n表示不含小数点的位数长度。如果n&amp;lt;原数字长度，则用科学计数法表示。&lt;/p&gt;
&lt;p&gt;.valueOf() 返回Number对象的基本数字值；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;String类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;str.length 返回字符串的长度，即为字符数；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;str.toLowerCase()将字符串所有的字符转成小写；&lt;/p&gt;
&lt;p&gt;str.UpLowerCase()将字符串所有的字符转成大写；&lt;/p&gt;
&lt;p&gt;str.charAt(N)截取数组的第N个字符，相当于str[N]；&lt;/p&gt;
&lt;p&gt;str.indexOf(&quot;srt&quot;,index)查找子串在字符串中出现的位置，如果没有找到返回-1，其他同数组的indexOf方法；&lt;/p&gt;
&lt;p&gt;str.lastIndexOf()同数组。&lt;/p&gt;
&lt;p&gt;str.subString (begin,end) 截取数组中的某一部分并返回截取的字符串&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;传入一个参数，表示是开始的区间，默认将截取到字符串末尾；&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;传入两个参数，表示开始和结束的下标，是一个左闭右开区间；&lt;/p&gt;
&lt;p&gt;str.split(分隔符)将字符串以指定分隔符分隔存入数组中，&lt;/p&gt;
&lt;p&gt;str.replace(old，new)将字符串中的字符进行替换；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Date日期类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、new Date();返回当前最新时间；&lt;/p&gt;
&lt;p&gt;new Date(&quot;2017,08,29,12:33:29&quot;) 返回指定时间；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;43、什么是Jquery中的文档就绪函数&lt;span&gt;？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;文档就绪函数防止文档在未完全加载之前，运行JQuery代码；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;$(document).ready(function() {&lt;/p&gt;
&lt;p&gt;//JQuery代码&lt;/p&gt;
&lt;p&gt;})；&lt;/p&gt;
&lt;p&gt;简写形式如下：&lt;/p&gt;
&lt;p&gt;$(function(){});&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[文档就绪函数&amp;amp;window.onload的区别]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① window.onload必须等到网页中的所有内容(包括图片视频)加载完成后才能执行代码；&lt;/p&gt;
&lt;p&gt;文档就绪函数只需要在 网页DOM结构加载完成之后，就可以执行代码；&lt;/p&gt;
&lt;p&gt;② window.onload只能写一个，写多个之后只会执行最后一个；&lt;/p&gt;
&lt;p&gt;文档就绪函数可以写多个，而且不会覆盖。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;44、常用的CSS的预处理器有哪些？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;less&lt;/p&gt;
&lt;p&gt;sass 常用的编译方式&lt;/p&gt;
&lt;p&gt;它们之间的区别：&lt;/p&gt;
&lt;p&gt;SCSS中的嵌套：选择器嵌套 属性嵌套 伪类嵌套&lt;/p&gt;
&lt;p&gt;&lt;span&gt;混合宏、继承、占位符：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① 混合宏:使用@mixin声明混合宏，在其他选择器中使用@include调用混合宏&lt;/p&gt;
&lt;p&gt;② 继承 ：声明一个普通的class，在其他的选择器中使用extend 继承这个class；&lt;/p&gt;
&lt;p&gt;③ 占位符 ：使用%声明%占位符，在其他选择器中使用@extend 继承占位符；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;45、简述下JS中的事件分类&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1、鼠标事件： click/dblclick/onmouseon/onmouseover.....&lt;/p&gt;
&lt;p&gt;2、HTML事件： onload/onscroll/onsubmit/onchange/onfocus....&lt;/p&gt;
&lt;p&gt;3、键盘事件：&lt;/p&gt;
&lt;p&gt;keydown:键盘按下时触发&lt;/p&gt;
&lt;p&gt;keypress:键盘按住时触发&lt;/p&gt;
&lt;p&gt;keyup:键盘抬起时触发&lt;/p&gt;
&lt;p&gt;【确定触发的按键】&lt;/p&gt;
&lt;p&gt;① 在触发的函数中传入一个参数e，表示键盘事件；&lt;/p&gt;
&lt;p&gt;② 使用e.keyCode，取到按键的Ascii码值，进而确定触发按键；&lt;/p&gt;
&lt;p&gt;③ 所有浏览器的兼容写法(一般并不需要)&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110184731013-1817762299.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;46、浅谈JavaScript的优点和缺点：&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;性能：由于JavaScript运行在客户端，节省了web服务器的请求时间和带宽&lt;/li&gt;
&lt;li&gt;轻量级的脚本语言，比较容易学习&lt;/li&gt;
&lt;li&gt;运行在用户机器上，运行结果和处理相对比较快。&lt;/li&gt;
&lt;li&gt;可以使用第三方附加组件来检查代码片段。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安全问题：由于JavaScript在客户端运行，可能被用于黑客目的。&lt;/li&gt;
&lt;li&gt;渲染问题：在不同浏览器中的处理结果可能不同。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;47、浅谈jQuery的优点和缺点：&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;使用jQuery最大的好处是少量的代码做更多的事情。&lt;/p&gt;
&lt;p&gt;Write Less Do More&lt;/p&gt;
&lt;p&gt;看个简单例子，获取元素的值，使用JavaScript：&lt;/p&gt;
&lt;p&gt;Javascript代码&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;document.getElementById(‘elementid').value&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用jQuery：&lt;/p&gt;
&lt;p&gt;Jquery代码&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;$(‘#elementid').val();&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;与JavaScript相比，jQuery的语法更加简单。&lt;span&gt;通过jQuery，可以很容易地浏览文档、选择元素、处理事件以及添加效果等，同时还允许开发者定制插件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;jQuery消除了JavaScript跨平台兼容问题。&lt;/li&gt;
&lt;li&gt;相比其他JavaScript和JavaScript库，jQuery更容易使用。&lt;/li&gt;
&lt;li&gt;jQuery有一个庞大的库/函数。&lt;/li&gt;
&lt;li&gt;jQuery有良好的文档和帮助手册。&lt;/li&gt;
&lt;li&gt;jQuery支持AJAX。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由于不是原生JavaScript语言，理解起来可能会受到限制。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;项目中需要包含jQuery库文件。如果包含多个版本的jQuery库，可能会发生冲突。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;48、浅谈angular优缺点&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;简介：angularjs是一个javascript框架。通过script脚本引入，他是一个用Javascript编写的库。&lt;span&gt;angularjs通过指令扩展了HTML，通过表达式绑定数据到HTML中。&lt;span&gt;AngularJS主要考虑的是构建CRUD（增删改查）应用。幸运的是，至少90%的WEB应用都是CRUD应用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. 改变操作dom的方式&lt;/p&gt;
&lt;p&gt;将传统的JQuery的先选择元素，在操作的方式改变成了直接对于元素本身的操作。&lt;/p&gt;
&lt;p&gt;这依赖于强大的Html Parser的能力和directive灵活。&lt;/p&gt;
&lt;p&gt;2. 后端MVC前端化&lt;/p&gt;
&lt;p&gt;3. 数据操作&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、框架略笨重&lt;/p&gt;
&lt;p&gt;2、不适合页面复杂的网站类型开发：&lt;/p&gt;
&lt;div readability=&quot;6.0769230769231&quot;&gt;内容网站，需要SEO的。(SEO目前也有了prerender解决方案) https//&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//prerender.io/&quot;&gt;&lt;span&gt;prerender.io&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;交互频繁的，如游戏之类交互体验网站。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;49、什么叫做事件委派？有什么作用？（优点）&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;Jq中的事件委派on&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;将原本需要绑定到子元素上的事件，绑定到其祖先节点乃至根节点上面，再委派给子元素节点，生效！&lt;/p&gt;
&lt;p&gt;eg: $(&quot;p&quot;).on(&quot;click&quot;,function(){});&lt;/p&gt;
&lt;p&gt;事件委派 如下：&lt;/p&gt;
&lt;p&gt;$(document).on(&quot;click&quot;,&quot;p&quot;,function(){});&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;作用：&lt;/p&gt;
&lt;p&gt;不使用事件委派的绑定方式，只能将事件绑定到初始化时的子元素标签上，&lt;/p&gt;
&lt;p&gt;当页面新增同类型标签时，这些新增的标签上，没有之前绑定的事件。&lt;/p&gt;
&lt;p&gt;而使用 事件委派时 ，当页面新增更同类型标签时,这些新增的事件也具有之同类型前标签所绑定的事件！&lt;/p&gt;
&lt;p&gt;off()取消事件绑定&lt;/p&gt;
&lt;p&gt;$(&quot;p&quot;).off(&quot;click&quot;):取消单事件绑定&lt;/p&gt;
&lt;p&gt;$(&quot;p&quot;).off(&quot;click mouseover dbclick&quot;):取消多事件绑定&lt;/p&gt;
&lt;p&gt;$(document).off(&quot;click&quot;，&quot;p&quot;):取消委派事件绑定&lt;/p&gt;
&lt;p&gt;$(&quot;p&quot;).off()取消所有的事件绑定&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;50、详细介绍下 CSS的动画&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1、 css的transition transition抓住了所设置变化属性的起始态和完成态，通过设定的速度曲线来完成动画。可以涉及到各种变化的css属性，默认为all，则所有变化的属性都会在出发时，以动画的形式展现出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;tips：transform是一种变化属性，该属性允许我们对元素进行旋转、缩放、移动或倾斜。可以作为transition中需要变化的属性。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.css3的animation属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用animation属性制作动画可以更加灵活的设置动画帧，通过不同keyframe（动画帧）的设置，实现很多优雅的效果，keyframe中的百分数是动画完成总时间的比例。&lt;/p&gt;
&lt;p&gt;animation是设置总的动画效果，而keyframe中设置上相应的动画名字，然后在keyframe中设置具体的动画效果。&lt;/p&gt;
&lt;p&gt;JS中的动画&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.原生js动画&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;原生js动画利用js代码，将动画一步以函数的方式写出来，可以实现多种动画样式，而且可以自己做兼容性处理，自己设立每一步的动画效果，并且能够完成比较复杂的效果，但是代码量很大。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;51、&lt;span&gt;Jquery与jQuery UI 有啥区别？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;*jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;*jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;52、jquery 中如何将数组转化为json字符串，然后再转化回来？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
   $.fn.stringifyArray = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(array) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; JSON.stringify(array)
    }
    $.fn.parseArray &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(array) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; JSON.parse(array)
    }
    然后调用：
    $(&lt;/span&gt;&quot;&quot;).stringifyArray(array)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;53、函数实现&lt;span&gt;阻止冒泡函数的功能？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td data-cell-id=&quot;2439-1508681416627-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;2439-1508681416627-cell-0-1&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;span&gt;function stopPropagation(e) {  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;e = e || window.event;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;if(e.stopPropagation) { //W3C阻止冒泡方法  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;e.stopPropagation();  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;} else {  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;e.cancelBubble = true; //IE阻止冒泡方法  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;}  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;document.getElementById('need_hide').onclick = function(e) {  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;stopPropagation(e);  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;54、什么是闭包？ &lt;span&gt;&lt;span&gt;写一个简单的闭包？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;  &lt;span&gt;我的理解是，闭包就是能够读取其他函数内部变量的函数。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JS中提供了一种闭包的概念：在函数中，定义一个子函数，子函数可以访问父函数的私有变量，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以在子函数中进行操作，最后将子函数通过return返回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;闭包的作用:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① 可以在函数外部访问函数的私有变量；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② 让函数内部的变量，可以始终存在于内存中，不会在函数调用完成之后立即释放！&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td data-cell-id=&quot;8058-1508682327164-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;8058-1508682327164-cell-0-1&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;function outer(){&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;var num = 1;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;function inner(){&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;var n = 2;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;alert(n + num);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;return inner;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;outer()();&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;55、call和apply的区别是什么？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;    参数形式不同，call(obj, pra, pra)后面是单个参数。apply(obj, [args])后面是数组。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;56、为什么不能定义&lt;span&gt;1px左右的div容器？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;   &lt;span&gt;IE6下这个问题是因为默认的行高造成的，解决的方法也有很多，例如：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;overflow:hidden | zoom:0.08 | line-height:1px&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;57、bind(), live(), delegate()的区别&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;    bind： 绑定事件，对新添加的事件不起作用，方法用于将一个处理程序附加到每个匹配元素的事件上并返回jQuery对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    live： 方法将一个事件处理程序附加到与当前选择器匹配的所有元素（包含现有的或将来添加的）的指定事件上并返回jQuery对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;delegate： 方法基于一组特定的根元素将处理程序附加到匹配选择器的所有元素（现有的或将来的）的一个或多个事件上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;58、简述&lt;span&gt;link和import的区别？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;区别&lt;span&gt;1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;区别&lt;span&gt;2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;区别&lt;span&gt;3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;区别&lt;span&gt;4：link支持使用Javascript控制DOM去改变样式；而@import不支持。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;59、你如何优化自己的代码？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1、代码重用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、避免全局变量（命名空间，封闭空间，模块化&lt;span&gt;mvc..）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、拆分函数避免函数过于臃肿：&lt;span&gt;单一职责&lt;span&gt;原则&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、适当的注释，尤其是一些复杂的业务逻辑或者是计算逻辑，都应该写出这个业务逻辑的具体过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存管理，尤其是闭包中的变量释放&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;60、使用&lt;span&gt;js实现这样的效果：在文本域里输入文字时，当按下enter键时不换行，而是替换成“{{enter}}”,(只需要考虑在行尾按下enter键的情况)&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;textarea.&lt;span&gt;onkeydown=function(e){&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  e.preventDefault();//&lt;span&gt;为了阻止&lt;span&gt;enter&lt;span&gt;键的默认换行效果&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  if(e.keycode==”enter&lt;span&gt;键码”){&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    testarea.value+&lt;span&gt;=”{&lt;span&gt;{enter}}”;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;61、请简要描述&lt;span&gt;web&lt;span&gt;前端性能需要考虑哪方面，你的优化思路是什么？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;参见雅虎&lt;span&gt;14web&lt;span&gt;优化规则&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;减少&lt;span&gt;http&lt;span&gt;请求：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1&lt;span&gt;、小图弄成大图，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2&lt;span&gt;、合理的设置缓存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3&lt;span&gt;、资源合并、压缩&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将外部的&lt;span&gt;js&lt;span&gt;文件置底&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;62、简述readyonly与disabled的区别&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;readonly&lt;span&gt;只针对&lt;span&gt;input(text / password)&lt;span&gt;和&lt;span&gt;textarea&lt;span&gt;有效，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而disabled&lt;span&gt;对于所有的表单元素都有效，当表单元素在使用了disabled&lt;span&gt;后，当我们将表单以&lt;span&gt;POST&lt;span&gt;或&lt;span&gt;GET&lt;span&gt;的方式提交的话，这个元素的值不会被传递出去，而&lt;span&gt;readonly&lt;span&gt;会将该值传递出去&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;63、请尽可能详尽的解释ajax的工作原理&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;思路：&lt;span&gt;先解释异步，再解释&lt;span&gt;ajax&lt;span&gt;如何使用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ajax&lt;span&gt;的&lt;span&gt;原理简单来说通过&lt;span&gt;XmlHttpRequest&lt;span&gt;对象来向服务器发异步请求，从服务器获得数据，然后用&lt;span&gt;javascript&lt;span&gt;来操作&lt;span&gt;DOM&lt;span&gt;而更新页面。&lt;span&gt;这其中最关键的一步就是&lt;span&gt;从服务器获得请求数据&lt;span&gt;。要清楚这个过程和原理，我们必须对&lt;span&gt; XMLHttpRequest&lt;span&gt;有所了解。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;XMLHttpRequest&lt;span&gt;是&lt;span&gt;ajax&lt;span&gt;的核心机制，它是在&lt;span&gt;IE5&lt;span&gt;中首先引入的，是一种支持异步请求的技术。简单的说&lt;span&gt;，也就是&lt;span&gt;javascript&lt;span&gt;可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;64、为什么扩展javascript内置对象不是好的做法？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;因为扩展内置对象会影响整个程序中所使用到的该内置对象的原型属性&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;65、浏览器标准模式和怪异模式之间的区别是什么？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;标准模式是指，浏览器按&lt;span&gt;W3C&lt;span&gt;标准解析执行代码；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;浏览器解析时到底使用标准模式还是怪异模式，与你网页中的&lt;span&gt;DTD&lt;span&gt;声明&lt;span&gt;直接相关，&lt;span&gt;DTD&lt;span&gt;声明定义了标准文档的类型（标准模式解析）文档类型，会使浏览器使用相应的方式加载网页并显示，忽略&lt;span&gt;DTD&lt;span&gt;声明&lt;span&gt;,&lt;span&gt;将使网页进入怪异模式。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;66、如果设计中使用了非标准的字体，你该如何去实现？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;先通过&lt;span&gt;font-face&lt;span&gt;定义字体，再引用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;@font-face&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;font-family: myFirstFont;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;src: url('Sansation_Light.ttf'),&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     url('Sansation_Light.eot'); &lt;span&gt;/* IE9+ */&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;67、简述.trigger与.triggerHandler的区别&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;.trigger()自动 触发某元素事件；&lt;/p&gt;
&lt;p&gt;第一个参数：是需要触发的事件类型；&lt;/p&gt;
&lt;p&gt;第二个参数：(可选)数组格式，表示传递给事件函数的参数；&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;传递进来的参数，可以在事件函数中，定义形参进行获取&lt;/p&gt;
&lt;p&gt;(形参第一个必须是event事件，所以从第二个开始为所传递的参数！)&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; 也可以直接在函数中，使用arguements对象数组，读取参数;&lt;/p&gt;
&lt;p&gt; .triggerHandler()：功能同上，区别如下：&lt;/p&gt;
&lt;p&gt;① .triggerHandler()不能触发浏览器默认的HTML事件，如submit等；&lt;/p&gt;
&lt;p&gt;② .trigger()可以触发页面中所有匹配元素的事件；&lt;/p&gt;
&lt;p&gt;而.triggerHandler()只能触发第一个匹配元素的事件；&lt;/p&gt;
&lt;p&gt;③ .trigger()的返回值，返回的是调用当前函数的对象，符合JQuery的可链式语法；&lt;/p&gt;
&lt;p&gt;.triggerHandler()返回的是事件函数的返回值，如果事件函数没有返回值，则返回的是Undefined；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;69、call bind apply 这三个函数有什么共同的作用？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;通过函数名调用这三个函数，可以强行将函数中的this指定为某一个对象&lt;/p&gt;
&lt;p&gt;三个函数的唯一区别，在于接受func的&lt;span&gt;参数列表的形式不同，除此之外，功能上没有差别！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;三个函数的写法(区别)&lt;/p&gt;
&lt;p&gt;① call写法：func.call(func的this指向的obj,func参数1,func参2,....);&lt;/p&gt;
&lt;p&gt;② apply写法：func.apply(func的this指向的obj,[func参数1,func参2,....]);&lt;/p&gt;
&lt;p&gt;③ bind写法：func.bind(func的this指向的obj),(func参数1,func参2,....);&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;70、扩展Object实现继承&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;① 声明一个父类函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;function Parent (){}&lt;/p&gt;
&lt;p&gt;声明一个子类函数&lt;/p&gt;
&lt;p&gt;function Son (){}&lt;/p&gt;

&lt;p&gt;&lt;span&gt;② 通过prototype给Object类添加一个扩展方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Object.prototype.extend = function (parent) {&lt;/p&gt;
&lt;p&gt;for(var i in parent){&lt;/p&gt;
&lt;p&gt;this[i] = parent[i];&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③ 分别拿到父类对象和子类对象: 实例化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;var p = new Parent();&lt;/p&gt;
&lt;p&gt;var s = Son();&lt;/p&gt;
&lt;p&gt;&lt;span&gt;④ 用子类对象调用扩展方法，实现从继承操作：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;s.extend(p)&lt;/p&gt;
&lt;p&gt;实现继承的原理：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过循环将父类对象的所有属性和方法，全部赋给子类对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;关键点在于for-in循环，即使不扩展Object，也能通过简单的循环实现操作；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;71、详细解释下JS中的this指向问题&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;谁最终调用函数，this就指向谁！&lt;/p&gt;
&lt;p&gt;this指向的规律 ：(跟函数的调用方式息息相关！)&lt;/p&gt;
&lt;p&gt;① 通过 【 函数名() 】 调用的，this永远指向window；&lt;/p&gt;
&lt;p&gt;② 通过 【 对象.方法 】调用的，this永远指向对象。obj.func();&lt;/p&gt;
&lt;p&gt;③ 函数作为数组中的 一个元素，通过数组下标调用的 【 arr[i]() 】，this指向数组arr。&lt;/p&gt;
&lt;p&gt;④ 函数作为window内置函数的回调函数使用，this指向widow；&lt;/p&gt;
&lt;p&gt;setTimeout() setInterval()等&lt;/p&gt;
&lt;p&gt;⑤ 函数作为构造函数，使用new关键字调用，this指向新new出的对象。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;72、BootStrap的优点和缺点:&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;优点：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;流媒体网格布局&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;响应式设计&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自定义表单元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;页面排版&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JavaScript交互性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;跨浏览器兼容性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;BT栅格系统的本质就是通过CSS3的媒体查询实现的&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BootStrap的缺点:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;兼容性可能不太好&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;73、什么是渐进增强（progressive enhancement）、优雅降级（graceful degradation）呢？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;渐进增强（progressive enhancement）：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。（&lt;span&gt;从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能，向页面添加无害于基础浏览器的额外样式和功能。当浏览器支持时，它们会自动地呈现出来并发挥作用。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;优雅降级（graceful degradation）：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。（&lt;span&gt;Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了，为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的、能够起作用的版本开始，并不断扩充，以适应未来环境的需要。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;74、常见的浏览器状态码&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;200--请求成功！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;500--内部服务器错误！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;404--请求失败！&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;75、详述jQuery中Ajax的写法以及get和post的区别&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;$.ajax() 通过 HTTP 请求加载远程数据。jQuery 最底层 AJAX 实现函数。&lt;/p&gt;
&lt;p&gt;接受一个大的对象。对象里面的属性和方法，表示ajax请求的相关设置：&lt;/p&gt;
&lt;p&gt;① url:被请求的远程文件的路径。&lt;/p&gt;
&lt;p&gt;② Ajax请求的类型，可选值get/post.&lt;/p&gt;
&lt;p&gt;回调函数：&lt;/p&gt;
&lt;p&gt;•success： 请求成功的回调函数。接受一个参数data，表示后台返回的数据。&lt;/p&gt;
&lt;p&gt;•dataType：预期服务器返回的数据类型。&lt;/p&gt;
&lt;p&gt;&quot;json&quot;: 返回 JSON 数据 。&lt;/p&gt;
&lt;p&gt;&quot;text&quot;: 返回纯文本字符串&lt;/p&gt;
&lt;p&gt;•data：对象格式。向后台发送一个对象，表示传递的数据。&lt;/p&gt;
&lt;p&gt;常用于type为post的请求方式。&lt;/p&gt;
&lt;p&gt;如果type为get,可以使用？直接追加载URL后面。&lt;/p&gt;
&lt;p&gt;•error:请求失败时的回调函数&lt;/p&gt;
&lt;p&gt;•statusCode:接受一个对象，对象的键值对是status状态码和对应的回调函数，&lt;/p&gt;
&lt;p&gt;表示当请求状态码是对应数字时，执行具体的操作函数.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$.get(); $.post(); 这两个函数，是在$.ajax()的基础上进行封装而来。可以直接默认发送get请求或post请求；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;*&lt;/p&gt;
&lt;p&gt;* 接受四个参数：&lt;/p&gt;
&lt;p&gt;* ① 请求的URL路径。 相当于$.ajax()里面的url；&lt;/p&gt;
&lt;p&gt;* ② 向后台传递的数据。 相当于$.ajax()里面的data；&lt;/p&gt;
&lt;p&gt;* ③ 请求成功的回调函数。 相当于$.ajax()里面的success；&lt;/p&gt;
&lt;p&gt;* ① 预期返回的数据类型。 相当于$.ajax()里面的dataType；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;76、IE和DOM事件流的区别&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;IE9以前&lt;span&gt;：&lt;span&gt;attachEvent(“onclick”)、detachEvent&lt;span&gt;(“onclick”)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IE9开始&lt;span&gt;跟&lt;span&gt;DOM事件流是一样的，都是addEventListener&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;77、IE跟DOM事件流有什么区别&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;① 阐述事件绑定方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IE9以前&lt;span&gt;：&lt;span&gt;attachEvent(“onclick”)、detachEvent&lt;span&gt;(“onclick”)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IE9开始:&lt;span&gt;跟&lt;span&gt;DOM事件流是一样的，都是addEventListener&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② 这两种绑定方式的区别&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;span&gt;写法上的区别：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;attachEvent&lt;span&gt;两个参数、事件带&lt;span&gt;on&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;addEventListener &lt;span&gt;三个参数、事件不带&lt;span&gt;on、true/false表示&lt;span&gt;捕获&lt;span&gt;/冒泡&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;功能上的区别：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;attachEvent绑定的事件全部冒泡&lt;span&gt;、&lt;span&gt;addEventListener根据第三个参数是true还是false决定冒泡还是捕获。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③ &lt;span&gt;事件冒泡和事件捕获。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;冒泡： &lt;span&gt;&lt;span&gt;当触发一个事件时，会从当前节点开始，依次触发其祖先节点的同类型事件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;span&gt;捕获： &lt;span&gt;&lt;span&gt;从根节点开始，依次触发其祖先节点同类型事件，直到节点自身。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;78、IE和标准下有哪些兼容性的写法？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1、获取事件对象&lt;span&gt;(&lt;span&gt;事件因子&lt;span&gt;)&lt;span&gt;：  ev = e || window.event;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、DOM2&lt;span&gt;添加事件： &lt;span&gt;if(dom.attachEvent&lt;span&gt;){&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Dom. attachEvent(“onclick”,function);&lt;/p&gt;
&lt;p&gt;}else{&lt;/p&gt;
&lt;p&gt;Dom.&lt;span&gt; addEventListener(“click”,function);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、取消事件冒泡： &lt;span&gt;if (e.stopPropagation) {&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         e.stopPropagation(); //IE&lt;span&gt;以外&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    } else {&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        e.cancelBubble = true; //IE8&lt;span&gt;之前&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、取消默认事件：if (e.preventDefault) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     e.preventDefault(); //IE&lt;span&gt;以外&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  } else {&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;  e.returnValue = false; //IE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;79、API是什么？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;API&lt;span&gt;（&lt;span&gt;Application Programming Interface,&lt;span&gt;应用程序编程接口&lt;span&gt;）是一&lt;span&gt;些预先定义的函数，&lt;span&gt;目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而&lt;span&gt;又无需访问源码&lt;span&gt;，或理解内部工作机制的细节。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在编程语言中，API&lt;span&gt;通常指语言中内置的函数、接口、类等系统工具。我们编程人员无需关心这些函数的实现细节，只需要按照API&lt;span&gt;文档的要求，给函数传入指定参数接受返回值即可。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;在前后台传递数据，API&lt;span&gt;也是后台提供给前台的接口，前台只需要按照要求请求接口并发送指定参数，结课接受JSON&lt;span&gt;字符串。例如：&lt;a href=&quot;https://api.douban.com/v2/book/1220562&quot;&gt;&lt;span&gt;https://api.douban.com/v2/book/1220562&lt;/span&gt;&lt;/a&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;80、Javascript事件处理器在线程空闲之前不会运行是什么意思？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;JS&lt;span&gt;是一个&lt;span&gt;单线程应用，&lt;span&gt;也就是说，当某一段代码正在执行的时候，其他代码如果需要执行也必须等到这个线程结束后，才能执行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td data-cell-id=&quot;8790-1508838851156-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;8790-1508838851156-cell-0-1&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;for(var i=1;i&amp;lt;=3;i++){&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  setTimeout(function(){&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      console.log(i);   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  },0); &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;代码执行到for&lt;span&gt;循环时，当for&lt;span&gt;循环执行第一次，遇到第一个&lt;span&gt;setTimeout时并不会立即触发&lt;span&gt;，因为&lt;span&gt;for循环还有结束&lt;span&gt;，现在的线程被&lt;span&gt;for循环阻塞&lt;span&gt;。&lt;span&gt;setTimeout必须等到for循环的线程结束以后&lt;span&gt;，也就是线程空闲之后，才能执行，而这时候&lt;span&gt;i已经变成了4.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;所以最终打印三个&lt;span&gt;4.  解决的办法可以将var改成let，或者for循环中嵌套自执行函数。 原理。。。。。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;81、js中callee和caller的作用&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;写法不同：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;callee&lt;span&gt;是&lt;span&gt;Arguments&lt;span&gt;的一个属性，在函数中使用&lt;span&gt;Arguments.callee&lt;span&gt;调用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;C&lt;span&gt;aller&lt;span&gt;在函数中，直接使用函数名调用。  F&lt;span&gt;unc.&lt;span&gt; C&lt;span&gt;aller&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;功能不同：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Arguments.callee &lt;span&gt;返回的是，&lt;span&gt;当前函数自身的引用！！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;F&lt;span&gt;unc.&lt;span&gt; C&lt;span&gt;aller &lt;span&gt;返回的是&lt;span&gt;，当前函数在哪个函数中调用。 &lt;span&gt;&lt;span&gt;如果函数时顶层调用，则返回&lt;span&gt;null&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;function func(){&lt;/p&gt;
&lt;p&gt;console.log(func.caller);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;func(); // null&lt;/p&gt;
&lt;p&gt;function func1(){&lt;/p&gt;
&lt;p&gt;func();&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;func1(); // &lt;span&gt;返回&lt;span&gt;func1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;82、js中的保留字是什么？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;程序中&lt;span&gt;预定义的关键字&lt;span&gt;(&lt;span&gt;函数名、类名、属性名、方法名等标识符&lt;span&gt;)&lt;span&gt;都是&lt;span&gt;js&lt;span&gt;中的保留字。 这些保留字，不允许用户再次声明为变量、方法、函数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;保留字在编译器中会变色。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;83、工厂方式创建js对象是啥方式 （JS中创建对象的多种方式）&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt; ① 字面量模式： &lt;span&gt;var obj = {}&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110183259466-1894034820.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110183325903-1969404552.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110183349169-1324536019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;混合模式就是我们所说的将属性添加到成员属性&lt;span&gt;(&lt;span&gt;构造函数模式&lt;span&gt;)&lt;span&gt;，将方法添加到原型方法（原型模式）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110183411216-1590117069.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;84、js延迟加载的方式有哪些？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;+&lt;span&gt;将&lt;span&gt;JS&lt;span&gt;代码放在文档最后也是延迟加载的方式之一。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;85、documen.write和 innerHTML 的区别？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;documen.write &lt;span&gt;是直接在整个文档中，写入代码。会覆盖掉其他已有代码。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;innerHTML &lt;span&gt;是选中一个节点后，修改节点里面的代码，只影响当前节点。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;86、解释jsonp的原理，以及为什么不是真正的ajax&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;后续讲解&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;87、javascript 中的垃圾回收机制？闭包中的内存释放？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Js&lt;span&gt;中的垃圾回收机制，函数中的变量，会在函数执行完成后，被回收处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，如果函数中使用了闭包，那么函数中的变量将始终被内部的函数持有，而不会在函数执行完成后释放。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;闭包的两个重要作用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① 可以让函数外部，能够访问函数内部的变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② 让函数内部的变量在函数执行完成后，不会被释放，而始终保持在内存中&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;88、哪些操作会造成内存泄漏&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;大量使用全局变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大量使用闭包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;清除DOM&lt;span&gt;节点时，只清除节点，而没有删除事件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;



&lt;hr/&gt;&lt;p&gt;&lt;span&gt;89、js中的精度问题&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;JS&lt;span&gt;中在浮点数运算或者大整数运算的时候，可能导致不准确的结果出现。 &lt;span&gt;&lt;span&gt;例如&lt;span&gt;0.7+0.1=0.7999999999999 &lt;span&gt;解决办法可以将数字&lt;span&gt;*10&lt;span&gt;相加，然后再除以&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;90、简述defer和async的区别&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1&lt;span&gt;.&lt;span&gt;默认引用 &lt;span&gt;script:&lt;span&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;x.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当浏览器遇到 &lt;span&gt;script &lt;span&gt;标签时，&lt;span&gt;文档的解析将停止，并立即下载并执行脚本&lt;span&gt;，脚本执行完毕后将继续解析文档。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2&lt;span&gt;.async&lt;span&gt;模式&lt;span&gt; &amp;lt;script &lt;span&gt;type=&quot;text/javascript&quot; src=&quot;x.min.js&quot; async=&quot;async&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当浏览器遇到 &lt;span&gt;script &lt;span&gt;标签时，文档的&lt;span&gt;解析不会停止&lt;span&gt;，&lt;span&gt;其他线程将下载脚本，脚本下载完成后开始执行脚本&lt;span&gt;，脚本执行的过程中文档将停止解析，直到脚本执行完毕。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3&lt;span&gt;.defer&lt;span&gt;模式&lt;span&gt; &amp;lt;script &lt;span&gt;type=&quot;text/javascript&quot; src=&quot;x.min.js&quot; defer=&quot;defer&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当浏览器遇到 &lt;span&gt;script &lt;span&gt;标签时，文档的解析不会停止，其他线程将下载脚本，&lt;span&gt;待到文档解析完成，脚本才会执行&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110183507981-1079945671.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;91、业界常用的优化WEB页面加载速度的方法（可以分别从页面元素展现，请求连接，css,js,服务器等方面介绍）&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;92、解释什么是sql注入，xss漏洞？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;93、解释下这个css选择器发生什么？   [role=nav]&amp;gt;ul a:not([href^=mailto]){}&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;[role=nav] &lt;span&gt;选中页面中&lt;span&gt; role&lt;span&gt;属性等于&lt;span&gt;nav&lt;span&gt;的元素&lt;span&gt;. &lt;span&gt;也就是导航栏&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[role=nav]&amp;gt;ul &lt;span&gt;导航栏中的子节点&lt;span&gt; ul&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[role=nav]&amp;gt;ul a  UL&lt;span&gt;里面的&lt;span&gt;a&lt;span&gt;标签&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;a:not([href^=mailto]) &lt;span&gt;选中a&lt;span&gt;标签，除了href&lt;span&gt;属性使用&lt;span&gt;mailto&lt;span&gt;开头的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选中导航栏中的&lt;span&gt;ul&lt;span&gt;里面的不是&lt;span&gt;mailto&lt;span&gt;的&lt;span&gt;a&lt;span&gt;标签。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;94、有这样一个URL：http://item.taobao.com/item.htm?a=1&amp;amp;b=2&amp;amp;c= e &amp;amp;d=xxx，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:’1′,?b:’2′,?c:”,?d:’xxx’,?e:undefined}。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110183621794-706138375.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;95、以下哪个单词不属于javascript保留字   B&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;A.with&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;B.parent&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C.class&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;D.void&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;96、 动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;97、 按需异步载入js&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;99、简单的介绍下JS面向对象中的__proto__与prototype&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1、prototype:函数的原型对象&lt;/p&gt;
&lt;p&gt;① 只有函数才有prototype，而且所有的函数必然有prototype!&lt;/p&gt;
&lt;p&gt;② prototype本身也是一个对象！&lt;/p&gt;
&lt;p&gt;③ prototype指向了当前函数所在的引用地址！&lt;/p&gt;
&lt;p&gt;2、__proto__：对象的原型&lt;/p&gt;
&lt;p&gt;① 只有对象才有__proto__，而且所有的对象必有__proto__；&lt;/p&gt;
&lt;p&gt;② __proto__也是一个对象，所以也有自己的__proto__，顺着这条线向上找的顺序，就是原型链。&lt;/p&gt;
&lt;p&gt;③ 数组都是对象，也都有自己的__proto__；&lt;/p&gt;
&lt;p&gt;3、实例化一个类，拿到对象的原理：&lt;/p&gt;
&lt;p&gt;实例化一个类的时候，实际上是将新对象的__proto__，指向构造函数所在的prototype；&lt;/p&gt;
&lt;p&gt;也就是说：zhangsan.__proto__ ==Person.prototype √&lt;/p&gt;
&lt;p&gt;4、所有对象的__proto__沿着原型链向上查找都将指向Object的prototype;&lt;/p&gt;
&lt;p&gt;Object的prototype的原型，指向null；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;100、简述下什么是CSShack以及其表现形式有哪些？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;CSS hack由于不同厂商的&lt;span&gt;浏览器，比如Internet Explorer,Safari,&lt;span&gt;Mozilla Firefox,Chrome等，或者是同一厂商的浏览器的不同版本，如IE6和IE7，对CSS的解析认识不完全一样，因此会导致生成的页面效果不一样，得不到我们所需要的页面效果。 这个时候我们就需要针对不同的浏览器去写不同的CSS，让它能够同时兼容不同的浏览器，能在不同的浏览器中也能得到我们想要的页面效果。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;简单的来说：&lt;/p&gt;
&lt;p&gt;CSS hack的目的就是使你的CSS代码兼容不同的浏览器。&lt;/p&gt;
&lt;p&gt;表现形式：&lt;/p&gt;
&lt;p&gt;（1）方式一 条件注释法&lt;/p&gt;
&lt;p&gt;（2）方式二 类内属性前缀法&lt;/p&gt;
&lt;p&gt;（3）CSS hack方式三：选择器前缀法&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;101、Require.js有什么作用？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1、实现了文件的异步加载，避免网页失去响应。&lt;/p&gt;
&lt;p&gt;2、管理模块之间的依赖性，便于代码的编写和维护。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;102、怎么检测一个对象是不是一个类的实例？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;instanceof：A instanceof B 检测一个对象(A)是不是一个类(B)的一个实例；&lt;/p&gt;
&lt;p&gt;louver instanceof Person;√ louver是函数Person的实例化；&lt;/p&gt;
&lt;p&gt;louver instanceof Object;√ 所有对象都是Object的一个实例；&lt;/p&gt;
&lt;p&gt;Person instanceof Object;√ 函数本身也是一个对象；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;constructor：返回当前对象的构造函数；&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;103、zepto和jQuery的不同之处有哪些？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1、zepto不支持IE浏览器；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、zepto增加了一些基本的触摸事件：如tap，swip事件’&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、DOM操作的区别：添加ID时jQuery不会生效，而zepto会生效！&lt;/p&gt;
&lt;p&gt;4、使用zepto时，load事件的处理函数会执行，使用jQuery时，load事件的处理函数不会执行。&lt;/p&gt;
&lt;p&gt;5、事件委派的不同：&lt;/p&gt;
&lt;p&gt;在zepto中，当a被点击之后，一次性弹出内容为a事件和b事件，但是在jQuery中只会触发委托弹出a事件，再点击一次才会触发b事件！&lt;/p&gt;
&lt;p&gt;6、offse:zepto：返回left top width heigth&lt;/p&gt;
&lt;p&gt;jQuery:只会返回left top&lt;/p&gt;

&lt;p&gt;&lt;span&gt;7、zepto无法隐藏元素的宽高，jQuery可以；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8、zepto不支持的选择器：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① 基本伪类：first last eq(index)&lt;/p&gt;
&lt;p&gt;② 内容伪类：contains(text) :empty :has(selector)&lt;/p&gt;
&lt;p&gt;③ 可见性伪类：hidden visible&lt;/p&gt;
&lt;p&gt;④ 属性选择器：[attribute = value]&lt;/p&gt;
&lt;p&gt;⑤ 表单伪类：input :text :password :submit&lt;/p&gt;
&lt;p&gt;⑥ 表单对象属性：selected&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;104、使用JS跳转页面的方法：&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Window.location=&quot;http://www.baidu.com&quot;;&lt;/p&gt;
&lt;p&gt;细分几种使用location跳转页面的类型：&lt;/p&gt;
&lt;p&gt;location.replace(&quot;http://www.baidu.com&quot;); 使用新的文档替换当前文档，替换以后，不能退回。&lt;/p&gt;
&lt;p&gt;location.assign(&quot;http://www.baidu.com&quot;);加载新的文档，加载之后，可以退回。&lt;/p&gt;
&lt;p&gt;location.repload();重新加载当前页面，即刷新页面；&lt;/p&gt;
&lt;p&gt;①、 location.repload(true) 强制刷新页面，从服务器端重新加载页面----Ctrl+f5;&lt;/p&gt;
&lt;p&gt;②、 location.repload() 在本地刷新当前页面---f5&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;105、一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;图片懒加载&lt;span&gt;，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果图片为&lt;span&gt;css图片，可以使用&lt;span&gt;CSSsprite&lt;span&gt;，&lt;span&gt;SVGsprite&lt;span&gt;，&lt;span&gt;Iconfont&lt;span&gt;、&lt;span&gt;Base64&lt;span&gt;等技术。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更换最新的图片格式&lt;span&gt; &lt;span&gt;谷歌的&lt;span&gt;webp腾讯的tpg&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;合成雪碧图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大图分割加载&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;106、CSS3新增伪类有那些？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt; p:first-of-type 选择属于其父元素的首个 &amp;lt;p&amp;gt; 元素的每个 &amp;lt;p&amp;gt; 元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    p:last-of-type  选择属于其父元素的最后 &amp;lt;p&amp;gt; 元素的每个 &amp;lt;p&amp;gt; 元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    p:only-of-type  选择属于其父元素唯一的 &amp;lt;p&amp;gt; 元素的每个 &amp;lt;p&amp;gt; 元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    p:only-child    选择属于其父元素的唯一子元素的每个 &amp;lt;p&amp;gt; 元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &amp;lt;p&amp;gt; 元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    :enabled、:disabled 控制表单控件的禁用状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;:checked，单选框或复选框被选中。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;107、如何在 HTML5 页面中嵌入音频、视频?&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;HTML 5 包含嵌入音频文件的标准方式，支持的格式包括 MP3、Wav 和 Ogg：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;audio controls&amp;gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &amp;lt;source src=&quot;jamshed.mp3&quot; type=&quot;audio/mpeg&quot;&amp;gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   Your browser does'nt support audio embedding feature. &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;/audio&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;和音频一样，&lt;span&gt;HTML5 定义了嵌入视频的标准方法，支持的格式包括：MP4、WebM 和 Ogg：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;video width=&quot;500px&quot; height=&quot;500px&quot; autoplay=&quot;autoplay&quot; loop=&quot;loop&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;source src=&quot;binzhiliang1.mp4&quot; type=&quot;video/mp4&quot; &amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Your browser does'nt support video embedding feature. &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;/source&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;/video&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;108、怎么取到一个网址并转化为字符串格式存储？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;console.log(location.href);//返回当前完整路径；&lt;/p&gt;
&lt;p&gt;/*将js中的对象、数组，转化*/&lt;/p&gt;
&lt;p&gt;var str1 = JSON.stringify(jsonObj);&lt;/p&gt;
&lt;p&gt;console.log(str1);&lt;/p&gt;
&lt;p&gt;var obj = JSON.parse(str1);&lt;/p&gt;
&lt;p&gt;console.log(obj);&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;109、如何优化网页加载速度？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;   1.减少css，js文件数量及大小(减少重复性代码，代码重复利用)，压缩CSS和Js代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   2.图片的大小&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   3.把css样式表放置顶部，把js放置页面底部&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   4.减少http请求数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   5.使用外部 Js 和 CSS&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;110、知道css有个content属性吗？有什么作用？有什么应用？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;知道。&lt;span&gt;css的content属性专门应用在 before/after 伪元素上，用来插入生成内容。最常见的应用是利用伪类清除浮动。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;//一种常见利用伪类清除浮动的代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.clearfix:after {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    content:&quot;.&quot;; //这里利用到了content属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    display:block;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    height:0;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    visibility:hidden;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    clear:both; }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.clearfix {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    *zoom:1;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;after伪元素通过 content 在元素的后面生成了内容为一个点的块级素，再利用clear:both清除浮动。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;111、简述下web storage和cookie的区别&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1、&lt;span&gt;Web Storage&lt;span&gt;相对于&lt;span&gt;cookie&lt;span&gt;来说，拥有更大的容量储存。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、Cookie&lt;span&gt;的大小是受限的，并且每次你请求一个新的页面的时候&lt;span&gt;Cookie&lt;span&gt;都会被发送过去，这样无形 中浪费了带宽。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、&lt;span&gt;cookie&lt;span&gt;还需要指定作用域，不可以跨域调用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、&lt;span&gt;Web Storage&lt;span&gt;拥有&lt;span&gt;setItem,getItem,removeItem,clear&lt;span&gt;等方法，不像&lt;span&gt;cookie&lt;span&gt;需要前端开发者自己封装&lt;span&gt;setCookie&lt;span&gt;，&lt;span&gt;getCookie&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、但是&lt;span&gt;Cookie&lt;span&gt;也是不可以或缺的：&lt;span&gt;Cookie&lt;span&gt;的作用是与服务器进行交互，作为&lt;span&gt;HTTP&lt;span&gt;规范的一部分而存在&lt;span&gt; ，而Web Storage&lt;span&gt;仅仅是为了在本地&lt;span&gt;“&lt;span&gt;存储&lt;span&gt;”&lt;span&gt;数据而生。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;112、为什么利用多个域名来存储网站资源会更有效？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;CDN&lt;span&gt;缓存更方便&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;突破浏览器并发限制&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;节约&lt;span&gt;cookie带宽 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;节约主域名的连接数，优化页面响应速度&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;防止不必要的安全问题&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;113、HTML5 Canvas 元素有什么用？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;答：&lt;span&gt;Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在 HTML 上进行图形操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;115、请用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; iArray =&lt;span&gt; [];
funtion getRandom(istart, iend){
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; iChoice = istart - iend +1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Math.floor(Math.random() * iChoice +&lt;span&gt; istart;
}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0; i&amp;lt;10; i++&lt;span&gt;){
iArray.push(getRandom(&lt;/span&gt;10,100&lt;span&gt;));
}
iArray.sort();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;116、如何消除一个数组里面重复的元素？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;方法一：
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr=[1,2,3,3,4,4,5,5,6,1,9,3,25,4&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; deRepeat(){
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newArr=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj=&lt;span&gt;{};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; index=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; l=&lt;span&gt;arr.length;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;l;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(obj[arr[i]]==&lt;span&gt;undefined){
obj[arr[i]]&lt;/span&gt;=1&lt;span&gt;;
newArr[index&lt;/span&gt;++]=&lt;span&gt;arr[i];
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(obj[arr[i]]==1&lt;span&gt;)
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; newArr;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newArr2=&lt;span&gt;deRepeat(arr);
alert(newArr2); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出1,2,3,4,5,6,9,25&lt;/span&gt;
&lt;span&gt;方法二：
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr = [1,2,2,3,3,3,4,5,6&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; func (arr){
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newArr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array;
newArr.push(arr[&lt;/span&gt;0&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;=arr.length;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newArr.indexOf(arr[i])==-1&lt;span&gt;) {
newArr.push(arr[i]);
}
}
document.write(newArr);
}
func(arr);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;117、闭包：下面这个ul，如何点击每一列的时候alert其index？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;ul id=&quot;test&quot;&amp;gt;
&amp;lt;li&amp;gt;这是第一条&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;这是第二条&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;这是第三条&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;span&gt;非闭包实现
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lis=document.querySelectorAll('li'&lt;span&gt;);
document.querySelector(&lt;/span&gt;'#test').onclick=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; lis.length; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; li =&lt;span&gt; lis[i];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(li==&lt;span&gt;e.target){
            alert(i);
        }
    }
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;闭包实现&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; lis=document.querySelectorAll('li'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; lis.length; i++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; li =&lt;span&gt; lis[i];
    li.onclick&lt;/span&gt;=(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(index){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
            alert(index);
        };
    })(i);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;118、JavaScript数组元素添加、删除、排序等方法有哪些？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;Array.concat( ) &lt;span&gt;连接数组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.join( ) &lt;span&gt;将数组元素连接起来以构建一个字符串&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.length &lt;span&gt;数组的大小&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.pop( ) &lt;span&gt;删除并返回数组的最后一个元素&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.push( ) &lt;span&gt;给数组添加元素&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.reverse( ) &lt;span&gt;颠倒数组中元素的顺序&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.shift( ) &lt;span&gt;将元素移出数组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.slice( ) &lt;span&gt;返回数组的一部分&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.sort( ) &lt;span&gt;对数组元素进行排序&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.splice( ) &lt;span&gt;插入、删除或替换数组的元素&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.toLocaleString( ) &lt;span&gt;把数组转换成局部字符串&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.toString( ) &lt;span&gt;将数组转换成一个字符串&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;119、简述remove和detach异同&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;* 1、相同点：&lt;/p&gt;
&lt;p&gt;* ① 都会把当前标签，以及当前标签的所有子节点，全部删除；&lt;/p&gt;
&lt;p&gt;* ② 都可以在删除时，把当前节点返回。并可以使用变量接受返回的节点，以便后期恢复；&lt;/p&gt;
&lt;p&gt;* 2、 不同点：&lt;/p&gt;
&lt;p&gt;* 使用接受的节点，恢复原节点时。&lt;/p&gt;
&lt;p&gt;* remove只能恢复节点的内容，但是事件绑定，不能再恢复；&lt;/p&gt;
&lt;p&gt;* detach不但恢复节点的内容，还能再恢复 事件的绑定；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;120、Ajax 是什么? 如何创建一个Ajax？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;Ajax并不算是一种新的技术，全称是asynchronous javascript and xml，可以说是已有技术的组合，主要用来&lt;span&gt;实现客户端与服务器端的异步通信效果，实现页面的局部刷新&lt;span&gt;，&lt;span&gt;带来更好的用户体验；按需获取数据，节约带宽资源；&lt;span&gt;早期的浏览器并不能原生支持ajax，可以使用隐藏帧（iframe）方式变相实现异步效果，后来的浏览器提供了对ajax的原生支持&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用&lt;span&gt;ajax原生方式发送请求主要通过XMLHttpRequest(标准浏览器)、ActiveXObject(IE浏览器)对象实现异步通信效果&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;121、举例简述同步和异步的区别?&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;同步：阻塞的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-张三叫李四去吃饭，李四一直忙得不停，张三一直等着，直到李四忙完两个人一块去吃饭&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;=浏览器向服务器请求数据，服务器比较忙，浏览器一直等着（页面白屏），直到服务器返回数据，浏览器才能显示页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;异步：非阻塞的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-张三叫李四去吃饭，李四在忙，张三说了一声然后自己就去吃饭了，李四忙完后自己去吃&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;=浏览器向服务器请求数据，服务器比较忙，浏览器可以自如的干原来的事情（显示页面），服务器返回数据的时候通知浏览器一声，浏览器把返回的数据再渲染到页面，局部更新&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;122、如何解决跨域问题?&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;理解跨域的概念：&lt;span&gt;协议&lt;span&gt;、&lt;span&gt;域名&lt;span&gt;、&lt;span&gt;端口&lt;span&gt;都相同才同域，否则都是跨域&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出于安全考虑，服务器不允许&lt;span&gt;ajax跨域获取数据，但是可以跨域获取文件内容，所以基于这一点，可以动态创建script标签，使用标签的src属性访问js文件的形式获取js脚本，并且这个js脚本中的内容是&lt;span&gt;函数调用&lt;span&gt;，该函数调用的参数是服务器返回的数据，为了获取这里的参数数据，需要事先在页面中定义回调函数，在回调函数中处理服务器返回的数据，这就是解决跨域问题的主流解决方案&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;123、页面编码和被请求的资源编码如果不一致如何处理？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;对于&lt;span&gt;ajax请求传递的参数，如果是get请求方式，参数如果传递中文，在有些浏览器会乱码，不同的浏览器对参数编码的处理方式不同，所以对于get请求的参数需要使用 &lt;span&gt;encodeURIComponent&lt;span&gt;函数对参数进行编码处理，后台开发语言都有相应的解码&lt;span&gt;api。对于post请求不需要进行编码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;124、简述ajax 的过程。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1. 创建XMLHttpRequest对象,也就是创建一个异步调用对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 设置响应HTTP请求状态变化的函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 发送HTTP请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. 获取异步调用返回的数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6. 使用JavaScript和DOM实现局部刷新&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写法如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$.ajax() 通过 HTTP 请求加载远程数据。jQuery 最底层 AJAX 实现函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接受一个大的对象。对象里面的属性和方法，表示ajax请求的相关设置：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① url:被请求的远程文件的路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② Ajax请求的类型，可选值get/post.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回调函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;•success： 请求成功的回调函数。接受一个参数data，表示后台返回的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;•dataType：预期服务器返回的数据类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;json&quot;: 返回 JSON 数据 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;text&quot;: 返回纯文本字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;•data：对象格式。向后台发送一个对象，表示传递的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常用于type为post的请求方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果type为get,可以使用？直接追加载URL后面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;•error:请求失败时的回调函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;•statusCode:接受一个对象，对象的键值对是status状态码和对应的回调函数，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表示当请求状态码是对应数字时，执行具体的操作函数.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;404 - 页面没有找到！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;403 - 服务器收到请求，但是拒绝提供服务！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;200 - 请求成功！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;500 - 内部服务器错误！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;503 - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;301 - 资源（网页等）被永久转移到其它URL！&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;125、阐述一下异步加载。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1. 异步加载的方案： 动态插入 script 标签&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 通过 ajax 去获取 js 代码，然后通过 eval 执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. script 标签上添加 defer 或者 async 属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 创建并插入 iframe，让它异步执行 js&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;126、请解释一下 JavaScript 的同源策略。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;所谓同源指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在前后台进行数据交互时，两个文件必须处于同一域名同一端口号同一协议名之下，否则跨域请求&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;127、ajax的缺点&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt; 1、ajax不支持浏览器back按钮。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2、安全问题 AJAX暴露了与服务器交互的细节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3、对搜索引擎的支持比较弱。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 4、破坏了程序的异常机制。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;128、解释jsonp的原理，以及为什么不是真正的ajax&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;　　&lt;span&gt;Jsonp并不是一种数据格式，而json是一种数据格式，&lt;span&gt;jsonp是用来解决跨域获取数据的一种解决方案&lt;span&gt;，具体是通过&lt;span&gt;动态创建&lt;span&gt;script标签，&lt;span&gt;然后通过标签的&lt;span&gt;src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好&lt;span&gt;回调函数，本质上使用的并不是&lt;span&gt;ajax技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;129、什么是Ajax和JSON，它们的优缺点。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;Ajax是全称是asynchronous JavaScript andXML，即异步JavaScript和xml，&lt;span&gt;用于在Web页面中实现异步数据交互，实现页面局部刷新。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优点：可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量，避免用户不断刷新或者跳转页面，提高用户体验&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点：对搜索引擎不友好；要实现&lt;span&gt;ajax下的前后退功能成本较大；可能造成请求数据的增加跨域问题限制；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JSON是一种轻量级的数据交换格式&lt;span&gt;，ECMA的一个子集&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优点：轻量级、易于人的阅读和编写，便于机器（&lt;span&gt;JavaScript）解析，支持复合数据类型（数组、对象、字符串、数字）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;130、分别介绍下javascript的本地对象，内置对象和宿主对象&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;本地对象为独立于宿主环境的&lt;span&gt;ECMAScript提供的对象，包括Array Object RegExp等&lt;span&gt;可以new实例化&lt;span&gt;的对象&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内置对象为&lt;span&gt;Gload&lt;span&gt;，&lt;span&gt;Math 等&lt;span&gt;不可以实例化&lt;span&gt;的(他们也是本地对象，内置对象是本地对象的一个子集)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;宿主对象为所有的非本地对象，所有的&lt;span&gt;BOM和DOM对象都是宿主对象，如&lt;span&gt;浏览器自带的&lt;span&gt;document,window 等&lt;span&gt;对象。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图解：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110183900513-278896728.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;131、为什么利用多个域名来存储网站资源会更有效？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1、速度保证：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;确保用户在不同地区能用最快的速度打开网站。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、安全保障：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中某个域名崩溃用户也能通过其他域名问网站，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、服务端：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;并且不同的资源放到不同的服务器上有利于减轻单台服务器的压力。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;132、请说出三种减低页面加载时间的方法&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1、压缩css、js文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、合并js、css文件，减少http请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、外部js、css文件放在最底下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、减少dom操作，尽可能用变量替代不必要的dom操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、优化图片加载的方式。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;133、 知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么?&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;Webkit是浏览器引擎，包括html渲染和js解析功能，手机浏览器的主流内核，与之相对应的引擎有Gecko（Mozilla Firefox 等使用）和Trident（也称MSHTML，IE 使用）。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于浏览器的调试工具要熟练使用，主要是页面结构分析，后台请求信息查看，&lt;span&gt;js调试工具使用，熟练使用这些工具可以快速提高解决问题的效率.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110183934247-249314736.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;1、Elements 功能标签页：用来查看，修改页面上的元素，包括DOM标签，以及css样式的查看，修改，还有相关盒模型的图形信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、Console控制台：用于打印和输出相关的命令信息，常用于JS错误调试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、Sources js资源页面：这个页面内我们可以找到当然浏览器页面中的js 源文件，方便我们查看和调试(打断点调试)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、.Network 网络请求标签页：可以看到所有的资源请求，包括网络请求，图片资源，html,css，js文件等请求，可以根据需求筛选请求项，一般多用于网络请求的查看和分析，分析后端接口是否正确传输，获取的数据是否准确，请求头，请求参数的查看&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、.Timeline标签页可以显示JS执行时间、页面元素渲染时间，不做过多介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、.Profiles标签页可以查看CPU执行时间与内存占用，不做过多介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7、.Resources标签页会列出所有的资源，以及HTML5的Database和LocalStore等，你可以对存储的内容编辑和删除 不做过多介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8、.Security标签页 可以告诉你这个网站的安全性，查看有效的证书等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9、.Audits标签页 可以帮你分析页面性能，有助于优化前端页面，分析后得到的报告&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;134、简述一下 Handlebars 的基本用法？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Handlebars 是 JavaScript 一个语义模板库，通过对view和data的分离来快速构建Web模板。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;135、详解在AngualrJS中使用$http进行数据请求的方法？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$http({
method: &lt;/span&gt;'GET', &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;请求的方法&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
url: &lt;/span&gt;'h51701.json' &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;请求的地址&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj){
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;请求成功的回调函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
alert(&lt;/span&gt;&quot;请求成功！&quot;&lt;span&gt;);
$scope.data &lt;/span&gt;=&lt;span&gt; obj.data;
},&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;请求失败的回调函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
alert(&lt;/span&gt;&quot;请求失败！&quot;&lt;span&gt;);
});
[简写方式]
可以直接简写为get或者post方式：
$http.get(&lt;/span&gt;'/someUrl'&lt;span&gt;).then(successCallback, errorCallback);
$http.post(&lt;/span&gt;'/someUrl', data).then(successCallback, errorCallback);
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;136、如何让一个标签块级显示？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1、给该元素添加浮动属性&lt;/p&gt;
&lt;p&gt;2、给该元素添加绝对定位属性&lt;/p&gt;
&lt;p&gt;3、 给父元素添加display:flex属性设置为弹性盒子（弹性盒子内部全是块级标签）&lt;/p&gt;
&lt;p&gt;4、给其本身添加display:block/ inlineblock属性&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;137、利用原生JS实现Ajax请求后台数据的步骤？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一步： 获得XMLHttpRequest对象&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; ajax = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二步： 设置状态监听函数&lt;/span&gt;
ajax.onreadystatechange = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
console.log(ajax.readyState);
console.log(ajax.status);
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第五步：在监听函数中，判断readyState=4 &amp;amp;&amp;amp; status=200表示请求成功&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;(ajax.readyState==4 &amp;amp;&amp;amp; ajax.status==200&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第六步： 使用responseText、responseXML接受响应数据，并使用原生JS操作DOM进行显示&lt;/span&gt;
&lt;span&gt;console.log(ajax.responseText);
console.log(ajax.responseXML);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回不是XML，显示null&lt;/span&gt;
&lt;span&gt;console.log(JSON.parse(ajax.responseText));
console.log(eval(&lt;/span&gt;&quot;(&quot;+ajax.responseText+&quot;)&quot;&lt;span&gt;));
}
}
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三步： open一个链接&lt;/span&gt;
ajax.open(&quot;GET&quot;,&quot;h51701.json&quot;,&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true异步请求，false同步&lt;/span&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第四步： send一个请求。 可以发送对象和字符串，不需要传递数据发送null&lt;/span&gt;
ajax.send(&lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;138、实现Ajax的跨域请求有哪些方法？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;【跨域请求处理】&lt;/p&gt;
&lt;p&gt;由于JS中存在同源策略，当请求不同协议名，不同端口号，不同主机名下面的文件时，将会违背同源策略，无法请求成功！需要进行跨域处理！&lt;/p&gt;
&lt;p&gt;1、后台PHP进行设置，在后台请求的PHP文件中，写入一条header:&lt;/p&gt;
&lt;p&gt;header( &quot;Access-Control-Allow-Origin:*&quot;);&lt;/p&gt;
&lt;p&gt;表示允许哪些域名请求这个PHP文件，*表示所有的域名都允许。&lt;/p&gt;
&lt;p&gt;2、使用src属性+JSONP实现跨域&lt;/p&gt;
&lt;p&gt;① 拥有src属性的标签自带跨域功能，所以可以使用&amp;lt;script&amp;gt;标签的src属性请求后台属性。&lt;/p&gt;
&lt;p&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://127.0.0.1/json.php&quot;&amp;gt; &amp;lt;/ script&amp;gt;&lt;/p&gt;
&lt;p&gt;② 由于src在加载数据成功之后，会直接将加载内容放入到script标签中，&lt;/p&gt;
&lt;p&gt;所以后台直接返回JSON字符串将不能在script标签中解析。&lt;/p&gt;
&lt;p&gt;因此，后台应该返回给前台一个回调函数名，并将JSON字符串作为参数传入，&lt;/p&gt;
&lt;p&gt;后台PHP文件中返回 ： echo &quot;callBack($str)&quot;;&lt;/p&gt;
&lt;p&gt;③ 前台接收到返回的回调函数，将直接在script标签中调用。因此需要声明这样的一个回调函数，作为请求成功的回调函数。&lt;/p&gt;
&lt;p&gt;* function callBack(data) {&lt;/p&gt;
&lt;p&gt;alert(&quot;请求成功！&quot;);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;3、jQuery的Ajax实现JSONP&lt;/p&gt;
&lt;p&gt;① 在Ajax请求时设置dataType:&quot;jsonp&quot;&lt;/p&gt;
&lt;p&gt;② 后台返回时，依然需要返回回调函数，但是，在ajax发送请求时，会默认使用get请求将回调函数名发给后台，&lt;/p&gt;
&lt;p&gt;后台可以使用$_GET['callback']取出回到函数名。&lt;/p&gt;
&lt;p&gt;echo &quot;{$_GET['callback']}({$str})&quot;;&lt;/p&gt;
&lt;p&gt;③ 后台返回之后，Ajax依然可以使用succes作为成功的回调函数：&lt;/p&gt;
&lt;p&gt;success:function(data){&lt;/p&gt;
&lt;p&gt;console.log(data);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;当然后台也可以随便返回一个回调函数名： echo &quot;callBack($json)&quot;;&lt;/p&gt;
&lt;p&gt;前台只要请求成功就会自动调用这个函数。类似于上面的第2条的② ③ 步；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;139、js中捕获异常是啥？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;Js中的异常捕获用&lt;span&gt;try{}catch(){} &lt;span&gt;结构进行捕获&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将程序中可能出现异常错误的代码，用&lt;span&gt;try块包裹&lt;span&gt;，当代码真正出现异常时，程序流将进入&lt;span&gt;carch块捕获异常&lt;span&gt;，&lt;span&gt;try块中从异常语句开始下面的代码将不再执行&lt;span&gt;，转而执行&lt;span&gt;catch&lt;span&gt;块中的代码！！！！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JS&lt;span&gt;中常见的异常类型： &lt;span&gt;   &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
EvalError: raised when an error occurs executing code &lt;span&gt;in&lt;/span&gt;&lt;span&gt; eval()
RangeError: raised when a numeric variable or parameter is outside of its valid range
ReferenceError: raised when de&lt;/span&gt;-&lt;span&gt;referencing an invalid reference
SyntaxError: raised when a syntax error occurs &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; parsing code &lt;span&gt;in&lt;/span&gt;&lt;span&gt; eval()
TypeError: raised when a variable or parameter is not a valid type
URIError: raised when encodeURI() or decodeURI() are passed invalid parameters   &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  &lt;span&gt;所有异常都继承自Error&lt;span&gt;类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用户可以自定义异常： &lt;span&gt;throw new Error() ;  &lt;span&gt; throw new TypeError(&lt;span&gt;“错误信息”&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Catch&lt;span&gt;块的小括号中可以接受异常对象&lt;span&gt;e, e.name&lt;span&gt;表示错误名，e.message&lt;span&gt;表示错误信息。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;140、事件委派的原理是啥？事件冒泡吗？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;事件委派的原理就是事件冒泡！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当你点击一个元素时，这个点击事件是会冒泡的，事件依次从该元素向父级元素依次触发，事件委托就是在&lt;span&gt;父级元素上统一监听和处理事件，&lt;span&gt;而不是在具体的元素上，然后通过判断事件源来确定是哪个元素触发的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样做的好处是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们不需要为每个元素添加事件，更节省资源；并且后来新增的元素直接可以同样获得事件，不需要再为其添加监听。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;141、前端代码优化的方法？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;








&lt;hr/&gt;&lt;p&gt;&lt;span&gt;142、详细解释一下关于伪数组与数组？（在Javascript中什么是伪数组？如何将伪数组转化为标准数组？）&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;伪数组：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具有&lt;span&gt;length属性；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按索引方式存储数据；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不具有数组的&lt;span&gt;push()、pop()等方法；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;var fakeArray01 = {0:'a',1:'b',length:2};//这是一个标准的伪数组对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;var arr01 = Array.prototype.slice.call(fakeArray01);&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;143、Javascript作用域链?&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;函数作用域的嵌套就组成了所谓的函数作用域链&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;144、什么是JSOPN？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;jsonp：JSON with padding，是JSON的 一种“&lt;span&gt;使用模式”，可用于解决主流浏览器的跨域数据访问的问题。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;145、如何利用Ajxa实现跨域请求？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;由于JS中存在同源策略，当请求不同协议名，不同端口号，不同主机名下面的文件时，将会违背同源策略，无法请求成功！需要进行跨域处理！&lt;/p&gt;
&lt;p&gt;1、后台PHP进行设置，在后台请求的PHP文件中，写入一条header:&lt;/p&gt;
&lt;p&gt;header( &quot;Access-Control-Allow-Origin:*&quot;);&lt;/p&gt;
&lt;p&gt;表示允许哪些域名请求这个PHP文件，*表示所有的域名都允许。&lt;/p&gt;
&lt;p&gt;2、使用src属性+JSONP实现跨域&lt;/p&gt;
&lt;p&gt;① 拥有src属性的标签自带跨域功能，所以可以使用&amp;lt;script&amp;gt;标签的src属性请求后台属性。&lt;/p&gt;
&lt;p&gt;* &amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://127.0.0.1/json.php&quot;&amp;gt; &amp;lt;/ script&amp;gt;&lt;/p&gt;
&lt;p&gt;② 由于src在加载数据成功之后，会直接将加载内容放入到script标签中，&lt;/p&gt;
&lt;p&gt;* 所以后台直接返回JSON字符串将不能在script标签中解析。&lt;/p&gt;
&lt;p&gt;* 因此，后台应该返回给前台一个回调函数名，并将JSON字符串作为参数传入，&lt;/p&gt;
&lt;p&gt;后台PHP文件中返回 ： echo &quot;callBack($str)&quot;;&lt;/p&gt;
&lt;p&gt;③ 前台接收到返回的回调函数，将直接在script标签中调用。因此需要声明这样的一个回调函数，作为请求成功的回调函数。&lt;/p&gt;
&lt;p&gt;* function callBack(data) {&lt;/p&gt;
&lt;p&gt;alert(&quot;请求成功！&quot;);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;3、利用jQuery的Ajax实现JSONP&lt;/p&gt;
&lt;p&gt;① 在Ajax请求时设置dataType:&quot;jsonp&quot;&lt;/p&gt;
&lt;p&gt;② 后台返回时，依然需要返回回调函数，但是，在ajax发送请求时，会默认使用get请求将回调函数名发给后台，&lt;/p&gt;
&lt;p&gt;后台可以使用$_GET['callback']取出回到函数名。&lt;/p&gt;
&lt;p&gt;echo &quot;{$_GET['callback']}({$str})&quot;;&lt;/p&gt;
&lt;p&gt;③ 后台返回之后，Ajax依然可以使用succes作为成功的回调函数：&lt;/p&gt;
&lt;p&gt;success:function(data){&lt;/p&gt;
&lt;p&gt;console.log(data);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;当然后台也可以随便返回一个回调函数名： echo &quot;callBack($json)&quot;;&lt;/p&gt;
&lt;p&gt;前台只要请求成功就会自动调用这个函数。类似于上面的第2条的② ③ 步；&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;146、 JavaScript window.onload 事件和 jQuery ready 函数有何不同？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1.执行时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。&lt;/p&gt;
&lt;p&gt;    $(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.编写个数不同&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个&lt;/p&gt;
&lt;p&gt;     $(document).ready()可以同时编写多个，并且都可以得到执行&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.简化写法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     window.onload没有简化写法&lt;/p&gt;
&lt;p&gt;     $(document).ready(function(){})可以简写成$(function(){});&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;147、$(this) 和 this 关键字在 jQuery 中有何不同?&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1、this表示javascript的&lt;span&gt;dom对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、$(this)表示把&lt;span&gt;dom对象转换为jquery对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、jquery包的方法只能由jquery对象调用，不能用javascript的&lt;span&gt;Dom对象使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;$(&quot;input&quot;).click(function(){&lt;/p&gt;
&lt;p&gt;//这里的this表示被点击的输入框对象,可以使用javascript对该对象进行操作&lt;/p&gt;
&lt;p&gt;var value=this.value;&lt;/p&gt;
&lt;p&gt;//jquery对象与&lt;span&gt;dom对象取值方法不一样，要用jquery方法必须使用$(dom对象)转换&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;var val=$(this).val();&lt;/p&gt;
&lt;p&gt;）}&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;148、简单介绍下JavaScript中的作用域与变量声明提升？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1、一个变量的作用域表示这个变量存在的上下文。一个变量的作用域表示这个变量存在的上下文。javascript有拥有函数级别的作用域，也就是说，在一个函数内定义的变量只能在函数内部访问或者这个函数内部的函数访问（闭包除外）每一个在函数外部声明或者定义的变量都是一个全局对象，所以这个变量可以在任何地方被使用。&lt;/p&gt;
&lt;p&gt;2、变量声明提升就是在函数内部不用var 声明的一个变量，想要访问的时候，会在当前函数中寻找，发现当前函数中没有，继续往上层函数找，一直到全局作用下还没有找到，就会将这个变量在全局范围内进行声明。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;149、jquery.extend 与 jquery.fn.extend的区别？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;jQuery为开发插件提拱了两个方法，分别是：&lt;/p&gt;
&lt;p&gt;jQuery.fn.extend();&lt;/p&gt;
&lt;p&gt;jQuery.extend();&lt;/p&gt;
&lt;p&gt;&lt;span&gt;jquery.extend&lt;span&gt;：用于声明全局插件&lt;span&gt;/方法。&lt;span&gt;声明插件&lt;span&gt;/方法使用$.func();直接调用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;query.fn.extend&lt;span&gt;：用于声明局部插件&lt;span&gt;/方法。&lt;span&gt;声明插件&lt;span&gt;/方法使用$(“选择器”).func();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;150、常见的浏览器内核有哪些？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1，使用Trident的是internet explorer，国产的绝大部分浏览器。Trident是就是&lt;span&gt;ie内核&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2，使用Gecko的是Mozilla Firefox，使用 Gecko 内核的浏览器也有不少，如 Netscape MozillaSuite/SeaMonkey 等&lt;/p&gt;
&lt;p&gt;3，使用Presto的是opera，这是目前公认网页浏览速度最快的&lt;span&gt;浏览器内核&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4，使用WebKit的有&lt;span&gt;苹果的safari，&lt;span&gt;谷歌的chrome，还有国产的大部分双核浏览器其中一核就是WebKit&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;151、margin和padding分别适合什么场景使用？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。 margin用于布局分开元素使元素与元素互不相干； padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;152、::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）&lt;/p&gt;
&lt;p&gt;双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，&lt;/p&gt;
&lt;p&gt;比如:first-line、:first-letter、:before、:after等，&lt;/p&gt;
&lt;p&gt;而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。 想让插入的内容出现在其它内容前，使用::before，否者，使用::after；&lt;/p&gt;
&lt;p&gt;在代码顺序上，::after生成的内容也比::before生成的内容靠后。&lt;/p&gt;
&lt;p&gt;如果按堆栈视角，::after生成的内容会在::before生成的内容之上&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;153、 li与li之间（display:inline-block）有看不见的空白间隔是什么原因引起的？有什么解决办法？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;浏览器的默认行为是把inline元素间的空白字符（空格换行tab）渲染成一个空格，&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;154、解释一下JavaScript中的this指针、闭包、作用域？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;This指向&lt;span&gt;：&lt;span&gt;JS函数中的this&lt;span&gt;，永远指向&lt;span&gt;函数调用语句所在的对象&lt;span&gt;(谁调用函数，this指向谁)。&lt;span&gt;(2分)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;闭包： &lt;span&gt;&lt;span&gt;在函数中，写一个子函数。内层函数可以访问外层函数中的变量。&lt;span&gt;(2分)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作用域： &lt;span&gt;&lt;span&gt;变量生效的范围称为作用域。&lt;span&gt;JS中只有全局作用域和函数作用域。&lt;span&gt;(2分)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;155、使用jQuery操作元素的属性attr()方法和val()有什么区别?&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;Attr():用于读取或者设置元素的属性&lt;span&gt;；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Val(): 用于读取或者设置表单元素的value；&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;156、JavaScript怎样创建节点、删除节点、替换节点、复制节点？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;创建节点： &lt;span&gt;.creatElement();&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;删除节点： &lt;span&gt;.removeChild();&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;替换节点： &lt;span&gt;.replaceChild();&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;复制节点： &lt;span&gt;.cloneNode(true/false);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;157、CSS中的link和@import有什么区别？常用哪种？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;① link属于标准的HTML标签，而@import不是标准标签；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② link可以兼容所有低版本浏览器，而@import只在CSS2之后能用；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③ link是将两个文件链接起来，起桥梁作用； 而@import相当于将CSS文件复制到HTML文件中；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;④ link会在HTML文件边加载的过程中，边链接CSS文件；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;@import会在HTML文件全部加载完以后，再导入CSS文件；&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 10 Nov 2017 10:51:00 +0000</pubDate>
<dc:creator>卡尔西法calcifer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wq1994/p/7816020.html</dc:identifier>
</item>
<item>
<title>服务器 : Apache Tomcat - 理解架构层次 - Rudolph_Browne</title>
<link>http://www.cnblogs.com/CARPE-DIEM-wu/p/7709545.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CARPE-DIEM-wu/p/7709545.html</guid>
<description>&lt;h3&gt; 文章概览&lt;/h3&gt;
&lt;p&gt;　　相信很多接触java的人都对Tom猫有着多少的熟悉,就个人而言,本来只知道Tom简单的操作与配置,就像裹上一层纱,迷迷糊糊的.&lt;/p&gt;
&lt;p&gt;　　Tomcat的书籍本来就不多,高分的还是很久之前的版本,直到最近看到下面这本书,解答了我的很多疑问,同时这篇文章将总结读书收获.&lt;/p&gt;
&lt;p&gt;　　如果觉得文章写的内容是你感兴趣的或者我的猫使你感兴趣,建议你读读这本书.&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171101110431716-405618801.png&quot; alt=&quot;&quot; width=&quot;229&quot; height=&quot;307&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171101112642779-536230757.png&quot; alt=&quot;&quot; width=&quot;403&quot; height=&quot;303&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　该文会介绍Tom的架构,服务器如何从一层层抽象设计到完整的架构&lt;/p&gt;
&lt;h3&gt;Tomcat介绍&lt;/h3&gt;
&lt;p&gt;　　Tom是一款全世界著名的轻量级应用服务器,基于java,服务于java.主要作为应用服务器来处理客户端发来的动态资源响应. &lt;/p&gt;
&lt;p&gt;　　目前版本是9.x,很多人都在使用6.x,但新版其实提供了很多新的功能,比如WebSocket的支持,点击了解&lt;a href=&quot;WebSocket%20%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5%EF%BC%9F%20-%20Ovear%E7%9A%84%E5%9B%9E%E7%AD%94%20-%20%E7%9F%A5%E4%B9%8E%20https://www.zhihu.com/question/20215561/answer/40316953&quot; target=&quot;_blank&quot;&gt;WebSocket&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171101114455138-1819646546.png&quot; alt=&quot;&quot; width=&quot;470&quot; height=&quot;263&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Tomcat启动参数&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　windows修改$CATALINA_HOME/bin/catalina.bat文件&lt;/p&gt;
&lt;p&gt;　　　　Set JAVA_OPTS=-server -Xms1024m -Xmx2048m -XX:PermSize=256m -XX:MaxPermSize=512m&lt;/p&gt;
&lt;p&gt;　　　　linux修改$CATALINA_HOME/bin/catalina.sh文件&lt;/p&gt;
&lt;p&gt;　　　　JAVA_OPTS=&quot;-server -Xms1024m -Xmx2048m -XX:PermSize=256m -XX:MaxPermSize=512m&quot;&lt;/p&gt;
&lt;p&gt;　　　　-server　　Server端启动Tomcat,Client启动Tomcat两者的初始化参数会有所不同&lt;/p&gt;
&lt;p&gt;　　　　-Xms1024m 初始化堆内存大小&lt;/p&gt;
&lt;p&gt;　　　　-Xmx2048m 允许的最大堆内存大小&lt;/p&gt;
&lt;p&gt;　　　　-XX:PermSize=256m 初始化非堆内存大小&lt;/p&gt;
&lt;p&gt;　　　　-XX:MaxPermSize=512m 允许的最大非堆内存大小&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Debug方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　依赖于JDK提供的JPDA(Java Platform Debugger Architecture,Java平台调试体系)&lt;/p&gt;
&lt;p&gt;　　　　catalina jpda start&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;目录结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171101181818201-17793876.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;86&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　该文使用的版本是apache-tomcat-9.0.1,目录大致都很容易理解.&lt;/p&gt;
&lt;p&gt;　　　　conf放置的Tomcat的核心配置文件,下文会介绍.&lt;/p&gt;
&lt;p&gt;　　　　webapps是默认的web app的应用目录,只要把项目目录放置进去就可以运行&lt;/p&gt;
&lt;p&gt;　　　　work是Tomcat运行时产生的jsp编译文件所存放的位置&lt;/p&gt;
&lt;h3&gt; 总体架构&lt;/h3&gt;
&lt;p&gt;　　Tomcat是一款应用服务器,我们从最根本的类一层一层演变,直至Tomcat当前版本.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;/span&gt;应用服务器是&lt;span&gt;接收&lt;/span&gt;其他计算机(客户端)发来的&lt;span&gt;请求&lt;/span&gt;数据并对其解析,完成相关业务处理,然后把&lt;span&gt;处理&lt;/span&gt;结果作为&lt;span&gt;响应返回&lt;/span&gt;给计算机.&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171102143006279-1167260582.png&quot; alt=&quot;&quot; width=&quot;590&quot; height=&quot;232&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;/span&gt;一个问题摆在眼前,前面Server请求监听和请求处理放在一起,应用服务器通常会与web服务器进行集群部署和负载均衡,但是这两者的协议并不是HTTP.&lt;/p&gt;
&lt;p&gt;也就是说,&lt;span&gt;服务器连接的另一端需要适配不同的协议来对请求作出不同的处理.&lt;/span&gt;前面的模型扩展性太差,应该分离请求监听和请求处理.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Connector模块管理请求监听,Container模块负责请求处理,&lt;span&gt;两个组件都拥有start()和stop()来加载和释放自己维护的资源&lt;/span&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样子,Server下可以有多个Connector来传送请求至不同的Container中.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171102145759873-1935955560.png&quot; alt=&quot;&quot; width=&quot;555&quot; height=&quot;310&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.&lt;/strong&gt;&lt;/span&gt;上面的设计有个缺陷,既然server可以有多个Connector和Container,那么如何知道哪个Connector将请求发至哪个Container呢?&lt;/p&gt;
&lt;p&gt;考虑一下下面这个设计图,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171102152908466-869114614.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.&lt;/strong&gt;&lt;/span&gt;我们接触过的Tomcat应该是放置web app的容器,在哪放置web app?这将决定哪个app来处理Engine所获取的请求信息.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171102153825216-1105101662.png&quot; alt=&quot;&quot; width=&quot;290&quot; height=&quot;138&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  再想一下,我们浏览器是个app,对吧?然后服务器其实也是app对吧?网络就是两者的通信.我们来看一下网络是怎么进行通信的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171102160952513-1131433490.png&quot; alt=&quot;&quot; width=&quot;633&quot; height=&quot;369&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没错,web app需要端点信息(IP地址,端口号),我们需要提供这一层的抽象.&lt;span&gt;一个Host下可以对应有多个app(Context).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171102161432623-2096080189.png&quot; alt=&quot;&quot; width=&quot;552&quot; height=&quot;369&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.&lt;/strong&gt;&lt;/span&gt;现在设计已经可以满足两个应用的连接了,现在设想一下,应用该怎么进行表示?毕竟Tomcat作为一款Servlet容器而存在.首先Apache组织按照Servlet官方的标准,加入了Servlet的包装类Wrapper.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171102162139716-791879221.png&quot; alt=&quot;&quot; width=&quot;331&quot; height=&quot;95&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6.&lt;/span&gt;&lt;/strong&gt;就目前为止,我们使用&quot;&lt;span&gt;容器&lt;/span&gt;&quot;这一概念来形容&lt;span&gt;处理接收客户端的请求并且返回响应数据的组件&lt;/span&gt;,依此,使用一个类Container来统一表示这一想法,让Engine,Host,Context,Wrapper这类组件来继承Container.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171103093246591-2080032771.png&quot; alt=&quot;&quot; width=&quot;591&quot; height=&quot;492&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Container类能够添加子组件addChild方法,有时需要执行一些异步处理,所以加入backgroundProcess方法.&lt;/p&gt;
&lt;p&gt;由于Engine,Host,Context,Wrapper这类的引用变成了父类Container,所以之前的&lt;span&gt;强组合关系变成了弱组合关系&lt;/span&gt;.强弱关系指的是两个类直接关联或者是间接关联.&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;7.&lt;/span&gt;&lt;/strong&gt;为了从抽象和复用层面上再审视一下当前设计,使概念更加清晰,提供通用性定义.&lt;span&gt;由于所有容器都有着自身的生命周期管理方法,那么我们可以将其进行抽象成一个接口Lifecycle,在方法定义上加入初始化方法init,销毁方法destroy,事件监听方法addLifecycleListener和removeLifecycleListener.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171103100339763-129008876.png&quot; alt=&quot;&quot; width=&quot;609&quot; height=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;8.&lt;/span&gt;&lt;/strong&gt;上面这个设计Container部分具有伸缩性和扩展性,这很棒.接下来Tomcat的开发人员为了提高每个组件的灵活性,使其更易扩展,加入了Pipeline和Valve这两个接口.这两个接口的设计运用了职责链模式.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171103103421998-373302533.png&quot; alt=&quot;&quot; width=&quot;455&quot; height=&quot;246&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单介绍以下职责链模式,关于设计模式可以查看博客里的文章&lt;a href=&quot;http://www.cnblogs.com/CARPE-DIEM-wu/p/7624014.html&quot; target=&quot;_blank&quot;&gt;《软件设计 : 聚焦设计模式》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;职责链模式使用一个抽象类来统一定义处理器,然后将处理器构造成一条链,当Client端发来请求时,第一个Handler判断是否处理,不处理则往下个Handler传递,直至被处理或则处理链结束.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171103104007232-315998161.png&quot; alt=&quot;&quot; width=&quot;629&quot; height=&quot;140&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171103104213373-317953730.png&quot; alt=&quot;&quot; width=&quot;655&quot; height=&quot;317&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回头看Tomcat怎么运用这个设计模式,&lt;span&gt;Pipeline接口用于构建职责链,Valve接口代表职责链上的每个处理器.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Pipeline中维护一个基础的Valve,它始终位于Pipeline执行链的末端,封装了具体的请求处理和输出响应过程.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171103110236888-1279941456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就可以构造一条职责链,可是为什么要这么做?记得之前Container不就是可以自包含的容器吗?为什么要弄出多两个接口?&lt;/p&gt;
&lt;p&gt;的确,Container可以自包含,但是它是作为容器抽象类而存在,&lt;strong&gt;&lt;span&gt;而阀(Valve)作为接口而存在,我们可以在实现这个接口的类中添加属于我们自己的Valve实现类,&lt;/span&gt;&lt;/strong&gt;你想做什么都行.&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;就像水管一样,你如果是超级马里奥,你可以随时给它加个阀,做任何事.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171103105439888-1361808673.png&quot; alt=&quot;&quot; width=&quot;585&quot; height=&quot;271&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171103111331795-331548186.png&quot; alt=&quot;&quot; width=&quot;624&quot; height=&quot;443&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;9.&lt;/strong&gt;&lt;/span&gt;前面的设计基本落在Container部分,来看看Connector的设计方案,Connector必须完成下面的功能项.&lt;/p&gt;
&lt;p&gt;　　①监听服务器端口,读取客户端的请求&lt;/p&gt;
&lt;p&gt;　　②将请求数据按指定协议进行解析&lt;/p&gt;
&lt;p&gt;　　③根据请求地址匹配正确的容器进行处理&lt;/p&gt;
&lt;p&gt;　　④将请求返回客户端&lt;/p&gt;
&lt;p&gt;Tomcat支持多协议(HTTP/AJP)和多种IO方式(BIO,NIO,NIO2,APR,HTTP/2)&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171105122629951-857004236.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ProtocolHandler表示协议处理器,针对不同的协议和IO方式,提供不同的实现,ProtocolHandler包含一个Endpoint用来启动socket监听,该接口按照IO方式进行分类实现,还包含一个Process用于按照指定协议读取数据,并交由容器处理.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;处理逻辑如下:&lt;/p&gt;
&lt;p&gt;1.在Connector启动时,Endpoint会启动线程来监听服务器端口,并在接收到请求后调用Process进行数据读取.&lt;/p&gt;
&lt;p&gt;2.当Process读取客户端请求之后,需要按照地址映射到具体的容器进行处理,即请求映射.&lt;/p&gt;
&lt;p&gt;3.由于Tomcat各个组件采用通用的生命周期进行管理,而且通过管理工具进行状态变更,因此请求映射除了考虑映射规则的实现外,还要考虑容器组件的注册和销毁.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171105143835295-669692606.png&quot; alt=&quot;&quot; width=&quot;659&quot; height=&quot;421&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Tomcat采用Mapper来维护容器映射信息,按照映射规则(Servlet规范定义)查找容器;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MapperListener实现LifecycleListener和ContainerListener,用于在容器组件状态变更时,注册或者取消对应的容器映射信息;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;MapperListener实现了Lifecycle接口,当Service启动时,会自动作为监听器注册到各个容器组件之上,同时将已创建的容器注册到Mapper;&lt;/p&gt;
&lt;p&gt;Tomcat通过适配器模式实现了Connector与Mapper,Container的解耦,默认实现为CoyotoAdapter;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;10.&lt;/strong&gt;&lt;/span&gt;到这里,服务器可以正常接入请求和完成响应,可是我们还没考虑到一个关键的问题——并发&lt;/p&gt;
&lt;p&gt;Tomcat使用组件式的设计理念,那么也会有并发组件.&lt;/p&gt;
&lt;p&gt;Tomcat组织为此&lt;span&gt;提供了一个Executor接口表示一个可以在组件间共享的线程池&lt;/span&gt;,该接口同样继承自Lifecycle接口,按照通用组件进行管理.&lt;/p&gt;
&lt;p&gt;Executor由Service进行维护,因此同一个Service中的组件共享一个线程池.值得注意的是如果没有定义线程池,相关组件会自动创建线程池,此时线程池不再共享.&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;在Tomcat中,Endpoint会启动一组线程来监听Socket端口,当接收到客户请求会创建请求处理对象,并交由线程池处理,由此支持并发处理客户端请求.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171105151228638-1423040040.png&quot; alt=&quot;&quot; width=&quot;684&quot; height=&quot;438&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;11.&lt;/strong&gt;&lt;/span&gt;现在Tomcat基础的核心组件已经完整了,但是架构其实还有很多组件没有显示出来.Tomcat开发人员为了让使用者很好地使用Tomcat,提供了&lt;span&gt;一套配置环境来支持系统的可配置性——Catalina&lt;/span&gt;.&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;Catalina代表了整个Servlet容器架构,包含了上面所有组件,还有还没谈及的安全,会话,集群,部署,管理等Servlet容器组件.它通过松耦合的方式集成了Coyoto,以完成按照请求协议进行数据读写.同时,还包括启动入口、Shell程序等.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Bootstrap是Catalina的启动入口.&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;为什么Tomcat不通过Catalina启动,而又提供了Bootstrap?&lt;/p&gt;
&lt;p&gt;查看一下Tomcat发布包目录,Bootstrap并不存放于Catalina的lib目录下,而是置于bin目录中.&lt;span&gt;&lt;strong&gt;Bootstrap通过反射调用Catalina实例,与Tomcat服务器完全松耦合,它可以直接依赖JRE运行并为Tomcat应用服务器创建共享类加载器,用于构建Catalina实例以及整个Tomcat服务器.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171105154154560-1040028761.png&quot; alt=&quot;&quot; width=&quot;701&quot; height=&quot;451&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此,Tomcat的基础核心组件介绍结束,我们回顾一下组件的概念&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/span&gt;　　 表示整个Servlet容器,一个Tomcat运行环境只存在一个Server,可存在多个Service.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Service&lt;/span&gt;&lt;/strong&gt;　   表示链接器和处理器的集合,同一个Service下的链接器将请求传至该Service下的处理器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Connector&lt;/span&gt;&lt;/strong&gt; 表示链接器,用于监听并转化Socket请求,支持不同协议与IO方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Container&lt;/span&gt;&lt;/strong&gt;  表示容器组件,能执行客户端请求并返回响应的组件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Engine&lt;/span&gt;&lt;/strong&gt;　   表示顶级容器,是获取目标容器的入口&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Host&lt;/span&gt;&lt;/strong&gt;　　　表示Servlet引擎中的虚拟机,提供Host之类的域名信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Context&lt;/span&gt;&lt;/strong&gt;　 表示一个web app应用上下文环境&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Wrapper&lt;/span&gt;&lt;/strong&gt;　具体的Servlet包装类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Executor   &lt;/span&gt;&lt;/strong&gt;组件间共享的线程池&lt;/p&gt;
&lt;h3&gt;Tomcat启动与请求响应&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171105160049857-1157037456.png&quot; alt=&quot;&quot; width=&quot;681&quot; height=&quot;375&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171105160218748-498514621.png&quot; alt=&quot;&quot; width=&quot;660&quot; height=&quot;476&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;Tomcat类加载器&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;应用服务器通常会自行创建类加载器以实现更加灵活的控制,这是对规范的实现(Servlet规范要求每个Web应用都有独立的类加载器实例),也是架构层面的考虑.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;书中p46对类加载器进行了详细说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JVM默认提供了三个类加载器来进行类加载,Tomcat在加载器上进行扩展,用来加载应用自身的类.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171110173234200-1514864636.png&quot; alt=&quot;&quot; width=&quot;559&quot; height=&quot;362&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Bootstrap&lt;/span&gt;&lt;/strong&gt;　　JVM提供,加载JVM运行的基础运行类,即位于%JAVA_HOME%/jre/lib目录下的核心类库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Extension&lt;/span&gt;&lt;/strong&gt;　   JVM提供,加载%JAVA_HOME%/jre/lib/ext目录下的扩展类库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;System　&lt;/span&gt;&lt;/strong&gt;　    JVM提供,加载CLASSPATH指定目录下或者-classpath运行参数指定的jar包&lt;/p&gt;
&lt;p&gt;　　　　　　   Tomcat的Bootstrap类即由这个加载器载入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Common&lt;/span&gt;&lt;/strong&gt;　　 以System为父类加载器,是Tomcat应用服务器顶层的公用类加载器,&lt;/p&gt;
&lt;p&gt;　　　　　　   其路径common.loader,默认指向$Catalina_Home/lib目录.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Catalina&lt;/span&gt;&lt;/strong&gt;　　   用于加载Tomcat应用服务器的类加载器,路径为server.loader,&lt;/p&gt;
&lt;p&gt;　　　　　  　 默认为空,此时Tomcat使用Common类加载器加载应用服务器.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Shared&lt;/span&gt;&lt;/strong&gt;　　 　所有Web应用的类加载器,路径为shared.loader,默认为空.&lt;/p&gt;
&lt;p&gt;　　　　　  　 此时使用Common类加载器作为Web应用的父加载器.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Web App&lt;/span&gt;&lt;/strong&gt;　 　加载WEB-INF/classes目录下未压缩的Class和资源文件以及/WEB-INF/lib目录下的jar包.&lt;/p&gt;
&lt;p&gt;　　　　　　  该类加载器对当前web应用可见,对其他web应用不可见. &lt;/p&gt;





</description>
<pubDate>Fri, 10 Nov 2017 10:29:00 +0000</pubDate>
<dc:creator>Rudolph_Browne</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CARPE-DIEM-wu/p/7709545.html</dc:identifier>
</item>
</channel>
</rss>