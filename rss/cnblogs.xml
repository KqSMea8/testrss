<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>RMQ_第一弹_Sparse Table - 31415926535x</title>
<link>http://www.cnblogs.com/31415926535x/p/9688994.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/31415926535x/p/9688994.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;title: RMQ_第一弹_Sparse Table&lt;br/&gt;date: 2018-09-21 21:33:45&lt;br/&gt;tags:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;acm&lt;/li&gt;
&lt;li&gt;RMQ&lt;/li&gt;
&lt;li&gt;ST&lt;/li&gt;
&lt;li&gt;dp&lt;/li&gt;
&lt;li&gt;数据结构&lt;/li&gt;
&lt;li&gt;算法&lt;br/&gt;categories:&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&quot;acm&quot;&gt;ACM&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;RMQ (Range Minimum/Maximum Query)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从英文便可以看出这个算法的主要是询问一个区间内的最值问题，，，&lt;/p&gt;
&lt;p&gt;暑假集训的时候学习了 &lt;strong&gt;线段树&lt;/strong&gt; ，，，&lt;/p&gt;
&lt;p&gt;也可以对给定数组查询任意区间的最值问题，，，，&lt;/p&gt;
&lt;p&gt;这两个主要的区别就是 线段树 可以进行单点的修改操作，，，而 &lt;strong&gt;Sparse Table&lt;/strong&gt; 算法不能进行点修改，，&lt;/p&gt;
&lt;p&gt;或者说这样修改一次重预处理一次不划算，，，&lt;/p&gt;
&lt;p&gt;所以说，，要是题目只是单纯的多次查询任意区间的最值，，，Sparse Table 首选，，毕竟，，毕竟写起来比线段树简单得多了，，，&lt;/p&gt;

&lt;h2 id=&quot;算法原理&quot;&gt;算法原理&lt;/h2&gt;
&lt;p&gt;基本思想是dp,,,,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dp的状态&lt;/strong&gt; : 对于数组 &lt;span class=&quot;math inline&quot;&gt;\(a[1-n]\)&lt;/span&gt; , &lt;span class=&quot;math inline&quot;&gt;\(F[i , j]\)&lt;/span&gt;表示从第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个位置开始 ， &lt;strong&gt;长度&lt;/strong&gt; 为&lt;span class=&quot;math inline&quot;&gt;\(2^j\)&lt;/span&gt; 个数这个区间中的最值，，，;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dp的初始值&lt;/strong&gt; : &lt;span class=&quot;math inline&quot;&gt;\(F[i , 0] = a[i]\)&lt;/span&gt;;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;状态转移方程&lt;/strong&gt; : &lt;span class=&quot;math inline&quot;&gt;\(F[i , j] = max (F[i , j - 1] , F[i + 2^{j - 1} , j - 1])\)&lt;/span&gt;;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思想&lt;/strong&gt; : &lt;span class=&quot;math inline&quot;&gt;\(F[i , j]\)&lt;/span&gt; 就是不断取他的左右这两段的最值，，这两段的长度相等，都为 &lt;span class=&quot;math inline&quot;&gt;\(2^{j - 1}\)&lt;/span&gt; 个元素，，&lt;/p&gt;
&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;const int maxn = 5e4 + 10;
int n , q;
int a[maxn];
int mx[maxn][20];
int mi[maxn][20];
void rmq()
{
    for (int i = 1; i &amp;lt;= n; ++i)
        mx[i][0] = mi[i][0] = a[i];

    for (int j = 1; (1 &amp;lt;&amp;lt; j) &amp;lt;= n; ++j)
    {
        for (int i = 1; i + (1 &amp;lt;&amp;lt; j) - 1 &amp;lt;= n; ++i)
        {
            mx[i][j] = max(mx[i][j - 1] , mx[i + (1 &amp;lt;&amp;lt; (j - 1))][j - 1]);
            mi[i][j] = min(mi[i][j - 1] , mi[i + (1 &amp;lt;&amp;lt; (j - 1))][j - 1]);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们需要注意的是循环的顺序，我们发现外层是j，内层所i，这是为什么呢？可以是i在外，j在内吗？&lt;br/&gt;答案是不可以。因为我们需要理解这个状态转移方程的意义。&lt;/p&gt;
&lt;p&gt;状态转移方程的含义是：先更新所有长度为F[i,0]即1个元素，然后通过2个1个元素的最值，获得所有长度为F[i,1]即2个元素的最值，然后再通过2个2个元素的最值，获得所有长度为F[i,2]即4个元素的最值，以此类推更新所有长度的最值。&lt;/p&gt;
&lt;p&gt;而如果是i在外，j在内的话，我们更新的顺序就是F[1,0],F[1,1],F[1,2],F[1,3],表示更新从1开始1个元素，2个元素，4个元素，8个元素（A[0],A[1],....A[7]）的最值，这里F[1,3] = max(max(A[0],A[1],A[2],A[3]),max(A[4],A[5],A[6],A[7]))的值，但是我们根本没有计算max(A[0],A[1],A[2],A[3])和max(A[4],A[5],A[6],A[7])，所以这样的方法肯定是错误的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/niushuai666/article/details/6624672?utm_source=copy&quot;&gt;本段来自某大佬博客&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;思想&quot;&gt;思想&lt;/h2&gt;
&lt;p&gt;假如我们需要查询的区间为(i,j)，那么我们需要找到覆盖这个闭区间(左边界取i，右边界取j)的最小幂（可以重复，比如查询5，6，7，8，9，我们可以查询5678和6789）。&lt;/p&gt;
&lt;p&gt;因为这个区间的长度为 &lt;span class=&quot;math inline&quot;&gt;\(j - i + 1\)&lt;/span&gt; ,所以我们可以取 &lt;span class=&quot;math inline&quot;&gt;\(k=log2( j - i + 1)\)&lt;/span&gt; ，则有：&lt;span class=&quot;math inline&quot;&gt;\(RMQ(A, i, j)=max(F[i , k], F[ j - 2 ^ k + 1, k])\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;举例说明，要求区间[2，8]的最大值，&lt;span class=&quot;math inline&quot;&gt;\(k = log_2（8 - 2 + 1）= 2\)&lt;/span&gt;，即求 &lt;span class=&quot;math inline&quot;&gt;\(max(F[2, 2]，F[8 - 2 ^ 2 + 1, 2]) = max(F[2, 2]，F[5, 2])\)&lt;/span&gt;；&lt;/p&gt;
&lt;h2 id=&quot;实现-1&quot;&gt;实现&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int ans(int l , int r)
{
    int k = 0;
    int len = r - l + 1;
    while ((1 &amp;lt;&amp;lt; (k + 1)) &amp;lt;= len)
        ++k;

    return max (mx[l][k] , mx[r - (1 &amp;lt;&amp;lt; k) + 1][k]) - min (mi[l][k] , mi[r - (1 &amp;lt;&amp;lt; k) + 1][k]);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=3264&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目大意: 给定的数列a[1 - n] , 求出[l , r]这个区间内的极差 ， 即最大值与最小值的差&lt;/p&gt;
&lt;p&gt;直接套板子，，，，&lt;/p&gt;
&lt;p&gt;ac代码:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;
const int maxn = 5e4 + 10;
int n , q;
int a[maxn];
int mx[maxn][20];
int mi[maxn][20];
void rmq()
{
    for (int i = 1; i &amp;lt;= n; ++i)
        mx[i][0] = mi[i][0] = a[i];

    for (int j = 1; (1 &amp;lt;&amp;lt; j) &amp;lt;= n; ++j)
    {
        for (int i = 1; i + (1 &amp;lt;&amp;lt; j) - 1 &amp;lt;= n; ++i)
        {
            mx[i][j] = max(mx[i][j - 1] , mx[i + (1 &amp;lt;&amp;lt; (j - 1))][j - 1]);
            mi[i][j] = min(mi[i][j - 1] , mi[i + (1 &amp;lt;&amp;lt; (j - 1))][j - 1]);
        }
    }
}
int ans(int l , int r)
{
    int k = 0;
    int len = r - l + 1;
    while ((1 &amp;lt;&amp;lt; (k + 1)) &amp;lt;= len)
        ++k;

    return max (mx[l][k] , mx[r - (1 &amp;lt;&amp;lt; k) + 1][k]) - min (mi[l][k] , mi[r - (1 &amp;lt;&amp;lt; k) + 1][k]);
}
using namespace std;
int main(){ 
    while (scanf(&quot;%d%d&quot; , &amp;amp;n , &amp;amp;q) != EOF)
    {
        for (int i = 1; i &amp;lt;= n; ++i)
            scanf(&quot;%d&quot; , &amp;amp;a[i]);

        rmq();
        
        while (q--)
        {
            int l , r;
            scanf(&quot;%d%d&quot; , &amp;amp;l , &amp;amp;r);
            printf(&quot;%d\n&quot; , ans(l , r));
        }
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;一维:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;const int MAXN = 50010;
int dp[MAXN][20];
int mm[MAXN];
//初始化 RMQ, b 数组下标从 1 开始，从 0 开始简单修改
void initRMQ(int n,int b[])
{
    mm[0] = −1;
    for(int i = 1; i &amp;lt;= n; i++)
    {
        mm[i] = ((i&amp;amp;(i−1)) == 0)?mm[i−1]+1:mm[i−1];
        dp[i][0] = b[i];
    }
    for(int j = 1; j &amp;lt;= mm[n]; j++)
        for(int i = 1; i + (1&amp;lt;&amp;lt;j) −1 &amp;lt;= n; i++)
            dp[i][j] = max(dp[i][j−1],dp[i+(1&amp;lt;&amp;lt;(j−1))][j−1]);
}
 //查询最大值
int rmq(int x,int y)
{
    int k = mm[y−x+1];
    return max(dp[x][k],dp[y−(1&amp;lt;&amp;lt;k)+1][k]);
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 21 Sep 2018 15:23:00 +0000</pubDate>
<dc:creator>31415926535x</dc:creator>
<og:description>title: RMQ_第一弹_Sparse Table date: 2018 09 21 21:33:45 tags: acm RMQ ST dp 数据结构 算法 categories: ACM 概述</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/31415926535x/p/9688994.html</dc:identifier>
</item>
<item>
<title>WPF 语言格式化文本控件 - 唐宋元明清2188</title>
<link>http://www.cnblogs.com/kybs0/p/9688933.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kybs0/p/9688933.html</guid>
<description>&lt;p&gt;&lt;span&gt;本章讲述正确添加语言资源的方式，以及一段语言资源的多种样式显示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：“@&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;Winter&lt;/strong&gt;，你好！感谢已使用软件 &lt;span&gt;800&lt;/span&gt; 天！&lt;/span&gt;”&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在添加如上多语言资源项时，“XX，你好！感谢已使用软件 X 天！”&lt;/p&gt;
&lt;p&gt;那么，你是怎么添加语言资源的呢？&lt;/p&gt;
&lt;p&gt;分别添加，“，你好！”、“&lt;span&gt;感谢已使用软件&lt;/span&gt;”、“年”3个，再通过界面绑定动态变量 &lt;strong&gt;昵称和使用天数&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;假如你是按照如上添加语言资源的，那么问题来了，添加如上英文语言资源呢？是不是也分别添加单个资源，再拼凑绑定？&lt;/p&gt;

&lt;p&gt;正确的做法是，添加整个语言资源，&lt;span&gt;“&lt;span&gt;{0}，你好！感谢已使用软件 {1} 天！&lt;/span&gt;”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因：&lt;/span&gt;&lt;span&gt;使用格式化的语言资源，那么将中文资源翻译成英文或者其它语言后，得到的译文符合原有的含义了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不然，一段一段翻译后的文本拼接，得到的只会是，&lt;span&gt;中式英文之类的&lt;/span&gt;。。。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在添加了语言资源后，如何在WPF界面显示呢？&lt;/p&gt;
&lt;h2&gt;简单的文本样式&lt;/h2&gt;
&lt;p&gt;只是简单的文本拼接，样式相同时，可以直接绑定动态变量值 - 昵称和使用年限，然后通过StringFormat或者Conveter去处理格式化文本。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果只有一个动态变量，直接使用&lt;span&gt;StringFormat处理即可。&lt;/span&gt;Text=&quot;{Binding Name,StringFormat={StaticResource TheFormatedText}}&quot;&lt;/li&gt;
&lt;li&gt;如果多个动态变量，可以使用多重绑定+Converter，实现文本格式化。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;复杂的文本样式&lt;/h2&gt;
&lt;p&gt;复杂样式，例如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;文本+按钮&lt;/li&gt;
&lt;li&gt;文本+超链接&lt;/li&gt;
&lt;li&gt;加粗文本+普通文本+红色文本&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上，如何处理？&lt;/p&gt;
&lt;h2&gt;语言格式化控件实现&lt;/h2&gt;
&lt;p&gt;Demo显示效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685541/201809/685541-20180921224554537-1066896742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 1. 添加一个继承TextBlock的用户控件ComplexTextBlock&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 解决复杂文本格式化样式的文本框控件
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 如&quot;已使用软件 {0} 天&quot;，天数需要标红加粗，或者用于【文本】【文字按钮】【文本】的组合
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ComplexTextBlock : TextBlock
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; 
&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 重写文本依赖属性&lt;/p&gt;
&lt;p&gt;为了监听文本变更，所以重写文本的依赖属性。文本变更事件处理，之后会详细介绍~&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DependencyProperty TextProperty =
&lt;span&gt; 2&lt;/span&gt;         DependencyProperty.Register(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(ComplexTextBlock), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertyMetadata(TextPropertyChanged));
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetText(DependencyObject element)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;)element.GetValue(TextProperty);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetText(DependencyObject element, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; value)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        element.SetValue(TextProperty, value);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TextPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        LoadComplexContent(d);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. 添加动态变量显示的控件列表&lt;/p&gt;
&lt;p&gt;如“@&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;Winter&lt;/strong&gt;，你好！感谢已使用软件 &lt;span data-mce-=&quot;&quot;&gt;&lt;span&gt;800&lt;/span&gt; 天，可查看&lt;span&gt;详情&lt;/span&gt;！”，可以将&lt;strong&gt;昵称、使用时间、详情&lt;/strong&gt;，分别设置为&lt;strong&gt;文本控件、文本控件、超链接按钮&lt;/strong&gt;，然后添加到动态控件列表中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DependencyProperty ContentFormatsProperty =
&lt;span&gt; 2&lt;/span&gt;         DependencyProperty.Register(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ContentFormats&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;(ContentFormatsCollection), &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(ComplexTextBlock),
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; PropertyMetadata(&lt;span&gt;default&lt;/span&gt;&lt;span&gt;(ContentFormatsCollection), ContentFormatsPropertyChanged));
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 格式化内容列表
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ContentFormatsCollection ContentFormats
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;get&lt;/span&gt; =&amp;gt;&lt;span&gt; (ContentFormatsCollection)GetValue(ContentFormatsProperty);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;set&lt;/span&gt; =&amp;gt;&lt;span&gt; SetValue(ContentFormatsProperty, value);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ContentFormatsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        LoadComplexContent(d);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4. 处理格式化文本&lt;/p&gt;
&lt;p&gt;处理方法，主要是将当前格式化的文本拆分为多个文本段落和格式化字符“{0}”，然后将待显示的动态变量（文本控件/按钮等）替换拆分后列表中的格式化字符。组合成完整的显示文本。&lt;/p&gt;
&lt;p&gt;其中，需要注意的是，文本的样式继承。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FormattedKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 加载复杂文本
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;dependencyObject&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; LoadComplexContent(DependencyObject dependencyObject)
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!(dependencyObject &lt;span&gt;is&lt;/span&gt;&lt;span&gt; ComplexTextBlock complexTextBlock))
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt;         &lt;span&gt;string&lt;/span&gt; text =&lt;span&gt; GetText(complexTextBlock);
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; contentFormats =&lt;span&gt; complexTextBlock.ContentFormats;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(text) || contentFormats == &lt;span&gt;null&lt;/span&gt; || contentFormats.Count == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; 
&lt;span&gt; 22&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; contentFormats.Count; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             text = text.Replace(i.ToString(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; list =&lt;span&gt; GetTextList(text);
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空当前文本&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;         complexTextBlock.Text = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分段加载文本&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; stackPanel = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StackPanel();
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;         stackPanel.Orientation =&lt;span&gt; Orientation.Horizontal;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         stackPanel.VerticalAlignment =&lt;span&gt; VerticalAlignment.Center;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; formatIndex = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; paraText &lt;span&gt;in&lt;/span&gt;&lt;span&gt; list)
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (paraText ==&lt;span&gt; FormattedKey)
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;                 stackPanel.Children.Add(contentFormats[formatIndex++&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; textLine = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TextBlock();
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (complexTextBlock.Style != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;                     textLine.Style =&lt;span&gt; complexTextBlock.Style;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;                     textLine.VerticalAlignment =&lt;span&gt; complexTextBlock.VerticalAlignment;
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                     textLine.HorizontalAlignment =&lt;span&gt; complexTextBlock.HorizontalAlignment;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                     textLine.Background =&lt;span&gt; complexTextBlock.Background;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;                     textLine.FontFamily =&lt;span&gt; complexTextBlock.FontFamily;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;                     textLine.FontSize =&lt;span&gt; complexTextBlock.FontSize;
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;                     textLine.Foreground =&lt;span&gt; complexTextBlock.Foreground;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;                     textLine.FontWeight =&lt;span&gt; complexTextBlock.FontWeight;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;                     textLine.FontStyle =&lt;span&gt; complexTextBlock.FontStyle;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                 textLine.Text =&lt;span&gt; paraText;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;                stackPanel.Children.Add(textLine);
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        complexTextBlock.Inlines.Add(stackPanel);
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取分段文本列表
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;text&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; GetTextList(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; text)
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; list = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; formatIndex =&lt;span&gt; text.IndexOf(FormattedKey, StringComparison.Ordinal);
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.不存在格式化关键字，则直接返回当前文本&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (formatIndex == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;            list.Add(text);
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.存在格式化关键字&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (formatIndex == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;            list.Add(FormattedKey);
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;             list.Add(text.Substring(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, formatIndex));
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;            list.Add(FormattedKey);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取下一格式化文本&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (formatIndex &amp;lt;&lt;span&gt; text.Length)
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             list.AddRange(GetTextList(text.Substring(formatIndex +&lt;span&gt; FormattedKey.Length)));
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;详细代码实现，可查看&lt;a href=&quot;https://github.com/Kybs0/ComplexTextBlock&quot; target=&quot;_blank&quot;&gt;Github源码Demo&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 21 Sep 2018 15:19:00 +0000</pubDate>
<dc:creator>唐宋元明清2188</dc:creator>
<og:description>前言 本章讲述正确添加语言资源的方式，以及一段语言资源的多种样式显示。 例如：“@Winter，你好！感谢已使用软件 800 天！” 在添加如上多语言资源项时，“XX，你好！感谢已使用软件 X 天！”</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kybs0/p/9688933.html</dc:identifier>
</item>
<item>
<title>MyBatis框架原理3：缓存 - AbcBoy</title>
<link>http://www.cnblogs.com/abcboy/p/9688961.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/abcboy/p/9688961.html</guid>
<description>&lt;p&gt;上一篇[MyBatis框架原理2：SqlSession运行过程][1]介绍了MyBatis的工作流程，其中涉及到了MyBatis缓存的使用，首先回顾一下工作流程图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1175086/201809/1175086-20180921231419887-780392574.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果开启了二级缓存，数据查询执行过程就是首先从二级缓存中查询，如果未命中则从一级缓存中查询，如果也未命中则从数据库中查询。MyBatis的一级和二级缓存都是基于Cache接口的实现，下面先来看看Cache接口和其各种实现类。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;public interface Cache {
  String getId();
  //缓存中添加数据，key为生成的CacheKey,value为查询结果
  void putObject(Object key, Object value);
  //查询
  Object getObject(Object key);
  //删除
  Object removeObject(Object key);
  //清空缓存
  void clear();
  //获取缓存数量
  int getSize();
  //获取读写锁
  ReadWriteLock getReadWriteLock();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Cache接口位于MyBatis的cache包下，定义了缓存的基本方法，其实现类采用了装饰器模式，通过实现类的组装，可以实现操控缓存的功能。cache包结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1175086/201809/1175086-20180921231443649-1402966429.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PerpetualCache是Cache接口的实现类，通过内部的HashMap来对缓存进行基本的操作，通常配合装饰器类一起使用。&lt;/li&gt;
&lt;li&gt;BlockingCache装饰器：保证只有一个线程到数据库中查询指定key的数据，如果该线程在BlockingCache中未查找到数据，就获取key对应的锁，阻塞其他查询这个key的线程，通过其内部ConcurrentHashMap来实现，源码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class BlockingCache implements Cache {

  //阻塞时长
  private long timeout;
  private final Cache delegate;
  //key和ReentrantLock对象一一对应
  private final ConcurrentHashMap&amp;lt;Object, ReentrantLock&amp;gt; locks;

  @Override
  public Object getObject(Object key) {
    //获取key的锁
    acquireLock(key);
    //根据key查询
    Object value = delegate.getObject(key);
    //如果命中缓存，释放锁，未命中则继续持有锁
    if (value != null) {
      releaseLock(key);
    }        
    return value;
  }
 @Override
  //从数据库获取结果后，将结果放入BlockingCache,然后释放锁
  public void putObject(Object key, Object value) {
    try {
      delegate.putObject(key, value);
    } finally {
      releaseLock(key);
    }
  }
...&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;FifoCache装饰器: 先入先出规则删除最早的缓存，通过其内部的Deque实现。&lt;/li&gt;
&lt;li&gt;LruCache装饰器: 删除最近使用最少的缓存， 通过内部的LinkedHashMap实现。&lt;/li&gt;
&lt;li&gt;SynchronizedCache装饰器：同步Cache。&lt;/li&gt;
&lt;li&gt;LoggingCache装饰器： 提供日志功能，记录和输出缓存命中率。&lt;/li&gt;
&lt;li&gt;SerializedCache装饰器：序列化功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CacheKey对象是用来确认缓存项的唯一标识，由其内部ArrayList添加的所有对象来确认两个CacheKey是否相同，通常ArrayList内将添加MappedStatement的id,SQL语句，用户传递给SQL语句的参数以及查询结果集范围RowBounds等，CacheKey源码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class CacheKey implements Cloneable, Serializable {
...
  private final int multiplier;
  private int hashcode;
  private long checksum;
  private int count;
  private List&amp;lt;Object&amp;gt; updateList;

  public CacheKey() {
    this.hashcode = DEFAULT_HASHCODE;
    this.multiplier = DEFAULT_MULTIPLYER;
    this.count = 0;
    this.updateList = new ArrayList&amp;lt;Object&amp;gt;();
  }

  //向updateLis中添加对象
  public void update(Object object) {
    int baseHashCode = object == null ? 1 : ArrayUtil.hashCode(object); 

    count++;
    checksum += baseHashCode;
    baseHashCode *= count;

    hashcode = multiplier * hashcode + baseHashCode;

    updateList.add(object);
  }


  @Override
  //重写equals方法判断CacheKey是否相同
  public boolean equals(Object object) {
    if (this == object) {
      return true;
    }
    if (!(object instanceof CacheKey)) {
      return false;
    }

    final CacheKey cacheKey = (CacheKey) object;

    if (hashcode != cacheKey.hashcode) {
      return false;
    }
    if (checksum != cacheKey.checksum) {
      return false;
    }
    if (count != cacheKey.count) {
      return false;
    }
    //比较updateList中每一项
    for (int i = 0; i &amp;lt; updateList.size(); i++) {
      Object thisObject = updateList.get(i);
      Object thatObject = cacheKey.updateList.get(i);
      if (!ArrayUtil.equals(thisObject, thatObject)) {
        return false;
      }
    }
    return true;
  }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;一级缓存是session级别缓存，只存在当前会话中，在没有任何配置下，MyBatis默认开启一级缓存，当一个SqlSession第一次执行SQL语句和参数查询时，将生成的CacheKey和查询结果放入缓存中，下一次通过相同的SQL语句和参数查询时，就会从缓存中获取，当进行更新或者插入操作时，一级缓存会进行清空。在上一篇中说到，MayBatis进行一级缓存查询和写入是由BaseExecutor执行的，源码如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始化缓存：&lt;br/&gt;一级缓存是Cache接口的PerpetualCache实现类对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public abstract class BaseExecutor implements Executor {

  ...
  protected PerpetualCache localCache;
  protected PerpetualCache localOutputParameterCache;
  protected Configuration configuration;

  protected int queryStack;
  private boolean closed;

  protected BaseExecutor(Configuration configuration, Transaction transaction) {
    this.transaction = transaction;
    this.deferredLoads = new ConcurrentLinkedQueue&amp;lt;DeferredLoad&amp;gt;();
    //一级缓存初始化
    this.localCache = new PerpetualCache(&quot;LocalCache&quot;);
    this.localOutputParameterCache = new PerpetualCache(&quot;LocalOutputParameterCache&quot;);
    this.closed = false;
    this.configuration = configuration;
    this.wrapper = this;
  }
...&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;生成CacheKey&lt;br/&gt;key在CachingExecutor中生成，CacheKey的updateList中放入了MappedStatement,传入SQL的参数，结果集范围rowBounds和boundSql:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
    BoundSql boundSql = ms.getBoundSql(parameterObject);
    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);
    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;将查询结果和CacheKey放入缓存：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;private &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    List&amp;lt;E&amp;gt; list;
    //缓存中放入CacheKey和占位符
    localCache.putObject(key, EXECUTION_PLACEHOLDER);
    try {
      //在数据库中查询操作
      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
    } finally {
      localCache.removeObject(key);
    }
    //缓存中放入CacheKey和结果集
    localCache.putObject(key, list);
    if (ms.getStatementType() == StatementType.CALLABLE) {
      localOutputParameterCache.putObject(key, parameter);
    }
    //返回结果
    return list;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;再次执行相同查询条件时从缓存获取结果：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());
    if (closed) {
      throw new ExecutorException(&quot;Executor was closed.&quot;);
    }
    if (queryStack == 0 &amp;amp;&amp;amp; ms.isFlushCacheRequired()) {
      clearLocalCache();
    }
    List&amp;lt;E&amp;gt; list;
    try {
      queryStack++;
      //从缓存获取结果
      list = resultHandler == null ? (List&amp;lt;E&amp;gt;) localCache.getObject(key) : null;
      if (list != null) {
        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
      } else {
      //未命中缓存，则从数据库查询
        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
      }
    } finally {
      queryStack--;
    }
    if (queryStack == 0) {
      for (DeferredLoad deferredLoad : deferredLoads) {
        deferredLoad.load();
      }
      // issue #601
      deferredLoads.clear();
      if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
        // issue #482
        clearLocalCache();
      }
    }
    return list;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;更新操作时清空缓存：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; public int update(MappedStatement ms, Object parameter) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing an update&quot;).object(ms.getId());
    if (closed) {
      throw new ExecutorException(&quot;Executor was closed.&quot;);
    }
    //清空缓存
    clearLocalCache();
    return doUpdate(ms, parameter);
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过以下代码验证下，分别开两个session进行相同的查询，第一个session查询两次：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void testSelect() {
        SqlSession sqlSession = sqlSessionFactory.openSession();
        User user = sqlSession.selectOne(&quot;findUserById&quot;, 1);
        System.out.println(user);
        User user2 = sqlSession.selectOne(&quot;findUserById&quot;, 1);
        System.out.println(user2);
        sqlSession.close();
        System.out.println(&quot;sqlSession closed!===================================&quot;);
        //新建会话
        SqlSession sqlSession2 = sqlSessionFactory.openSession();
        User user3 = sqlSession2.selectOne(&quot;findUserById&quot;, 1);
        System.out.println(user3);
        sqlSession2.close();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把日志设置为DEBUG级别得到运行日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DEBUG [main] - ==&amp;gt;  Preparing: SELECT * FROM user WHERE id = ? 
DEBUG [main] - ==&amp;gt; Parameters: 1(Integer)
DEBUG [main] - &amp;lt;==      Total: 1
User [id=1, username=小明, birthday=null, sex=1, address=四川成都]
User [id=1, username=小明, birthday=null, sex=1, address=四川成都]
DEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@16022d9d]
DEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@16022d9d]
DEBUG [main] - Returned connection 369241501 to pool.
sqlSession closed!===================================
DEBUG [main] - Opening JDBC Connection
DEBUG [main] - Checked out connection 369241501 from pool.
DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@16022d9d]
DEBUG [main] - ==&amp;gt;  Preparing: SELECT * FROM user WHERE id = ? 
DEBUG [main] - ==&amp;gt; Parameters: 1(Integer)
DEBUG [main] - &amp;lt;==      Total: 1
User [id=1, username=小明, birthday=null, sex=1, address=四川成都]
DEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@16022d9d]
DEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@16022d9d]
DEBUG [main] - Returned connection 369241501 to pool.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一次会话中，虽然查询了两次id为1的用户，但是只执行了一次SQL，关闭会话后开启一次新的会话，再次查询id为1的用户，SQL再次执行，说明了一级缓存只存在SqlSession中，不同SqlSession不能共享。&lt;/p&gt;

&lt;p&gt;二级缓存是Mapper级别缓存，也就是同一Mapper下不同的session共享二级缓存区域。&lt;br/&gt;只需要在XML映射文件中增加cache标签或cache-ref标签标签就可以开启二级缓存，cache-ref标签配置的是共享其指定Mapper的二级缓存区域。具体配置信息如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;blocking : 是否使用阻塞缓存&lt;/li&gt;
&lt;li&gt;readOnly : 是否只读&lt;/li&gt;
&lt;li&gt;eviction: 缓存策略，可指定Cache接口下装饰器类FifoCache、LruCache、SoftCache和WeakCache&lt;/li&gt;
&lt;li&gt;flushInterval : 自动刷新缓存时间&lt;/li&gt;
&lt;li&gt;size : 设置缓存个数&lt;/li&gt;
&lt;li&gt;type : 设置缓存类型，用于自定义缓存类，默认为PerpetualCache&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;二级缓存是在MyBatis的解析配置文件时初始化，在XMLMapperBuilder中将缓存配置解析：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void cacheElement(XNode context) throws Exception {
    if (context != null) {
      //指定默认类型为PerpetualCache
      String type = context.getStringAttribute(&quot;type&quot;, &quot;PERPETUAL&quot;);
      Class&amp;lt;? extends Cache&amp;gt; typeClass = typeAliasRegistry.resolveAlias(type);
      //默认缓存策略为LruCache
      String eviction = context.getStringAttribute(&quot;eviction&quot;, &quot;LRU&quot;);
      Class&amp;lt;? extends Cache&amp;gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);
      Long flushInterval = context.getLongAttribute(&quot;flushInterval&quot;);
      Integer size = context.getIntAttribute(&quot;size&quot;);
      boolean readWrite = !context.getBooleanAttribute(&quot;readOnly&quot;, false);
      boolean blocking = context.getBooleanAttribute(&quot;blocking&quot;, false);
      Properties props = context.getChildrenAsProperties();
      //委托builderAssistant构建二级缓存
      builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构建过程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Cache useNewCache(Class&amp;lt;? extends Cache&amp;gt; typeClass,
      Class&amp;lt;? extends Cache&amp;gt; evictionClass,
      Long flushInterval,
      Integer size,
      boolean readWrite,
      boolean blocking,
      Properties props) {
    Cache cache = new CacheBuilder(currentNamespace)
        //设置缓存类型，默认为PerpetualCache
        .implementation(valueOrDefault(typeClass, PerpetualCache.class))
        //设置缓存策略，默认使用LruCache装饰器
        .addDecorator(valueOrDefault(evictionClass, LruCache.class))
        //设置刷新时间
        .clearInterval(flushInterval)
        //设置大小
        .size(size)
        //设置是否只读
        .readWrite(readWrite)
        .blocking(blocking)
        .properties(props)
        .build();
    configuration.addCache(cache);
    currentCache = cache;
    return cache;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终得到默认的二级缓存对象结构为：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1175086/201809/1175086-20180921231630252-95335430.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CachingExecutor将初始化的Cache对象用TransactionalCache包装后放入TransactionalCacheManager的Map中，下面代码中的tcm就是TransactionalCacheManager对象，CachingExecutor执行二级缓存操作过程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)
      throws SQLException {
    //从Configuration的MappedStatement中获取二级缓存
    Cache cache = ms.getCache();
    if (cache != null) {
     //判断是否需要刷新缓存，SELECT不刷新，INSERT|UPDATE|DELETE刷新缓存
      flushCacheIfRequired(ms);
      if (ms.isUseCache() &amp;amp;&amp;amp; resultHandler == null) {
        ensureNoOutParams(ms, boundSql);
        @SuppressWarnings(&quot;unchecked&quot;)
        //从二级缓存中获取数据
        List&amp;lt;E&amp;gt; list = (List&amp;lt;E&amp;gt;) tcm.getObject(cache, key);
        if (list == null) {
          //委托BaseExecutor查询
          list = delegate.&amp;lt;E&amp;gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
          //查询结果放入二级缓存
          tcm.putObject(cache, key, list); // issue #578 and #116
        }
        return list;
      }
    }
    return delegate.&amp;lt;E&amp;gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过之前一级缓存的例子验证二级缓存，只需要在UserMapper映射文件中加入cache标签，并且让相关POJO类实现java.io.Serializable接口，运行得到日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DEBUG [main] - ==&amp;gt;  Preparing: SELECT * FROM user WHERE id = ? 
DEBUG [main] - ==&amp;gt; Parameters: 1(Integer)
DEBUG [main] - &amp;lt;==      Total: 1
User [id=1, username=小明, birthday=null, sex=1, address=四川成都]
DEBUG [main] - Cache Hit Ratio [com.kkb.mybatis.mapper.UserMapper]: 0.0
User [id=1, username=小明, birthday=null, sex=1, address=四川成都]
DEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@5c072e3f]
DEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@5c072e3f]
DEBUG [main] - Returned connection 1543974463 to pool.
sqlSession closed!===================================
DEBUG [main] - Cache Hit Ratio [com.kkb.mybatis.mapper.UserMapper]: 0.3333333333333333
User [id=1, username=小明, birthday=null, sex=1, address=四川成都]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不同session查询同一条记录时，总共只执行了一次SQL语句，并且日志打印出了缓存的命中率，这时候不同session已经共享了二级缓存区域。&lt;br/&gt;[1]: https://www.cnblogs.com/abcboy/p/9656302.html&lt;/p&gt;
</description>
<pubDate>Fri, 21 Sep 2018 15:17:00 +0000</pubDate>
<dc:creator>AbcBoy</dc:creator>
<og:description>上一篇[MyBatis框架原理2：SqlSession运行过程][1]介绍了MyBatis的工作流程，其中涉及到了MyBatis缓存的使用，首先回顾一下工作流程图： 如果开启了二级缓存，数据查询执行过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/abcboy/p/9688961.html</dc:identifier>
</item>
<item>
<title>高并发第九弹:逃不掉的Map --&gt; HashMap,TreeMap,ConcurrentHashMap - 爱呼吸的鱼</title>
<link>http://www.cnblogs.com/aihuxi/p/9688711.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aihuxi/p/9688711.html</guid>
<description>&lt;p&gt;平时大家都会经常使用到 Map,面试的时候又经常会遇到问Map的,其中主要就是 &lt;span&gt;&lt;strong&gt;ConcurrentHashMap&lt;/strong&gt;,在说ConcurrentHashMap.我们还是先看一下,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其他两个基础的 Map 类: HashMap  和 TreeMap&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img-blog.csdn.net/20161027110129194&quot; alt=&quot;&quot; width=&quot;624&quot; height=&quot;443&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap: &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HashMap&amp;lt;K,V&amp;gt; &lt;span&gt;extends&lt;/span&gt; AbstractMap&amp;lt;K,V&amp;gt;
    &lt;span&gt;implements&lt;/span&gt; Map&amp;lt;K,V&amp;gt;, Cloneable,Serializable {   // 这里有个很逗的事情 hashMap 继承了AvstractMap 为什么还要实现Map? 据说,作者说的 这只是个错误的写法 Q_Q
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TreeMap:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TreeMap&amp;lt;K,V&amp;gt;
    &lt;span&gt;extends&lt;/span&gt; AbstractMap&amp;lt;K,V&amp;gt;
    &lt;span&gt;implements&lt;/span&gt; NavigableMap&amp;lt;K,V&amp;gt;, Cloneable, java.io.Serializable&lt;p&gt;public interface NavigableMap&amp;lt;K,V&amp;gt; extends SortedMap&amp;lt;K,V&amp;gt; 
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;实现&lt;/td&gt;
&lt;td&gt;存储&lt;/td&gt;
&lt;td&gt;遍历&lt;/td&gt;
&lt;td&gt;性能损耗&lt;/td&gt;
&lt;td&gt;键值对&lt;/td&gt;
&lt;td&gt;安全&lt;/td&gt;
&lt;td&gt;效率&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;TreeMap&lt;/td&gt;
&lt;td&gt;SortMap接口，基于红黑树 &lt;/td&gt;
&lt;td&gt;默认按键的升序排序 &lt;/td&gt;
&lt;td&gt;Iterator遍历是排序的&lt;/td&gt;
&lt;td&gt;插入、删除&lt;/td&gt;
&lt;td&gt;键、值都不能为null &lt;/td&gt;
&lt;td&gt;非并发安全Map &lt;/td&gt;
&lt;td&gt;适用于在Map中插入、删除和定位元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;HashMap&lt;/td&gt;
&lt;td&gt;基于哈希散列表实现&lt;/td&gt;
&lt;td&gt;随机存储&lt;/td&gt;
&lt;td&gt;Iterator遍历是随机的 &lt;/td&gt;
&lt;td&gt;基本无&lt;/td&gt;
&lt;td&gt;只允许键、值均为null&lt;/td&gt;
&lt;td&gt;非并发安全Map&lt;/td&gt;
&lt;td&gt;适用于按自然顺序或自定义顺序遍历键(key)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;br/&gt;&lt;span&gt;HashMap通常比TreeMap快一点(树和哈希表的数据结构使然)，建议多使用HashMap，在需要排序的Map时候才用TreeMap。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;那么现在就聊一下 HashMap和ConcurrentHashMap &lt;/strong&gt; &lt;br/&gt;&lt;span&gt;我们都知道ConcurrentHashMap 是线程安全的.那为什么HashMap就线程不安全了呢?&lt;br/&gt;这里有很不错的解释&lt;a href=&quot;https://my.oschina.net/hosee/blog/673521&quot; target=&quot;_blank&quot;&gt;https://my.oschina.net/hosee/blog/673521&lt;/a&gt;&lt;br/&gt;还有一个路径太长了.给个短的 &lt;a title=&quot;也还可以就是路径太长了&quot; href=&quot;https://blog.csdn.net/jesonjoke/article/details/79978855#3hashmap%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E5%8E%9F%E5%9B%A0%E4%B8%80%E6%AD%BB%E5%BE%AA%E7%8E%AF&quot; target=&quot;_blank&quot;&gt;还可以的&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;总结起来就是:&lt;br/&gt;　　&lt;/span&gt;&lt;span&gt;1. resize死循环&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　　　&lt;span&gt;我们都知道HashMap初始容量大小为16,一般来说，当有数据要插入时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大Hash表的尺寸，但是这样一来，整个Hash表里的元素都需要被重算一遍。这叫rehash，这个成本相当的大。&lt;br/&gt;在rehash的时候,在多线程的时候容易造成环形链表&lt;br/&gt;　　2.fail-fast &lt;br/&gt;　　　如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;这个异常意在提醒开发者及早意识到线程安全问题，具体原因请查看&lt;a href=&quot;http://my.oschina.net/hosee/blog/612718&quot; rel=&quot;nofollow&quot;&gt;ConcurrentModificationException的原因以及解决措施&lt;/a&gt;  看了这个 我觉得需要去修改一下我原来说的CopyAndWriteArrayList 了&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;ConcurrentHashMap来了.面试以前遇到了很多次&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;（1）结构 [Java7与Java8不同]&lt;/p&gt;
&lt;p&gt;JDK7&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180418110431880?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2plc29uam9rZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot; width=&quot;528&quot; height=&quot;386&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.ConcurrentHashMap中的分段锁称为Segment,它即类似于HashMap（&lt;a class=&quot;external&quot; href=&quot;http://my.oschina.net/hosee/blog/618953&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;JDK7与JDK8中HashMap的实现&lt;/a&gt;）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock）&lt;/p&gt;
&lt;p&gt;2 . 当我们读取某个Key的时候它先取出key的Hash值，并将Hash值得高sshift位与Segment的个数取模，决定key属于哪个Segment。接着像HashMap一样操作Segment。 为了保证不同的Hash值保存到不同的Segment中，ConcurrentHashMap对Hash值也做了专门的优化。&lt;/p&gt;
&lt;p&gt;3. 如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。（文档的说法是根据你并发的线程数量决定，太多会导性能降低）&lt;/p&gt;
&lt;h2 id=&quot;h2_9&quot;&gt;2. JDK8中的实现&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180418111414251?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2plc29uam9rZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot; width=&quot;364&quot; height=&quot;387&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ConcurrentHashMap在JDK8中进行了巨大改动，很需要通过源码来再次学习下Doug Lea的实现方法。&lt;/p&gt;
&lt;p&gt;它摒弃了Segment（锁段）的概念，而是启用了一种全新的方式实现,利用CAS算法。它沿用了与它同时期的HashMap版本的思想，底层依然由“数组”+链表+红黑树的方式思想(&lt;a class=&quot;external&quot; href=&quot;http://my.oschina.net/hosee/blog/618953&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;JDK7与JDK8中HashMap的实现&lt;/a&gt;)，但是为了做到并发，又增加了很多辅助的类，例如TreeBin，Traverser等对象内部类。&lt;/p&gt;
&lt;h2 id=&quot;h2_28&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;JDK6,7中的ConcurrentHashmap主要使用Segment来实现减小锁粒度，把HashMap分割成若干个Segment，在put的时候需要锁住Segment，get时候不加锁，使用volatile来保证可见性，当要统计全局时（比如size），首先会尝试多次计算modcount来确定，这几次尝试中，是否有其他线程进行了修改操作，如果没有，则直接返回size。如果有，则需要依次锁住所有的Segment来计算。&lt;/p&gt;
&lt;p&gt;jdk7中ConcurrentHashmap中，当长度过长碰撞会很频繁，链表的增改删查操作都会消耗很长的时间，影响性能,所以jdk8 中完全重写了concurrentHashmap,代码量从原来的1000多行变成了 6000多 行，实现上也和原来的分段式存储有很大的区别。&lt;/p&gt;
&lt;p&gt;主要设计上的变化有以下几点:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不采用segment而采用node，锁住node来实现减小锁粒度。&lt;/li&gt;
&lt;li&gt;设计了MOVED状态 当resize的中过程中 线程2还在put数据，线程2会帮助resize。&lt;/li&gt;
&lt;li&gt;使用3个CAS操作来确保node的一些操作的原子性，这种方式代替了锁。&lt;/li&gt;
&lt;li&gt;sizeCtl的不同值来代表不同含义，起到了控制的作用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;至于为什么JDK8中使用synchronized而不是ReentrantLock，我猜是因为JDK8中对synchronized有了足够的优化吧。&lt;/p&gt;
&lt;p&gt;总结: &lt;/p&gt;
&lt;p&gt;HashMap非线程安全、ConcurrentHashMap线程安全      (可以看下这个,很有&lt;a class=&quot;external&quot; href=&quot;http://my.oschina.net/hosee/blog/675423&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;ConcurrentHashMap能完全替代HashTable吗？&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;HashMap允许Key与Value为空，ConcurrentHashMap不允许&lt;/p&gt;
&lt;p&gt;HashMap不允许通过迭代器遍历的同时修改，ConcurrentHashMap允许。并且更新可见&lt;/p&gt;
</description>
<pubDate>Fri, 21 Sep 2018 15:11:00 +0000</pubDate>
<dc:creator>爱呼吸的鱼</dc:creator>
<og:description>平时大家都会经常使用到 Map,面试的时候又经常会遇到问Map的,其中主要就是 ConcurrentHashMap,在说ConcurrentHashMap.我们还是先看一下, 其他两个基础的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aihuxi/p/9688711.html</dc:identifier>
</item>
<item>
<title>socket传送二进制流的一些总结 - 随性者也</title>
<link>http://www.cnblogs.com/zhugaopeng/p/9688882.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhugaopeng/p/9688882.html</guid>
<description>&lt;p&gt;第一次实质性的接触socket通信方面的工作，所以遇到的问题还真不少，写篇博客记录一下，提升下记忆。&lt;/p&gt;
&lt;p&gt;需求是通过私有协议进行二进制数据的传输，必须保证数据包不能被丢失，所以选择tcp的socket进行通信。&lt;/p&gt;
&lt;p&gt;1. 遇到的第一个问题是客户端与服务端的socket通信没有保持持续的连接状态&lt;/p&gt;
&lt;p&gt;   这个是一个想当然的错误。想当然的以为TCP是有连接的通信，但是你如果长时间不通信，服务端一直保持着通信，这对服务器资源是一种极大的浪费。客户端与服务端的连接是需要占用一定资源的，而服务端的资源是有限的。如果一直保持连接状态，那么你的服务器的性能肯定是有问题的。&lt;/p&gt;
&lt;p&gt;   解决这个问题的办法是保活。服务端发送心跳包，客户端接受到之后进行回应。客户端告诉服务器，还在线，不要断开连接。如果客户端长时间没有回应，服务器断开与此客户端的连接，减少资源占用。&lt;/p&gt;

&lt;p&gt;2. 二进制文件的读写问题&lt;/p&gt;
&lt;p&gt;    第一次尝试读取二进制文件采取了分段读取的方式。测试过程中发现一个很大的问题：文件读取到部分就会中断读取。debug下，得出是读取到了空字符('\0')。这个直接导致一次读取到内容在发送前丢失，甚至有些情况下会有空字符，客户端接受时会产生崩溃现象。&lt;/p&gt;
&lt;p&gt;   既然分段不行，就干脆全部读取，然后在分段发送。boost.asio库支持对vector包装发送，分段发送时，把一块二进制流拷贝到vector中，然后整体发送。&lt;/p&gt;

&lt;p&gt;3. 提高二进制流的传输效率&lt;/p&gt;
&lt;p&gt;   直接传输二进制流不是一个高效的行为，也不是一个安全的行为。直接发送一个二进制流很容易被截获，从而导致信息泄露。&lt;/p&gt;
&lt;p&gt;   提高二进制流传输效率的办法就是加密压缩再发送。服务器加密压缩，客户端解密解压缩。可采取两种方式：&lt;/p&gt;
&lt;p&gt;   1）整体压缩，分段发送&lt;/p&gt;
&lt;p&gt;   2）分段压缩，分段发送&lt;/p&gt;
&lt;p&gt;   要求不是很高的话，采取方式一比较好。简单粗暴。。&lt;/p&gt;

&lt;p&gt;贴一些代码，整体读取二进制文件的：&lt;/p&gt;
&lt;p&gt;先是C++的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt; fileName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/XtAmpClient/XtAmpTradeClient_x64_3.0.1.14473.exe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    ifstream ifs(fileName, ios_base::binary);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     filebuf* pbuf =&lt;span&gt; ifs.rdbuf();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; size = pbuf-&amp;gt;pubseekoff(&lt;span&gt;0&lt;/span&gt;, ios_base::end, ios_base::&lt;span&gt;in&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     pbuf-&amp;gt;pubseekpos(&lt;span&gt;0&lt;/span&gt;, ios_base::&lt;span&gt;in&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt;* buf = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;&lt;span&gt;[size];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     pbuf-&amp;gt;&lt;span&gt;sgetn(buf, size);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    ifs.close();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;delete&lt;/span&gt; []buf;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后是C的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* fileName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/XtAmpClient/XtAmpTradeClient_x64_3.0.1.14473.exe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     FILE* fp = fopen(fileName, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (NULL ==&lt;span&gt; fp)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;open file failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     fseek(fp, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, SEEK_END);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; size =&lt;span&gt; ftell(fp);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    rewind(fp);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt;* buffer = (&lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;char&lt;/span&gt;) *&lt;span&gt; size);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (NULL ==&lt;span&gt; buffer)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;malloc failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; ret = fread(buffer, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, size, fp);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (ret !=&lt;span&gt; size)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reading failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    fclose(fp);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;free&lt;/span&gt;(buffer);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;性能上C比C++好一点点，但是C++的代码明显更简洁。&lt;/p&gt;
</description>
<pubDate>Fri, 21 Sep 2018 14:48:00 +0000</pubDate>
<dc:creator>随性者也</dc:creator>
<og:description>第一次实质性的接触socket通信方面的工作，所以遇到的问题还真不少，写篇博客记录一下，提升下记忆。 需求是通过私有协议进行二进制数据的传输，必须保证数据包不能被丢失，所以选择tcp的socket进行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhugaopeng/p/9688882.html</dc:identifier>
</item>
<item>
<title>玩转ASP.NET Core中的日志组件 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/9683482.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/9683482.html</guid>
<description>&lt;p&gt;&lt;strong&gt;日志组件&lt;/strong&gt;，作为程序员使用频率最高的组件，给程序员开发调试程序提供了必要的信息。ASP.NET Core中内置了一个通用日志接口&lt;code&gt;ILogger&lt;/code&gt;，并实现了多种内置的日志提供器，例如&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Console&lt;/li&gt;
&lt;li&gt;Debug&lt;/li&gt;
&lt;li&gt;EventSource&lt;/li&gt;
&lt;li&gt;EventLog&lt;/li&gt;
&lt;li&gt;TraceSource&lt;/li&gt;
&lt;li&gt;Azure App Service&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了内置的日志提供器，ASP.NET Core还支持了多种第三方日志工具，例如&lt;/p&gt;
&lt;p&gt;开发人员在ASP.Net Core中可以自由指定日志提供器，并将日志发送到指定的位置。&lt;br/&gt;本篇博文中，我们将由浅入深的介绍ASP.Net Core中通用日志接口，最后我们将实现一些自定义的日志提供器(Log Provider)。&lt;/p&gt;

&lt;h2 id=&quot;日志级别log-level&quot;&gt;日志级别(Log Level)&lt;/h2&gt;
&lt;p&gt;ASP.NET Core中提供了6种日志级别，分别是Trace, Debug, Information, Warning, Error, Critical。以下是他们的具体使用场景&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;Trace&lt;/td&gt;
&lt;td&gt;记录一些对程序员调试问题有帮助的信息,&lt;br/&gt;其中可能包含一些敏感信息, 所以应该避免在&lt;br/&gt;生产环境中启用Trace日志&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;Debug&lt;/td&gt;
&lt;td&gt;记录一些在开发和调试阶段有用的短时变&lt;br/&gt;量(Short-term usefulness), 所以除非为了临时排除生产环境的&lt;br/&gt;故障，开发人员应该尽量避免在生产环境中启用Debug日志&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;Information&lt;/td&gt;
&lt;td&gt;记录应用程序的一些流程, 例如，记录当前api请求的url&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;Warning&lt;/td&gt;
&lt;td&gt;记录应用程序中发生的不正常或者未预期的事件信息。&lt;br/&gt;这些信息中可能包含错误消息或者错误产生的条件, 例如, 文件未找到&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Error&lt;/td&gt;
&lt;td&gt;记录应用程序中某个操作产生的错误和异常信息。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Critical&lt;/td&gt;
&lt;td&gt;记录一些需要立刻修复的问题。例如数据丢失，磁盘空间不足。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;如何创建日志&quot;&gt;如何创建日志&lt;/h2&gt;
&lt;p&gt;为了创建一个日志，我们首先需要通过依赖注入获取一个实现ILogger&amp;lt;日志类别&amp;gt;的泛型接口对象。&lt;/p&gt;
&lt;p&gt;已以下代码为例, 在&lt;code&gt;ValuesController&lt;/code&gt;的构造函数中，我们注入了一个&lt;code&gt;ILogger&lt;/code&gt;的日志记录器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    [Route(&quot;api/[controller]&quot;)]
    [ApiController]
    public class ValuesController : ControllerBase
    {
        private readonly ILogger&amp;lt;ValuesController&amp;gt; _logger = null;

        public ValuesController(ILogger&amp;lt;ValuesController&amp;gt; logger)
        {
            _logger = logger;
        }

        // GET api/values
        [HttpGet]
        public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
        {
            _logger.LogInformation(&quot;[Test Log]Getting items.&quot;);
            return new string[] { &quot;value1&quot;, &quot;value2&quot; };
        }


    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们使用&lt;code&gt;ILogger&lt;/code&gt;接口提供的&lt;code&gt;LogInformation&lt;/code&gt;方法添加了一个Information类型日志&quot;[Test Log]Getting items&quot;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：&lt;code&gt;ILogger&lt;/code&gt;为了提供了6个可用的输出日志方法，分别对应了6个不同的日志级别&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;LogTrace&lt;/li&gt;
&lt;li&gt;LogDebug&lt;/li&gt;
&lt;li&gt;LogInformation&lt;/li&gt;
&lt;li&gt;LogWarning&lt;/li&gt;
&lt;li&gt;LogError&lt;/li&gt;
&lt;li&gt;LogCritical!&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;下面我们使用Kestral服务器启动项目&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201809/65831-20180921212856486-815180648.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目产生的日志如下，我们手动输出的日志出现在控制台中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201809/65831-20180921212922423-906742638.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;日志配置&quot;&gt;日志配置&lt;/h2&gt;
&lt;p&gt;可能针对以上的代码，有些同学可能有疑问，我们没有在Startup.cs中注入任何日志提供器，但是日志却正常产生了。这是由于Program.cs中默认使用WebHost.CreateDefaultBuilder方法添加了2个日志提供器。&lt;/p&gt;
&lt;h3 id=&quot;默认日志提供器&quot;&gt;默认日志提供器&lt;/h3&gt;
&lt;p&gt;当创建一个新的ASP.NET Core WebApi项目，我们通常在Program.cs中看到以下代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class Program
    {
        public static void Main(string[] args)
        {
            CreateWebHostBuilder(args).Build().Run();
        }

        public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
            WebHost.CreateDefaultBuilder(args)
                .UseStartup&amp;lt;Startup&amp;gt;();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们看一下WebHost.CreateDefaultBuilder的源代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static IWebHostBuilder CreateDefaultBuilder(string[] args)
    {
        var builder = new WebHostBuilder()
            .UseKestrel()
            .UseContentRoot(Directory.GetCurrentDirectory())
            .ConfigureAppConfiguration((hostingContext, config) =&amp;gt;
            {
                var env = hostingContext.HostingEnvironment;

                config.AddJsonFile(&quot;appsettings.json&quot;, optional: true, reloadOnChange: true)
                      .AddJsonFile($&quot;appsettings.{env.EnvironmentName}.json&quot;, optional: true, reloadOnChange: true);

                if (env.IsDevelopment())
                {
                    var appAssembly = Assembly.Load(new AssemblyName(env.ApplicationName));
                    if (appAssembly != null)
                    {
                        config.AddUserSecrets(appAssembly, optional: true);
                    }
                }

                config.AddEnvironmentVariables();

                if (args != null)
                {
                    config.AddCommandLine(args);
                }
            })
            .ConfigureLogging((hostingContext, logging) =&amp;gt;
            {
                logging.UseConfiguration(hostingContext.Configuration.GetSection(&quot;Logging&quot;));
                logging.AddConsole();
                logging.AddDebug();
            })
            .UseIISIntegration()
            .UseDefaultServiceProvider((context, options) =&amp;gt;
            {
                options.ValidateScopes = context.HostingEnvironment.IsDevelopment();
            })
            .ConfigureServices(services =&amp;gt;
            {
                services.AddTransient&amp;lt;IConfigureOptions&amp;lt;KestrelServerOptions&amp;gt;, KestrelServerOptionsSetup&amp;gt;();
            });

        return builder;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你会发现代码中通过&lt;code&gt;logging.AddConsole&lt;/code&gt;和&lt;code&gt;logging.AddDebug&lt;/code&gt;默认配置了Console和Debug类型的日志提供器，这也就是为什么我们没有注入任何日志提供器，日志却能正常产生了。&lt;/p&gt;
&lt;h3 id=&quot;手动添加日志提供器&quot;&gt;手动添加日志提供器&lt;/h3&gt;
&lt;p&gt;看了以上代码后，你应该可以也清楚了如何自己添加其他内置的日志提供器。我们只需要在Program.cs中使用ConfigureLogging方法就可以配置我们需要的日志提供器了。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class Program
    {
        public static void Main(string[] args)
        {
            CreateWebHostBuilder(args).Build().Run();
        }

        public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
            WebHost.CreateDefaultBuilder(args)
            .ConfigureLogging((hostingContext, logging) =&amp;gt;
            {
                logging.AddConsole();
                logging.AddDebug();
                logging.AddEventSourceLogger();
            })
            .UseStartup&amp;lt;Startup&amp;gt;();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了在Program.cs添加日志提供器之外，我们还可以在Startup.cs中添加日志提供器。&lt;br/&gt;在Startup.cs中，我们可以为Configure方法添加第三个参数&lt;code&gt;ILoggerFactory loggerFactory&lt;/code&gt;, 并使用该参数添加日志提供器。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }

        loggerFactory.AddConsole();
        loggerFactory.AddDebug();
        
        app.UseMvc();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置文件及日志级别过滤&quot;&gt;配置文件及日志级别过滤&lt;/h3&gt;
&lt;p&gt;ASP.NET Core默认会从appSetting.json中的Logging属性读取日志的配置(当然你也可以从其他文件中读取配置)，这里设置了不同的日志提供器产生的最低的日志级别，配置样例如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;Logging&quot;: {
    &quot;Debug&quot;: {
      &quot;LogLevel&quot;: {
        &quot;Default&quot;: &quot;Information&quot;
      }
    },
    &quot;Console&quot;: {
      &quot;LogLevel&quot;: {
        &quot;Microsoft.AspNetCore.Mvc.Razor.Internal&quot;: &quot;Warning&quot;,
        &quot;Microsoft.AspNetCore.Mvc.Razor.Razor&quot;: &quot;Debug&quot;,
        &quot;Microsoft.AspNetCore.Mvc.Razor&quot;: &quot;Error&quot;,
        &quot;Default&quot;: &quot;Trace&quot;
      }
    },
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Debug&quot;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码中的Debug表示Debug日志提供器, Console表示Console日志提供器, 最后一个LogLevel表示其他日志提供器通用。&lt;br/&gt;Debug中的Default设置为Information, 即Debug中产生的日志最低级别是Information, 低于Information级别的日志不会输出。Console中的配置同理。&lt;/p&gt;

&lt;p&gt;在学习了以上基础知识之后，我们应该对内置的日志提供器有了简单的认识。下面我们尝试自定义2个日志提供器。&lt;br/&gt;在ASP.NET Core中，我们可以通过实现&lt;code&gt;ILogger&lt;/code&gt;, &lt;code&gt;ILoggerProvider&lt;/code&gt;2个接口来创建我们自己的日志提供器。&lt;/p&gt;
&lt;h2 id=&quot;编写一个自定义样式的控制台日志组件&quot;&gt;编写一个自定义样式的控制台日志组件&lt;/h2&gt;
&lt;p&gt;这里我们希望添加一个在控制台中输出的日志，但是和内置Console类型日志的区别是我们为不同的日志类型设置了不同的颜色。&lt;/p&gt;
&lt;p&gt;首先我们创建一个新的Api项目ColoredConsoleLoggerSample&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201809/65831-20180921212944855-1277713354.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们创建一个针对不同日志级别的字体颜色配置类&lt;code&gt;ColoredConsoleLoggerConfiguration&lt;/code&gt;, 代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class ColoredConsoleLoggerConfiguration
    {
        public LogLevel LogLevel { get; set; } = LogLevel.Warning;
        public ConsoleColor Color { get; set; } = ConsoleColor.Yellow;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类中定义了针对不同日志类型设置不同的字体颜色。&lt;/p&gt;
&lt;p&gt;然后我们创建一个日志类&lt;code&gt;ColoredConsoleLogger&lt;/code&gt;, 它实现了&lt;code&gt;ILogger&lt;/code&gt;接口，代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class ColoredConsoleLogger : ILogger
    {
        private readonly string _name;
        private readonly ColoredConsoleLoggerConfiguration _config;

        public ColoredConsoleLogger(string name, ColoredConsoleLoggerConfiguration config)
        {
            _name = name;
            _config = config;
        }

        public IDisposable BeginScope&amp;lt;TState&amp;gt;(TState state)
        {
            return null;
        }

        public bool IsEnabled(LogLevel logLevel)
        {
            return logLevel == _config.LogLevel;
        }

        public void Log&amp;lt;TState&amp;gt;(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func&amp;lt;TState, Exception, string&amp;gt; formatter)
        {
            if (!IsEnabled(logLevel))
            {
                return;
            }
            
            var color = Console.ForegroundColor;
            Console.ForegroundColor = _config.Color;
            Console.WriteLine($&quot;{logLevel.ToString()} - {_name} - {formatter(state, exception)}&quot;);
            Console.ForegroundColor = color;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码解释&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ColoredConsoleLogger仅针对一种日志级别&lt;/li&gt;
&lt;li&gt;只要当前产生的日志级别和ColoredConsoleLogger中定义的日志级别一样时，日志才会输出，这里我们是用&lt;code&gt;IsEnable&lt;/code&gt;方法判断的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Log&lt;/code&gt;是ILogger接口中定义的方法，我们就是在这个方法中输出日志的&lt;/li&gt;
&lt;li&gt;这里我们在输入日志前记录下了当前控制台的原始字体颜色， 当输出日志完成之后，我们将字体颜色恢复成了原来的颜色&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后我们添加一个Logger提供器类&lt;code&gt;ColoredConsoleLoggerProvider&lt;/code&gt;，代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class ColoredConsoleLoggerProvider : ILoggerProvider
    {
        private readonly ColoredConsoleLoggerConfiguration _config;

        public ColoredConsoleLoggerProvider(ColoredConsoleLoggerConfiguration config)
        {
            _config = config;
        }

        public ILogger CreateLogger(string categoryName)
        {
            return new ColoredConsoleLogger(categoryName, _config);
        }

        public void Dispose()
        {

        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码解释&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ColoredConsoleLoggerProvider仅针对一种日志级别&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CreateLogger&lt;/code&gt;是&lt;code&gt;ILoggerProvider&lt;/code&gt;接口中定义的方法，它是用来返回一个日志生成器的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后我们修改Startup.cs中的Configure方法, 代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }
        
        loggerFactory.AddProvider(new ColoredConsoleLoggerProvider(new ColoredConsoleLoggerConfiguration
        {
            LogLevel = LogLevel.Information,
            Color = ConsoleColor.Blue
        }));
        loggerFactory.AddProvider(new ColoredConsoleLoggerProvider(new ColoredConsoleLoggerConfiguration
        {
            LogLevel = LogLevel.Debug,
            Color = ConsoleColor.Gray
        }));

        app.UseMvc();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们添加了2个日志日志提供器，分别是针对Information级别日志和Debug级别日志的&lt;/p&gt;
&lt;h4 id=&quot;最终效果&quot;&gt;最终效果&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201809/65831-20180921213001275-1411664716.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们的日志根据我们预设的字体颜色正确的显示了出来&lt;/p&gt;
&lt;h2 id=&quot;编写一个与signalr集成的实时日志组件&quot;&gt;编写一个与SignalR集成的实时日志组件&lt;/h2&gt;
&lt;p&gt;下面我们再来自定义一个与SignalR集成的日志提供器，我们希望产生的日志通过一个SignalR服务器推送到一个网页中。&lt;/p&gt;
&lt;p&gt;首先我们创建一个ASP.NET Core WebApi项目，命名为SignalrServer, 创建之后，我们右键项目属性，修改App Url为http://localhost:5000&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201809/65831-20180921213238072-2014467640.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们创建一个LogHub类，它集成自Hub类，代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class LogHub : Hub
    {
        public async Task WriteLog(Log log)
        {
            await Clients.All.SendAsync(&quot;showLog&quot;, log);
        }
    }

    public class Log
    {
        public LogLevel Level { get; set; }

        public string Content { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码解释&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这里我们创建了一个写日志的方法，它会把日志推送到所有连接到SignalR服务器的客户端，并调用客户端的showLog方法来展示推送的日志信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后我们修改Startup.cs文件，代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        // This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddCors();
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
            
            services.AddSignalR();
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            app.UseCors(p =&amp;gt; p.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader().AllowCredentials());
            app.UseSignalR(routes =&amp;gt;
            {
                routes.MapHub&amp;lt;LogHub&amp;gt;(&quot;/logHub&quot;);
            });

            

            app.UseMvc();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码解释&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们通过&lt;code&gt;service.AddSignalR&lt;/code&gt;注册了SignalR服务&lt;/li&gt;
&lt;li&gt;我们通过&lt;code&gt;app.UserSignalR&lt;/code&gt;方法注册一个logHub&lt;/li&gt;
&lt;li&gt;这里我们启用了CORS, 因为需要提供跨域访问&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后我们创建一个另外一个ASP.NET Core WebApi项目, SignalRLoggerSample&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201809/65831-20180921213251180-1460056264.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目创建成功之后，我们右键点击项目属性，并设置App URL为http://localhost:5001&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201809/65831-20180921213300497-1318546926.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们使用Package Console Manager, 安装Microsoft.AspNetCore.SignalR.Client&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PM&amp;gt; install-package Microsoft.AspNetCore.SignalR.Client&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了创建一个SignalR日志提供器， 我们分别创建一个SignalRLogger类和一个SignalRLoggerProvider类， 代码如下&lt;/p&gt;
&lt;p&gt;SignalRLogger.cs&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class SignalRLogger : ILogger
    {
        HubConnection connection;

        public SignalRLogger()
        {
            connection = new HubConnectionBuilder()
             .WithUrl(&quot;http://localhost:5000/LogHub&quot;)
             .Build();
        }

        public IDisposable BeginScope&amp;lt;TState&amp;gt;(TState state)
        {
            return null;
        }

        public bool IsEnabled(LogLevel logLevel)
        {
            return true;
        }

        public void Log&amp;lt;TState&amp;gt;(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func&amp;lt;TState, Exception, string&amp;gt; formatter)
        {
            if (!IsEnabled(logLevel))
            {
                return;
            }

            connection.StartAsync().Wait();
            var task = connection.SendAsync(&quot;writeLog&quot;, new { Level = logLevel, Content = formatter(state, exception) });
            task.Wait();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SignalRLoggerProvider.cs&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class SignalRLoggerProvider : ILoggerProvider
    {
        public SignalRLoggerProvider()
        {
        }

        public ILogger CreateLogger(string categoryName)
        {
            return new SignalRLogger();
        }

        public void Dispose()
        {

        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码解释&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这里使用&lt;code&gt;HubConnectionBuilder&lt;/code&gt;创建了一个SignalR连接&lt;/li&gt;
&lt;li&gt;连接启动成功之后，我们使用&lt;code&gt;connection.SendAsync&lt;/code&gt;方法，将当前产生的日志信息发送到SignalR服务器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;添加完成之后，我们在wwwroot文件夹中创建一个index.html, 在其中引入jquery和signalr的js库，并指定连接的signalR服务器是http://localhost:5000/logHub&lt;/p&gt;
&lt;p&gt;index.html&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;script src=&quot;jquery-1.10.2.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;signalr.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;Logs&amp;lt;/h1&amp;gt;
    &amp;lt;div id=&quot;content&quot; style=&quot;border:1px solid #0094ff&quot;&amp;gt;

    &amp;lt;/div&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        var levels = [
            { level: 0, name: 'Trace', backgroundColor: 'gray' },
            { level: 1, name: 'Debug', backgroundColor: 'green' },
            { level: 2, name: 'Information', backgroundColor: 'blue' },
            { level: 3, name: 'Warning', backgroundColor: 'yellow' },
            { level: 4, name: 'Error', backgroundColor: 'orange' },
            { level: 5, name: 'Critical', backgroundColor: 'red' },
        ];

        function getLevelName(level) {
            return levels.find(function (o) {
                return o.level == level;
            }).name;
        }

        function getLevelColor(level) {
            return levels.find(function (o) {
                return o.level == level;
            }).backgroundColor;
        }

        var connection = new signalR.HubConnectionBuilder().withUrl(&quot;http://localhost:5000/logHub&quot;).build();

        connection.on(&quot;showLog&quot;, function (message) {
            var div = &quot;&amp;lt;div style='background-color:&quot; + getLevelColor(message.level)+&quot;'&amp;gt;[&quot; + getLevelName(message.level) + &quot;]:&quot; + message.content + &quot;&amp;lt;/div&amp;gt;&quot;;
            $(&quot;#content&quot;).append(div);
        });

        connection.start().catch(function (err) {
            return console.error(err.toString());
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们修改ValuesController文件，代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    [Route(&quot;api/[controller]&quot;)]
    [ApiController]
    public class ValuesController : ControllerBase
    {
        private ILogger&amp;lt;ValuesController&amp;gt; _logger = null;

        public ValuesController(ILogger&amp;lt;ValuesController&amp;gt; logger)
        {
            _logger = logger;
        }

        // GET api/values
        [HttpGet]
        public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
        {
            _logger.LogTrace(&quot;User call the /api/values api&quot;);
            _logger.LogDebug(&quot;User call the /api/values api&quot;);
            _logger.LogInformation(&quot;User call the /api/values api&quot;);
            _logger.LogWarning(&quot;User call the /api/values api&quot;);
            _logger.LogError(&quot;User call the /api/values api&quot;);
            _logger.LogCritical(&quot;User call the /api/values api&quot;);
            return new string[] { &quot;value1&quot;, &quot;value2&quot; };
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码解释&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们创建了一个ValueController类的日志&lt;/li&gt;
&lt;li&gt;当用户请求/api/values时，我们输出了6个不同级别的日志&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后我们修改Startup.cs中的Configure方法，使用我们之前介绍的方法，将SignalRLoggerProvider添加到管道中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }
        app.UseStaticFiles();

        loggerFactory.AddProvider(new SignalRLoggerProvider());

        app.UseMvc();


    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;最终效果-1&quot;&gt;最终效果&lt;/h4&gt;
&lt;p&gt;最后我们按照顺序，先启动SignalRServer, 再启动SignalRLoggerSample, 效果如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201809/65831-20180921213314960-208241893.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/lwqlun/logging.zip&quot;&gt;本篇源代码&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 21 Sep 2018 13:42:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>简介 日志组件 ，作为程序员使用频率最高的组件，给程序员开发调试程序提供了必要的信息。ASP.NET Core中内置了一个通用日志接口ILogger，并实现了多种内置的日志提供器，例如 Console</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/9683482.html</dc:identifier>
</item>
<item>
<title>朱晔的互联网架构实践心得S1E9：架构评审一百问和设计文档五要素 - lovecindywang</title>
<link>http://www.cnblogs.com/lovecindywang/p/9688523.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovecindywang/p/9688523.html</guid>
<description>&lt;p&gt;【&lt;a href=&quot;https://files.cnblogs.com/files/lovecindywang/ZHUYE_ARCH_S1E9.pdf&quot; target=&quot;_blank&quot;&gt;下载文本PDF进行阅读&lt;/a&gt;】&lt;/p&gt;

&lt;p&gt;本文我会来说说我认为架构评审中应该看的一些点，以及我写设计文档的一些心得。助你在架构评审中过五关斩六将，助你写出能让人收藏点赞的设计文档。&lt;/p&gt;

&lt;h2&gt;技术架构评审&lt;/h2&gt;

&lt;p&gt;架构评审或技术方案评审的价值在于集众人的力量大家一起来分析看看方案里是否有坑，方案上线后是否会遇到不可逾越的重大技术问题，提前尽可能把一些事情先考虑到提出质疑其实对项目的健康发展有很大的好处。很多公司都有架构评审委员会都有架构评审的流程，做业务的兄弟要么看到这个流程往往心惊胆战害怕自己做的方案被毙了咋整，要么就是认为这是一种过场，随便糊弄一点文档发给委员会看一下就算过去了。我做过架构评审委员也做过提交评审方案的业务兄弟，不管哪个角色我都不害怕而是喜欢这一流程，评审这个事情做的好其实可以很享受，大家都是一起学习的过程，不存在谁为难谁。下面说说我觉得架构评审（非代码评审）中看重的需要评审的一些点。&lt;/p&gt;

&lt;h4&gt;组件选型&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;为什么选A不选B呢？&lt;/li&gt;
&lt;li&gt;A不是开源的，出了问题怎么办？&lt;/li&gt;
&lt;li&gt;B虽然是开源的，但是是Erlang写的，公司没人能看懂怎么办？&lt;/li&gt;
&lt;li&gt;C我看待解决的Issues还有很多，有没有去了解过？&lt;/li&gt;
&lt;li&gt;这个组件在性能方面你是否了解过？&lt;/li&gt;
&lt;li&gt;开源的免费版本不支持集群怎么办？&lt;/li&gt;
&lt;li&gt;如果彻底要自己写这个组件有没有可能性？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;组件特别是存储组件选型挺重要的，真心建议事先可以有那么几周的时间搭一个高可用的集群，使用接近于真实的数据对组件进行压测（你看之前我博客上的Mongodb的压测文章停火的，说明很多人没有这个时间和条件对一些组件进行压测）。眼见为实耳听为虚，自己通过压测对比一下自己得出的数据和公开的数据是否有差异，如果有的话说不定还能发现自己使用上的一些问题。尽量还是选用使用的人多的开源组件吧，出了问题至少Patch不会来的太慢。&lt;/p&gt;

&lt;h4&gt;性能&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;我们需求的TPS、QPS和RT是多少？&lt;/li&gt;
&lt;li&gt;整体设计上会做到的TPS、QPS和RT是多少？&lt;/li&gt;
&lt;li&gt;随着数据量的增大系统性能会不会出现明显问题？&lt;/li&gt;
&lt;li&gt;系统哪个环节会是最大的瓶颈？&lt;/li&gt;
&lt;li&gt;是否打算做压力测试，压力测试方案是怎么样的？&lt;/li&gt;
&lt;li&gt;怎么提高前端用户的访问流畅性？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于重要的项目，建议做一下整体压测，没有经过压测得出来的估计的结论往往可能是错的，我们总以为最终会死在最后的存储上，但是很可能早早就死在了程序的低级错误上，比如在一些存储组件的Client使用上，如果没把控好最佳实践（把应该作为单例使用Clinet每次都去创建一次，默认的线程数小的可怜应该重新配置但是保留了默认值），死的非常难看。&lt;/p&gt;

&lt;h4&gt;可伸缩性&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;每一个环节是否都是可以横向扩展的？&lt;/li&gt;
&lt;li&gt;扩容需要怎么做手动还是自动？&lt;/li&gt;
&lt;li&gt;数据库不能横向扩展怎么办？&lt;/li&gt;
&lt;li&gt;纵向扩展有多少效果？&lt;/li&gt;
&lt;li&gt;横向扩展是否是线性的？&lt;/li&gt;
&lt;li&gt;扩展后是否可以提高响应速度？&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;灵活性&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;是否有了解过产品层面以后会怎么发展？&lt;/li&gt;
&lt;li&gt;模块A是否能拆分出去独立为其它业务服务？&lt;/li&gt;
&lt;li&gt;模块B是否可以替换为另一种第三方数据源？&lt;/li&gt;
&lt;li&gt;如果流程有变，需要多大的工作量来适应？&lt;/li&gt;
&lt;li&gt;业务是否可以做到可配？&lt;/li&gt;
&lt;li&gt;为什么A和B都有差不多的逻辑？&lt;/li&gt;
&lt;li&gt;是否考虑到了A业务的实现以后还有B的可能性？&lt;/li&gt;
&lt;li&gt;如果现在有两种策略以后扩展到了八种策略怎么做？&lt;/li&gt;
&lt;li&gt;以后是否可以把这个业务的H5前端适配到PC？&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;可扩展性&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;为什么A和B都有差不多的逻辑？&lt;/li&gt;
&lt;li&gt;是否考虑到了A业务的实现以后还有B的可能性？&lt;/li&gt;
&lt;li&gt;如果现在有两种策略以后扩展到了八种策略怎么做？&lt;/li&gt;
&lt;li&gt;以后是否可以把这个业务的H5前端适配到PC？&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;可靠性&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;是否架构中有单点？&lt;/li&gt;
&lt;li&gt;故障转移是怎么实现的？&lt;/li&gt;
&lt;li&gt;集群内部故障转移需要多久？&lt;/li&gt;
&lt;li&gt;MQ或存储出现问题的时候系统会怎么样？&lt;/li&gt;
&lt;li&gt;MQ或存储出现问题又恢复了系统是否会自己恢复？&lt;/li&gt;
&lt;li&gt;是否考虑过异地故障转移的方案？&lt;/li&gt;
&lt;li&gt;是否考虑过多活的方案？&lt;/li&gt;
&lt;li&gt;是否有数据丢失的可能性？&lt;/li&gt;
&lt;li&gt;数据丢失后是否可以恢复？&lt;/li&gt;
&lt;li&gt;系统彻底挂了对其它业务的影响是什么？&lt;/li&gt;
&lt;li&gt;系统彻底挂了是否可以有线下的方式走业务？&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;安全性&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;是否彻底避免SQL注入和XSS？&lt;/li&gt;
&lt;li&gt;是否做了风控策略？&lt;/li&gt;
&lt;li&gt;是否有防刷保护机制？&lt;/li&gt;
&lt;li&gt;数据库拖库了会怎么样？&lt;/li&gt;
&lt;li&gt;是否有数据泄露的可能性？&lt;/li&gt;
&lt;li&gt;数据的权限怎么控制的？&lt;/li&gt;
&lt;li&gt;功能的权限是怎么控制的？&lt;/li&gt;
&lt;li&gt;是否做了日志审计？&lt;/li&gt;
&lt;li&gt;受到了DDOS攻击怎么办？&lt;/li&gt;
&lt;li&gt;数据传输是否加密验签？&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;兼容性&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;老的系统打算怎么办？&lt;/li&gt;
&lt;li&gt;怎么进行新老系统替换？&lt;/li&gt;
&lt;li&gt;新老系统能否来回切换？&lt;/li&gt;
&lt;li&gt;别的系统怎么连接你这套新服务？&lt;/li&gt;
&lt;li&gt;上下游依赖是否梳理过，影响范围多大？&lt;/li&gt;
&lt;li&gt;上下游改造的难度怎么样？&lt;/li&gt;
&lt;li&gt;上下游改造有排期吗？&lt;/li&gt;
&lt;li&gt;上下游改造的计划和通知时间确定了吗？&lt;/li&gt;
&lt;li&gt;使用了新的数据源数据怎么迁移？&lt;/li&gt;
&lt;li&gt;使用了新的技术老项目开发能否适应？&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;弹性处理&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;这个数据重复消费会怎么样？&lt;/li&gt;
&lt;li&gt;这个接口重复调用会怎么样？&lt;/li&gt;
&lt;li&gt;是否考虑了服务降级？哪些业务支持降级？&lt;/li&gt;
&lt;li&gt;是否考虑了服务熔断？熔断后怎么处理？&lt;/li&gt;
&lt;li&gt;是否考虑了服务限流？限流后客户端表现怎么样？&lt;/li&gt;
&lt;li&gt;队列爆仓会怎么样？&lt;/li&gt;
&lt;li&gt;是否考虑了隔离性？&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;事务性&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;这段业务由谁保证事务性？&lt;/li&gt;
&lt;li&gt;数据库事务回滚后会怎么样？&lt;/li&gt;
&lt;li&gt;服务调用了失败怎么办？&lt;/li&gt;
&lt;li&gt;队列补偿怎么做的？&lt;/li&gt;
&lt;li&gt;服务调用补偿怎么做的？&lt;/li&gt;
&lt;li&gt;数据补偿实现最终一致需要多久？&lt;/li&gt;
&lt;li&gt;在数据不完整的时候用户会感知到吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;可测试性&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;测试环境和线上的差异多大？&lt;/li&gt;
&lt;li&gt;是否支持部署多套隔离的测试环境？&lt;/li&gt;
&lt;li&gt;是否打算做单元测试，覆盖率目标是多少？&lt;/li&gt;
&lt;li&gt;测试黑盒白盒工作量的比例是怎么样的？&lt;/li&gt;
&lt;li&gt;是否支持接口层面的自动化测试？&lt;/li&gt;
&lt;li&gt;是否有可能做UI自动化测试？&lt;/li&gt;
&lt;li&gt;压测怎么造数据？&lt;/li&gt;
&lt;li&gt;是否可以在线上做压测？&lt;/li&gt;
&lt;li&gt;线上压测怎么隔离测试数据？&lt;/li&gt;
&lt;li&gt;是否有测试白名单功能？&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;可运维性&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;每一个组件对服务器哪方面的压力会最大？&lt;/li&gt;
&lt;li&gt;重新搭建整套系统最快需要多少时间？&lt;/li&gt;
&lt;li&gt;系统是否可以完全基于源代码构建？&lt;/li&gt;
&lt;li&gt;系统是否有初始化或预热的环节？&lt;/li&gt;
&lt;li&gt;系统里哪些环节需要人工参与？&lt;/li&gt;
&lt;li&gt;数据是否需要定期归档处理？&lt;/li&gt;
&lt;li&gt;会不会有突发的数据量业务量增大？&lt;/li&gt;
&lt;li&gt;随着时间的推移如果压力保持不变的话系统需要怎么来巡检和维护？&lt;/li&gt;
&lt;li&gt;怎么在容器里进行部署？&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;监控&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;业务层面哪些指标需要监控和报警？&lt;/li&gt;
&lt;li&gt;应用层面系统内部是否有暴露了一些指标作监控和报警？&lt;/li&gt;
&lt;li&gt;系统层面使用的中间件和存储是否有监控报警？&lt;/li&gt;
&lt;li&gt;是否所有环节都接入了全链路跟踪？&lt;/li&gt;
&lt;li&gt;出现报警的时候应该由谁来处理？&lt;/li&gt;
&lt;li&gt;每一个模块是否有固定的主要和次要负责人？&lt;/li&gt;
&lt;li&gt;有没有可能系统出了问题无法通过监控指标体现？&lt;/li&gt;
&lt;li&gt;哪些指标需要上大屏由监控进行7*24监控？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看了这么多问题可能会觉得这架构设计是没法做了，其实不同阶段的项目有不同的目标，我们不会在项目起步的时候做99.99%的可用性支持百万QPS的架构，高效完成项目的业务目标也是架构考虑的因素之一。而且随着项目的发展，随着公司中间件和容器的标准化，很多架构的工作被标准化替代，业务代码需要考虑架构方面伸缩性运维性等等的需求越来越少，慢慢的这些工作都能由架构和运维团队来接。一开始的时候我们可以花一点时间来考虑这些问题，但是不是所有的问题都需要有最终的方案。&lt;/p&gt;

&lt;h2&gt;技术设计文档&lt;/h2&gt;
&lt;p&gt;如果你在Google搜索架构设计文档、技术设计文档、概要设计文档可以搜索到很多模板，很多公司也会以这些模板作为设计文档的模板来让大家填写。对于大部分所谓的项目只是一个项目中的一个小环节是一个具体的业务逻辑，因此总是可以看到大家写的所谓的技术设计文档只能填满文档的20%，其余都不知道怎么写。当你不知道文档应该写哪些内容的时候可以这么来考虑问题，就是你这个项目接下去是要卖给别人来用的，你没有机会当面和他把这个项目说清楚，你只能通过文档来把事情写清楚，别人就给你一次机会，如果看不懂你文档表达的意思，不能理解你的项目，你的项目就卖不出去不值钱，这个时候你一定会从各个角度来剖析你的系统想尽一切办法来把事情说清楚，用这个方法逼一下自己的，你的文档会很优秀。接下去我想说一下如果是我的话我看重技术设计的哪些部分以及这些部分的文档的写作方式，这些内容构成了一个必要的（概要）设计文档，算是抛砖引玉。&lt;/p&gt;

&lt;h4&gt;交代背景和需求全貌&lt;/h4&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180921212257360-2020170680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在这里，推荐使用脑图在技术角度给出一下自己理解的项目需求的分布。PRD中的产品功能脑图可以和这里技术角度的脑图有差异，在说清楚需求的同时侧重技术层面，体现在：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以不按照需求的功能点进行归类而是按照实际项目归类，把需求列在实际的项目下面&lt;/li&gt;
&lt;li&gt;可以区分需求是自己干的还是调用外部的接口，可以在图上以不同的形态提现&lt;/li&gt;
&lt;li&gt;可以画出功能之间的依赖关系，以虚线实线进一步区分依赖的程度&lt;/li&gt;
&lt;li&gt;可以在图上体现需求的优先级以及需求目前的进展和负责人，这样基本一个图就可以看清楚这个项目需要消耗多少资源需要多久可以结束&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看了这个图基本产品需求就可以理解个大概，具体的细节规则可以进一步参考PRD。&lt;/p&gt;

&lt;h4&gt;系统架构图&lt;/h4&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180921212314553-230618853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在本系列文章的第二到第五篇中，我都配了一个架构图。架构图需要传递清楚下面的信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;项目由哪些模块、服务、缓存、存储构成，可以以不同的图案和颜色代表不同类型&lt;/li&gt;
&lt;li&gt;模块之间的依赖关系（当然，也可以从数据的流向角度来画）&lt;/li&gt;
&lt;li&gt;核心流程的步骤，沿着图上的1、2、3基本就可以大概了解核心流程的实现&lt;/li&gt;
&lt;li&gt;可以用大的框把组件进行分组来描述组件的部署方式（比如相同机器上承载的组件在一个框内）&lt;/li&gt;
&lt;li&gt;可以以边框的虚实来分类项目内的组件或三方组件，可以以箭头的虚实来标记主要流程次要流程等等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;UML里会有一些具体的分类，什么类图、组件图、部署图等等，我觉得不必拘泥于这些细节，通过线线框框的架构图能把模块和模块之间的关系表述请求，然后再配以一定的文字来说明每一个组件即可。我自己常用的是gliffy，只要能说清楚，Word画也可以。根据项目的大小，图上的模块不一定是需要独立部署的进程，模块也可以是项目内部的一个模块或类。对于复杂的项目，要画一个图说清楚很难，可以画一个大的架构图，然后针对每一个模块或流程再细化画不同层次的图。&lt;/p&gt;

&lt;h4&gt;对外API定义&lt;/h4&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180921212309042-1107189522.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;API的详细定义可以由Swagger UI、Spring REST Doc、Miredot等等工具生成，这些生成的接口是按照代码来组织层次关系的，只能体现接口的参数定义不能体现接口的形态等，是没有思想的，不适合用来阅读，只适合用来参考。因此还是建议做一个脑图来总体阐述一下接口的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分类，按业务功能的分类，按受众的分类等等&lt;/li&gt;
&lt;li&gt;形式（图上不同的颜色），同步还是异步（结果不在响应中，单独的回调返回），单条还是批量，数据接口还是页面调用等等&lt;/li&gt;
&lt;li&gt;重要性（图上文字后的星号），比如重点标记主流程的接口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;图上可以不显示出参数清单，但可以以简单的文字来描述重要参数，比如下单接口：-&amp;gt;@用户身份，优惠券ID*，[{商品ID,数量}]&amp;lt;-订单号，下单结果（0-失败，1-成功）。（-&amp;gt;代表输入，&amp;lt;-代表输出，[]代表数组，@代表隐式参数，*代表可空参数等等）。&lt;/p&gt;
&lt;p&gt;之前强调过好多次涉及到和外部交互的API是设计中非常重要的一个环节，不仅仅体现了系统对外输出的能力，也体现了系统设计在安全性、复用性、封装等方面的平衡。&lt;/p&gt;

&lt;h4&gt;交互时序&lt;/h4&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180921212322047-540956533.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;时序图的表达非常重要，可以表现需求脑图、架构图和API脑图无法表现出来的几个方面，清晰展现了某个事情：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关键的利益关系方。这个事情由哪几个方面构成，可以是用户、甲方、乙方这么来分，也可以是用户、APP客户端、服务端这么来分&lt;/li&gt;
&lt;li&gt;每一方在做什么，依赖的又是什么，整个顺序是怎么样的&lt;/li&gt;
&lt;li&gt;技术层面这是同步接口、还是回调、还是非技术的线下流程&lt;/li&gt;
&lt;li&gt;还可以在图上表现出可选逻辑，条件判断逻辑，循环逻辑等等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我觉得能在比较高的层面说一下技术（对接）流程即可，不一定要详细到类和类之间的交互，类和类之间的交互阅读代码或直接看全链路调用的图就可以。如果项目有多个合作方多个依赖方，项目流程比较复杂，那么序列图是能把这个事情说清楚的最好的方式。&lt;/p&gt;
&lt;p&gt;对于这种时序图，采用传统的工具来画费时费力，推荐下面两个工具（&lt;a href=&quot;https://www.websequencediagrams.com/&quot;&gt;https://www.websequencediagrams.com/&lt;/a&gt;和&lt;a href=&quot;http://plantuml.com/sequence-diagram&quot;&gt;http://plantuml.com/sequence-diagram&lt;/a&gt;），可以在几分钟内生成需要的图。&lt;/p&gt;
&lt;p&gt;我们输入类似的文字：&lt;/p&gt;
&lt;p&gt;title 合作流程&lt;/p&gt;
&lt;p&gt;用户-&amp;gt;XX:投资YY标的&lt;/p&gt;
&lt;p&gt;XX-&amp;gt;YY:同步投资情况，更新可用额度&lt;/p&gt;
&lt;p&gt;用户-&amp;gt;YY:在额度内消费&lt;/p&gt;
&lt;p&gt;YY-&amp;gt;XX:同步消费情况，更新可用额度，更新回款计划&lt;/p&gt;
&lt;p&gt;YY-&amp;gt;XX:还款&lt;/p&gt;
&lt;p&gt;XX-&amp;gt;用户:回款（已消费部分作为手续费给XX）&lt;/p&gt;
&lt;p&gt;opt 线下流程&lt;/p&gt;
&lt;p&gt;XX-&amp;gt;YY:对于YY用户的消费出账单&lt;/p&gt;
&lt;p&gt;YY-&amp;gt;XX:对账确认账单&lt;/p&gt;
&lt;p&gt;XX-&amp;gt;YY:打款开具发票&lt;/p&gt;
&lt;p&gt;End&lt;/p&gt;
&lt;p&gt;网站生成类似的时序图，还可以自由选择自己喜欢的样式：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180921212333744-590347865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;数据库ER&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180921212342330-308964411.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;ER图就是实体联系图。形式上我们可以在图上表现几个点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实体：哪些表&lt;/li&gt;
&lt;li&gt;实体上的属性：体现实体之间关系以及实体业务功能的重要字段&lt;/li&gt;
&lt;li&gt;联系：实体和实体之间的关系，比如一对多，多对一还是多对多之类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在有的时候我们可以省略属性的类型定义，甚至可以直接省略具体的属性（实体名和M对N的关系是必须的），把图简化为类似下面的部分：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180921212350524-975344653.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ER图的信息量非常大，绝对不是粘贴一下表结构的DDL可以替代的，原因是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ER图可以以极小的空间展现很多信息，这样我们可以在图上对业务进行分组，看到全貌&lt;/li&gt;
&lt;li&gt;ER图展现的是表和表之间的关系，一眼可以看出最重要核心的表是哪些&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如下图，是否一眼就可以看明白一套P2P金融业务整个数据结构的架构呢：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180921212356502-1410921664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（随便画的图，不代表任何意义，请不要以这个图做P2P的表结构设计）&lt;/p&gt;

&lt;p&gt;所有的图，文字只是一个维度，我们要学会利用边框类型（矩形、圆角矩形），边框样式（虚线，实线），填充色，文字颜色，关联线条粗细颜色样式，框内ICON来增加我们要表现信息的维度，最多可以增加到6维+，这种能力是文字很难实现的。一图胜过千言，所以我一直认为图是设计文档中非常重要的部分。&lt;/p&gt;

&lt;h4&gt;其它&lt;/h4&gt;

&lt;p&gt;之前我说了我们可以以五图的形式（需求脑图、架构图、API脑图、序列图、数据库ER图）把系统大概介绍一个底朝天，说清楚了需求、架构、对外接口、交互流程和数据结构设计这几个事情，业务项目说清楚这些足够了。&lt;/p&gt;
&lt;p&gt;对于偏向于中间件（不管是基础中间件还是业务中间件，中台）的项目（而不是业务项目），这里我再补充几个重要的方面，需要在设计文档中有体现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可靠性：是否有单点的组件，非单点的组件如何做故障转移&lt;/li&gt;
&lt;li&gt;高性能：是否有抗突发性能压力的能力，大概可以满足多少的TPS和QPS，怎么去做来实现高性能&lt;/li&gt;
&lt;li&gt;可扩展：随着压力上升哪些环节可以做扩展，怎么做扩展&lt;/li&gt;
&lt;li&gt;安全性：哪些手段防突破，万一突破了后果怎么样&lt;/li&gt;
&lt;li&gt;兼容性：和遗留系统怎么通讯，怎么做迁移&lt;/li&gt;
&lt;li&gt;…………等等方面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些点我就不一一展开说了，在第一节说架构评审的时候都有提到过，针对那些问题写一下自己的设计是怎么应对的吧。&lt;/p&gt;

&lt;p&gt;这些点我认为可以构成一个合格的设计文档，文档的形式不重要，重要的是可以把业务的技术实现梳理清楚，确保我们在开发之前有一个清晰的思路，在开发上线后，文档也是一个后人熟悉系统的非常重要的手段。你可能会提出疑问说这样的设计文档是不是太粗略了一点，完全没有体现到软件层面设计的细节，没错是这样，但是我一直说的是互联网架构心得，敢问现在互联网项目从0开始的大项目1到2个月上线，大的版本迭代2周一次，如果设计的时间是五分之一的话，设计也就是2天到一周这样子，我们有多少时间和能力来细化文档呢，如果能把我这里说的五要素都做好，对于互联网项目已经笑死。&lt;/p&gt;
&lt;p&gt;还有一点往往会比较可惜，我们或许可以做到在开发之前有一个概要设计文档的产出，但是我们很难做到在系统上线后随着迭代还能继续维护第一版产品上线时那个大而全的文档。随着产品的迭代，我们的技术文档也像PRD迭代文档一样只说这次迭代的技术改动的话，这种设计文档因为没有全局观意义不大。对于这个情况，我觉得对于每一条业务线的产品，我都建议我们至少能维护大而全的下面这些文档的全量版本：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;完整表结构（顺带标一下归档方案、重要程度）&lt;/li&gt;
&lt;li&gt;需求全貌&lt;/li&gt;
&lt;li&gt;对外产品能力输出全貌&lt;/li&gt;
&lt;li&gt;整体架构图&lt;/li&gt;
&lt;li&gt;关键业务交互流程（特别是那种很难说清楚的多方结算关系）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;定期回顾一下这五个文档，根据最近的需求改改，可能也只需要花费几小时的时间，对于大项目其意义往往是新人的灵魂导师（之前我有画过一个比较复杂系统的架构图，这个架构图我看到有人做了桌面）。&lt;/p&gt;
</description>
<pubDate>Fri, 21 Sep 2018 13:24:00 +0000</pubDate>
<dc:creator>lovecindywang</dc:creator>
<og:description>朱晔的互联网架构实践心得S1E9：架构评审一百问和设计文档五要素 朱晔的互联网架构实践心得S1E9：架构评审一百问和设计文档五要素 【下载文本PDF进行阅读】 本文我会来说说我认为架构评审中应该看的一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovecindywang/p/9688523.html</dc:identifier>
</item>
<item>
<title>[llvm] LLVM 核心类简明示例 : llvm::Value &amp;&amp; llvm::Type &amp;&amp; llvm::Constant - racaljk</title>
<link>http://www.cnblogs.com/racaljk/p/9688336.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/racaljk/p/9688336.html</guid>
<description>&lt;p&gt;llvm核心类位于 &lt;code&gt;include/llvm/IR&lt;/code&gt;中，用以表示机器无关且表现力极强的LLVM IR。&lt;/p&gt;
&lt;h2 id=&quot;llvmvalue&quot;&gt;llvm::Value&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;llvm::Value&lt;/strong&gt;则是这其中的重中之重，它用来表示一个具有类型的值。它是类图如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/600493/201809/600493-20180921202805710-1561882155.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;llvm::Argument&lt;/code&gt;,&lt;code&gt;llvm::BasicBlock&lt;/code&gt;,&lt;code&gt;llvm::Constant&lt;/code&gt;,&lt;code&gt;llvm::Instruction&lt;/code&gt;这些很重要的类都是它的子类。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;llvm::Value&lt;/code&gt;有一个&lt;code&gt;llvm::Type*&lt;/code&gt;成员和一个&lt;code&gt;use list&lt;/code&gt;。后者可以跟踪有哪些其他&lt;code&gt;Value&lt;/code&gt;使用了自己，我们可以使用下面的迭代器对它进行访问：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;unsigned use_size() 返回有多少Value使用它&lt;/li&gt;
&lt;li&gt;bool use_empty() 是否没有Value使用它&lt;/li&gt;
&lt;li&gt;use_iterator use_begin() 返回use list的迭代器头&lt;/li&gt;
&lt;li&gt;use_iterator use_end() 返回尾&lt;/li&gt;
&lt;li&gt;User *use_back() 返回use list的最后一个元素&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int main() {
    Value* val1 = ConstantFP::get(theContext, APFloat(3.2));
    if (val1-&amp;gt;use_empty()) {
        std::cout &amp;lt;&amp;lt; &quot;no one use it\n&quot;;
    }
    system(&quot;pause&quot;);
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;llvmtype&quot;&gt;llvm:Type&lt;/h2&gt;
&lt;p&gt;前者顾名思义表示一个类型。可以通过&lt;code&gt;Value::getType()&lt;/code&gt;获取到这个&lt;code&gt;llvm::Type*&lt;/code&gt;,它有一些&lt;code&gt;is*()&lt;/code&gt;成员函数可以判断是下面哪种类型：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;  enum TypeID {
    // PrimitiveTypes - make sure LastPrimitiveTyID stays up to date.
    VoidTyID = 0,    ///&amp;lt;  0: type with no size
    HalfTyID,        ///&amp;lt;  1: 16-bit floating point type
    FloatTyID,       ///&amp;lt;  2: 32-bit floating point type
    DoubleTyID,      ///&amp;lt;  3: 64-bit floating point type
    X86_FP80TyID,    ///&amp;lt;  4: 80-bit floating point type (X87)
    FP128TyID,       ///&amp;lt;  5: 128-bit floating point type (112-bit mantissa)
    PPC_FP128TyID,   ///&amp;lt;  6: 128-bit floating point type (two 64-bits, PowerPC)
    LabelTyID,       ///&amp;lt;  7: Labels
    MetadataTyID,    ///&amp;lt;  8: Metadata
    X86_MMXTyID,     ///&amp;lt;  9: MMX vectors (64 bits, X86 specific)
    TokenTyID,       ///&amp;lt; 10: Tokens

    // Derived types... see DerivedTypes.h file.
    // Make sure FirstDerivedTyID stays up to date!
    IntegerTyID,     ///&amp;lt; 11: Arbitrary bit width integers
    FunctionTyID,    ///&amp;lt; 12: Functions
    StructTyID,      ///&amp;lt; 13: Structures
    ArrayTyID,       ///&amp;lt; 14: Arrays
    PointerTyID,     ///&amp;lt; 15: Pointers
    VectorTyID       ///&amp;lt; 16: SIMD 'packed' format, or other vector type
  };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如这样：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int main() {
    Value* val1 = ConstantFP::get(theContext, APFloat(3.2));
    Type* t = val1-&amp;gt;getType();

    if (t-&amp;gt;isDoubleTy()) {
        std::cout &amp;lt;&amp;lt; &quot;val1 is typed as double(&quot; &amp;lt;&amp;lt; t-&amp;gt;getTypeID() &amp;lt;&amp;lt;&quot;)\n&quot;;
    }
    system(&quot;pause&quot;);
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除此之外&lt;code&gt;llvm::Type&lt;/code&gt;还有很多成员函数，详细请参见&lt;a href=&quot;http://llvm.org/doxygen/classllvm_1_1Type.html&quot; class=&quot;uri&quot;&gt;http://llvm.org/doxygen/classllvm_1_1Type.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;多说一句，我们还可以对 &lt;strong&gt;llvm::Value&lt;/strong&gt; 进行命名&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;bool hasName() const&lt;/li&gt;
&lt;li&gt;std::string getName() const&lt;/li&gt;
&lt;li&gt;void setName(const std::string &amp;amp;Name)&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;llvmconstant&quot;&gt;llvm::Constant&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;llvm::Constant&lt;/code&gt;表示一个各种常量的基类，基于它派生出了&lt;code&gt;ConstantInt 整型常量&lt;/code&gt;,&lt;code&gt;ConstantFP 浮点型常量&lt;/code&gt;,&lt;code&gt;ConstantArray 数组常量&lt;/code&gt;,&lt;code&gt;ConstantStruct 结构体常量&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int main() {
    // 构造一个32位，无符号的整型值，值为1024
    APInt ci = APInt(32, 1024);
    ConstantInt* intVal = ConstantInt::get(theContext, ci);
    std::cout &amp;lt;&amp;lt; &quot;bit width:&quot; &amp;lt;&amp;lt; intVal-&amp;gt;getBitWidth()
              &amp;lt;&amp;lt; &quot;\nvalue:&quot; &amp;lt;&amp;lt; intVal-&amp;gt;getValue().toString(16, false);

    system(&quot;pause&quot;);
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 21 Sep 2018 12:26:00 +0000</pubDate>
<dc:creator>racaljk</dc:creator>
<og:description>LLVM 核心类简明示例 : llvm::Value &amp;&amp; llvm::Type &amp;&amp; llvm::Constant llvm核心类位于 中，用以表示机器无关且表现力极强的LLVM IR。 llvm:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/racaljk/p/9688336.html</dc:identifier>
</item>
<item>
<title>业务拆分的思考 - 挑战者V</title>
<link>http://www.cnblogs.com/youcong/p/9688300.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youcong/p/9688300.html</guid>
<description>&lt;p&gt;从最初的单体应用，即将进行业务拆分，分而治之，虽心不免有些激动，但是很快就陷入深思。&lt;/p&gt;
&lt;p&gt;因为我不得不考虑如何拆分比较好及其现在要不要拆分的问题。&lt;/p&gt;
&lt;p&gt;目前我们开发的是一个多租户系统应用，考虑到公共通用功能，例如用户功能、组织功能、菜单功能、模块功能、系统监控、审批功能、权限管理等，我们将其作为公共模块，而像共享方面的系统或者是智能门锁方面的系统，我们决定将其抽象另外的模块，当特定的用户需要该功能时，只需与我方沟通签订对应的合作协议，我方后台超级管理员只需配置下相应的权限即可。&lt;/p&gt;
&lt;p&gt;一、先谈谈是否要拆分的问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
孙子曰：“不尽知用兵之害者，则不能尽知用兵之利“。
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;还是回到之前的那个问题，业务是否真正需要拆分呢？这里要结合具体的业务需求。&lt;/p&gt;
&lt;p&gt;比如，目前我对这个多租户系统有这么样一个想法，如果要拆分，按照上述的原则公共模块进行抽取，抽取为一个后台web应用。&lt;/p&gt;
&lt;p&gt;而像共享方面(例如共享汽车等)和智能门锁可单独作为另外的一个应用。之所以这么做的原因在于处于如下考虑:&lt;/p&gt;
&lt;p&gt;(1)解耦性和可维护性&lt;/p&gt;
&lt;p&gt;如果所有的系统都要放入一个庞大的war下，那么代码耦合度可能会比较高，而且不易维护，就好比git分支开发，之所以强调每个人在自己的分支下开发对应的功能模块，是因为避免全部都在主分支开发时，导致出现的代码混乱和冲突问题。另外还有一个考虑是，通常主分支，也就是master分支，一般情况下，主分支的代码是不存在问题的，或者问题非常小，但是由于都在主分支上进行开发，导致有的时候，因为没有严格的代码审核机制，导致有些开发人员，比如曾经的我，仅仅只是为了完成任务而开发，写程序时，很少思考不考虑到是否会不会影响到其他同事的代码，最后的结果是，陷入的一个死循环，改bug,改bug....&lt;/p&gt;
&lt;p&gt;之所以强调可维护性，是因为，对于这个多租户而言，后台模块单独作为一个应用，由部分人负责，而像智能门锁或者是共享汽车等应用是另外一个模块，也由专门的开发人员负责，这样一来，你打你的我打我的，总的原则，坚持一个，“高内聚，低耦合，代码可读性良好，可扩展性良好”。&lt;/p&gt;
&lt;p&gt;当然了，实际情况也不能你打你的，我打我的，各自为战，该及时沟通还是得及时沟通，对于项目组长而言就需要时刻了解自己的组员工作进度及其代码方面的情况，因为这样一来当项目经理问起时，也不必胆战心惊。&lt;/p&gt;
&lt;p&gt;作为项目经理，处于整个项目的领路人，项目的成败，很大程度不仅仅是由底层的开发人员所决定，还有就是项目经理的决策和管理。&lt;/p&gt;

&lt;p&gt;(2)稳定性&lt;/p&gt;
&lt;p&gt;有这么一句话，“鸡蛋不能同时放在一个笼子下”。&lt;/p&gt;
&lt;p&gt;后台应用，一般情况下仅仅只是管理人员使用，或者是管理员通过权限分配指定某一些人使用。这样一来，基本上，不用考虑高并发。&lt;/p&gt;
&lt;p&gt;而像智能门锁这样的，不得不考虑高并发和性能方面的问题，如果全部将其放在一个war下，一个出问题，全部出问题，将会导致宕机，影响项目的正常服务，容错性差。&lt;/p&gt;
&lt;p&gt;这样看来，业务拆分，也是为了提高稳定性。&lt;/p&gt;


&lt;p&gt;二、谈谈业务拆分的思路&lt;/p&gt;
&lt;p&gt;(1)梳理所有的业务功能环节&lt;/p&gt;
&lt;p&gt;主要以粗分为主，例如智能门锁系统的智能门锁、智能网关等等这样的。&lt;/p&gt;
&lt;p&gt;(2）业务功能细分&lt;/p&gt;
&lt;p&gt;例如智能门锁系统中的智能门锁，它不仅包含门锁列表展示、安装门锁、门锁详情信息、门锁授权人、一次性密码和系统密码等，还包括如何开锁等等。&lt;/p&gt;
&lt;p&gt;(3)梳理业务主体，进行分门别类划分&lt;/p&gt;
&lt;p&gt;这里主要强调的是将业务分类，类似开发中的紧急并非常重要、紧急但不重要这样的开发优先级。&lt;/p&gt;
&lt;p&gt;(4)将金字塔结构图结合业务泳道图通过关键指标来识别关键业务功能&lt;/p&gt;
&lt;p&gt;也许这句话不是特别好理解，比较官方，不过当我说完后，你一定会非常明白。&lt;/p&gt;
&lt;p&gt;其实整个项目就是一个金字塔结构&lt;/p&gt;
&lt;p&gt;从顶层到下层，自顶向下，如图(画的有点丑，大家凑合着看吧)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201809/1255290-20180921195607745-1762649664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 根据这幅图可归纳为如下四点:&lt;/p&gt;
&lt;p&gt;a. 将所有的通过用业务逻辑组成公共服务，比如配置服务，调度服务，缓存服务等;&lt;/p&gt;
&lt;p&gt;b.如果有一个业务主体，得到了各方面的关注，那么就把这个业务首先拆分出来独立成一个模块；&lt;/p&gt;
&lt;p&gt;c.长流程业务就符合业务主体特殊一条标准，可以提取为一个独立的服务；&lt;/p&gt;
&lt;p&gt;d. 分渠道，比如将接口调用的逻辑和界面方式的逻辑解耦成两个服务，比如后台和接口，使得两个变成独立的管道互不影响；&lt;/p&gt;

&lt;p&gt;(6)重构&lt;br/&gt;拆分的过程也意味着对代码进行重构。&lt;/p&gt;
&lt;p&gt;a.首先拆除所有的公共服务(校验服务，规则服务，开通服务，归档服务)，然后再拆分特殊业务主体服务(重点业务，长流程业务)，最后拆不同驱动实现方式（接口服务和界面服务）;&lt;/p&gt;
&lt;p&gt;b.因为业务量特别大，系统采用消息队列的方式进行处理，通过接骨法接触代码之间的耦合，并提供对外服务的接口;&lt;/p&gt;
&lt;p&gt;c. 比如创建订单的环节，设计所有的业务主体，影响大，所以这个服务不能一下子全拆出来，要通过修路法，先建设一个订单服务和原来的系统并行使用，同时分流出几个试点业务到订单服务。当上下游调用没有问题，可以正常创建订单后，再通过分批逃跑法，逐步地将其他业务的处理迁移到这个微服务上面，最终当所有的业务都迁移成功之后，原来的系统的订单处理逻辑就废弃了；&lt;/p&gt;
&lt;p&gt;d.业务的拆分过程中，数据库拆分的工作也同时进行（主从和读写分离）；&lt;/p&gt;

&lt;p&gt;三、分布式拆分&lt;/p&gt;
&lt;p&gt;提到分布式，普及下什么是分布式系统，这里我引用图片:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201809/1255290-20180921200516820-1081016815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;引用百度百科:&lt;/p&gt;
&lt;p&gt;分布式系统（distributed system）是建立在网络之上的&lt;a href=&quot;https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6&quot; target=&quot;_blank&quot;&gt;软件&lt;/a&gt;系统。正是因为&lt;a href=&quot;https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6/12053&quot; target=&quot;_blank&quot; data-lemmaid=&quot;12053&quot;&gt;软件&lt;/a&gt;的特性，所以分布式系统具有高度的&lt;a href=&quot;https://baike.baidu.com/item/%E5%86%85%E8%81%9A%E6%80%A7/4973441&quot; target=&quot;_blank&quot; data-lemmaid=&quot;4973441&quot;&gt;内聚性&lt;/a&gt;和透明性。因此，网络和分布式系统之间的区别更多的在于高层&lt;a href=&quot;https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6/12053&quot; target=&quot;_blank&quot; data-lemmaid=&quot;12053&quot;&gt;软件&lt;/a&gt;（特别是&lt;a href=&quot;https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192&quot; target=&quot;_blank&quot; data-lemmaid=&quot;192&quot;&gt;操作系统&lt;/a&gt;），而不是硬件。&lt;a href=&quot;https://baike.baidu.com/item/%E5%86%85%E8%81%9A%E6%80%A7/4973441&quot; target=&quot;_blank&quot; data-lemmaid=&quot;4973441&quot;&gt;内聚性&lt;/a&gt;是指每一个&lt;a href=&quot;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728&quot; target=&quot;_blank&quot; data-lemmaid=&quot;103728&quot;&gt;数据库&lt;/a&gt;分布节点&lt;a href=&quot;https://baike.baidu.com/item/%E9%AB%98%E5%BA%A6%E8%87%AA%E6%B2%BB/3379318&quot; target=&quot;_blank&quot; data-lemmaid=&quot;3379318&quot;&gt;高度自治&lt;/a&gt;，有本地的&lt;a href=&quot;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1239101&quot; target=&quot;_blank&quot; data-lemmaid=&quot;1239101&quot;&gt;数据库管理系统&lt;/a&gt;。透明性是指每一个&lt;a href=&quot;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728&quot; target=&quot;_blank&quot; data-lemmaid=&quot;103728&quot;&gt;数据库&lt;/a&gt;分布节点对用户的应用来说都是透明的，看不出是本地还是远程。在&lt;a href=&quot;https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/5389644&quot; target=&quot;_blank&quot; data-lemmaid=&quot;5389644&quot;&gt;分布式数据库系统&lt;/a&gt;中，用户感觉不到数据是分布的，即用户不须知道关系是否分割、有无&lt;a href=&quot;https://baike.baidu.com/item/%E5%89%AF%E6%9C%AC/3512540&quot; target=&quot;_blank&quot; data-lemmaid=&quot;3512540&quot;&gt;副本&lt;/a&gt;、数据存于哪个站点以及&lt;a href=&quot;https://baike.baidu.com/item/%E4%BA%8B%E5%8A%A1/5945882&quot; target=&quot;_blank&quot; data-lemmaid=&quot;5945882&quot;&gt;事务&lt;/a&gt;在哪个站点上执行等。&lt;/p&gt;

&lt;p&gt;关于分布式拆分，我主要围绕三个方面讲，需求，原则，方法等三个方面。&lt;/p&gt;
&lt;p&gt;(1)需求&lt;/p&gt;
&lt;p&gt;a.组织结构变化&lt;/p&gt;
&lt;p&gt;从最初的一个团队逐渐成长并拆分为几个团队，团队按照业务线不同进行划分，为了减少各个业务系统和代码间的关联和耦合，几个团队不再可能共同向一个代码库中提交代码，必须对原有系统进行拆分，以减少团队间的干扰。&lt;/p&gt;

&lt;p&gt;b.安全&lt;/p&gt;
&lt;p&gt;这里所指的安全不是系统级别的安全，而是指代码或成果的安全，尤其是对于很多具有核心算法的系统，为了代码不被泄露，需要对相关系统进行模块化拆分，隔离核心功能，保护知识产权。&lt;/p&gt;

&lt;p&gt;c.替换性&lt;/p&gt;
&lt;p&gt;有些产品为了提供差异化的服务，需要产品具有可定制功能，根据用户的选择自由组合为一个完整的系统，比如一些模块，免费用户使用的功能与收费用户使用的功能肯定是不一样的，这就需要这些模块具有替换性，判断是免费用户还是收费用户使用不同的模块组装，这也需要对系统进行模块化拆分。&lt;/p&gt;

&lt;p&gt;d.交互速度&lt;/p&gt;
&lt;p&gt;单体程序最大的问题在于系统错综复杂，牵一发而动全身，也许一个小的改动就造成很多功能没办法正常工作，极大的降低了软件的交付速度，因为每次改动都需要大量的回归测试确保每个模块都能正确工作，因为我们不清楚改动会影响到什么，所以需要做大量重复工作，增加了测试成本。这时候就需要对系统进行拆分，理清各个功能间的关系并解耦。&lt;/p&gt;

&lt;p&gt;e.技术需求&lt;/p&gt;
&lt;p&gt;单体程序由于技术栈固定，尤其的是比较庞大的系统，不能很方便的进行技术升级，或者说对引入新技术或框架等处于封闭状态；每种语言都有自己的特点，单体程序没有办法享受到其它语言带来的便利；对应到团队中，团队技术相对比较单一。&lt;/p&gt;
&lt;p&gt;相比于基于业务的垂直拆分，基于技术的横向拆分也很重要，使用数据访问层可以很好的隐藏对数据库的直接访问、减少数据库连接数、增加数据使用效率等；横向拆分可以极大的提高各个层级模块的重用性。&lt;/p&gt;
&lt;p&gt;f.业务需求&lt;/p&gt;
&lt;p&gt;由于业务上的某些特殊要求，比如对某个功能或模块的高可用性、高性能、可伸缩性等的要求，虽然也可以将单体整体部署到分布式环境中实现高可用、高性能等，但是从系统维护的角度来考虑，每次改动都要重新部署所有节点，显然会增加很多潜在的风险和不确定定性因素，所以有时候不得不选择将那些有特殊要求的功能从系统中抽取出来，独立部署和扩展。&lt;/p&gt;

&lt;p&gt;(2)原则&lt;/p&gt;
&lt;p&gt;a.业务优先&lt;/p&gt;
&lt;p&gt;每个系统天然都会按业务功能分成多个模块，每个模块又包含许多业务相关的功能，在系统拆分时，我们就可以优先考虑按照业务边界进行切割，切割完成后再针对每个模块进行拆解，循序渐进，逐渐迭代深入，最终完成系统的拆解。这个过程类似庖丁解牛，要找到关节之处下刀，方能事半功倍。&lt;/p&gt;

&lt;p&gt;b.循环渐进&lt;/p&gt;
&lt;p&gt;系统拆分过程中包含两个非常重要的工作：拆分和测试。二者缺一不可，并且二者是并行进行的，一定要边拆分边测试。每一步拆分完成都要保证系统功能是完整的，保证系统的测试是完整的。拆分要小步前进，如此以来可以减少累计错误的发生。这一点在《重构》这本书中也讲到了。&lt;/p&gt;

&lt;p&gt;c.兼顾技术&lt;/p&gt;
&lt;p&gt;系统不能为了分布式而分布式，系统拆分的代价相当昂贵；当然如果有拆分的需要，我们也不能白白浪费这么好的学习机会：&lt;/p&gt;
&lt;p&gt;可靠测试：“重构之前，首先检查自己是否有一套可靠的测试机制”，这是MartinFowler在《重构》这本书中说到的，它同样对系统拆分有效。拆分是在对系统进行大手术，每一次的改动都要保证系统保持原来的行为不变。测试使得我有足够的信心进行下一步的拆分或重构，不至于在错误的道路上越走越远，以至于错误累积。测试与拆分如影随形，每一步都要有足够的测试。没有测试的拆分和重构我真的不敢想象结果会是什么样子。&lt;/p&gt;
&lt;p&gt;关于测试的重要性可以参考我的这篇文章:&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/youcong/p/9291184.html&quot;&gt;论单元测试之重要性&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前我强调过，测试由底层的单元到高层的UI，其中单元是最有利于发现问题解决问题的。&lt;/p&gt;

&lt;p&gt;(3)方法&lt;/p&gt;
&lt;p&gt;a.公共模块复用;&lt;/p&gt;
&lt;p&gt;b.增加代理，解耦;&lt;/p&gt;

&lt;p&gt;小结:&lt;/p&gt;
&lt;p&gt;本文主要讲三个大方面，第一个是业务拆分是否有必要拆分;第二个是业务拆分的思路;最后一个是分布式业务拆分。&lt;/p&gt;
&lt;p&gt;本文的重点在于第一个和第二个，因为这两个我深有体会，试验过，应用过。至于分布式的话，此次主要普及下相关的知识和给有这方面需求的人启发。&lt;/p&gt;
&lt;p&gt;本文主要参考如下两篇文章：&lt;/p&gt;
&lt;p&gt;业务系统拆分的基本思路:https://blog.csdn.net/u011402896/article/details/80506394&lt;/p&gt;
&lt;p&gt;分布式拆分:https://blog.csdn.net/zzz34k/article/details/52576731&lt;/p&gt;
&lt;p&gt;当然了，也加上了我自己的理解和想法。&lt;/p&gt;
&lt;p&gt;希望能给广大的IT友友们带来有益的收获。&lt;/p&gt;
</description>
<pubDate>Fri, 21 Sep 2018 12:19:00 +0000</pubDate>
<dc:creator>挑战者V</dc:creator>
<og:description>从最初的单体应用，即将进行业务拆分，分而治之，虽心不免有些激动，但是很快就陷入深思。 因为我不得不考虑如何拆分比较好及其现在要不要拆分的问题。 目前我们开发的是一个多租户系统应用，考虑到公共通用功能，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youcong/p/9688300.html</dc:identifier>
</item>
<item>
<title>在AndroidStudio上使用AddressSanitizer - willhua</title>
<link>http://www.cnblogs.com/willhua/p/9688266.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willhua/p/9688266.html</guid>
<description>&lt;p&gt;AddressSanitizer是Google主导的一个开源内存问题检测工具。现在也开始支持Android平台，且受Google推荐来替代之前的Valgrind。目前AddressSanitizer能够发现如下问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Out-of-bounds accesses to heap, stack and globals&lt;/li&gt;
&lt;li&gt;Use-after-free&lt;/li&gt;
&lt;li&gt;Use-after-return (runtime flag ASAN_OPTIONS=detect_stack_use_after_return=1)&lt;/li&gt;
&lt;li&gt;Use-after-scope (clang flag -fsanitize-address-use-after-scope)&lt;/li&gt;
&lt;li&gt;Double-free, invalid free&lt;/li&gt;
&lt;li&gt;Memory leaks (experimental)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中，值得一提的是&lt;strong&gt;Memory leaks&lt;/strong&gt;，现在还是experiment，准确的说，现在还只支持Linux平台，并不支持Android。所以，想写一个内存泄露来检验AddressSanitizer是否生效就要注意了，就像本人一样，其实AddressSanitizer都已经正常运行了，然后一直没有检测出来Memory leaks就以为没有生效，导致浪费了很多时间。&lt;/p&gt;
&lt;blockquote readability=&quot;9.469387755102&quot;&gt;
&lt;p&gt;For more information on leak detector in AddressSanitizer, see &lt;a href=&quot;https://clang.llvm.org/docs/LeakSanitizer.html&quot;&gt;LeakSanitizer&lt;/a&gt;. The leak detection is turned on by default on Linux, and can be enabled using &lt;code&gt;ASAN_OPTIONS=detect_leaks=1&lt;/code&gt; on OS X; however, it is not yet supported on other platforms.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也许有人会说，Android不也是Linux嘛。这个的话，从它的Supported Platforms：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Linux i386/x86_64 (tested on Ubuntu 12.04)&lt;/li&gt;
&lt;li&gt;OS X 10.7 - 10.11 (i386/x86_64)&lt;/li&gt;
&lt;li&gt;iOS Simulator&lt;/li&gt;
&lt;li&gt;Android ARM&lt;/li&gt;
&lt;li&gt;NetBSD i386/x86_64&lt;/li&gt;
&lt;li&gt;FreeBSD i386/x86_64 (tested on FreeBSD 11-current)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;就可以看出来，Linux和Android是不同的。而且这里还注明了必须ARM，也就是说如果用非ARM的Android设备可能就不支持。个人认为这和AddressSanitizer的实现机制有关。因为它是通过重写比如malloc之类的函数，构造&lt;strong&gt;shadow Memory&lt;/strong&gt;来实现的检测。而这些函数可能都是汇编语言写的，所以不同的CPU硬件就需要不同的实现版本。&lt;/p&gt;
&lt;h4 id=&quot;as中的应用&quot;&gt;AS中的应用&lt;/h4&gt;
&lt;h5 id=&quot;编译指令&quot;&gt;编译指令&lt;/h5&gt;
&lt;p&gt;其实很简单，就两点，开启AddressSanitizer标志和使用clang编译器。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;开启AddressSanitizer标志：在CMakeLists.txt中添加如下语句：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;SET (CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -O0 -g -fsanitize=address -fno-omit-frame-pointer&quot;)
SET (CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -O0 -g -fsanitize=address -fno-omit-frame-pointer&quot;)
SET (CMAKE_SHARED_LINKER_FLAGS &quot;${CMAKE_SHARED_LINKER_FLAGS} -fsanitize=address&quot;)
SET (CMAKE_ANDROID_ARM_MODE ARM)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;使用clang编译：在build.gradle的cmake模块下面添加：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;arguments &quot;-DANDROID_TOOLCHAIN=clang&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;在设备中安装asan&quot;&gt;在设备中安装ASAN&lt;/h5&gt;
&lt;p&gt;要点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设备需要root&lt;/li&gt;
&lt;li&gt;运行ndk中的asan_device_setup脚本&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于asan_device_setup脚本，在AS自带的ndk-bundle中，其脚本路径为&lt;code&gt;ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/lib64/clang/7.0.2/bin/asan_device_setup&lt;/code&gt;，而如果是自己单独安装的NDK，那么其路径为&lt;code&gt;NDKROOT/toolchains/llvm/prebuilt/linux-x86_64/bin/asan_device_setup&lt;/code&gt;。如果脚本执行成功，那么设备就会自动重启，在本人实践中，最后部分信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt; Pushing files to the device
Installing /system/lib/libclang_rt.asan-arm-android.so 644 
[100%] /system/lib/libclang_rt.asan-arm-android.so
Installing /system/lib64/libclang_rt.asan-aarch64-android.so 644 
[100%] /system/lib64/libclang_rt.asan-aarch64-android.so
Installing /system/bin/app_process32 755 u:object_r:zygote_exec:s0
[100%] /system/bin/app_process32
Installing /system/bin/app_process32.real 755 u:object_r:zygote_exec:s0
[100%] /system/bin/app_process32.real
Installing /system/bin/app_process64 755 u:object_r:zygote_exec:s0
[100%] /system/bin/app_process64
Installing /system/bin/app_process64.real 755 u:object_r:zygote_exec:s0
[100%] /system/bin/app_process64.real
Installing /system/bin/asanwrapper 755 
[100%] /system/bin/asanwrapper
Installing /system/bin/asanwrapper64 755 
[100%] /system/bin/asanwrapper64
&amp;gt;&amp;gt; Restarting shell (asynchronous)
&amp;gt;&amp;gt; Please wait until the device restarts&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;测试&quot;&gt;测试&lt;/h5&gt;
&lt;p&gt;有了前面两步，就可以实验了，其实还是很简单的。&lt;/p&gt;
&lt;p&gt;使用AS新建一个C++支持的默认Android项目，然后修改其native函数如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;extern &quot;C&quot; JNIEXPORT jstring
JNICALL
Java_com_example_willhua_asantest_MainActivity_stringFromJNI(
        JNIEnv *env,
        jobject /* this */) {
    std::string hello = &quot;Hello from C++&quot;;

    int *ptr = (int*)malloc(sizeof(int) * 3);
    ptr[4] = 6;

    return env-&amp;gt;NewStringUTF(hello.c_str());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在注意Build Variant为debug，点击启动就OK啦。然后在log中可以看到检测到了heap-buffer-overflow：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/infteK&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/09/21/infteK.png&quot; alt=&quot;infteK.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;参考&quot;&gt;参考&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://clang.llvm.org/docs/AddressSanitizer.html#supported-platforms&quot;&gt;clang: AddressSanitizer&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29176806&quot;&gt;Android Native内存检测&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37515148&quot;&gt;内存检测工具&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/google/sanitizers/wiki/AddressSanitizerOnAndroid&quot;&gt;AddressSanitizerOnAndroid&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Sep 2018 12:08:00 +0000</pubDate>
<dc:creator>willhua</dc:creator>
<og:description>在AndroidStudio上使用AddressSanitizer AddressSanitizer是Google主导的一个开源内存问题检测工具。现在也开始支持Android平台，且受Google推荐</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/willhua/p/9688266.html</dc:identifier>
</item>
</channel>
</rss>