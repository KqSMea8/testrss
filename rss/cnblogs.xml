<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【原创】自己动手写一个服务网关 - 孤独烟</title>
<link>http://www.cnblogs.com/rjzheng/p/9220437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rjzheng/p/9220437.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;h3 id=&quot;什么是网关为什么需要使用网关&quot;&gt;什么是网关？为什么需要使用网关？&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1194802/o_gateway1.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;如图所示，在不使用网关的情况下，我们的服务是直接暴露给服务调用方。当调用方增多，势必需要添加定制化访问权限、校验等逻辑。当添加API网关后，再第三方调用端和服务提供方之间就创建了一面墙，这面墙直接与调用方通信进行权限控制。&lt;br/&gt;本文所实现的网关源码抄袭了---Oh,不对，是借鉴。借鉴了Zuul网关的源码，提炼出其核心思路，实现了一套简单的网关源码，博主将其改名为Eatuul。&lt;/p&gt;
&lt;h3 id=&quot;题外话&quot;&gt;题外话&lt;/h3&gt;
&lt;p&gt;本文是业内能搜到的第一篇自己动手实现网关的文章。博主写的手把手系列的文章，目的是在以最简单的方式，揭露出中间件的核心原理，让读者能够迅速了解实现的核心。需要说明的是，这不是源码分析系列的文章，因此写出来的代码，省去了一些复杂的内容，毕竟大家能理解到该中间件的核心原理即可。如果想看源码分析系列的，请关注博主，后期会将spring、spring boot、dubbo、mybatis等开源框架一一揭示。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;
&lt;h3 id=&quot;设计思路&quot;&gt;设计思路&lt;/h3&gt;
&lt;p&gt;先大致说一下，就是定义一个Servlet接收请求。然后经过preFilter(封装请求参数),routeFilter(转发请求)，postFilter(输出内容)。三个过滤器之间，共享request、response以及其他的一些全局变量。如下图所示&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1194802/o_gateway3.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;&lt;strong&gt;和真正的Zuul的区别?&lt;/strong&gt;&lt;br/&gt;主要区别有如下几点&lt;br/&gt;(1)Zuul中在异常处理模块，有一个ErrorFilter来处理，博主在实现的时候偷懒了，略去。&lt;br/&gt;(2)Zuul中PreFilters,RoutingFilters,PostFilters默认都实现了一组，具体如下表所示&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1194802/o_gateway4.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;博主总不可能每一个都给你们实现一遍吧。所以偷懒了，每种只实现一个。但是调用顺序还是不变，按照PreFilters-&amp;gt;RoutingFilters-&amp;gt;PostFilters的顺序调用&lt;br/&gt;(3)在routeFilters确实有转发请求的Filter,然而博主偷天换日了，改用RestTemplate实现.&lt;/p&gt;
&lt;h3 id=&quot;代码结构&quot;&gt;代码结构&lt;/h3&gt;
&lt;p&gt;大家去&lt;a href=&quot;http://start.spring.io/&quot;&gt;spring官网&lt;/a&gt;上搭建一套springboot的项目，博主就不展示pom的代码了。直接将项目结构展示一下，如下图所示&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1194802/o_gateway6.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;&lt;strong&gt;EatuulServlet.java&lt;/strong&gt;&lt;br/&gt;这个是网关的入口，逻辑也十分简单，分为三步&lt;br/&gt;(1)将request,response放入threadlocal中&lt;br/&gt;(2)执行三组过滤器&lt;br/&gt;(3)清除threadlocal中的的环境变量&lt;br/&gt;源码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.rjzheng.eatuul.http;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet(name = &quot;eatuul&quot;, urlPatterns = &quot;/*&quot;)
public class EatuulServlet extends HttpServlet {

    private EatRunner eatRunner = new EatRunner();

    @Override
    public void service(HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {
        //将request，和response放入上下文对象中
        eatRunner.init(req, resp);
        try {
            //执行前置过滤
            eatRunner.preRoute();
            //执行过滤
            eatRunner.route();
            //执行后置过滤
            eatRunner.postRoute();
        } catch (Throwable e) {
            RequestContext.getCurrentContext().getResponse()
                          .sendError(HttpServletResponse.SC_NOT_FOUND, e.getMessage());
        } finally {
            //清除变量
            RequestContext.getCurrentContext().unset();
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;EatuulRunner.java&lt;/strong&gt;&lt;br/&gt;这个是具体的执行器。需要说明一下，在Zuul中，ZuulRunner在获取具体有哪些过滤器的时候，有一个FileLoader可以动态读取配置加载。博主在实现我们自己的EatuulRunner时候，略去动态读取的过程，直接静态写死。&lt;br/&gt;源码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.rjzheng.eatuul.http;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.rjzheng.eatuul.filter.EatuulFilter;
import com.rjzheng.eatuul.filter.post.SendResponseFilter;
import com.rjzheng.eatuul.filter.pre.RequestWrapperFilter;
import com.rjzheng.eatuul.filter.route.RoutingFilter;

public class EatRunner {
    //静态写死过滤器
    private ConcurrentHashMap&amp;lt;String, List&amp;lt;EatuulFilter&amp;gt;&amp;gt; hashFiltersByType = new ConcurrentHashMap&amp;lt;String, List&amp;lt;EatuulFilter&amp;gt;&amp;gt;(){{  
        put(&quot;pre&quot;,new ArrayList&amp;lt;EatuulFilter&amp;gt;(){{
            add(new RequestWrapperFilter());
        }});
        put(&quot;route&quot;,new ArrayList&amp;lt;EatuulFilter&amp;gt;(){{
            add(new RoutingFilter());
        }});
        put(&quot;post&quot;,new ArrayList&amp;lt;EatuulFilter&amp;gt;(){{
            add(new SendResponseFilter());
        }});
     }};
    
    public void init(HttpServletRequest req, HttpServletResponse resp) {
        RequestContext ctx = RequestContext.getCurrentContext();
        ctx.setRequest(req);
        ctx.setResponse(resp);
    }

    public void preRoute() throws Throwable {
        runFilters(&quot;pre&quot;);  
    }

    public void route() throws Throwable{
        runFilters(&quot;route&quot;);    
    }

    public void postRoute() throws Throwable{
        runFilters(&quot;post&quot;);
    }
    
     public void runFilters(String sType) throws Throwable {
            List&amp;lt;EatuulFilter&amp;gt; list = this.hashFiltersByType.get(sType);
            if (list != null) {
                for (int i = 0; i &amp;lt; list.size(); i++) {
                    EatuulFilter zuulFilter = list.get(i);
                    zuulFilter.run();
                }
            }
     }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;EatuulFilter.java&lt;/strong&gt;&lt;br/&gt;接下来就是一系列Filter的代码了，先上父类EatuulFilter的源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.rjzheng.eatuul.filter;

public abstract class EatuulFilter {

    abstract public String filterType();

    abstract public int filterOrder();

    abstract public void run();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;RequestWrapperFilter.java&lt;/strong&gt;&lt;br/&gt;这个是PreFilter,前置执行过滤器，负责封装请求。步骤如下所示&lt;br/&gt;(1)封装请求头&lt;br/&gt;(2)封装请求体&lt;br/&gt;(3)构造出RestTemplate能识别的RequestEntity&lt;br/&gt;(4)将RequestEntity放入全局threadlocal之中&lt;br/&gt;代码如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.rjzheng.eatuul.filter.pre;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Collections;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.RequestEntity;
import org.springframework.util.MultiValueMap;
import org.springframework.util.StreamUtils;

import com.rjzheng.eatuul.filter.EatuulFilter;
import com.rjzheng.eatuul.http.RequestContext;

public class RequestWrapperFilter extends EatuulFilter{

    @Override
    public String filterType() {
        // TODO Auto-generated method stub
        return &quot;pre&quot;;
    }

    @Override
    public int filterOrder() {
        // TODO Auto-generated method stub
        return -1;
    }

    @Override
    public void run() {
        String rootURL = &quot;http://localhost:9090&quot;;
        RequestContext ctx =RequestContext.getCurrentContext();
        HttpServletRequest servletRequest = ctx.getRequest();
        String targetURL = rootURL + servletRequest.getRequestURI();
        RequestEntity&amp;lt;byte[]&amp;gt; requestEntity = null;
        try {
            requestEntity = createRequestEntity(servletRequest, targetURL);
        } catch (Exception e) {
            e.printStackTrace();
        }
        //4、将requestEntity放入全局threadlocal之中
        ctx.setRequestEntity(requestEntity);
    }
    
    private RequestEntity createRequestEntity(HttpServletRequest request,String url) throws URISyntaxException, IOException {
        String method = request.getMethod();
        HttpMethod httpMethod = HttpMethod.resolve(method);
        //1、封装请求头
        MultiValueMap&amp;lt;String, String&amp;gt; headers =createRequestHeaders(request);
        //2、封装请求体
        byte[] body = createRequestBody(request);
        //3、构造出RestTemplate能识别的RequestEntity
        RequestEntity requestEntity = new RequestEntity&amp;lt;byte[]&amp;gt;(body,headers,httpMethod, new URI(url));
        return requestEntity;
    }
    

    private byte[] createRequestBody(HttpServletRequest request) throws IOException {
        InputStream inputStream = request.getInputStream();
        return StreamUtils.copyToByteArray(inputStream);
    }

    private MultiValueMap&amp;lt;String, String&amp;gt; createRequestHeaders(HttpServletRequest request) {
        HttpHeaders headers = new HttpHeaders();
        List&amp;lt;String&amp;gt; headerNames = Collections.list(request.getHeaderNames());
        for(String headerName:headerNames) {
            List&amp;lt;String&amp;gt; headerValues = Collections.list(request.getHeaders(headerName));
            for(String headerValue:headerValues) {
                headers.add(headerName, headerValue);
            }
        }
        return headers;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;RoutingFilter.java&lt;/strong&gt;&lt;br/&gt;这个是routeFilter,这里我偷懒了，直接做转发请求，并且将返回值ResponseEntity放入全局threadlocal中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.rjzheng.eatuul.filter.route;

import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;

import com.rjzheng.eatuul.filter.EatuulFilter;
import com.rjzheng.eatuul.http.RequestContext;

public class RoutingFilter extends EatuulFilter{

    @Override
    public String filterType() {
        // TODO Auto-generated method stub
        return &quot;route&quot;;
    }

    @Override
    public int filterOrder() {
        // TODO Auto-generated method stub
        return 0;
    }
    
    @Override
    public void run(){
        RequestContext ctx = RequestContext.getCurrentContext();
        RequestEntity requestEntity = ctx.getRequestEntity();
        RestTemplate restTemplate = new RestTemplate();
        ResponseEntity responseEntity = restTemplate.exchange(requestEntity,byte[].class);
        ctx.setResponseEntity(responseEntity);
    }
    

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;SendResponseFilter.java&lt;/strong&gt;&lt;br/&gt;这个是postFilters,将ResponseEntity输出即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.rjzheng.eatuul.filter.post;

import java.util.List;
import java.util.Map;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;

import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseEntity;

import com.rjzheng.eatuul.filter.EatuulFilter;
import com.rjzheng.eatuul.http.RequestContext;

public class SendResponseFilter extends EatuulFilter{

    @Override
    public String filterType() {
        return &quot;post&quot;;
    }

    @Override
    public int filterOrder() {
        return 1000;
    }

    @Override
    public void run() {
        try {
            addResponseHeaders();
            writeResponse();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void addResponseHeaders() {
        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletResponse servletResponse = ctx.getResponse();
        ResponseEntity responseEntity = ctx.getResponseEntity();
        HttpHeaders httpHeaders = responseEntity.getHeaders();
        for(Map.Entry&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; entry:httpHeaders.entrySet()) {
            String headerName = entry.getKey();
            List&amp;lt;String&amp;gt; headerValues = entry.getValue();
            for(String headerValue:headerValues) {
                servletResponse.addHeader(headerName, headerValue);
            }
        }
    }

    private void writeResponse()throws Exception {
        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletResponse servletResponse = ctx.getResponse();
        if (servletResponse.getCharacterEncoding() == null) { // only set if not set
            servletResponse.setCharacterEncoding(&quot;UTF-8&quot;);
        }
        ResponseEntity responseEntity = ctx.getResponseEntity();
        if(responseEntity.hasBody()) {
            byte[] body = (byte[]) responseEntity.getBody();
            ServletOutputStream outputStream = servletResponse.getOutputStream();
            outputStream.write(body);
            outputStream.flush();
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;RequestContext.java&lt;/strong&gt;&lt;br/&gt;最后是一直在说的全局threadlocal变量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.rjzheng.eatuul.http;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;

public class RequestContext extends ConcurrentHashMap&amp;lt;String, Object&amp;gt; {
    protected static Class&amp;lt;? extends RequestContext&amp;gt; contextClass = RequestContext.class;
    protected static final ThreadLocal&amp;lt;? extends RequestContext&amp;gt; threadLocal = new ThreadLocal&amp;lt;RequestContext&amp;gt;() {
        @Override
        protected RequestContext initialValue() {
            try {
                return contextClass.newInstance();
            } catch (Throwable e) {
                throw new RuntimeException(e);
            }
        }
    };

    public static RequestContext getCurrentContext() {
        RequestContext context = threadLocal.get();
        return context;
    }

    public HttpServletRequest getRequest() {
        return (HttpServletRequest) get(&quot;request&quot;);
    }

    public void setRequest(HttpServletRequest request) {
        put(&quot;request&quot;, request);
    }

    public HttpServletResponse getResponse() {
        return (HttpServletResponse) get(&quot;response&quot;);
    }

    public void setResponse(HttpServletResponse response) {
        set(&quot;response&quot;, response);
    }

    
    public void setRequestEntity(RequestEntity requestEntity){
        set(&quot;requestEntity&quot;,requestEntity);
    }
    
    public RequestEntity getRequestEntity() {
        return (RequestEntity) get(&quot;requestEntity&quot;);
    }
    
    public void setResponseEntity(ResponseEntity responseEntity){
        set(&quot;responseEntity&quot;,responseEntity);
    }
    
    public ResponseEntity getResponseEntity() {
        return (ResponseEntity) get(&quot;responseEntity&quot;);
    }
    
    public void set(String key, Object value) {
        if (value != null)
            put(key, value);
        else
            remove(key);
    }

    public void unset() {
        threadLocal.remove();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;如何测试&quot;&gt;如何测试？&lt;/h3&gt;
&lt;p&gt;自己另外起一个server端口为9090如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.rjzheng.eatservice;

import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.boot.web.servlet.ServletComponentScan;

import com.rjzheng.eatservice.controller.IndexController;

@SpringBootApplication
@ServletComponentScan(basePackageClasses = IndexController.class)
public class Application {

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).properties(&quot;server.port=9090&quot;).run(args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再来一个controller&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.rjzheng.eatservice.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class IndexController {
    
    @RequestMapping(&quot;/index&quot;)
    public String index() {
        return &quot;hello!world&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，你就发现可以从localhost:8080/index进行跳转访问了&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;p&gt;本文模拟了一下zuul网关的源码，借鉴了一下其精髓的部分。希望大家能有所收获&lt;/p&gt;
</description>
<pubDate>Sun, 24 Jun 2018 23:49:00 +0000</pubDate>
<dc:creator>孤独烟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rjzheng/p/9220437.html</dc:identifier>
</item>
<item>
<title>【作业4.0】HansBug的第四次面向对象课程思考 - HansBug</title>
<link>http://www.cnblogs.com/HansBug/p/9222492.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HansBug/p/9222492.html</guid>
<description>&lt;p&gt;嘛。。不知不觉这门课程要结束了，那么就再说点啥以示庆祝呗。&lt;/p&gt;

&lt;p&gt;说到这个，相比很多人对此其实很有疑惑，请让我慢慢分析。&lt;/p&gt;
&lt;h2 id=&quot;逻辑概览&quot;&gt;逻辑概览&lt;/h2&gt;
&lt;p&gt;首先我们来看看两种方式各自的做法和流程是什么样的：&lt;/p&gt;
&lt;h3 id=&quot;单元测试&quot;&gt;单元测试&lt;/h3&gt;
&lt;p&gt;在测试中，我们是这样的一个流程&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/703546/201806/703546-20180625015133525-456035499.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此外，为了保证测试能覆盖到工程代码的每一个区域，&lt;strong&gt;需要保证测试的覆盖率&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;正确性证明&quot;&gt;正确性证明&lt;/h3&gt;
&lt;p&gt;在证明中，我们是这样的一个流程&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/703546/201806/703546-20180625021054534-1576820762.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这一过程中&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于行为分析的&lt;code&gt;repOk&lt;/code&gt;永真性证明依赖于JSF中的&lt;code&gt;modifies&lt;/code&gt;项&lt;/li&gt;
&lt;li&gt;方法正确性将基于JSF中所描述的&lt;code&gt;effects&lt;/code&gt;和&lt;code&gt;requires&lt;/code&gt;项&lt;/li&gt;
&lt;li&gt;各方法内其他方法的调用需要依赖被调用方法的正确性，具体来说
&lt;ul&gt;&lt;li&gt;对于系统自带的类与方法实现一律默认正确&lt;/li&gt;
&lt;li&gt;对于其他位置的调用，正确性则依赖于其具体方法或类的正确性证明&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;关键细节&quot;&gt;关键细节&lt;/h2&gt;
&lt;p&gt;基于以上的逻辑，我们不难发现一个细节：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在单元测试的流程图上，当程序通过测试后，是&lt;strong&gt;假定程序为正确&lt;/strong&gt;而不是&lt;strong&gt;程序为正确&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;或者更具体地说，这里多出了一个名为&lt;strong&gt;假定&lt;/strong&gt;的字眼。&lt;/p&gt;
&lt;p&gt;这是什么原因的？其实说来也非常简单——因为&lt;strong&gt;测试，只能证明程序有错，而不能证明程序是对的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;虽然有大数定律的理论支撑（即只要测试集数量无限大，则必定可以覆盖一切情况），可是实际上并不存在无限大的测试集，故测试上的死角总还是会存在的。&lt;/p&gt;
&lt;p&gt;设一个有限集 $ T $ ，为测试集（单元测试中的测试集不可能做到无穷），而 $ S $为全集。然而，在实际情况下，可能遇到的情况常常是无穷多的，故 $ S $ 是一个无穷集。&lt;/p&gt;
&lt;p&gt;故，$ \complement^{S}{T} $ 即为测试集没有覆盖到的地方。又 $ T $ 有穷， $ S $ 无穷，故 $ T \subset S $ 恒成立，$ \complement^{S}{T} \neq \emptyset $&lt;/p&gt;
&lt;p&gt;故永远有覆盖不到的数据，且对于这部分无法覆盖到的区域，是无法仅依靠测试来证明正确性的。&lt;/p&gt;
&lt;p&gt;故&lt;strong&gt;基于测试的正确性验证的严谨性问题是不可避免的&lt;/strong&gt;。&lt;strong&gt;若要严格意义上地论证正确性，基于程序逻辑的正确性证明是唯一的选择&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;异与同取与舍&quot;&gt;异与同、取与舍&lt;/h2&gt;
&lt;p&gt;在上面的分析中，我们论证了单元测试方法存在的硬伤。&lt;/p&gt;
&lt;p&gt;然而，我们为啥还要保留这样的方法呢？&lt;/p&gt;
&lt;p&gt;因为，实际问题与应用大都不是一元线性的，而&lt;strong&gt;是时间、经济、人力等多方面成本以及多方面效益指标所构成的高维量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其实，在工业界各类应用中，常常有以下两种模式可以长久而稳定的存在：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;较高的成本，&lt;strong&gt;绝对高的质量&lt;/strong&gt;（或者说其质量水准具有不可替代性），但是部署门槛稍高&lt;/li&gt;
&lt;li&gt;成本低廉，较高的质量，且&lt;strong&gt;易于广泛普及与部署，易于操作易于维护&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实际上，不仅在计算机行业，在其他工业界乃至于商业中，也&lt;strong&gt;常常会形成这样两种模式并存的局面&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而反映在软件质量保证领域，则分别是&lt;strong&gt;基于程序设计逻辑的正确性证明&lt;/strong&gt;（正确性从原理层面上就有绝对的保障，可是成本嘛，各位都写过一次论证，体验过其成本之高昂）和&lt;strong&gt;面向数据期望的单元测试&lt;/strong&gt;（操作非常简便，方便大范围部署，且能覆盖绝大部分实际情况）。&lt;/p&gt;
&lt;p&gt;所以，在实际应用中&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;严格的正确性证明常常&lt;strong&gt;只会被运用在一些对产品质量要求绝对高的局部区域&lt;/strong&gt;（例如航天器的核心控制程序，对错误的容忍度为零）&lt;/li&gt;
&lt;li&gt;普通的单元测试则会&lt;strong&gt;被广泛运用在一般工程项目的测试中&lt;/strong&gt;（对错误有一定的容忍限度，但务必兼顾时间、经济成本和效益，创业公司的项目中更是如此）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说到底，这两者其实很难去严格区分一个优劣。很多问题，根本上还是一句话——&lt;strong&gt;具体问题具体分析，适合的就是对的&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;何谓ocl&quot;&gt;何谓OCL&lt;/h2&gt;
&lt;p&gt;OCL，英文全称&lt;code&gt;object constraint language&lt;/code&gt;，翻译过来就是&lt;strong&gt;对象约束语言&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;顾名思义，其作用在于对设计的对象进行约束，且保证不存在二义性。且实际上，OCL和UML（统一建模语言，&lt;code&gt;Unified Modeling Language&lt;/code&gt;）捆绑使用。&lt;/p&gt;
&lt;h2 id=&quot;异与同&quot;&gt;异与同&lt;/h2&gt;
&lt;p&gt;从以上的一些基本概述中，我们不难发现OCL实际上和JSF有着相似之处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;都是对于程序设计上的约束（其中包含了类合法性、以及方法行为等要素）&lt;/li&gt;
&lt;li&gt;最终目标都是描述程序设计的预期行为，作为一个统一的标准&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然而进一步研究与分析，其区别也是很大的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，OCL约束的核心对象和JSF有较大差别。&lt;strong&gt;JSF在围绕方法和类&lt;/strong&gt;，而OCL则在对象，以及对象内、对象间所包含的&lt;strong&gt;数据项&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;基于以上的原因，OCL的表达能力远远比JSF丰富。&lt;strong&gt;OCL作为约束语言，可以自由地约束各处的数据项和设计规范&lt;/strong&gt;。而JSF的不变式约束相比之下就逊色了非常多。&lt;/li&gt;
&lt;li&gt;也正是由于OCL的&lt;strong&gt;丰富性和完备的可计算性&lt;/strong&gt;，所以OCL完全具备类似SQL那样的查询能力。&lt;/li&gt;
&lt;li&gt;但是，为了支撑如此庞大丰富的能力，且保证无二义性，OCL所付出的代价就是&lt;strong&gt;重量化&lt;/strong&gt;。而JSF则相比之下更轻便更快捷。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而至于具体应用呢，则还是老规矩——&lt;strong&gt;适合的就是最好的&lt;/strong&gt;。在不同的工程项目，不同的场合下，自然会有不同的选择。&lt;/p&gt;

&lt;h2 id=&quot;uml类图&quot;&gt;UML类图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/703546/201806/703546-20180625040750299-1765108077.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;顺序图&quot;&gt;顺序图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/703546/201806/703546-20180625052419479-465033217.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;状态图&quot;&gt;状态图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/703546/201806/703546-20180625055347768-2078061811.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;知识点之间的关系&quot;&gt;知识点之间的关系&lt;/h2&gt;
&lt;p&gt;首先，我们来回顾下我们这学期四章的各个标题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一章 Java与对象（Java和面向对象基本概念入门）&lt;/li&gt;
&lt;li&gt;第二章 并发与安全（多线程程序设计入门）&lt;/li&gt;
&lt;li&gt;第三章 抽象与规格（规格化与整体设计进阶）&lt;/li&gt;
&lt;li&gt;第四章 测试与论证（工程化质量保证措施学习与体验）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实这很明显，是一个循序渐进的过程，体现在两个不同的层面上：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从学生学习的角度而言，&lt;strong&gt;知识体系是层层递进的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;从工业生产的角度而言，这个也&lt;strong&gt;很接近一个产品从设计到交付，自底向上的一个完整流程&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;个人收获与小结&quot;&gt;个人收获与小结&lt;/h2&gt;
&lt;p&gt;实际上，笔者在多年前，就已经接触并使用了面向对象程序设计语言。&lt;/p&gt;
&lt;p&gt;所以，实际上在这个学期，笔者的主要收获如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过十几次作业对程序框架设计的反复揣摩，笔者&lt;strong&gt;在整体框架设计上的水平更加趋于成熟&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;更加深入的&lt;strong&gt;了解了严格工业界的一些做法&lt;/strong&gt;（例如广泛地规格化程序设计，以及正确性证明等）&lt;/li&gt;
&lt;li&gt;此外，笔者结合之前多年的实践经验（理论课上讲到过的坑，笔者当年几乎全都亲自踩过一遍）和对工业界的一些基本了解（笔者已经做过多笔的外包项目，目前仍在着手运营的项目也有数个），&lt;strong&gt;对面向对象和工程化的理解也更加深入了&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;工程化的个人见解&quot;&gt;工程化的个人见解&lt;/h2&gt;
&lt;p&gt;关于工程化呢，其实说难也难，说简单也简单得很。&lt;/p&gt;
&lt;p&gt;一些具体的好处呢，笔者在前三次博客作业中均有不同程度的论述（此处不再赘述）：&lt;/p&gt;
&lt;p&gt;不过说到底呢，其实就几件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;任何时代任何情况下，左右战局的决定性因素，永远是人&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;因此，工程化的一个基本思想就是&lt;strong&gt;以人为本&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;从开发者角度，为开发者提供方便提高效率（无论是短期还是长期，无论是单人还是团队，都是需要考虑的）&lt;/li&gt;
&lt;li&gt;从商业团体角度，&lt;strong&gt;提高整体战斗力，创造更大的效益和价值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;从用户角度，让用户体验更优（或者说给用户提供足够的方便），&lt;strong&gt;让用户更加愿意直接或间接地掏腰包&lt;/strong&gt;（统计意义上的）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;此外，&lt;strong&gt;对于不同的解决方案，一般情况下存在即合理&lt;/strong&gt;（或者说，对于还没有被淘汰的解决方案，其存在终究是可以良好满足某些场合下的需求的）。对此，我们该做的，就是&lt;strong&gt;具体问题具体分析，选择在具体情况下最优的方案&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;课程思考与建议&quot;&gt;课程思考与建议&lt;/h2&gt;
&lt;h3 id=&quot;个人的思考与建议&quot;&gt;个人的思考与建议&lt;/h3&gt;
&lt;p&gt;关于这个问题，笔者在两三个月前，就已经开始思考了。&lt;/p&gt;
&lt;p&gt;众所周知，面向对象课程的槽点还是不算少的。&lt;/p&gt;
&lt;p&gt;不过，据笔者看，这些问题看似庞杂，但是&lt;strong&gt;只要仔细去理一理背后的逻辑关系，其实也很简单&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;笔者根据自身了解的一些事实，和大半个学期以来的观察与分析，粗略的得到了下面的这张逻辑图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/703546/201806/703546-20180625071343780-1373883948.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过这样一来，看似错综复杂的事情也就清楚了。&lt;/p&gt;
&lt;p&gt;稍加观察，便可以发现问题的根源——&lt;strong&gt;没有一个相对公平合理的横向比较机制&lt;/strong&gt;。（稍微了解拓扑排序的概念，便可以得出这样的结论，找到节点的上游）&lt;/p&gt;
&lt;p&gt;其实，很多同学（包括16级的和以前的学长学姐们）之前所吐槽过的问题，根源都在这边。&lt;/p&gt;
&lt;p&gt;假如，我们有一个很靠谱的自动化横向比较机制&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;那么，我们的分数将更具有梯度和区分度，且&lt;strong&gt;评分核心依据将是程序的真实质量&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;那么，互测的实际门槛将可以考虑提高，互测人员的整体素质也将提高&lt;/li&gt;
&lt;li&gt;那么，基于上一条，我们将不再需要每次祈祷不遇上坏人（指的是为了自己的分数可以不要脸良心还从不痛的那种）&lt;/li&gt;
&lt;li&gt;那么，基于上一条，我们的助教们将不再需要面临巨大的仲裁任务压力&lt;/li&gt;
&lt;li&gt;那么，基于上一条，我们的同学们将不再需要承受等待助教仲裁的痛苦煎熬&lt;/li&gt;
&lt;li&gt;那么，&lt;strong&gt;我们的评测将可以考虑部分模糊化，以适应模糊化的需求&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;那么，基于上一条，我们的同学可以不再不停地纠结需求细节（常常还是无关紧要的细节），助教们也将大大减少issue答疑时间&lt;/li&gt;
&lt;li&gt;那么，基于以上所有条，我们的&lt;strong&gt;同学们的整体体验将有质的飞跃&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;那么，基于上一条，&lt;strong&gt;同学们将更加愿意积极努力学习这门课程&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实际上，想做出改变，也并不难，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;公测不再严格面向bug出数据。或者至少不完全面向bug，面向bug的部分可以作为功能性弱测。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动化公测引入模糊化测试&lt;/strong&gt;。比如类似于oj中的&lt;code&gt;Special Judge&lt;/code&gt;和提交答案题里面的部分分机制相结合，让程序只要不违背基本法（例如电梯不准瞬移不准分身）就能有分数，且各个水准的程序得分有梯度。&lt;/li&gt;
&lt;li&gt;可以将面向bug的功能性弱测和模糊化性能强测相结合，构建出更有游戏性的制度（也可以允许在一定时间内公测多次提交，多次刷分，追求卓越）。&lt;/li&gt;
&lt;li&gt;由此，可以基于公测最终成绩，设立一定的互测门槛，通过门槛者方可进入互测环节。&lt;/li&gt;
&lt;li&gt;在互测环节中，可以设计类似&lt;code&gt;codeforces&lt;/code&gt;那样的多对多大混战hack模式（也可以考虑待测程序不匿名，从此不再有无效作业的坑），&lt;strong&gt;保证互测的运气成分降到最低&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然以上只是一些初步构想，&lt;strong&gt;笔者对于这个（自认为）靠谱的新制度，已经有了更深层次的计划和构想&lt;/strong&gt;，更具体的计划等细节将在另一篇文章中详细阐述。&lt;/p&gt;
&lt;h3 id=&quot;想对接下来的分析者们说的一些话&quot;&gt;想对接下来的分析者们说的一些话&lt;/h3&gt;
&lt;p&gt;笔者写到这里之前，看过之前不少同学的一些思考与建tu议cao。&lt;/p&gt;
&lt;p&gt;不得不说，虽然&lt;strong&gt;大部分的所谓分析完全流于表面&lt;/strong&gt;，透过现象看本质的几乎没有（截至2018.6.25 6点整），但是，大家反映的问题，也很真实，或者说&lt;strong&gt;很真实地描绘了大众水平同学眼中的面向对象课程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;说这个，其实不是想吐槽各位（实际上，笔者更希望大家能继续描述内心的真实体验）。&lt;/p&gt;
&lt;p&gt;引用笔者之前说过不止一遍的一句话&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;没法带来丝毫改变，甚至只会让事情更坏的怒火，是毫无意义的。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以呢，希望接下来看到笔者文章的各位，能&lt;strong&gt;在吐槽的基础上和自身能力所及的情况下，进行更深入的思考，可以的话也多想想到底如何才能让事情变得更好&lt;/strong&gt;，而不是一味地抱怨与泄私愤。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抱怨没有用，实干才能解决问题&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Sun, 24 Jun 2018 23:37:00 +0000</pubDate>
<dc:creator>HansBug</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HansBug/p/9222492.html</dc:identifier>
</item>
<item>
<title>Java高并发之锁优化 - 大道方圆</title>
<link>http://www.cnblogs.com/xdecode/p/9137804.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xdecode/p/9137804.html</guid>
<description>&lt;p&gt;本文主要讲并行优化的几种方式, 其结构如下:&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201806/1285727-20180625070314183-2036349251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;锁优化&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;减少锁的持有时间&lt;/h4&gt;
&lt;p&gt;例如避免给整个方法加锁&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; syncMethod(){ 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        othercode1(); 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        mutextMethod(); 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        othercode2(); 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改进后&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; syncMethod2(){ 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        othercode1(); 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;){ 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;            mutextMethod(); 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        } 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        othercode2(); 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;减小锁的粒度&lt;/h4&gt;
&lt;p&gt;将大对象，拆成小对象，大大增加并行度，降低锁竞争. 如此一来偏向锁，轻量级锁成功率提高. &lt;/p&gt;
&lt;p&gt;一个简单的例子就是jdk内置的ConcurrentHashMap与SynchronizedMap.&lt;/p&gt;
&lt;p&gt;Collections.synchronizedMap&lt;/p&gt;
&lt;p&gt;其本质是在读写map操作上都加了锁, 在高并发下性能一般.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201805/1285727-20180530222925997-1117168164.png&quot; alt=&quot;&quot; width=&quot;475&quot; height=&quot;294&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ConcurrentHashMap&lt;/p&gt;
&lt;p&gt;内部使用分区Segment来表示不同的部分, 每个分区其实就是一个小的hashtable. 各自有自己的锁. &lt;/p&gt;
&lt;p&gt;只要多个修改发生在不同的分区, 他们就可以并发的进行. 把一个整体分成了16个Segment, 最高支持16个线程并发修改. &lt;/p&gt;
&lt;p&gt;代码中运用了很多volatile声明共享变量, 第一时间获取修改的内容, 性能较好.&lt;/p&gt;
&lt;h4&gt;读写分离锁替代独占锁&lt;/h4&gt;
&lt;p&gt;顾名思义, 用ReadWriteLock将读写的锁分离开来, 尤其在读多写少的场合, 可以有效提升系统的并发能力.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读-读不互斥：读读之间不阻塞。&lt;/li&gt;
&lt;li&gt;读-写互斥：读阻塞写，写也会阻塞读。&lt;/li&gt;
&lt;li&gt;写-写互斥：写写阻塞。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;锁分离&lt;/h4&gt;
&lt;p&gt;在读写锁的思想上做进一步的延伸, 根据不同的功能拆分不同的锁, 进行有效的锁分离.&lt;/p&gt;
&lt;p&gt;一个典型的示例便是LinkedBlockingQueue,在它内部, take和put操作本身是隔离的, &lt;/p&gt;
&lt;p&gt;有若干个元素的时候, 一个在queue的头部操作, 一个在queue的尾部操作, 因此分别持有一把独立的锁.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201806/1285727-20180613070619982-1230258202.png&quot; alt=&quot;&quot; width=&quot;558&quot; height=&quot;143&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Lock held by take, poll, etc &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReentrantLock &lt;strong&gt;takeLock&lt;/strong&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Wait queue for waiting takes &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Condition notEmpty =&lt;span&gt; takeLock.newCondition();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Lock held by put, offer, etc &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReentrantLock &lt;strong&gt;putLock&lt;/strong&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Wait queue for waiting puts &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Condition notFull = putLock.newCondition();
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;锁粗化&lt;/h4&gt;
&lt;p&gt;通常情况下, 为了保证多线程间的有效并发, 会要求每个线程持有锁的时间尽量短, &lt;/p&gt;
&lt;p&gt;即在使用完公共资源后, 应该立即释放锁. 只有这样, 等待在这个锁上的其他线程才能尽早的获得资源执行任务.&lt;/p&gt;
&lt;p&gt;而凡事都有一个度, 如果对同一个锁不停的进行请求 同步和释放, 其本身也会消耗系统宝贵的资源, 反而不利于性能的优化&lt;/p&gt;
&lt;p&gt;一个极端的例子如下, 在一个循环中不停的请求同一个锁.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 1000; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(lock){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 优化后&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(lock){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0;i &amp;lt; 1000; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;锁粗化与减少锁的持有时间, 两者是截然相反的, 需要在实际应用中根据不同的场合权衡使用.&lt;/p&gt;
&lt;p&gt;JDK中各种涉及锁优化的并发类可以看之前的博文: &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/xdecode/p/9102741.html&quot;&gt;并发包总结&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;ThreadLocal&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;除了控制有限资源访问外, 我们还可以增加资源来保证对象线程安全.&lt;/p&gt;
&lt;p&gt;对于一些线程不安全的对象, 例如SimpleDateFormat, 与其加锁让100个线程来竞争获取, &lt;/p&gt;
&lt;p&gt;不如准备100个SimpleDateFormat, 每个线程各自为营, 很快的完成format工作.&lt;/p&gt;
&lt;h4&gt;示例&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadLocalDemo {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ThreadLocal&amp;lt;SimpleDateFormat&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadLocal();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         ExecutorService service = Executors.newFixedThreadPool(10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             service.submit(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (threadLocal.get() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                         threadLocal.set(&lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyy-MM-dd&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;                     System.out.println(threadLocal.get().format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;原理&lt;/h4&gt;
&lt;p&gt;对于set方法, 先获取当前线程对象, 然后getMap()获取线程的ThreadLocalMap, 并将值放入map中.&lt;/p&gt;
&lt;p&gt;该map是线程Thread的内部变量, 其key为threadlocal, vaule为我们set进去的值.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; set(T value) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Thread t =&lt;span&gt; Thread.currentThread();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         ThreadLocalMap map =&lt;span&gt; getMap(t);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             map.set(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, value);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;            createMap(t, value);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于get方法, 自然是先拿到map, 然后从map中获取数据.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T get() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Thread t =&lt;span&gt; Thread.currentThread();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         ThreadLocalMap map =&lt;span&gt; getMap(t);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             ThreadLocalMap.Entry e = map.getEntry(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (T)e.value;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; setInitialValue();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;内存释放&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;手动释放: 调用threadlocal.set(null)或者threadlocal.remove()即可&lt;/li&gt;
&lt;li&gt;自动释放: 关闭线程池, 线程结束后, 自动释放threadlocalmap.&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StaticThreadLocalTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ThreadLocal tt = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadLocal();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         ExecutorService service = Executors.newFixedThreadPool(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             service.submit(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     BigMemoryObject oo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BigMemoryObject();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                    tt.set(oo);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 做些其他事情
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放方式一: 手动置null
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;                    tt.set(null);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放方式二: 手动remove
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;                    tt.remove();&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放方式三: 关闭线程或者线程池
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接new Thread().start()的场景, 会在run结束后自动销毁线程
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        service.shutdown();&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             Thread.sleep(24 * 3600 * 1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构建一个大内存对象, 便于观察内存波动.&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BigMemoryObject{
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    BigMemoryObject() {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10000000; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            list.add(i);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;内存泄露&lt;/h4&gt;
&lt;p&gt;内存泄露主要出现在无法关闭的线程中, 例如web容器提供的并发线程池, 线程都是复用的.&lt;/p&gt;
&lt;p&gt;由于ThreadLocalMap生命周期和线程生命周期一样长. 对于一些被强引用持有的ThreadLocal, 如定义为static.&lt;/p&gt;
&lt;p&gt;如果在使用结束后, 没有手动释放ThreadLocal, 由于线程会被重复使用, 那么会出现之前的线程对象残留问题,&lt;/p&gt;
&lt;p&gt;造成内存泄露, 甚至业务逻辑紊乱.&lt;/p&gt;
&lt;p&gt;对于没有强引用持有的ThreadLocal, 如方法内变量, 是不是就万事大吉了呢? 答案是否定的.&lt;/p&gt;
&lt;p&gt;虽然ThreadLocalMap会在get和set等操作里删除key 为 null的对象, 但是这个方法并不是100%会执行到.&lt;/p&gt;
&lt;p&gt;看ThreadLocalMap源码即可发现, 只有调用了getEntryAfterMiss后才会执行清除操作, &lt;/p&gt;
&lt;p&gt;如果后续线程没满足条件或者都没执行get set操作, 那么依然存在内存残留问题.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ThreadLocal.ThreadLocalMap.Entry getEntry(ThreadLocal key) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (table.length - 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         ThreadLocal.ThreadLocalMap.Entry e =&lt;span&gt; table[i];
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; e.get() ==&lt;span&gt; key)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 并不是一定会执行&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getEntryAfterMiss(key, i, e);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; ThreadLocal.ThreadLocalMap.Entry getEntryAfterMiss(ThreadLocal key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, ThreadLocal.ThreadLocalMap.Entry e) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         ThreadLocal.ThreadLocalMap.Entry[] tab =&lt;span&gt; table;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; tab.length;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             ThreadLocal k =&lt;span&gt; e.get();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (k ==&lt;span&gt; key)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除key为null的value&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                expungeStaleEntry(i);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;                 i =&lt;span&gt; nextIndex(i, len);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             e =&lt;span&gt; tab[i];
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;最佳实践&lt;/h4&gt;
&lt;p&gt;不管threadlocal是static还是非static的, 都要像加锁解锁一样, 每次用完后, 手动清理, 释放对象.&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;无锁&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;与锁相比, 使用CAS操作, 由于其非阻塞性, 因此不存在死锁问题, 同时线程之间的相互影响, &lt;/p&gt;
&lt;p&gt;也远小于锁的方式. 使用无锁的方案, 可以减少锁竞争以及线程频繁调度带来的系统开销.&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;例如生产消费者模型中, 可以使用BlockingQueue来作为内存缓冲区, 但他是基于锁和阻塞实现的线程同步.&lt;/p&gt;
&lt;p&gt;如果想要在高并发场合下获取更好的性能, 则可以使用基于CAS的ConcurrentLinkedQueue. &lt;/p&gt;
&lt;p&gt;同理, 如果可以使用CAS方式实现整个生产消费者模型, 那么也将获得可观的性能提升, 如Disruptor框架.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于无锁, 这边不再赘述, 之前博文已经有所介绍, 具体见: &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/xdecode/p/9022525.html&quot;&gt;Java高并发之无锁与Atomic源码分析&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 24 Jun 2018 23:18:00 +0000</pubDate>
<dc:creator>大道方圆</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xdecode/p/9137804.html</dc:identifier>
</item>
<item>
<title>C# Dictionary详解 - 大兄弟竹子</title>
<link>http://www.cnblogs.com/joeymary/p/9222488.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/joeymary/p/9222488.html</guid>
<description>&lt;h3 id=&quot;看完这篇再也不怕面试官问我c中字典的问题啦&quot;&gt;看完这篇再也不怕面试官问我C#中字典的问题啦。&lt;/h3&gt;
&lt;p&gt;开讲。&lt;/p&gt;
&lt;p&gt;我们知道Dictionary的最大特点就是可以通过任意类型的key寻找值。而且是通过索引，速度极快。&lt;br/&gt;该特点主要意义：数组能通过索引快速寻址，其他的集合基本都是以此为基础进行扩展而已。 但其索引值只能是int，某些情境下就显出Dictionary的便利性了。&lt;br/&gt;那么问题就来了--C#是怎么做的呢，能使其做到泛型索引。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/776708/201806/776708-20180625001403462-481994959.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们关注圈中的内容，这是Dictionary的本质 --- 两个数组，。这是典型的用空间换取时间的做法。&lt;br/&gt;先来说下两数组分别代表什么。&lt;br/&gt;1- buckets，int[] ，水桶！不过我觉得用仓库更为形象。eg: buckets = new int[3]; 表示三个仓库，i = buckets [0] ，if i = -1 表示该仓库为空，否则表示第一个仓库存储着东西。这个东西表示数组entries的索引。&lt;br/&gt;2- entries ， Entry[] ，Entry是个结构，key,value就是我们的键值真实值，hashCode是key的哈希值，next可以理解为指针，这里先不具体展开。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[StructLayout(LayoutKind.Sequential)]
private struct Entry
{
    public int hashCode;
    public int next;
    public TKey key;
    public TValue value;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先说一下索引，如何用人话来解释呢？这么说吧，本身操作系统只支持地址寻址，如数组声明时会先存一个header，同时获取一个base地址指向这个header，其后的元素都是通过*(base+index)来进行寻址。&lt;br/&gt;基于这个共识，Dictionary用泛型key索引的实现就得想方设法把key转换到上面数组索引上去。&lt;/p&gt;
&lt;p&gt;也就是说要在记录的存储位置和它的关键字之间建立一个确定的对应关系 f,使每个关键字和结构中一个惟一的存储位置相对应。&lt;br/&gt;因而在查找时，只要根据这个对应关系 f 找到给定值 K 的函数值 f(K)。若结构中存在关键字和 K 相等的记录。在此，我们称这个对应关系 f 为哈希 (Hash) 函数，按这个思想建立的表为哈希表。&lt;/p&gt;
&lt;p&gt;回到Dictionary,这个f(K)就存在于key跟buckets之间：&lt;/p&gt;
&lt;p&gt;dic[key]加值的实现：entries数组加1,获取i--&amp;gt;key--&amp;gt;获取hashCode--&amp;gt;f(hashCode)--&amp;gt;确定key对应buckets中的某个仓库（buckets对应的索引）--&amp;gt;设置仓库里的东西（entries的索引 = i）&lt;br/&gt;dic[key]取值的实现：key--&amp;gt;获取hashCode--&amp;gt;f(hashCode)--&amp;gt;确定key对应buckets中的某个仓库（buckets对应的索引）--&amp;gt; 获取仓库里的东西(entries的索引i，上面有说到)--&amp;gt;真实的值entries[i]&lt;/p&gt;
&lt;p&gt;上面的流程中只有一个（f(K)获取仓库索引）让我们很难受，因为不认识，那现在问题变成了这个f(K)如何实现了。&lt;br/&gt;实现：&lt;/p&gt;
&lt;p&gt;` int index = hashCode % buckets.Length;&lt;/p&gt;
&lt;p&gt;这叫做除留余数法，哈希函数的其中一种实现。如果你自己写一个MyDictionary，可以用其他的哈希函数。&lt;/p&gt;
&lt;p&gt;举个例子,假设两数组初始大小为3， this.comparer.GetHashCode(4) &amp;amp; 0x7fffffff = 4：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Dictionary&amp;lt;int, string&amp;gt; dic = new Dictionary&amp;lt;int, string&amp;gt;(); 
dic.Add(4, &quot;value&quot;); 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;i=0,key=4--&amp;gt; hashCode=4.GetHashCode()=4--&amp;gt; f(hashCode)=4 % 3 = 1--&amp;gt;第1号仓库--&amp;gt;东西 i = 0.&lt;br/&gt;此时两数组状态为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/776708/201806/776708-20180625014129387-1575137558.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;取值按照之前说的顺序进行，仿佛已经完美。但这里还有个问题，不同的key生成的hashCode经过f(K)生成的值不是唯一的。即一个仓库可能会放很多东西。&lt;/p&gt;
&lt;p&gt;C#是这么解决的，每次往仓库放东西的时候，先判断有没有东西（buckets[index] 是否为 -1），如果有，则进行修改。&lt;br/&gt;如再：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dic.Add(7, &quot;value&quot;);
dic.Add(10, &quot;value&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;f(entries[1]. hashCode)=7 % 3 = 1也在第一号仓库，则修改buckets[1] = 1。&lt;br/&gt;同时修改entries[1].next = 0;//上一个仓库的东西&lt;/p&gt;
&lt;p&gt;f(entries[2].hashCode)=10 % 3 = 1也在第一号仓库，则再修改buckets[1] = 2。&lt;br/&gt;同时修改entries[1].next = 1;//上一个仓库的东西&lt;/p&gt;
&lt;p&gt;这样相当于1号仓库存了一个单向链表，entries:2-1-0。&lt;/p&gt;
&lt;p&gt;成功解决。&lt;/p&gt;
&lt;p&gt;这里有人如果看过这些集合源码的话知道数组一般会有一个默认大小（当然我们初始化集合的时候也可以手动传入capacity），总之，Length不可能无限大。&lt;br/&gt;那么当集合满的时候，我们需对集合进行扩容，C#一般直接Length*2。那么buckets.Length就是可变的，上面的f(K)结果也就不是恒定的。&lt;/p&gt;
&lt;p&gt;C#对此的解决放在了扩容这一步：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/776708/201806/776708-20180625011910856-956352989.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到扩容实质就是新开辟一个更大空间的数组，讲道理是耗资源的。所以我们在初始化集合的时候，每次都给定一个合适的Capacity，讲道理是一个老油条该干的事儿。&lt;/p&gt;
&lt;p&gt;上面说的这就是所谓“用空间换取时间的做法”，两个数组存了一个集合，而集合中我们最关心的value仿佛是个主角，一堆配角作陪。&lt;/p&gt;
&lt;h3 id=&quot;现在看下源码实现&quot;&gt;现在看下源码实现：&lt;/h3&gt;
&lt;p&gt;索引器取值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/776708/201806/776708-20180625023058719-867758879.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/776708/201806/776708-20180625001217999-1814944536.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1,2,3,4,5就是本文的重点。基本都讲到了，其中4 ，5 -- (this.entries[i].hashCode == num) &amp;amp;&amp;amp; this.comparer.Equals(this.entries[i].key, key)：确定唯一key value对的条件，hashCode相等，key也得相等。&lt;/p&gt;
&lt;p&gt;说明hashCode也有相等的情况，其实这里 (this.entries[i].hashCode == num)这个条件可以省略，因为如果key Equal则hashCode 肯定相等。当然&amp;amp;&amp;amp;符号会先计算第一个条件，比较hashCode快得多，先过滤掉一大部分元素，最后再用Equals比较确定。&lt;/p&gt;
&lt;p&gt;Thanks All.&lt;/p&gt;
&lt;p&gt;欢迎讨论~&lt;br/&gt;感谢阅读~&lt;/p&gt;
&lt;p&gt;个人公众号：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/776708/201805/776708-20180513175442855-1199387064.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://www.cnblogs.com/joeymary/p/9222488.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/joeymary/p/9222488.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 24 Jun 2018 18:17:00 +0000</pubDate>
<dc:creator>大兄弟竹子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/joeymary/p/9222488.html</dc:identifier>
</item>
<item>
<title>【JMeter】---HTTP压测 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/9222433.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/9222433.html</guid>
<description>
&lt;h2&gt;&lt;span&gt;一、创建线程组&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;        右击--&amp;gt;添加--&amp;gt;Threads(Users)--&amp;gt;线程组&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180624224655031-114017947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面对比较重要的几个参数，讲解下：&lt;/p&gt;
&lt;p&gt;          &lt;strong&gt;名称&lt;/strong&gt;： 就是给你这个线程组起名字。&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;线程数&lt;/strong&gt;：指压力测试时候模拟几个用户测试接口。&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;Ramp-Up&lt;/strong&gt;：这里指几秒运行完上面的模拟用户数。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;循环次数&lt;/strong&gt;：指循环几次线程数。&lt;/p&gt;
&lt;p&gt;总的理解下：上面的意思是2秒内模拟5个用户请求API，循环2次。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、添加HTTP&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;      在线程组上右击--&amp;gt;添加--&amp;gt;Sampler--&amp;gt;HTTP请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180624230220893-301765298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在java代码中添加API接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@RequestMapping(value = &quot;users&quot;, method =&lt;span&gt; RequestMethod.GET)  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; @ResponseBody Object users() {
        List&lt;/span&gt;&amp;lt;String&amp;gt; userList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        userList.add(&lt;/span&gt;&quot;张三&quot;&lt;span&gt;);
        userList.add(&lt;/span&gt;&quot;李四&quot;&lt;span&gt;);
        userList.add(&lt;/span&gt;&quot;王五&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;获取用户接口......&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userList;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;三、查看结果树&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;       在线程组上右击--&amp;gt;添加--&amp;gt;监听器--&amp;gt;察看结果树&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180624231126557-791681153.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    运行JMter查看结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180624231812106-1526935082.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    通过测试可以发现，已经向users接口请求10次，10次都成功，也都有返回数据。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;四、响应断言&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 响应断言： 断言用于检查测试中得到的相应数据等是否符合预期，断言一般用来设置检查点，用以保证性能测试过程中的数据交互是否与预期一致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 增加断言: 在线程组上右击--&amp;gt; 添加--&amp;gt; 断言 --&amp;gt; 响应断言&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180624234818535-672803744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;apply to(应用范围):&lt;/p&gt;
&lt;p&gt;     Main sample only: 仅当前父取样器 进行断言，一般一个请求，如果发一个请求会触发多个，则就有sub sample（比较少用）&lt;/p&gt;
&lt;p&gt;常用响应字段：&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;响应文本&lt;/strong&gt;：即响应的数据，比如json等文本&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;响应代码&lt;/strong&gt;：http的响应状态码，比如200，302，404这些&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;响应信息&lt;/strong&gt;：http响应代码对应的响应信息，例如：OK, Found&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;Response Header&lt;/strong&gt;: 响应头&lt;/p&gt;
&lt;p&gt;模式匹配规则：&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;包括&lt;/strong&gt;：包含在里面就成功&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt; equals&lt;/strong&gt;：完全匹配，区分大小写&lt;/p&gt;
&lt;p&gt; 再次运行JMeter，查看结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180624234937220-1548465827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现http请求报错，因为返回数据不包含断言中所设定的数据。（一般调试阶段可以设置断言，但真实压力测试情况下建议不要开启断言和查看结果树，因为会因为性能问题，使测试结果不十分准确）&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;五、聚合报告&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;     线程组右击--&amp;gt;添加-&amp;gt;监听器-&amp;gt;聚合报告（Aggregate Report）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180625000202425-2105246315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;lable&lt;/strong&gt;: sampler的名称&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;Samples&lt;/strong&gt;: 一共发出去多少请求,例如5个用户，循环2次，则是 10&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;Average: 平均响应时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;Median&lt;/strong&gt;: 中位数，也就是 50％ 用户的响应时间&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;90% Line : 90％ 用户的响应不会超过该时间&lt;/span&gt; （90％的样本不超过这个时间。 剩下的样本至少与此一样长）&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;95% Line&lt;/strong&gt; : 95％ 用户的响应不会超过该时间&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;99% Line&lt;/strong&gt; : 99％ 用户的响应不会超过该时间&lt;/p&gt;
&lt;p&gt;             &lt;strong&gt;min&lt;/strong&gt; : 最小响应时间&lt;/p&gt;
&lt;p&gt;            &lt;strong&gt;max&lt;/strong&gt; : 最大响应时间&lt;/p&gt;
&lt;p&gt;        &lt;span&gt;Error%：错误的请求的数量/请求的总数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;Throughput： 吞吐量——默认情况下表示每秒完成的请求数（Request per Second) 可类比为qps&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;KB/Sec&lt;/strong&gt;: 每秒接收数据量&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;六、自定义变量&lt;/strong&gt;&lt;/span&gt; &lt;/h2&gt;
&lt;p&gt;      为什么使用：很多变量在全局中都有使用，或者测试数据更改，可以在一处定义，四处使用比如服务器地址你如果每一个里面都手动输入127.0.0.1，那万一那天服务器地址变了，总不能在一个一个改服务器地址&lt;/p&gt;
&lt;p&gt;吧，那么这里我们可以写在全局配置文件中。&lt;/p&gt;
&lt;p&gt;     线程组-&amp;gt;add -&amp;gt; Config Element(配置原件)-&amp;gt; User Definde Variable（用户定义的变量）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180625002728372-761780166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面配置了两个全局变量：&lt;/p&gt;
&lt;p&gt;引用方式${XXX}，在接口中变量中使用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180625003315575-1916095752.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;七、CSV可变参数压测&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; &lt;strong&gt;作用&lt;/strong&gt;：你在API接口传入参数的时候，不可能100次请求都传一样的参数，为了更真是的模拟用户，所传的参数当然也是随机的，这样才更真实。&lt;/p&gt;
&lt;p&gt; 线程组右击--&amp;gt;add -&amp;gt; Config Element(配置原件)--&amp;gt; CSV data set config (CSV数据文件设置)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180625010656409-688238074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比较关键的参数：&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt; 文件名&lt;/strong&gt;：就是你引用的文件地址（因为大量的数据都会写在外部文件中）&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;变量名称&lt;/strong&gt;：如果有多个用逗号隔开&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;分隔符&lt;/strong&gt;：csv默认用逗号，如果是txt文件这个需要设置符号&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 1、user.csv文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180625010610631-1194944825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、HTTP请求&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180625010802152-896557880.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、API接口&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
@RequestMapping(value = &quot;login&quot;, method =&lt;span&gt; RequestMethod.POST)  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; @ResponseBody Object login(String name, String pwd) {
        
         List&lt;/span&gt;&amp;lt;String&amp;gt; userList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
            userList.add(name);
            userList.add(pwd);
            userList.add(name.length()&lt;/span&gt;+&quot;&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出客户端传来的值&lt;/span&gt;
            System.out.println(&quot;name:&quot;+name+&quot;----pwd:&quot;+&lt;span&gt;pwd);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userList;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 测试运行（看java控制台）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180625011143074-1640663051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;想太多，做太少，中间的落差就是烦恼。想没有烦恼，要么别想，要么多做。少校【20】&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 24 Jun 2018 17:18:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/9222433.html</dc:identifier>
</item>
<item>
<title>.NET Core微服务之基于IdentityServer建立授权与验证服务（续） - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/identityserver4_foundation_and_quickstart_02.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/identityserver4_foundation_and_quickstart_02.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/identityserver4_foundation_and_quickstart_01.html&quot; target=&quot;_blank&quot;&gt;上一篇&lt;/a&gt;我们基于IdentityServer4建立了一个AuthorizationServer，并且继承了QuickStartUI，能够成功获取Token了。这一篇我们了解下如何集成API Service和MVC Web Application。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;1.1 添加ASP.NET Core WebAPI项目&lt;/h2&gt;
&lt;p&gt;　　新建两个WebAPI程序，假设这里取名为ApiService01（占用端口5010）和ApiService02（占用端口5020）。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180603142110235-2104564052.png&quot; alt=&quot;&quot; width=&quot;402&quot; height=&quot;282&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为了方便快速启动，可以继续在launchSettings.json中删掉关于IISExpress的部分，由于是WebAPI，所以也不需要启动浏览器（将其设为false）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;profiles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Manulife.DNC.MSAD.IdentityServer4Test.ApiService01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;commandName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Project&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;launchBrowser&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;strong&gt;&lt;span&gt;false&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;launchUrl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/values&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;environmentVariables&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ASPNETCORE_ENVIRONMENT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Development&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      },
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;applicationUrl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5010/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.2 安装IdentityServer4.AccessTokenValidation&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;NuGet&amp;gt;Install-Package IdentityServer4.AccessTokenValidation　　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　安装完成之后，需要做一些适配，所以我们来注册一下关于其的配置：这里设置的默认模式是Bearer，其中AddIdentityServerAuthentication方法是将我们上一篇创建的授权服务器注册为token的处理人，即在本API程序中涉及到token的处理，都会移交给指定服务器（这里即上一篇中创建的AuthorizationServer）进行处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
    {
        ......

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; IdentityServer&lt;/span&gt;
&lt;span&gt;        services.AddMvcCore().AddAuthorization().AddJsonFormatters();
        services.AddAuthentication(Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Identity:Scheme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
            .AddIdentityServerAuthentication(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                options.RequireHttpsMetadata &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; for dev env&lt;/span&gt;
                options.Authority = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://{Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;Identity:IP&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]}:{Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;Identity:Port&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                options.ApiName &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service:Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; match with configuration in IdentityServer&lt;/span&gt;
&lt;span&gt;            });

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Swagger&lt;/span&gt;
&lt;span&gt;        ......
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　配置文件中的内容如下所示：&lt;strong&gt;&lt;span&gt;&lt;em&gt;这里需要注意的是Name需要和我们在上一篇中的InMemoryConfiguration中自行hard-code的一样&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c028aec7-3df1-4559-bbd1-689c296de77a')&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_c028aec7-3df1-4559-bbd1-689c296de77a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c028aec7-3df1-4559-bbd1-689c296de77a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c028aec7-3df1-4559-bbd1-689c296de77a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c028aec7-3df1-4559-bbd1-689c296de77a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5010&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DocName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS Client Service API&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Description&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS Client Service API provide some API to help you get client information from CAS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Contact&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS 2.0 Team&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Email&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EdisonZhou@manulife.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;XmlFile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Manulife.DNC.MSAD.IdentityServer4Test.ApiService01.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Scheme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　此外，还需要在Configure方法中配置Authentication中间件：&lt;span&gt;&lt;strong&gt;&lt;em&gt;这里需要注意的就是需要放在UseMvc()之前调用&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; authentication&lt;/span&gt;
&lt;span&gt;        app.UseAuthentication();

        app.UseMvc();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; swagger&lt;/span&gt;
&lt;span&gt;        .......
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上是ApiService01的配置，ApiService02的配置类似，只是配置文件中的信息从clientservice改为了productservice。&lt;/p&gt;
&lt;h2&gt;1.3 为要进行验证授权的方法添加[Authorize]特性&lt;/h2&gt;
&lt;p&gt;　　由于我们创建WebAPI时，默认有一个ValuesController，保留它，我们直接为这个Controller添加一个[Authorize]特性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;    [Authorize]&lt;/strong&gt;
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : Controller
    {
        ......
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样的话，刚刚注册的中间件就会在请求的过程中基于传递过来的token进行Authorization，如果没有token或者token是非法的，它就会告诉api的消费者这个请求时未授权的（HTTP StatusCode 401）&lt;/p&gt;
&lt;h2&gt;1.4 简单测试一下&lt;/h2&gt;
&lt;p&gt;　　测试之前首先确保AuthorizationServer和两个ApiService都一起启动，可以在解决方案属性的启动选项中进行设置。&lt;/p&gt;
&lt;p&gt;　　（1）不带token的情况&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180624103534380-1093006979.png&quot; alt=&quot;&quot; width=&quot;595&quot; height=&quot;201&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（2）带正确token的情况&lt;/p&gt;
&lt;p&gt;　　首先请求获取一下token：这里我们使用的grant_type是client_credentials，也可以使用password（需要输入用户名和密码）。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180624103902415-1818164810.png&quot; alt=&quot;&quot; width=&quot;686&quot; height=&quot;351&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　带上这个token再去调用api service&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180624103921219-2035787986.png&quot; alt=&quot;&quot; width=&quot;685&quot; height=&quot;242&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（3）带不正确的token的情况（这里简单改一下token的值）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180624104106584-386993377.png&quot; alt=&quot;&quot; width=&quot;684&quot; height=&quot;232&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（4）用刚刚授予(clientservice)的token访问未经授权的productservice&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180624104309701-1945805467.png&quot; alt=&quot;&quot; width=&quot;683&quot; height=&quot;228&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们也可以通过在ValuesController中加上如下的一句，来获取Claims =&amp;gt; 它是从已验证过的token中抽取的信息。如果我们将上面获取的token的grant_type设置为password的话，那我们会在Claims中获取到用户ID的信息。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180624105204118-1771066938.png&quot; alt=&quot;&quot; width=&quot;676&quot; height=&quot;185&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180624105249832-1518996899.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.1 添加ASP.NET Core MVC项目&lt;/h2&gt;
&lt;p&gt;　　新建一个ASP.NET Core MVC项目，这里假设取名为MvcClient（占用端口5100）&lt;/p&gt;
&lt;p&gt;　　仍然修改launchSettings.json，删掉IISExpress部分，但仍然选择启动浏览器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;profiles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Manulife.DNC.MSAD.IdentityServer4Test.MvcClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;commandName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Project&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;launchBrowser&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;environmentVariables&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ASPNETCORE_ENVIRONMENT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Development&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      },
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;applicationUrl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5100/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.2 为指定方法添加[Authorize]特性&lt;/h2&gt;
&lt;p&gt;　　这里我们在HomeController的About方法上面添加[Authorize]特性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;    [Authorize]
    &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult About()
    {
        ViewData[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Your application description page.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这时如果我们直接访问About，会抛异常，告知我们No authenticationScheme was specified......&lt;/p&gt;
&lt;p&gt;　　而我们想要的效果是当User第一次点击About，页面重定向到AuthorizationServer (localhost:5000)，当用户登录验证授权之后，再重定向到该网站。此后一定时间范围内的第二次，第三次点击，都不再需要再重定向到AuthorizationServer，而是直接读取保存的token。&lt;/p&gt;
&lt;h2&gt;2.3 添加OpenID Connect Authentication&lt;/h2&gt;
&lt;p&gt;　　这一部分主要集中于做Authentication（身份验证）而非Authorization（授权）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
    {
        services.AddMvc();

        &lt;strong&gt;JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear(); &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ensure not change any return Claims from Authorization Server&lt;/span&gt;
        &lt;strong&gt;services.AddAuthentication(options =&amp;gt;&lt;span&gt;
        {
            options.DefaultScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            options.DefaultChallengeScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;/strong&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; oidc =&amp;gt; open ID connect&lt;/span&gt;
&lt;span&gt;&lt;strong&gt;        })&lt;/strong&gt;
        &lt;strong&gt;.AddCookie(&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        .AddOpenIdConnect(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, options =&amp;gt;&lt;span&gt;
        {
            options.SignInScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            options.Authority &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://{Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;Identity:IP&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]}:{Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;Identity:Port&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            options.RequireHttpsMetadata &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;&lt;/strong&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; please use https in production env&lt;/span&gt;
            &lt;strong&gt;options.ClientId = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cas.mvc.client.implicit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            options.ResponseType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id_token token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;/strong&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; allow to return access token&lt;/span&gt;
            &lt;strong&gt;options.SaveTokens = &lt;span&gt;true&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;;&lt;/strong&gt;
        &lt;strong&gt;});&lt;/strong&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里我们使用的是implicit这个flow（详细内容可以阅读ddrsql的&lt;a href=&quot;http://www.cnblogs.com/ddrsql/p/7922451.html&quot; target=&quot;_blank&quot;&gt;IdentityServer4之Implicit（隐式许可）&lt;/a&gt;），它主要用于客户端应用程序（主要指基于javascript的应用），它允许客户端程序重定向到AuthorizationServer，然后带着token重定向回来。值得一提的是这里的ResponseType为&quot;id_token token&quot;，表示既获取id_token也获取access_token。而SaveTokens设为true则表示要将从AuthorizationServer返回的token持久化在cookie之中，这样就不用每次都去请求token了。&lt;/p&gt;
&lt;p&gt;　　当然，也还得在Configure方法中，配置Authentication中间件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
        {
            app.UseBrowserLink();
            app.UseDeveloperExceptionPage();
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            app.UseExceptionHandler(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Home/Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;strong&gt;app.UseAuthentication();&lt;/strong&gt;

        app.UseStaticFiles();

        app.UseMvc(routes &lt;/span&gt;=&amp;gt;&lt;span&gt;
        {
            routes.MapRoute(
                name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller=Home}/{action=Index}/{id?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        });
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　*.位置仍然需要在UseMvc之前。&lt;/p&gt;
&lt;h2&gt;2.4 在AuthorizationServer添加这个MvcClient&lt;/h2&gt;
&lt;p&gt; 　　在InMemoryConfiguration类中修改GetClients方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;Client&amp;gt;&lt;span&gt; GetClients()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
        {
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
            {
                ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client.api.service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                ClientSecrets &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientsecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256()) },
                AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.ResourceOwnerPasswordAndClientCredentials,
                AllowedScopes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
            },
            ......,
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
            {
                ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cas.mvc.client.implicit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                ClientName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS MVC Web App Client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.Implicit,
                RedirectUris &lt;/span&gt;= { $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://{Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;Clients:MvcClient:IP&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]}:{Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;Clients:MvcClient:Port&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]}/signin-oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                PostLogoutRedirectUris &lt;/span&gt;= { $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://{Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;Clients:MvcClient:IP&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]}:{Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;Clients:MvcClient:Port&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]}/signout-callback-oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                AllowedScopes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; [] {
                    IdentityServerConstants.StandardScopes.OpenId,
                    IdentityServerConstants.StandardScopes.Profile,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;agentservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                },
                AllowAccessTokensViaBrowser &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; can return access_token to this client&lt;/span&gt;
&lt;span&gt;            }
        };
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里的ClientId要和MvcClient中设置的一致。RedirectUris是指登录成功之后需要重定向的地址（这里这个位置在MvcClient中），而PostLogoutRedirectUris是指登出之后需要重定向的地址。和API Service Client的设置不同的就是在AllowedScopes中给它增加了OpenId和Profile，因为我们为MvcClient设定的是oidc而不是bearer的模式。最后为了使用这些OpenID Connect Scopes，需要设置这些Identity Resources：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;IdentityResource&amp;gt;&lt;span&gt; GetIdentityResources()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;IdentityResource&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IdentityResources.OpenId(),
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IdentityResources.Profile(),
        };
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
    {
        .......

        services.AddIdentityServer()
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.AddDeveloperSigningCredential()&lt;/span&gt;
            .AddSigningCredential(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; X509Certificate2(Path.Combine(basePath,
                Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Certificates:CerPath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]),
                Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Certificates:Password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
            &lt;strong&gt;.AddInMemoryIdentityResources(InMemoryConfiguration.GetIdentityResources())&lt;/strong&gt;
            .AddTestUsers(InMemoryConfiguration.GetUsers().ToList())
            .AddInMemoryClients(InMemoryConfiguration.GetClients())
            .AddInMemoryApiResources(InMemoryConfiguration.GetApiResources());
        ......
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　同时，为了演示方便，我们在MvcClient的About视图中添加几句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@{
    ViewData[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;About&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&amp;lt;h2&amp;gt;@ViewData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]&amp;lt;/h2&amp;gt;
&amp;lt;h3&amp;gt;@ViewData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]&amp;lt;/h3&amp;gt;&lt;span&gt;

@using Microsoft.AspNetCore.Authentication
&lt;/span&gt;&amp;lt;div&amp;gt;
    &amp;lt;strong&amp;gt;id_token&amp;lt;/strong&amp;gt;
    &amp;lt;span&amp;gt;@await ViewContext.HttpContext.GetTokenAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;strong&amp;gt;access_token&amp;lt;/strong&amp;gt;
    &amp;lt;span&amp;gt;@await ViewContext.HttpContext.GetTokenAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;access_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;dl&amp;gt;&lt;span&gt;
    @foreach (&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; claim &lt;span&gt;in&lt;/span&gt;&lt;span&gt; User.Claims)
    {
        &lt;/span&gt;&amp;lt;dt&amp;gt;@claim.Type&amp;lt;/dt&amp;gt;
        &amp;lt;dd&amp;gt;@claim.Value&amp;lt;/dd&amp;gt;&lt;span&gt;
    }
&lt;/span&gt;&amp;lt;/dl&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里我们将id_token, access_token（&lt;span&gt;&lt;em&gt;&lt;strong&gt;只有拿到access_token，才可以在MvcClient中发起请求调用API Service，而具体可以访问哪些API Service是在InMemoryConfiguration中配置的AllowScopes里面的那些&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;）都显示出来，还会将Claims数据也显示出来（这里的Claims数据就是从AuthorizationServer返回的token里面payload部分的数据，关于payload请搜索JWT）&lt;/p&gt;
&lt;h2&gt;2.5 简单测试一下&lt;/h2&gt;
&lt;p&gt;　　（1）未登陆的情况&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180624112958299-9190343.gif&quot; alt=&quot;&quot; width=&quot;674&quot; height=&quot;332&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　拿到access_token，可以去JWT.io上进行解析看看：比如关注payload部分，可以得到很多信息，比如过期时间为1小时（默认）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180624123411899-646211769.png&quot; alt=&quot;&quot; width=&quot;655&quot; height=&quot;241&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（2）已登录的情况&lt;/p&gt;
&lt;p&gt;　　这里为了方便演示，新增一个Logout方法：这里需要确保同时登出MvcClient的Cookies和OpenId Connect（即到Identity Server去清除单点登录的Session）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController: Controller
    {
        ......

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Logout()
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; HttpContext.SignOutAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; HttpContext.SignOutAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        ......
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180624114052490-916564112.gif&quot; alt=&quot;&quot; width=&quot;674&quot; height=&quot;332&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最后，关于access token的生命周期，可以阅读一下园友晓晨Master（李志强）的《&lt;a href=&quot;https://www.cnblogs.com/stulzq/p/8998274.html&quot;&gt;IdentityServer4实战 - AccessToken 生命周期分析&lt;/a&gt;》，里面提到一个时间偏移的概念，需要了解一下。另外，如果是前后端分离的结构，也可以浏览一下ddrsql的《&lt;a href=&quot;https://www.cnblogs.com/ddrsql/p/8004888.html&quot;&gt;IdentityServer4之Implicit(隐式许可) —— oidc-client-js前后端分离&lt;/a&gt;》，里面介绍了oidc-client这个JS库的使用，以及如何支持跨域。&lt;/p&gt;

&lt;p&gt;　　本篇基于上一篇搭建好的AuthorizationServer，通过集成API Service与MVC Web Application来演示他们如何与Authorization Server的交互，了解了两种不同的Scheme（Bearer和Implicit），最后补充了一些材料供扩展阅读。但是，IdentityServer的内容很多，我只是学习了一些我要掌握以做POC的部分，其他还有很多功能和知识点我没有学习，大家可以通过搜索园子里各种大神（eg.晓晨Master, solenovex等等等等）的文章进行学习。后面我会将IdentityServer与Ocelot进行集成，尝试在API网关处做统一验证与授权。最后，感谢参考资料的作者们，本篇主要基于参考资料的学习而成的笔记。另外，一些朋友十分想要一些基于生产环境的采坑经验以及更加实际的应用案例，对此我只能说声抱歉，我目前仍然处于学习与准备POC阶段，目的是为了在公司里推广以及给老板安利（虽然很难），还没有实际项目迁移到.NET Core微服务架构上去，但是如果不努力让公司迁移和应用，那像我司一样的传统行业的金融保险公司是不会主动升级的，还请各位谅解。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180624182939525-1422084203.jpg&quot; alt=&quot;&quot; width=&quot;219&quot; height=&quot;208&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　Click =&amp;gt; &lt;a href=&quot;https://github.com/EdisonChou/EDC.IdentityServer4.Demo&quot; target=&quot;_blank&quot;&gt;https://github.com/EdisonChou/EDC.IdentityServer4.Demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;《&lt;a href=&quot;https://identityserver4.readthedocs.io/en/release/&quot; target=&quot;_blank&quot;&gt;identityserver4官方文档&lt;/a&gt;》&lt;strong&gt;&lt;em&gt;=&amp;gt; 重点关注那些流程图与术语&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ddrsql，《&lt;a href=&quot;https://www.cnblogs.com/ddrsql/p/7922451.html&quot;&gt;IdentityServer4之Implicit(隐式许可)&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;solenovex，《&lt;a href=&quot;http://www.cnblogs.com/cgzl/p/7746496.html&quot; target=&quot;_blank&quot;&gt;学习Identity Server4的预备知识&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;solenovex，《&lt;a href=&quot;https://www.cnblogs.com/cgzl/p/7780559.html&quot;&gt;使用Identity Server 4建立Authorization Server (1)&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;solenovex，《&lt;a href=&quot;https://www.cnblogs.com/cgzl/p/7788636.html&quot;&gt;使用Identity Server 4建立Authorization Server (2)&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;solenovex，《&lt;a href=&quot;https://www.cnblogs.com/cgzl/p/7793241.html&quot;&gt;使用Identity Server 4建立Authorization Server (3)&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;晓晨Master，《&lt;a href=&quot;https://www.cnblogs.com/stulzq/p/8998274.html&quot;&gt;IdentityServer4实战 - AccessToken 生命周期分析&lt;/a&gt;》&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 24 Jun 2018 16:36:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/identityserver4_foundation_and_quickstart_02.html</dc:identifier>
</item>
<item>
<title>[参考]用递归的方法获取 字符 对应的 二进制字符串 (C/C++) - 司徒鲜生</title>
<link>http://www.cnblogs.com/stxs/p/9222421.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stxs/p/9222421.html</guid>
<description>&lt;p&gt;将字符转换为16进制字符串、十进制字符串可以参考这里：&lt;a href=&quot;https://www.cnblogs.com/stxs/p/8846545.html&quot;&gt;https://www.cnblogs.com/stxs/p/8846545.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;代码及调试结果&lt;/h2&gt;
&lt;p&gt;举例：字符'a'，它对应的ASCII码为0011 0110，没错我就是要在屏幕上输出0011 0110！！！&lt;/p&gt;
&lt;p&gt;具体的代码贴在下面，注释写的很清楚，需要的话可以仔细研究一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;56&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;
using namespace std;
// 核心函数
// ch:传入的字符; n:n*2对应对了当前ch的进制数，初始值选为16。
// m:指针，用于索引数组,初始值为0; out_bin[]：输出的二进制字符串
void Char2Bin(unsigned char ch,int n, int *m, unsigned char out_bin[]){
    if (n&amp;gt;4){
        // 当前的ch将变为16位的二进制，之后将变成4位的二进制，所以 n/4(16/4)
        Char2Bin(ch/n,n/4,m,out_bin);
        Char2Bin(ch%n,n/4,m,out_bin);
    }
    else if (n&amp;gt;2){
        // 当前的ch将变为4位的二进制，之后将变成2位的二进制，所以 n/2(4/2)
        Char2Bin(ch/n,n/2,m,out_bin);
        Char2Bin(ch%n,n/2,m,out_bin);
    }
    else{
        // 当前ch是2位的二进制,只需将其转化为0和1即可
        out_bin[(*m)++] = ch/2 + '0';
        out_bin[(*m)++] = ch%2 + '0';
        return;    // 到这里必须返回，否则都会运行最后一行再返回，造成冗余
    }
    out_bin[8] = '\0'; // 字符数组最后以'\0'结尾就会变成字符串,
    // 可以参考 http://www.runoob.com/cplusplus/cpp-strings.html
}

// 调试部分
void main (){
    unsigned char out[9];
    int m = 0;
    Char2Bin('a',16,&amp;amp;m,out); // 当前ch是32位的二进制
    cout &amp;lt;&amp;lt; out &amp;lt;&amp;lt; endl;
    system(&quot;pause&quot;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1357381/201806/1357381-20180625003124970-811713504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 24 Jun 2018 16:31:00 +0000</pubDate>
<dc:creator>司徒鲜生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stxs/p/9222421.html</dc:identifier>
</item>
<item>
<title>WebGL绘制有宽度的线 - 木的树</title>
<link>http://www.cnblogs.com/dojo-lzz/p/9219290.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dojo-lzz/p/9219290.html</guid>
<description>&lt;p&gt;　　WebGL中有宽度的线一直都是初学者的一道门槛，因为在windows系统中底层的渲染接口都是D3D提供的，所以无论你的lineWidth设置为多少，最终绘制出来的只有一像素。即使在移动端可以设置有宽度的线，但是在拐弯处原生api没有做任何处理，所以往往达不到项目需求，再者比如对于虚线、导航线的绘制，原生api是无能为力。差不多从事WebGL开发已经一周年，总结一下绘制线的方法和踩过的坑，聊以慰藉后来者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201806/412020-20180623234001381-545231329.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;宽度线绘制原理&lt;/h2&gt;
&lt;p&gt;　　宽度线的绘制最核心的思想就是利用三角形来绘制线，将一根有宽度的线，看成是多个三角形的拼接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201806/412020-20180623230211367-1346388664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　将线剖分成三角形的过程是一个计算密集型的过程，如果放在主线程中会阻塞渲染造成卡顿，通常来讲都是放到顶点着色器中来处理，利用GPU并行计算来处理。通常来着色中，将顶点沿着法线方向平移lineWidth/2的距离。对于一个顶点只能平移一次，所以在cpu中我们需要把一个顶点复制两份传给gpu同时提前确定好剖分出来的三角形的顶点索引顺序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201806/412020-20180623230012368-1347896590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对于拐弯处，需要做一系列的计算来确定拐角的距离，比如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201806/412020-20180623231355888-364760055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　但这幅图过于复杂，我比较喜欢下面这个比较简单的图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201806/412020-20180623231513015-1644583238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　假设dir1为向量last-&amp;gt;current的单位向量，dir2为向量current-&amp;gt;next的单位向量，根据这两个向量求出avg向量，avg向量 = normalize(dir1 + dir2)；将avg向量旋转九十度即可求出在拐角处的偏移向量，当然这个向量可向下，也可以向上，所以一般对上文中重复的顶点还有对应的一个side变量，来告诉着色器应该向下还是向上偏移，同样上面图中的last和next也要传入对应上一个和下一个顶点的坐标值。对应的着色器代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ios11下直接使用==判断会有精度问题导致两个数字不相同引出bug&lt;/span&gt;
'    if( abs(nextP.x - currentP.x)&amp;lt;=0.000001 &amp;amp;&amp;amp; abs(nextP.y - currentP.y)&amp;lt;=0.000001) dir = normalize( currentP - prevP );'&lt;span&gt;,
&lt;/span&gt;'    else if( abs(prevP.x - currentP.x)&amp;lt;=0.000001 &amp;amp;&amp;amp; abs(prevP.y - currentP.y) &amp;lt;=0.000001) dir = normalize( nextP - currentP );'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; '    if( nextP.x == currentP.x &amp;amp;&amp;amp; nextP.y == currentP.y) dir = normalize( currentP - prevP );',&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; '    else if( prevP.x == currentP.x &amp;amp;&amp;amp; prevP.y == currentP.y ) dir = normalize( nextP - currentP );',&lt;/span&gt;
'    else {'&lt;span&gt;,
&lt;/span&gt;'        vec2 dir1 = normalize( currentP - prevP );'&lt;span&gt;,
&lt;/span&gt;'        vec2 dir2 = normalize( nextP - currentP );'&lt;span&gt;,
&lt;/span&gt;'        dir = normalize( dir1 + dir2 );'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'    }'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'    vec2 normal = vec2( -dir.y, dir.x );',
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;着色器中的实践&lt;/h2&gt;
&lt;p&gt;　　原理上面已经实现，那么在具体的绘制中，我们还要明白一个问题，lineWidth的单位是什么，如果你需要绘制的是以像素为单位，那么我们就需要将3d坐标映射到屏幕坐标来进行计算，这样绘制出来的线不会有明显的透视效果，即不会受相机距离远近的影响。&lt;/p&gt;
&lt;p&gt;　　我们需要几个函数来帮忙，第一个是transform函数，用来将3D坐标转换成透视坐标系下的坐标：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
'vec4 transform(vec3 coord) {'&lt;span&gt;,
&lt;/span&gt;'    return projectionMatrix * modelViewMatrix * vec4(coord, 1.0);'&lt;span&gt;,
&lt;/span&gt;'}',
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　接下来是project函数，这个函数传入的是透视坐标，也就是经过transform函数返回的坐标；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
'vec2 project(vec4 device) {'&lt;span&gt;,
&lt;/span&gt;'    vec3 device_normal = device.xyz / device.w;'&lt;span&gt;,
&lt;/span&gt;'    vec2 clip_pos = (device_normal * 0.5 + 0.5).xy;'&lt;span&gt;,
&lt;/span&gt;'    return clip_pos * resolution;'&lt;span&gt;,
&lt;/span&gt;'}',
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中第一步device.xyz / device.w将坐标转化成ndc坐标系下的坐标，这个坐标下，xyz的范围全部都是-1~1之间。&lt;/p&gt;
&lt;p&gt;　　第二步device_normal * 0.5后所有坐标的取值范围在-0.5~0.5之间，后面在加上0.5后坐标范围变为0~1之间，由于我们绘线在屏幕空间，所以z值无用可以丢弃，这里我们只取xy坐标。&lt;/p&gt;
&lt;p&gt;　　第三部resolution是一个vec2类型，代表最终展示canvas的宽高。将clip_pos * resolution完全转化成屏幕坐标，这时候x取值范围在0~width之间，y取值范围在0~height之间，单位像素。&lt;/p&gt;

&lt;p&gt;　　接下来的unproject函数，这个函数的作用是当我们在屏幕空间中计算好最终顶点位置后，将该屏幕坐标重新转化成透视空间下的坐标。是project的逆向过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
'vec4 unproject(vec2 screen, float z, float w) {'&lt;span&gt;,
&lt;/span&gt;'    vec2 clip_pos = screen / resolution;'&lt;span&gt;,
&lt;/span&gt;'    vec2 device_normal = clip_pos * 2.0 - 1.0;'&lt;span&gt;,
&lt;/span&gt;'    return vec4(device_normal * w, z, w);'&lt;span&gt;,
&lt;/span&gt;'}',
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由于屏幕空间的坐标没有z值和w值，所以需要外界传入。&lt;/p&gt;
&lt;p&gt; 　　最终着色器代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('913ff488-c0a2-4df8-a661-ac589d870f83')&quot; readability=&quot;79.5&quot;&gt;&lt;img id=&quot;code_img_closed_913ff488-c0a2-4df8-a661-ac589d870f83&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_913ff488-c0a2-4df8-a661-ac589d870f83&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('913ff488-c0a2-4df8-a661-ac589d870f83',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_913ff488-c0a2-4df8-a661-ac589d870f83&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;154&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vertexShaderSource =&lt;span&gt; [
&lt;/span&gt;'precision highp float;'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'attribute vec3 position;'&lt;span&gt;,
&lt;/span&gt;'attribute vec3 previous;'&lt;span&gt;,
&lt;/span&gt;'attribute vec3 next;'&lt;span&gt;,
&lt;/span&gt;'attribute float side;'&lt;span&gt;,
&lt;/span&gt;'attribute float width;'&lt;span&gt;,
&lt;/span&gt;'attribute vec2 uv;'&lt;span&gt;,
&lt;/span&gt;'attribute float counters;'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'uniform mat4 projectionMatrix;'&lt;span&gt;,
&lt;/span&gt;'uniform mat4 modelViewMatrix;'&lt;span&gt;,
&lt;/span&gt;'uniform vec2 resolution;'&lt;span&gt;,
&lt;/span&gt;'uniform float lineWidth;'&lt;span&gt;,
&lt;/span&gt;'uniform vec3 color;'&lt;span&gt;,
&lt;/span&gt;'uniform float opacity;'&lt;span&gt;,
&lt;/span&gt;'uniform float near;'&lt;span&gt;,
&lt;/span&gt;'uniform float far;'&lt;span&gt;,
&lt;/span&gt;'uniform float sizeAttenuation;'&lt;span&gt;,
&lt;/span&gt;'uniform float forBorder;'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'varying vec2 vUV;'&lt;span&gt;,
&lt;/span&gt;'varying vec4 vColor;'&lt;span&gt;,
&lt;/span&gt;'varying float vCounters;'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'vec4 transform(vec3 coord) {'&lt;span&gt;,
&lt;/span&gt;'    return projectionMatrix * modelViewMatrix * vec4(coord, 1.0);'&lt;span&gt;,
&lt;/span&gt;'}'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'vec2 project(vec4 device) {'&lt;span&gt;,
&lt;/span&gt;'    vec3 device_normal = device.xyz / device.w;'&lt;span&gt;,
&lt;/span&gt;'    vec2 clip_pos = (device_normal * 0.5 + 0.5).xy;'&lt;span&gt;,
&lt;/span&gt;'    return clip_pos * resolution;'&lt;span&gt;,
&lt;/span&gt;'}'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'vec4 unproject(vec2 screen, float z, float w) {'&lt;span&gt;,
&lt;/span&gt;'    vec2 clip_pos = screen / resolution;'&lt;span&gt;,
&lt;/span&gt;'    vec2 device_normal = clip_pos * 2.0 - 1.0;'&lt;span&gt;,
&lt;/span&gt;'    return vec4(device_normal * w, z, w);'&lt;span&gt;,
&lt;/span&gt;'}'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'void main() {'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'    float aspect = resolution.x / resolution.y;', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 屏幕宽高比&lt;/span&gt;
'     float pixelWidthRatio = 1. / (resolution.x * projectionMatrix[0][0]);', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (r-l)/(2n*Width)&lt;/span&gt;
''&lt;span&gt;,
&lt;/span&gt;'    vColor = vec4( color, opacity );'&lt;span&gt;,
&lt;/span&gt;'    vUV = uv;'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'    vec4 finalPosition = transform(position);'&lt;span&gt;,
&lt;/span&gt;'    vec4 prevPos = transform(previous);'&lt;span&gt;,
&lt;/span&gt;'    vec4 nextPos = transform(next);'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'    vec2 currentP = project(finalPosition);'&lt;span&gt;,
&lt;/span&gt;'    vec2 prevP = project(prevPos);'&lt;span&gt;,
&lt;/span&gt;'    vec2 nextP = project(nextPos);'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'    vec2 dir;'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ios11下直接使用==判断会有精度问题导致两个数字不相同引出bug&lt;/span&gt;
'    if( abs(nextP.x - currentP.x)&amp;lt;=0.000001 &amp;amp;&amp;amp; abs(nextP.y - currentP.y)&amp;lt;=0.000001) dir = normalize( currentP - prevP );'&lt;span&gt;,
&lt;/span&gt;'    else if( abs(prevP.x - currentP.x)&amp;lt;=0.000001 &amp;amp;&amp;amp; abs(prevP.y - currentP.y) &amp;lt;=0.000001) dir = normalize( nextP - currentP );'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; '    if( nextP.x == currentP.x &amp;amp;&amp;amp; nextP.y == currentP.y) dir = normalize( currentP - prevP );',&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; '    else if( prevP.x == currentP.x &amp;amp;&amp;amp; prevP.y == currentP.y ) dir = normalize( nextP - currentP );',&lt;/span&gt;
'    else {'&lt;span&gt;,
&lt;/span&gt;'        vec2 dir1 = normalize( currentP - prevP );'&lt;span&gt;,
&lt;/span&gt;'        vec2 dir2 = normalize( nextP - currentP );'&lt;span&gt;,
&lt;/span&gt;'        dir = normalize( dir1 + dir2 );'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'    }'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'    vec2 normal = vec2( -dir.y, dir.x );'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; '    normal.x /= aspect;',&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; '    normal *= .5 * w;',&lt;/span&gt;
''&lt;span&gt;,
&lt;/span&gt;'    float realSide = forBorder &amp;gt; 0.0 ? (side &amp;lt; 0.0 ? side : 0.0) : side;'&lt;span&gt;,
&lt;/span&gt;'    vec2 pos = currentP + normal * lineWidth * realSide * 0.5;'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; '    vec4 offset = vec4( normal * realSide, 0.0, 1.0 );',// ndc空间上做偏移&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; '    finalPosition.xy += offset.xy;',&lt;/span&gt;
''&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; '    gl_Position = finalPosition;',&lt;/span&gt;
'    gl_Position = unproject(pos, finalPosition.z, finalPosition.w);'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'}' ];
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;虚线以及箭头的绘制原理&lt;/h2&gt;
&lt;p&gt;　　上面介绍了有宽度线的绘制，但是在一些地图场景中，往往需要绘制虚线、地铁线以及导航路线等有一定规则的路线。这里主要介绍导航线的绘制，明白这个后虚线以及地铁的线绘制就很简单了。首先介绍一下导航线的核心原理，要绘制导航线我们有几个问题需要解决，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;箭头的间隔&lt;/li&gt;
&lt;li&gt;一个箭头应该绘制在几米的范围内（范围计算不准图片会失真）&lt;/li&gt;
&lt;li&gt;如何让线区域范围内的每个像素取的纹理重对应像素&lt;/li&gt;
&lt;li&gt;以及一些各个机型上兼容性问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201806/412020-20180624000729865-32779500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　无论是虚线、地铁线、导航线都可以用这个图来表达。我们可以规定每个markerDelta米在halfd（halfd = markerDelta/2）到uvDelta长的距离里绘制一个标识（虚线的空白区域，地铁线的黑色区域、导航线的箭头）。那么问题来了如何让每一个像素都清楚的知道自己应该成为线的哪一部分？这个时候我的方案是求出每个顶点距离起始坐标点的 ~距离/路线总长度~，将这个距离存入纹理坐标中，利用纹理坐标的插值保证每个像素都能均匀的知道自己的长度占比；在着色器中乘以路线总长度，算出这个像素距离起始点距离uvx。uvx对markerDelta取模运算得muvx，求出在本间隔中的长度，在根据规则（if(muvx &amp;gt;= halfd &amp;amp;&amp;amp; muvx &amp;lt;= halfd + uvDelta)）计算这个像素是否在uvDelta中。对于导航线，我们需要从箭头图片的纹理中取纹素，所以该像素对应的真正的纹理坐标是float s = (muvx - halfd) / uvDelta;对应着色器代码为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;float&lt;/span&gt; uvx = vUV.x * repeat.x;'&lt;span&gt;,
&lt;/span&gt;'    &lt;span&gt;float&lt;/span&gt; muvx = mod(uvx, markerDelta);'&lt;span&gt;,
&lt;/span&gt;'    &lt;span&gt;float&lt;/span&gt; halfd = markerDelta / 2.0;'&lt;span&gt;,
&lt;/span&gt;'    &lt;span&gt;if&lt;/span&gt;(muvx &amp;gt;= halfd &amp;amp;&amp;amp; muvx &amp;lt;= halfd + uvDelta) {'&lt;span&gt;,
&lt;/span&gt;'      &lt;span&gt;float&lt;/span&gt; s = (muvx - halfd) / uvDelta;'&lt;span&gt;,
&lt;/span&gt;'      tc = texture2D( map, vec2(s, vUV.y));'&lt;span&gt;,
&lt;/span&gt;'      c.xyzw = tc.w &amp;gt;= 0.5 ? tc.xyzw : c.xyzw;'&lt;span&gt;,
&lt;/span&gt;'    }',
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最终完整着色器代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('034d8087-435c-42f9-94e6-e5d7639e2ea9')&quot; readability=&quot;55&quot;&gt;&lt;img id=&quot;code_img_closed_034d8087-435c-42f9-94e6-e5d7639e2ea9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_034d8087-435c-42f9-94e6-e5d7639e2ea9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('034d8087-435c-42f9-94e6-e5d7639e2ea9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_034d8087-435c-42f9-94e6-e5d7639e2ea9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;105&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; fragmentShaderSource =&lt;span&gt; [
        &lt;/span&gt;'#extension GL_OES_standard_derivatives : enable'&lt;span&gt;,
&lt;/span&gt;'precision highp float;'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'uniform sampler2D map;'&lt;span&gt;,
&lt;/span&gt;'uniform sampler2D alphaMap;'&lt;span&gt;,
&lt;/span&gt;'uniform float useMap;'&lt;span&gt;,
&lt;/span&gt;'uniform float useAlphaMap;'&lt;span&gt;,
&lt;/span&gt;'uniform float useDash;'&lt;span&gt;,
&lt;/span&gt;'uniform vec2 dashArray;'&lt;span&gt;,
&lt;/span&gt;'uniform float visibility;'&lt;span&gt;,
&lt;/span&gt;'uniform float alphaTest;'&lt;span&gt;,
&lt;/span&gt;'uniform vec2 repeat;'&lt;span&gt;,
&lt;/span&gt;'uniform float uvDelta;', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代表应该绘制箭头的区域&lt;/span&gt;
'uniform float markerDelta;'&lt;span&gt;,
&lt;/span&gt;'uniform vec3 borderColor;'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'varying vec2 vUV;'&lt;span&gt;,
&lt;/span&gt;'varying vec4 vColor;'&lt;span&gt;,
&lt;/span&gt;'varying float vCounters;'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'void main() {'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'  vec4 c = vColor;'&lt;span&gt;,
&lt;/span&gt;'  if (useMap &amp;gt; 0.0) {'&lt;span&gt;,
&lt;/span&gt;'    vec4 tc = vec4(1.0, 1.0, 1.0, 0.0);',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mod(vUV.x * repeat.x, 10.0) &amp;gt;= 0.0 ||&lt;/span&gt;
'    float uvx = vUV.x * repeat.x;'&lt;span&gt;,
&lt;/span&gt;'    float muvx = mod(uvx, markerDelta);'&lt;span&gt;,
&lt;/span&gt;'    float halfd = markerDelta / 2.0;'&lt;span&gt;,
&lt;/span&gt;'    if(muvx &amp;gt;= halfd &amp;amp;&amp;amp; muvx &amp;lt;= halfd + uvDelta) {'&lt;span&gt;,
&lt;/span&gt;'      float s = (muvx - halfd) / uvDelta;'&lt;span&gt;,
&lt;/span&gt;'      tc = texture2D( map, vec2(s, vUV.y));'&lt;span&gt;,
&lt;/span&gt;'      c.xyzw = tc.w &amp;gt;= 0.5 ? tc.xyzw : c.xyzw;'&lt;span&gt;,
&lt;/span&gt;'    }'&lt;span&gt;,
&lt;/span&gt;'  }'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; '     if( c.a &amp;lt; alphaTest ) c.a = 0.0;',&lt;/span&gt;

'    gl_FragColor = c;'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; '     gl_FragColor.a *= step(vCounters,visibility);',&lt;/span&gt;
'}' ];
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　关于markerDelta和uvDelta来说，则需要跟相机距离、纹理图片性质等因素来综合计算，比如在我的项目中的计算法方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
let meterPerPixel = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._getPixelMeterRatio();
      let radio &lt;/span&gt;= meterPerPixel / 0.0746455; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前比例尺与21级比例尺相比&lt;/span&gt;
      let mDelta = Math.min(30, Math.max(radio * 10, 1)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最大间隔为10米&lt;/span&gt;
      let uvDelta = 8 * meterPerPixel;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 8是经验值，实际要根据线实际像素宽度、纹理图片宽高比来计算&lt;/span&gt;
      uvDelta = &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;isIOSPlatform() ? 8 * meterPerPixel : &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;parseFloat(uvDelta.toFixed(2&lt;span&gt;));

      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.routes.forEach(r =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (r._isVirtual) {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        r._material.uniforms.uvDelta &lt;/span&gt;= {type: 'f', value: uvDelta};&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 暂时取一米&lt;/span&gt;
        r._material.uniforms.markerDelta = {type: 'f'&lt;span&gt;, value: mDelta};
      });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　另一个问题如何绘制有边框的线，可以在着色器中来控制，比如设定一个阈值，超过这个阈值的就绘制成border的颜色；或者简单点也可以把一条线绘制两遍，宽的使用border的颜色，窄的使用主线的颜色，同时控制两条线的绘制顺序，让主线压住border线。&lt;/p&gt;
&lt;h2&gt;兼容性的坑&lt;/h2&gt;
&lt;p&gt;　　首先发现在iphone6p 10.3.3中纹理失真；&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201806/412020-20180624003258972-380918329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　纹理失真肯定是设备像素与纹理纹素没有对应，但是为什么没有对应呢？纹理失真就是uv方向上对应问题，为了排查这个过程我把只要落在纹理区域的范围都设置成红色，发现在纵向方向上不管纹理在什么尺度下红色区域范围都是一样的，而且结合图片发现纵向上基本覆盖了整个纹理图片，所以纵向没有问题。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201806/412020-20180624003153210-1585926778.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　那么就是横向上的取值，问题，但是横向是通过纹理坐标产生的，没有计算的内容；最后怀疑到数字精度问题；将其中的mediump改成highp;这个问题得到解决；iphone6上能画出完美的箭头&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
'precision mediump float;',
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 　　然而又碰到了另一个非常棘手的问题，iphone7以上的设备箭头周围有碎点。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201806/412020-20180624003416271-1983024981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　首先要搞清楚这些碎点是什么，发现不论换那张图片都有碎点，一开始我以为这些碎点是纹理坐标计算时的精度问题，后来发现不论怎么调整纹理u的取值范围都无法做到在任何时刻完全避免这个问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201806/412020-20180624003544793-759937033.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最后偶然发现改变一下这个等式就能解决问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201806/412020-20180624003645775-1341235079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201806/412020-20180624003700655-1711328267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　所以肯定这个些碎点肯定是从纹理中取得的，有可能在这个区域内，Linear过滤模式刚好取得了几个像素的平均值，导致这里的alpha通道非是0.0同时取到了一定的平均颜色才会显示这些碎点；最后怀疑这是因为mipmap方式导致这个设备像素刚好落到前后两章图片的像素上，综合差值后得到一个碎点；至于是否是跟mipmap有关还需要后续验证，由于项目时间关系先往下解决。解决完这个问题已经是凌晨四点多&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201806/412020-20180624004054590-1739771128.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　然而又出现了另一个问题，iphone6下在某些角度下，纹理会消失，发现是因为上面的判断引起的&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201806/412020-20180624003935129-828763531.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　将阈值范围改成能够解决问题，后续这块需要梳理一下，作为一个外部可传入的变量来处理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201806/412020-20180624003905913-1167189705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;参考文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://codeflow.org/entries/2012/aug/05/webgl-rendering-of-solid-trails/&quot;&gt;&lt;span&gt;http://codeflow.org/entries/2012/aug/05/webgl-rendering-of-solid-trails/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://forum.libcinder.org/topic/smooth-thick-lines-using-geometry-shader&quot;&gt;&lt;span&gt;https://forum.libcinder.org/topic/smooth-thick-lines-using-geometry-shader&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Drawing Antialiased Lines with OpenGL&lt;a href=&quot;https://www.mapbox.com/blog/drawing-antialiased-lines/&quot;&gt;&lt;span&gt;https://www.mapbox.com/blog/drawing-antialiased-lines/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://forum.libcinder.org/topic/smooth-thick-lines-using-geometry-shader&quot;&gt;&lt;strong&gt;&lt;span&gt;Smooth thick lines using geometry shader&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mattdesl.svbtle.com/drawing-lines-is-hard&quot;&gt;&lt;strong&gt;&lt;span&gt;Drawing Lines is Hard&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 24 Jun 2018 16:14:00 +0000</pubDate>
<dc:creator>木的树</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dojo-lzz/p/9219290.html</dc:identifier>
</item>
<item>
<title>深度理解盒子大小的计算问题 - 保罗4592</title>
<link>http://www.cnblogs.com/zhangqiyu/p/9222395.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangqiyu/p/9222395.html</guid>
<description>&lt;p&gt;在HTML和css中，盒子的大小计算问题是一个比较重要的知识点，当我们从设计师的手上拿到设计稿时，就应该大概的了解到页面的布局，在布局时，就需要运用盒子来填充页面的各个板块。页面的宽高是固定的，盒子的个数是不固定的，这就需要前端人员合理的处理盒子与盒子之间的距离问题。&lt;/p&gt;
&lt;p&gt;盒子的布局有两种模式：box-sizing&lt;/p&gt;
&lt;p&gt;1、默认模式：content-box&lt;/p&gt;
&lt;p&gt;在content模式下，盒子的宽高指的是盒子内容的区域，即content区域，这种模式下，程序员在代码中给的宽高，并不是在页面中显示的宽高，页面中实际的宽高还要加上内边距、边框、外边距的距离：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1413239/201806/1413239-20180625000623335-669257365.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、border-box&lt;/p&gt;
&lt;p&gt;在此模式下（怪异模式），代码中的宽高即为边框的宽高，包含了内容和padding区域，所以在计算的时候，它的宽高直接在给定值得基础上加上margin就行了：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1413239/201806/1413239-20180625001316817-298579137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 24 Jun 2018 16:14:00 +0000</pubDate>
<dc:creator>保罗4592</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangqiyu/p/9222395.html</dc:identifier>
</item>
<item>
<title>Java垃圾回收手册翻译 - 什么是垃圾回收 - pyx0</title>
<link>http://www.cnblogs.com/pyx0/p/9222356.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pyx0/p/9222356.html</guid>
<description>&lt;h3 id=&quot;java垃圾回收手册翻译---什么是垃圾回收&quot;&gt;Java垃圾回收手册翻译 - 什么是垃圾回收&lt;/h3&gt;
&lt;p&gt;初看之下，垃圾回收应该要做其名称之事 - 找到和丢掉垃圾。然而事实上它正好做着相反的事，垃圾回收会记录所有仍在使用中的对象，然后将其他标记为垃圾。谨记这点，我们开始挖掘更多Java虚拟机如何实现被称为垃圾回收的自动化内存回收过程的细节。&lt;/p&gt;
&lt;p&gt;为了避免一头扎进细节，我们从头开始，解释垃圾回收的一般性质以及核心概念和方法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;免责声明：本手册关注于Oracle Hotspot和OpenJDK的表现，其他运行时甚至其他虚拟机，比如jRockit或IBM J9，会在某些方面有不同于本手册所涵盖的表现。&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;手动内存管理&quot;&gt;手动内存管理&lt;/h4&gt;
&lt;p&gt;在开始现代形式的垃圾回收内容之前，我们先快速回顾一下那些需要手动显示分配和释放数据内存的日子。那时候如果你忘记释放内存，你将不能重用那块内存。这部分内存会被声明到但是没有使用，这种场景叫做内存泄漏。&lt;/p&gt;
&lt;p&gt;下面是一个用C语言写的使用手动内存管理的简单例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int send_request() {
    size_t n = read_size();
    int *elements = malloc(n * sizeof(int));

    if(read_elements(n, elements) &amp;lt; n) {
        // elements not freed!
        return -1;
    }

    // …

    free(elements)
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正如我们所见，非常容易忘记释放内存。相比于现在，内存泄漏在过去是更加常见的问题。你只能通过修复代码才能真正的对付它们。因此，一个更好的方法是将回收不用的内存的工作自动化，整体消除可能产生的人为错误。这个自动化操作叫做垃圾回收（简称GC）。&lt;/p&gt;
&lt;h4 id=&quot;智能指针&quot;&gt;智能指针&lt;/h4&gt;
&lt;p&gt;一种自动化操作的方式是通过使用析构函数。例如，我们使用C++中的向量&lt;em&gt;vector&lt;/em&gt;做上一个例子中同样的事，它会在离开其作用域时自动的调用其析构函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int send_request() {
    size_t n = read_size();
    vector&amp;lt;int&amp;gt; elements = vector&amp;lt;int&amp;gt;(n);

    if(read_elements(elements.size(), &amp;amp;elements[0]) &amp;lt; n) {
        return -1;
    }

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是再更复杂的情况中，尤其是在多个线程中共享对象时，仅仅使用析构函数并不够。这就引出了垃圾回收最简单的形式：引用计数。对每个对象，你只需要知道它有多少次被引用到，并且当这个计数达到零时这个对象就可以安全的被回收。一个众所周知的例子是C++中的共享指针&lt;em&gt;shared pointers&lt;/em&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int send_request() {
    size_t n = read_size();
    auto elements = make_shared&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;();

    // read elements

    store_in_cache(elements);

    // process elements further

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，为了避免下次函数调用时再去读这个元素&lt;em&gt;elements&lt;/em&gt;，我们可能想要缓存他们。在这个例子中，就不能再当向量&lt;em&gt;vector&lt;/em&gt;离开作用域时销毁它。因此，我们使用共享指针&lt;em&gt;shared_ptr&lt;/em&gt;，它记录引用到它的数量，当你使用它传值时计数增加，同时当它离开作用域时计数减少。一旦引用的计数降到零，共享指针&lt;em&gt;shared_ptr&lt;/em&gt;就会自动地删除下面的向量。&lt;/p&gt;
&lt;p&gt;TBC...&lt;/p&gt;
</description>
<pubDate>Sun, 24 Jun 2018 15:54:00 +0000</pubDate>
<dc:creator>pyx0</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pyx0/p/9222356.html</dc:identifier>
</item>
</channel>
</rss>