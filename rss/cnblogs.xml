<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>线程池ThreadPoolExecutor整理 - 江湖前辈黄药师</title>
<link>http://www.cnblogs.com/xxj0316/p/9548626.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xxj0316/p/9548626.html</guid>
<description>&lt;p&gt;项目用到线程池,但是其实很多人对原理并不熟悉 ,这里只是整理一下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ThreadPoolExecutor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;构造方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; corePoolSize,
                              &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; maximumPoolSize,
                              &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;/span&gt;&amp;lt;Runnable&amp;gt;&lt;span&gt; workQueue,
                              ThreadFactory threadFactory) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             threadFactory, defaultHandler);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　corePoolSize 　　　　　　        核心线程数&lt;br/&gt;　　　　maximumPoolSize 　　　　       最大线程数 阻塞队列装不下的后 总得线程数  包含corePoolSize &lt;br/&gt;　　　　keepAliveTime 　　　　　　      超时时间 线程池中当前的空闲线程服务完某任务后的存活时间。如果时间足够长，那么可能会服务其它任务&lt;br/&gt;　　　　unit 　　　　　　　　　　　　  时间单位&lt;br/&gt;　　　　workQueue 　　　　　　　　    阻塞队列 线程数大于核心线程后放到队列中&lt;br/&gt;　　　　threadFactory　　　　　　　　 线程池工厂&lt;br/&gt;　　　　handler 　　　　　　　　　　   拒绝策略 阻塞队列满了,也达到了最大线程数 执行拒绝策略&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;corePoolSize：核心池的大小，在创建了线程池后，即在没有任务到来之前就创建  默认情况下，在创建了线程池后，线程池中的线程数为0，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法来预创建线程.当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，&lt;span&gt;只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用&lt;/span&gt;，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　1）当池子大小 小于corePoolSize就新建线程，并处理请求&lt;br/&gt;　　　　2）当池子大小 等于corePoolSize，把请求放入workQueue中，池子里的空闲线程就去从workQueue中取任务并处理&lt;br/&gt;　　　　3）当workQueue放不下新入的任务时，新建线程入池，并处理请求(不用等待队列)，如果池子大小撑到了maximumPoolSize就用RejectedExecutionHandler来做拒绝处理&lt;br/&gt;　　　　4）另外，当池子的线程数大于corePoolSize的时候，多余的线程会等待keepAliveTime长的时间，如果无请求可处理就自行销毁&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1009365/201808/1009365-20180828152006583-154276566.png&quot; alt=&quot;&quot; width=&quot;537&quot; height=&quot;302&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　处理步骤:  核心线程 &amp;lt;&amp;lt; 阻塞队列 &amp;lt;&amp;lt;最大线程数&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;通俗流程解释&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；&lt;br/&gt;　　　　当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；&lt;br/&gt;　　　　如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；&lt;br/&gt;　　　　然后就将任务也分配给这4个临时工人做；&lt;br/&gt;　　　　如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。&lt;br/&gt;　　　　当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的.&lt;br/&gt;　　　　这个例子中的corePoolSize就是10，而maximumPoolSize就是14（10+4）。&lt;/p&gt;
&lt;p&gt;　　　　也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。 &lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;阻塞队列&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；&lt;/p&gt;
&lt;p&gt;　　　　2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；&lt;/p&gt;
&lt;p&gt;　　　　3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;拒绝策略&lt;/strong&gt; 四种&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　AbortPolicy 默认 直接抛弃 并抛异常&lt;br/&gt;　　　　DiscardPolicy 直接抛弃 不抛异常&lt;br/&gt;　　　　CallerRunsPolicy 在主线程中执行&lt;br/&gt;　　　　DiscardOldestPolicy 把注册队列中最老的抛弃掉 执行当前的&lt;br/&gt;　　　　自定义的策略 实现RejectedExecutionHandler即可&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;测试案例&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {   
         ThreadPoolExecutor executor &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(5, 10, 200&lt;span&gt;, TimeUnit.MILLISECONDS,
                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(5&lt;span&gt;));
 
         &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;15;i++&lt;span&gt;){
             MyTask myTask &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyTask(i);
             executor.execute(myTask);
             System.out.println(&lt;/span&gt;&quot;线程池中线程数目：&quot;+executor.getPoolSize()+&quot;，队列中等待执行的任务数目：&quot;+&lt;span&gt;
             executor.getQueue().size()&lt;/span&gt;+&quot;，已执行完别的任务数目：&quot;+&lt;span&gt;executor.getCompletedTaskCount());
         }
         executor.shutdown();
     }
}
 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; MyTask &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; taskNum;
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyTask(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.taskNum =&lt;span&gt; num;
    }
 
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        System.out.println(&lt;/span&gt;&quot;正在执行task &quot;+&lt;span&gt;taskNum);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.currentThread().sleep(&lt;/span&gt;4000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&lt;/span&gt;&quot;task &quot;+taskNum+&quot;执行完毕&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;执行结果&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
正在执行task 0&lt;span&gt;
线程池中线程数目：&lt;/span&gt;1，队列中等待执行的任务数目：0，已执行完别的任务数目：0&lt;span&gt;
线程池中线程数目：&lt;/span&gt;2，队列中等待执行的任务数目：0，已执行完别的任务数目：0&lt;span&gt;
正在执行task &lt;/span&gt;1&lt;span&gt;
线程池中线程数目：&lt;/span&gt;3，队列中等待执行的任务数目：0，已执行完别的任务数目：0&lt;span&gt;
正在执行task &lt;/span&gt;2&lt;span&gt;
线程池中线程数目：&lt;/span&gt;4，队列中等待执行的任务数目：0，已执行完别的任务数目：0&lt;span&gt;
正在执行task &lt;/span&gt;3&lt;span&gt;
线程池中线程数目：&lt;/span&gt;5，队列中等待执行的任务数目：0，已执行完别的任务数目：0&lt;span&gt;
正在执行task &lt;/span&gt;4&lt;span&gt;
线程池中线程数目：&lt;/span&gt;5，队列中等待执行的任务数目：1，已执行完别的任务数目：0&lt;span&gt;
线程池中线程数目：&lt;/span&gt;5，队列中等待执行的任务数目：2，已执行完别的任务数目：0&lt;span&gt;
线程池中线程数目：&lt;/span&gt;5，队列中等待执行的任务数目：3，已执行完别的任务数目：0&lt;span&gt;
线程池中线程数目：&lt;/span&gt;5，队列中等待执行的任务数目：4，已执行完别的任务数目：0&lt;span&gt;
线程池中线程数目：&lt;/span&gt;5，队列中等待执行的任务数目：5，已执行完别的任务数目：0&lt;span&gt;
线程池中线程数目：&lt;/span&gt;6，队列中等待执行的任务数目：5，已执行完别的任务数目：0&lt;span&gt;
正在执行task &lt;/span&gt;10&lt;span&gt;
线程池中线程数目：&lt;/span&gt;7，队列中等待执行的任务数目：5，已执行完别的任务数目：0&lt;span&gt;
正在执行task &lt;/span&gt;11&lt;span&gt;
线程池中线程数目：&lt;/span&gt;8，队列中等待执行的任务数目：5，已执行完别的任务数目：0&lt;span&gt;
正在执行task &lt;/span&gt;12&lt;span&gt;
线程池中线程数目：&lt;/span&gt;9，队列中等待执行的任务数目：5，已执行完别的任务数目：0&lt;span&gt;
正在执行task &lt;/span&gt;13&lt;span&gt;
线程池中线程数目：&lt;/span&gt;10，队列中等待执行的任务数目：5，已执行完别的任务数目：0&lt;span&gt;
正在执行task &lt;/span&gt;14&lt;span&gt;
task 3执行完毕
task 0执行完毕
task 2执行完毕
task 1执行完毕
正在执行task &lt;/span&gt;8&lt;span&gt;
正在执行task &lt;/span&gt;7&lt;span&gt;
正在执行task &lt;/span&gt;6&lt;span&gt;
正在执行task &lt;/span&gt;5&lt;span&gt;
task 4执行完毕
task 10执行完毕
task 11执行完毕
task 13执行完毕
task 12执行完毕
正在执行task &lt;/span&gt;9&lt;span&gt;
task 14执行完毕
task 8执行完毕
task 5执行完毕
task 7执行完毕
task 6执行完毕
task 9执行完毕&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;strong&gt;如何合理的配置线程池&lt;/strong&gt;&lt;/strong&gt;
&lt;ul readability=&quot;9&quot;&gt;&lt;li readability=&quot;21&quot;&gt;
&lt;p&gt;要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;任务的性质：CPU密集型任务，IO密集型任务和混合型任务。&lt;/li&gt;
&lt;li&gt;任务的优先级：高，中和低。&lt;/li&gt;
&lt;li&gt;任务的执行时间：长，中和短。&lt;/li&gt;
&lt;li&gt;任务的依赖性：是否依赖其他系统资源，如数据库连接。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能少的线程数量，如配置N&lt;sub&gt;cpu&lt;/sub&gt;+1个线程的线程池。IO密集型任务则由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2*N&lt;sub&gt;cpu&lt;/sub&gt;。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。&lt;/p&gt;
&lt;p&gt;优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。&lt;/p&gt;
&lt;p&gt;执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。&lt;/p&gt;
&lt;p&gt;依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建议使用有界队列&lt;/strong&gt;，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最佳实践&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    //&lt;/span&gt;&lt;span&gt;创建线程池指定有意义的线程名字, 方便出错是回溯   &lt;/span&gt;
    ThreadFactory namedThreadFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadFactoryBuilder() .setNameFormat(&lt;/span&gt;&quot;demo-pool-%d&quot;&lt;span&gt;).build();
    ExecutorService singleThreadPool &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(1, 1&lt;span&gt;,
        &lt;/span&gt;0L&lt;span&gt;, TimeUnit.MILLISECONDS,&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(1024), namedThreadFactory, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor.AbortPolicy());

    singleThreadPool.execute(()&lt;/span&gt;-&amp;gt;&lt;span&gt; System.out.println(Thread.currentThread().getName())
    );
   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TimerTaskThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TimerTaskThread(){
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;.setName(&quot;TimerTaskThread&quot;&lt;span&gt;); 
           …
        }    
        …
   }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Tue, 28 Aug 2018 07:40:00 +0000</pubDate>
<dc:creator>江湖前辈黄药师</dc:creator>
<og:description>项目用到线程池,但是其实很多人对原理并不熟悉 ,这里只是整理一下 ThreadPoolExecutor java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xxj0316/p/9548626.html</dc:identifier>
</item>
<item>
<title>【worker】js中的多线程 - YanBigFeg</title>
<link>http://www.cnblogs.com/yanbigfeg/p/9546599.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanbigfeg/p/9546599.html</guid>
<description>&lt;p&gt;      因为下个项目中要用到一些倒计时的功能，所以就提前准备了一下，省的到时候出现一下界面不友好和一些其他的事情。正好趁着这个机会也加深一下html5中的多线程worker的用法和理解。&lt;/p&gt;
&lt;h2&gt;Worker简介&lt;/h2&gt;
&lt;p&gt;    JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。这些都是我们所公知的。但是随着业务的不断增加，只是单纯的单线程模式已经可能无法满足我们的需求了。于是在html5中新增了后台任务worker API。&lt;/p&gt;
&lt;p&gt;w3c中的介绍：web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。&lt;/p&gt;
&lt;p&gt;       worker就是为了JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。开启后台线程，在不影响前台线程的前提下做一些耗时或者异步的操作。因为是不同的线程，所以主线程与worker线程互不干扰。也不会相互打断。所以在一些场景可以提高页面的流程性。Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。&lt;/p&gt;
&lt;h2&gt;使用规则&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;必须同源：也就是所js文件的路径必须和主线程的脚本同源。防止了外部引用。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;dom限制：在worker线程中不能操作dom（document，windows，parent）。注意可以使用浏览器的navigator和location对象。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通讯限制：worker线程和主线程不在一个上下文中所有不能直接通讯。也就是说主线程定义的变量在worker中也是不能使用的。所有只能通过消息完成。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;提示禁止：worker线程不能alert和confirm，这个不知到具体原因？&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;传值dom：进行消息通讯也不能传值dom只能是变量。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ie限制：ie9不能使用！ie9不能使用！ie9不能使用！&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;worker文档&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Web Workers API的&lt;strong&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/strong&gt;界面代表了一个可以轻松创建的后台任务，可以将消息发送回其创建者。创建worker就像调用 构造函数并指定要在工作线程中运行的脚本一样简单。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;构造函数&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;worker（）：&lt;/span&gt;&lt;span&gt;&lt;span&gt;创建一个专用的Web worker，在指定的URL上执行脚本。示例：var worker=new Worker('js/setTime.js')；&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;属性&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;onerror：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这是一个在error事件发生时调用的函数，并且通过该函数冒泡worker。示例：worker.onerror=function(){....};&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;onmessage&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  这是一个worker中message事件要发生的时候调用的事件。  示例：worker.onmessage=function(){....};&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  这个事件一般与postMessage事件同时使用，一个用来发送数据，一个用来接受数据。例如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 主线程中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  var&lt;/span&gt; jsId = &quot;00001&quot;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; worker = &lt;span&gt;new&lt;/span&gt; Worker('js/setTime.js'&lt;span&gt;);
  worker.postMessage(jsId);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;         worker线程中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接受事件参数&lt;/span&gt;
onmessage = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {

    console.log(e.data[&lt;/span&gt;0&lt;span&gt;])
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就完成了一个主线程向worker线程传递参数的过程。同样如果worker线程要向主线程传递参数反过来写即可。&lt;/p&gt;
&lt;p&gt; onmessageerror：&lt;/p&gt;
&lt;p&gt;在消息传递过程出现错误的属性事件。示例：worker.onmessageerror=function(){....};&lt;/p&gt;
&lt;h3&gt;方法&lt;/h3&gt;
&lt;p&gt;postMessage：&lt;/p&gt;
&lt;p&gt;向线程worker的内部范围发送消息，可以设置参数，发送给worker线程的数据。在onmessage中接受。&lt;/p&gt;
&lt;p&gt;terminate：&lt;/p&gt;
&lt;p&gt;过多的开启worker线程非常浪费资源所以在使用过后可以终止它，终止方法使用terminate（）。示例：worker.terminate（）；&lt;/p&gt;
&lt;p&gt;close：&lt;/p&gt;
&lt;p&gt;除了上面的关闭，如果是在worker线程自身也可以使用self.close（）关闭。&lt;/p&gt;
&lt;h2&gt; 计时器示例&lt;/h2&gt;
&lt;p&gt;上面说了那么多都是介绍worker的一些基本属性或者方法的使用。下面通过具体的示例来看效果。&lt;/p&gt;
&lt;p&gt;我们就拿最常用的倒计时来做示例说明。很简单的一个例子。我们在业务中经常遇到倒计时业务，在倒计时的时候还要做一些其他的业务。因为js单线程的特性，你会发现你的倒计时在你进行其他业务操作的时候是暂停了的。例如现在是9:57你进行了三秒的业务处理。等业务处理完成应该是：9:54，但是你的倒计时还是9:57.就很明显的说明了这一个现象。&lt;/p&gt;
&lt;h3&gt;场景业务设计&lt;/h3&gt;
&lt;p&gt;那么我们现在设计这么一个业务操作，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先我们页面有一个定时器和一个业务操作按钮（用来模拟耗时的操作）。&lt;/li&gt;
&lt;li&gt;然后把定时器写到一个worker中进行倒计时操作。&lt;/li&gt;
&lt;li&gt;最后通过消息通讯把每次的倒计时时间发送给主线程让主线程修改显示时间。&lt;/li&gt;
&lt;li&gt;结束倒计时完毕结束定时器和线程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 有人可能会说为什么还要回到主线程修改时间显示值，请看一下上面的使用规则，我本来也是打算进行主线程传值dom给worker线程奈何不行只能在回传回来。&lt;/p&gt;
&lt;h3&gt;代码展示&lt;/h3&gt;
&lt;p&gt; Html代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;body&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;span id=&quot;Minute_p&quot;&amp;gt;10&amp;lt;/span&amp;gt; :
            &amp;lt;span id=&quot;Second_p&quot;&amp;gt;00&amp;lt;/span&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;button type=&quot;button&quot; onclick=&quot;business()&quot;&amp;gt;耗时操作&amp;lt;/button&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主线程js代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            //&lt;/span&gt;&lt;span&gt;页面加载完成后初始化&lt;/span&gt;
            window.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建定时器线程&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; worker = &lt;span&gt;new&lt;/span&gt; Worker('js/setTime.js'&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取dom对象&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; domMinute_p = document.getElementById('Minute_p'&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; domSecond_p = document.getElementById('Second_p'&lt;span&gt;);
                worker.postMessage(&lt;/span&gt;600&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里可以接受worker线程的返回值&lt;/span&gt;
                worker.onmessage = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; totalSecond =&lt;span&gt; event.data;
                    console.log(totalSecond)
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算分钟数&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; minute_p = parseInt(totalSecond / 60&lt;span&gt;);
                    domMinute_p.innerText &lt;/span&gt;=&lt;span&gt; minute_p;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算秒数&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; second_p = parseInt(totalSecond % 60&lt;span&gt;);
                    domSecond_p.innerText &lt;/span&gt;=&lt;span&gt; second_p;
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里是模拟的耗时操作&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; business() {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data = [1, 2, 3, 4, 5&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 1; i &amp;lt; 1000; i++&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j = 1; j &amp;lt; 1000; j++&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; k = 1; k &amp;lt; 5000; k++&lt;span&gt;) {
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b = k * 100&lt;span&gt;;
                        }
                    }
                }
                console.log(&lt;/span&gt;&quot;业务终于走完了！&quot;&lt;span&gt;)
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;worker线程js代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; totalSecond = 600&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; domMinute_p, domSecond_p,

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接受事件参数&lt;/span&gt;
    onmessage = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
        console.log(e.data)
        domMinute_p &lt;/span&gt;=&lt;span&gt; e.data;
    }
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; timeId = setInterval(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    totalSecond&lt;/span&gt;--&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(totalSecond == 0&lt;span&gt;) {
        self.close();
    }
    console.log(totalSecond)
    postMessage(totalSecond)

}, &lt;/span&gt;1000)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了大致示例就是这么多。下面是截图效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/809005/201808/809005-20180828114850882-233462241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 开始运行后编号1会开始倒计时，但是当你点击了编号2进行了模拟耗时后，编号1还是会卡住，只有完成编号2后才会运行，但是不同与上面说到的单线程是，他再次运行时的时间是正确时间，还是刚才的例子如果是9:57，点击编号2模拟耗时了3秒，耗时完成后编号1会显示9:54而不是单线程的9:57。就说明worker现在在耗时操作的时候是持续运行的，时间卡只不过是主线程的dom操作被卡住了而已（可以把耗时业务也开启worker就不卡住了）。这里只是介绍worker的使用，所有就不纠结这个界面显示的问题。&lt;/p&gt;


</description>
<pubDate>Tue, 28 Aug 2018 07:27:00 +0000</pubDate>
<dc:creator>YanBigFeg</dc:creator>
<og:description>因为下个项目中要用到一些倒计时的功能，所以就提前准备了一下，省的到时候出现一下界面不友好和一些其他的事情。正好趁着这个机会也加深一下html5中的多线程worker的用法和理解。 Worker简介 J</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yanbigfeg/p/9546599.html</dc:identifier>
</item>
<item>
<title>vue.js响应式原理解析与实现—实现v-model与{{}}指令 - 陈陈jg</title>
<link>http://www.cnblogs.com/chenjg/p/9548473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenjg/p/9548473.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chenjg/p/9541291.html&quot;&gt;上一节&lt;/a&gt;我们已经分析了vue.js是通过Object.defineProperty以及发布订阅模式来进行数据劫持和监听,并且实现了一个简单的demo。今天，我们就基于上一节的代码，来实现一个MVVM类，将其与html结合在一起，并且实现v-model以及{{}}语法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tips:本节新增代码（去除注释）在一百行左右。使用的Observer和Watcher都是延用上一节的代码，没有修改&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;接下来，让我们一步步来，实现一个MVVM类。&lt;/p&gt;
&lt;h3 id=&quot;构造函数&quot;&gt;构造函数&lt;/h3&gt;
&lt;p&gt;首先，一个MVVM的构造函数如下(和vue.js的构造函数一样)：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class MVVM {
  constructor({ data, el }) {
    this.data = data;
    this.el = el;
    this.init();
    this.initDom();
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和vue.js一样，有它的data属性以及el元素。&lt;/p&gt;
&lt;h3 id=&quot;初始化操作&quot;&gt;初始化操作&lt;/h3&gt;
&lt;p&gt;vue.js可以通过this.xxx的方法来直接访问this.data.xxx的属性，这一点是怎么做到的呢？其实答案很简单，它是通过Object.defineProperty来做手脚，当你访问this.xxx的时候，它返回的其实是this.data.xxx。当你修改this.xxx值的时候，其实修改的是this.data.xxx的值。具体可以看如下代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class MVVM {
  constructor({ data, el }) {
    this.data = data;
    this.el = el;
    this.init();
    this.initDom();
  }
  // 初始化
  init() {
    // 对this.data进行数据劫持
    new Observer(this.data);
    // 传入的el可以是selector,也可以是元素，因此我们要在这里做一层处理，保证this.$el的值是一个元素节点
    this.$el = this.isElementNode(this.el) ? this.el : document.querySelector(this.el);
    // 将this.data的属性都绑定到this上，这样用户就可以直接通过this.xxx来访问this.data.xxx的值
    for (let key in this.data) {
      this.defineReactive(key);
    }
  }
    
  defineReactive(key) {
    Object.defineProperty(this, key, {
      get() {
        return this.data[key];
      },
      set(newVal) {
        this.data[key] = newVal;
      }
    })
  }
  // 是否是属性节点
  isElementNode(node) {
    return node.nodeType === 1;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在完成初始化操作后，我们需要对this.$el的节点进行编译。目前我们要实现的语法有v-model和{{}}语法,v-model这个属性只可能会出现在元素节点的attributes里，而{{}}语法则是出现在文本节点里。&lt;/p&gt;
&lt;h3 id=&quot;fragment&quot;&gt;fragment&lt;/h3&gt;
&lt;p&gt;在对节点进行编译之前，我们先考虑一个现实问题：如果我们在编译过程中直接操作DOM节点的话，每一次修改DOM都会导致DOM的回流或重绘，而这一部分性能损耗是很没有必要的。因此，我们可以利用fragment,将节点转化为fragment,然后在fragment里编译完成后，再将其放回到页面上。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class MVVM {
  constructor({ data, el }) {
    this.data = data;
    this.el = el;
    this.init();
    this.initDom();
  }
  
  initDom() {
    const fragment = this.node2Fragment();
    this.compile(fragment);
    // 将fragment返回到页面中
    document.body.appendChild(fragment);
  }
  // 将节点转为fragment,通过fragment来操作DOM，可以获得更高的效率
  // 因为如果直接操作DOM节点的话，每次修改DOM都会导致DOM的回流或重绘，而将其放在fragment里，修改fragment不会导致DOM回流和重绘
  // 当在fragment一次性修改完后，在直接放回到DOM节点中
  node2Fragment() {
    const fragment = document.createDocumentFragment();
    let firstChild;
    while(firstChild = this.$el.firstChild) {
      fragment.appendChild(firstChild);
    }
    return fragment;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实现v-model&quot;&gt;实现v-model&lt;/h3&gt;
&lt;p&gt;在将node节点转为fragment后，我们来对其中的v-model语法进行编译。&lt;/p&gt;
&lt;p&gt;由于v-model语句只可能会出现在元素节点的attributes里，因此，我们先判断该节点是否为元素节点，若为元素节点，则判断其是否是directive(目前只有v-model)，若都满足的话，则调用CompileUtils.compileModelAttr来编译该节点。&lt;/p&gt;
&lt;p&gt;编译含有v-model的节点主要有两步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为元素节点注册input事件，在input事件触发的时候，更新vm(this.data)上对应的属性值。&lt;/li&gt;
&lt;li&gt;对v-model依赖的属性注册一个Watcher函数，当依赖的属性发生变化，则更新元素节点的value。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class MVVM {
  constructor({ data, el }) {
    this.data = data;
    this.el = el;
    this.init();
    this.initDom();
  }
  
  initDom() {
    const fragment = this.node2Fragment();
    this.compile(fragment);
    // 将fragment返回到页面中
    document.body.appendChild(fragment);
  }
  
  compile(node) {
    if (this.isElementNode(node)) {
      // 若是元素节点，则遍历它的属性，编译其中的指令
      const attrs = node.attributes;
      Array.prototype.forEach.call(attrs, (attr) =&amp;gt; {
        if (this.isDirective(attr)) {
          CompileUtils.compileModelAttr(this.data, node, attr)
        }
      })
    }
    // 若节点有子节点的话，则对子节点进行编译
    if (node.childNodes &amp;amp;&amp;amp; node.childNodes.length &amp;gt; 0) {
      Array.prototype.forEach.call(node.childNodes, (child) =&amp;gt; {
        this.compile(child);
      })
    }
  }
  // 是否是属性节点
  isElementNode(node) {
    return node.nodeType === 1;
  }
  // 检测属性是否是指令(vue的指令是v-开头)
  isDirective(attr) {
    return attr.nodeName.indexOf('v-') &amp;gt;= 0;
  }
}

const CompileUtils = {
  // 编译v-model属性,为元素节点注册input事件，在input事件触发的时候，更新vm对应的值。
  // 同时也注册一个Watcher函数，当所依赖的值发生变化的时候，更新节点的值
  compileModelAttr(vm, node, attr) {
    const { value: keys, nodeName } = attr;
    node.value = this.getModelValue(vm, keys);
    // 将v-model属性值从元素节点上去掉
    node.removeAttribute(nodeName);
    node.addEventListener('input', (e) =&amp;gt; {
      this.setModelValue(vm, keys, e.target.value);
    });
      
    new Watcher(vm, keys, (oldVal, newVal) =&amp;gt; {
      node.value = newVal;
    });
  },
  /* 解析keys，比如，用户可以传入
  *  &amp;lt;input v-model=&quot;obj.name&quot; /&amp;gt;
  *  这个时候，我们在取值的时候，需要将&quot;obj.name&quot;解析为data[obj][name]的形式来获取目标值
  */
  parse(vm, keys) {
    keys = keys.split('.');
    let value = vm;
    keys.forEach(_key =&amp;gt; {
      value = value[_key];
    });
    return value;
  },
  // 根据vm和keys，返回v-model对应属性的值
  getModelValue(vm, keys) {
    return this.parse(vm, keys);
  },
  // 修改v-model对应属性的值
  setModelValue(vm, keys, val) {
    keys = keys.split('.');
    let value = vm;
    for(let i = 0; i &amp;lt; keys.length - 1; i++) {
      value = value[keys[i]];
    }
    value[keys[keys.length - 1]] = val;
  },
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实现语法&quot;&gt;实现{{}}语法&lt;/h3&gt;
&lt;p&gt;{{}}语法只可能会出现在文本节点中，因此，我们只需要对文本节点做处理。如果文本节点中出现{{key}}这种语句的话，我们则对该节点进行编译。在这里，我们可以通过下面这个正则表达式来对文本节点进行处理，判断其是否含有{{}}语法。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const textReg = /\{\{\s*\w+\s*\}\}/gi; // 检测{{name}}语法
console.log(textReg.test('sss'));
console.log(textReg.test('aaa{{  name  }}'));
console.log(textReg.test('aaa{{  name  }} {{ text }}'));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若含有{{}}语法，我们则可以对其处理，由于一个文本节点可能出现多个{{}}语法，因此编译含有{{}}语法的文本节点主要有以下两步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;找出该文本节点中所有依赖的属性，并且保留原始文本信息，根据原始文本信息还有属性值，生成最终的文本信息。比如说，原始文本信息是&quot;test {{test}} {{name}}&quot;,那么该文本信息依赖的属性有this.data.test和this.data.name,那么我们可以根据原本信息和属性值，生成最终的文本。&lt;/li&gt;
&lt;li&gt;为该文本节点所有依赖的属性注册Watcher函数，当依赖的属性发生变化的时候，则更新文本节点的内容。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class MVVM {
  constructor({ data, el }) {
    this.data = data;
    this.el = el;
    this.init();
    this.initDom();
  }
  
  initDom() {
    const fragment = this.node2Fragment();
    this.compile(fragment);
    // 将fragment返回到页面中
    document.body.appendChild(fragment);
  }
  
  compile(node) {
    const textReg = /\{\{\s*\w+\s*\}\}/gi; // 检测{{name}}语法
    if (this.isTextNode(node)) {
      // 若是文本节点，则判断是否有{{}}语法，如果有的话，则编译{{}}语法
      let textContent = node.textContent;
      if (textReg.test(textContent)) {
        // 对于 &quot;test{{test}} {{name}}&quot;这种文本，可能在一个文本节点会出现多个匹配符，因此得对他们统一进行处理
        // 使用 textReg来对文本节点进行匹配，可以得到[&quot;{{test}}&quot;, &quot;{{name}}&quot;]两个匹配值
        const matchs = textContent.match(textReg);
        CompileUtils.compileTextNode(this.data, node, matchs);
      }
    }
    // 若节点有子节点的话，则对子节点进行编译
    if (node.childNodes &amp;amp;&amp;amp; node.childNodes.length &amp;gt; 0) {
      Array.prototype.forEach.call(node.childNodes, (child) =&amp;gt; {
        this.compile(child);
      })
    }
  }
  // 是否是文本节点
  isTextNode(node) {
    return node.nodeType === 3;
  }
}

const CompileUtils = {
  reg: /\{\{\s*(\w+)\s*\}\}/, // 匹配 {{ key }}中的key
  // 编译文本节点，并注册Watcher函数，当文本节点依赖的属性发生变化的时候，更新文本节点
  compileTextNode(vm, node, matchs) {
    // 原始文本信息
    const rawTextContent = node.textContent;
    matchs.forEach((match) =&amp;gt; {
      const keys = match.match(this.reg)[1];
      console.log(rawTextContent);
      new Watcher(vm, keys, () =&amp;gt; this.updateTextNode(vm, node, matchs, rawTextContent));
    });
    this.updateTextNode(vm, node, matchs, rawTextContent);
  },
  // 更新文本节点信息
  updateTextNode(vm, node, matchs, rawTextContent) {
    let newTextContent = rawTextContent;
    matchs.forEach((match) =&amp;gt; {
      const keys = match.match(this.reg)[1];
      const val = this.getModelValue(vm, keys);
      newTextContent = newTextContent.replace(match, val);
    })
    node.textContent = newTextContent;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;这样，一个具有v-model和{{}}功能的MVVM类就已经完成了。&lt;a href=&quot;https://github.com/chenjigeng/vue-data-binding&quot;&gt;代码地址点击这里。&lt;/a&gt;有兴趣的小伙伴可以上去看下（也可以star or fork下哈哈哈）。&lt;/p&gt;
&lt;p&gt;这里也有一个&lt;a href=&quot;https://chenjigeng.github.io/example/vue-data-binding/index.html&quot;&gt;简单的样例&lt;/a&gt;(忽略样式)。&lt;/p&gt;
&lt;p&gt;接下来的话，可能会继续实现computed属性,v-bind方法，以及支持在{{}}里面放表达式。如果觉得这个文章对你有帮助的话，麻烦点个赞，嘻嘻。&lt;/p&gt;
&lt;p&gt;最后，贴上所有的代码:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class Observer {
  constructor(data) {
    // 如果不是对象，则返回
    if (!data || typeof data !== 'object') {
      return;
    }
    this.data = data;
    this.walk();
  }

  // 对传入的数据进行数据劫持
  walk() {
    for (let key in this.data) {
      this.defineReactive(this.data, key, this.data[key]);
    }
  }
  // 创建当前属性的一个发布实例，使用Object.defineProperty来对当前属性进行数据劫持。
  defineReactive(obj, key, val) {
    // 创建当前属性的发布者
    const dep = new Dep();
    /*
    * 递归对子属性的值进行数据劫持，比如说对以下数据
    * let data = {
    *   name: 'cjg',
    *   obj: {
    *     name: 'zht',
    *     age: 22,
    *     obj: {
    *       name: 'cjg',
    *       age: 22,
    *     }
    *   },
    * };
    * 我们先对data最外层的name和obj进行数据劫持，之后再对obj对象的子属性obj.name,obj.age, obj.obj进行数据劫持，层层递归下去，直到所有的数据都完成了数据劫持工作。
    */
    new Observer(val);
    Object.defineProperty(obj, key, {
      get() {
        // 若当前有对该属性的依赖项，则将其加入到发布者的订阅者队列里
        if (Dep.target) {
          dep.addSub(Dep.target);
        }
        return val;
      },
      set(newVal) {
        if (val === newVal) {
          return;
        }
        val = newVal;
        new Observer(newVal);
        dep.notify();
      }
    })
  }
}

// 发布者,将依赖该属性的watcher都加入subs数组，当该属性改变的时候，则调用所有依赖该属性的watcher的更新函数，触发更新。
class Dep {
  constructor() {
    this.subs = [];
  }

  addSub(sub) {
    if (this.subs.indexOf(sub) &amp;lt; 0) {
      this.subs.push(sub);
    }
  }

  notify() {
    this.subs.forEach((sub) =&amp;gt; {
      sub.update();
    })
  }
}

Dep.target = null;

// 观察者
class Watcher {
  /**
   *Creates an instance of Watcher.
   * @param {*} vm
   * @param {*} keys
   * @param {*} updateCb
   * @memberof Watcher
   */
  constructor(vm, keys, updateCb) {
    this.vm = vm;
    this.keys = keys;
    this.updateCb = updateCb;
    this.value = null;
    this.get();
  }

  // 根据vm和keys获取到最新的观察值
  get() {
    // 将Dep的依赖项设置为当前的watcher,并且根据传入的keys遍历获取到最新值。
    // 在这个过程中，由于会调用observer对象属性的getter方法，因此在遍历过程中这些对象属性的发布者就将watcher添加到订阅者队列里。
    // 因此，当这一过程中的某一对象属性发生变化的时候，则会触发watcher的update方法
    Dep.target = this;
    this.value = CompileUtils.parse(this.vm, this.keys);
    Dep.target = null;
    return this.value;
  }

  update() {
    const oldValue = this.value;
    const newValue = this.get();
    if (oldValue !== newValue) {
      this.updateCb(oldValue, newValue);
    }
  }
}

class MVVM {
  constructor({ data, el }) {
    this.data = data;
    this.el = el;
    this.init();
    this.initDom();
  }

  // 初始化
  init() {
    // 对this.data进行数据劫持
    new Observer(this.data);
    // 传入的el可以是selector,也可以是元素，因此我们要在这里做一层处理，保证this.$el的值是一个元素节点
    this.$el = this.isElementNode(this.el) ? this.el : document.querySelector(this.el);
    // 将this.data的属性都绑定到this上，这样用户就可以直接通过this.xxx来访问this.data.xxx的值
    for (let key in this.data) {
      this.defineReactive(key);
    }
  }

  initDom() {
    const fragment = this.node2Fragment();
    this.compile(fragment);
    document.body.appendChild(fragment);
  }
  // 将节点转为fragment,通过fragment来操作DOM，可以获得更高的效率
  // 因为如果直接操作DOM节点的话，每次修改DOM都会导致DOM的回流或重绘，而将其放在fragment里，修改fragment不会导致DOM回流和重绘
  // 当在fragment一次性修改完后，在直接放回到DOM节点中
  node2Fragment() {
    const fragment = document.createDocumentFragment();
    let firstChild;
    while(firstChild = this.$el.firstChild) {
      fragment.appendChild(firstChild);
    }
    return fragment;
  }

  defineReactive(key) {
    Object.defineProperty(this, key, {
      get() {
        return this.data[key];
      },
      set(newVal) {
        this.data[key] = newVal;
      }
    })
  }

  compile(node) {
    const textReg = /\{\{\s*\w+\s*\}\}/gi; // 检测{{name}}语法
    if (this.isElementNode(node)) {
      // 若是元素节点，则遍历它的属性，编译其中的指令
      const attrs = node.attributes;
      Array.prototype.forEach.call(attrs, (attr) =&amp;gt; {
        if (this.isDirective(attr)) {
          CompileUtils.compileModelAttr(this.data, node, attr)
        }
      })
    } else if (this.isTextNode(node)) {
      // 若是文本节点，则判断是否有{{}}语法，如果有的话，则编译{{}}语法
      let textContent = node.textContent;
      if (textReg.test(textContent)) {
        // 对于 &quot;test{{test}} {{name}}&quot;这种文本，可能在一个文本节点会出现多个匹配符，因此得对他们统一进行处理
        // 使用 textReg来对文本节点进行匹配，可以得到[&quot;{{test}}&quot;, &quot;{{name}}&quot;]两个匹配值
        const matchs = textContent.match(textReg);
        CompileUtils.compileTextNode(this.data, node, matchs);
      }
    }
    // 若节点有子节点的话，则对子节点进行编译。
    if (node.childNodes &amp;amp;&amp;amp; node.childNodes.length &amp;gt; 0) {
      Array.prototype.forEach.call(node.childNodes, (child) =&amp;gt; {
        this.compile(child);
      })
    }
  }
  
  // 是否是属性节点
  isElementNode(node) {
    return node.nodeType === 1;
  }
  // 是否是文本节点
  isTextNode(node) {
    return node.nodeType === 3;
  }

  isAttrs(node) {
    return node.nodeType === 2;
  }
  // 检测属性是否是指令(vue的指令是v-开头)
  isDirective(attr) {
    return attr.nodeName.indexOf('v-') &amp;gt;= 0;
  }

}

const CompileUtils = {
  reg: /\{\{\s*(\w+)\s*\}\}/, // 匹配 {{ key }}中的key
  // 编译文本节点，并注册Watcher函数，当文本节点依赖的属性发生变化的时候，更新文本节点
  compileTextNode(vm, node, matchs) {
    // 原始文本信息
    const rawTextContent = node.textContent;
    matchs.forEach((match) =&amp;gt; {
      const keys = match.match(this.reg)[1];
      console.log(rawTextContent);
      new Watcher(vm, keys, () =&amp;gt; this.updateTextNode(vm, node, matchs, rawTextContent));
    });
    this.updateTextNode(vm, node, matchs, rawTextContent);
  },
  // 更新文本节点信息
  updateTextNode(vm, node, matchs, rawTextContent) {
    let newTextContent = rawTextContent;
    matchs.forEach((match) =&amp;gt; {
      const keys = match.match(this.reg)[1];
      const val = this.getModelValue(vm, keys);
      newTextContent = newTextContent.replace(match, val);
    })
    node.textContent = newTextContent;
  },
  // 编译v-model属性,为元素节点注册input事件，在input事件触发的时候，更新vm对应的值。
  // 同时也注册一个Watcher函数，当所依赖的值发生变化的时候，更新节点的值
  compileModelAttr(vm, node, attr) {
    const { value: keys, nodeName } = attr;
    node.value = this.getModelValue(vm, keys);
    // 将v-model属性值从元素节点上去掉
    node.removeAttribute(nodeName);
    new Watcher(vm, keys, (oldVal, newVal) =&amp;gt; {
      node.value = newVal;
    });
    node.addEventListener('input', (e) =&amp;gt; {
      this.setModelValue(vm, keys, e.target.value);
    });
  },
  /* 解析keys，比如，用户可以传入
  *  let data = {
  *    name: 'cjg',
  *    obj: {
  *      name: 'zht',
  *    },
  *  };
  *  new Watcher(data, 'obj.name', (oldValue, newValue) =&amp;gt; {
  *    console.log(oldValue, newValue);
  *  })
  *  这个时候，我们需要将keys解析为data[obj][name]的形式来获取目标值
  */
  parse(vm, keys) {
    keys = keys.split('.');
    let value = vm;
    keys.forEach(_key =&amp;gt; {
      value = value[_key];
    });
    return value;
  },
  // 根据vm和keys，返回v-model对应属性的值
  getModelValue(vm, keys) {
    return this.parse(vm, keys);
  },
  // 修改v-model对应属性的值
  setModelValue(vm, keys, val) {
    keys = keys.split('.');
    let value = vm;
    for(let i = 0; i &amp;lt; keys.length - 1; i++) {
      value = value[keys[i]];
    }
    value[keys[keys.length - 1]] = val;
  },
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 28 Aug 2018 07:23:00 +0000</pubDate>
<dc:creator>陈陈jg</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenjg/p/9548473.html</dc:identifier>
</item>
<item>
<title>微信小程序之自定义select下拉选项框组件 - 站住，别跑</title>
<link>http://www.cnblogs.com/zjjDaily/p/9548433.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjjDaily/p/9548433.html</guid>
<description>&lt;p&gt;&lt;strong&gt;知识点&lt;/strong&gt;：&lt;strong&gt;组件&lt;/strong&gt;，&lt;strong&gt;animation&lt;/strong&gt;，&lt;strong&gt;获取当前点击元素的索引与内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微信小程序中没有select下拉选项框，所以只有自定义。自定义的话，可以选择&lt;strong&gt;模板&lt;/strong&gt;的方式，也可以选择&lt;strong&gt;组件&lt;/strong&gt;的方式来创建。&lt;/p&gt;
&lt;p&gt;这次我选择了组件，这样只需引入组件和添加数据，其它的不用管，就能实现多个地方重复使用了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一步：创建组件所需的文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我喜欢把共用的内容都放在和pages文件同级的地方，所以有了下面的目录结构&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1040666/201808/1040666-20180828140445344-1754109424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（1） 先创建一个自定义名字的文件夹，例如我上面的Componet&lt;/p&gt;
&lt;p&gt;（2） 再创建一个select文件夹，然后：右键这个文件夹，新建下面的这个Component。然后输入需要创建的名称，我这里为了方便就取了select的名字。然后就会&lt;span&gt;自动创建4个文件&lt;/span&gt;，js、json、wxml、wxss。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1040666/201808/1040666-20180828140823004-941156598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二步：开始配置组件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;如果通过第一步创建的可直接跳过第二步。&lt;/p&gt;
&lt;p&gt;（1） 通过第一步创建的组件的文件夹中，已经自动配置好了。只需&lt;strong&gt;在引入组件的时候&lt;/strong&gt;，在引入组件的页面的json文件中配置组件的名称和组件的位置。&lt;/p&gt;
&lt;p&gt;（2） 如果自己手动创建组件的js、json、wxml、wxss这个文件，那么需要在json文件中填入 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;component&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;/span&gt; 表示自定义组件声明。js文件中也需要写成这种格式： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Component({
  properties: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里定义了innerText属性，属性值可以在组件使用时指定&lt;/span&gt;
&lt;span&gt;    innerText: {
      type: String,
      value: &lt;/span&gt;'default value'&lt;span&gt;,
    }
  },
  data: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里是一些组件内部数据&lt;/span&gt;
&lt;span&gt;    someData: {}
  },
  methods: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里是一个自定义方法&lt;/span&gt;
    customMethod: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){}
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第三步：自定义组件样式及js。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;这里可以在 &lt;strong&gt;app.json&lt;/strong&gt; 的 &lt;strong&gt;pages&lt;/strong&gt; 中把组件所在的页面放到第一位，这样就能在组件的页面编写代码了，比如我上面的目录结构：就需要写成 &lt;span class=&quot;cnblogs_code&quot;&gt;&quot;Componet/select/select&quot;,&lt;/span&gt; 后面再是其它的页面。这样方便得多。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 组件的wxml&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='com-selectBox'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='com-sContent' &lt;/span&gt;&lt;span&gt;bindtap&lt;/span&gt;&lt;span&gt;='selectToggle'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='com-sTxt'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{nowText}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;image &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;='../../public/img/local/down.png'  &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='com-sImg'  &lt;/span&gt;&lt;span&gt;animation&lt;/span&gt;&lt;span&gt;=&quot;{{animationData}}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='com-sList' &lt;/span&gt;&lt;span&gt;wx:if&lt;/span&gt;&lt;span&gt;=&quot;{{selectShow}}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;wx:for&lt;/span&gt;&lt;span&gt;=&quot;{{propArray}}&quot;&lt;/span&gt;&lt;span&gt; data-index&lt;/span&gt;&lt;span&gt;=&quot;{{index}}&quot;&lt;/span&gt;&lt;span&gt; wx:key&lt;/span&gt;&lt;span&gt;='' &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='com-sItem' &lt;/span&gt;&lt;span&gt;bindtap&lt;/span&gt;&lt;span&gt;='setText'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{item.text}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（1）  &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;animation=&quot;&lt;/span&gt;{&lt;span&gt;{animationData&lt;/span&gt;}&lt;span&gt;}&quot;&lt;/span&gt;&lt;/span&gt; 这个是下箭头的动画效果&lt;/p&gt;
&lt;p&gt;（2）  &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;data-index=&quot;&lt;/span&gt;{&lt;span&gt;{index&lt;/span&gt;}&lt;span&gt;}&quot;&lt;/span&gt;&lt;/span&gt; 这个是当前元素被点击时的索引&lt;/p&gt;
&lt;p&gt;（3） selectToggle是模仿下拉选项框隐藏和显示的事件。&lt;/p&gt;
&lt;p&gt;（4） setText是模仿下拉选项框选择子项之后，设置内容的事件。&lt;/p&gt;
&lt;p&gt;（5） selectShow是表示option选项显示与否&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 组件的wxss&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.com-selectBox&lt;/span&gt;{&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;
}&lt;span&gt;
.com-sContent&lt;/span&gt;{&lt;span&gt;
    border&lt;/span&gt;:&lt;span&gt; 1px solid #e2e2e2&lt;/span&gt;;&lt;span&gt;
    background&lt;/span&gt;:&lt;span&gt; white&lt;/span&gt;;&lt;span&gt;
    font-size&lt;/span&gt;:&lt;span&gt; 16px&lt;/span&gt;;&lt;span&gt;
    position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
    height&lt;/span&gt;:&lt;span&gt; 30px&lt;/span&gt;;&lt;span&gt;
    line-height&lt;/span&gt;:&lt;span&gt; 30px&lt;/span&gt;;
}&lt;span&gt;
.com-sImg&lt;/span&gt;{&lt;span&gt;
    position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
    right&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;&lt;span&gt;
    top&lt;/span&gt;:&lt;span&gt; 11px&lt;/span&gt;;&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt; 16px&lt;/span&gt;;&lt;span&gt;
    height&lt;/span&gt;:&lt;span&gt; 9px&lt;/span&gt;;&lt;span&gt;
    transition&lt;/span&gt;:&lt;span&gt; all .3s ease&lt;/span&gt;;
}&lt;span&gt;
.com-sTxt&lt;/span&gt;{&lt;span&gt;
    overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;&lt;span&gt;
    text-overflow&lt;/span&gt;:&lt;span&gt; ellipsis&lt;/span&gt;;&lt;span&gt;
    white-space&lt;/span&gt;:&lt;span&gt; nowrap&lt;/span&gt;;&lt;span&gt;
    padding&lt;/span&gt;:&lt;span&gt;0 20px 0 6px&lt;/span&gt;;&lt;span&gt;
    font-size&lt;/span&gt;:&lt;span&gt; 14px&lt;/span&gt;;
}&lt;span&gt;
.com-sList&lt;/span&gt;{&lt;span&gt;
    background&lt;/span&gt;:&lt;span&gt; white&lt;/span&gt;;&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt; inherit&lt;/span&gt;;&lt;span&gt;
    position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
    border&lt;/span&gt;:&lt;span&gt; 1px solid #e2e2e2&lt;/span&gt;;&lt;span&gt;
    border-top&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;&lt;span&gt;
    box-sizing&lt;/span&gt;:&lt;span&gt; border-box&lt;/span&gt;;&lt;span&gt;
    z-index&lt;/span&gt;:&lt;span&gt; 3&lt;/span&gt;;&lt;span&gt;
    max-height&lt;/span&gt;:&lt;span&gt; 120px&lt;/span&gt;;&lt;span&gt;
    overflow&lt;/span&gt;:&lt;span&gt; auto&lt;/span&gt;;
}&lt;span&gt;
.com-sItem&lt;/span&gt;{&lt;span&gt;
    height&lt;/span&gt;:&lt;span&gt; 30px&lt;/span&gt;;&lt;span&gt;
    line-height&lt;/span&gt;:&lt;span&gt; 30px&lt;/span&gt;;&lt;span&gt;
    border-top&lt;/span&gt;:&lt;span&gt; 1px solid #e2e2e2&lt;/span&gt;;&lt;span&gt;
    padding&lt;/span&gt;:&lt;span&gt; 0 6px&lt;/span&gt;;&lt;span&gt;
    text-align&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
    overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;&lt;span&gt;
    text-overflow&lt;/span&gt;:&lt;span&gt; ellipsis&lt;/span&gt;;&lt;span&gt;
    white-space&lt;/span&gt;:&lt;span&gt; nowrap&lt;/span&gt;;&lt;span&gt;
    font-size&lt;/span&gt;:&lt;span&gt; 14px&lt;/span&gt;;
}&lt;span&gt;
.com-sItem:first-child&lt;/span&gt;{&lt;span&gt;
    border-top&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;3. 组件的 js&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Componet/Componet.js&lt;/span&gt;
&lt;span&gt;Component({
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 组件的属性列表
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    properties: {
        propArray:{
            type:Array,
        }
    },
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 组件的初始数据
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    data: {
        selectShow:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始option不显示&lt;/span&gt;
        nowText:&quot;请选择&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始内容&lt;/span&gt;
        animationData:{}&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右边箭头的动画&lt;/span&gt;
&lt;span&gt;    },
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 组件的方法列表
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    methods: {
　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;option的显示与否&lt;/span&gt;
        selectToggle:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; nowShow=&lt;span&gt;this&lt;/span&gt;.data.selectShow;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前option显示的状态&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建动画&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; animation =&lt;span&gt; wx.createAnimation({
                timingFunction:&lt;/span&gt;&quot;ease&quot;&lt;span&gt;
            })
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.animation=&lt;span&gt;animation;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(nowShow){
                animation.rotate(&lt;/span&gt;0&lt;span&gt;).step();
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
                    animationData: animation.export()
                })
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                animation.rotate(&lt;/span&gt;180&lt;span&gt;).step();                
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
                    animationData: animation.export()
                })
            }
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
                selectShow: &lt;/span&gt;!&lt;span&gt;nowShow
            })
        },
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置内容&lt;/span&gt;
        setText:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; nowData = &lt;span&gt;this&lt;/span&gt;.properties.propArray;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前option的数据是引入组件的页面传过来的，所以这里获取数据只有通过this.properties&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; nowIdx = e.target.dataset.index;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前点击的索引&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; nowText = nowData[nowIdx].text;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前点击的内容&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;再次执行动画，注意这里一定，一定，一定是this.animation来使用动画&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.animation.rotate(0&lt;span&gt;).step();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
                selectShow: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                nowText:nowText,
                animationData: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.animation.export()
            })
        }
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（1） 组件的 &lt;strong&gt;properties&lt;/strong&gt; 属性是对外属性，我理解的是可以当做 data 数据来使用，它是一个含有三个属性的对象，分别是 &lt;strong&gt;&lt;code&gt;type&lt;/code&gt;&lt;/strong&gt; 表示属性类型、 &lt;strong&gt;&lt;code&gt;value&lt;/code&gt;&lt;/strong&gt; 表示属性初始值、&lt;strong&gt; &lt;code&gt;observer&lt;/code&gt;&lt;/strong&gt; 表示属性值被更改时的响应函数。&lt;strong&gt;type&lt;/strong&gt; 是必填的，其它的可选。如果只有 &lt;strong&gt;type&lt;/strong&gt;，可以写成：&lt;span&gt;属性名：type类型&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;（2） 组件的 data 和普通页面的data一样，是组件的内部数据，和 &lt;strong&gt;&lt;code&gt;properties&lt;/code&gt;&lt;/strong&gt; 一同用于组件的模版渲染。&lt;/p&gt;
&lt;p&gt;（3） 组件的 method 是专门用于 事件响应函数 和 任意的自定义方法。在这里面获取数据有两种方法：一种是获取data里的数据： &lt;span&gt;this.data.属性名&lt;/span&gt;；一种是获取 properties 中的属性值： &lt;span&gt;this.properties.属性名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（4） 创建animation动画，作用在&lt;strong&gt;通过 true 和 false 切换显示状态&lt;/strong&gt;的内容上&lt;strong&gt;没有过渡、没有过渡、没有过渡&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第四步：引入组件，传入组件所需数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.&lt;/span&gt; 引入前，需要在&lt;span&gt;引入组件的页面的json文件中配置&lt;/span&gt;，比如我要在 index.wxml 中引入，那么在 index.json 中我就需要配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&quot;usingComponents&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;Select&quot;: &quot;/Componet/select/select&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（1） &lt;span&gt;Select&lt;/span&gt; 是你&lt;strong&gt;定义的组件的名称&lt;/strong&gt;，后面的是&lt;strong&gt;组件所在的位置&lt;/strong&gt;。 /  单斜杠表示根目录，是绝对路径。&lt;/p&gt;
&lt;p&gt;（2） 如果出现下面这种说没找到路径的，一定是自己填写的路径不对，认真查找。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1040666/201808/1040666-20180828145150377-1084744122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.&lt;/span&gt; 配置好后，就可以引入组件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Select &lt;/span&gt;&lt;span&gt;prop-array&lt;/span&gt;&lt;span&gt;='{{selectArray}}'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（1） prop-array 是我自定义的属性名，这个是和组件所在的 js 中properties中的属性是对应的。在 &lt;code&gt;properties&lt;/code&gt; 定义的属性中，属性名采用驼峰写法（例如：propArray）；在引入组件的 &lt;code&gt;wxml&lt;/code&gt; 中，指定属性值时则对应使用连字符写法（例如：prop-array&lt;code&gt;=&quot;...&quot;&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.&lt;/span&gt; 最后就是传入数据了。在引入组件的js的data中，添加：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;selectArray: [{
    &lt;/span&gt;&quot;id&quot;: &quot;10&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;text&quot;: &quot;会计类&quot;&lt;span&gt;
}, {
    &lt;/span&gt;&quot;id&quot;: &quot;21&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;text&quot;: &quot;工程类&quot;&lt;span&gt;
}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 最终结果：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1040666/201808/1040666-20180828150617878-2043030228.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 如果引入两个相同的组件，传入的数据也相同： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Select &lt;/span&gt;&lt;span&gt;prop-array&lt;/span&gt;&lt;span&gt;='{{selectArray}}'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Select &lt;/span&gt;&lt;span&gt;prop-array&lt;/span&gt;&lt;span&gt;='{{selectArray}}'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  这样的方式组件并不会相互影响，都是独立的。  &lt;/p&gt;

&lt;p&gt;对了，组件样式的规则可以查看&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html&quot; target=&quot;_blank&quot;&gt;官方的规则&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 28 Aug 2018 07:19:00 +0000</pubDate>
<dc:creator>站住，别跑</dc:creator>
<og:description>知识点：组件，animation，获取当前点击元素的索引与内容 微信小程序中没有select下拉选项框，所以只有自定义。自定义的话，可以选择模板的方式，也可以选择组件的方式来创建。 这次我选择了组件，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjjDaily/p/9548433.html</dc:identifier>
</item>
<item>
<title>如何去学习，成为一个有目标的学习者呢？ - 56899◎か</title>
<link>http://www.cnblogs.com/qy1234/p/9548205.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qy1234/p/9548205.html</guid>
<description>&lt;h4 class=&quot;entry-title&quot;&gt;一、背景&lt;/h4&gt;
&lt;p&gt;    &lt;strong&gt;无意中看到一篇《成为一个有目标学习者》文章，文章中里面的一些见解，方法论，给我一些思考，启发；之前我的曹哥，也告诉我学习一门技术或者知识，要有自己学习方法，才是最重要的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、摘取文章段落&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文章中可取之处段落：&lt;/p&gt;
&lt;p&gt;“对于技术人来说，新的目标可以是做一个解决自己生活中遇到问题的小产品，努力做到 1000 日活，做一个开源项目，努力得到 1000 个 Star，做一个小工具，努力赚到 1000 人民币，做一个小社群，努力拥有 1000 个注册用户，或者开一篇博客，写一个公众号，努力做到 1000 阅读。&lt;/p&gt;
&lt;p&gt;这些都是可以成为刺激你的下一个源泉。很多很能折腾的人，总是在持续不断的折腾，就是因为他们总是在不断的接收正反馈，他们在不断的认可自己的过程中。”&lt;/p&gt;

&lt;p&gt;“不要因为别人说一本书好，或是一篇文章，一类技术好，就去学它，其实根本没有必要，因为你学它的动力其实是&lt;strong&gt;伪动力&lt;/strong&gt;，&lt;strong&gt;学有所用&lt;/strong&gt;才是可能持续学习的动力，主观的坚持不是可持续的真正动力。”&lt;/p&gt;

&lt;p&gt;“而且很多复杂的东西，其实很难用一篇博客文章写清楚。越是清楚其中逻辑和原理的人，反而越是很少写技术文章，一来因为这些技术人感觉还有很多东西要研究，复杂问题写起来总是长篇大论，依赖知识也非常多，写起来麻烦。二来，研究到这些复杂东西的人，往往已经掌握了方法论，也不需要读这些文章，非要写一篇文章的话，只用只言片语提及思路，便够了。”&lt;/p&gt;

&lt;p&gt;“我其实一直是很不主张去读其他人的技术文章，至少大多数技术文章都是对你无益的，读的越多，你越是会产生彷徨和焦虑，感觉自己没有成长，缺少自信。缺少自信的表现是你会恐惧未来遇到的新问题，你还是得大量依赖搜索引擎去读几百篇博客去解决一个问题，你没有自己真正的独立思考，你只解决了一个眼前问题，你没有办法套用到千千万万个问题上，你无法亢奋自己的神经，而产生持续的学习和研究欲望。&lt;/p&gt;
&lt;p&gt;大量读别人的文章，其实你也无法得到一个独立解决问题的方法论，你会滋生思想的懒惰，很多美好的事物和机会，也会和你擦身而过。”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;学习方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“我主张你去看原始的资料，主张你去读系统的书籍，主张你去研究官方或是优秀项目的源码。&lt;/strong&gt;这些都是一手资料和优质 Demo。这才是真正的方法论，&lt;strong&gt;Google 是不会给你带来安全感的&lt;/strong&gt;。”&lt;/p&gt;

&lt;p&gt;“那些没时间娱乐的人，他们的时间会花在生病上。——约翰 沃纳梅克”&lt;/p&gt;

&lt;p&gt;学习是件终身的事，所以心态上首先要放松，不能着急。多自己开一些小项目，在项目中提升自己的技术。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、读后感&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       读了《成为一个有目标的学习者》的文章，我发现作者文章里面提及的一些观点，见解，我感同身受，前段时间我特别着急，什么都想学习，因为觉得自己太差，周边的人什么都会，懂的很多，而我什么都不知道；&lt;strong&gt;作为我从一个开发转行到测试的我，自学之路是很迷茫的，自己总是再乱撞中学习，迷茫，缺乏自信，然后在网上各种百度大家推荐测试的书籍，测试的技术，然后自己买一堆书回来，睡大觉；因为里面的书籍内容我都看不懂，不适合自己的阶段看，&lt;/strong&gt;然后我也把这些困惑告诉我家曹哥，曹哥告诉学东西不要什么都要泛泛而学，技术知识把某一领域学精才是硬道理，曹哥建议：搞清楚原理，多思考问题，多玩模型。&lt;/p&gt;
&lt;p&gt;    学习是一个循序渐进过程，急不得，所以放宽心态。给自己定一个小目标去实现某功能过程中，提升自己的技术吧！&lt;/p&gt;

&lt;p&gt;  注：多玩模型是开玩笑，他希望对模型有兴趣，哈哈哈哈  （：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;作者学习方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我主张你去看原始的资料，主张你去读系统的书籍，主张你去研究官方或是优秀项目的源码。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;题外之话：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    以前对曹哥特别生气，他手把手教公司同事写代码，带他们做项目，就不教我，；我每次遇到问题，我去问他，他都不会告诉我，他给我说最多 ，这些网上都是有的，自己百度的或者去谷歌查资料，我问他为什么不告诉我直接答案，我就不知道吗？他总会理直气壮告诉我是在教你如何学习，如何去解决问题，他说如何学习才是最重要的，就算我告诉你了，你下次遇到同样问题还是不会，自己要学会解决；以前自己小并不理解他的做法，不过现在要特别感谢他，让我自己慢慢有适合自己的学习方法。&lt;/p&gt;

&lt;p&gt;文章片段转载之处：&lt;a href=&quot;https://daimajia.com/2017/02/25/you-need-a-goal&quot; target=&quot;_blank&quot;&gt;https://daimajia.com/2017/02/25/you-need-a-goal&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;《&lt;strong&gt;成为一个有目标的学习者》&lt;/strong&gt;&lt;/p&gt;


</description>
<pubDate>Tue, 28 Aug 2018 06:53:00 +0000</pubDate>
<dc:creator>56899◎か</dc:creator>
<og:description>一、背景 无意中看到一篇《成为一个有目标学习者》文章，文章中里面的一些见解，方法论，给我一些思考，启发；之前我的曹哥，也告诉我学习一门技术或者知识，要有自己学习方法，才是最重要的。 二、摘取文章段落</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qy1234/p/9548205.html</dc:identifier>
</item>
<item>
<title>react+spring 记录跨域问题的解决方法 - 喝着啤酒写bug</title>
<link>http://www.cnblogs.com/cq-jiang/p/9548197.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cq-jiang/p/9548197.html</guid>
<description>&lt;p&gt;react 跨域访问后台，默认是有跨域问题，并且火弧和谷歌浏览器，对跨域问题展示还不一样.&lt;/p&gt;
&lt;p&gt;谷歌浏览器如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1128579/201808/1128579-20180828140813738-430697519.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此处状态是200，然而在Response却没有任何信息，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1128579/201808/1128579-20180828140943983-2108340404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然而火弧浏览器，对该问题的描述，就清淅得多，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1128579/201808/1128579-20180828141034291-429859027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;火弧浏览器告诉我们，跨域了，关于react跨域的帖子，网上也有相关帖子，搜索到的方法，大约都是如下解决方式：&lt;/p&gt;
&lt;p&gt;如果你是通过creat-react-app构建的项目，请在package.json文件中的根目录下，添加&quot;proxy&quot;: &quot;http://api.xxxx.com&quot;，如果你的项目，需要调用多个不同ip的接口，请使用如下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&quot;proxy&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;/api/RoomApi&quot;&lt;span&gt;: {
          &lt;/span&gt;&quot;target&quot;: &quot;http://open.douyucdn.cn&quot;&lt;span&gt;,
          &lt;/span&gt;&quot;changeOrigin&quot;:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        },
        &lt;/span&gt;&quot;/api/v1&quot;&lt;span&gt;:{
          &lt;/span&gt;&quot;target&quot;:&quot;http://capi.douyucdn.cn&quot;&lt;span&gt;,
          &lt;/span&gt;&quot;changeOrigin&quot;:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        }
      }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于antd-pro的项目，需要在package.json的同等目录下添加.roadhogrc文件，具体代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    {
      &lt;/span&gt;&quot;entry&quot;: &quot;src/index.js&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;extraBabelPlugins&quot;&lt;span&gt;: [
        &lt;/span&gt;&quot;transform-runtime&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;transform-decorators-legacy&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;transform-class-properties&quot;&lt;span&gt;,
        [&lt;/span&gt;&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; }]
      ],
      &lt;/span&gt;&quot;env&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;development&quot;&lt;span&gt;: {
          &lt;/span&gt;&quot;extraBabelPlugins&quot;&lt;span&gt;: [
            &lt;/span&gt;&quot;dva-hmr&quot;&lt;span&gt;
          ]
        }
      },
      &lt;/span&gt;&quot;externals&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;g2&quot;: &quot;G2&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;g-cloud&quot;: &quot;Cloud&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;g2-plugin-slider&quot;: &quot;G2.Plugin.slider&quot;&lt;span&gt;
      },
      &lt;/span&gt;&quot;ignoreMomentLocale&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&quot;theme&quot;: &quot;./src/theme.js&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;proxy&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;/api&quot;&lt;span&gt;: {
          &lt;/span&gt;&quot;target&quot;: &quot;http://api.xxxx.com/&quot;&lt;span&gt;,
          &lt;/span&gt;&quot;changeOrigin&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        }
      }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置完成后，再次访问接口，还是出现一样的跨域问题，既然recat的配置，未解决跨域问题，我就把思路转到spring，在spring去处理跨域，在后端程序添加一个拦截器,&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gg.interceptor;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Vector;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletResponse;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.HandlerInterceptor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.ModelAndView;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProcessInterceptor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; HandlerInterceptor{

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定白名单域名   &lt;/span&gt;&lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;:8000,&lt;/span&gt;&lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;:8000&lt;/span&gt;
        List&amp;lt;String&amp;gt; whileList  = &lt;span&gt;new&lt;/span&gt; Vector&amp;lt;String&amp;gt;&lt;span&gt;(); 
        whileList.add(&lt;/span&gt;&quot;http://127.0.0.1:8000&quot;&lt;span&gt;);
        whileList.add(&lt;/span&gt;&quot;http://localhost:8000&quot;&lt;span&gt;);
        String clientIp &lt;/span&gt;= httpServletRequest.getHeader(&quot;origin&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; status = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String ip : whileList) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(clientIp!=&lt;span&gt;null&lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt;clientIp.equals(ip)) {
                status &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 网上解决方案是httpServletResponse.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;);设置后发现，还是不能处理跨域问题，需要指定某一个ip，如：&lt;/span&gt;&lt;span&gt;http://127.0.0.1&lt;/span&gt;&lt;span&gt;:8000  
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        httpServletResponse.setHeader(&lt;/span&gt;&quot;Access-Control-Allow-Origin&quot;,status?clientIp:&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;响应头设置  &lt;/span&gt;
        httpServletResponse.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,Content-Length, Authorization, Accept,X-Requested-With&quot;&lt;span&gt;);  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;响应类型&lt;/span&gt;
        httpServletResponse.setHeader(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;&lt;span&gt;);  
        httpServletResponse.setHeader(&lt;/span&gt;&quot;X-Powered-By&quot;,&quot;Jetty&quot;&lt;span&gt;);  
        httpServletResponse.setHeader(&lt;/span&gt;&quot;Access-Control-Allow-Credentials&quot;,&quot;true&quot;&lt;span&gt;);
        String method&lt;/span&gt;=&lt;span&gt; httpServletRequest.getMethod();  
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (method.equals(&quot;OPTIONS&quot;&lt;span&gt;)){  
            httpServletResponse.setStatus(&lt;/span&gt;200&lt;span&gt;);  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;  
        }  
  
        System.out.println(method&lt;/span&gt;+&quot;,status:&quot;+status+&quot;,clientIp:&quot;+&lt;span&gt;clientIp);  
  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;  
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
            ModelAndView modelAndView) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;        
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;        
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;spring-servlet.xml配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.gg.interceptor.ProcessInterceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mvc:interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;react客户端代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Model层js代码:
&lt;/span&gt;*&lt;span&gt;login({ payload }, { call, put }){
      let formData &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FormData();
      formData.append(&lt;/span&gt;&quot;loginId&quot;,payload.loginId);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;账号&lt;/span&gt;
      formData.append(&quot;passWord&quot;,payload.passWord);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;密码&lt;/span&gt;
      const response =&lt;span&gt; yield call(requestGuangGao, formData); 
      yield put({
        type: &lt;/span&gt;'changeLoginStatus'&lt;span&gt;,
        payload: response,
      });
    },

api层js代码:
export async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; requestGuangGao(formData){
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; let formData = new FormData();&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; formData.append(&quot;loginId&quot;,params.loginId);&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; formData.append(&quot;passWord&quot;,params.passWord);&lt;/span&gt;
&lt;span&gt;
  console.log(&lt;/span&gt;&quot;requestGua   &amp;gt;url  :&quot;&lt;span&gt; );
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; request('http://127.0.0.1:8080/guanggao/userController/login.do'&lt;span&gt;, {
    method: &lt;/span&gt;'POST'&lt;span&gt;, 
    mode: &lt;/span&gt;'cors'&lt;span&gt;, 
    body:formData,
  });   
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过以下设置，react跨域问题就处理好了。&lt;/p&gt;
</description>
<pubDate>Tue, 28 Aug 2018 06:52:00 +0000</pubDate>
<dc:creator>喝着啤酒写bug</dc:creator>
<og:description>react 跨域访问后台，默认是有跨域问题，并且火弧和谷歌浏览器，对跨域问题展示还不一样. 谷歌浏览器如下图： 此处状态是200，然而在Response却没有任何信息，如下图 然而火弧浏览器，对该问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cq-jiang/p/9548197.html</dc:identifier>
</item>
<item>
<title>前端项目模块化的实践1：搭建 NPM 私有仓库管理源码及依赖 - Jusfr</title>
<link>http://www.cnblogs.com/Jusfr/p/9547897.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jusfr/p/9547897.html</guid>
<description>&lt;p&gt;以下是关于前端项目模块化的实践，包含以下内容：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/Jusfr/p/9547897.html&quot;&gt;搭建 NPM 私有仓库管理源码及依赖&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/Jusfr/p/9547929.html&quot;&gt;使用 Webpack 打包基础设施代码&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;使用 TypeScript 编写可靠类库 (实现中)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本文是关于前端项目模板化的第1部分&lt;/p&gt;
&lt;h3 id=&quot;使用-docker-搭建私有npm仓库&quot;&gt;使用 Docker 搭建私有NPM仓库&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关于 Docker 的使用不在本文之中，请自行参考其他文档。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过测试， &lt;a href=&quot;https://hub.docker.com/r/keyvanfatehi/sinopia/&quot;&gt;keyvanfatehi/sinopia&lt;/a&gt; 可用。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将 docker image 拉下来&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker pull keyvanfatehi/sinopia&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;将 &lt;em&gt;keyvanfatehi/sinopia&lt;/em&gt; 跑起来&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker run --name sinopia -d -p 4873:4873 keyvanfatehi/sinopia&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我的 docker 主机名是 ubuntu-17，此时通过 &lt;code&gt;http://ubuntu-17/4873&lt;/code&gt; 可以访问私有NPM 仓库网页。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/Jusfr/1288177/o_1.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;发布-javascript-类库&quot;&gt;发布 JavaScript 类库&lt;/h3&gt;
&lt;p&gt;添加示例类库项目 &lt;em&gt;myGreeting&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mkdir myGreeting
cd myGreeting
yarn init -y # npm init -y
touch index.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 index.js 内添加如下内容&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let greeting = function(name) {
    return 'Hello ' + name;
}

module.exports = greeting;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这份代码导出了一个函数，已经可以发布和被依赖了。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;npm adduser&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;初次使用这个私有仓库需要添加用户&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;npm adduser --registry http://ubuntu-17:4873&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;npm publish&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;再把上面的代码发布上去&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;npm publish . --registry http://ubuntu-17:4873&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NPM 有自己的版本和发布策略，可以使用以下命令查看帮助文档&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;npm help version&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm help publish&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;发布可能因为版本问题失败，追加谓词 &lt;strong&gt;--force&lt;/strong&gt; 可强制发布但并非是常规操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;发布后的管理页面图示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/Jusfr/1288177/o_2.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;引用已发布的类库&quot;&gt;引用已发布的类库&lt;/h3&gt;
&lt;p&gt;添加示例业务项目 &lt;em&gt;myDemo&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mkdir myDemo
cd myDemo
yarn init -y # npm init -y
touch index.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;引用 &lt;em&gt;myGreeting&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;yarn add myGreeting --dev --registry http://ubuntu-17:4873&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 index.js 内添加如下内容&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const myGreeting = require('myGreeting');

(function() {
    let greeting = myGreeting('Rattz');
    console.log(greeting);
})();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行起来&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;node index.js
Hello Rattz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此私有NPM仓库搭建、类库发布、依赖引用的部分已经完成。&lt;/p&gt;
&lt;p&gt;项目所使用源码已发布 &lt;a href=&quot;https://github.com/jusfr/PracticeInNPM&quot;&gt;github&lt;/a&gt;，jusfrw 原创&lt;/p&gt;
</description>
<pubDate>Tue, 28 Aug 2018 06:20:00 +0000</pubDate>
<dc:creator>Jusfr</dc:creator>
<og:description>以下是关于前端项目模块化的实践，包含以下内容： 1.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jusfr/p/9547897.html</dc:identifier>
</item>
<item>
<title>视觉设计师的进化 - 网易云</title>
<link>http://www.cnblogs.com/163yun/p/9547949.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/163yun/p/9547949.html</guid>
<description>&lt;p&gt;本文来自&lt;a href=&quot;https://sq.163yun.com/blog?tag=M_tg_136_65&quot; target=&quot;_self&quot;&gt;网易云社区&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;视觉设计师面临修饰者的困境，如何提升全链路认知和体系化思维成为区分者和驱动者?本文在网易易盾&quot;图片在线检测&quot;功能改版中引入设计冲刺进行尝试。设计冲刺让设计师拥有全局性视野和整体性思考方式，在把握用户需求和业务目标前提下，更大地发挥视觉设计的价值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视觉设计师的现状&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;视觉设计师通常会面临这样的场景：做设计的时候要面临来自产品、运营、开发等各方的意见，甚至有时候领导的需求是一切。&lt;/p&gt;
&lt;p&gt;香港理工大学教授John Heskett认为，设计师有三层价值：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;修饰者，主要美化产品页面，体现较为底层的基础价值&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;区分者，根据不同的产品打造不同调性，赋予产品差异性&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;驱动者，在战略高度思考产品，引领整个公司，这是价值感非常强的阶段&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;典型的例子就是苹果公司，是一家设计师驱动、以设计为导向的公司，创新设计能力是产品的核心竞争力。这是每一位设计师梦寐以求的阶段。要成为杰出的区分者乃至驱动者，就意味着需要具备全链路的开阔视野和综合能力，既有用户需求和商业需求的洞察能力，也有交互设计的思维能力，还有视觉设计的审美能力。&lt;/p&gt;
&lt;p&gt;国内大多数互联网公司，由于岗位分工很明确，界限分明，在传统的设计开发流程中，视觉设计师通常处于下游的流水线等待的状态，也就是交互设计之后的视觉还原工作，仅仅局限于将界面视觉美观性发挥到极致，存在感和成就感都很低。很多视觉设计师可能处于第一层修饰者，小部分处于第二层区分者，成为杰出的区分者乃至驱动者指明了视觉设计师未来的主要进化发展方向之一。那么如何提升视觉设计师全链路的综合能力呢？我们的实践表明，谷歌的设计冲刺是一个很好的尝试，创造了非常好的机会使视觉设计师全程协同参与，不仅更深刻地理解了用户需求和业务目标，也更有效地提升了视觉设计的价值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计冲刺简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设计冲刺是谷歌提出的一套为期5天的创新设计流程方法，集思考、设计、分析、产品原型产出为一体。&lt;/p&gt;
&lt;p&gt;分为6个步骤：&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;理解：即理解用户需求、商业需求，了解技术可行性&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;定义：定义关键和重点问题，既定义需求&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;发散：围绕定义的需求尽可能探索更多的想法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;决策：选择目前来说最好的方案&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;原型：制作低保真原型进行用户测试&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;验证：与用户、商业利益相关者、技术专家进行方案验证测试，最后迭代优化&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180822132142c81d2220-0e6e-42cd-98f9-aa18c4299701.png&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;设计冲刺的实践&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网易易盾是网易云旗下一站式B2B安全服务平台，其中内容安全业务主要为客户提供文本、图片、视频等垃圾过滤服务并开放相对应的在线体验服务。我们结合网易易盾广告在线体验功能的改版，给大家介绍一下设计冲刺的具体实践过程以及视觉设计师的深度参与。&lt;/p&gt;
&lt;p&gt;“网易易盾图片在线体验功能需要优化”是这次改版的主要目标，其面临的业务挑战是，如何提升用户体验以确保用户留存率。考虑到设计冲刺这种快速试错迭代的设计方法，很适合短时间小范围洞察用户需求并测试其准确性以及发现具体需要完善的地方。这是传统设计流程难以解决的，或者说是成本和风险都相对比较高的任务。&lt;/p&gt;
&lt;p&gt;1、理解&lt;/p&gt;
&lt;p&gt;首先我们拿到产品的需求，“网易易盾图片在线体验功能不好用，需要优化”。拿到需求第一步我们要做的是分析问题，从用户入手，去挖掘和理解用户的真实需求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180822132214c91eae14-2c68-4722-b1a0-a69a97432fe6.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次的项目中，视觉设计师也主动参与到用户研究中。我们通过面对面的深度访谈、观察用户在使用过程中，具体在哪些环节上遇到了体验上的问题。通过观察到的行为和场景去挖掘隐藏着的真实需求。&lt;/p&gt;
&lt;p&gt;深度访谈之后我们还原用户所有的操作过程，绘制用户旅程图，即用户行为路径图。我们发现用户几乎在每一个阶段都遇到了操作上的问题，我们把问题对应到每一阶段的行为路径上，比如找不到体验入口、页面跳转频繁、没有明确的判断标准、上传过程很麻烦、结果不准确等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180822132239aa08af93-d8b1-4e32-bf0e-75cc3fa41f16.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户使用网易易盾图片在线体验功能过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180822132250c1cc6b6e-7b96-4a0e-aaad-1c2217ed3ca6.jpg&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;用户使用网易易盾图片在线体验功能行为路径图以及各个阶段对应的问题点&lt;/p&gt;
&lt;p&gt;2、定义&lt;/p&gt;
&lt;p&gt;理解了用户的真正需求之后，需要定义需求，把问题限定在一定的范围内进行讨论和解决，这样可以清晰目标，之后的一切工作都围绕着定义好的需求展开。所以，定义问题（需求）比解决问题更重要。&lt;/p&gt;
&lt;p&gt;那我们要如何定义需求呢？我们采用DVF（Desirability、Viability、Feasibility）模型来定义需求，也就是从用户需求出发，同时考虑技术可行性和业务可持续性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180822132304c5f66c60-2ada-4280-9170-139c0271071b.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;DVF模型&lt;/p&gt;
&lt;p&gt;最后，我们定义的图片在线检测功能需求如下：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用场景：图片在线检测&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;目标客户：有反垃圾需求的企业用户&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;遇到的问题：操作复杂、判断结果不精确&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;核心需求：简单便捷的在线体验服务，判断精准无误&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;业务目标：提升用户留存率&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以前视觉设计师一拿到交互框架就开始美化界面，从一开始就沉浸在细节中却很少去想为什么这样解决，而正是从项目前期开始主动与用研同学一起理解和定义用户真实需求，全方位、多角度熟悉业务目标和技术实现能力的过程中，视觉设计师们开始尝试培养自己的理性思维，有针对性地去思考问题的真正起源，给自己的设计带去一个更宽广的视野和更清晰的理解；进而，将体验目标融入业务规划，参与确定这次改版优化的方向，将自己从接需求的被动角色转变为体验规划的主动推进者。&lt;/p&gt;
&lt;p&gt;3、发散&lt;/p&gt;
&lt;p&gt;明确需求以后，就可以发散思维，探索各种可能的解决方案了。&lt;/p&gt;
&lt;p&gt;我们结合波诺的水平思维法（即基于核心问题每个人自由发散思维，探索无穷无尽的各种可能性，通常用“我们该如何……”起头）和概念扇思维法来发散思维，概念扇主要是有目标、方向、概念和想法方案四个部分组成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180822132320a879ff4a-d4fb-438e-b04f-0bd503464c7b.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在有一个目标：将一个贴纸贴到天花板。  我们可能会想到梯子。思考一下：“梯子”只是“将我们从地面提高”的一个工具。如果把“将我们从地面提高”作为一个概念，这个概念发散还有“站在桌子上”“找人将我举起来”。&lt;/p&gt;
&lt;p&gt;“将我们从地面提高”只是“缩短贴纸与天花板的距离”，如果把他作为一个广义概念，那么满足他的其他概念还有“把我的胳膊变成”“让物体移动”，对应的想法就是“用棍子加长我的胳膊”、“用伸缩式杆”“贴到氢气球上”、“操控无人机”等。&lt;/p&gt;
&lt;p&gt;水平思维不拘泥与形式和路径，你可以从任何节点开始，只要最终能建立这样的概念扇即可。&lt;/p&gt;
&lt;p&gt;概念扇应用到实际案例中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180822132333a0462bb2-9f95-4d33-aa8d-2e6e09a16791.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;区别于传统头脑风暴的地方是：设计冲刺鼓励团队成员在限定的时间内独立分散思考问题，然后再集体聚合每个人的想法。有了对于用户需求和业务目标的深刻理解后，视觉设计师在此环节与其他同学一起，开始学会始终围绕核心问题创造更好的体验去有条理，有针对性地开脑洞，也让自己的视觉创意有了更大的发挥空间，最终我们用便签贴的方式输出头脑风暴的结果，横轴为可行性，纵轴为用户价值、满意度，聚合归类所有想法。过程中我们不批判他人的想法是对是错，你可以在他的想法的基础上有延伸或者补充，脑洞越大越好，但要围绕定义的需求和核心问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180822132356fb6fe3fd-d81e-489a-ba01-8000e07e01c2.png&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;

&lt;p&gt;我们聚焦在问题较多的检测过程中和检测结果2个阶段，提供多种方式上传图片、提供在线图库、检测过程可感知、结果圈出广告元素、具体原因分析等解决方案。&lt;/p&gt;
&lt;p&gt;然后每个人根据自己提的点子，快速绘制方案草图，然后从每个人绘制的草图中选出自己最满意的方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201808221324106491afaf-926d-4554-8681-71e109fc9fe8.jpg&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;解决方案&lt;/p&gt;
&lt;p&gt;4、决策&lt;/p&gt;
&lt;p&gt;决策的过程，我们提倡单独投票，然后集体决定最好的概念。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180822132441f73f77de-98ac-4827-bc12-cdc7215b88cf.jpg&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;解决方案1-TAB切换&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201808221324569fb40c76-d72a-4eda-8478-ababcf7c126b.jpg&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;解决方案2-在线样本库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201808221325025715edfb-6f56-4298-bd8a-5129f4969943.jpg&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;解决方案3-检测过程以及结果展示&lt;/p&gt;
&lt;p&gt;以上是我们绘制的小部分草图方案，我们的新方案具备以下几个功能：广告样本图片展示、广告图片判定规则说明、检测过程真实可信、检测结果准确，对结果有具体分析、支持多种本地上传方式、提供在线样本图片库。&lt;/p&gt;
&lt;p&gt;5、原型&lt;/p&gt;
&lt;p&gt;该阶段我们需要把抽象的想法变成具体化的，可供用户实际操作的低保真原型。对视觉设计师来说绘制低保真原型图是优势所在。在这个过程中视觉设计师和交互设计师就会协同绘制原型。而与交互设计师的协同工作，也帮助视觉设计师更清楚地理解用户需求实现时的整个设计的上下文逻辑关系和前因后果，避免了没有支撑理由、自我表达式的视觉设计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180822132550e51bf326-3f83-4556-8b3f-7161957a13eb.jpg&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;1、固定导航，减少切换2、增加判断规则和样本示例3、支持批量、单张、粘贴url、直接拖动等多种上传方式  4、增加图片在线样本库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201808221326008e2e8975-00f2-421a-9242-c6f5eb6bd44c.jpg&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;5、在线图片库可以一次性添加10张随机图片，供检测试用，也可以随机更换&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/2018082213261064b3af12-fe1a-49e6-b622-00f071076f38.jpg&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;

&lt;p&gt;6、检测进度可感知，让用户知道图片在线检测当前的状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201808221326212f603142-c653-48b4-8333-95dca6bc2d30.jpg&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;7、检测结果圈出违规元素（文字、二维码、电话等），图片类型、违规程度百分比展示&lt;/p&gt;
&lt;p&gt;6、验证&lt;/p&gt;
&lt;p&gt;设计冲刺包含2方面测试，第一是验证概念方向是否正确，第二是可用性测试。由于我们这里做的是功能的优化，所以只是做了可用性测试。我们招募了典型的5-7位用户代表进行测试。在情境访谈式的可用性测试中，我们细心观察用户使用过程中的各种表情以及动作等，鼓励用户发声思考。同时制作打分版，统计完成率、错误率。最后归纳总结所有问题，提出优化的迭代方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/2018082213264019d027f6-8a2d-4a5d-bea1-073875d36d19.png&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;测试结果表明，我们选定的方案是行之有效的，5位目标用户均完成了我们的测试，整个操作流程基本没有遇到挫折，体验流畅，并大都给出了满意的反馈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180822132656354598cc-8df4-46ce-8ffc-8e69d811b342.jpg&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;改版之前存在页面跳转多、上传方式单一、入口不明显、检测结果不准确等问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180822132725ce4e92f6-6dbd-4731-8e3c-8222a081a440.jpg&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;改版之后体验入口固定左侧、样本图片展示、判断标准展示、结果圈出广告元素、展示类型和违规程度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于设计冲刺的反思&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、设计冲刺的本质&lt;/p&gt;
&lt;p&gt;其实，在我们看来，设计冲刺的本质就是设计思维，是关于设计的元思考。&lt;/p&gt;
&lt;p&gt;我们把设计冲刺归纳成2大阶段，问题的解读和问题的解决。第一个阶段从用户研究到问题和机会点定义，明确方向，是做正确的事情，属于策略层面的事情；第二个阶段明确方向以后，开始创意发散和迭代测试，直到重新聚拢在技术合理业务可行的方案上，是把事情做正确，这属于执行层面的事。这就是一种全局性认知。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180822132830809b60c2-017a-499b-b08c-69acbe813e28.jpg&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;2、设计冲刺的价值&lt;/p&gt;
&lt;p&gt;通过实践可以看到，视觉设计师参与整个研究和设计过程中，对目标用户需求、业务目标和交互逻辑有更透彻和深入的理解，让视觉设计回归到了“人”本身，变得有理有据，而不是单纯的视觉技巧的呈现，这样视觉设计可以发挥更大的价值，能够获得更完整的视野和更系统的设计思考能力，从而在与用研、交互以及整个团队的协同工作中释放更大的价值，增强视觉设计师在团队中的成就感。与此同时，设计冲刺强调的协同工作打破了职位分工的隔阂，大家学会相互理解，更合理地发挥各自所长，客观上能够大大提升团队的创新效率。&lt;/p&gt;
&lt;p&gt;精通自身领域同时具备综合能力，那么你在团队中的不可替代性更强，对于企业来说也会更重视这样的全方位人才。&lt;/p&gt;
&lt;p&gt;设计冲刺只是其中一种方法工作，如果自己能够有意识地去培养整体性的设计思维，就回有更大的价值感和成就感产生。&lt;/p&gt;

&lt;p&gt;参考文献：&lt;/p&gt;
&lt;p&gt;1、《让你脑洞打开的创新思维方法（1）》 2017-04-03 青溪&lt;/p&gt;
&lt;p&gt;2、《设计冲刺》 2016-08  [美] 杰克·纳普 / [美] 约翰·泽拉茨基/ [美] 布拉登·科维&lt;/p&gt;


&lt;p&gt;原文：&lt;a href=&quot;https://sq.163yun.com/blog/article/190591284291063808?tag=M_tg_136_65&quot; target=&quot;_self&quot;&gt;&lt;span&gt;视觉设计师的进化&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;网易云新用户大礼包：&lt;a href=&quot;https://www.163yun.com/gift?tag=M_tg_136_65&quot; target=&quot;_self&quot;&gt;https://www.163yun.com/gift&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文来自网易云社区，经作者黄霞君授权发布。&lt;/p&gt;

</description>
<pubDate>Tue, 28 Aug 2018 06:15:00 +0000</pubDate>
<dc:creator>网易云</dc:creator>
<og:description>本文来自网易云社区 视觉设计师面临修饰者的困境，如何提升全链路认知和体系化思维成为区分者和驱动者?本文在网易易盾&quot;图片在线检测&quot;功能改版中引入设计冲刺进行尝试。设计冲刺让设计师拥有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/163yun/p/9547949.html</dc:identifier>
</item>
<item>
<title>python之装饰器详解 - 天宇之游</title>
<link>http://www.cnblogs.com/cwp-bg/p/9547797.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cwp-bg/p/9547797.html</guid>
<description>&lt;p&gt;python的装饰器使用是python语言一个非常重要的部分，装饰器是程序设计模式中装饰模式的具体化，python提供了特殊的语法糖可以非常方便的实现装饰模式。&lt;/p&gt;
&lt;h2 id=&quot;装饰模式简介&quot;&gt;装饰模式简介&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;什么叫装饰？&lt;strong&gt;简单来说就是在已有的对象上添加格外的属性、方法或一段代码实现一个新的功能但是又不改变原来的对象或上下文的结构；&lt;/strong&gt;这样做的意义在于为了是程序的设计符合开放-封闭原则，即对扩展开放，但是对修改封闭；也就是说一个类或方法被定义完成后就不要再去修改它了，你可以通过继承、装饰、代理等一些模式去扩展它的功能；最终的目的是为了降耦合和保证系统的稳定性。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;python装饰模式的简单实现&quot;&gt;python装饰模式的简单实现&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;class Car(object):
    &quot;&quot;&quot;
    一个汽车类
    &quot;&quot;&quot;
    def __init__(self):
        self.logo = &quot;奔驰&quot; # 车标
        self.oil = 2 # 油耗
        self.ornamental = None # 装饰品

    # 安装空调
    def air_conditioner(self):
        print(&quot;空调真舒服！&quot;)

    def decorator(self, component):
        &quot;&quot;&quot;用来额外添加装饰方法的&quot;&quot;&quot;
        self.ornamental = component

# 由于汽车的装饰品会发生变化
class Cushion(object):
    &quot;&quot;&quot;
    坐垫
    &quot;&quot;&quot;
    def __init__(self):
        self.name = &quot;席梦思&quot;

class Flower(object):
    &quot;&quot;&quot;
    装饰花
    &quot;&quot;&quot;
    def __init__(self, name):
        self.name = name

if __name__ == '__main__':
    car = Car()
    cushion = Cushion()
    flower = Flower(&quot;玫瑰&quot;)
    # 汽车添加一个坐垫
    car.decorator(cushion)
    print(car.ornamental)
    # 添加一个花
    car.decorator(flower)
    print(car.ornamental)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上例中坐垫和花是可以为汽车动态添加的额外的属性，这样的话可以精简Car类的结构，同时可以扩展Car类的功能。&lt;/p&gt;
&lt;h2 id=&quot;python的装饰器&quot;&gt;python的装饰器&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;python装饰器主要针对的是为一段已完成的方法增加额外的需要执行的代码，为了保持原来的方法不变，装饰器装饰后应该返回一个新的方法；实现这种功能需要一个载体，这个载体可以是函数也可以是类，同时python提供了语法糖@来完成装饰功能。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;python装饰器实现原理介绍&quot;&gt;python装饰器实现原理介绍&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;@decorator
def get_name():
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上所示，&lt;strong&gt;当代码初始化加载上下文的时候，先定义get_name函数，decorator一定要在定义get_name函数之前加载到上下文中，解释器遇到@这种语法糖，会将@下的get_name函数作为参数代入decorator中执行decorator并返回新的方法，重新将返回的方法赋值给get_name。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那decorator究竟是什么结构呢？我们可以看装饰器的要求，需要返回一个新的方法，因此可以是闭包结构，也可以是类结构。&lt;/p&gt;
&lt;h3 id=&quot;使用闭包结构的装饰器&quot;&gt;使用闭包结构的装饰器&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;def decorator(func):
    def new_func(*args,**kwargs):
        &quot;do something&quot;
        res = func(*args,**kwargs)
        &quot;do something&quot;
        return res

    return new_func

@decorator
def get_name():
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;什么是闭包？在函数中定义一个新的函数，这个函数用到了外边函数的变量，将这个函数以及用到的一些变量称之为闭包。闭包函数在初始化上下文的时候是不会被定义的，只有在执行的时候才会被定义。&lt;/p&gt;
&lt;p&gt;上例所示，get_name函数作为参数传递到decorator函数中执行decorator函数返回new_func，new_func函数的参数就是get_name函数的参数，new_func赋值给get_name。此时get_name方法中添加了额外的代码。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;装饰器带参数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果需要在原来的装饰器上还需要添加额外的参数，那就必须使用双层闭包结构了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def new_decorator(pas=&quot;&quot;):
    def decorator(func):
        def new_func(*args,**kwargs):
            &quot;do something&quot;
            print(pas)
            res = func(*args,**kwargs)
            &quot;do something&quot;
            return res

        return new_func
    return decorator


@new_decorator('new prams')
def get_name():
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上所示，pas参数会被传递到闭包函数中去，此时加载上下文时，new_decorator由于自带了()形式，会被直接执行，返回内层decorator函数，然后按照正常的方式装饰过程执行，&lt;strong&gt;pas参数由于被内层函数引用住，会长久地驻留在内存中而不会被释放。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;多层装饰&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果在已被装饰的函数上再添加额外的代码功能，就需要再添加装饰器了，此时的重点就在于装饰器函数的执行顺序了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def new_decorator(pas=&quot;&quot;):
    def decorator(func):
        def new_func(*args,**kwargs):
            &quot;do something&quot;
            print(pas)
            res = func(*args,**kwargs)
            &quot;do something&quot;
            return res

        return new_func
    return decorator

def tow_decorator(func):
    def new_func(*args, **kwargs):
        res = func(*args, **kwargs)
        &quot;do other something&quot;
        return res

    return new_func

@tow_decorator
@new_decorator(pas='hhhhh')
def get_name():&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;装饰器函数的执行顺序不同于我们的习惯，其按就近原则，即如上new_decorator会先执行装饰，将返回的函数赋值给get_name,然后依次往上；因此装饰代码的整体结构为tow_decorator添加的额外代码包裹new_decorator的代码，这在需要考虑代码的执行顺序是很重要。&lt;/p&gt;
&lt;h3 id=&quot;使用类结构的装饰器&quot;&gt;使用类结构的装饰器&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;class Decorator(object):
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        &quot;&quot;&quot;
        添加额外的代码
        :param args:
        :param kwargs:
        :return:
        &quot;&quot;&quot;
        print('do something')
        return self.func(*args, **kwargs)

@Decorator
def get_name():
    pass

print(isinstance(get_name, Decorator))

# 结果
True&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，由于在python中，一个对象只要具备了__call__方法，就可以使用xxx()的形式进行调用执行call方法中的代码，利用的这个原理我们就可以实现装饰器的结构；&lt;/p&gt;
&lt;p&gt;初始化上下文时，执行Decorator，get_name作为参数对Decorator的实例进行初始化，返回一个Decorator的实例赋值给get_name，此时get_name是一个类的实例对象,当调用get_name时会执行Decorator实例对象的call方法。但这种方式相对于闭包结构来说就有点复杂了，一般不用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;装饰器带参数结构&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果使用类结构需要添加额外的参数怎么办呢？和闭包结构一样，再添加一层。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def three_decorator(pas=''):
    class Decorator(object):
        def __init__(self, func):
            self.func = func
            self.pas = pas

        def __call__(self, *args, **kwargs):
            &quot;&quot;&quot;
            添加额外的代码
            :param args:
            :param kwargs:
            :return:
            &quot;&quot;&quot;
            print('do something')
            return self.func(*args, **kwargs)

    return Decorator

@three_decorator('hhhhh')
def get_name():
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用装饰器的副作用&quot;&gt;使用装饰器的副作用&lt;/h2&gt;
&lt;p&gt;装饰器的用处不用多说，函数校验、进入日志、函数执行前后处理等多场景都需要用到，它也有一点副作用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def tow_decorator(func):
    def new_func(*args, **kwargs):
        &quot;&quot;&quot;new_func function&quot;&quot;&quot;
        res = func(*args, **kwargs)
        print(&quot;do other something&quot;)
        return res

    return new_func

@tow_decorator
def get_name():
    &quot;&quot;&quot;get_name function&quot;&quot;&quot;
    print('jjjjjj')
if __name__ == '__main__':
    print(get_name.__doc__)

# 结果
‘new_func function’&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，由于get_name被装饰后指向的是new_func函数，所以打印的信息不再是get_name函数的说明了，对于调试是不方便的。我们可以使用functools模块的wraps函数消除这个副作用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def tow_decorator(func):
    @functools.wraps(func)
    def new_func(*args, **kwargs):
        &quot;&quot;&quot;new_func function&quot;&quot;&quot;
        res = func(*args, **kwargs)
        print(&quot;do other something&quot;)
        return res

    return new_func

@tow_decorator
def get_name():
    &quot;&quot;&quot;get_name function&quot;&quot;&quot;
    print('jjjjjj')
if __name__ == '__main__':
    print(get_name.__doc__)

# 结果
get_name function&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;所以一般创建装饰器的标准结构是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import functools
def decorator(func):
    @functools.wraps(func)
    def new_func(*args,**kwargs):
        &quot;do something&quot;
        res = func(*args,**kwargs)
        print(&quot;do something&quot;)
        return res

    return new_func&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;box&quot;&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;作者：天宇之游&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/cwp-bg/&quot;&gt;http://www.cnblogs.com/cwp-bg/&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;本文版权归作者和博客园共有，欢迎转载、交流，但未经作者同意必须保留此段声明，且在文章明显位置给出原文链接。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 28 Aug 2018 05:53:00 +0000</pubDate>
<dc:creator>天宇之游</dc:creator>
<og:description>python的装饰器使用是python语言一个非常重要的部分，装饰器是程序设计模式中装饰模式的具体化，python提供了特殊的语法糖可以非常方便的实现装饰模式。 装饰模式简介 什么叫装饰？ 简单来说就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cwp-bg/p/9547797.html</dc:identifier>
</item>
<item>
<title>JavaScript模拟自由落体 - caryForJava</title>
<link>http://www.cnblogs.com/ccylovehs/p/9547690.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ccylovehs/p/9547690.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/996357/201808/996357-20180828130247213-1628743318.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;利用Canvas画圆球、地面；&lt;/p&gt;
&lt;h2&gt;1.下落过程&lt;/h2&gt;
&lt;p&gt;物理知识回顾，物体下落过程（不计损耗）由重力势能转换成动能&lt;/p&gt;
&lt;p&gt;重力势能 Ep = mgh&lt;/p&gt;
&lt;p&gt;动能 　　Ek = (1/2)mv^2&lt;/p&gt;
&lt;p&gt;速度右0增加至gt&lt;/p&gt;
&lt;p&gt;此间需要计算浏览器每次渲染的圆球y坐标&lt;/p&gt;
&lt;p&gt;y = (1/2)gt^2&lt;/p&gt;
&lt;h2&gt;2.反弹过程&lt;/h2&gt;
&lt;p&gt;动能转化成重力势能&lt;/p&gt;
&lt;p&gt;速度是逐渐减少直至为0&lt;/p&gt;
&lt;p&gt;本打算设置 y = (1/2)g(t-t1)^2，t1为下落或者反弹消耗的时长&lt;/p&gt;
&lt;p&gt;但是实际呈现的效果却不尽人意，应该是反弹位移计算有误，经反复思考无果（若哪位大拿有更好的实现方式欢迎评论告知）&lt;/p&gt;
&lt;p&gt;所以决定将下落过程的位移保存在一个数组里，待反弹时再逐一取出赋值&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        body &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; rgba(0, 0, 0, 1)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        #canvas&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 10px auto&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;canvas &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;canvas&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&quot;600&quot;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;=&quot;600&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;your browser is not support canvas&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;canvas&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自由落体 H=(gt^2)/2 动能 Ek=(mv^2)/2 重力势能:Ep = mgh&lt;/span&gt;
&lt;span&gt;    let x&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;300&lt;/span&gt;&lt;span&gt;,y&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt;,                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;圆心坐标&lt;/span&gt;
&lt;span&gt;        minHeight &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;60&lt;/span&gt;&lt;span&gt;,             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小下落位移&lt;/span&gt;
&lt;span&gt;        maxHeight &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;446&lt;/span&gt;&lt;span&gt;,            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大下落位移&lt;/span&gt;
&lt;span&gt;        dir &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dir true下落，false为弹起&lt;/span&gt;
&lt;span&gt;    (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        let canvas&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;canvas&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        let ctx &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; canvas.getContext(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        draw(ctx);
    })();
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; draw(ctx){
        let currentTime &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getTime();     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始毫秒数,折返记录一次currentTime&lt;/span&gt;
&lt;span&gt;        let arr_y &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; [];                             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置下落位移的数组&lt;/span&gt;
&lt;span&gt;        window.requestAnimationFrame(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; init(){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(dir){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(y &lt;/span&gt;&lt;span&gt;&amp;gt;=&lt;/span&gt;&lt;span&gt; maxHeight){
                    dir &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    currentTime &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getTime();
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    y &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; y &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; Math.pow((&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getTime() &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; currentTime)&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1000,2)*10&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
                    arr_y.push(y);
                }
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(y &lt;/span&gt;&lt;span&gt;&amp;lt;=&lt;/span&gt;&lt;span&gt; minHeight){
                    dir &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    currentTime &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getTime();
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    y &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; arr_y.splice(&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] &lt;/span&gt;&lt;span&gt;||&lt;/span&gt; &lt;span&gt;60&lt;/span&gt;&lt;span&gt;;
                }
            }
            drawArc(ctx,x,y);
            requestAnimationFrame(init);
        });
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制圆球和地面&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; drawArc(ctx,x,y){
        ctx.clearRect(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;600&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;600&lt;/span&gt;&lt;span&gt;);
        ctx.beginPath();
        ctx.arc(x,y,&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,Math.PI&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
        ctx.fillStyle&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#98adf0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        ctx.fill();
        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;#ffffff&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        ctx.moveTo(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;);
        ctx.lineTo(&lt;/span&gt;&lt;span&gt;600&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;);
        ctx.lineWidth &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
        ctx.stroke();
        ctx.closePath();
        ctx.save();
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;虽然只是一个简单的下落和弹起，但是为了弹起位移的实现整整花费本人6天的时间（主要是每天都思考怎么计算弹起位移）&lt;/p&gt;
&lt;p&gt;主要开始的思路一直关注在&lt;/p&gt;
&lt;p&gt;下落位移 （开口线上抛物线方程）&lt;/p&gt;
&lt;p&gt;y = (1/2)gt^2&lt;/p&gt;
&lt;p&gt;思考反弹的位移应该改是将抛物线沿x轴右移t1，得出&lt;/p&gt;
&lt;p&gt;y = (1/2)g(t-t1)^2&lt;/p&gt;
&lt;p&gt;有兴趣的同学可以试试看看效果&lt;/p&gt;
&lt;p&gt;浏览器渲染反弹的效果不尽人意，所以一直没想出计算的位移方法，故使用数组实现&lt;/p&gt;

&lt;p&gt;欢迎纠错~&lt;/p&gt;

</description>
<pubDate>Tue, 28 Aug 2018 05:23:00 +0000</pubDate>
<dc:creator>caryForJava</dc:creator>
<og:description>1.效果图 2.实现分析 利用Canvas画圆球、地面； 1.下落过程 物理知识回顾，物体下落过程（不计损耗）由重力势能转换成动能 重力势能 Ep = mgh 动能 Ek = (1/2)mv^2 速度</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ccylovehs/p/9547690.html</dc:identifier>
</item>
</channel>
</rss>