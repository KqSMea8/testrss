<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>整理一下 System.Linq.Enumerable 类中的那些比较少用的方法 - h82258652</title>
<link>http://www.cnblogs.com/h82258652/p/8779461.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/h82258652/p/8779461.html</guid>
<description>&lt;p&gt;Linq 虽然用得多，但是里面有一些方法比较少用，因此整理一下。Enumerable 类的所有方法可以在 MSDN 上查阅到：&lt;a title=&quot;https://msdn.microsoft.com/zh-cn/library/system.linq.enumerable.aspx&quot; href=&quot;https://msdn.microsoft.com/zh-cn/library/system.linq.enumerable.aspx&quot;&gt;https://msdn.microsoft.com/zh-cn/library/system.linq.enumerable.aspx&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;这个方法有三个重载，先看第一个&lt;/p&gt;
&lt;h3&gt;Aggregate&amp;lt;TSource&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, TSource, TSource&amp;gt;)&lt;/h3&gt;
&lt;p&gt;参数是接受两个 TSource 类型的输入，返回一个 TSource 类型的输出。&lt;/p&gt;
&lt;p&gt;按照 MSDN 上的说明，输入的第一个参数是累加的值，第二个参数是元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] array = &lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result = array.Aggregate((sum, i) =&amp;gt; sum +&lt;span&gt; i);
    Console.WriteLine(result);
}
{
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] array = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; result = array.Aggregate((combine, str) =&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; combine + &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str;
    });
    Console.WriteLine(result);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;则会输出 15 和 hello world !&lt;/p&gt;
&lt;p&gt;在第一次进入 Aggregate 的 Func 时，combine 的值为第一个元素的值，str 为第二个元素的值。&lt;/p&gt;
&lt;p&gt;当输入的序列的元素个数为 0 时，则抛出 InvalidOperationException 异常。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152628379-726908070.png&quot;&gt;&lt;img title=&quot;QQ截图20180410123951&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152628939-2032313231.png&quot; alt=&quot;QQ截图20180410123951&quot; width=&quot;902&quot; height=&quot;173&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而当元素的个数只有一个的时候，则不会执行 Func。&lt;/p&gt;
&lt;p&gt;接下来看第二个重载&lt;/p&gt;
&lt;h3&gt;Aggregate&amp;lt;TSource, TAccumulate&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, TAccumulate, Func&amp;lt;TAccumulate, TSource, TAccumulate&amp;gt;)&lt;/h3&gt;
&lt;p&gt;比起第一个重载，多了一个参数输入参数 TAccumulate，泛型参数也变成了两个。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] array = &lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; result = array.Aggregate(-&lt;span&gt;1L&lt;/span&gt;, (sum, i) =&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sum +&lt;span&gt; i;
    });
    Console.WriteLine(result);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么这段代码的输出则会是 14。第一次进入 Func 的时候，sum 的值为 -1L，i 的值是 1，这个行为跟第一个重载稍微有点区别。&lt;/p&gt;
&lt;p&gt;而且当元素只有一个的时候，也是会进入 Func 的&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152629327-553223264.png&quot;&gt;&lt;img title=&quot;QQ截图20180410124719&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152629782-1134745771.png&quot; alt=&quot;QQ截图20180410124719&quot; width=&quot;513&quot; height=&quot;133&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当序列为空的时候，也不会触发到异常&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152630156-1794106317.png&quot;&gt;&lt;img title=&quot;QQ截图20180410124856&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152630559-617645840.png&quot; alt=&quot;QQ截图20180410124856&quot; width=&quot;615&quot; height=&quot;235&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;直接等于输入参数的值。&lt;/p&gt;
&lt;p&gt;第三个重载&lt;/p&gt;
&lt;h3&gt;Aggregate&amp;lt;TSource, TAccumulate, TResult&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, TAccumulate, Func&amp;lt;TAccumulate, TSource, TAccumulate&amp;gt;, Func&amp;lt;TAccumulate, TResult&amp;gt;)&lt;/h3&gt;
&lt;p&gt;这个其实就是相当与第二个重载增加了最后一个参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] array = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; result = array.Aggregate(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (combine, str) =&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; combine + &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str;
    }, end &lt;/span&gt;=&amp;gt;&lt;span&gt; end.ToUpperInvariant());
    Console.WriteLine(result);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行后会输出 START HELLO WORLD !。&lt;/p&gt;
&lt;p&gt;最后的那个参数相对于对最终结果进行了一下处理，跟下面的代码是等价的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] array = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; result = array.Aggregate(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (combine, str) =&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; combine + &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str;
    }).ToUpperInvariant();
    Console.WriteLine(result);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第一个重载&lt;/p&gt;
&lt;h3&gt;DefaultIfEmpty&amp;lt;TSource&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;)&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152630980-1743778890.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_130422&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152631439-273151605.png&quot; alt=&quot;snipaste_20180410_130422&quot; width=&quot;642&quot; height=&quot;327&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152631838-669554314.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_130457&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152632251-836346494.png&quot; alt=&quot;snipaste_20180410_130457&quot; width=&quot;636&quot; height=&quot;219&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;就是说，如果一个序列的元素个数是零个的话，那就返回一个只有一个 default(TSource) 元素的序列。感觉这没啥用(lll￢ω￢)&lt;/p&gt;
&lt;p&gt;看另一个重载&lt;/p&gt;
&lt;h3&gt;DefaultIfEmpty&amp;lt;TSource&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, TSource)&lt;/h3&gt;
&lt;p&gt;多了个参数，猜也猜得出来了&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152632704-748716340.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_130857&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152633208-1037164788.png&quot; alt=&quot;snipaste_20180410_130857&quot; width=&quot;862&quot; height=&quot;327&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152633614-535876134.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_130942&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152634515-2025440784.png&quot; alt=&quot;snipaste_20180410_130942&quot; width=&quot;681&quot; height=&quot;215&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;唔，好像还是没啥实用意义…………&lt;/p&gt;


&lt;h3&gt;Except&amp;lt;TSource&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, IEnumerable&amp;lt;TSource&amp;gt;)&lt;/h3&gt;
&lt;p&gt;求差集&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152634931-1181689979.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_131437&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152635458-1395416056.png&quot; alt=&quot;snipaste_20180410_131437&quot; width=&quot;598&quot; height=&quot;223&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A 序列减去 B 序列，并且去重了。&lt;/p&gt;
&lt;p&gt;另一重载&lt;/p&gt;
&lt;h3&gt;Except&amp;lt;TSource&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, IEnumerable&amp;lt;TSource&amp;gt;, IEqualityComparer&amp;lt;TSource&amp;gt;)&lt;/h3&gt;
&lt;p&gt;多了一个比较器&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152636051-546946922.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_131741&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152636478-1578335915.png&quot; alt=&quot;snipaste_20180410_131741&quot; width=&quot;792&quot; height=&quot;221&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后只会输出 Hello，因为在 IgnoreCase 比较器下，world 和 WORLD 是一样的。&lt;/p&gt;


&lt;p&gt;虽然用得还是比较多，但是重载比较多，还是写一下吧。&lt;/p&gt;
&lt;h3&gt;GroupBy&amp;lt;TSource, TKey&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, TKey&amp;gt;)&lt;/h3&gt;
&lt;p&gt;这个是最简单的重载了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152636937-2131417288.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_132350&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152637394-194162257.png&quot; alt=&quot;snipaste_20180410_132350&quot; width=&quot;834&quot; height=&quot;678&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据 Age 分组，这个重载很简单，也是最常用的。&lt;/p&gt;
&lt;h3&gt;GroupBy&amp;lt;TSource, TKey&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, TKey&amp;gt;, IEqualityComparer&amp;lt;TKey&amp;gt;)&lt;/h3&gt;
&lt;p&gt;多了一个比较器，不难&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152637943-1707092982.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_132621&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152638443-520194578.png&quot; alt=&quot;snipaste_20180410_132621&quot; width=&quot;1087&quot; height=&quot;688&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152638995-1491709549.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_132655&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152639605-912140337.png&quot; alt=&quot;snipaste_20180410_132655&quot; width=&quot;1084&quot; height=&quot;652&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Key 会根据第一次匹配到的值。&lt;/p&gt;
&lt;h3&gt;GroupBy&amp;lt;TSource, TKey, TElement&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, TKey&amp;gt;, Func&amp;lt;TSource, TElement&amp;gt;)&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152640189-649330387.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_133013&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152643938-1121835004.png&quot; alt=&quot;snipaste_20180410_133013&quot; width=&quot;945&quot; height=&quot;436&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第一个重载的改版而且，如果将上面的 person =&amp;gt; person.Name 改为 person =&amp;gt; person，那跟第一个重载没区别。&lt;/p&gt;
&lt;h3&gt;GroupBy&amp;lt;TSource, TKey, TElement&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, TKey&amp;gt;, Func&amp;lt;TSource, TElement&amp;gt;, IEqualityComparer&amp;lt;TKey&amp;gt;)&lt;/h3&gt;
&lt;p&gt;多了一个比较器而已，不说了。&lt;/p&gt;
&lt;h3&gt;GroupBy&amp;lt;TSource, TKey, TResult&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, TKey&amp;gt;, Func&amp;lt;TKey, IEnumerable&amp;lt;TSource&amp;gt;, TResult&amp;gt;)&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152649033-1012428997.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_133702&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152654340-1916293198.png&quot; alt=&quot;snipaste_20180410_133702&quot; width=&quot;845&quot; height=&quot;480&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;分完组后对每一组进行了一下处理。&lt;/p&gt;
&lt;h3&gt;GroupBy&amp;lt;TSource, TKey, TResult&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, TKey&amp;gt;, Func&amp;lt;TKey, IEnumerable&amp;lt;TSource&amp;gt;, TResult&amp;gt;, IEqualityComparer&amp;lt;TKey&amp;gt;)&lt;/h3&gt;
&lt;p&gt;比上面多了一个比较器，不说了。&lt;/p&gt;
&lt;h3&gt;GroupBy&amp;lt;TSource, TKey, TElement, TResult&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, TKey&amp;gt;, Func&amp;lt;TSource, TElement&amp;gt;, Func&amp;lt;TKey, IEnumerable&amp;lt;TElement&amp;gt;, TResult&amp;gt;)&lt;/h3&gt;
&lt;p&gt;多了元素选择的参数重载，参考上面。&lt;/p&gt;
&lt;h3&gt;GroupBy&amp;lt;TSource, TKey, TElement, TResult&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, TKey&amp;gt;, Func&amp;lt;TSource, TElement&amp;gt;, Func&amp;lt;TKey, IEnumerable&amp;lt;TElement&amp;gt;, TResult&amp;gt;, IEqualityComparer&amp;lt;TKey&amp;gt;)&lt;/h3&gt;
&lt;p&gt;多了选择器，不说。&lt;/p&gt;


&lt;h3&gt;Join&amp;lt;TOuter, TInner, TKey, TResult&amp;gt;(IEnumerable&amp;lt;TOuter&amp;gt;, IEnumerable&amp;lt;TInner&amp;gt;, Func&amp;lt;TOuter, TKey&amp;gt;, Func&amp;lt;TInner, TKey&amp;gt;, Func&amp;lt;TOuter, TInner, TResult&amp;gt;)&lt;/h3&gt;
&lt;p&gt;这个其实不难，只要参考一下 SQL 中的 inner join 的话。&lt;/p&gt;
&lt;p&gt;先初始化测试数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
List&amp;lt;Person&amp;gt; list1 = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Person&amp;gt;&lt;span&gt;()
{
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person()
    {
        Id &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
        Gender &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person()
    {
        Id &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt; ,
        Gender &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person()
    {
        Id &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
        Gender &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
};
List&lt;/span&gt;&amp;lt;Student&amp;gt; list2 = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Student&amp;gt;&lt;span&gt;()
{
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student()
    {
        Id &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
        Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;martin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student()
    {
        Id &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
        Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;valid void&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student()
    {
        Id &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,
        Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;justin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后测试代码走起&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152659151-1721459079.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_135801&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152701252-189193845.png&quot; alt=&quot;snipaste_20180410_135801&quot; width=&quot;766&quot; height=&quot;158&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;没啥难的，等价于以下的 linq 写法&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152703834-1444319820.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_140346&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152704892-1004895772.png&quot; alt=&quot;snipaste_20180410_140346&quot; width=&quot;911&quot; height=&quot;142&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Join&amp;lt;TOuter, TInner, TKey, TResult&amp;gt;(IEnumerable&amp;lt;TOuter&amp;gt;, IEnumerable&amp;lt;TInner&amp;gt;, Func&amp;lt;TOuter, TKey&amp;gt;, Func&amp;lt;TInner, TKey&amp;gt;, Func&amp;lt;TOuter, TInner, TResult&amp;gt;, IEqualityComparer&amp;lt;TKey&amp;gt;)&lt;/h3&gt;
&lt;p&gt;多了个比较器，用于比较 key，不说了。&lt;/p&gt;


&lt;h3&gt;GroupJoin&amp;lt;TOuter, TInner, TKey, TResult&amp;gt;(IEnumerable&amp;lt;TOuter&amp;gt;, IEnumerable&amp;lt;TInner&amp;gt;, Func&amp;lt;TOuter, TKey&amp;gt;, Func&amp;lt;TInner, TKey&amp;gt;, Func&amp;lt;TOuter, IEnumerable&amp;lt;TInner&amp;gt;, TResult&amp;gt;)&lt;/h3&gt;
&lt;p&gt;看上去很复杂，但其实可以参考 Join 的输入进行对比。&lt;/p&gt;
&lt;p&gt;测试数据我们还是沿用 Join 的。执行测试代码&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152707740-1588650549.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_141037&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152708626-588132992.png&quot; alt=&quot;snipaste_20180410_141037&quot; width=&quot;941&quot; height=&quot;185&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对等的 linq 写法如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; result = (&lt;span&gt;from&lt;/span&gt; person &lt;span&gt;in&lt;/span&gt;&lt;span&gt; list1
              join student &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; list2 on person.Id equals student.Id into studentGroup
              &lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;
              {
                  Id &lt;/span&gt;=&lt;span&gt; person.Id,
                  Gender &lt;/span&gt;=&lt;span&gt; person.Gender,
                  Students &lt;/span&gt;=&lt;span&gt; studentGroup.ToList()
              }).ToList();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;GroupJoin&amp;lt;TOuter, TInner, TKey, TResult&amp;gt;(IEnumerable&amp;lt;TOuter&amp;gt;, IEnumerable&amp;lt;TInner&amp;gt;, Func&amp;lt;TOuter, TKey&amp;gt;, Func&amp;lt;TInner, TKey&amp;gt;, Func&amp;lt;TOuter, IEnumerable&amp;lt;TInner&amp;gt;, TResult&amp;gt;, IEqualityComparer&amp;lt;TKey&amp;gt;)&lt;/h3&gt;
&lt;p&gt;多了一个比较器，不说了。&lt;/p&gt;


&lt;p&gt;这个最近这段时间用得比较多，也记录一下吧&lt;/p&gt;
&lt;h3&gt;SelectMany&amp;lt;TSource, TResult&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, IEnumerable&amp;lt;TResult&amp;gt;&amp;gt;)&lt;/h3&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152709342-1125059932.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_142134&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152711423-166400494.png&quot; alt=&quot;snipaste_20180410_142134&quot; width=&quot;464&quot; height=&quot;237&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单的来说就是将一个 IEnumerable&amp;lt;IEnumerable&amp;lt;T&amp;gt;&amp;gt; 的序列变成一个 IEnumerable&amp;lt;T&amp;gt; 的序列。&lt;/p&gt;
&lt;p&gt;对等的 linq 写法&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152712647-1341184769.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_142358&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152713281-198587175.png&quot; alt=&quot;snipaste_20180410_142358&quot; width=&quot;574&quot; height=&quot;124&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感觉 linq 写法会相对比较好理解的说。&lt;/p&gt;
&lt;h3&gt;SelectMany&amp;lt;TSource, TResult&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, Int32, IEnumerable&amp;lt;TResult&amp;gt;&amp;gt;)&lt;/h3&gt;
&lt;p&gt;Func 多了个 Int32 的参数，看测试代码&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152714434-1063419987.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_142808&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152715324-57398883.png&quot; alt=&quot;snipaste_20180410_142808&quot; width=&quot;571&quot; height=&quot;225&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152716249-306796274.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_142818&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152716827-494016736.png&quot; alt=&quot;snipaste_20180410_142818&quot; width=&quot;555&quot; height=&quot;222&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很好理解，就是当前的索引。&lt;/p&gt;
&lt;h3&gt;SelectMany&amp;lt;TSource, TCollection, TResult&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, IEnumerable&amp;lt;TCollection&amp;gt;&amp;gt;, Func&amp;lt;TSource, TCollection, TResult&amp;gt;)&lt;/h3&gt;
&lt;p&gt;比起第一个就是多了个结果执行而已&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152717447-1893770857.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_143405&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152717936-1429296875.png&quot; alt=&quot;snipaste_20180410_143405&quot; width=&quot;814&quot; height=&quot;239&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;会进入这个 Func 四次，前两次是 helloword 那个 List，后两次是 justin martin 那个 List。&lt;/p&gt;
&lt;h3&gt;SelectMany&amp;lt;TSource, TCollection, TResult&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, Int32, IEnumerable&amp;lt;TCollection&amp;gt;&amp;gt;, Func&amp;lt;TSource, TCollection, TResult&amp;gt;)&lt;/h3&gt;
&lt;p&gt;多了索引，参考上面。&lt;/p&gt;


&lt;p&gt;序列比较，知道有这个东西，但平时好像没有怎么用过。&lt;/p&gt;
&lt;h3&gt;SequenceEqual&amp;lt;TSource&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, IEnumerable&amp;lt;TSource&amp;gt;)&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152718410-1280760752.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_144435&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152718841-1188367945.png&quot; alt=&quot;snipaste_20180410_144435&quot; width=&quot;618&quot; height=&quot;310&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很好理解，首要前提肯定是元素个数相等，其次要每一个元素相等。&lt;/p&gt;
&lt;h3&gt;SequenceEqual&amp;lt;TSource&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, IEnumerable&amp;lt;TSource&amp;gt;, IEqualityComparer&amp;lt;TSource&amp;gt;)&lt;/h3&gt;
&lt;p&gt;多了个比较器，不说了。&lt;/p&gt;


&lt;p&gt;Skip 倒是一直在用，SkipWhile 就用得比较少，也记录一下吧。&lt;/p&gt;
&lt;h3&gt;SkipWhile&amp;lt;TSource&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, Boolean&amp;gt;)&lt;/h3&gt;
&lt;p&gt;不难，就是当 Func 返回 false 时停止。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152719281-817323888.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_145113&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152719694-1252148937.png&quot; alt=&quot;snipaste_20180410_145113&quot; width=&quot;559&quot; height=&quot;207&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为当去到 3 的时候为 false，因此返回 3 和剩下的元素。&lt;/p&gt;
&lt;h3&gt;SkipWhile&amp;lt;TSource&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, Int32, Boolean&amp;gt;)&lt;/h3&gt;
&lt;p&gt;多了个索引而已，没啥好说的。&lt;/p&gt;


&lt;p&gt;先看第一个重载&lt;/p&gt;
&lt;h3&gt;ToDictionary&amp;lt;TSource, TKey&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, TKey&amp;gt;)&lt;/h3&gt;
&lt;p&gt;不难，Func 就是获取按照什么来生成 Key。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152720136-1422957059.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_145804&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152720869-1793951789.png&quot; alt=&quot;snipaste_20180410_145804&quot; width=&quot;646&quot; height=&quot;301&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外使用这个方法是要注意，Key 是不能重复的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152721348-16955417.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_145939&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152721807-400734983.png&quot; alt=&quot;snipaste_20180410_145939&quot; width=&quot;936&quot; height=&quot;262&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以说实话，这方法平时比较少用。。。&lt;/p&gt;
&lt;h3&gt;ToDictionary&amp;lt;TSource, TKey&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, TKey&amp;gt;, IEqualityComparer&amp;lt;TKey&amp;gt;)&lt;/h3&gt;
&lt;p&gt;多了一个比较器，没啥好说的。&lt;/p&gt;
&lt;h3&gt;ToDictionary&amp;lt;TSource, TKey, TElement&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, TKey&amp;gt;, Func&amp;lt;TSource, TElement&amp;gt;)&lt;/h3&gt;
&lt;p&gt;比起第一个重载，多了一个如何生成字典的值的 Func，也没啥好说的。&lt;/p&gt;
&lt;h3&gt;ToDictionary&amp;lt;TSource, TKey, TElement&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, TKey&amp;gt;, Func&amp;lt;TSource, TElement&amp;gt;, IEqualityComparer&amp;lt;TKey&amp;gt;)&lt;/h3&gt;
&lt;p&gt;多了比较器，不说了。&lt;/p&gt;


&lt;p&gt;这个有点像上面的 ToDictionary 的。&lt;/p&gt;
&lt;h3&gt;ToLookup&amp;lt;TSource, TKey&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, TKey&amp;gt;)&lt;/h3&gt;
&lt;p&gt;跟 ToDictionary 的第一个重载的输入参数是一样的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152722378-1536180601.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_150636&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152722847-978397036.png&quot; alt=&quot;snipaste_20180410_150636&quot; width=&quot;722&quot; height=&quot;378&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ILookup&amp;lt;int, Person&amp;gt; 这个的结构类似于一个数组，然后每个数组的元素是一个 Group。&lt;/p&gt;
&lt;p&gt;当元素的 Key 重复的时候：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152723264-1341096800.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_151211&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152723688-1233181320.png&quot; alt=&quot;snipaste_20180410_151211&quot; width=&quot;724&quot; height=&quot;384&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么这个 lookup 就只有一个 group 了，但这个 group 就会有多个元素。&lt;/p&gt;
&lt;h3&gt;ToLookup&amp;lt;TSource, TKey&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, TKey&amp;gt;, IEqualityComparer&amp;lt;TKey&amp;gt;)&lt;/h3&gt;
&lt;h3&gt;ToLookup&amp;lt;TSource, TKey, TElement&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, TKey&amp;gt;, Func&amp;lt;TSource, TElement&amp;gt;)&lt;/h3&gt;
&lt;h3&gt;ToLookup&amp;lt;TSource, TKey, TElement&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;, Func&amp;lt;TSource, TKey&amp;gt;, Func&amp;lt;TSource, TElement&amp;gt;, IEqualityComparer&amp;lt;TKey&amp;gt;)&lt;/h3&gt;
&lt;p&gt;这三个重载可以参考一下 ToDictionary 的重载，一样的说。&lt;/p&gt;


&lt;p&gt;这个方法就只有一个，没别的重载&lt;/p&gt;
&lt;h3&gt;Zip&amp;lt;TFirst, TSecond, TResult&amp;gt;(IEnumerable&amp;lt;TFirst&amp;gt;, IEnumerable&amp;lt;TSecond&amp;gt;, Func&amp;lt;TFirst, TSecond, TResult&amp;gt;)&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152724081-1383416849.png&quot;&gt;&lt;img title=&quot;snipaste_20180410_151919&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180410152724474-1881203233.png&quot; alt=&quot;snipaste_20180410_151919&quot; width=&quot;632&quot; height=&quot;176&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里就借用 MSDN 上的示例代码了，看结果也看得出 Zip 这个操作的逻辑了。遍历两个序列进行操作，直到其中一个到达尾部。&lt;/p&gt;

&lt;p&gt;另外像 TakeWhile 可以参考上面的 SkipWhile 就不说了。Distinct、Union 和 Intersect 平时也用得比较多，因此也不说了。&lt;/p&gt;
</description>
<pubDate>Tue, 10 Apr 2018 07:27:00 +0000</pubDate>
<dc:creator>h82258652</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/h82258652/p/8779461.html</dc:identifier>
</item>
<item>
<title>BAT美团滴滴java面试大纲（带答案版）之四：多线程Lock - xiaoyang_</title>
<link>http://www.cnblogs.com/xyang/p/8779368.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xyang/p/8779368.html</guid>
<description>&lt;p&gt;继续面试大纲系列文章。&lt;/p&gt;

&lt;p&gt;　　这是多线程的第二篇。&lt;/p&gt;
&lt;p&gt;　　多线程就像武学中对的吸星大法，理解透了用好了可以得道成仙，俯瞰芸芸众生；而滥用则会遭其反噬。&lt;/p&gt;
&lt;p&gt;　　在多线程编程中要渡的第二个“劫”，则是Lock。在很多时候，包括面试、包括实际项目应用，我们都会拿来和synchronized对比一番。&lt;/p&gt;
&lt;p&gt;　　我们知道，多线程的核心思想是通过增加线程数量来并发的运行，来提高效率，也就是数量决胜论，而不是质量决胜（提高每个线程的处理能力）。多线程编程中面临的最大挑战，是如何解决多个线程同时修改一个公用的变量所带来的变量值不确定性问题。顺着这个思路分析，常用办法，无非就是，要么对变量动手，在一个线程修改时，变量值被锁定。要么是对修改的操作动手，在该段代码执行时，对其加锁，其他线程不可以在同一时刻进入该段代码执行。&lt;/p&gt;
&lt;p&gt;　　同synchronized一样，Lock，也是实现了后一种办法。只不过，实现方式，有所不同。&lt;/p&gt;



&lt;ol&gt;&lt;li&gt;&lt;strong&gt;问：&lt;/strong&gt;你平时涉及到多线程编程多不多？谈谈你对Lock锁的理解&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分析：最好对比着synchronized来讲&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;答：&lt;/strong&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;　　&lt;/strong&gt;在多线程编程中，为了达到线程安全的目的，我们往往通过加锁的方式来实现。Lock锁是java代码级别来实现的，相对于synchronizedd在功能性上，有所加强，主要是，公平锁，轮询锁，定时锁，可中断锁等，还增加了多路通知机制（Condition），可以用一个锁来管理多个同步块。另外在使用的时候，必须手动的释放锁。&lt;/li&gt;
&lt;li&gt;详细分析：
&lt;ol&gt;&lt;li&gt;Lock锁的实现，主要是借助于队列同步器（我们常常见到的AQS）来实现。它包括一个int变量来表示状态；一个FIFO队列，来存储获取资源的排队线程。&lt;/li&gt;
&lt;li&gt;当一个线程申请资源时，就是是获取当前的同步状态，并判断是否可符合预期，如果是，则通过CAS操作，来修改上述Int变量标识的同步状态。如果否，则线程进入队列排队（这是在一般情况，在使用tyrLock时，是直接返回获取锁失败）。
&lt;ol&gt;&lt;li&gt;
&lt;ol&gt;&lt;li readability=&quot;0&quot;&gt;锁有独占锁和共享锁。独占锁就是在同一时刻，只允许同一个线程持有该锁；共享锁实现的时候和独占锁稍有不同，不是简单的修改同步状态（比如1和0），而是获取这个值，当值大于0时，即标识获取共享锁成功（隐含意思是每个线程获取锁成功后，这个值减1）。这里附上独占锁的实现源码（源码片段来自《java并发编程的艺术》，并加上自己的注释）：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Mutex &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Lock {  
  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 静态内部类，自定义同步器  &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Sync &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractQueuedSynchronizer{  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该方法用于判断当前锁是否在独占模式下被占用状态  &lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isHeldExclusively(){  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getState() == 1&lt;span&gt;;  
        }  
  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取锁!!! &lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAcquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; acquires){ &lt;br/&gt;　　 　　     //典型的CAS原子操作，如果初始状态为0，可以获得锁
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compareAndSetState(0, 1&lt;span&gt;)){  
                setExclusiveOwnerThread(Thread.currentThread());  
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;  
            }  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;  
        }  
  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放锁，将当前状态设置为0  &lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryRelease(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; releases){  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getState() == 0&lt;span&gt;){  
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalMonitorStateException();  
            }  
            setExclusiveOwnerThread(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);  
            setState(&lt;/span&gt;0&lt;span&gt;);  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;  
        }  
  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回一个Condition，每个condition都包含了一个condition队列 ，这个后续再说 &lt;/span&gt;
&lt;span&gt;        Condition newCondition(){  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConditionObject();  
        }  
    } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Lock锁中，支持可中断的锁，实现原理是，队列中的等待线程，可以响应其他线程发起的中断信号，抛出InterruptdException异常。&lt;/li&gt;
&lt;li&gt;关于同步队列，需要了解，获取同步状态失败的线程，被包装为Node节点后，加入队列尾，这个操作是CAS操作，以保证线程安全，失败就死循环重试；而队列首节点，则是当前持有锁的线程。该节点一旦释放锁，会唤醒后继节点。&lt;/li&gt;
&lt;li&gt;关于唤醒，是这样的，每个在同步队列中的阻塞线程，都处于自旋的状态，不断的尝试获取锁。这样，当首节点释放锁唤醒后继线程后，被唤醒的线程，还需要判断是否前继线程是首线程，是则获取同步状态（锁）成功。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;　　4.扩展：Condition，多路通知机制　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在Synchronized锁中，提供了wait、notify、notifyAll等方法，实现了等待/通知模式。那么在lock中，由Condition配合，也实现了类似的模式。&lt;/li&gt;
&lt;li&gt;其实现实质是，一个Condition包含一个等待队列，定义多个Condition，那就有多个等待队列，和上文提到的同步队列配合使用。同步队列-等待队列模型请参考下图：&lt;img src=&quot;https://images2018.cnblogs.com/blog/177141/201804/177141-20180410151126388-147360370.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;在上述模型中，调用await方法，相当于把同步队列首节点（持有锁的线程），移动到等待队列。调用signal方法唤醒阻塞的线程，则是将对应Condition等待队列里的首节点（等待时间最长），移入同步队列。&lt;/li&gt;
&lt;li&gt;还有一点需要补充，就是线程的唤醒，调用signal可以正常唤醒；在其他线程中终止线程，也一样会唤醒，只不过唤醒后，只是抛出InterruptException异常。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果你看的爽，请点击右下角的“推荐”，是对小端坚持分享原创的最大鼓励。也可以关注小端的个人公众号 ：   pnxsxb  ，会分享更多的原创技术文章。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;欢迎扫描以下二维码关注公众号：小端有话说：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/177141/201803/177141-20180327102908200-2000617773.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Apr 2018 07:25:00 +0000</pubDate>
<dc:creator>xiaoyang_</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xyang/p/8779368.html</dc:identifier>
</item>
<item>
<title>session详解 - 冒雨ing</title>
<link>http://www.cnblogs.com/saysmy/p/8777600.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/saysmy/p/8777600.html</guid>
<description>&lt;p&gt;&lt;span&gt;1. 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;2. 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;3. Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;所以，总结一下：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。&lt;/span&gt;&lt;/p&gt;


&lt;div readability=&quot;46.020816653323&quot;&gt;
&lt;p&gt;session_start()会做两件事：&lt;/p&gt;
&lt;h3&gt;1、在客户端生成一个存放PHPSESSID的cookie文件，&lt;/h3&gt;
&lt;p&gt;这个文件的存放位置和存放方式跟程序的执行方式有关，不同的浏览器也不尽相同，这一步会产生一个序列化后的字符串——PHPSESSID；&lt;/p&gt;
&lt;h3&gt;2、在服务端生成一个存放session数据的临时文件；&lt;/h3&gt;
&lt;p&gt;存放的位置由session.save_path参数指定，名称类似于“sess_b2f326ee7a8b7617c215a30d22a602f1”，“sess_”代表这是个session文件，“b2f326ee7a8b7617c215a30d22a602f1”即此次会话的PHPSESSID，跟客户端的PHPSESSID一定是一样的。这个文件里存放的就是$_SESSION变量里的具体值，格式为：&lt;/p&gt;
&lt;p&gt;变量名 | 变量类型 : [长度] : 值&lt;/p&gt;
&lt;p&gt;eg：test|s:7:&quot;test111&quot;;test2|i:22222;&lt;/p&gt;


&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;webkit-html-text-node being-edited editing&quot;&gt;session_id() 存取目前 session 代号。&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;webkit-html-text-node being-edited editing&quot;&gt;语法:   &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;string&lt;/span&gt; &lt;span&gt;session_id&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt; [id]);&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;webkit-html-text-node being-edited editing&quot;&gt;&lt;br/&gt;&lt;span class=&quot;webkit-html-text-node being-edited editing&quot;&gt;本函数可取得或者重新配置目前存放 Session 的代号。若无参数 id 则表示只有取得目前 Session 的代号，加上参数则表示将 Session 代号设成新指定的 id。输入及返回均为字符串。&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;webkit-html-text-node being-edited editing&quot;&gt;输出 session_id()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
    &lt;/span&gt;&lt;span&gt;session_start&lt;/span&gt;&lt;span&gt;(); 
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;session_id&lt;/span&gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出 dqr58dnuqj2gufvg4o3tmjb9v4&lt;/span&gt;
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;webkit-html-text-node being-edited editing&quot;&gt;设置 session_id()&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
    &lt;/span&gt;&lt;span&gt;session_id&lt;/span&gt;(&quot;NowaMagic&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;session_start&lt;/span&gt;&lt;span&gt;(); 
    
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;session_id&lt;/span&gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出 NowaMagic&lt;/span&gt;
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;.session的扩展：默认session存储在哪里。&lt;br/&gt;在php.ini配置文件中有这么一行 session.save_handler = files,&lt;br/&gt;files，说明了php默认的是用文件读写的方式来保存session的。那么在哪个目录呢？继续看。session.save_path = &quot;/tmp&quot;,&lt;br/&gt;这一行前面有个 ; ，说明是被注释的，不过即便这样，php默认的&lt;br/&gt;session 也是保存在这里的，/tmp目录。上图：&lt;br/&gt;&lt;img src=&quot;http://box.kancloud.cn/document_2015-08-31_55e44c61f3733.PNG&quot; alt=&quot;document/2015-08-31/55e44c61f3733&quot;/&gt;&lt;br/&gt;从图中我们可以看到确实在这个目录下面，我们顺便看看里面的内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://box.kancloud.cn/document_2015-08-31_55e44c8eb3e27.PNG&quot; alt=&quot;document/2015-08-31/55e44c8eb3e27&quot;/&gt;&lt;br/&gt;我的写入session的语句是：&lt;br/&gt;$_SESSION['as'] = 'as';&lt;br/&gt;解读一下，第一个as代表的是$_SESSION['as']中的as，|后面的s表示的是这是一个字符串类型的数据，2表示的是这个字符串所占的字节数，最后双引号引起来的是值as。&lt;/p&gt;
&lt;p&gt; 更多存储方式：&lt;a href=&quot;https://blog.csdn.net/fb408487792/article/details/47804241&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/fb408487792/article/details/47804241&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;


&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;https://www.zhihu.com/question/19786827/answer/28752144&lt;/p&gt;
&lt;p&gt;http://www.manongjc.com/article/1267.html&lt;/p&gt;
&lt;p&gt;https://www.bgpy.net/biancheng/php_49756.html&lt;/p&gt;
&lt;p&gt;http://phpbook.phpxy.com/58029&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 10 Apr 2018 07:13:00 +0000</pubDate>
<dc:creator>冒雨ing</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/saysmy/p/8777600.html</dc:identifier>
</item>
<item>
<title>Java总结 - wz-speed</title>
<link>http://www.cnblogs.com/wz-speed/p/8779257.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wz-speed/p/8779257.html</guid>
<description>&lt;p&gt;&lt;strong&gt;项目介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大部分情况，这是一场面试的开门题，面试官问这个问题，主要是考察你的概述能力和全局视野。有的人经常抱怨自己每天在堆业务，但没有成长。事实上，很多情况下确实在堆业务，但并不是没有成长的。并非做中间件或者技术架构才是成长，例如我们的需求分析能力，沟通协作能力，产品思维能力，抽象建模能力等都是一个非常重要的硬实力。&lt;/p&gt;
&lt;p&gt;好的，现在进入正文:&lt;/p&gt;
&lt;p&gt;1、明确项目是做什么的&lt;/p&gt;
&lt;p&gt;2、明确项目的价值。（为什么做这个项目，它解决了用户什么痛点，它带来什么价值？）&lt;/p&gt;
&lt;p&gt;3、明确项目的功能。（这个项目涉及哪些功能？）&lt;/p&gt;
&lt;p&gt;4、明确项目的技术。（这个项目用到哪些技术？）&lt;/p&gt;
&lt;p&gt;5、明确个人在项目中的位置和作用。（你在这个项目的承担角色？）&lt;/p&gt;
&lt;p&gt;6、明确项目的整体架构。&lt;/p&gt;
&lt;p&gt;7、明确项目的优缺点,如果重新设计你会如何设计。&lt;/p&gt;
&lt;p&gt;8、明确项目的亮点。（这个项目有什么亮点？）&lt;/p&gt;
&lt;p&gt;9、明确技术成长。（你通过这个项目有哪些技术成长？）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、List 和 Set 的区别&lt;/p&gt;
&lt;p&gt;2、HashSet 是如何保证不重复的&lt;/p&gt;
&lt;p&gt;3、HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?&lt;/p&gt;
&lt;p&gt;4、HashMap 的扩容过程&lt;/p&gt;
&lt;p&gt;5、HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？&lt;/p&gt;
&lt;p&gt;6、final finally finalize&lt;/p&gt;
&lt;p&gt;7、强引用 、软引用、 弱引用、虚引用&lt;/p&gt;
&lt;p&gt;8、Java反射&lt;/p&gt;
&lt;p&gt;9、Arrays.sort 实现原理和 Collection 实现原理&lt;/p&gt;
&lt;p&gt;10、LinkedHashMap的应用&lt;/p&gt;
&lt;p&gt;11、cloneable接口实现原理&lt;/p&gt;
&lt;p&gt;12、异常分类以及处理机制&lt;/p&gt;
&lt;p&gt;13、wait和sleep的区别&lt;/p&gt;
&lt;p&gt;14、数组在内存中如何分配&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java 并发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、synchronized 的实现原理以及锁优化？&lt;/p&gt;
&lt;p&gt;2、volatile 的实现原理？&lt;/p&gt;
&lt;p&gt;3、Java 的信号灯？&lt;/p&gt;
&lt;p&gt;4、synchronized 在静态方法和普通方法的区别？&lt;/p&gt;
&lt;p&gt;5、怎么实现所有线程在等待某个事件的发生才会去执行？&lt;/p&gt;
&lt;p&gt;6、CAS？CAS 有什么缺陷，如何解决？&lt;/p&gt;
&lt;p&gt;7、synchronized 和 lock 有什么区别？&lt;/p&gt;
&lt;p&gt;8、Hashtable 是怎么加锁的 ？&lt;/p&gt;
&lt;p&gt;9、HashMap 的并发问题？&lt;/p&gt;
&lt;p&gt;10、ConcurrenHashMap 介绍？1.8 中为什么要用红黑树？&lt;/p&gt;
&lt;p&gt;11、AQS&lt;/p&gt;
&lt;p&gt;12、如何检测死锁？怎么预防死锁？&lt;/p&gt;
&lt;p&gt;13、Java 内存模型？&lt;/p&gt;
&lt;p&gt;14、如何保证多线程下 i++ 结果正确？&lt;/p&gt;
&lt;p&gt;15、线程池的种类，区别和使用场景？&lt;/p&gt;
&lt;p&gt;16、分析线程池的实现原理和线程的调度过程？&lt;/p&gt;
&lt;p&gt;17、线程池如何调优，最大数目如何确认？&lt;/p&gt;
&lt;p&gt;18、ThreadLocal原理，用的时候需要注意什么？&lt;/p&gt;
&lt;p&gt;19、CountDownLatch 和 CyclicBarrier 的用法，以及相互之间的差别?&lt;/p&gt;
&lt;p&gt;20、LockSupport工具&lt;/p&gt;
&lt;p&gt;21、Condition接口及其实现原理&lt;/p&gt;
&lt;p&gt;22、Fork/Join框架的理解&lt;/p&gt;
&lt;p&gt;23、分段锁的原理,锁力度减小的思考&lt;/p&gt;
&lt;p&gt;24、八种阻塞队列以及各个阻塞队列的特性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、BeanFactory 和 FactoryBean？&lt;/p&gt;
&lt;p&gt;2、Spring IOC 的理解，其初始化过程？&lt;/p&gt;
&lt;p&gt;3、BeanFactory 和 ApplicationContext？&lt;/p&gt;
&lt;p&gt;4、Spring Bean 的生命周期，如何被管理的？&lt;/p&gt;
&lt;p&gt;5、Spring Bean 的加载过程是怎样的？&lt;/p&gt;
&lt;p&gt;6、如果要你实现Spring AOP，请问怎么实现？&lt;/p&gt;
&lt;p&gt;7、如果要你实现Spring IOC，你会注意哪些问题？&lt;/p&gt;
&lt;p&gt;8、Spring 是如何管理事务的，事务管理机制？&lt;/p&gt;
&lt;p&gt;9、Spring 的不同事务传播行为有哪些，干什么用的？&lt;/p&gt;
&lt;p&gt;10、Spring 中用到了那些设计模式？&lt;/p&gt;
&lt;p&gt;11、Spring MVC 的工作原理？&lt;/p&gt;
&lt;p&gt;12、Spring 循环注入的原理？&lt;/p&gt;
&lt;p&gt;13、Spring AOP的理解，各个术语，他们是怎么相互工作的？&lt;/p&gt;
&lt;p&gt;14、Spring 如何保证 Controller 并发的安全？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Netty&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、BIO、NIO和AIO&lt;/p&gt;
&lt;p&gt;2、Netty 的各大组件&lt;/p&gt;
&lt;p&gt;3、Netty的线程模型&lt;/p&gt;
&lt;p&gt;4、TCP 粘包/拆包的原因及解决方法&lt;/p&gt;
&lt;p&gt;5、了解哪几种序列化协议？包括使用场景和如何去选择&lt;/p&gt;
&lt;p&gt;6、Netty的零拷贝实现&lt;/p&gt;
&lt;p&gt;7、Netty的高性能表现在哪些方面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式相关&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、Dubbo的底层实现原理和机制&lt;/p&gt;
&lt;p&gt;2、描述一个服务从发布到被消费的详细过程&lt;/p&gt;
&lt;p&gt;3、分布式系统怎么做服务治理&lt;/p&gt;
&lt;p&gt;4、接口的幂等性的概念&lt;/p&gt;
&lt;p&gt;5、消息中间件如何解决消息丢失问题&lt;/p&gt;
&lt;p&gt;6、Dubbo的服务请求失败怎么处理&lt;/p&gt;
&lt;p&gt;7、重连机制会不会造成错误&lt;/p&gt;
&lt;p&gt;8、对分布式事务的理解&lt;/p&gt;
&lt;p&gt;9、如何实现负载均衡，有哪些算法可以实现？&lt;/p&gt;
&lt;p&gt;10、Zookeeper的用途，选举的原理是什么？&lt;/p&gt;
&lt;p&gt;11、数据的垂直拆分水平拆分。&lt;/p&gt;
&lt;p&gt;12、zookeeper原理和适用场景&lt;/p&gt;
&lt;p&gt;13、zookeeper watch机制&lt;/p&gt;
&lt;p&gt;14、redis/zk节点宕机如何处理&lt;/p&gt;
&lt;p&gt;15、分布式集群下如何做到唯一序列号&lt;/p&gt;
&lt;p&gt;16、如何做一个分布式锁&lt;/p&gt;
&lt;p&gt;17、用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗&lt;/p&gt;
&lt;p&gt;18、MQ系统的数据如何保证不丢失&lt;/p&gt;
&lt;p&gt;19、列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询的问题&lt;/p&gt;
&lt;p&gt;20、zookeeper的选举策略&lt;/p&gt;
&lt;p&gt;21、全局ID&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、mysql分页有什么优化&lt;/p&gt;
&lt;p&gt;2、悲观锁、乐观锁&lt;/p&gt;
&lt;p&gt;3、组合索引，最左原则&lt;/p&gt;
&lt;p&gt;4、mysql 的表锁、行锁&lt;/p&gt;
&lt;p&gt;5、mysql 性能优化&lt;/p&gt;
&lt;p&gt;6、mysql的索引分类：B+，hash；什么情况用什么索引&lt;/p&gt;
&lt;p&gt;7、事务的特性和隔离级别&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、Redis用过哪些数据数据，以及Redis底层怎么实现&lt;/p&gt;
&lt;p&gt;2、Redis缓存穿透，缓存雪崩&lt;/p&gt;
&lt;p&gt;3、如何使用Redis来实现分布式锁&lt;/p&gt;
&lt;p&gt;4、Redis的并发竞争问题如何解决&lt;/p&gt;
&lt;p&gt;5、Redis持久化的几种方式，优缺点是什么，怎么实现的&lt;/p&gt;
&lt;p&gt;6、Redis的缓存失效策略&lt;/p&gt;
&lt;p&gt;7、Redis集群，高可用，原理&lt;/p&gt;
&lt;p&gt;8、Redis缓存分片&lt;/p&gt;
&lt;p&gt;9、Redis的数据淘汰策略&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JVM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、详细jvm内存模型&lt;/p&gt;
&lt;p&gt;2、讲讲什么情况下回出现内存溢出，内存泄漏？&lt;/p&gt;
&lt;p&gt;3、说说Java线程栈&lt;/p&gt;
&lt;p&gt;4、JVM 年轻代到年老代的晋升过程的判断条件是什么呢？&lt;/p&gt;
&lt;p&gt;5、JVM 出现 fullGC 很频繁，怎么去线上排查问题？&lt;/p&gt;
&lt;p&gt;6、类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？&lt;/p&gt;
&lt;p&gt;7、类的实例化顺序&lt;/p&gt;
&lt;p&gt;8、JVM垃圾回收机制，何时触发MinorGC等操作&lt;/p&gt;
&lt;p&gt;9、JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的&lt;/p&gt;
&lt;p&gt;10、各种回收器，各自优缺点，重点CMS、G1&lt;/p&gt;
&lt;p&gt;11、各种回收算法&lt;/p&gt;
&lt;p&gt;12、OOM错误，stackoverflow错误，permgen space错误&lt;/p&gt;
</description>
<pubDate>Tue, 10 Apr 2018 07:11:00 +0000</pubDate>
<dc:creator>wz-speed</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wz-speed/p/8779257.html</dc:identifier>
</item>
<item>
<title>C#制作ActiveX插件 - 名称不可用</title>
<link>http://www.cnblogs.com/yangery/p/8779215.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangery/p/8779215.html</guid>
<description>&lt;ol&gt;&lt;li&gt;首先新建项目---&amp;gt;类库,取名:ActiveXDemo&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/188275/201804/188275-20180410143232424-2088951873.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;右键项目属性:应用属性==&amp;gt;程序集信息=&amp;gt;使程序集Com可见,&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/188275/201804/188275-20180410143352382-871961744.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;生成==&amp;gt;输出==&amp;gt;为com互操作注册&lt;/li&gt;
&lt;li&gt;新建接口类取名:IObjectSafety,以下代码可直接用,最好不要修改&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Runtime.InteropServices;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ActiveXDemo
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     [ComImport, Guid(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CB5BDC81-93C1-11CF-8F20-00805F2CD064&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IObjectSafety
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        [PreserveSig]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; GetInterfaceSafetyOptions(&lt;span&gt;ref&lt;/span&gt; Guid riid, [MarshalAs(UnmanagedType.U4)] &lt;span&gt;ref&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; pdwSupportedOptions, [MarshalAs(UnmanagedType.U4)] &lt;span&gt;ref&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pdwEnabledOptions);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        [PreserveSig()]
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; SetInterfaceSafetyOptions(&lt;span&gt;ref&lt;/span&gt; Guid riid, [MarshalAs(UnmanagedType.U4)] &lt;span&gt;int&lt;/span&gt; dwOptionSetMask, [MarshalAs(UnmanagedType.U4)] &lt;span&gt;int&lt;/span&gt;&lt;span&gt; dwEnabledOptions);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新建用户控件取名:UserControl1,UserControl1继承自上面新建的接口IObjectSafety,并实现接口(实现接口的方法请复制下面的内容),在类UserControl1添加Guid特性值,利用VS的工具生成guid&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/188275/201804/188275-20180410143825274-956927264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.ComponentModel;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Drawing;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Forms;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Runtime.InteropServices;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ActiveXDemo
{
    [Guid(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C5BD015D-E2AA-4DD3-AEB7-93D7409FA751&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserControl1 : UserControl, IObjectSafety
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserControl1()
        {
            InitializeComponent();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; button1_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ActiveXDemo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetGUID()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Guid.NewGuid().ToString();
        }


        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; IObjectSafety 接口成员实现（直接拷贝即可）

        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; _IID_IDispatch = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{00020400-0000-0000-C000-000000000046}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; _IID_IDispatchEx = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{a6ef9860-c720-11d0-9337-00a0c90dcaa9}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; _IID_IPersistStorage = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0000010A-0000-0000-C000-000000000046}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; _IID_IPersistStream = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{00000109-0000-0000-C000-000000000046}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; _IID_IPersistPropertyBag = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{37D84F60-42CB-11CE-8135-00AA004BB851}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INTERFACESAFE_FOR_UNTRUSTED_CALLER = &lt;span&gt;0x00000001&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INTERFACESAFE_FOR_UNTRUSTED_DATA = &lt;span&gt;0x00000002&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; S_OK = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; E_FAIL = &lt;span&gt;unchecked&lt;/span&gt;((&lt;span&gt;int&lt;/span&gt;)&lt;span&gt;0x80004005&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; E_NOINTERFACE = &lt;span&gt;unchecked&lt;/span&gt;((&lt;span&gt;int&lt;/span&gt;)&lt;span&gt;0x80004002&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; _fSafeForScripting = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; _fSafeForInitializing = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;


        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; GetInterfaceSafetyOptions(&lt;span&gt;ref&lt;/span&gt; Guid riid, [MarshalAs(UnmanagedType.U4)] &lt;span&gt;ref&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; pdwSupportedOptions, [MarshalAs(UnmanagedType.U4)] &lt;span&gt;ref&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pdwEnabledOptions)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Rslt =&lt;span&gt; E_FAIL;

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; strGUID = riid.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            pdwSupportedOptions &lt;/span&gt;= INTERFACESAFE_FOR_UNTRUSTED_CALLER |&lt;span&gt; INTERFACESAFE_FOR_UNTRUSTED_DATA;
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (strGUID)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; _IID_IDispatch:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; _IID_IDispatchEx:
                    Rslt &lt;/span&gt;=&lt;span&gt; S_OK;
                    pdwEnabledOptions &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_fSafeForScripting == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                        pdwEnabledOptions &lt;/span&gt;=&lt;span&gt; INTERFACESAFE_FOR_UNTRUSTED_CALLER;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; _IID_IPersistStorage:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; _IID_IPersistStream:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; _IID_IPersistPropertyBag:
                    Rslt &lt;/span&gt;=&lt;span&gt; S_OK;
                    pdwEnabledOptions &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_fSafeForInitializing == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                        pdwEnabledOptions &lt;/span&gt;=&lt;span&gt; INTERFACESAFE_FOR_UNTRUSTED_DATA;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    Rslt &lt;/span&gt;=&lt;span&gt; E_NOINTERFACE;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Rslt;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SetInterfaceSafetyOptions(&lt;span&gt;ref&lt;/span&gt; Guid riid, [MarshalAs(UnmanagedType.U4)] &lt;span&gt;int&lt;/span&gt; dwOptionSetMask, [MarshalAs(UnmanagedType.U4)] &lt;span&gt;int&lt;/span&gt;&lt;span&gt; dwEnabledOptions)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Rslt =&lt;span&gt; E_FAIL;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; strGUID = riid.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (strGUID)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; _IID_IDispatch:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; _IID_IDispatchEx:
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (((dwEnabledOptions &amp;amp; dwOptionSetMask) == INTERFACESAFE_FOR_UNTRUSTED_CALLER) &amp;amp;&amp;amp; (_fSafeForScripting == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;))
                        Rslt &lt;/span&gt;=&lt;span&gt; S_OK;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; _IID_IPersistStorage:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; _IID_IPersistStream:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; _IID_IPersistPropertyBag:
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (((dwEnabledOptions &amp;amp; dwOptionSetMask) == INTERFACESAFE_FOR_UNTRUSTED_DATA) &amp;amp;&amp;amp; (_fSafeForInitializing == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;))
                        Rslt &lt;/span&gt;=&lt;span&gt; S_OK;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    Rslt &lt;/span&gt;=&lt;span&gt; E_NOINTERFACE;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Rslt;
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;进行简单界面布局:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/188275/201804/188275-20180410144024793-733279478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击按钮效果见上面代码,还可自己写一个公共方法,我写的是GetGUID(),&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/188275/201804/188275-20180410144221673-1603934430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;生成成功将会生成两个文件:ActiveXDemo.dll和ActiveXDemo.tlb,至此ActiveX浏览器插件制作完成,&lt;/p&gt;
&lt;p&gt;以下是如何打包安装ActiveX插件,&lt;/p&gt;
&lt;p&gt;我用的InstallShield2010破解版制作安装包&lt;/p&gt;
&lt;p&gt;新建InstallScript Msi类型工程&lt;/p&gt;
&lt;p&gt;最主要的是在添加文件时候,要把ActiveXDemo.tlb这个文件设为自注册&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/188275/201804/188275-20180410145337818-356491424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在生成安装文件时候,可以选择生成适合网络形式的或者单个安装包,在这里我生成了单个安装包,你也可以选择生成网络的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/188275/201804/188275-20180410145721637-703630815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击生成安装包按钮,生成后如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/188275/201804/188275-20180410145841204-1622598565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至此,安装包制作完成,我们点击安装后他会自动注册tlb文件.&lt;/p&gt;
&lt;p&gt;以下是如何使用ActiveX插件:&lt;/p&gt;
&lt;p&gt;新建一个html页面:我取名:TestActiveX.html&lt;/p&gt;
&lt;p&gt;内容如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt; xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/xhtml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; GetGUID() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;           &lt;span&gt;var&lt;/span&gt;&lt;span&gt; a&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;  document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ActiveXDemo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).GetGUID();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            alert(a);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;object &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;ActiveXDemo&quot;&lt;/span&gt;&lt;span&gt; classid&lt;/span&gt;&lt;span&gt;='clsid:C5BD015D-E2AA-4DD3-AEB7-93D7409FA751' &lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;=&quot;350&quot;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;=&quot;350&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;Button1&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;获取guid&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;GetGUID()&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意这里的classid要和你的插件上生成的guid一致才可以&lt;br/&gt;查看页面效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/188275/201804/188275-20180410150353566-1596871993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/188275/201804/188275-20180410150403983-475503053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此,结束,关于用InstallShield制作安装包的详细过程,请自行学习.&lt;/p&gt;

</description>
<pubDate>Tue, 10 Apr 2018 07:08:00 +0000</pubDate>
<dc:creator>名称不可用</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangery/p/8779215.html</dc:identifier>
</item>
<item>
<title>CentOS 6.5 Tomcat安装及配置 - 厚积薄发2010</title>
<link>http://www.cnblogs.com/xiaohai2010/p/8778967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohai2010/p/8778967.html</guid>
<description>&lt;p&gt;1.安装jdk，配置jdk环境（此步骤略过）&lt;/p&gt;
&lt;p&gt;2.下载安装tomcat&lt;/p&gt;
&lt;p&gt;百度网盘链接: https://pan.baidu.com/s/1Ieejo7TQyzRAVPhQft8Phw 密码: dg2v&lt;/p&gt;
&lt;p&gt;下载之后对tomcat压缩包进行解压&lt;/p&gt;
&lt;p&gt;# tar xzf apache-tomcat-7.0.85.tar.gz&lt;/p&gt;
&lt;p&gt;将解压出来的文件夹移动到tomcat文件夹下&lt;br/&gt;# mv apache-tomcat-7.0.85 /usr/local/tomcat7&lt;/p&gt;
&lt;p&gt;3.启动tomcat&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1297590/201804/1297590-20180410133446474-2074803896.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动之后在浏览器上输入服务器ip:8080 即可访问&lt;/p&gt;
&lt;p&gt;4.设置tomcat为开机自动启动&lt;/p&gt;
&lt;p&gt;编辑脚本文件rc.local：vim /etc/rc.d/rc.local&lt;/p&gt;
&lt;p&gt;在末尾添加以下内容：&lt;/p&gt;
&lt;p&gt;export JAVA_HOME=/usr/local/java/jdk1.7.0_79&lt;/p&gt;
&lt;p&gt;/usr/local/tomcat7/apache-tomcat-7.0.85/bin/startup.sh&lt;/p&gt;
&lt;p&gt;esc 退出编辑，:wq 保存修改&lt;/p&gt;
&lt;p&gt;5.将rc.local修改为可执行&lt;/p&gt;
&lt;p&gt;chmod 777 /etc/rc.d/rc.local&lt;/p&gt;

</description>
<pubDate>Tue, 10 Apr 2018 06:47:00 +0000</pubDate>
<dc:creator>厚积薄发2010</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohai2010/p/8778967.html</dc:identifier>
</item>
<item>
<title>十个你需要在 PHP 7 中避免的坑 - Summer2018</title>
<link>http://www.cnblogs.com/summerblue/p/8778819.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/summerblue/p/8778819.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/162383/201804/162383-20180410143608036-1007673938.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;不要使用-mysql_-类函数&quot;&gt;1. 不要使用 mysql_ 类函数&lt;/h2&gt;
&lt;p&gt;终于，你不用再看到建议不要使用 &lt;code&gt;mysql_&lt;/code&gt; 函数的提示了。因为 PHP 7 从核心上完全移除了它们，这意味着请你移步至更好的 &lt;code&gt;mysqli_&lt;/code&gt; 类函数，或者更灵活的 PDO 层。&lt;/p&gt;
&lt;h2 id=&quot;不要写无用的代码&quot;&gt;2. 不要写无用的代码&lt;/h2&gt;
&lt;p&gt;这看上去是个无脑建议，但是随着 PHP7 速度的提升掩盖了一些问题使它显得日趋重要。不要仅仅因切到 PHP7 让网站速度变得快点，你就沾沾自喜了。&lt;/p&gt;
&lt;p&gt;想理解速度的重要性和如何做的更好，去看看我们这篇文章 &lt;a href=&quot;https://kinsta.com/learn/page-speed/&quot;&gt;初学者加速优化指南&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;作为开发者，应该确保按需加载脚本，可能时再组合，编写高效的数据库查询语句，如果可能的话 &lt;a href=&quot;https://kinsta.com/blog/wordpress-caching/&quot;&gt;使用缓存&lt;/a&gt; 等等。&lt;/p&gt;
&lt;h2 id=&quot;不要在文件末尾使用-php-闭合标签&quot;&gt;3. 不要在文件末尾使用 PHP 闭合标签&lt;/h2&gt;
&lt;p&gt;如果你随便看看，就会发现大部分 WordPress 核心代码文件结尾都省略了 PHP 闭合标签。事实上，Zend 框架尤为明显地 &lt;a href=&quot;http://framework.zend.com/manual/1.12/en/coding-standard.php-file-formatting.html&quot;&gt;禁止了闭合标签&lt;/a&gt;。它并非 PHP 所必须，在文件结尾处省略它，可确保结尾无额外空白。&lt;/p&gt;
&lt;h2 id=&quot;如非必须不要引用传参&quot;&gt;4. 如非必须不要引用传参&lt;/h2&gt;
&lt;p&gt;我个人非常不喜欢引用传参。我当然知道在某些场合下它很有用，但是多数场合下，它会使得代码难以理解，难以遵循，难以预测结果。&lt;/p&gt;
&lt;p&gt;人们认为引用可以使它们的代码更快，不过正如 &lt;a href=&quot;http://schlueters.de/blog/archives/125-Do-not-use-PHP-references.html&quot;&gt;可敬的 PHP 程序员&lt;/a&gt; 的这篇文章所指出的，事实并非如此。&lt;/p&gt;
&lt;p&gt;PHP 内置的 &lt;code&gt;shuffle()&lt;/code&gt; 或者 &lt;code&gt;sort()&lt;/code&gt; 函数，就是糟糕的引用传参案例。 它修改了原数组而不是返回一个打乱的或者排好序的数组，这是完全违背了我们意愿的。&lt;/p&gt;
&lt;h2 id=&quot;不要在循环里使用查询&quot;&gt;5. 不要在循环里使用查询&lt;/h2&gt;
&lt;p&gt;在循环中使用数据库查询时最糟糕的。他会给系统带来不必要的压力，并且很有可能，你可以在循环外使用查询而更快的得到相同的结果。当我碰到必须这样用的场景时，我通常会通过分成两个查询来构造一个数组的方式来解决。然后循环数组而无需循环查询。&lt;/p&gt;
&lt;p&gt;由于 WordPress 的运行方式，这样做可能会有些例外。 &lt;code&gt;get_post_meta()&lt;/code&gt; 将从数据库获取一个元数据，如果您正在循环访问特定文章的元数据，则可以在循环中使用它。这是因为当你第一次使用它的时候，WordPress 实际上取得了所有的元数据并缓存了起来。 之后的调用实际上是调用缓存数据而不是调用数据库。&lt;/p&gt;
&lt;p&gt;解决这些问题的最好办法是阅读函数文档并且使用一些类似 &lt;a href=&quot;https://kinsta.com/blog/query-monitor/&quot;&gt;查询监听器&lt;/a&gt; 的东西。&lt;/p&gt;
&lt;p&gt;6. 不要在 SQL 查询中使用 *&lt;br/&gt;-------------------------------&lt;/p&gt;
&lt;p&gt;好吧，这更像是一个 MySQL 的问题，但我们更倾向于在代码中编写 SQL 语句，所以我说这是个公平的游戏。不管什么情况下，如果你能避免使用通配符，那就不要使用，尤其是当你的数据库有很多字段的时候。&lt;/p&gt;
&lt;p&gt;明确指定你需要的字段，并且只检索这些字段。这有助于节省内存，保护数据，并且能让事情变得更加清晰明白。&lt;/p&gt;
&lt;p&gt;在 SQL 方面，尽可能的了解你可用的函数并测试速度。 当计算平均数，求和以及计算相似的数字的时候，使用 SQL 内置函数而不是 PHP 的函数。 如果你不确定一个查询的速度快慢，测试一下它并和其他做法进行比较，选出最好的那一种。&lt;/p&gt;
&lt;h2 id=&quot;不要信任用户的输入&quot;&gt;7. 不要信任用户的输入&lt;/h2&gt;
&lt;p&gt;信任用户输入并不明智。对于用户输入，总是需要过滤，杀毒，转义，校验以及使用回退。 用户输入存在三个问题：我们开发者不可能考虑到所有可能性，经常出错，存心的恶意输入。&lt;/p&gt;
&lt;p&gt;一个经过深思熟虑的系统可以防止所有的这些问题。 在使用数据库时，确保使用内置的函数，如 &lt;code&gt;filter_var()&lt;/code&gt;，来检查合法性，进行转义，和其他能做的事。&lt;/p&gt;
&lt;p&gt;WordPress 有一堆函数可以帮到你。可以瞧一瞧这篇文章来了解更多信息 &lt;a href=&quot;https://codex.wordpress.org/Validating_Sanitizing_and_Escaping_User_Data&quot;&gt;Validating, escaping and sanitising user data&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;不要自作聪明&quot;&gt;8. 不要自作聪明&lt;/h2&gt;
&lt;p&gt;你的目标就是写出能清晰的表达你的意愿的优雅代码。可能你通过缩短变量名，使用多层级三目逻辑运算和其他小聪明让每个页面节约了0.01秒的加载时间，但是和因此种下你和你的团队头疼不已难以维护的恶果相比，得不偿失。&lt;/p&gt;
&lt;p&gt;恰当的命名变量，以简洁明了的方式写出代码文档。更好的做法就是，使用标准化的面向对象的代码风格，或多或少的编写文档，而非使用大量的内联代码注释。&lt;/p&gt;
&lt;h2 id=&quot;不要重复造轮子&quot;&gt;9. 不要重复造轮子&lt;/h2&gt;
&lt;p&gt;PHP 已经存在有一段时间了，网站开发存在的时间甚至更久远。 无论你做过啥，前人肯定已经做过。不要害怕依赖别人的支持， &lt;a href=&quot;http://github.org/&quot;&gt;Github&lt;/a&gt;， &lt;a href=&quot;https://getcomposer.org/&quot;&gt;Composer&lt;/a&gt; ， &lt;a href=&quot;https://packagist.org/&quot;&gt;Packagist&lt;/a&gt; 都是你的良师益友。&lt;/p&gt;
&lt;p&gt;从日志到颜色处理器，从分析器到单元测试框架，从 Mailchimp APIs 到 Twitter Bootstrap，所有的东西只需要按一个按钮（或者敲一个命令）就能用，去使用它们吧！&lt;/p&gt;
&lt;h2 id=&quot;不要忽视其他语言&quot;&gt;10. 不要忽视其他语言&lt;/h2&gt;
&lt;p&gt;如果你是个 PHPer，现在的标准做法是至少了解 HTML，CSS，Javascript 和 MySQL。 当你能很好的处理这些语言的时候，就是再去学习一遍 Javascript 的时候。Javascript 不是 jQuery。你应该学习 Javascript 来有效的利用 jQuery。&lt;/p&gt;
&lt;p&gt;我也建议学习 PHP 面向对象的一切。它是个救星，能让你的代码在数量级上得到提升。它也能打开类似 C# 和 Java 语言的大门，在你有了这些经验后，它们能让你更容易明白面向对象编程（OOP）。&lt;/p&gt;
&lt;p&gt;通过学习包管理，构建脚本，Coffeescript， LESS， SASS， YAML， 模板引擎以及其他有用的工具来扩展知识面。我也由衷的推荐看看其他框架，尤其是 &lt;a href=&quot;http://laravel.com/&quot;&gt;Laravel&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;当你这些都做得够好了的时候，考虑下 Ruby， Ruby on Rails 以及 Android，iPhone，Windows Phone 的 app 开发？ 你可能认为这些毫无意义，因为它们不在你的舒适区和工作需求之内，但它们恰恰是重点。 每种语言都有一些有用的教学知识和一些无害的额外知识。所有顶尖的PHP开发人员都了解其他编程语言，这不是偶然的！&lt;/p&gt;
&lt;blockquote readability=&quot;3&quot;&gt;
&lt;p&gt;更多现代化 PHP 知识，请前往 &lt;a href=&quot;https://laravel-china.org/topics/9334&quot;&gt;Laravel / PHP 知识社区&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 10 Apr 2018 06:37:00 +0000</pubDate>
<dc:creator>Summer2018</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/summerblue/p/8778819.html</dc:identifier>
</item>
<item>
<title>归并排序和快速排序的衍生问题 - Lovebugs.cn</title>
<link>http://www.cnblogs.com/Lovebugs/p/8778671.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lovebugs/p/8778671.html</guid>
<description>&lt;p data-anchor-id=&quot;dauc&quot;&gt;前面两篇总结了常见的几种排序算法的主要思想以及C++与python两种方式的实现过程， 几种排序算法中比较重要的就是归并排序和快速排序，这两种方法的相同点就是都使用了分治的思想，现在用来解决两个具体问题。&lt;/p&gt;&lt;p data-anchor-id=&quot;f22r&quot;&gt;  分治法就是将原问题分割成同等结构的子问题，之后将子问题逐一解决后，原问题也就得到了解决。 需要注意的是归并排序和快速排序虽然都使用了分治的思想，但它们分别代表了分治算法的两类基本思想。对于归并排序而言，它对“分”这个过程没有做太多操作，只是简单的将数组分为两部分然后递归的进行归并排序，而归并排序的关键是这样分完之后如何将它们归并起来，即merge()操作。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;  而对于快速排序来说，则是废了很大功夫放在了如何“分”这个问题上，我们是选取了一个标定点，然后使用partition()这个子过程将这个标定点移到了合适的位置，当它移到了合适的位置之后才将整个数组分成了两部分，而这样分完之后，在“合”的时候就不用做过多的考虑了，只需要一步一步递归下去就好了。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;  下面解决两个直接从归并排序和快速排序中衍生出来的具体问题的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;70&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算逆序数对的结果以long long返回
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为对于一个大小为n的数组, 其最大的逆序数对个数为 n*(n-1)/2, 非常容易产生整型溢出
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; __merge函数求出在arr[l,mid]和arr[mid+1,r]有序的基础上, arr[l,r]的逆序数对个数&lt;/span&gt;
&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; __merge(&lt;span&gt;int&lt;/span&gt; arr[],&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt; mid,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; res = &lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化逆序数对个数 res = 0&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; aux[r - l + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = l;i &amp;lt;= r;i++&lt;span&gt;)
aux[i &lt;/span&gt;- l] =&lt;span&gt; arr[i];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; l;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = mid + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; k = l;k &amp;lt;= r;k++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i &amp;gt;&lt;span&gt; mid){
arr[k] &lt;/span&gt;= aux[j -&lt;span&gt; l];
j &lt;/span&gt;++&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(j &amp;gt;&lt;span&gt; r){
arr[k] &lt;/span&gt;= aux[i -&lt;span&gt; l];
i &lt;/span&gt;++&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(aux[i - l] &amp;lt; aux[j -&lt;span&gt; l]){
arr[k] &lt;/span&gt;= aux[i -&lt;span&gt; l];
i &lt;/span&gt;++&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;{&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左半部分所指元素 &amp;gt; 右半部分所指元素&lt;/span&gt;
arr[k] = aux[j -&lt;span&gt; l];
j &lt;/span&gt;++&lt;span&gt;;
res &lt;/span&gt;+= (&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;) (mid - i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时, 因为右半部分所指的元素小
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个元素和左半部分的所有未处理的元素都构成了逆序数对
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左半部分此时未处理的元素个数为 mid - j + 1&lt;/span&gt;
&lt;span&gt;}
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 求arr[l,r]范围的逆序数对个数&lt;/span&gt;
&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; __inversionCount(&lt;span&gt;int&lt;/span&gt; arr[],&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(l &amp;gt;=&lt;span&gt; r)
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mid = l + (r - l) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; res1 = __inversionCount(arr,l,mid);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 求出 arr[l,mid] 范围的逆序数&lt;/span&gt;
&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; res2 = __inversionCount(arr,mid + &lt;span&gt;1&lt;/span&gt;,r);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 求出 arr[mid+1,r] 范围的逆序数&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; res1 + res2 +&lt;span&gt; __merge(arr,l,mid,r);
}
&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; inversionCount(&lt;span&gt;int&lt;/span&gt; arr[],&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; __inversionCount(arr,&lt;span&gt;0&lt;/span&gt;,n - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a[&lt;span&gt;10&lt;/span&gt;] = {&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
cout&lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;逆序对数量为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; inversionCount(a,n)&amp;lt;&amp;lt;&lt;span&gt;endl;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;20&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__merge&lt;/span&gt;&lt;span&gt;(arr,l,mid,r):
res &lt;/span&gt;=&lt;span&gt; 0
aux &lt;/span&gt;=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(l,r + 1&lt;span&gt;):
aux.append(arr[x])
i &lt;/span&gt;=&lt;span&gt; l
j &lt;/span&gt;= mid + 1
&lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt; range(l,r + 1&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; i &amp;gt;&lt;span&gt; mid:
arr[k] &lt;/span&gt;= aux[j -&lt;span&gt; l]
j &lt;/span&gt;+= 1
&lt;span&gt;elif&lt;/span&gt; j &amp;gt;&lt;span&gt; r:
arr[k] &lt;/span&gt;= aux[i -&lt;span&gt; l]
i &lt;/span&gt;+= 1
&lt;span&gt;elif&lt;/span&gt; aux[i - l] &amp;lt; aux[j -&lt;span&gt; l]:
arr[k] &lt;/span&gt;= aux[i -&lt;span&gt; l]
i &lt;/span&gt;+= 1
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
arr[k] &lt;/span&gt;= aux[j -&lt;span&gt; l]
j &lt;/span&gt;+= 1&lt;span&gt;
res &lt;/span&gt;+= mid - i + 1
&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__inversionCount&lt;/span&gt;&lt;span&gt;(arr,l,r):
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; l &amp;gt;=&lt;span&gt; r:
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; 0
mid &lt;/span&gt;= l + (r - l) // 2&lt;span&gt;
res1 &lt;/span&gt;= &lt;span&gt;__inversionCount&lt;/span&gt;&lt;span&gt;(arr,l,mid)
res2 &lt;/span&gt;= &lt;span&gt;__inversionCount&lt;/span&gt;(arr,mid + 1&lt;span&gt;,r)
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; res1 + res2 + &lt;span&gt;__merge&lt;/span&gt;&lt;span&gt;(arr,l,mid,r)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; inversionCount(arr):
n &lt;/span&gt;=&lt;span&gt; len(arr)
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;__inversionCount&lt;/span&gt;(arr,0,n - 1&lt;span&gt;)
arr &lt;/span&gt;= [10,9,8,7,6,5,4,3,2,1&lt;span&gt;]
res &lt;/span&gt;=&lt;span&gt; inversionCount(arr)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;逆序对数量为：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str(res))
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;&lt;div readability=&quot;23.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstdlib&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;ctime&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; __partition(&lt;span&gt;int&lt;/span&gt; arr[],&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
swap(arr[l],arr[rand()&lt;/span&gt;%(r - l + &lt;span&gt;1&lt;/span&gt;) +&lt;span&gt; l]);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; v =&lt;span&gt; arr[l];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j =&lt;span&gt; l;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = l + &lt;span&gt;1&lt;/span&gt;;i &amp;lt;= r;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr[i] &amp;gt;&lt;span&gt; v){
swap(arr[i],arr[j &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
j &lt;/span&gt;++&lt;span&gt;;
}
}
swap(arr[l],arr[j]);
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; j;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; __selection(&lt;span&gt;int&lt;/span&gt; arr[],&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt; r,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k){
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(l ==&lt;span&gt; r)
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr[l];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; p =&lt;span&gt; __partition(arr,l,r);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(p ==&lt;span&gt; k)
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr[p];
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(p &amp;gt;&lt;span&gt; k)
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; __selection(arr,l,p - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,k);
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; __selection(arr,p + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,r,k);
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; selection(&lt;span&gt;int&lt;/span&gt; arr[],&lt;span&gt;int&lt;/span&gt; n,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k){
srand(time(NULL));
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; __selection(arr,&lt;span&gt;0&lt;/span&gt;,n - &lt;span&gt;1&lt;/span&gt;,k - &lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引是从0开始的&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; arr[&lt;span&gt;10&lt;/span&gt;] = {&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数组中第3大的元素为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;selection(arr,n,&lt;span&gt;3&lt;/span&gt;)&amp;lt;&amp;lt;&lt;span&gt;endl;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;&lt;div readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__partition&lt;/span&gt;&lt;span&gt;(arr,l,r):
k &lt;/span&gt;=&lt;span&gt; random.randint(l,r)
arr[l],arr[k] &lt;/span&gt;=&lt;span&gt; arr[k],arr[l]
v&lt;/span&gt;=&lt;span&gt; arr[l]
j &lt;/span&gt;=&lt;span&gt; l
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(l + 1,r + 1&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; arr[i] &amp;lt;&lt;span&gt; v:
arr[i],arr[j &lt;/span&gt;+ 1] = arr[j + 1&lt;span&gt;],arr[i]
j &lt;/span&gt;+= 1&lt;span&gt;
arr[l],arr[j] &lt;/span&gt;=&lt;span&gt; arr[j],arr[l]
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; j
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__selection&lt;/span&gt;&lt;span&gt;(arr,l,r,k):
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; l ==&lt;span&gt; r:
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr[l]
p &lt;/span&gt;= &lt;span&gt;__partition&lt;/span&gt;&lt;span&gt;(arr,l,r)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; p ==&lt;span&gt; k:
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr[p]
&lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; p &amp;gt;&lt;span&gt; k:
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;__selection&lt;/span&gt;(arr,l,p - 1&lt;span&gt;,k)
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;__selection&lt;/span&gt;(arr,p + 1&lt;span&gt;,r,k)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; selection(arr,k):
n &lt;/span&gt;=&lt;span&gt; len(arr)
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;__selection&lt;/span&gt;(arr,0,n - 1,k - 1&lt;span&gt;)
arr &lt;/span&gt;= [10,9,8,7,6,5,4,3,2,1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;数组中第2小的元素为&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+ str(selection(arr,2)))
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;本公众号致力于免费分享全网最优秀的视频资源，学习资料，面试经验等，前端，PHP，JAVA，算法，Python，大数据等等，你想要的这都有&lt;/strong&gt;&lt;/p&gt;</description>
<pubDate>Tue, 10 Apr 2018 06:22:00 +0000</pubDate>
<dc:creator>Lovebugs.cn</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Lovebugs/p/8778671.html</dc:identifier>
</item>
<item>
<title>XML之XPath - CN_ZhangTao</title>
<link>http://www.cnblogs.com/zhangtaotqy/p/8778444.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangtaotqy/p/8778444.html</guid>
<description>&lt;p&gt;1.在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档节点（或称为根节点）。&lt;/p&gt;
&lt;p&gt;1.1 &lt;/p&gt;
&lt;h2&gt;XPath 术语&lt;/h2&gt;
&lt;h3&gt;节点（Node）&lt;/h3&gt;
&lt;p&gt;在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点。XML 文档是被作为节点树来对待的。树的根被称为文档节点或者根节点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bookstore&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Harry Potter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;J K. Rowling&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2005&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;29.99&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bookstore&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的XML文档中的节点例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bookstore&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; （文档节点）
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;J K. Rowling&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; （元素节点）
lang=&quot;en&quot; （属性节点） &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;基本值（或称原子值，Atomic value）&lt;/h3&gt;
&lt;p&gt;基本值是无父或无子的节点。&lt;/p&gt;
&lt;p&gt;基本值的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;J K. Rowling
&quot;en&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;项目（Item）&lt;/h3&gt;
&lt;p&gt;项目是基本值或者节点。&lt;/p&gt;
&lt;h2&gt;节点关系&lt;/h2&gt;
&lt;h3&gt;父（Parent）&lt;/h3&gt;
&lt;p&gt;每个元素以及属性都有一个父。&lt;/p&gt;
&lt;p&gt;在下面的例子中，book 元素是 title、author、year 以及 price 元素的父：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Harry Potter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;J K. Rowling&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2005&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;29.99&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;子（Children）&lt;/h3&gt;
&lt;p&gt;元素节点可有零个、一个或多个子。&lt;/p&gt;
&lt;p&gt;在下面的例子中，title、author、year 以及 price 元素都是 book 元素的子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Harry Potter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;J K. Rowling&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2005&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;29.99&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;同胞（Sibling）&lt;/h3&gt;
&lt;p&gt;拥有相同的父的节点&lt;/p&gt;
&lt;p&gt;在下面的例子中，title、author、year 以及 price 元素都是同胞：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Harry Potter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;J K. Rowling&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2005&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;29.99&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;先辈（Ancestor）&lt;/h3&gt;
&lt;p&gt;某节点的父、父的父，等等。&lt;/p&gt;
&lt;p&gt;在下面的例子中，title 元素的先辈是 book 元素和 bookstore 元素：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bookstore&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Harry Potter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;J K. Rowling&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2005&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;29.99&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bookstore&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;后代（Descendant）&lt;/h3&gt;
&lt;p&gt;某个节点的子，子的子，等等。&lt;/p&gt;
&lt;p&gt;在下面的例子中，bookstore 的后代是 book、title、author、year 以及 price 元素：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bookstore&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Harry Potter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;J K. Rowling&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2005&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;29.99&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bookstore&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. XPath 使用路径表达式来选取 XML 文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的。&lt;/p&gt;
&lt;h2&gt;XML 实例文档&lt;/h2&gt;
&lt;p&gt;我们将在下面的例子中使用这个 XML 文档。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;booksto.....................................................re&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;eng&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Harry Potter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;29.99&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;eng&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Learning XML&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;39.95&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bookstore&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;选取节点&lt;/h2&gt;
&lt;p&gt;XPath 使用路径表达式在 XML 文档中选取节点。节点是通过沿着路径或者 step 来选取的。&lt;/p&gt;
&lt;h3&gt;下面列出了最有用的路径表达式：&lt;/h3&gt;
&lt;table class=&quot;dataintable&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;nodename&lt;/td&gt;
&lt;td&gt;选取此节点的所有子节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;从根节点选取。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;//&lt;/td&gt;
&lt;td&gt;从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;选取当前节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;..&lt;/td&gt;
&lt;td&gt;选取当前节点的父节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@&lt;/td&gt;
&lt;td&gt;选取属性。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;实例&lt;/h3&gt;
&lt;p&gt;在下面的表格中，我们已列出了一些路径表达式以及表达式的结果：&lt;/p&gt;
&lt;table class=&quot;dataintable&quot;&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr&gt;&lt;th&gt;路径表达式&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;bookstore&lt;/td&gt;
&lt;td&gt;选取 bookstore 元素的所有子节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5.5&quot;&gt;&lt;td&gt;/bookstore&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;选取根元素 bookstore。&lt;/p&gt;
&lt;p&gt;注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;bookstore/book&lt;/td&gt;
&lt;td&gt;选取属于 bookstore 的子元素的所有 book 元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;//book&lt;/td&gt;
&lt;td&gt;选取所有 book 子元素，而不管它们在文档中的位置。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;bookstore//book&lt;/td&gt;
&lt;td&gt;选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;//@lang&lt;/td&gt;
&lt;td&gt;选取名为 lang 的所有属性。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;谓语（Predicates）&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;&lt;br/&gt;谓语用来查找某个特定的节点或者包含某个指定的值的节点。&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;谓语被嵌在方括号中。&lt;/p&gt;
&lt;h3&gt;实例&lt;/h3&gt;
&lt;p&gt;在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：&lt;/p&gt;
&lt;table class=&quot;dataintable&quot;&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr&gt;&lt;th&gt;路径表达式&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;/bookstore/book[1]&lt;/td&gt;
&lt;td&gt;选取属于 bookstore 子元素的第一个 book 元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;/bookstore/book[last()]&lt;/td&gt;
&lt;td&gt;选取属于 bookstore 子元素的最后一个 book 元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;/bookstore/book[last()-1]&lt;/td&gt;
&lt;td&gt;选取属于 bookstore 子元素的倒数第二个 book 元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;/bookstore/book[position()&amp;lt;3]&lt;/td&gt;
&lt;td&gt;选取最前面的两个属于 bookstore 元素的子元素的 book 元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;//title[@lang]&lt;/td&gt;
&lt;td&gt;选取所有拥有名为 lang 的属性的 title 元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;//title[@lang='eng']&lt;/td&gt;
&lt;td&gt;选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;/bookstore/book[price&amp;gt;35.00]&lt;/td&gt;
&lt;td&gt;选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;/bookstore/book[price&amp;gt;35.00]/title&lt;/td&gt;
&lt;td&gt;选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;选取未知节点&lt;/h2&gt;
&lt;p&gt;XPath 通配符可用来选取未知的 XML 元素。&lt;/p&gt;
&lt;table class=&quot;dataintable&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;th&gt;通配符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;匹配任何元素节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@*&lt;/td&gt;
&lt;td&gt;匹配任何属性节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;node()&lt;/td&gt;
&lt;td&gt;匹配任何类型的节点。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;实例&lt;/h3&gt;
&lt;p&gt;在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：&lt;/p&gt;
&lt;table class=&quot;dataintable&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;th&gt;路径表达式&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;/bookstore/*&lt;/td&gt;
&lt;td&gt;选取 bookstore 元素的所有子元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;//*&lt;/td&gt;
&lt;td&gt;选取文档中的所有元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;//title[@*]&lt;/td&gt;
&lt;td&gt;选取所有带有属性的 title 元素。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;选取若干路径&lt;/h2&gt;
&lt;p&gt;通过在路径表达式中使用“|”运算符，您可以选取若干个路径。&lt;/p&gt;
&lt;h3&gt;实例&lt;/h3&gt;
&lt;p&gt;在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：&lt;/p&gt;
&lt;table class=&quot;dataintable&quot;&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr&gt;&lt;th&gt;路径表达式&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;//book/title | //book/price&lt;/td&gt;
&lt;td&gt;选取 book 元素的所有 title 和 price 元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;//title | //price&lt;/td&gt;
&lt;td&gt;选取文档中的所有 title 和 price 元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;/bookstore/book/title | //price&lt;/td&gt;
&lt;td&gt;选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;XML 实例文档&lt;/h2&gt;
&lt;p&gt;我们将在下面的例子中使用此 XML 文档：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bookstore&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;eng&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Harry Potter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;29.99&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;eng&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Learning XML&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;39.95&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bookstore&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;XPath 轴&lt;/h2&gt;
&lt;p&gt;轴可定义相对于当前节点的节点集。&lt;/p&gt;
&lt;table class=&quot;dataintable&quot;&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr&gt;&lt;th&gt;轴名称&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ancestor&lt;/td&gt;
&lt;td&gt;选取当前节点的所有先辈（父、祖父等）。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ancestor-or-self&lt;/td&gt;
&lt;td&gt;选取当前节点的所有先辈（父、祖父等）以及当前节点本身。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;attribute&lt;/td&gt;
&lt;td&gt;选取当前节点的所有属性。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;child&lt;/td&gt;
&lt;td&gt;选取当前节点的所有子元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;descendant&lt;/td&gt;
&lt;td&gt;选取当前节点的所有后代元素（子、孙等）。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;descendant-or-self&lt;/td&gt;
&lt;td&gt;选取当前节点的所有后代元素（子、孙等）以及当前节点本身。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;following&lt;/td&gt;
&lt;td&gt;选取文档中当前节点的结束标签之后的所有节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;namespace&lt;/td&gt;
&lt;td&gt;选取当前节点的所有命名空间节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;parent&lt;/td&gt;
&lt;td&gt;选取当前节点的父节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;preceding&lt;/td&gt;
&lt;td&gt;选取文档中当前节点的开始标签之前的所有节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;preceding-sibling&lt;/td&gt;
&lt;td&gt;选取当前节点之前的所有同级节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;self&lt;/td&gt;
&lt;td&gt;选取当前节点。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;位置路径表达式&lt;/h2&gt;
&lt;p&gt;位置路径可以是绝对的，也可以是相对的。&lt;/p&gt;
&lt;p&gt;绝对路径起始于正斜杠( / )，而相对路径不会这样。在两种情况中，位置路径均包括一个或多个步，每个步均被斜杠分割：&lt;/p&gt;
&lt;h3&gt;绝对位置路径：&lt;/h3&gt;
&lt;pre&gt;
/step/step/...
&lt;/pre&gt;
&lt;h3&gt;相对位置路径：&lt;/h3&gt;
&lt;pre&gt;
step/step/...
&lt;/pre&gt;
&lt;h3&gt;步的语法：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
轴名称::节点测试[谓语]
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;实例&lt;/h3&gt;
&lt;table class=&quot;dataintable&quot;&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr&gt;&lt;th&gt;例子&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;child::book&lt;/td&gt;
&lt;td&gt;选取所有属于当前节点的子元素的 book 节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;attribute::lang&lt;/td&gt;
&lt;td&gt;选取当前节点的 lang 属性。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;child::*&lt;/td&gt;
&lt;td&gt;选取当前节点的所有子元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;attribute::*&lt;/td&gt;
&lt;td&gt;选取当前节点的所有属性。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;child::text()&lt;/td&gt;
&lt;td&gt;选取当前节点的所有文本子节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;child::node()&lt;/td&gt;
&lt;td&gt;选取当前节点的所有子节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;descendant::book&lt;/td&gt;
&lt;td&gt;选取当前节点的所有 book 后代。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ancestor::book&lt;/td&gt;
&lt;td&gt;选择当前节点的所有 book 先辈。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ancestor-or-self::book&lt;/td&gt;
&lt;td&gt;选取当前节点的所有 book 先辈以及当前节点（如果此节点是 book 节点）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;child::*/child::price&lt;/td&gt;
&lt;td&gt;选取当前节点的所有 price 孙节点。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;XPath 运算符&lt;/h2&gt;
&lt;p&gt;下面列出了可用在 XPath 表达式中的运算符：&lt;/p&gt;
&lt;table class=&quot;dataintable&quot;&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr&gt;&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;返回值&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;计算两个节点集&lt;/td&gt;
&lt;td&gt;//book | //cd&lt;/td&gt;
&lt;td&gt;返回所有拥有 book 和 cd 元素的节点集&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;加法&lt;/td&gt;
&lt;td&gt;6 + 4&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;减法&lt;/td&gt;
&lt;td&gt;6 - 4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;乘法&lt;/td&gt;
&lt;td&gt;6 * 4&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;div&lt;/td&gt;
&lt;td&gt;除法&lt;/td&gt;
&lt;td&gt;8 div 4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;等于&lt;/td&gt;
&lt;td&gt;price=9.80&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;如果 price 是 9.80，则返回 true。&lt;/p&gt;
&lt;p&gt;如果 price 是 9.90，则返回 false。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;不等于&lt;/td&gt;
&lt;td&gt;price!=9.80&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;如果 price 是 9.90，则返回 true。&lt;/p&gt;
&lt;p&gt;如果 price 是 9.80，则返回 false。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;小于&lt;/td&gt;
&lt;td&gt;price&amp;lt;9.80&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;如果 price 是 9.00，则返回 true。&lt;/p&gt;
&lt;p&gt;如果 price 是 9.90，则返回 false。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&amp;lt;=&lt;/td&gt;
&lt;td&gt;小于或等于&lt;/td&gt;
&lt;td&gt;price&amp;lt;=9.80&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;如果 price 是 9.00，则返回 true。&lt;/p&gt;
&lt;p&gt;如果 price 是 9.90，则返回 false。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;大于&lt;/td&gt;
&lt;td&gt;price&amp;gt;9.80&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;如果 price 是 9.90，则返回 true。&lt;/p&gt;
&lt;p&gt;如果 price 是 9.80，则返回 false。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&amp;gt;=&lt;/td&gt;
&lt;td&gt;大于或等于&lt;/td&gt;
&lt;td&gt;price&amp;gt;=9.80&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;如果 price 是 9.90，则返回 true。&lt;/p&gt;
&lt;p&gt;如果 price 是 9.70，则返回 false。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;or&lt;/td&gt;
&lt;td&gt;或&lt;/td&gt;
&lt;td&gt;price=9.80 or price=9.70&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;如果 price 是 9.80，则返回 true。&lt;/p&gt;
&lt;p&gt;如果 price 是 9.50，则返回 false。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;and&lt;/td&gt;
&lt;td&gt;与&lt;/td&gt;
&lt;td&gt;price&amp;gt;9.00 and price&amp;lt;9.90&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;如果 price 是 9.80，则返回 true。&lt;/p&gt;
&lt;p&gt;如果 price 是 8.50，则返回 false。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mod&lt;/td&gt;
&lt;td&gt;计算除法的余数&lt;/td&gt;
&lt;td&gt;5 mod 2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;XML实例文档&lt;/h2&gt;
&lt;p&gt;我们将在下面的例子中使用这个 XML 文档：&lt;/p&gt;
&lt;h3&gt;&quot;books.xml&quot; :&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bookstore&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;book &lt;/span&gt;&lt;span&gt;category&lt;/span&gt;&lt;span&gt;=&quot;COOKING&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Everyday Italian&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Giada De Laurentiis&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2005&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30.00&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;book &lt;/span&gt;&lt;span&gt;category&lt;/span&gt;&lt;span&gt;=&quot;CHILDREN&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Harry Potter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;J K. Rowling&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2005&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;29.99&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;book &lt;/span&gt;&lt;span&gt;category&lt;/span&gt;&lt;span&gt;=&quot;WEB&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;XQuery Kick Start&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;James McGovern&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Per Bothner&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Kurt Cagle&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;James Linn&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Vaidyanathan Nagarajan&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2003&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;49.99&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;book &lt;/span&gt;&lt;span&gt;category&lt;/span&gt;&lt;span&gt;=&quot;WEB&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Learning XML&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Erik T. Ray&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2003&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;39.95&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bookstore&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;加载 XML 文档&lt;/h2&gt;
&lt;p&gt;所有现代浏览器都支持使用 XMLHttpRequest 来加载 XML 文档的方法。&lt;/p&gt;
&lt;p&gt;针对大多数现代浏览器的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
var xmlhttp=new XMLHttpRequest()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;针对古老的微软浏览器（IE 5 和 6）的代码：&lt;/p&gt;
&lt;pre&gt;
var xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)
&lt;/pre&gt;
&lt;h2&gt;选取节点&lt;/h2&gt;
&lt;p&gt;不幸的是，Internet Explorer 和其他处理 XPath 的方式不同。&lt;/p&gt;
&lt;p&gt;在我们的例子中，包含适用于大多数主流浏览器的代码。&lt;/p&gt;
&lt;p&gt;Internet Explorer 使用 selectNodes() 方法从 XML 文档中的选取节点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
xmlDoc.selectNodes(xpath);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Firefox、Chrome、Opera 以及 Safari 使用 evaluate() 方法从 XML 文档中选取节点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
xmlDoc.evaluate(xpath, xmlDoc, null, XPathResult.ANY_TYPE,null);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;选取所有 title&lt;/h2&gt;
&lt;p&gt;下面的例子选取所有 title 节点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
/bookstore/book/title
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;选取第一个 book 的 title&lt;/h2&gt;
&lt;p&gt;下面的例子选取 bookstore 元素下面的第一个 book 节点的 title：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
/bookstore/book[1]/title
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有一个问题。上面的例子在 IE 和其他浏览器中输出不同的结果。&lt;/p&gt;
&lt;p&gt;IE5 以及更高版本将 [0] 视为第一个节点，而根据 W3C 的标准，应该是 [1]。&lt;/p&gt;
&lt;p&gt;为了解决 IE5+ 中 [0] 和 [1] 的问题，可以为 XPath 设置语言选择（SelectionLanguage）。&lt;/p&gt;
&lt;p&gt;下面的例子选取 bookstore 元素下面的第一个 book 节点的 title：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;xml.setProperty(&quot;SelectionLanguage&quot;,&quot;XPath&quot;);
xml.selectNodes(&quot;/bookstore/book[1]/title&quot;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;选取所有价格&lt;/h2&gt;
&lt;p&gt;下面的例子选取 price 节点中的所有文本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/bookstore/book/price/text()
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;选取价格高于 35 的 price 节点&lt;/h2&gt;
&lt;p&gt;下面的例子选取价格高于 35 的所有 price 节点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/bookstore/book[price&amp;gt;35]/price
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;选取价格高于 35 的 title 节点&lt;/h2&gt;
&lt;p&gt;下面的例子选取价格高于 35 的所有 title 节点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/bookstore/book[price&amp;gt;35]/title
&lt;/pre&gt;&lt;/div&gt;


&lt;pre&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 10 Apr 2018 05:55:00 +0000</pubDate>
<dc:creator>CN_ZhangTao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangtaotqy/p/8778444.html</dc:identifier>
</item>
<item>
<title>Oracle复合B*tree索引branch block内是否包含非先导列键值？ - lhdz_bj</title>
<link>http://www.cnblogs.com/lhdz_bj/p/8778377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lhdz_bj/p/8778377.html</guid>
<description>&lt;p&gt;好久不碰数据库底层细节的东西，前几天，一个小家伙跑来找我，非要说复合b*tree index branch block中只包含先导列键值信息，并不包含非先导列键值信息，而且还dump了branch block，用以证明他的说法，从常理和SQL的语句执行信息就可以知道，他的说法是有问题的，但如何证明这一点呢？为了证明这点，也麻烦一次，玩玩多年不碰的dump。下面是他证明自己观点的两个dump结果（一个为单键索引，另一个是复合索引）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20140718123312899?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHVuaW5nX29wdG1pemF0aW9u/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20140718123103046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHVuaW5nX29wdG1pemF0aW9u/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是本人的测试过程和结果：&lt;/p&gt;
&lt;p&gt;create table t1(c1 int,c2 int,c3 int,c4 char(2000),c5 char(2000));&lt;/p&gt;&lt;p&gt;create index t1_idx1 on t1(c1,c2,c3,c4,c5);&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;for i in 1..1000 loop&lt;br/&gt;insert into t1 values(0,0,i,'aa','aa');&lt;br/&gt;end loop;&lt;br/&gt;end;&lt;br/&gt;/&lt;/p&gt;&lt;p&gt;begin&lt;br/&gt;for i in 1001..2000 loop&lt;br/&gt;insert into t1 values(0,i,i,'bb','bb');&lt;br/&gt;end loop;&lt;br/&gt;end;&lt;br/&gt;/&lt;/p&gt;&lt;p&gt;select segment_name,file_id,block_id &lt;br/&gt;  from dba_extents &lt;br/&gt; where segment_name='T1_IDX1'&lt;br/&gt;   and extent_id=0;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;alter system dump datafile 4 block 195;&lt;/p&gt;
&lt;p&gt;trc文件内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20140718123128515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHVuaW5nX29wdG1pemF0aW9u/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此可见，复合b*tree index branch block中，有时不包含非先导列键值，但有时包含。那么，什么情况下包含，什么情况下不包含呢？实验结果为，当先导列键值的选择性足够好时，就无需包含非先导列的键值，不然，也是浪费branck block宝贵的空间；只有当先导列的键值选择性不足够好，必须结合非先导列的键值才能定位到下一级block时，才需要包含非先导列的键值，该测试过程此处略去，感兴趣的同学可以按照这个思路自己测试。&lt;/p&gt;

</description>
<pubDate>Tue, 10 Apr 2018 05:43:00 +0000</pubDate>
<dc:creator>lhdz_bj</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lhdz_bj/p/8778377.html</dc:identifier>
</item>
</channel>
</rss>