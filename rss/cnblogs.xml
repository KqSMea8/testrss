<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【polly】微服务故障处理库 - 深井田蛙</title>
<link>http://www.cnblogs.com/yanbigfeg/p/9203669.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanbigfeg/p/9203669.html</guid>
<description>&lt;h2&gt;熔断、降级：&lt;/h2&gt;
&lt;p&gt;熔断：熔断就是我们常说的“&lt;strong&gt;保险丝&lt;/strong&gt;”，意为当服务出现某些状况时，切断服务，从而防止应用程序不断地常识执行可能会失败的操作造成系统的“雪崩”，或者大量的超时等待导致系统卡死等情况，很多地方也将其成为“过载保护”。&lt;/p&gt;
&lt;p&gt;降级：降级的目的就是当某个服务提供者发生故障的时候，向调用方返回一个替代响应或者错误响应。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;介绍：&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;POLLY是一个.NET回弹和瞬态故障处理库，它允许开发人员以流畅和线程安全的方式表达诸如重试、断路器、超时、隔板隔离和回退等策略。github官方解释嘿嘿。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Polly以.NET Standard 1.1（&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/net-standard#net-implementation-support&quot; rel=&quot;nofollow&quot;&gt;&lt;span&gt;&lt;span&gt;覆盖范围&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;：.NET Framework 4.5-4.6.1，.NET Core 1.0，Mono，Xamarin，UWP，WP8.1 +）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;            .NET Standard 2.0+（&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/net-standard#net-implementation-support&quot; rel=&quot;nofollow&quot;&gt;&lt;span&gt;&lt;span&gt;覆盖范围&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;：.NET Framework 4.6.1， .NET Core 2.0+以及后来的Mono，Xamarin和UWP目标）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;安装：&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;首先当然是创建一个控制台项目，然后通过NuGet安装:&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package Polly&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/809005/201806/809005-20180620142327831-193765099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现以上界面就说明你已经安装了最新的版本到你的项目；&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;策略介绍：&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;polly通过官方介绍我们可以知道有7种恢复策略，先不管会不会，先列出来再说哈哈：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    重试策略（Retry）：许多故障是短暂的，并且在短暂的延迟后可能会自我纠正。允许我们做的是能够自动配置重试机制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    断路器（Circuit-breaker）：当一个系统严重挣扎时，快速失败优于让用户/呼叫者等待。&lt;span class=&quot;Apple-converted-space&quot;&gt; 说白了就是应该优先直接返回失败，而不是一直让用户等待。保护故障系统免受过载可以帮助恢复。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;/span&gt;超时（Timeout）：超时策略针对的前置条件是超过一定的等待时间，想要得到成功的结果是不可能的，保证调用者不必等待超时。&lt;/p&gt;

&lt;p&gt;    隔板隔离（Bulkhead Isolation）：隔板隔离针对的前置条件是当进程出现故障时，多个失败一直在主机中对资源（例如线程/ CPU）一直占用。下游系统故障也可能导致上游失败。这两个风险都将造成严重的后果。都说一粒老鼠子屎搅浑一锅粥，而Polly则将受管制的操作限制在固定的资源池中，免其他资源受其影响。&lt;/p&gt;

&lt;p&gt;    缓存（Cache）：就是一些请求，会把数据缓存起来，然后在持续一段时间内，直接从缓存中取。&lt;/p&gt;

&lt;p&gt;    回退（Fallback）：操作仍然会失败，也就是说当发生这样的事情时我们打算做什么。也就是说定义失败返回操作。我们在使用时就是所说的降级。&lt;/p&gt;

&lt;p&gt;    策略包装（PolicyWrap）：&lt;span&gt;不同的故障需要不同的策略&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;弹性意味着使用组合。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;使用步骤：&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;polly一般分为三步进行：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义条件：&lt;/span&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;pure-highlightjs hljs dts&quot;&gt;
&lt;span&gt;.Handle&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;ExceptionType&lt;/span&gt;&amp;gt;（）：&lt;/span&gt;
&lt;/pre&gt;
&lt;pre name=&quot;code&quot; class=&quot;pure-highlightjs hljs dts&quot;&gt;
&lt;span&gt;.Handle&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;ExceptionType&amp;gt;（&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;ex &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt; &lt;span class=&quot;pl-smi&quot;&gt;ex.&lt;span class=&quot;pl-smi&quot;&gt;Number &lt;span class=&quot;pl-k&quot;&gt;== 10&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;）：具有条件的单个异常类型。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Handle&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;HttpRequestException&amp;gt;()
.&lt;span class=&quot;pl-en&quot;&gt;Or&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;OperationCanceledException&amp;gt;():多个异常类型，当然他也可以变成具有条件的多个异常类型，类似于单个操作。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;&lt;span&gt;定义返回结果的条件：&lt;/span&gt;&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;pure-highlightjs hljs dts&quot;&gt;
&lt;span&gt;.HandleResult&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;HttpResponseMessage&lt;/span&gt;&amp;gt;(&lt;span class=&quot;pl-smi&quot;&gt;r &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt; &lt;span class=&quot;pl-smi&quot;&gt;r.&lt;span class=&quot;pl-smi&quot;&gt;StatusCode &lt;span class=&quot;pl-k&quot;&gt;== &lt;span class=&quot;pl-smi&quot;&gt;HttpStatusCode.&lt;span class=&quot;pl-smi&quot;&gt;NotFound)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;:用条件处理返回值，处理单个返回值。&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;.&lt;span class=&quot;pl-en&quot;&gt;HandleResult&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;HttpResponseMessage&amp;gt;(&lt;span class=&quot;pl-smi&quot;&gt;r &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt; &lt;span class=&quot;pl-smi&quot;&gt;r.&lt;span class=&quot;pl-smi&quot;&gt;StatusCode &lt;span class=&quot;pl-k&quot;&gt;== &lt;span class=&quot;pl-smi&quot;&gt;HttpStatusCode.&lt;span class=&quot;pl-smi&quot;&gt;InternalServerError)
.&lt;span class=&quot;pl-en&quot;&gt;OrResult&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;HttpResponseMessage&amp;gt;(&lt;span class=&quot;pl-smi&quot;&gt;r &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt; &lt;span class=&quot;pl-smi&quot;&gt;r.&lt;span class=&quot;pl-smi&quot;&gt;StatusCode &lt;span class=&quot;pl-k&quot;&gt;== &lt;span class=&quot;pl-smi&quot;&gt;HttpStatusCode.&lt;span class=&quot;pl-smi&quot;&gt;BadGateway)：处理多个返回值。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre name=&quot;code&quot; class=&quot;pure-highlightjs hljs dts&quot;&gt;
&lt;/pre&gt;
&lt;p&gt; 指定策略（重试）：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Retry()：重试一次。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Retry(3)：重试三次，修改数值即可定义自己想使用的次数。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Retry(&lt;span class=&quot;pl-c1&quot;&gt;3, (&lt;span class=&quot;pl-smi&quot;&gt;exception, &lt;span class=&quot;pl-smi&quot;&gt;retryCount) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;
    {
        &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;// do something 
    })：重试多次，在每次重试都执行一个操作，参数为：当前异常和重试计数。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Retry(&lt;span class=&quot;pl-c1&quot;&gt;3, (&lt;span class=&quot;pl-smi&quot;&gt;exception, &lt;span class=&quot;pl-smi&quot;&gt;retryCount, &lt;span class=&quot;pl-smi&quot;&gt;context) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;
    {
        &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;// do something 
    })：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;重试多次，在每次重试都执行一个操作，参数为：当前异常，重试计数和上下文&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;.&lt;span class=&quot;pl-en&quot;&gt;RetryForever()：永远重试直到成功，同时也也有重试的相同扩展，可以写参数。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;.&lt;span class=&quot;pl-en&quot;&gt;WaitAndRetry(&lt;span class=&quot;pl-k&quot;&gt;new[]
  {
    &lt;span class=&quot;pl-smi&quot;&gt;TimeSpan.&lt;span class=&quot;pl-en&quot;&gt;FromSeconds(&lt;span class=&quot;pl-c1&quot;&gt;1),
    &lt;span class=&quot;pl-smi&quot;&gt;TimeSpan.&lt;span class=&quot;pl-en&quot;&gt;FromSeconds(&lt;span class=&quot;pl-c1&quot;&gt;2),
    &lt;span class=&quot;pl-smi&quot;&gt;TimeSpan.&lt;span class=&quot;pl-en&quot;&gt;FromSeconds(&lt;span class=&quot;pl-c1&quot;&gt;3)
  })：等待并重试，就是在每个重试的时候需要等待指定的执行时间，同样有相同扩展，可以在每个重试调用一个操作。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;.&lt;span class=&quot;pl-en&quot;&gt;WaitAndRetryForever(&lt;span class=&quot;pl-smi&quot;&gt;retryAttempt &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt; 
        &lt;span class=&quot;pl-smi&quot;&gt;TimeSpan.&lt;span class=&quot;pl-en&quot;&gt;FromSeconds(&lt;span class=&quot;pl-smi&quot;&gt;Math.&lt;span class=&quot;pl-en&quot;&gt;Pow(&lt;span class=&quot;pl-c1&quot;&gt;2, &lt;span class=&quot;pl-smi&quot;&gt;retryAttempt))
    )：等待和重试永远（直到成功）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;  指定策略（熔断）：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;&lt;span&gt;CircuitBreaker(&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;&lt;span&gt;2, &lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;&lt;span&gt;TimeSpan.&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;&lt;span&gt;FromMinutes(&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;&lt;span&gt;1))：在指定数量的连续异常之后中断开。这里就不做过多解释了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt; 指定策略（降级）：回退&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Fallback&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;UserAvatar&amp;gt;(&lt;span class=&quot;pl-smi&quot;&gt;UserAvatar.&lt;span class=&quot;pl-smi&quot;&gt;Blank)：如果执行错误，则提供替代值，就是出现错误，定义一个返回值给他&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Fallback&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;UserAvatar&amp;gt;(() &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt; &lt;span class=&quot;pl-smi&quot;&gt;UserAvatar.&lt;span class=&quot;pl-en&quot;&gt;GetRandomAvatar()) :定义一个方法给他，该方法代替提供值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;执行： &lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&lt;span class=&quot;pl-en&quot;&gt;Execute&lt;/span&gt;(() &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt; &lt;span class=&quot;pl-en&quot;&gt;DoSomething())&lt;/span&gt;&lt;/span&gt;：执行一项方法&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;执行通过任意上下文数据的操作：&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; policy =&lt;span&gt; Policy
    .Handle&lt;/span&gt;&amp;lt;SomeExceptionType&amp;gt;&lt;span&gt;()
    .Retry(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, (exception, retryCount, context) =&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; methodThatRaisedException = context[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;methodName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
        Log(exception, methodThatRaisedException);
    });

policy.Execute(
    () &lt;/span&gt;=&amp;gt;&lt;span&gt; DoSomething(),
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;() {{ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;methodName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;some method&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }}
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt; 使用示例：&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;降级的使用代码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7a4ec0b7-1508-481a-b49a-789b9904c77c')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_7a4ec0b7-1508-481a-b49a-789b9904c77c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7a4ec0b7-1508-481a-b49a-789b9904c77c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7a4ec0b7-1508-481a-b49a-789b9904c77c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7a4ec0b7-1508-481a-b49a-789b9904c77c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;#region&lt;/span&gt; 降级
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Downgrade()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;降级处理程序&lt;/span&gt;
            ISyncPolicy policy = Policy.Handle&amp;lt;ArgumentException&amp;gt;&lt;span&gt;()
            .Fallback(() &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;降级给的返回值结果&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;运行程序&lt;/span&gt;
            policy.Execute(() =&amp;gt;&lt;span&gt;
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务开始&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;降级任务出错，马上要降级了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务结束&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;



&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/809005/201806/809005-20180620153410545-2100462347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重试机制的代码：&lt;/p&gt;
&lt;p&gt;出错后重复3次。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('60b12fcb-97fc-4fe7-a07d-96288a05de9e')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_60b12fcb-97fc-4fe7-a07d-96288a05de9e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_60b12fcb-97fc-4fe7-a07d-96288a05de9e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('60b12fcb-97fc-4fe7-a07d-96288a05de9e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_60b12fcb-97fc-4fe7-a07d-96288a05de9e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;#region&lt;/span&gt; 重试机制
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Retry()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置重试次数&lt;/span&gt;
            ISyncPolicy policy = Policy.Handle&amp;lt;Exception&amp;gt;().Retry(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                policy.Execute(() &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务开始&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (DateTime.Now.Second % &lt;span&gt;10&lt;/span&gt; != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务出错了，开始重试&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务结束&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                });
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;异常结果 : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ex.Message);
            }
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/809005/201806/809005-20180620153522940-2111080947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 熔断机制代码：&lt;/p&gt;
&lt;p&gt;但出现错误连续三次后，等待10秒后进行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c64528c4-e9a3-4bef-8ead-f00b91b23641')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_c64528c4-e9a3-4bef-8ead-f00b91b23641&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c64528c4-e9a3-4bef-8ead-f00b91b23641&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c64528c4-e9a3-4bef-8ead-f00b91b23641',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c64528c4-e9a3-4bef-8ead-f00b91b23641&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#region&lt;/span&gt; 熔断机制
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Fusing()
        {
            &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;            ISyncPolicy policy = Policy.Handle&amp;lt;Exception&amp;gt;().CircuitBreaker(&lt;span&gt;3&lt;/span&gt;, TimeSpan.FromSeconds(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {

                    policy.Execute(() &lt;/span&gt;=&amp;gt;&lt;span&gt;
                        {
                            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务开始&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;出错了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务结束&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        });

                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;异常结果 : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ex.Message);
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 20 Jun 2018 07:36:00 +0000</pubDate>
<dc:creator>深井田蛙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yanbigfeg/p/9203669.html</dc:identifier>
</item>
<item>
<title>SpringBoot(十)_springboot集成Redis - 阳光温暖</title>
<link>http://www.cnblogs.com/zhenghengbin/p/9203771.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenghengbin/p/9203771.html</guid>
<description>&lt;h4 id=&quot;redis-介绍&quot;&gt;Redis 介绍&lt;/h4&gt;
&lt;p&gt;Redis是一款开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存也可持久化的日志型、Key-Value高性能数据库。&lt;/p&gt;
&lt;h5 id=&quot;数据模型&quot;&gt;数据模型&lt;/h5&gt;
&lt;p&gt;Redis 数据模型不仅与关系数据库管理系统（RDBMS）不同，也不同于任何简单的 NoSQL 键-值数据存储。Redis 数据类型类似于编程语言的基础数据类型，所以开发人员感觉很自然。每个数据类型都支持适用于其类型的操作。受支持的数据类型包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;string（字符串）&lt;/li&gt;
&lt;li&gt;hash（哈希）&lt;/li&gt;
&lt;li&gt;list（列表）&lt;/li&gt;
&lt;li&gt;set（集合）&lt;/li&gt;
&lt;li&gt;zset（sorted set：有序集合）&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;关键优势&quot;&gt;关键优势&lt;/h5&gt;
&lt;p&gt;Redis 的优势包括它的速度、它对富数据类型的支持、它的操作的原子性，以及它的通用性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读速度为110000次/s，写速度为81000次/s，性能极高。&lt;/li&gt;
&lt;li&gt;丰富的数据类型，Redis 对大多数开发人员已知道的大多数数据类型提供了原生支持，这使得各种问题得以轻松解决。&lt;/li&gt;
&lt;li&gt;原子性，因为所有 Redis 操作都是原子性的，所以多个客户端会并发地访问一个 Redis 服务器，获取相同的更新值。&lt;/li&gt;
&lt;li&gt;丰富的特性，Redis 是一个多效用工具，有非常多的应用场景，包括缓存、消息队列（Redis 原生支持发布/订阅）、短期应用程序数据（如 Web 会话、Web 页面命中计数）等。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;springboot集成redis&quot;&gt;springboot集成Redis&lt;/h4&gt;
&lt;h5 id=&quot;创建集成redis的springboot项目&quot;&gt;1、创建集成redis的springboot项目&lt;/h5&gt;
&lt;p&gt;我直接用idea创建一个新的工程，在创建的时候，直接集成Redis，如下图&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20180620135454.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;application-配置application.yml&quot;&gt;2.application 配置(application.yml)&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;spring:
  redis:
    # Redis 服务器地址
    host: 192.168.142.128
    # Redis 服务器连接端口
    port: 6379
    # Redis 服务器连接密码（默认为空）
    password:
    # Redis 数据库索引（默认为0）
    database: 1
    jedis:
      pool:
        # 连接池最大连接数（使用负值表示没有限制）
        max-active: 8
        # 连接池最大阻塞等待时间（使用负值表示没有限制）
        max-wait: -1
        # 连接池中的最大空闲连接
        max-idle: 8
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;redis-对多种数据类型的操作&quot;&gt;3、Redis 对多种数据类型的操作&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里我直接在Test类中进行操作，注入RedisTemplate&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;@RunWith(SpringRunner.class)
@SpringBootTest
public class RedisDemo01ApplicationTests {


    @Resource
    private RedisTemplate redisTemplate;


    @Test
    public void contextLoads() {
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;String类型&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    /**
     * 测试存储String
     */
    @Test
    public  void testString(){
        redisTemplate.opsForValue().set(&quot;maomao&quot;, &quot;hello&quot;);
        System.out.println(redisTemplate.opsForValue().get(&quot;maomao&quot;).toString());
    }
    //输出hello&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;hash类型&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;hash set 的时候需要传入三个参数，第一个为 key，第二个为 field，第三个为存储的值。一般情况下 Key 代表一组数据，field 为 key 相关的属性，而 value 就是属性对应的值.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    /**
     * hash
     */
    @Test
    public void testHash() {
        HashOperations&amp;lt;String, Object, Object&amp;gt; hash = redisTemplate.opsForHash();
        hash.put(&quot;hash&quot;,&quot;hello&quot;,&quot;java&quot;);
        String value=(String) hash.get(&quot;hash&quot;,&quot;hello&quot;);
        System.out.println(&quot;hash value :&quot;+value);
    }
    //输出 hash value :java&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;list类型&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Redis list 的应用场景非常多，也是 Redis 最重要的数据结构之一。 使用 List 可以轻松的实现一个队列，List 典型的应用场景就是消息队列，可以利用 list 的 PUSH 操作，将任务存在 list 中，然后工作线程再用 POP 操作将任务取出进行执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    @Test
    public void testListPop() {
        String key=&quot;list&quot;;
        redisTemplate.delete(key);
        ListOperations&amp;lt;String, String&amp;gt; list = redisTemplate.opsForList();
        list.leftPush(key,&quot;just&quot;);
        list.leftPush(key,&quot;do&quot;);
        list.leftPush(key,&quot;it&quot;);
        String value=list.leftPop(key);
        System.out.println(&quot;list value :&quot;+value);
    }
    //输出结果 list value :it&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;使用 range 来读取,range 后面的两个参数就是插入数据的位置，输入不同的参数就可以取出队列中对应的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    @Test
    public void testListRange() {
        String key=&quot;list&quot;;
        redisTemplate.delete(key);
        ListOperations&amp;lt;String, String&amp;gt; list = redisTemplate.opsForList();
        list.rightPush(key,&quot;just&quot;);
        list.rightPush(key,&quot;do&quot;);
        list.rightPush(key,&quot;it&quot;);

        List&amp;lt;String&amp;gt; values=list.range(key,0,3);
        for (String v:values){
            System.out.println(&quot;list range :&quot;+v);
        }
    }
    //输出结果
    //list range :just
    //list range :do
    //list range :it&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Redis set 对外提供的功能与 list 类似是一个列表的功能，特殊之处在于 set 是可以自动排重的，当需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    @Test
    public void testSet(){
        String key = &quot;set&quot;;
        redisTemplate.delete(key);
        SetOperations&amp;lt;String,String&amp;gt; set = redisTemplate.opsForSet();
        set.add(key,&quot;just&quot;);
        set.add(key,&quot;do&quot;);
        set.add(key,&quot;do&quot;);
        set.add(key,&quot;it&quot;);
        Set&amp;lt;String&amp;gt; values = set.members(key);
        for (String value:values){
            System.out.println(&quot;set value :&quot;+value);
        }
    }
    //输出结果
    //set value :just
    //set value :it
    //set value :do&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Redis 为集合提供了求交集、并集、差集等操作，可以非常方便的使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    @Test
    public void testSetMore() {
        SetOperations&amp;lt;String, String&amp;gt; set = redisTemplate.opsForSet();
        String key1=&quot;setMore1&quot;;
        String key2=&quot;setMore2&quot;;

        set.add(key1,&quot;just&quot;);
        set.add(key1,&quot;do&quot;);
        set.add(key1,&quot;do&quot;);
        set.add(key1,&quot;it&quot;);

        set.add(key2,&quot;java&quot;);
        set.add(key2,&quot;do&quot;);

        Set&amp;lt;String&amp;gt; diffs=set.difference(key1,key2);
        for (String v:diffs){
            System.out.println(&quot;diffs set value :&quot;+v);
        }
        //输出 
        //diffs set value :it
        //diffs set value :just

        String key3=&quot;setMore3&quot;;
        String key4=&quot;setMore4&quot;;
        
        set.add(key3,&quot;just&quot;);
        set.add(key3,&quot;do&quot;);
        set.add(key3,&quot;java&quot;);
        set.add(key4,&quot;it&quot;);
        set.add(key4,&quot;do&quot;);
        set.add(key4,&quot;hello&quot;);
        
        Set&amp;lt;String&amp;gt; unions=set.union(key3,key4);
        for (String v:unions){
            System.out.println(&quot;unions value :&quot;+v);
        }
        //输出
        //unions value :do
        //unions value :java
        //unions value :just
        //unions value :it
        //unions value :hello
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Redis sorted set 的使用场景与 set 类似，区别是 set 不是自动有序的，而 sorted set 可以通过用户额外提供一个优先级（score）的参数来为成员排序，并且是插入有序，即自动排序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    @Test
    public void testZset(){
        String key=&quot;zset&quot;;
        redisTemplate.delete(key);
        ZSetOperations&amp;lt;String, String&amp;gt; zset = redisTemplate.opsForZSet();
        zset.add(key,&quot;just&quot;,1);
        zset.add(key,&quot;now&quot;,5);
        zset.add(key,&quot;it&quot;,4);
        zset.add(key,&quot;do&quot;,3);

        Set&amp;lt;String&amp;gt; zsets=zset.range(key,0,3);
        for (String v:zsets){
            System.out.println(&quot;zset value :&quot;+v);
        }
        //zset value :just
        //zset value :do
        //zset value :it
        //zset value :now


        Set&amp;lt;String&amp;gt; zsetB=zset.rangeByScore(key,0,3);
        for (String v:zsetB){
            System.out.println(&quot;zsetB value :&quot;+v);
        }
        //zsetB value :just
        //zsetB value :do
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;redis-其他的操作&quot;&gt;4.Redis 其他的操作&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;超时失效&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
/**
     * 测试超时失效
     * @throws InterruptedException
     */
    @Test
    public void testExpire() throws InterruptedException {
        ValueOperations&amp;lt;String, String&amp;gt; operations=redisTemplate.opsForValue();
        operations.set(&quot;expire&quot;, &quot;java&quot;,100,TimeUnit.MILLISECONDS);
        Thread.sleep(1000);
        boolean exists=redisTemplate.hasKey(&quot;expire&quot;);
        if(exists){
            System.out.println(&quot;exists is true&quot;);
        }else{
            System.out.println(&quot;exists is false&quot;);
        }
    }
    // 输出 exists is false&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;删除数据&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    /**
     * 删除数据
     */
    @Test
    public void testDelete() {
        ValueOperations&amp;lt;String, String&amp;gt; operations=redisTemplate.opsForValue();
        operations.set(&quot;deletekey&quot;, &quot;springboot&quot;);
        redisTemplate.delete(&quot;deletekey&quot;);
        //判断key是否还在
        boolean exists=redisTemplate.hasKey(&quot;deletekey&quot;);
        if(exists){
            System.out.println(&quot;exists is true&quot;);
        }else{
            System.out.println(&quot;exists is false&quot;);
        }
    }
    //输出 exists is false
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;封装&quot;&gt;5、封装&lt;/h5&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在实际的使用过程中，不会给每一个使用的类都注入 redisTemplate 来直接使用，一般都会对业务进行简单的包装，最后提供出来对外使用. 这里就不在展示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;完整代码下载：&lt;a href=&quot;https://github.com/runzhenghengbin/SpringBoot&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 Jun 2018 06:55:00 +0000</pubDate>
<dc:creator>阳光温暖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenghengbin/p/9203771.html</dc:identifier>
</item>
<item>
<title>Http协议和Tomcat服务器 - Kingram</title>
<link>http://www.cnblogs.com/Kingram/p/9203726.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Kingram/p/9203726.html</guid>
<description>&lt;p&gt;一.Http协议&lt;/p&gt;
&lt;p&gt;1.什么是Http协议&lt;/p&gt;
&lt;p&gt;　　http,超文本传输协议(HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议.所有的WWW文件都必须遵守这个标准.设计Http的最初目的是为了提供一种发布和接受Html页面的方法&lt;/p&gt;
&lt;p&gt;2.Http协议的组成&lt;/p&gt;
&lt;p&gt;　　Http协议由Http请求和Http响应组成，当在浏览器中输入网址访问某个网站时， &lt;span&gt;你的浏览器会将你的请求封装成一个&lt;/span&gt;Http请求发送给服务器站点，服务器接收到请 &lt;span&gt;求后会组织响应数据封装成一个&lt;/span&gt;Http响应返回给浏览器。即没有请求就没有响应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1383283/201806/1383283-20180620135951935-234854540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.Http请求&lt;/p&gt;
&lt;p&gt;　　编辑一个form.html的表单页面,如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;测试&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;actioon &lt;/span&gt;&lt;span&gt;= &quot;#&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;测试Http请求&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;br&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击提交按钮,抓包如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1383283/201806/1383283-20180620140643885-1695793777.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1）请求行&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　请求方式：&lt;/span&gt;POST、GET&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　请求的资源：&lt;/span&gt;/DemoEE/form.html&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　协议版本：&lt;/span&gt;HTTP/1.1&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　　　HTTP/1.0，发送请求，创建一次连接，获得一个web资源，连接断开。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　　　HTTP/1.1，发送请求，创建一次连接，获得多个web资源，保持连接。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;2）请求头&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　请求头是客户端发送给服务器端的一些信息，使用键值对表示&lt;/span&gt;key：value&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;13.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;162&quot;&gt;
&lt;p&gt;常见请求头&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;600&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;描述 （红色掌握，其他了解）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;162&quot;&gt;
&lt;p&gt;Referer&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;600&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;浏览器通知服务器，当前请求来自何处。如果是直接访问，则不会有这个头。常用于：防盗链&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;162&quot;&gt;
&lt;p&gt;If-Modified-Since&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;600&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;浏览器通知服务器，本地缓存的最后变更时间。与另一个响应头组合控制浏览器页面的缓存。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;162&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Cookie&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;600&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;与会话有关技术，用于存放浏览器缓存的cookie信息。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;162&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;User-Agent&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;600&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;浏览器通知服务器，客户端浏览器与操作系统相关信息&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;162&quot;&gt;
&lt;p&gt;Connection&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;600&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;保持连接状态。Keep-Alive 连接中，close 已关闭&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;162&quot;&gt;
&lt;p&gt;Host&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;600&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;请求的服务器主机名&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;162&quot;&gt;
&lt;p&gt;Content-Length&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;600&quot;&gt;
&lt;p&gt;请求体的长度&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;162&quot;&gt;
&lt;p&gt;Content-Type&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;600&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;如果是POST请求，会有这个头，默认值为application/x-www-form-urlencoded，表示请求体内容使用url编码&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;162&quot;&gt;
&lt;p&gt;Accept：&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;600&quot; readability=&quot;15&quot;&gt;
&lt;p&gt;浏览器可支持的MIME类型。文件类型的一种描述方式。&lt;/p&gt;
&lt;p&gt;MIME格式：大类型/小类型[;参数]&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;   text/html ，html文件&lt;/p&gt;
&lt;p&gt;   text/css，css文件&lt;/p&gt;
&lt;p&gt;   text/javascript，js文件&lt;/p&gt;
&lt;p&gt;   image/*，所有图片文件&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;162&quot;&gt;
&lt;p&gt;Accept-Encoding&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;600&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;浏览器通知服务器，浏览器支持的数据压缩格式。如：GZIP压缩&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;162&quot;&gt;
&lt;p&gt;Accept-Language&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;600&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;浏览器通知服务器，浏览器支持的语言。各国语言（国际化i18n）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt;1）请求体&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　当请求方式是&lt;/span&gt;post的时，请求体会有请求的参数，格式如下：&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　　　username=zhangsan&amp;amp;password=123&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　如果请求方式为&lt;/span&gt;get，那么请求参数不会出现在请求体中，会拼接在url地址后面&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　　　&lt;a&gt;&lt;span&gt;http://localhost:8080...?username=zhangsan&amp;amp;password=123&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;4.Http响应&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1383283/201806/1383283-20180620141054504-451281894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1）响应行&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;Http协议&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;状态码：&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　常用的状态码如下：&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　200 ：请求成功。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　302 ：请求重定向。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　304 ：请求资源没有改变，访问本地缓存。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　404 ：请求资源不存在。通常是用户路径编写错误，也可能是服务器资源已删除。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　500 ：服务器内部错误。通常程序抛异常。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;状态信息：状态信息是根据状态码变化而变化的&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;2）响应头&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;响应也都是键值对形式，服务器端将信息以键值对的形式返回给客户端&lt;/p&gt;
&lt;div align=&quot;center&quot; readability=&quot;75&quot;&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;186&quot;&gt;
&lt;p&gt;常见请求头&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;587&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;186&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Location&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;587&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;指定响应的路径，需要与状态码302配合使用，完成跳转。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;186&quot;&gt;
&lt;p&gt;Content-Type&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;587&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;响应正文的类型（MIME类型）&lt;/p&gt;
&lt;p&gt;取值：text/html;charset=UTF-8&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;186&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Content-Disposition&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;587&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;通过浏览器以下载方式解析正文&lt;/p&gt;
&lt;p&gt;取值：attachment;filename=xx.zip&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;186&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Set-Cookie&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;587&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;与会话相关技术。服务器向浏览器写入cookie&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;186&quot;&gt;
&lt;p&gt;Content-Encoding&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;587&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;服务器使用的压缩格式&lt;/p&gt;
&lt;p&gt;取值：gzip&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;186&quot;&gt;
&lt;p&gt;Content-length&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;587&quot;&gt;
&lt;p&gt;响应正文的长度&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;186&quot;&gt;
&lt;p&gt;Refresh&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;587&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;定时刷新，格式：秒数;url=路径。url可省略，默认值为当前页。&lt;/p&gt;
&lt;p&gt;取值：3;url=www.itcast.cn    //三秒刷新页面到www.itcast.cn&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;186&quot;&gt;
&lt;p&gt;Server&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;587&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;指的是服务器名称，默认值：Apache-Coyote/1.1。可以通过conf/server.xml配置进行修改。&amp;lt;Connector port=&quot;8080&quot; ... server=&quot;itcast&quot;/&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;186&quot;&gt;
&lt;p&gt;Last-Modified&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;587&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;服务器通知浏览器，文件的最后修改时间。与If-Modified-Since一起使用。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;justify&quot;&gt;3）响应体&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　响应体是服务器回写给客户端的页面正文，浏览器将正文加载到内存，然后解析渲染 显示页面内容&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;二.Tomcat服务器&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;1.web开发中的常见概念&lt;/p&gt;
&lt;h4&gt;(1)B/S系统和C/S系统&lt;/h4&gt;
&lt;p&gt;Brower/Server：浏览器 服务器 系统 ----- 网站&lt;/p&gt;
&lt;p&gt;Client/Server：客户端 服务器 系统 ----- QQ、飞秋、大型游戏&lt;/p&gt;
&lt;h4&gt;(2)web应用服务器&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;供向外部发布&lt;/span&gt;web资源的服务器软件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1383283/201806/1383283-20180620141446581-1617987880.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;(3)web资源&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;存在于&lt;/span&gt;web应用服务器可供外界访问的资源就是web资源&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：存在于&lt;/span&gt;web应用服务器内部的Html、Css、js、图片、视频等&lt;/p&gt;

&lt;p&gt;1）静态资源：指web页面中供人们浏览的数据始终是不变。比如：HTML、CSS、 JS、图片、多媒体。&lt;/p&gt;
&lt;p&gt;2）动态资源：指web页面中供人们浏览的数据是由程序产生的，不同时间点访问 web页面看到的内容各不相同。比如：JSP/Servlet、ASP、PHP&lt;/p&gt;
&lt;p&gt;javaWEB领域：动态资源认为通过java代码去动态生成html&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(4)请求和响应&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1383283/201806/1383283-20180620141745395-875127817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;(5)&lt;span&gt;请求的&lt;/span&gt;URL地址&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1383283/201806/1383283-20180620141834205-1774595468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.web开发中常见的web应用服务器&lt;/p&gt;
&lt;p&gt;1）weblogic：oracle公司的大型收费web服务器 支持全部javaEE规范&lt;/p&gt;
&lt;p&gt;2）websphere：IBM公司的大型收费web服务器 支持全部的javaEE规范&lt;/p&gt;
&lt;p&gt;3）Tomcat：Apache开源组织下的 开源免费的中小型的web应用服务器 支持 javaEE &lt;span&gt;中的&lt;/span&gt; servlet 和 jsp规范&lt;/p&gt;
&lt;p&gt;3.Tomcat的目录结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1383283/201806/1383283-20180620142205515-469283636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;bin：脚本目录&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　启动脚本：&lt;/span&gt;startup.bat&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　停止脚本：&lt;/span&gt;shutdown.bat&lt;/p&gt;
&lt;p&gt;conf：配置文件目录 (config /configuration)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　核心配置文件：&lt;/span&gt;server.xml&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　用户权限配置文件：&lt;/span&gt;tomcat-users.xml&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所有&lt;/span&gt;web项目默认配置文件：web.xml&lt;/p&gt;
&lt;p&gt;lib：依赖库，tomcat和web项目中需要使用的jar包&lt;/p&gt;
&lt;p&gt;logs：日志文件.&lt;/p&gt;
&lt;p&gt;　　localhost_access_log.*.txt tomcat记录用户访问信息，星*表示时间。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　例如：&lt;/span&gt;localhost_access_log.2016-02-28.txt&lt;/p&gt;
&lt;p&gt;temp：临时文件目录，文件夹内内容可以任意删除。&lt;/p&gt;
&lt;p&gt;webapps：默认情况下发布WEB项目所存放的目录。&lt;/p&gt;
&lt;p&gt;work：tomcat处理JSP的工作目录。&lt;/p&gt;

&lt;p&gt;4.web应用的目录结构&lt;span&gt;(&lt;span&gt;注意：&lt;/span&gt;WEB-INF目录是受保护的，外界不能直接访问)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1383283/201806/1383283-20180620142350910-332992565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.使用Eclipse绑定Tomcat并发布应用&lt;/p&gt;
&lt;p&gt;&lt;span&gt;步骤&lt;/span&gt;1：获得服务器运行环境配置，Window/Preferences/Server/Runtime Environments&lt;/p&gt;
&lt;p&gt;步骤2：添加服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1383283/201806/1383283-20180620143405499-1659977865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;步骤&lt;/span&gt;3：选择服务器在硬盘的地址，然后所有的都是确定/Next/Finish&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1383283/201806/1383283-20180620143541318-1783945300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;步骤&lt;/span&gt;4：完成设置发布位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1383283/201806/1383283-20180620144519380-1221176658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;步骤&lt;/span&gt;5：&lt;span&gt;项目右键&lt;/span&gt;/Run As/Run on Server发布&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1383283/201806/1383283-20180620144737384-1635729226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;
</description>
<pubDate>Wed, 20 Jun 2018 06:50:00 +0000</pubDate>
<dc:creator>Kingram</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Kingram/p/9203726.html</dc:identifier>
</item>
<item>
<title>MySQL组复制(2)：配置单主模型的组复制 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9203154.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9203154.html</guid>
<description>&lt;p&gt;MySQL的组复制可以配置为&lt;strong&gt;单主模型&lt;/strong&gt;和&lt;strong&gt;多主模型&lt;/strong&gt;两种工作模式，它们都能保证MySQL的高可用。以下是两种工作模式的特性简介：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单主模型：从复制组中众多个MySQL节点中&lt;strong&gt;自动选举&lt;/strong&gt;一个master节点，只有master节点可以写，其他节点自动设置为read only。当master节点故障时，会自动选举一个新的master节点，选举成功后，它将设置为可写，其他slave将指向这个新的master。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;多主模型：复制组中的任何一个节点都可以写，因此没有master和slave的概念，只要突然故障的节点数量不太多，这个多主模型就能继续可用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然多主模型的特性很诱人，但缺点是要配置和维护这种模式，必须要深入理解组复制的理论，更重要的是，多主模型限制较多，其一致性、安全性还需要多做测试。&lt;/p&gt;
&lt;p&gt;而使用单主模型的组复制就简单的太多了，唯一需要知道的就是它会自动选举master节点这个特性，因为它的维护一切都是自动进行的，甚至对于管理人员来说，完全可以不用去了解组复制的理论。&lt;/p&gt;
&lt;p&gt;虽然单主模型比多主模型的性能要差，但它没有数据不一致的危险，加上限制少，配置简单，基本上没有额外的学习成本，所以多数情况下都是配置单主模型的组复制，即使是PXC和MariaDB也如此。&lt;/p&gt;


&lt;p&gt;虽说组复制的单主模型很简单，但有必要了解一点和单主模型有关的理论，尽管不了解也没什么问题，毕竟一切都是自动的。&lt;/p&gt;
&lt;p&gt;如下图，master节点为s1，其余为slave节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201806/733013-20180619164451814-1310834102.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;组复制一切正常时，所有的写操作都路由到s1节点上，所有的读操作都路由到s2、s3、s4或s5上。当s1节点故障后，组复制自动选举新的master节点。假如选举s2为新master成功后，s3、s4和s5将指向s2，写操作将路由到s2节点上。&lt;/p&gt;
&lt;p&gt;至于如何改变客户端的路由目标，这不是组复制应该考虑的事情，而是客户端应用程序应该考虑的事情。实际上，更好的方式是使用中间件来做数据库的路由，比如MySQL Router、ProxySQL、amoeba、cobar、mycat。&lt;/p&gt;

&lt;h2 id=&quot;如何加入新节点&quot;&gt;1.1 如何加入新节点&lt;/h2&gt;
&lt;p&gt;上面一直说，单主模型是自动选举主节点的，那么如何选举？&lt;/p&gt;
&lt;p&gt;首先，在第一个MySQL节点s1启动时，一般会将其设置为组的引导节点，所谓引导就是在启动组复制功能时去创建一个复制组。当然，这并非强制要求，也可以设置第二个启动节点作为组的引导节点。因为组内没有其他节点，所以这第一个节点会直接选为master节点。&lt;/p&gt;
&lt;p&gt;然后，如果有第二个节点要加入组时，新节点需要征得组的同意，因为目前只有一个节点，所以只需s1节点同意即可。新节点在加入组时，首先会联系s1，与s1建立&lt;strong&gt;异步复制&lt;/strong&gt;的通道，并从s1节点处获取s2上目前缺失的数据，等到s1和s2节点上的数据同步后，s2节点就会真正成为组中的新成员。当然，实际过程要比这里复杂一些，本文不会过多讨论。&lt;/p&gt;
&lt;p&gt;如果还有新节点(比如s3节点)继续加入组，s3将从s1或s2中选一个，并与之建立异步复制的通道，然后获取缺失的数据，同步结束后，如果s1和s2都同意s3加入，那么s3将会组中的新成员。其余节点加入组也依次类推。&lt;/p&gt;
&lt;p&gt;有两点需要注意：&lt;/p&gt;
&lt;ol readability=&quot;8&quot;&gt;&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;新节点加入组时，如何选择联系对象？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面说加入第二个节点s2时会联系s1，加入s3时会联系s1、s2中的任意一个。实际上，新节点加入组时联系的对象，称为donor，意为数据供应者。新节点会和选中的donor建立异步复制通道，并从donor处获取缺失的数据。&lt;/p&gt;
&lt;p&gt;在配置组复制时，需要指定种子节点列表。当新节点加入组时，只会联系种子节点，也即是说，只有种子节点列表中的节点才有机会成为donor，没有在种子节点列表中的节点不会被新节点选中。但&lt;strong&gt;建议，将组中所有节点都加入到种子列表中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当联系第一个donor失败后，会向后联系第二个donor，再失败将联系第三个donor，如果所有种子节点都联系失败，在等待一段时间后再次从头开始联系第一个donor。依此类推，直到加组失败报错。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;新节点加入组时，需要征得哪些节点的同意？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际上，新节点加组涉及到组的决策：是否允许它加组。在组复制中，所有的决策都需要组中大多数节点达成一致，也即是达到法定票数。所谓大多数节点，指的是&lt;code&gt;N/2+1&lt;/code&gt;(N是组中目前节点总数)，例如目前组中有5个节点，则需要3个节点才能达到大多数的要求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;如何选举新的master&quot;&gt;1.2 如何选举新的master&lt;/h2&gt;
&lt;p&gt;当主节点s1故障后，组复制的故障探测机制就能发现这个问题并报告给组中其他成员，组中各成员根据收集到的其他成员信息，会比较各成员的权重值(由变量&lt;code&gt;group_replication_member_weigth&lt;/code&gt;控制)，权重值最高的优先成为新的Master。如果有多个节点具有相同的最高权重值，会按字典顺序比较它们的server_uuid值，最小的(升序排序，最小值在最前面)优先成为新的master。&lt;/p&gt;
&lt;p&gt;但需要注意，变量&lt;code&gt;group_replication_member_weigth&lt;/code&gt;是从MySQL 5.7.20开始提供的，在MySQL 5.7.17到5.7.19之间没有该变量。此时将根据它们的server_uuid值进行排序选举。具体的规则可自行测试。&lt;/p&gt;

&lt;h2 id=&quot;最多允许多少个节点故障&quot;&gt;1.3 最多允许多少个节点故障&lt;/h2&gt;
&lt;p&gt;MySQL组复制使用Paxos分布式算法来提供节点间的分布式协调。正因如此，它要求组中大多数节点在线才能达到法定票数，从而对一个决策做出一致的决定。&lt;/p&gt;
&lt;p&gt;大多数指的是&lt;code&gt;N/2+1&lt;/code&gt;(N是组中目前节点总数)，例如目前组中有5个节点，则需要3个节点才能达到大多数的要求。所以，允许出现故障的节点数量如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201806/733013-20180619175159515-1966257287.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;单主模型组复制的要求&quot;&gt;1.4 单主模型组复制的要求&lt;/h2&gt;
&lt;p&gt;见：&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9197442.html&quot;&gt;使用MySQL组复制的限制和局限性&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;更多组复制的理论&quot;&gt;1.5 更多组复制的理论&lt;/h2&gt;
&lt;p&gt;若想了解更多组复制的理论以及组复制中每一个过程的细节，请参考我另一篇文章(暂未写)，或者阅读我对MySQL官方手册关于&lt;a href=&quot;https://files.cnblogs.com/files/f-ck-need-u/MySQL%E7%BB%84%E5%A4%8D%E5%88%B6%E7%BF%BB%E8%AF%91.pdf&quot;&gt;组复制的翻译&lt;/a&gt;。&lt;/p&gt;


&lt;p&gt;本文配置3个节点的单主模型组复制。配置很简单，基本上就是在常规复制选项的基础上多了几个选项、多了几步操作。&lt;/p&gt;
&lt;p&gt;拓扑图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201806/733013-20180619181103824-527250075.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体环境细节如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;s1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;MySQL 5.7.22&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.100.21&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.100.21&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;全新实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;s2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;MySQL 5.7.22&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.100.22&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.100.21&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;全新实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;s3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;MySQL 5.7.22&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.100.23&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.100.21&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;全新实例&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;发现了每个节点都给了两个接口吗？我这里配置它们都使用同一个接口eth0。其中：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端接口是mysqld向外提供数据库服务的，对应端口是3306，例如php程序连接MySQL执行一个查询语句时就使用该地址。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;组内节点通信接口用于组内各节点消息传递，组内两两节点建立一条消息传递的TCP连接。所以，3个节点需要建立的组内通信连接为：&lt;code&gt;s1&amp;lt;--&amp;gt;s2、s1&amp;lt;--&amp;gt;s3、s2&amp;lt;--&amp;gt;s3&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;请确保这3个节点的主机名不同，且能正确解析为客户端接口的地址&lt;/strong&gt;(别搞错地址了)，因为在连接donor进行数据恢复的时候，是通过主机名进行解析的。所以，所有节点都要先配置好不同的主机名，并修改/etc/hosts文件。对于克隆出来的实验主机，这一步骤很关键。以centos 7为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# s1上：
hostnamectl set-hostname --static s1.longshuai.com
hostnamectl -H root@192.168.100.22 set-hostname s2.longshuai.com
hostnamectl -H root@192.168.100.23 set-hostname s3.longshuai.com

# 写/etc/hosts
# s1上：
cat &amp;gt;&amp;gt;/etc/hosts&amp;lt;&amp;lt;eof
    192.168.100.21 s1.longshuai.com
    192.168.100.22 s2.longshuai.com
    192.168.100.23 s3.longshuai.com
eof
scp /etc/hosts 192.168.100.22:/etc
scp /etc/hosts 192.168.100.23:/etc&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;配置组内第一个节点s1&quot;&gt;2.1 配置组内第一个节点s1&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.先提供配置文件。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[mysqld]
datadir=/data
socket=/data/mysql.sock

server-id=100                      # 必须
gtid_mode=on                       # 必须
enforce_gtid_consistency=on        # 必须
log-bin=/data/master-bin           # 必须
binlog_format=row                  # 必须
binlog_checksum=none               # 必须
master_info_repository=TABLE       # 必须
relay_log_info_repository=TABLE    # 必须
relay_log=/data/relay-log          # 必须，如果不给，将采用默认值
log_slave_updates=ON               # 必须
sync-binlog=1                      # 建议
log-error=/data/error.log
pid-file=/data/mysqld.pid

transaction_write_set_extraction=XXHASH64         # 必须
loose-group_replication_group_name=&quot;aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa&quot;  # 必须
loose-group_replication_start_on_boot=off        # 建议设置为OFF
loose-group_replication_local_address=&quot;192.168.100.21:20001&quot;   # 必须，下一行也必须
loose-group_replication_group_seeds=&quot;192.168.100.21:20001,192.168.100.22:20002&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;想要使用组复制，要求还是挺多的。分析一下上面的配置选项：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;(1).因为组复制基于GTID，所以必须开启&lt;em&gt;gtid_mode&lt;/em&gt;和&lt;em&gt;enforce_gtid_consistency&lt;/em&gt;。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(2).组复制必须开启二进制日志，且必须设置为行格式的二进制日志，这样才能从日志记录中收集信息且保证数据一致性。所以设置&lt;em&gt;log_bin&lt;/em&gt;和&lt;em&gt;binlog_format&lt;/em&gt;。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(3).由于MySQL对复制事件校验的设计缺陷，组复制不能对他们校验，所以设置&lt;em&gt;binlog_checksum=none&lt;/em&gt;。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(4).组复制要将master和relay log的元数据写入到&lt;em&gt;mysql.slave_master_info&lt;/em&gt;和&lt;em&gt;mysql.slave_relay_log_info&lt;/em&gt;中。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(5).组中的每个节点都保留了完整的数据副本，它是share-nothing的模式。所以所有节点上都必须开启&lt;em&gt;log_slave_updates&lt;/em&gt;，这样新节点随便选哪个作为donor都可以进行异步复制。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(6).&lt;em&gt;sync_binlog&lt;/em&gt;是为了保证每次事务提交都立刻将binlog刷盘，保证出现故障也不丢失日志。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(7).最后的5行是组复制插件的配置。以&lt;code&gt;loose_&lt;/code&gt;开头表示即使启动组复制插件，MySQL也继续正常允许下去。这个前缀是可选的。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(8).倒数第5行表示写集合以&lt;code&gt;XXHASH64&lt;/code&gt;的算法进行hash。&lt;strong&gt;所谓写集，是对事务中所修改的行进行的唯一标识，在后续检测并发事务之间是否修改同一行冲突时使用&lt;/strong&gt;。它基于主键生成，所以使用组复制，表中必须要有主键。&lt;br/&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;(9).倒数第4行表示这个复制组的名称。它必须是一个有效的UUID值。嫌可以直接和上面一样全写字母a。在Linux下，可以使用&lt;code&gt;uuidgen&lt;/code&gt;工具来生成UUID值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@xuexi ~]# uuidgen
09c38ef2-7d81-463e-bdb4-9459b2c0e49b&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;(10).倒数第3行表示组复制功能不随MySQL实例启动而启动。虽然，可以将组复制插件和启动组复制功能的选项写在配置文件里，但强烈建议不要如此，而是每次手动去配置。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(11).倒数第2行表示本机上用于&lt;strong&gt;组内各节点之间通信的地址和端口&lt;/strong&gt;。&lt;br/&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;(12).最后一行，设置本组的种子节点。种子节点的意义在前文已经解释过了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在配置文件已经提供。可以启动mysql实例了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@xuexi ~]# systemctl start mysqld&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.创建复制用户。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;连上s1节点。创建用于复制的用户。我这里创建的用户为&lt;code&gt;repl&lt;/code&gt;，密码为&lt;code&gt;P@ssword1!&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;user&lt;/span&gt; repl@&lt;span class=&quot;st&quot;&gt;'192.168.100.%'&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;identified&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'P@ssword1!'&lt;/span&gt;;
mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;grant&lt;/span&gt; replication slave &lt;span class=&quot;kw&quot;&gt;on&lt;/span&gt; *.* &lt;span class=&quot;kw&quot;&gt;to&lt;/span&gt; repl@&lt;span class=&quot;st&quot;&gt;'192.168.100.%'&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3.配置节点加组时的通道。这是组复制的一个关键。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在新节点加入组时，首先要选择donor。新节点和donor之间的异步复制就是通过一个名为&lt;code&gt;group_replication_recovery&lt;/code&gt;的通道(通道名固定，不可使用自定义通道)进行数据恢复的，经过数据恢复后，新节点填充了它缺失的那部分数据，这样就和组内其他节点的数据保持了同步。&lt;/p&gt;
&lt;p&gt;这个恢复过程比较复杂，它是一种分布式恢复。本文不介绍这个，在&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/9203154.html&quot;&gt;组复制理论详解&lt;/a&gt;中，我将对此做详细的说明。&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;change master to&lt;/code&gt;语句设置恢复通道。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;change&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;master&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;to&lt;/span&gt; 
            master_user=&lt;span class=&quot;st&quot;&gt;'repl'&lt;/span&gt;,
            master_password=&lt;span class=&quot;st&quot;&gt;'P@ssword1!'&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; channel &lt;span class=&quot;st&quot;&gt;'group_replication_recovery'&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;这里的用户名、密码和通道在组复制中有一个专门的术语：通道凭据(channel credentials)&lt;/strong&gt;。通道凭据是连接donor的关键。&lt;/p&gt;
&lt;p&gt;当执行完上面的语句后，就生成了一个&lt;strong&gt;该通道的relay log文件&lt;/strong&gt;(注意称呼：该通道的relay log，后面还有另一个通道的relay log)。如下，其中前缀&quot;relay-log&quot;是配置文件中&quot;relay_log&quot;选项配置的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@xuexi ~]# ls -1 /data/*group*
/data/relay-log-group_replication_recovery.000001
/data/relay-log-group_replication_recovery.index&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;group_replication_recovery&lt;/code&gt;通道的relay log用于新节点加入组时，&lt;strong&gt;当新节点联系上donor后，会从donor处以异步复制的方式将其binlog复制到这个通道的relay log中，新节点将从这个recovery通道的relay log中恢复数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面配置文件中已经指定了master和relay log的元数据信息要记录到表中，所以这里可以先查看下关于relay log的元数据。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; mysql.slave_relay_log_info\G
*************************** &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;. &lt;span class=&quot;kw&quot;&gt;row&lt;/span&gt; ***************************
  Number_of_lines: &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;
   Relay_log_name: /data/relay-log-group_replication_recovery&lt;span class=&quot;fl&quot;&gt;.000001&lt;/span&gt;
    Relay_log_pos: &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
  Master_log_name: 
   Master_log_pos: &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
        Sql_delay: &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
Number_of_workers: &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
               Id: &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
     Channel_name: group_replication_recovery&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要查看连接master的元数据信息，则查询&lt;code&gt;mysql.slave_master_info&lt;/code&gt;表。不过现在没必要查，因为啥都还没做呢。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.安装组复制插件，并启动组复制功能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一切就绪后，可以开启mysql实例的组复制功能了。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;mysql&amp;gt; install plugin group_replication soname &lt;span class=&quot;st&quot;&gt;'group_replication.so'&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后开启组复制功能。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; @@global.group_replication_bootstrap_group=on;
mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;start&lt;/span&gt; group_replication;
mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; @@global.group_replication_bootstrap_group=off;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的过程很重要，需要引起注意。在开启组复制之前，设置全局变量&lt;code&gt;group_replication_bootstrap_group&lt;/code&gt;为on，这表示稍后启动的组复制功能将引导组，也就是创建组并配置组，这些都是自动的。配置引导变量为ON后，再开启组复制插件功能，也就是启动组复制。最后将引导变量设回OFF，之所以要设置回OFF，是为了避免下次重启组复制插件功能时再次引导创建一个组，这样会存在两个名称相同实际却不相同的组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这几个过程不适合放进配置文件中，强烈建议手动执行它们的。否则下次重启mysql实例时，会自动重新引导创建一个组。同理，除了第一个节点，其他节点启动组复制功能时，不应该引导组，所以只需执行其中的start语句，千万不能开启&lt;code&gt;group_replication_bootstrap_group&lt;/code&gt;变量引导组。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里的几个过程，应该形成一个习惯，在启动第一个节点时，这3条语句同时执行，在启动其他节点时，只执行start语句。&lt;/p&gt;
&lt;p&gt;当启动组复制功能后，将生成另一个通道&lt;code&gt;group_replication_applier&lt;/code&gt;的相关文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@xuexi ~]# ls -1 /data/*group*
/data/relay-log-group_replication_applier.000001
/data/relay-log-group_replication_applier.000002
/data/relay-log-group_replication_applier.index
/data/relay-log-group_replication_recovery.000001
/data/relay-log-group_replication_recovery.index&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是否还记得刚才用于恢复的通道&lt;code&gt;group_replication_recovery&lt;/code&gt;？这个applier通道是干什么的？&lt;strong&gt;在组复制中，没有常规复制的两个复制线程：io线程和sql线程，取而代之的是receiver、certifier和applier。&lt;/strong&gt;这里简单介绍一下它们的作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;receiver的作用类似于io线程，用于接收组内个节点之间传播的消息和事务。也用于接收外界新发起的事务。&lt;/li&gt;
&lt;li&gt;applier的作用类似于sql线程，用于应用relay log中的记录。不过，组复制的relay log不再是relay log，而是这里的组复制relay log：&lt;code&gt;relay-log-group_replication_applier.00000N&lt;/code&gt;。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;certifier的作用在receiver接收到消息后，验证是否有并发事务存在冲突问题。冲突检测通过后，这条消息就会写入到组复制的relay log中，等待applier去应用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;5.验证组中节点并测试插入不满足组复制要求的数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;至此，这个节点的组复制已经配置完成了。现在需要查看这个节点是否成功加入到组中，&lt;strong&gt;成功加入组的标志是被设置为&quot;ONLINE&quot;&lt;/strong&gt;。只要没有设置为ONLINE，就表示组中的这个节点是故障的。&lt;/p&gt;
&lt;p&gt;查看的方式是通过查询&lt;code&gt;performance_schema&lt;/code&gt;架构下的&lt;code&gt;replication_group_members&lt;/code&gt;表。在这个架构下，有几张对于维护组复制来说非常重要的表，这里的&lt;code&gt;replication_group_members&lt;/code&gt;是其中一张。关于其他的表，我会在有需要的地方或者其他文章中解释。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; select * from performance_schema.replication_group_members;
+---------------------------+--------------------------------------+---------------------+-------------+--------------+
| CHANNEL_NAME              | MEMBER_ID                            | MEMBER_HOST         | MEMBER_PORT | MEMBER_STATE |
+---------------------------+--------------------------------------+---------------------+-------------+--------------+
| group_replication_applier | a659234f-6aea-11e8-a361-000c29ed4cf4 | xuexi.longshuai.com |        3306 | ONLINE       |
+---------------------------+--------------------------------------+---------------------+-------------+--------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不方便观看，换一种显示方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; select * from performance_schema.replication_group_members\G
*************************** 1. row ***************************
CHANNEL_NAME: group_replication_applier
   MEMBER_ID: a659234f-6aea-11e8-a361-000c29ed4cf4
 MEMBER_HOST: xuexi.longshuai.com
 MEMBER_PORT: 3306
MEMBER_STATE: ONLINE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意这里的每一行，包括member_host，它是对外连接的地址，所以应该设置它的DNS解析为提供MySQL数据库服务的接口地址。这很重要，如果你不想去修改DNS解析，可以在启动组复制之前，设置report_host变量为对外的IP地址，或者将其写入到配置文件中。&lt;/p&gt;
&lt;p&gt;现在，组中的这个节点已经是ONLINE了，表示可以对外提供组复制服务了。&lt;/p&gt;
&lt;p&gt;稍后，将向组中加入第二个节点s2和第三个节点s3，但在加入新节点之前，先向s1节点写入一些数据，顺便测试一下开启组复制后，必须使用InnoDB、表中必须有主键的限制。&lt;/p&gt;
&lt;p&gt;下面创建4个表：t1和t4是InnoDB表，t3和t4具有主键。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create table t1(id int);
create table t2(id int)engine=myisam;
create table t3(id int primary key)engine=myisam;
create table t4(id int primary key);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽说组复制对这些有限制，但是创建时是不会报错的。&lt;/p&gt;
&lt;p&gt;向这4张表中插入数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;insert into t1 values(1);
insert into t2 values(1);
insert into t3 values(1);
insert into t4 values(1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会发现只有t4能插入成功，t1、t2、t3都插入失败，报错信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ERROR 3098 (HY000): The table does not comply with the requirements by an external plugin.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;意思是该表不遵从外部插件(即组复制插件)的要求。&lt;/p&gt;
&lt;p&gt;最后，查看下二进制日志中的事件。为了排版，我将显示结果中的日志名称列去掉了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; SHOW BINLOG EVENTS in 'master-bin.000004';
+------+----------------+-----------+-------------+-------------------------------------------------------------------+
| Pos  | Event_type     | Server_id | End_log_pos | Info                                                              |
+------+----------------+-----------+-------------+-------------------------------------------------------------------+
|    4 | Format_desc    |       100 |         123 | Server ver: 5.7.22-log, Binlog ver: 4                             |
|  123 | Previous_gtids |       100 |         150 |                                                                   |
|  150 | Gtid           |       100 |         211 | SET @@SESSION.GTID_NEXT= 'a659234f-6aea-11e8-a361-000c29ed4cf4:1' |
|  211 | Query          |       100 |         399 | CREATE USER 'repl'@'192.168.100.%' IDENTIFIED WITH 'password'     |
|  399 | Gtid           |       100 |         460 | SET @@SESSION.GTID_NEXT= 'a659234f-6aea-11e8-a361-000c29ed4cf4:2' |
|  460 | Query          |       100 |         599 | GRANT REPLICATION SLAVE ON *.* TO 'repl'@'192.168.100.%'          |
|  599 | Gtid           |       100 |         660 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1' |
|  660 | Query          |       100 |         719 | BEGIN                                                             |
|  719 | View_change    |       100 |         858 | view_id=15294216022242634:1                                       |
|  858 | Query          |       100 |         923 | COMMIT                                                            |
|  923 | Gtid           |       100 |         984 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:2' |
|  984 | Query          |       100 |        1083 | create database gr_test                                           |
| 1083 | Gtid           |       100 |        1144 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:3' |
| 1144 | Query          |       100 |        1243 | use `gr_test`; create table t1(id int)                            |
| 1243 | Gtid           |       100 |        1304 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:4' |
| 1304 | Query          |       100 |        1416 | use `gr_test`; create table t2(id int)engine=myisam               |
| 1416 | Gtid           |       100 |        1477 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:5' |
| 1477 | Query          |       100 |        1601 | use `gr_test`; create table t3(id int primary key)engine=myisam   |
| 1601 | Gtid           |       100 |        1662 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:6' |
| 1662 | Query          |       100 |        1773 | use `gr_test`; create table t4(id int primary key)                |
| 1773 | Gtid           |       100 |        1834 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:7' |
| 1834 | Query          |       100 |        1905 | BEGIN                                                             |
| 1905 | Table_map      |       100 |        1949 | table_id: 117 (gr_test.t4)                                        |
| 1949 | Write_rows     |       100 |        1985 | table_id: 117 flags: STMT_END_F                                   |
| 1985 | Xid            |       100 |        2012 | COMMIT /* xid=63 */                                               |
+------+----------------+-----------+-------------+-------------------------------------------------------------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了正常的事务对应的事件，需要关注的三行是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BEGIN
View_change &amp;lt;----&amp;gt; view_id=15294216022242634:1
COMMIT&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;组复制中，每个决策都需要组中大多数节点达成一致，包括新节点加组、离组的决定。实际上，组复制中内置了一个组成员服务，这个服务负责组成员的配置以及动态捕获组中成员列表，这个成员列表成为&lt;strong&gt;成员视图&lt;/strong&gt;。每个视图都有一个view id，view id的第一部分是创建组时随机生成的，只要组不停止，这部分就不改变，第二部分是从1开始的单调递增的数值。每当有成员加组、离组时，都会触发这个服务对组成员进行重新配置，每次组成员的重新配置，view id的第二部分都会单调递增地加1，表示这是新的成员视图，新的组成员视图需要得到组中大多数节点的同意，所以这个消息要在组中进行传播。如何传播？就是通过将视图更改的事件作为一个事务写进binlog中，然后在组中到处复制，这样每个节点都可收到视图变化的消息，并对此做出回应，同意之后再commit这个事务。如果足够细心，会发现这个事务的提交和下面插入数据的提交(&lt;code&gt;COMMIT /* xid=63 */&lt;/code&gt;)方式不一样。如果不理解也没关系，这个理论并不影响组复制的使用。&lt;/p&gt;
&lt;p&gt;再仔细一看，还可以发现MySQL中的DDL语句是没有事务的。所以，绝不允许不同节点上对同一个对象并发执行&quot;DDL+DML&quot;和&quot;DDL+DDL&quot;，冲突检测机制会探测到这样的冲突。&lt;/p&gt;

&lt;h2 id=&quot;向组中添加新节点&quot;&gt;2.2 向组中添加新节点&lt;/h2&gt;
&lt;p&gt;当组中已有第一个节点后，需要做的是向组中添加新的节点。这里以添加s2和s3为例。&lt;/p&gt;

&lt;h3 id=&quot;添加新节点前要做什么&quot;&gt;2.2.1 添加新节点前要做什么&lt;/h3&gt;
&lt;p&gt;前面多次提到，新节点在加入组的时候，会先选择一个donor，并通过异步复制的方式从这个donor处获取缺失的数据，以便在成功加入组的时候它的数据和组中已有的节点是完全同步的，这样才能向外界客户端提供查询。&lt;/p&gt;
&lt;p&gt;这里的重点在于异步复制，既然是复制，它就需要复制binlog，并通过应用binlog中的记录来写数据。如果在加入组之前，组中的数据量已经非常大，那么这个异步复制的过程会很慢，而且还会影响donor的性能，毕竟它要传输大量数据出去。&lt;/p&gt;
&lt;p&gt;本来加入新节点的目的就是对组复制进行扩展，提高它的均衡能力，现在因为异步复制慢，反而导致性能稍有下降，新节点短期内还无法上线向外提供服务。这有点背离原本的目标。&lt;/p&gt;
&lt;p&gt;再者，如果组中的节点purge过日志，那么新节点将无法从donor上获取完整的数据。这时新节点上的恢复过程会让它重新选择下一个donor。但很可能还是会失败，因为Purge如果是加组之后执行的，它已经复制到了组中的所有节点上，所有节点都会purge那段日志。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;在新节点加入组之前，应该先通过备份恢复的方式，从组中某节点上备份目前的数据到新节点上，然后再让新节点去加组&lt;/strong&gt;，这样加组的过程将非常快，且能保证不会因为purge的原因而加组失败。至于如何备份恢复，参见我的另一篇文章：&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9155003.html#blog4.2&quot;&gt;将slave恢复到master指定的坐标&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我这里做实验的环境，所有节点都是刚安装好的全新实例，数据量小，也没purge过日志，所以直接加入到组中就可以。&lt;/p&gt;

&lt;h3 id=&quot;添加第二个节点&quot;&gt;2.2.2 添加第二个节点&lt;/h3&gt;
&lt;p&gt;仍然先是提供配置文件。配置文件和第一个节点基本相同，除了几个需要保持唯一性的选项。&lt;/p&gt;
&lt;p&gt;配置文件内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[mysqld]
datadir=/data
socket=/data/mysql.sock

server-id=110                      # 必须，每个节点都不能相同
gtid_mode=on                       # 必须
enforce_gtid_consistency=on        # 必须
log-bin=/data/master-bin           # 必须
binlog_format=row                  # 必须
binlog_checksum=none               # 必须
master_info_repository=TABLE       # 必须
relay_log_info_repository=TABLE    # 必须
relay_log=/data/relay-log          # 必须，如果不给，将采用默认值
log_slave_updates=ON               # 必须
sync-binlog=1                      # 建议
log-error=/data/error.log
pid-file=/data/mysqld.pid

transaction_write_set_extraction=XXHASH64         # 必须
loose-group_replication_group_name=&quot;aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa&quot;  # 必须
loose-group_replication_start_on_boot=off        # 建议设置为OFF
loose-group_replication_local_address=&quot;192.168.100.22:20002&quot;   # 必须，下一行也必须
loose-group_replication_group_seeds=&quot;192.168.100.21:20001,192.168.100.22:20002&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里和s1的配置文件相比，只修改了&lt;code&gt;server-id&lt;/code&gt;和&lt;code&gt;group_replication_local_address&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后执行&lt;code&gt;change master to&lt;/code&gt;，选择一个donor(此刻只有s1能选)，并和donor建立通道连接。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; change master to 
            master_user='repl',
            master_password='P@ssword1!'
            for channel 'group_replication_recovery';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时，就已经选择好donor，并和donor建立通道连接了。如果去s1上查看，可以看到这个通道的连接。下面的查询结果中，第二行就是和s2建立的连接，通道为&lt;code&gt;group_replication_recovery&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; select * from mysql.slave_master_info\G
*************************** 1. row ***************************
       Number_of_lines: 25
       Master_log_name: 
        Master_log_pos: 4
                  Host: &amp;lt;NULL&amp;gt;
             User_name: 
         User_password: 
                  Port: 0
         Connect_retry: 60
           Enabled_ssl: 0
                Ssl_ca: 
            Ssl_capath: 
              Ssl_cert: 
            Ssl_cipher: 
               Ssl_key: 
Ssl_verify_server_cert: 0
             Heartbeat: 30
                  Bind: 
    Ignored_server_ids: 0
                  Uuid: 
           Retry_count: 86400
               Ssl_crl: 
           Ssl_crlpath: 
 Enabled_auto_position: 1
          Channel_name: group_replication_applier
           Tls_version: 
*************************** 2. row ***************************
       Number_of_lines: 25
       Master_log_name: 
        Master_log_pos: 4
                  Host: 
             User_name: repl
         User_password: P@ssword1!
                  Port: 3306
         Connect_retry: 60
           Enabled_ssl: 0
                Ssl_ca: 
            Ssl_capath: 
              Ssl_cert: 
            Ssl_cipher: 
               Ssl_key: 
Ssl_verify_server_cert: 0
             Heartbeat: 0
                  Bind: 
    Ignored_server_ids: 0
                  Uuid: 
           Retry_count: 86400
               Ssl_crl: 
           Ssl_crlpath: 
 Enabled_auto_position: 0
          Channel_name: group_replication_recovery
           Tls_version: 
2 rows in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后回到s2节点上，安装组复制插件，并开启组复制功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; install plugin group_replication soname 'group_replication.so';
mysql&amp;gt; start group_replication;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;组复制启动成功后，查看是否处于online状态。(请无视我这里的Member_host字段，这是我设置了report_host变量的结果)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; select * from performance_schema.replication_group_members\G 
*************************** 1. row ***************************
CHANNEL_NAME: group_replication_applier
   MEMBER_ID: a5165443-6aec-11e8-a8f6-000c29827955
 MEMBER_HOST: 192.168.100.22
 MEMBER_PORT: 3306
MEMBER_STATE: ONLINE
*************************** 2. row ***************************
CHANNEL_NAME: group_replication_applier
   MEMBER_ID: a659234f-6aea-11e8-a361-000c29ed4cf4
 MEMBER_HOST: xuexi.longshuai.com
 MEMBER_PORT: 3306
MEMBER_STATE: ONLINE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再查看数据是否已经同步到s2节点。其实显示了ONLINE，就一定已经同步。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; show tables from gr_test;
+-------------------+
| Tables_in_gr_test |
+-------------------+
| t1                |
| t2                |
| t3                |
| t4                |
+-------------------+
4 rows in set (0.00 sec)

mysql&amp;gt; select * from gr_test.t4;
+----+
| id |
+----+
|  1 |
+----+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看binlog事件。会发现内容已经复制，且view id又发生了一次变化。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; show binlog events in 'master-bin.000002';
+------+----------------+-----------+-------------+-------------------------------------------------------------------+
| Pos  | Event_type     | Server_id | End_log_pos | Info                                                              |
+------+----------------+-----------+-------------+-------------------------------------------------------------------+
|    4 | Format_desc    |       110 |         123 | Server ver: 5.7.22-log, Binlog ver: 4                             |
|  123 | Previous_gtids |       110 |         150 |                                                                   |
|  150 | Gtid           |       100 |         211 | SET @@SESSION.GTID_NEXT= 'a659234f-6aea-11e8-a361-000c29ed4cf4:1' |
|  211 | Query          |       100 |         399 | CREATE USER 'repl'@'192.168.100.%' IDENTIFIED WITH 'password'     |
|  399 | Gtid           |       100 |         460 | SET @@SESSION.GTID_NEXT= 'a659234f-6aea-11e8-a361-000c29ed4cf4:2' |
|  460 | Query          |       100 |         599 | GRANT REPLICATION SLAVE ON *.* TO 'repl'@'192.168.100.%'          |
|  599 | Gtid           |       100 |         660 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1' |
|  660 | Query          |       100 |         719 | BEGIN                                                             |
|  719 | View_change    |       100 |         858 | view_id=15294216022242634:1                                       |
|  858 | Query          |       100 |         923 | COMMIT                                                            |
|  923 | Gtid           |       100 |         984 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:2' |
|  984 | Query          |       100 |        1083 | create database gr_test                                           |
| 1083 | Gtid           |       100 |        1144 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:3' |
| 1144 | Query          |       100 |        1243 | use `gr_test`; create table t1(id int)                            |
| 1243 | Gtid           |       100 |        1304 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:4' |
| 1304 | Query          |       100 |        1416 | use `gr_test`; create table t2(id int)engine=myisam               |
| 1416 | Gtid           |       100 |        1477 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:5' |
| 1477 | Query          |       100 |        1601 | use `gr_test`; create table t3(id int primary key)engine=myisam   |
| 1601 | Gtid           |       100 |        1662 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:6' |
| 1662 | Query          |       100 |        1773 | use `gr_test`; create table t4(id int primary key)                |
| 1773 | Gtid           |       100 |        1834 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:7' |
| 1834 | Query          |       100 |        1893 | BEGIN                                                             |
| 1893 | Table_map      |       100 |        1937 | table_id: 112 (gr_test.t4)                                        |
| 1937 | Write_rows     |       100 |        1973 | table_id: 112 flags: STMT_END_F                                   |
| 1973 | Xid            |       100 |        2000 | COMMIT /* xid=31 */                                               |
| 2000 | Gtid           |       100 |        2061 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:8' |
| 2061 | Query          |       100 |        2120 | BEGIN                                                             |
| 2120 | View_change    |       100 |        2299 | view_id=15294216022242634:2                                       |
| 2299 | Query          |       100 |        2364 | COMMIT                                                            |
+------+----------------+-----------+-------------+-------------------------------------------------------------------+&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;添加第三个节点&quot;&gt;2.2.3 添加第三个节点&lt;/h3&gt;
&lt;p&gt;和加入s2节点几乎一致。所以这里做个步骤的简单总结：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.配置主机名和DNS解析&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;见&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/9203154.html#blog2&quot;&gt;2.配置单主模型&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.提供配置文件，并启动MySQL实例&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;datadir=/data
socket=/data/mysql.sock

server-id=120                      
gtid_mode=on                       
enforce_gtid_consistency=on        
log-bin=/data/master-bin           
binlog_format=row                  
binlog_checksum=none               
master_info_repository=TABLE       
relay_log_info_repository=TABLE    
relay_log=/data/relay-log          
log_slave_updates=ON               
sync-binlog=1                      
log-error=/data/error.log
pid-file=/data/mysqld.pid

transaction_write_set_extraction=XXHASH64         
loose-group_replication_group_name=&quot;aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa&quot;  
loose-group_replication_start_on_boot=off        
loose-group_replication_local_address=&quot;192.168.100.23:20003&quot;
loose-group_replication_group_seeds=&quot;192.168.100.21:20001,192.168.100.22:20002&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.连上新实例，设置恢复通道的凭据。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;change master to 
            master_user='repl',
            master_password='P@ssword1!'
            for channel 'group_replication_recovery';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.安装组复制插件，并启动组复制功能。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;install plugin group_replication soname 'group_replication.so';
start group_replication;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5.查看新节点是否已经处于ONLINE。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from performance_schema.replication_group_members\G&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;当加入一个新节点时，一切配置都正确，但是新节点死活就是不同步数据，随便执行一个语句都卡半天，查看&lt;code&gt;performance_schema.replication_group_members&lt;/code&gt;表时，还发现这个新节点一直处于recovering装态。&lt;/p&gt;
&lt;p&gt;这时，请查看新节点的错误日志。以下是我截取出来的一行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@xuexi ~]# tail /data/error.log 
2018-06-19T17:41:22.314085Z 10 [ERROR] Plugin group_replication reported: 'There was an error when connecting to the donor server. Please check that group_replication_recovery channel credentials and all MEMBER_HOST column values of performance_schema.replication_group_members table are correct and DNS resolvable.'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很显然，连接donor的时候出错，让我们检测通道凭据，并且查看member_host字段的主机名是否正确解析。一切正确配置的情况下，通道凭据是没错的，错就错在member_host的主机名。&lt;/p&gt;
&lt;p&gt;当和donor建立通道连接时，首先会通过member_host字段的主机名去解析donor的地址。这个主机名默认采取的是操作系统默认的主机名，而非ip地址。所以，必须设置DNS解析，或者/etc/hosts文件，将member_host对应的主机名解析为donor的ip地址。&lt;/p&gt;
&lt;p&gt;我这里之所以显示错误，是因为我在测试环境下，所有节点的主机名都相同：xuexi.longshuai.com。所以新节点会将这个主机名解析到本机。&lt;/p&gt;


&lt;p&gt;操作组复制的语句只有两个。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;start group_replication;
stop group_replication;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，和组复制相关的变量却有好几个。&lt;/p&gt;
&lt;p&gt;当要停止组中的某个成员中的组复制功能时，需要在那个节点上执行&lt;code&gt;stop group_replication&lt;/code&gt;语句。但一定要注意，在执行这个语句之前，必须要保证这个节点不会向外提供MySQL服务，否则有可能会有新数据写入(例如主节点停止时)，或者读取到过期数据。&lt;/p&gt;
&lt;p&gt;所以，要安全地&lt;strong&gt;重启整个组&lt;/strong&gt;，最佳方法是先停止所有非主节点的MySQL实例(不仅是停止组复制功能)，然后停止主节点的MySQL实例，再先重启主节点，在这个节点上引导组，并启动它的组复制功能。最后再将各slave节点加入组。&lt;/p&gt;
&lt;p&gt;如果只是想&lt;strong&gt;停止某单个节点&lt;/strong&gt;，如果这个节点是主节点，那么停止整个MySQL实例，如果是slave节点，那么只需停止它的组复制功能即可。当它们需要再次加组时，只需执行&lt;code&gt;start group_replication&lt;/code&gt;语句。&lt;/p&gt;
&lt;p&gt;那么，如何知道哪个节点是主节点？&lt;/p&gt;


&lt;p&gt;只有单主模型的组复制才需要查找主节点，多主模型没有master/slave的概念，所以无需查找。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; SELECT VARIABLE_VALUE FROM performance_schema.global_status 
       WHERE VARIABLE_NAME='group_replication_primary_member';
+--------------------------------------+
| VARIABLE_VALUE                       |
+--------------------------------------+
| a659234f-6aea-11e8-a361-000c29ed4cf4 |
+--------------------------------------+
1 row in set (0,00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; SHOW STATUS LIKE 'group_replication_primary_member';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样查找只是获取了主节点的uuid，可以表连接的方式获取主节点主机名。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select b.member_host the_master,a.variable_value master_uuid
    from performance_schema.global_status a
    join performance_schema.replication_group_members b
    on a.variable_value = b.member_id
    where variable_name='group_replication_primary_member';
+------------------+--------------------------------------+
| the_master       | master_uuid                          |
+------------------+--------------------------------------+
| s1.longshuai.com | a659234f-6aea-11e8-a361-000c29ed4cf4 |
+------------------+--------------------------------------+&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;目前，组中有3个节点：s1、s2和s3，其中s1是主节点。&lt;/p&gt;
&lt;p&gt;现在将主节点直接关机或者断掉网卡。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# s1上：
shell&amp;gt; ifconfig eth0 down&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后查看s2上的错误日志。可以看到选举新主节点的过程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Warning] group_replication reported: 'Member with address s1.longshuai.com:3306 has become unreachable.'
[Note] group_replication reported: '[GCS] Removing members that have failed while processing new view.'
[Warning] group_replication reported: 'Members removed from the group: s1.longshuai.com:3306'
[Note] group_replication reported: 'Primary server with address s1.longshuai.com:3306 left the group. Electing new Primary.'
[Note] group_replication reported: 'A new primary with address s2.longshuai.com:3306 was elected, enabling conflict detection until the new primary applies all relay logs.'
[Note] group_replication reported: 'This server is working as primary member.'
[Note] group_replication reported: 'Group membership changed to s2.longshuai.com:3306, s3.longshuai.com:3306 on view 15294358712349771:4.'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里将s2选为新的主节点，且告知成员视图中目前组中成员变为s2和s3。&lt;/p&gt;
&lt;p&gt;可以测试下，是否能向新的主节点s2中插入数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# s2上：
mysql&amp;gt; insert into gr_test.t4 values(333);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果再将s3停掉呢？还能继续写入数据吗？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 在s3上：
shell&amp;gt; ifconfig eth0 down&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回到s2，插入数据看看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# s2上：
mysql&amp;gt; insert into gr_test.t4 values(3333); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现无法插入，一直阻塞。&lt;/p&gt;
&lt;p&gt;查看下s2的错误日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Warning] group_replication reported: 'Member with address s3.longshuai.com:3306 has become unreachable.'
[ERROR] group_replication reported: 'This server is not able to reach a majority of members in the group. This server will now block all updates. The server will remain blocked until contact with the majority is restored. It is possible to use group_replication_force_members to force a new group membership.'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;已经说明了，s3移除后，组中的成员无法达到大多数的要求，所以将复制组给阻塞了。如果想要修复组，可以强制生成一个新的组成员视图。&lt;/p&gt;
&lt;p&gt;如果这时候，将s1和s3的网卡启动，s1和s3还会加入到组中吗？以下是s2上的错误日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Warning] group_replication reported: 'Member with address s3.longshuai.com:3306 is reachable again.'
[Warning] group_replication reported: 'The member has resumed contact with a majority of the members in the group. Regular operation is restored and transactions are unblocked.'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现s3加入了，但s1未加入。为什么？因为s1节点上只是停掉了网卡，mysql实例以及组复制功能还在运行，而且它的角色还保持为主节点。这时候，s1和s2、s3已经出现了所谓的&quot;网络分裂&quot;，对于s2和s3来说，s1被隔离，对于s1来说，s2和s3被隔离。当s1的网卡恢复后，它仍然保留着自己的主节点运行，但因为它达不到大多数的要求，所以s1是被阻塞的，如果网卡长时间没有恢复，则s1会被标记为ERROR。&lt;/p&gt;
&lt;p&gt;这种情况下的s1，要让它重新加入到组中，应该重启组复制，更安全的方法是重启mysql实例，因为组可能还没有标记为ERROR，这个组暂时还存在，它与s2、s3所属的组同名，可能会导致脑裂问题。&lt;/p&gt;
</description>
<pubDate>Wed, 20 Jun 2018 04:12:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9203154.html</dc:identifier>
</item>
<item>
<title>RabbitMQ入门：工作队列(Work Queue) - JAVA开发老菜鸟</title>
<link>http://www.cnblogs.com/sam-uncle/p/9202933.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sam-uncle/p/9202933.html</guid>
<description>
&lt;p&gt;在上一篇博客《&lt;a href=&quot;https://www.cnblogs.com/sam-uncle/p/9188426.html&quot; target=&quot;_blank&quot;&gt;RabbitMQ入门：Hello RabbitMQ 代码实例&lt;/a&gt;》中，我们通过指定的队列发送和接收消息，代码还算是比较简单的。&lt;/p&gt;
&lt;p&gt;假设有这一些比较耗时的任务，按照上一次的那种方式，我们要一直等前面的耗时任务完成了之后才能接着处理后面耗时的任务，那要等多久才能处理完？别担心，我们今天的主角--工作队列就可以解决该问题。我们将围绕下面这个索引展开：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;什么是工作队列&lt;/li&gt;
&lt;li&gt;代码准备&lt;/li&gt;
&lt;li&gt;循环分发&lt;/li&gt;
&lt;li&gt;消息确认&lt;/li&gt;
&lt;li&gt;公平分发&lt;/li&gt;
&lt;li&gt;消息持久化&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;废话少说，直接展开。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、什么是工作队列&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;工作队列--用来将耗时的任务分发给多个消费者（工作者），主要解决这样的问题：处理资源密集型任务，并且还要等他完成。有了工作队列，我们就可以将具体的工作放到后面去做，将工作封装为一个消息，发送到队列中，一个工作进程就可以取出消息并完成工作。如果启动了多个工作进程，那么工作就可以在多个进程间共享。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、代码准备&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;5.5&quot;&gt;生产者类:NewTask.java
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NewTask {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列名称&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String QUEUE_NAME = &quot;TASK_QUEUE&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列是否需要持久化&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; DURABLE = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要发送的消息列表&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String[] msgs = {&quot;task 1&quot;, &quot;task 2&quot;, &quot;task 3&quot;, &quot;task 4&quot;, &quot;task 5&quot;, &quot;task 6&quot;&lt;span&gt;};
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ConnectionFactory factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
        factory.setHost(&lt;/span&gt;&quot;localhost&quot;&lt;span&gt;);
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.connection &amp;amp; channel&lt;/span&gt;
            connection =&lt;span&gt; factory.newConnection();
            channel &lt;/span&gt;=&lt;span&gt; connection.createChannel();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.queue&lt;/span&gt;
            channel.queueDeclare(QUEUE_NAME, DURABLE, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.publish msg&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; msgs.length; i++&lt;span&gt;) {
                channel.basicPublish(&lt;/span&gt;&quot;&quot;, QUEUE_NAME, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, msgs[i].getBytes());
                System.out.println(&lt;/span&gt;&quot;** new task ****:&quot; +&lt;span&gt; msgs[i]);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (channel != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    channel.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
                    e.printStackTrace();
                }
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (connection != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    connection.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }

        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;4.5&quot;&gt;消费者类：Work.java
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Work {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        System.out.println(&lt;/span&gt;&quot;*** Work ***&quot;&lt;span&gt;);
        ConnectionFactory factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
        factory.setHost(&lt;/span&gt;&quot;localhost&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.connection &amp;amp; channel&lt;/span&gt;
            &lt;span&gt;final&lt;/span&gt; Channel channel =&lt;span&gt; factory.newConnection().createChannel();
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.queue&lt;/span&gt;
            channel.queueDeclare(NewTask.QUEUE_NAME, NewTask.DURABLE, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3. consumer instance&lt;/span&gt;
            Consumer consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultConsumer(channel) {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties,
                        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] body) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
                    String msg &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(body, &quot;UTF-8&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;deal task&lt;/span&gt;
&lt;span&gt;                    doWork(msg);

                }
            };
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.do consumer&lt;/span&gt;
            &lt;span&gt;boolean&lt;/span&gt; autoAck = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            channel.basicConsume(NewTask.QUEUE_NAME, autoAck, consumer);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
            e.printStackTrace();
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doWork(String msg) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;**** deal task begin :&quot; +&lt;span&gt; msg);
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;假装task比较耗时，通过sleep（）来模拟需要消耗的时间&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (&quot;sleep&quot;&lt;span&gt;.equals(msg)) {
                Thread.sleep(&lt;/span&gt;1000 * 60&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
            }

            System.out.println(&lt;/span&gt;&quot;**** deal task finish :&quot; +&lt;span&gt; msg);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;再来一个消费者类:Work2.java，代码同Work.java一模一样。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、循环分发&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们先启动Work和Work2，然后启动NewTask，运行结果如下：&lt;/p&gt;
&lt;p&gt;NewTask运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180620100444051-1410840262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Work运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180620100528522-1130304468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Work2运行结果:&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180620100602077-466120943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们发现，消息生产者发送了6条消息，消费者work和work2分别分到了3个消息，而且是循环轮流分发到的，这种分发的方式就是循环分发。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、消息确认&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;假如我们在发送的消息里面添加“sleep&quot;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要发送的消息列表&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String[] msgs = {&lt;strong&gt;&quot;sleep&quot;,&lt;/strong&gt; &quot;task 1&quot;, &quot;task 2&quot;, &quot;task 3&quot;, &quot;task 4&quot;, &quot;task 5&quot;, &quot;task 6&quot;};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据代码中的实现，这个sleep要耗时1分钟，万一在这1分钟之内，工作进程崩溃了或者被kill了，会发生什么情况呢？根据上面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.do consumer&lt;/span&gt;
            &lt;span&gt;boolean&lt;/span&gt; autoAck = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            channel.basicConsume(NewTask.QUEUE_NAME, autoAck, consumer);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自动确认为true，每次RabbitMQ向消费者发送消息之后，会自动发确认消息（我工作你放心，不会有问题），这个时候消息会立即从内存中删除。如果工作者挂了，那将会&lt;strong&gt;丢失它正在处理和未处理的所有工作，而且这些工作还不能再交由其他工作者处理，这种丢失属于客户端丢失。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们来验证下，和刚才的步骤一样执行程序：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;.NewTask的控制台打印结果：
&lt;/span&gt;** &lt;span&gt;new&lt;/span&gt; task ****&lt;span&gt;:sleep
&lt;/span&gt;** &lt;span&gt;new&lt;/span&gt; task ****:task 1
** &lt;span&gt;new&lt;/span&gt; task ****:task 2
** &lt;span&gt;new&lt;/span&gt; task ****:task 3
** &lt;span&gt;new&lt;/span&gt; task ****:task 4
** &lt;span&gt;new&lt;/span&gt; task ****:task 5
** &lt;span&gt;new&lt;/span&gt; task ****:task 6

2&lt;span&gt;.Work的控制台打印结果：
&lt;/span&gt;****&lt;span&gt; deal task begin :sleep

&lt;/span&gt;3&lt;span&gt;.Work2的控制台打印结果：
&lt;/span&gt;**** deal task begin :task 1
**** deal task finish :task 1
**** deal task begin :task 3
**** deal task finish :task 3
**** deal task begin :task 5
**** deal task finish :task 5
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据上面的内容，消息生产者发送了7条消息， work2消费了1、3、5 三条，那剩下的sleep、2、4、6 这四条消息肯定是work来处理，只是sleep耗时一分钟 ，时间差后面的还没来得及处理，这个时候我们kill掉work，去看下RabbitMQ 管理页面，没有未处理的消息，消息随着work被kill也跟着丢失了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180620103942717-482404302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是很可怕？&lt;/p&gt;
&lt;p&gt;为了应对这种情况，RabbitMQ支持消息确认。消费者处理完消息之后，会发送一个确认消息告诉RabbitMQ，消息处理完了，你可以删掉它了。&lt;/p&gt;
&lt;p&gt;代码修改（Work.java和Work2.java同步修改）：1.将自动确认改为false，2.消息处理之后再通过channel.basicAck进行消息确认&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180620103109946-1111173774.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 修改完后，执行程序：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;.NewTask的控制台打印结果：
&lt;/span&gt;** &lt;span&gt;new&lt;/span&gt; task ****&lt;span&gt;:sleep
&lt;/span&gt;** &lt;span&gt;new&lt;/span&gt; task ****:task 1
** &lt;span&gt;new&lt;/span&gt; task ****:task 2
** &lt;span&gt;new&lt;/span&gt; task ****:task 3
** &lt;span&gt;new&lt;/span&gt; task ****:task 4
** &lt;span&gt;new&lt;/span&gt; task ****:task 5
** &lt;span&gt;new&lt;/span&gt; task ****:task 6

2&lt;span&gt;.Work的控制台打印结果：
&lt;/span&gt;****&lt;span&gt; deal task begin :sleep

&lt;/span&gt;3&lt;span&gt;.Work2的控制台打印结果：
&lt;/span&gt;**** deal task begin :task 1
**** deal task finish :task 1
**** deal task begin :task 3
**** deal task finish :task 3
**** deal task begin :task 5
**** deal task finish :task 5
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后kill掉work，去看RabbitMQ管理页面，会发现有4条未确认：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180620104342159-491313013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再去看下work2的控制台，work2将work未处理完和未来得及处理的消息都给处理了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180620104539989-1345908201.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;等work2处理完后，你再去看RabbitMQ管理页面，会发现页面的消息数值也都变成0 了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、公平分发&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;按照上面那种循环分发的方式，每个消费者会分到&lt;strong&gt;相同数量&lt;/strong&gt;的任务，这样会有一个问题：假如有一些task非常耗时，之前的任务还没有完成，后面又来了那么多任务，来不及处理，那咋办？ 有的消费者忙的不可开交，有的消费者却很快处理完事情然后无所事事浪费资源，那咋整？答案就是：公平分发。 怎么实现呢？&lt;/p&gt;
&lt;p&gt; 发生上述问题的原因就是RabbitMQ收到消息后就立即分发出去，而没有确认各个工作者未返回确认的消息数量。因此我们可以使用&lt;code&gt;basicQos&lt;/code&gt;方法，并将参数&lt;code&gt;prefetchCount&lt;/code&gt;设为1，告诉RabbitMQ 我每次值处理一条消息，你要等我处理完了再分给我下一个。这样RabbitMQ就不会轮流分发了，而是寻找空闲的工作者进行分发。&lt;/p&gt;
&lt;p&gt;代码修改（work和Work2同步修改）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180620105838980-149450746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;.NewTask的控制台打印结果：
&lt;/span&gt;** &lt;span&gt;new&lt;/span&gt; task ****&lt;span&gt;:sleep
&lt;/span&gt;** &lt;span&gt;new&lt;/span&gt; task ****:task 1
** &lt;span&gt;new&lt;/span&gt; task ****:task 2
** &lt;span&gt;new&lt;/span&gt; task ****:task 3
** &lt;span&gt;new&lt;/span&gt; task ****:task 4
** &lt;span&gt;new&lt;/span&gt; task ****:task 5
** &lt;span&gt;new&lt;/span&gt; task ****:task 6

2&lt;span&gt;.Work的控制台打印结果：
&lt;/span&gt;****&lt;span&gt; deal task begin :sleep
&lt;/span&gt;****&lt;span&gt; deal task finish :sleep

&lt;/span&gt;3&lt;span&gt;.Work2的控制台打印结果：
&lt;/span&gt;**** deal task begin :task 1
**** deal task finish :task 1
**** deal task begin :task 2
**** deal task finish :task 2
**** deal task begin :task 3
**** deal task finish :task 3
**** deal task begin :task 4
**** deal task finish :task 4
**** deal task begin :task 5
**** deal task finish :task 5
**** deal task begin :task 6
**** deal task finish :task 6
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Work只处理了sleep，Work2处理了1、2、3、4、5、6 这个六条消息。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、消息持久化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面说到消息确认的时候，提到了工作者被kill的情况。那如果RabbitMQ被stop掉了呢？我们来看下：&lt;/p&gt;
&lt;p&gt;这次只启动Work和NewTask，不启动Work2，所有消息都交给Work来处理，控制台打印信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;.NewTask的控制台打印结果：
&lt;/span&gt;** &lt;span&gt;new&lt;/span&gt; task ****&lt;span&gt;:sleep
&lt;/span&gt;** &lt;span&gt;new&lt;/span&gt; task ****:task 1
** &lt;span&gt;new&lt;/span&gt; task ****:task 2
** &lt;span&gt;new&lt;/span&gt; task ****:task 3
** &lt;span&gt;new&lt;/span&gt; task ****:task 4
** &lt;span&gt;new&lt;/span&gt; task ****:task 5
** &lt;span&gt;new&lt;/span&gt; task ****:task 6

2&lt;span&gt;.Work的控制台打印结果：
&lt;/span&gt;**** deal task begin :sleep
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在work处理sleep的过程中，我们停掉RabbitMQ服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180620110939126-1826986799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后重新start服务并执行rabbitmq-plugins enable rabbitmq_management命令，然后查看管理页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180620111131210-233372474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你会发现，所有消息都将被清空了。这种丢失属于&lt;strong&gt;服务端丢失&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此需要将消息进行持久化来应对这种情况。&lt;/p&gt;
&lt;p&gt;持久化需要做两件事情：&lt;/p&gt;
&lt;ol readability=&quot;-1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;队列持久化，在声明队列的时候，将第二个参数设为true&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180620111451543-757865464.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;　　    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180620111510491-890634936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 另外，由于RabbitMQ不允许重新定义已经存在的队列，否则就会报错（上一篇博客中已经提到过了），因此我们将这次的队列名改下：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180620112147484-248870583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;消息持久化，在发送消息的时候，将第三个参数设为2&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180620111700148-1229241652.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然后运行代码，在work处理sleep的时候将服务停掉，并重新启动且执行rabbitmq-plugins enable rabbitmq_management命令，然后查看管理页面：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180620112300827-442835646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一共7条消息，未确认的1条（sleep）和ready的6条（1、2、3、4、5、6）。消息被保存了下来。&lt;/p&gt;
&lt;p&gt; 重新启动Work，所有消息被消费：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180620113443065-50749905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180620113506604-330670776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 20 Jun 2018 03:35:00 +0000</pubDate>
<dc:creator>JAVA开发老菜鸟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sam-uncle/p/9202933.html</dc:identifier>
</item>
<item>
<title>聊聊北京大部分前端从业者所面临的困境 - 闰土大叔</title>
<link>http://www.cnblogs.com/running-runtu/p/9202956.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/running-runtu/p/9202956.html</guid>
<description>&lt;p&gt;国内一线城市，首推北京、上海、广州、深圳，而在这四个强一线城市中互联网氛围最浓厚的，尤其以北京最为典型。那么我们就从北京这个大背景下开始聊起。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;从闲谈说开去&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从今天起，我拥有了一个新朋友，他叫王小闰（花名），目前在北京西二旗附近从事前端开发。今天他在微信上跟我聊起，自认为混的一般，想要奋进一把。&lt;/p&gt;

&lt;p&gt;然后我就问他，你目前在帝都月薪多少K？他还不好意思，说出来嫌丢人。我说没关系的，我目前在太原6K，这没什么可丢人的，勇敢地说出来吧~&lt;/p&gt;

&lt;p&gt;我似乎捅开了他的话匣子，由于我的坦诚，他瞬间放下了包袱，跟我攀谈起来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;聊聊业务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;他说，我在北京月薪才14K，目前的情况就是处于组长让我做什么我就做什么，项目架构都是组长搭建好的。&lt;/p&gt;

&lt;p&gt;然后我就问他，在你心里，你认为什么是项目架构？&lt;/p&gt;

&lt;p&gt;他说，就是搭项目，不使用类似于vue-cli这样的脚手架，npm安装一路回车就OK了。真正的项目架构是从零开始搭建项目的工程目录，这样是按照公司的一些标准来定制的。&lt;/p&gt;

&lt;p&gt;然后他继续说，反正我在工作中也接触不上，目前我这边就是最底层的干活，想接触高级的东西，能力够不到。一般就是，项目过来了，组长开始规划时间节点，然后分配业务块。一句话总结就是，目前处于写业务的阶段，所以感觉混得也很垃圾。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;聊聊培训班及后来者&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;让他迷茫的还不止这些，身边的95后、00后崛起的也比较迅速，培训班层层叠叠，现在培训班讲师直接培训的是vue，是react，是node，是webpack。而且现在大多数讲师技术都很厉害，直接讲的都是项目中实战用的干货。&lt;/p&gt;

&lt;p&gt;而当初我们在培训班的时候老师讲的是js（偏dom操作和事件处理），jQuery，bootstrap，而现在这些技术不能说落伍，只能说不算热门。&lt;/p&gt;

&lt;p&gt;如果你学习能力较强，尚能追赶上上前端发展的浪潮，当MVVM时代的弄潮儿。假如你学习能力较弱，只能眼巴巴地看着比自己年轻的前端er抢走自己的饭碗，因为00后培训完出来，要的薪资相对少啊，10K、11K就愿意干，有的甚至8K也做。同样是干活儿，技术可能还不比你差，面试官当然不待见我们这些薪资要的高的。&lt;/p&gt;

&lt;p&gt;当然，如果我们相对够坚强，这还不算什么，打击更严重的还在后头。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;聊聊去大厂的面试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前几天出去面试，碰了一鼻子灰。&lt;/p&gt;

&lt;p&gt;他停顿了一下，然后继续跟我讲，我现在不是想去一些大公司工作顺便镀镀金嘛，然后就投了宜信。巧的是，那边也让我去面试了。后来我就去了，面试官是个男的，看起来30多岁，一看就是经常加班 黑眼圈巨重，有点秃顶，戴着一个标准的程序员黑框眼镜，身材不胖也不瘦，上身穿着一件白体恤，感觉有点脏，下身穿着一条蓝色牛仔裤，鞋子没仔细看。&lt;/p&gt;

&lt;p&gt;这个大概就是宜信的前端leader了吧~&lt;/p&gt;


&lt;p&gt;在一番自我介绍之后，打击开始了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;聊聊我的世界观是如何轰然坍塌的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;面试官说，首先你的学历一般，反正这个学校我没听过。我这边是不缺985、211这些学历的。&lt;/p&gt;

&lt;p&gt;其次，你的工作年限其实也不长不短了，你没有做出什么成绩，业务上也没有稳定的路线，在我这来说，很一般。&lt;/p&gt;

&lt;p&gt;最后来说说你的技能点，也还是很一般，vue在我们公司是入门的门槛，进来的前端都很精通。Node你了解的一般，React你也是了解的一般，技能点在我这儿，也是一般。&lt;/p&gt;

&lt;p&gt;最后，面试官问了我朋友一个问题，你觉得就我现在对你的评价，我凭什么要你？&lt;/p&gt;

&lt;p&gt;然后，王小闰被怼的哑口无言，遗憾败北。&lt;/p&gt;

&lt;p&gt;这次面试对我的朋友王小闰来说，打击的不是一点半点，我甚至觉得都在他心里产生阴影了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;聊聊这次面试的感悟&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;但是等我朋友回了家心情平静下来之后，他觉得，其实面试官说的也不无道理。像咱们技术人在入行头几年里，都不知道自己到底要去什么公司工作。频繁的换工作，目的只是为了涨工资。坊间有句不成文的规定，程序员不跳槽不涨薪。&lt;/p&gt;

&lt;p&gt;然而，从面试官那里，我也深刻认识到，其实业务线也很重要。比如说我现在去面试，我会选择金融行业去，在面试的时候我会说，我有几年金融行业的业务经验。这样也很加分。&lt;/p&gt;

&lt;p&gt;我觉得这个问题就很有代表性。行业有很多，比如教育、房地产、医美、旅游等，我想告诉后来者的是，大家不要盲目跳槽，一味地只关注工资。因为到年纪大的时候，我们更想要去的是一家大公司，社保待遇福利齐全，可以稳定发展的，而不是到时候跳来跳去。那这个时候，业务线就很关键。&lt;/p&gt;

&lt;p&gt;当然，除了业务线，本身的技术沉淀也很重要。&lt;/p&gt;

&lt;p&gt;说到这里，我的朋友王小闰叹了口气，目前我的这个工作年限就很尴尬，不长不短，技术沉淀也不是很好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;聊聊北京面试的一些现象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;说完这个，在北京还有一个很典型的现象是：很多面试官会觉得vue很简单，都不能作为衡量你技术的标准，类似于早几年的jQuery。&lt;/p&gt;

&lt;p&gt;然后面试官就会问你一些React、node、webpack的知识。但是进来公司以后，能在项目中接触到的还是vue，那我就会觉得，面试官对vue从业者的态度，我不敢苟同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;聊聊你的期望薪资&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可能有人会问了，那你朋友王小闰去宜信应聘，简历上写的期望薪资是多少啊？&lt;/p&gt;

&lt;p&gt;当然，这是个好问题，我也是这么问王小闰的。&lt;/p&gt;

&lt;p&gt;然后，他告诉我，他写的是17K。&lt;/p&gt;

&lt;p&gt;至此，又诞生了另一种角度来解读那场面试，有一种可能，面试官是根据你填写的薪资来选择对号入座的面试题的，看薪资定级别。&lt;/p&gt;

&lt;p&gt;我的朋友王小闰也表示赞同这种说法，然后继续跟我说，所以说我现在个人觉得，能力有限，发展出现瓶颈，工资也还是上不去，虽然内心很想改善目前的处境。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;聊聊我朋友目前的想法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当然，他还跟我谈到了vue，他现在觉得，想要更深一步，去理解vue，还是要看源码。还有vue的服务端渲染，vue的响应式原理等，今年在北京面试也是火爆，以前是不会问到的。&lt;/p&gt;

&lt;p&gt;故事聊到这儿，也算是倾诉告一段落。&lt;strong&gt;我把这次聊天内容写出来，也是想总结点经验告诉后来者，让后来的前端童鞋有所感悟。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;文末彩蛋&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我猜这就是大部分在北京漂泊的前端从业者遇到的职业瓶颈，上不去，下不来，卡在中间甚是难受。如果你们也有如此困惑，为此感到迷茫不知所措，想摆脱目前的困境，欢迎翻阅我的另一篇文章《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIyNDg5MzM4Ng==&amp;amp;mid=2247484209&amp;amp;idx=1&amp;amp;sn=c93e383f2927f64d2308f25d6eac92ee&amp;amp;chksm=e8094394df7eca82c5ce1e4d3b285b8e7a9cddd617e4a53e1ca992b4de9713c7642d4a61cdc5&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;闰土杂谈（三）：如何在公司里体现前端的价值以及提升自己的议价能力？&lt;/a&gt;》，这篇文章或许会给你一点点答案。&lt;/p&gt;

&lt;p&gt;---&lt;/p&gt;

&lt;p&gt;更多文章我会第一时间更新在公众号&amp;lt;闰土大叔&amp;gt;里面，欢迎关注~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201806/701424-20180620113303334-885593351.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 Jun 2018 03:34:00 +0000</pubDate>
<dc:creator>闰土大叔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/running-runtu/p/9202956.html</dc:identifier>
</item>
<item>
<title>领域建模 - significantfrank</title>
<link>http://www.cnblogs.com/significantfrank/p/9202663.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/significantfrank/p/9202663.html</guid>
<description>&lt;p&gt;80后程序员都知道，我们国家“系统分析师” 和“系统设计师” 是两种不同的职称考试，也就是分析系统和设计系统不是同一个人，这种割裂导致需求分析的结果无法直接进行设计编程，而能够进行编程运行的代码却扭曲需求，导致客户运行软件后才发现很多功能不是自己想要的，而且软件不能快速跟随需求变化。&lt;/p&gt;
&lt;p&gt;DDD则打破了这种隔阂，提出了领域模型概念，统一了分析和设计编程，使得软件能够更灵活快速跟随需求变化。&lt;/p&gt;
&lt;h2 id=&quot;后端技术演变&quot;&gt;后端技术演变&lt;/h2&gt;
&lt;p&gt;服务器后端发展主要可以分成三个阶段： &lt;br/&gt;1. UI+DataBase的两层架构，这种面向数据库的架构没有灵活性。 &lt;br/&gt;2. UI+Service+DataBase的多层SOA架构，这种服务+表模型的架构易使服务变得囊肿，难于维护拓展，伸缩性能差，这也是Spring Web 应用的最大败笔. &lt;br/&gt;3. DDD+SOA的事件驱动的CQRS读写分离架构，应付复杂业务逻辑，以聚合模型替代数据表模型，以并发的事件驱动替代串联的消息驱动。真正实现以业务实体为核心的灵活拓展。 &lt;br/&gt;以DDD为代表的开发模式与传统CRUD或过程脚本或者面向数据表等在开发效率上比较如下： &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/572b98f111ddadacbf6d23e246288006.png&quot; alt=&quot;image.png&quot;/&gt; &lt;br/&gt;对于&lt;a href=&quot;https://martinfowler.com/eaaCatalog/transactionScript.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;事务脚本&lt;/a&gt;，一句话概括就是“上手容易，维护难”&lt;/p&gt;
&lt;h2 id=&quot;ddd革命&quot;&gt;DDD革命&lt;/h2&gt;
&lt;p&gt;DDD革命性在于，领域模型准确反映了业务语言，而传统J2EE或Spring+Hibernate等事务性编程模型只关心数据，这些数据对象除了简单setter/getter方法外，没有任何业务方法，被比喻成&lt;a href=&quot;https://martinfowler.com/bliki/AnemicDomainModel.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;贫血模式&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;以银行账号Account为案例，Account有“存款”，“计算利息”和“取款”等业务行为，但是传统经典的方式是将“存款”，“计算利息”和“取款”行为放在账号的服务AccountService中，而不是放在Account对象本身之中。我们不能因为用了计算机，用了数据库，用了框架，业务模型反而被技术框架给绑架了，就像人虽然是由母亲生的，但是人的吃喝拉撒母亲不能替代，更不能以母爱名义剥夺人的正常职责行为，如果是这样，这个人就是被母爱绑架了。&lt;/p&gt;
&lt;h2 id=&quot;ddd不是银弹&quot;&gt;DDD不是银弹&lt;/h2&gt;
&lt;p&gt;软件的世界里没有银弹，是用&lt;a href=&quot;https://martinfowler.com/eaaCatalog/transactionScript.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;事务脚本&lt;/a&gt;还是&lt;a href=&quot;https://martinfowler.com/eaaCatalog/domainModel.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;领域模型&lt;/a&gt;没有对错之分，关键看是否合适。就像自营和平台哪个模式更好？答案是都很好，所以亚马逊可以有三方入住，阿里也可以有自建仓嘛。&lt;/p&gt;
&lt;p&gt;实际上，CQRS就是对事务脚本和领域模型两种模式的综合，因为对于Query和报表的场景，使用领域模型往往会把简单的事情弄复杂，此时完全可以用奥卡姆剃刀把领域层剃掉，直接访问Infrastructure。&lt;/p&gt;
&lt;p&gt;我个人也是坚决反对过度设计的，因此对于简单业务场景，我强力建议还是使用事务脚本，其优点是简单、直观、易上手。但对于复杂的业务场景，你再这么玩就不行了，因为一旦业务变得复杂，事务脚本就很难应对，容易造成代码的“一锅粥”，系统的腐化速度和复杂性呈指数级上升。目前比较有效的治理办法就是领域建模，因为领域模型是面向对象的，在封装业务逻辑的同时，提升了对象的内聚性和重用性，因为使用了通用语言（&lt;a href=&quot;https://martinfowler.com/bliki/UbiquitousLanguage.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Ubiquitous Language&lt;/a&gt;），使得隐藏的业务逻辑得到显性化表达，使得复杂性治理成为可能。&lt;/p&gt;
&lt;p&gt;接下来，让我们看一个银行转账的实例，对比下事务脚本和领域模型两者编程模型的不同。&lt;/p&gt;

&lt;h2 id=&quot;银行转账事务脚本实现&quot;&gt;银行转账事务脚本实现&lt;/h2&gt;
&lt;p&gt;在事务脚本的实现中，关于在两个账号之间转账的领域业务逻辑都被写在了&lt;code&gt;MoneyTransferService&lt;/code&gt;的实现里面了，而Account仅仅是getters和setters的数据结构，也就是我们说的贫血模型：&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;language-java hljs has-numbering&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;MoneyTransferServiceTransactionScriptImpl
      &lt;span class=&quot;hljs-keyword&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;MoneyTransferService {
  &lt;span class=&quot;hljs-keyword&quot;&gt;private AccountDao accountDao;
  &lt;span class=&quot;hljs-keyword&quot;&gt;private BankingTransactionRepository bankingTransactionRepository;
  . . .
  &lt;span class=&quot;hljs-annotation&quot;&gt;@Override
  &lt;span class=&quot;hljs-keyword&quot;&gt;public BankingTransaction &lt;span class=&quot;hljs-title&quot;&gt;transfer(
      String fromAccountId, String toAccountId, &lt;span class=&quot;hljs-keyword&quot;&gt;double amount) {
    Account fromAccount = accountDao.findById(fromAccountId);
    Account toAccount = accountDao.findById(toAccountId);
    . . .
    &lt;span class=&quot;hljs-keyword&quot;&gt;double newBalance = fromAccount.getBalance() - amount;
    &lt;span class=&quot;hljs-keyword&quot;&gt;switch (fromAccount.getOverdraftPolicy()) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;case NEVER:
      &lt;span class=&quot;hljs-keyword&quot;&gt;if (newBalance &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;throw &lt;span class=&quot;hljs-keyword&quot;&gt;new DebitException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Insufficient funds&quot;);
      }
      &lt;span class=&quot;hljs-keyword&quot;&gt;break;
    &lt;span class=&quot;hljs-keyword&quot;&gt;case ALLOWED:
      &lt;span class=&quot;hljs-keyword&quot;&gt;if (newBalance &amp;lt; -limit) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;throw &lt;span class=&quot;hljs-keyword&quot;&gt;new DebitException(
            &lt;span class=&quot;hljs-string&quot;&gt;&quot;Overdraft limit (of &quot; + limit + &lt;span class=&quot;hljs-string&quot;&gt;&quot;) exceeded: &quot; + newBalance);
      }
      &lt;span class=&quot;hljs-keyword&quot;&gt;break;
    }
    fromAccount.setBalance(newBalance);
    toAccount.setBalance(toAccount.getBalance() + amount);
    BankingTransaction moneyTransferTransaction =
        &lt;span class=&quot;hljs-keyword&quot;&gt;new MoneyTranferTransaction(fromAccountId, toAccountId, amount);
    bankingTransactionRepository.addTransaction(moneyTransferTransaction);
    &lt;span class=&quot;hljs-keyword&quot;&gt;return moneyTransferTransaction;
  }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;上面的代码大家看起来应该比较眼熟，因为目前大部分系统都是这么写的。需求评审完，工程师画几张UML图完成设计，就开始向上面这样怼业务代码了，这样写基本不用太费脑，完全是面向过程的代码风格。有些同学可能会说，我这样写也可以实现系统功能啊，还是那句话“just because you can, doesn’t mean you should”。说句不好听的，正是有这么多“没有追求”、“不求上进”的码农才造成了应用系统的混乱、败坏了应用开发的名声。这也是为什么很多应用开发工程师觉得工作没意思，技术含量低，觉得整天就是写if-else的业务逻辑代码，系统又烂，工作繁琐、无聊、没有成长、没有成就感，所以转向去做中间件啊，去写JDK啊，觉得那个NB。实际上，应用开发一点都不简单也不无聊，业务的变化比底层Infrastructure的变化要多得多，解决的难度也丝毫不比写底层代码容易，只是很多人选择了用无聊的方式去做。其实我们是有办法做的更优雅的，这种优雅的方式就是领域建模，唯有掌握了这种优雅你才能实现从工程师向应用架构的转型。同样的业务逻辑，接下来就让我们看一下用DDD是怎么做的。&lt;/p&gt;
&lt;h2 id=&quot;银行转账领域模型实现&quot;&gt;银行转账领域模型实现&lt;/h2&gt;
&lt;p&gt;如果用DDD的方式实现，Account实体除了账号属性之外，还包含了行为和业务逻辑，比如&lt;code&gt;debit( )&lt;/code&gt;和&lt;code&gt;credit( )&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;language-java hljs has-numbering&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;而且透支策略&lt;code&gt;OverdraftPolicy&lt;/code&gt;也不仅仅是一个Enum了，而是被抽象成包含了业务规则并采用了策略模式的对象。&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;language-java hljs has-numbering&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface &lt;span class=&quot;hljs-title&quot;&gt;OverdraftPolicy {
  &lt;span class=&quot;hljs-keyword&quot;&gt;void preDebit(Account account, &lt;span class=&quot;hljs-keyword&quot;&gt;double amount);
  &lt;span class=&quot;hljs-keyword&quot;&gt;void postDebit(Account account, &lt;span class=&quot;hljs-keyword&quot;&gt;double amount);
}
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;NoOverdraftAllowed &lt;span class=&quot;hljs-keyword&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;OverdraftPolicy {
  &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;preDebit(Account account, &lt;span class=&quot;hljs-keyword&quot;&gt;double amount) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;double newBalance = account.balance() - amount;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if (newBalance &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0) {
      &lt;span class=&quot;hljs-keyword&quot;&gt;throw &lt;span class=&quot;hljs-keyword&quot;&gt;new DebitException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Insufficient funds&quot;);
    }
  }
  &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;postDebit(Account account, &lt;span class=&quot;hljs-keyword&quot;&gt;double amount) {
  }
}
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;LimitedOverdraft &lt;span class=&quot;hljs-keyword&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;OverdraftPolicy {
  &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;double limit;
  . . .
  &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;preDebit(Account account, &lt;span class=&quot;hljs-keyword&quot;&gt;double amount) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;double newBalance = account.balance() - amount;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if (newBalance &amp;lt; -limit) {
      &lt;span class=&quot;hljs-keyword&quot;&gt;throw &lt;span class=&quot;hljs-keyword&quot;&gt;new DebitException(
          &lt;span class=&quot;hljs-string&quot;&gt;&quot;Overdraft limit (of &quot; + limit + &lt;span class=&quot;hljs-string&quot;&gt;&quot;) exceeded: &quot; + newBalance);
    }
  }
  &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;postDebit(Account account, &lt;span class=&quot;hljs-keyword&quot;&gt;double amount) {
  }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而Domain Service只需要调用Domain Entity对象完成业务逻辑即可。&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;language-java hljs has-numbering&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;MoneyTransferServiceDomainModelImpl
      &lt;span class=&quot;hljs-keyword&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;MoneyTransferService {
  &lt;span class=&quot;hljs-keyword&quot;&gt;private AccountRepository accountRepository;
  &lt;span class=&quot;hljs-keyword&quot;&gt;private BankingTransactionRepository bankingTransactionRepository;
  . . .
  &lt;span class=&quot;hljs-annotation&quot;&gt;@Override
  &lt;span class=&quot;hljs-keyword&quot;&gt;public BankingTransaction &lt;span class=&quot;hljs-title&quot;&gt;transfer(
      String fromAccountId, String toAccountId, &lt;span class=&quot;hljs-keyword&quot;&gt;double amount) {
    Account fromAccount = accountRepository.findById(fromAccountId);
    Account toAccount = accountRepository.findById(toAccountId);
    . . .
    fromAccount.debit(amount);
    toAccount.credit(amount);
    BankingTransaction moneyTransferTransaction =
        &lt;span class=&quot;hljs-keyword&quot;&gt;new MoneyTranferTransaction(fromAccountId, toAccountId, amount);
    bankingTransactionRepository.addTransaction(moneyTransferTransaction);
    &lt;span class=&quot;hljs-keyword&quot;&gt;return moneyTransferTransaction;
  }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的DDD重构后，原来在事务脚本中的逻辑，被分散到Domain Service，Domain Entity和OverdraftPolicy三个满足SOLID的对象中，在继续阅读之前，我建议可以自己先体会一下DDD的好处。&lt;/p&gt;

&lt;p&gt;DDD最大的好处是：接触到需求第一步就是考虑领域模型，而不是将其切割成数据和行为，然后数据用数据库实现，行为使用服务实现，最后造成需求的首肢分离。DDD让你首先考虑的是业务语言，而不是数据。DDD强调业务抽象和面向对象编程，而不是过程式业务逻辑实现。&lt;span&gt;重点不同导致编程世界观不同&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id=&quot;面向对象&quot;&gt;面向对象&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;封装：Account的相关操作都封装在Account Entity上，提高了内聚性和可重用性。&lt;/li&gt;
&lt;li&gt;多态：采用策略模式的OverdraftPolicy（多态的典型应用）提高了代码的可扩展性。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;业务语义显性化&quot;&gt;业务语义显性化&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;通用语言：&lt;span&gt;“一个团队，一种语言”&lt;/span&gt;，将模型作为语言的支柱。确保团队在内部的所有交流中，代码中，画图，写东西，特别是讲话的时候都要使用这种语言。例如账号，转账，透支策略，这些都是非常重要的领域概念，如果这些命名都和我们日常讨论以及PRD中的描述保持一致，将会极大提升代码的可读性，减少认知成本。说到这，稍微吐槽一下我们有些工程师的英语水平，有些神翻译让一些核心领域概念变得面目全非。&lt;/li&gt;
&lt;li&gt;显性化：就是将隐式的业务逻辑从一推if-else里面抽取出来，用通用语言去命名、去写代码、去扩展，让其变成显示概念，比如“透支策略”这个重要的业务概念，按照事务脚本的写法，其含义完全淹没在代码逻辑中没有突显出来，看代码的人自然也是一脸懵逼，而领域模型里面将其用策略模式抽象出来，不仅提高了代码的可读性，可扩展性也好了很多。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;初步建模&quot;&gt;初步建模&lt;/h2&gt;
&lt;p&gt;领域建模这个话题太大，关于此的长篇大论和书籍也很多，比如什么通过语法和句法深入分析法，在我看来这些方法论有些繁琐了。好的模型应该是建立在对业务深入理解的基础上，如果业务理解不到位，你再怎么分析句子也不可能产出好的模型。就我自己的经验而言，建模也是一个不断迭代的过程，所以一开始可以简单点来，就采用两步建模法抓住一些核心概念，然后假设一些业务场景走查一下，再写一些伪代码验证一下run一下，看看顺不顺，如果很顺滑，说明没毛病，否则就要看看是不是需要调整一下模型，随着项目的进行和对业务理解的不断深入，这种迭代将持续进行。&lt;/p&gt;
&lt;p&gt;那什么是两步建模法呢？也就是只需要两个步骤就能建模了，首先从User Story找名词和动词，然后用UML类图画出领域模型。是不是很简约？简约并不意味着简单，对于业务架构师和系统分析师来说，见功力的地方往往就在于此。&lt;/p&gt;
&lt;p&gt;举个栗子，比如让你设计一个中介系统，一个典型的User Story可能是&lt;span&gt;“小明去找工作，中介说你留个电话，有工作机会我会通知你”&lt;/span&gt;，这里面的&lt;span&gt;关键名词&lt;/span&gt;很可能就是我们需要的领域对象： &lt;br/&gt;- &lt;span&gt;小明&lt;/span&gt;是求职者。 &lt;br/&gt;- &lt;span&gt;电话&lt;/span&gt;是求职者的属性。 &lt;br/&gt;- &lt;span&gt;中介&lt;/span&gt;包含了中介公司，中介员工两个关键对象。 &lt;br/&gt;- &lt;span&gt;工作机会&lt;/span&gt;肯定也是关键领域对象； &lt;br/&gt;- &lt;span&gt;通知&lt;/span&gt;这个动词暗示我们这里用观察者模式会比较合适。&lt;/p&gt;
&lt;p&gt;然后再梳理一下领域对象之间的关系，一个求职者可以应聘多个工作机会，一个工作机会也可以被多个求职者应聘，M2M的关系，中介公司可以包含多个员工，O2M的关系。对于这样简单的场景，这个建模就差不多了。&lt;/p&gt;
&lt;p&gt;当然我们的业务场景往往比这个要复杂，而且不是所有的名词都是领域对象也可能是属性，也不是所有的动词都是方法也可能是领域对象，再者，看的见实体好找，看不见的、隐藏的，需要深入理解业务，需要“无中生有”才能得到的抽象就没那么容易发现了，所以要具体问题具体对待，这个进化的过程需要我们有很好的业务理解力，抽象能力以及建模的经验（&lt;span&gt;知道为什么公司的job model里那么强调技术人员的业务理解力和抽象能力了吧&lt;/span&gt;），比如通常情况下，价格和库存只是订单和商品的一个属性，但是在阿里系电商业务场景下，价格计算和库存扣减的复杂程度可以让你怀疑人生，因此作为电商中台，把价格和库存单独当成一个域（Domain）去对待是很必要的。另外，建模不是一个一次性的工作，往往随着业务的变化以及我们对业务的理解越来越深入才能看清系统的全貌，所以迭代重构是免不了的，也就是要Agile Modelling。&lt;/p&gt;
&lt;h2 id=&quot;模型重构&quot;&gt;模型重构&lt;/h2&gt;
&lt;h3 id=&quot;模型统一&quot;&gt;模型统一&lt;/h3&gt;
&lt;p&gt;建模的过程很像盲人摸象，不同背景人用不同的视角看同一个东西，其理解也是不一样的。比如两个盲人都摸到大象鼻子，一个人认为是像蛇（活的能动），而另一个人认为像消防水管（可以喷水），那么他们将很难集成。双方都无法接受对方的模型，因为那不符合自己的体验。事实上，他们需要一个新的抽象，这个抽象需要把蛇的“活着的特性”与消防水管的“喷水功能”合并到一起，而这个抽象还应该排除先前两个模型中一些不确切的含义和属性，比如毒牙，或者卷起来放到消防车上去的行为，这就是模型的统一。统一完的模型也许还不叫大象鼻子，但是已经很接近大象鼻子的属性和功能了，随着我们对模型对象、对业务理解的越来越深入、越来越透彻，我们会不断的调整演化我们的模型，所以建模不是一个one-time off的工作，而是一个持续不断演化重构的过程。&lt;/p&gt;
&lt;h3 id=&quot;模型演化&quot;&gt;模型演化&lt;/h3&gt;
&lt;p&gt;世界上唯一不变的就是变化，模型和代码一样也需要不断的重构和精化，每一次的精化之后，开发人员应该对领域知识有了更加清晰的认识。这使得理解上的突破成为可能，之后，一系列快速的改变得到了更符合用户需要并更加切合实际的模型。其功能性及说明性急速增强，而复杂性却随之消失。这种突破需要我们对业务有更加深刻的领悟和思考，然后再加上重构的勇气和能力，勇气是项目工期很紧你敢不敢重构，能力是你有没有完备的CI保证你的重构不破坏现有的业务逻辑。&lt;/p&gt;
&lt;p&gt;实体在演变 &lt;br/&gt;以开篇的银行账号为例，假如一开始账号都有withdraw（取钱）的行为，此时只需要在Account上加上withdraw方法就好了。 &lt;br/&gt;- 演变一：&lt;br/&gt;随着业务的发展，我们需要支持ATM账号和Online账号，而Online账号是不能withdraw的，此时最差的做法是保持模型不变，而是在withdraw方法中判断如果是OnlineAccount则抛出异常。这种简单的代码堆砌可以满足业务功能，但是其业务语义完全被掩盖。更好的重构方法应该是将withdraw抽成一个接口IWithdrawable。 &lt;br/&gt;- 演变二：&lt;br/&gt;好的，没有什么可以阻挡业务对变化的向往。现在公司出于安全性的考虑，为新开通的ATMAccount设置了取款上线，超过则不能支取。简单做法是在IWithdrawable中再加入一个setLimit行为，可是我们并不想改动影响到老的账号业务，所以更好的重构应该是重新写一个ILimitedWithdrawable接口，让其继承老接口，这样老的代码就可以保持不变了。 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/e518ac7f9060a74aef9de08c66ebd8bf.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;通过上面的例子，我们可以看到领域模型和面向对象是一对孪生兄弟，我们会用到大量的OO原则，比如上面的重构就用到了SOLID的SRP（单一职责）和OCP（开闭原则）。在实际工作中，我的确也有这样的体会，自从践行DDD以后，我们采用OOA和OOD的时候比以前明显多了很多，OO的能力也在不断的提升。&lt;/p&gt;
&lt;p&gt;引入新抽象 &lt;br/&gt;还是以开篇的转账来举个例子，假如转账业务开始变的复杂，要支持现金，信用卡，支付宝，比特币等多种通道，且没种通道的约束不一样，还要支持一对多的转账。那么你还是用一个&lt;code&gt;transfer(fromAccount, toAccount)&lt;/code&gt;就不合适了，可能需要抽象出一个专门的&lt;span&gt;领域对象Transaction&lt;/span&gt;，这样才能更好的表达业务，其演化过程如下： &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/14f854789211df11a124f99ff71a89cc.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;聚合根&quot;&gt;聚合根&lt;/h2&gt;
&lt;p&gt;聚合根（Aggregate Root）是DDD中的一个概念，是一种更大范围的封装，把一组有相同生命周期、在业务上不可分隔的实体和值对象放在一起考虑，只有根实体可以对外暴露引用，也是一种内聚性的表现。&lt;/p&gt;
&lt;p&gt;确定聚合边界要满足固定规则（Invariant），是指在数据变化时必须保持的一致性规则，具体规则如下 &lt;br/&gt;- 根实体具有全局标识，最终负责检查规定规则 &lt;br/&gt;- 聚合内的实体具有本地标识，这些标识在Aggregate内部才是唯一的 &lt;br/&gt;- 外部对象不能引用除根Entity之外的任何内部对象 &lt;br/&gt;- 只有Aggregate的根Entity才能直接通过数据库查询获取，其他对象必须通过遍历关联来发现 &lt;br/&gt;- Aggegate内部的对象可以保持对其他Aggregate根的引用 &lt;br/&gt;- Aggregate边界内的任何对象修改时，整个Aggregate的所有固定规则都必须满足&lt;/p&gt;
&lt;p&gt;还是看银行的例子，Account（账号）是CustomerInfo（客户信息）Entity和Address（值对象）的聚合根，Tansaction（交易）是流水（Journal）的聚合根，因为流水是因为交易才产生的，具有相同的生命周期。 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/a20873698bab8973d0bf10b09a1e7694.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;最后提醒一下，聚合根是一个逻辑概念，主观性很强，所以在建模过程中很容易产生分歧，因此在日常工作中千万不要教条，把握住一条主要原则，我们的最终目的是为了业务语义显现化，如果因为聚合根把模型弄的晦涩难懂那就得不偿失了&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用领域服务&quot;&gt;使用领域服务&lt;/h2&gt;
&lt;h3 id=&quot;什么是领域服务&quot;&gt;什么是领域服务&lt;/h3&gt;
&lt;p&gt;有些领域中的动作，它们是一些动词，看上去却不属于任何对象。它们代表了领域中的一个重要的行为，所以不能忽略它们或者简单地把它们合并到某个实体或者值对象中。当这样的行为从领域中被识别出来时，最佳实践是将它声明成一个服务。这样的对象不再拥有内置的状态。它的作用仅仅是为领域提供相应的功能。Service往往是以一个活动来命名，而不是Entity来命名。例如开篇转账的例子，转账（transfer）这个行为是一个非常重要的领域概念，但是它是发生在两个账号之间的，归属于账号Entity并不合适，因为一个账号Entity没有必要去关联他需要转账的账号Entity，这种情况下，使用&lt;code&gt;MoneyTransferDomainService&lt;/code&gt;就比较合适了。 &lt;br/&gt;识别领域服务，主要看它是否满足以下三个特征： &lt;br/&gt;1. 服务执行的操作代表了一个领域概念，这个领域概念无法自然地隶属于一个实体或者值对象。 &lt;br/&gt;2. 被执行的操作涉及到领域中的其他的对象。 &lt;br/&gt;3. 操作是无状态的。&lt;/p&gt;
&lt;h3 id=&quot;领域服务陷阱&quot;&gt;领域服务陷阱&lt;/h3&gt;
&lt;p&gt;在使用领域服务时要特别当心，一个比较常见的错误是没有努力为行为找到一个适当的对象，就直接抽象成领域服务，这会使我们的代码逐渐转化为过程式的编程，一个极端的例子是把所有的行为都放到领域服务中，而领域模型退化成只有属性的贫血DO，那DDD就没有任何意义了。所以一定要深入思考，既不能勉强将行为放到不符合对象定义的对象中，破坏对象的内聚性，使其语义变得模糊。也不能不加思考的都放到领域服务中，从而退化成面向过程的编程。&lt;/p&gt;
&lt;h3 id=&quot;应用服务和领域服务如何划分&quot;&gt;应用服务和领域服务如何划分&lt;/h3&gt;
&lt;p&gt;在领域建模中，我们一般将系统划分三个大的层次，即应用层（Application Layer），领域层（Domain Layer）和基础实施层（Infrastructure Layer），关于这三个层次的详细内容可以参考我的另一篇SOFA框架的&lt;a href=&quot;https://www.atatech.org/articles/96063?msgid=1989736#13&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;分层设计&lt;/a&gt;。可以看到在App层和Domain层都有服务（Service），这两个Service如何划分呢，什么样的功能应该放在应用层，什么样的功能应该放在领域层呢？ &lt;br/&gt;决定一个服务（Service）应该归属于哪一层是很困难的。如果所执行的操作概念上属于应用层，那么服务就应该放到这个层。如果操作是关于领域对象的，而且确实是与领域有关的、为领域的需要服务，那么它就应该属于领域层。总的来说，涉及到重要领域概念的行为应该放在Domain层，而其它非领域逻辑的技术代码放在App层，例如参数的解析，上下文的组装，调用领域服务，消息发送等。还是银行转账的case为例，下图给出了划分的建议： &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/f1ff5a81e459a41fd92ff9827f51a94c.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;边界上下文&quot;&gt;边界上下文&lt;/h2&gt;
&lt;p&gt;领域实体是有边界上下文的，比如Apple这个实体不同的上下文，表达的含义就完全不一样，在水果店它就是水果，在苹果专卖店它就是手机。&lt;/p&gt;
&lt;p&gt;所以边界上下文（Bounded Context）在DDD里面是一个非常重要的概念，Bounded Context明确地限定了模型的应用范围，在Context中，要保证模型在逻辑上统一，而不用考虑它是不是适用于边界之外的情况。在其他Context中，会使用其他模型，这些模型具有不同的术语、概念、规则和Ubiquitous Language的行话。&lt;/p&gt;
&lt;p&gt;那么不同Context下的业务要互相通信怎么办呢？这就涉及跨边界的集成了，集成不能是简单的HSF调用，而是需要一个专门的防腐层（Anti-Corruption）做转化，其意义主要有以下两点：&lt;/p&gt;
&lt;p&gt;和外部依赖解耦 &lt;br/&gt;避免外部领域概念污染Context内部实体语义 &lt;br/&gt;以我们真实的业务场景举个例子，比如会员这个概念在ICBU网站是指网站上的Buyer，但是在CRM领域是指Customer，虽然很多的属性都是一样的，但是二者在不同的Context下其语义和概念是有差别的，我们需要用AC做一下转换： &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/f4053830a38294ba652e65ff6c104e35.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;好的领域建模可以降低应用的复杂性，而可视化和可配置化主要是帮助大家（主要是非技术人员，比如产品，业务和客户）直观地了解系统和配置系统，提供了一种“code free”的解决方案，也是SaaS软件的主要卖点。要注意的是可视化和可配置化难免会给系统增加额外的复杂度，必须慎之又慎，最好是能使可视化和配置化的逻辑与业务逻辑尽量少的耦合，否则破坏了原有的架构，把事情搞的更复杂就得不偿失了。 &lt;br/&gt;在&lt;a href=&quot;https://www.atatech.org/articles/96063?msgid=1989736#7&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;可扩展设计&lt;/a&gt;中，我已经介绍了我们SOFA架构是如何通过扩展点的设计来支撑不同业务差异化的需求的，那么可否更进一步，我们将领域的行为（也叫能力）和扩展点用可视化的方式呈现出来，并对于一些不需要编码实现的扩展点用配置的方式去完成呢。当然是可以的，比如还是开篇转账的例子，对于透支策略OverdraftPolicy这个业务扩展点，新来一个业务说透支额度不能超过1000，我们可以完全结合规则引擎进行配置化完成，而不需要编码。 &lt;br/&gt;所以我能想到的一种还比较优雅的方式，是通过Annotation注解的方式对领域能力和扩展点进行标注，然后在系统bootstrap阶段，通过代码扫描的方式，将这些能力点和扩展点收集起来上传到中心服务器，然后再通过GUI的方式呈现出来，从而做到业务的可视化和可配置化。大概的示意图如下： &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/154018b3021a3c8c95727a4a4ca84f5b.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;有同学可能会问流程要不要可视化，这里要分清楚两个概念，业务逻辑流和工作流，很多同学混淆了这两个概念。业务逻辑流是响应一次用户请求的业务处理过程，其本身就是业务逻辑，对其编排和可视化的意义并不是很大，无外乎只是把代码逻辑可视化了，在我们的SOFA框架中，是通过扩展点和策略模式来处理业务的分支情况，&lt;span&gt;而我看到我们阿里很多的内部系统将这种响应一次用户请求的业务逻辑用很重的工作流引擎来做，美其名曰流程可编排，实质上往往是把简单的事情复杂化了。&lt;/span&gt;而工作流是指完成一项任务所需要不同节点的连接，节点主要分为自动节点和人工节点，其中每个人工节点都需要用户的参与，也就是响应一次用户的请求，比如审批流程中的经理审批节点，CRM销售过程的业务员的处理节点等等。此时可以考虑使用工作流引擎，特别是当你的系统需要让用户自定义流程的时候，那就不得不使用可视化和可配置的工作流引擎了，除此之外，最好不要自找麻烦。我曾在银行工作过，亲眼看见过IBM是怎么忽悠银行使用它们的BPM系统，然后把系统弄的巨复杂无比，所以我对工作流引擎的印象并不好，当然也不排除有用的特别合适的案例，只是我还没看见，如果有看见的同学麻烦告诉我一声，学习一下。因为我们现在还没有让用户自定义流程的诉求，所以使用工作流引擎并不在我们现阶段的考虑范围之内。&lt;/p&gt;
</description>
<pubDate>Wed, 20 Jun 2018 02:50:00 +0000</pubDate>
<dc:creator>significantfrank</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/significantfrank/p/9202663.html</dc:identifier>
</item>
<item>
<title>时间序列异常检测算法S-H-ESD - Treant</title>
<link>http://www.cnblogs.com/en-heng/p/9202654.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/en-heng/p/9202654.html</guid>
<description>&lt;h2 id=&quot;grubbs-test&quot;&gt;Grubbs' Test&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.itl.nist.gov/div898/handbook/eda/section3/eda35h1.htm&quot;&gt;Grubbs' Test&lt;/a&gt;为一种假设检验的方法，常被用来检验服从正太分布的单变量数据集（univariate data set）&lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt; 中的单个异常值。若有异常值，则其必为数据集中的最大值或最小值。原假设与备择假设如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(H_0\)&lt;/span&gt;: 数据集中没有异常值&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(H_1\)&lt;/span&gt;: 数据集中有一个异常值&lt;/p&gt;
&lt;p&gt;Grubbs' Test检验假设的所用到的检验统计量（test statistic）为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ G = \frac{\max |Y_i - \overline{Y}|}{s} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(\overline{Y}\)&lt;/span&gt;为均值，&lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;为标准差。原假设&lt;span class=&quot;math inline&quot;&gt;\(H_0\)&lt;/span&gt;被拒绝，当检验统计量满足以下条件&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ G &amp;gt; \frac{(N-1)}{\sqrt{N}}\sqrt{\frac{ (t_{\alpha/(2N), N-2})^2}{N-2 + (t_{\alpha/(2N), N-2})^2}} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;为数据集的样本数，&lt;span class=&quot;math inline&quot;&gt;\(t_{\alpha/(2N), N-2}\)&lt;/span&gt;为显著度(significance level)等于&lt;span class=&quot;math inline&quot;&gt;\(\alpha/(2N)\)&lt;/span&gt;、自由度（degrees of freedom）等于&lt;span class=&quot;math inline&quot;&gt;\(N-2\)&lt;/span&gt;的t分布临界值。实际上，Grubbs' Test可理解为检验最大值、最小值偏离均值的程度是否为异常。&lt;/p&gt;
&lt;h2 id=&quot;esd&quot;&gt;ESD&lt;/h2&gt;
&lt;p&gt;在现实数据集中，异常值往往是多个而非单个。为了将Grubbs' Test扩展到&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;个异常值检测，则需要在数据集中逐步删除与均值偏离最大的值（为最大值或最小值），同步更新对应的t分布临界值，检验原假设是否成立。基于此，Rosner提出了Grubbs' Test的泛化版&lt;a href=&quot;http://www.itl.nist.gov/div898/handbook/eda/section3/eda35h3.htm&quot;&gt;ESD&lt;/a&gt;（Extreme Studentized Deviate test）。算法流程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;计算与均值偏离最远的残差，&lt;strong&gt;注意&lt;/strong&gt;计算均值时的数据序列应是删除上一轮最大残差样本数据后；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;\begin{equation}&lt;br/&gt;R_i = \frac{\max_i |Y_i - \overline{Y'}|}{s}&lt;br/&gt;\label{eq:esd_test}&lt;br/&gt;\end{equation}&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;计算临界值（critical value）；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \lambda_j = \frac{(n-j) * t_{p,n-j-1}}{\sqrt{(n-j-1+t_{p,n-j-1}^2)(n-j+1)}}, \quad 1 \leq j \leq k \]&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;检验原假设，比较检验统计量与临界值；若&lt;span class=&quot;math inline&quot;&gt;\(R_i &amp;gt; \lambda_j\)&lt;/span&gt;，则原假设&lt;span class=&quot;math inline&quot;&gt;\(H_0\)&lt;/span&gt;不成立，该样本点为异常点；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;重复以上步骤&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;至算法结束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鉴于时间序列数据具有周期性（seasonal）、趋势性（trend），异常检测时不能作为孤立的样本点处理；故而Twitter的工程师提出了S- ESD (Seasonal ESD)与S-H-ESD (Seasonal Hybrid ESD)算法，将ESD扩展到时间序列数据。&lt;/p&gt;
&lt;h2 id=&quot;s-esd&quot;&gt;S-ESD&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/en-heng/p/7390310.html&quot;&gt;STL&lt;/a&gt;将时间序列数据分解为趋势分量、周期分量和余项分量。想当然的解法——将ESD运用于STL分解后的余项分量中，即可得到时间序列上的异常点。但是，我们会发现在余项分量中存在着部分假异常点（spurious anomalies）。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/399159/201806/399159-20180620104722640-1761537210.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在红色矩形方框中，向下突起点被误报为异常点。为了解决这种假阳性降低准确率的问题，S-ESD算法用中位数（median）替换掉趋势分量；余项计算公式如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ R_X = X - S_X- \tilde{X} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;为原时间序列数据，&lt;span class=&quot;math inline&quot;&gt;\(S_X\)&lt;/span&gt;为STL分解后的周期分量，&lt;span class=&quot;math inline&quot;&gt;\(\tilde{X}\)&lt;/span&gt;为&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;的中位数。&lt;/p&gt;
&lt;h2 id=&quot;s-h-esd&quot;&gt;S-H-ESD&lt;/h2&gt;
&lt;p&gt;由于个别异常值会极大地拉伸均值和方差，从而导致S-ESD未能很好地捕获到部分异常点，召回率偏低。为了解决这个问题，S-H-ESD采用了更具鲁棒性的中位数与绝对中位差（Median Absolute Deviation, MAD）替换公式\eqref{eq:esd_test}中的均值与标准差。MAD的计算公式如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ MAD = median(|X_i - median(X)|) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;S-H-ESD的Python实现有&lt;a href=&quot;https://github.com/nicolasmiller/pyculiarity&quot;&gt;pyculiarity&lt;/a&gt;，时间序列异常检测数据集有Yahoo公开的&lt;a href=&quot;https://webscope.sandbox.yahoo.com/catalog.php?datatype=s&amp;amp;did=70&quot;&gt;A Labeled Anomaly Detection Dataset&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;[1] Hochenbaum, Jordan, Owen S. Vallis, and Arun Kejariwal. &quot;Automatic Anomaly Detection in the Cloud Via Statistical Learning.&quot; arXiv preprint arXiv:1704.07706 (2017).&lt;/p&gt;
</description>
<pubDate>Wed, 20 Jun 2018 02:48:00 +0000</pubDate>
<dc:creator>Treant</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/en-heng/p/9202654.html</dc:identifier>
</item>
<item>
<title>mysql之引擎、Explain、权限详解 - 人生不如戏</title>
<link>http://www.cnblogs.com/fu-yong/p/9202512.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fu-yong/p/9202512.html</guid>
<description>&lt;p&gt;在日常工作中，我们会有时会开慢查询去记录一些执行时间比较久的SQL语句，找出这些SQL语句并不意味着完事了，些时我们常常用到explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。所以我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。（QEP：sql生成一个执行计划query Execution plan）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; explain select * from servers;
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
| id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | servers | ALL  | NULL          | NULL | NULL    | NULL |    1 | NULL  |
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
1 row in set (0.03 sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;expain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra,下面对这些字段出现的可能进行解释：&lt;/p&gt;
&lt;p&gt;一、 &lt;strong&gt;id&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     我的理解是SQL执行的顺序的标识,SQL从大到小的执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. id相同时，执行顺序由上至下&lt;/p&gt;
&lt;p&gt;2. 如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行&lt;/p&gt;
&lt;p&gt;3.id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、select_type&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      &lt;/strong&gt;示查询中每个select子句的类型&lt;/p&gt;
&lt;p&gt;(1) SIMPLE(简单SELECT,不使用UNION或子查询等)&lt;/p&gt;
&lt;p&gt;(2) PRIMARY(查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY)&lt;/p&gt;
&lt;p&gt;(3) UNION(UNION中的第二个或后面的SELECT语句)&lt;/p&gt;
&lt;p&gt;(4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)&lt;/p&gt;
&lt;p&gt;(5) UNION RESULT(UNION的结果)&lt;/p&gt;
&lt;p&gt;(6) SUBQUERY(子查询中的第一个SELECT)&lt;/p&gt;
&lt;p&gt;(7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，取决于外面的查询)&lt;/p&gt;
&lt;p&gt;(8) DERIVED(派生表的SELECT, FROM子句的子查询)&lt;/p&gt;
&lt;p&gt;(9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、table&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显示这一行的数据是关于哪张表的，有时不是真实的表名字,看到的是derivedx(x是个数字,我的理解是第几步执行的结果)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; explain select * from (select * from ( select * from t1 where id=2602) a) b;
+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+
| id | select_type | table      | type   | possible_keys     | key     | key_len | ref  | rows | Extra |
+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+
|  1 | PRIMARY     | &amp;lt;derived2&amp;gt; | system | NULL              | NULL    | NULL    | NULL |    1 |       |
|  2 | DERIVED     | &amp;lt;derived3&amp;gt; | system | NULL              | NULL    | NULL    | NULL |    1 |       |
|  3 | DERIVED     | t1         | const  | PRIMARY,idx_t1_id | PRIMARY | 4       |      |    1 |       |
+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;四、type&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示MySQL在表中找到所需行的方式，又称“访问类型”。&lt;/p&gt;
&lt;p&gt;常用的类型有：&lt;strong&gt; ALL, index,  range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行&lt;/p&gt;
&lt;p&gt;index: Full Index Scan，index与ALL区别为index类型只遍历索引树&lt;/p&gt;
&lt;p&gt;range:只检索给定范围的行，使用一个索引来选择行&lt;/p&gt;
&lt;p&gt;ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值&lt;/p&gt;
&lt;p&gt;eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件&lt;/p&gt;
&lt;p&gt;const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system&lt;/p&gt;
&lt;p&gt;NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、possible_keys&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。&lt;br/&gt;如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;六、Key&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;key列显示MySQL实际决定使用的键（索引）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;七、key_len&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不损失精确性的情况下，长度越短越好&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;八、ref&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;九、rows&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;十、Extra&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;该列包含MySQL解决查询的详细信息,有以下几种情况：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Using where:列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤&lt;/p&gt;
&lt;p&gt;Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询&lt;/p&gt;
&lt;p&gt;Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序”&lt;/p&gt;
&lt;p&gt;Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。&lt;/p&gt;
&lt;p&gt;Impossible where：这个值强调了where语句会导致没有符合条件的行。&lt;/p&gt;
&lt;p&gt;Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;• EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况&lt;br/&gt;• EXPLAIN不考虑各种Cache&lt;br/&gt;• EXPLAIN不能显示MySQL在执行查询时所作的优化工作&lt;br/&gt;• 部分统计信息是估算的，并非精确值&lt;br/&gt;• EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;MySQL授权管理&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
show grants for '用户'@'IP地址'；                  -- 查看权限
grant  权限 on 数据库.表 to   '用户'@'IP地址'；      -- 授权
revoke 权限 on 数据库.表 from '用户'@'IP地址'；      -- 取消权限
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 权限参数&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
all privileges  除grant外的所有权限
            select          仅查权限
            select,insert   查和插入权限
            ...
            usage                   无访问权限
            alter                   使用alter table
            alter routine           使用alter procedure和drop procedure
            create                  使用create table
            create routine          使用create procedure
            create temporary tables 使用create temporary tables
            create user             使用create user、drop user、rename user和revoke  all privileges
            create view             使用create view
            delete                  使用delete
            drop                    使用drop table
            execute                 使用call和存储过程
            file                    使用select into outfile 和 load data infile
            grant option            使用grant 和 revoke
            index                   使用index
            insert                  使用insert
            lock tables             使用lock table
            process                 使用show full processlist
            select                  使用select
            show databases          使用show databases
            show view               使用show view
            update                  使用update
            reload                  使用flush
            shutdown                使用mysqladmin shutdown(关闭MySQL)
            super                   􏱂􏰈使用change master、kill、logs、purge、master和set global。还允许mysqladmin􏵗􏵘􏲊􏲋调试登陆
            replication client      服务器位置的访问
            replication slave       由复制从属使用

&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;数据库参数&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
对于目标数据库以及内部其他：
            数据库名.*           数据库中的所有
            数据库名.表          指定数据库中的某张表
            数据库名.存储过程     指定数据库中的存储过程
            *.*                所有数据库
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;用户IP参数&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
用户名@IP地址         用户只能在改IP下才能访问
用户名@192.168.1.%   用户只能在改IP段下才能访问(通配符%表示任意)
用户名@%             用户可以再任意IP下访问(默认IP地址为%)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;示例&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
grant all privileges on db1.tb1 TO '用户名'@'IP'；

            grant select on db1.* TO '用户名'@'IP'；

            grant select,insert on *.* TO '用户名'@'IP'；

            revoke select on db1.tb1 from '用户名'@'IP'；
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;刷新权限&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
flush privileges，将数据读取到内存中，从而立即生效。
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;忘记密码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 启动免授权服务端
mysqld --skip-grant-tables

# 客户端
mysql -u root -p

# 修改用户名密码
update mysql.user set authentication_string=password('666') where user='root';
flush privileges;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 20 Jun 2018 02:39:00 +0000</pubDate>
<dc:creator>人生不如戏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fu-yong/p/9202512.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core Web API 与 SSL - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/9202174.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/9202174.html</guid>
<description>&lt;p&gt;一直没有真正研究过SSL，不知道下面的理解是否正确。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;SSL是Secure Sockets Layer&lt;/strong&gt;&lt;/span&gt;的缩写，它用来保护服务器和客户端之前的通信。它是基于信任+加密的概念。&lt;/p&gt;
&lt;p&gt;在介绍SSL的原理之前，首先介绍一下加密（Encryption）的概念。&lt;/p&gt;

&lt;p&gt;在很多的应用/API里，最常见的一种加密的方式是&lt;span&gt;&lt;strong&gt;对称加密（Symmetric Encryption）&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对称加密&lt;/strong&gt;的原理是这样的：比如说甲方想要发送一些数据给某个调用者（乙方），乙方可能在某个进程或客户端服务器里，或者是跨越网络的。总之是两方通信。而甲方发送加密的数据需要一些加密的方法，这个加密方法双方必须都知道（例如AES），此外还需要一个secret，它是一个任意的字符串，加密方法需要使用secret来进行加密。使用这样的加密方法把数据加密，然后加密的数据就会被发给乙方。乙方在接受这个加密后的数据之后，需要同样的加密方法和同样的secret来进行解密。所以对称加密的弱点也就在这，这个secret需要在双方共享。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201806/986268-20180620092007446-878368822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;而对于SSL来说，它还可以使用第二种加密方式：&lt;span&gt;&lt;strong&gt;非对称加密（Asymetric Encryption）&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非对称加密&lt;/strong&gt;的原理是这样的，它也需要加密方法来对数据进行加密，但加密的时候使用的是public key&lt;/p&gt;
&lt;p&gt;，这个public key是从乙方那里获得的；它实际就是一个secret，但是这个secret并没有被保护，所以乙方并不担心甲方或其他方使用它来进行解密，因为public key不可以用来解密，它只能用来进行加密。而当乙方接收到加密数据之后，它使用private key来进行解密，这个private key是保密的，别人不知道的，这样乙方就可以得到解密后的数据。&lt;/p&gt;
&lt;p&gt;所以非对称加密的优势还是很明显的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201806/986268-20180620092030003-1207060689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;SSL使用这两种加密方式。&lt;/p&gt;
&lt;p&gt;当客户端和（Web）服务器使用SSL进行通信前会有一个&lt;strong&gt;&lt;span&gt;SSL握手&lt;/span&gt;&lt;/strong&gt;的操作，用户是不会察觉这个动作的，它发生在真正调用API之前。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201806/986268-20180620092045727-998412634.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当客户端开始请求（https）后，服务器首先返回的是证书。&lt;/p&gt;
&lt;p&gt;证书里面包含了很多的信息，这些信息首先就可以用来对证书本身进行信任确认。证书里包含了一些承诺：包括这个证书来自受信任的源。例如你使用SSL请求Microsoft.com，那么返回的证书就会对你承诺：“这个服务器是被微软所拥有的”等。证书还会包含着“谁可以保证这些信息的真实性”的信息。这里还有一个证书颁发机构（Certificate Authority，CA）的列表，这些机构是我不得不信任的，证书颁发机构可以保证这些信息等真实性。这里的证书就是由这些机构来签发的。通常浏览器都会加载这些知名证书颁发机构的根证书。这些机构维护着一个所有已签名证书的列表和已经被吊销的证书的列表。未签名的证书是不安全的，已签名的证书是不可以被修改的。自己签名的证书叫自签名证书。所有的根证书颁发机构的证书都是自签名的。&lt;/p&gt;
&lt;p&gt;服务器返回证书的同时还返回了一个public key，浏览器根据信任的CA来检查证书是否仍然有效并且和该网站仍然关联。&lt;/p&gt;
&lt;p&gt;如果浏览器最终信任了这个证书，那么它会使用这个public key来生成加密一个随机的对称加密key并把它使用加密的URL和HTTP数据一同送回到服务器。&lt;/p&gt;
&lt;p&gt;服务器通过它的private key来对这个对称的加密key进行解密，随后用解密出来的对称key来解密URL和HTTP数据。然后服务器会使用这个对称加密key发出一个加密确认，接下来加密的对话就可以开始了，后续的通信都是使用这个对称key。&lt;/p&gt;
&lt;p&gt;那么为什么整个通信不都使用非对称加密呢？因为它比较消耗资源。所以非对称加密只用在SSL握手阶段来创建一个后续对话的对称加密key，后续的通信都是使用这个对称key来加密传输的数据。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;HTTPS (也叫做 HTTP over TLS, HTTP over SSL, and HTTP Secure)，它的传输协议使用TLS（SSL）加密&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;下面都是官方文档的内容。&lt;/p&gt;
&lt;p&gt;官方建议ASP.NET Core应用使用HTTPS重定向中间件来把所有的HTTP请求都重定向到HTTPS上。&lt;/p&gt;
&lt;p&gt;而实际上，ASP.NET Core 2.1的webapi模版里已经这样做了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201806/986268-20180620094715291-250624679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此外还可以在ConfigureServices方法里配置该中间件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201806/986268-20180620094940480-2010504570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里把返回到状态码设为307，这其实是默认值。而生产环境应该调用 UseHsts方法。&lt;/p&gt;
&lt;p&gt;然后把Https的端口设置为5001，默认值是443。&lt;/p&gt;

&lt;p&gt;注意：&lt;span&gt;&lt;strong&gt;需要同时监听http和https的端口&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;运行程序，使用POSTMAN发出一个GET请求到ValuesController：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201806/986268-20180620100029537-1992422344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没有返回任何响应，这是因为POSTMAN到设置问题。请按照下图修改POSTMAN到配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201806/986268-20180620100140019-1872702560.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把SSL certificate verification一项设置成 OFF。&lt;/p&gt;
&lt;p&gt;然后再发送GET请求就OK了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201806/986268-20180620100324561-709248075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里面有一个重定向到过程，我们改一下POSTMAN到设置来看一下这个过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201806/986268-20180620101014499-738029646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把Automatically follow redirects改为OFF。&lt;/p&gt;
&lt;p&gt;然后发送HTTP的请求：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201806/986268-20180620101106634-134819692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它返回的body是空的，Header里面有重定向的地址，状态码是307，也就是我之前配置的。&lt;/p&gt;
&lt;p&gt;然后我再发送请求到Header里Location到这个地址就会得到想要到结果，我就不贴图了。&lt;/p&gt;

</description>
<pubDate>Wed, 20 Jun 2018 02:18:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/9202174.html</dc:identifier>
</item>
</channel>
</rss>