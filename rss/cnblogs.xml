<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>使用C# (.NET Core) 实现状态设计模式 (State Pattern) - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/8919272.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/8919272.html</guid>
<description>&lt;p&gt;本文的概念性内容来自深入浅出设计模式一书&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180423141030752-306995462.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个糖果机的需求图. &lt;/p&gt;
&lt;p&gt;它有四种状态, 分别是图中的四个圆圈:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;No Quarter: 无硬币&lt;/li&gt;
&lt;li&gt;Has Quater 有硬币&lt;/li&gt;
&lt;li&gt;Gumball Sold 糖果卖出&lt;/li&gt;
&lt;li&gt;Out of Gumball 没有糖果了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个图很像一个&lt;strong&gt;状态图&lt;/strong&gt;. 每个圆圈就是一个状态, 每个带箭头的线就是状态的转换.&lt;/p&gt;
&lt;p&gt;这个需求用文字描述就是: 糖果机在没投硬币的时候, 可以投硬币, 投完硬币, 搬动手柄, 糖果就会出来, 如果糖果机里没有糖果了, 那么就无法再卖糖果了.&lt;/p&gt;

&lt;p&gt;这个需求看起来还是蛮简单的, 我想可以这样来实现:&lt;/p&gt;
&lt;p&gt;1. 整理好所有的状态, 一共有4个:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180423141640444-1341159722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 创建一个实例变量来保存当前的状态, 并为每个状态定义一个值:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180423141756240-179713854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. 整理好系统中可能发生的动作:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180423142042085-1393784142.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4. 创建一个类作为状态机, 针对每一个动作, 我们创建一个方法, 在方法里我们使用条件语句来决定在每个状态中该行为是否合理. 例如, 投入硬币后, 我们可能需要下面这个方法:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180423142258297-156406497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意: 最后一个if中, 有改变状态的动作(如果之前的状态是没有硬币, 那么投入硬币后, 状态应改为有硬币).&lt;/p&gt;
&lt;p&gt;下面来实现这个状态机:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180423142436559-1352618351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180423142501864-293385142.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180423142526298-1683987538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180423142555989-820654895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180423142616106-139786292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码量还是不小啊, 这里面主要做的就是在每个动作方法里, 判断各种状态, 如何合理就改变状态.&lt;/p&gt;
&lt;p&gt;运行一下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180423142841362-674303151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180423142911652-993319186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看起来一切都OK了, 直到:&lt;/p&gt;

&lt;p&gt;糖果机老板说, 我想买糖果变成一个游戏, 投硬币买糖果的人中的10%在搬动手柄后将会得到两个糖果而不是一个.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现在的状态开始有点乱了:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180423143455348-2049375788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随着需求的变化, 我们设计会导致越来越多的bug...&lt;/p&gt;
&lt;p&gt;回想一下设计原则: &quot;把变化的部分封装起来&quot; 和 &quot;尽量使用组合&quot;. 我们可以把每个状态的行为放到它自己的类里面, 然后每个动作只需要实现自己状态下的动作即可. 而且也许糖果机可以使用状态对象来委托表示自己当前的状态.&lt;/p&gt;

&lt;p&gt;这次我们就把状态的行为封装到各个状态对象里面, 并在动作发生的时候委托到当前的状态.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 首先, 定义一个状态接口, 这个接口包含糖果机的每个动作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 针对每种状态, 实现一个具体的状态类. 这些类将负责糖果机在改状态下的行为.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 最后, 去掉那些条件判断代码, 把这些工作委托给状态类&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;上面要实现的就是状态模式 (State Pattern).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;把一个状态所有的行为放到一个类里面, 这样, 就实现了本地化并且便于修改和理解&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;设计类图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180423144403103-104306185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这里我们使用状态类来代替初版设计中的数值&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;当然别忘了这个状态:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180423144505500-952570453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我直接使用C#实现这些状态:&lt;/p&gt;
&lt;p&gt;状态接口:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; StatePattern.Abstractions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IState
    {
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; InjectQuarter();
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; EjectQuarter();
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; TurnCrank();
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispense();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;五个状态, 有硬币:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; StatePattern.Abstractions;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; StatePattern.Machines;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; StatePattern.States
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HasQuarterState : IState
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; GumballMachine _gumballMachine;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; Random _random = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HasQuarterState(GumballMachine gumballMachine)
        {
            _gumballMachine &lt;/span&gt;=&lt;span&gt; gumballMachine;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InjectQuarter()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You can’t insert another quarter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; EjectQuarter()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Quarter returned&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            _gumballMachine.State &lt;/span&gt;=&lt;span&gt; _gumballMachine.NoQuarterState;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TurnCrank()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You turned...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; winner = _random.Next(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (winner == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; _gumballMachine.Count &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            {
                _gumballMachine.State &lt;/span&gt;=&lt;span&gt; _gumballMachine.WinnerState;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                _gumballMachine.State &lt;/span&gt;=&lt;span&gt; _gumballMachine.SoldState;
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispense()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No gumball dispensed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ToString()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;just being inserted with a quarter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;无硬币:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('498a9bdd-274e-413d-9f86-e928364bea3c')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_498a9bdd-274e-413d-9f86-e928364bea3c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_498a9bdd-274e-413d-9f86-e928364bea3c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('498a9bdd-274e-413d-9f86-e928364bea3c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_498a9bdd-274e-413d-9f86-e928364bea3c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; StatePattern.Abstractions;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; StatePattern.Machines;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; StatePattern.States
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NoQuarterState: IState
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; GumballMachine _gumballMachine;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; NoQuarterState(GumballMachine gumballMachine)
        {
            _gumballMachine &lt;/span&gt;=&lt;span&gt; gumballMachine;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InjectQuarter()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You inserted a quarter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            _gumballMachine.State &lt;/span&gt;=&lt;span&gt; _gumballMachine.HasQuarterState;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; EjectQuarter()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You havn't inserted a quarter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TurnCrank()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You turned, but there is no quarter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispense()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You need to pay first&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ToString()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is Waiting for quarter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;卖光了:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bced2dd2-99e9-41cb-acdb-9d30b373998b')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_bced2dd2-99e9-41cb-acdb-9d30b373998b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bced2dd2-99e9-41cb-acdb-9d30b373998b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bced2dd2-99e9-41cb-acdb-9d30b373998b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bced2dd2-99e9-41cb-acdb-9d30b373998b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; StatePattern.Abstractions;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; StatePattern.Machines;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; StatePattern.States
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SoldOutState: IState
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; GumballMachine _gumballMachine;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SoldOutState(GumballMachine gumballMachine)
        {
            _gumballMachine &lt;/span&gt;=&lt;span&gt; gumballMachine;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InjectQuarter()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You can’t insert a quarter, the machine is sold out&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; EjectQuarter()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You can’t eject, you haven’t inserted a quarter yet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TurnCrank()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You turned, but there are no gumballs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispense()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No gumball dispensed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ToString()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is sold out&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;刚刚卖出糖果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('489c15ab-c2b2-454a-bbe3-691d98668528')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_489c15ab-c2b2-454a-bbe3-691d98668528&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_489c15ab-c2b2-454a-bbe3-691d98668528&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('489c15ab-c2b2-454a-bbe3-691d98668528',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_489c15ab-c2b2-454a-bbe3-691d98668528&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; StatePattern.Abstractions;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; StatePattern.Machines;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; StatePattern.States
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SoldState : IState
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; GumballMachine _gumballMachine;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SoldState(GumballMachine gumballMachine)
        {
            _gumballMachine &lt;/span&gt;=&lt;span&gt; gumballMachine;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InjectQuarter()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Please wait, we’re already giving you a gumball&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; EjectQuarter()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sorry, you already turned the crank&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TurnCrank()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Turning twice doesn’t get you another gumball!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispense()
        {
            _gumballMachine.ReleaseBall();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_gumballMachine.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                _gumballMachine.State &lt;/span&gt;=&lt;span&gt; _gumballMachine.NoQuarterState;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Oops, out of gumballs!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                _gumballMachine.State &lt;/span&gt;=&lt;span&gt; _gumballMachine.SoldOutState;
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ToString()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;just sold a gumball&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;中奖了:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('030e0b66-8184-4563-b2b1-36ce349cfd60')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_030e0b66-8184-4563-b2b1-36ce349cfd60&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_030e0b66-8184-4563-b2b1-36ce349cfd60&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('030e0b66-8184-4563-b2b1-36ce349cfd60',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_030e0b66-8184-4563-b2b1-36ce349cfd60&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; StatePattern.Abstractions;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; StatePattern.Machines;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; StatePattern.States
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WinnerState: IState
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; GumballMachine _gumballMachine;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WinnerState(GumballMachine gumballMachine)
        {
            _gumballMachine &lt;/span&gt;=&lt;span&gt; gumballMachine;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InjectQuarter()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Please wait, we’re already giving you a gumball&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; EjectQuarter()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sorry, you already turned the crank&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TurnCrank()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Turning twice doesn’t get you another gumball!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispense()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YOU'RE A WINNER! You get two balls for you quarter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            _gumballMachine.ReleaseBall();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_gumballMachine.Count == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                _gumballMachine.State &lt;/span&gt;=&lt;span&gt; _gumballMachine.SoldOutState;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                _gumballMachine.ReleaseBall();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_gumballMachine.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    _gumballMachine.State &lt;/span&gt;=&lt;span&gt; _gumballMachine.NoQuarterState;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Oops, out of gumballs!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    _gumballMachine.State &lt;/span&gt;=&lt;span&gt; _gumballMachine.SoldOutState;
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ToString()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;just sold 2 gumballs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;糖果机:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; StatePattern.Abstractions;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; StatePattern.States;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; StatePattern.Machines
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GumballMachine
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IState SoldOutState { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IState NoQuarterState { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IState HasQuarterState { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IState SoldState { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IState WinnerState { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IState State { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Count { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; GumballMachine(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; numberOfGumballs)
        {
            SoldState &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SoldState(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            NoQuarterState &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; NoQuarterState(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            HasQuarterState &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HasQuarterState(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            SoldOutState &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SoldOutState(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            WinnerState &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; WinnerState(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

            Count &lt;/span&gt;=&lt;span&gt; numberOfGumballs;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                State &lt;/span&gt;=&lt;span&gt; NoQuarterState;
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InjectQuarter()
        {
            State.InjectQuarter();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; EjectQuarter()
        {
            State.EjectQuarter();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TurnCrank()
        {
            State.TurnCrank();
            State.Dispense();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ReleaseBall()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A gumball comes rolling out the slot...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Count != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                Count&lt;/span&gt;--&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Refill(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count)
        {
            Count &lt;/span&gt;+=&lt;span&gt; count;
            State &lt;/span&gt;=&lt;span&gt; NoQuarterState;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ToString()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mighty Gumball, Inc.\nC#-enabled Standing Gumball Model #2018\nInventory: {Count} gumballs\nThe machine {State} &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;注意糖果机里面的状态使用的是对象而不是原来的数值&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;运行:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; StatePattern.Machines;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; StatePattern
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; originalColor =&lt;span&gt; Console.ForegroundColor;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; machine = &lt;span&gt;new&lt;/span&gt; GumballMachine(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
            Console.ForegroundColor &lt;/span&gt;=&lt;span&gt; ConsoleColor.Blue;
            Console.WriteLine(machine);

            Console.ForegroundColor &lt;/span&gt;=&lt;span&gt; originalColor;
            Console.WriteLine();
            machine.InjectQuarter();
            machine.TurnCrank();
            Console.ForegroundColor &lt;/span&gt;=&lt;span&gt; ConsoleColor.Blue;
            Console.WriteLine(machine);

            Console.ForegroundColor &lt;/span&gt;=&lt;span&gt; originalColor;
            Console.WriteLine();
            machine.InjectQuarter();
            machine.TurnCrank();
            machine.InjectQuarter();
            machine.TurnCrank();
            machine.InjectQuarter();
            machine.TurnCrank();
            machine.InjectQuarter();
            machine.TurnCrank();
            Console.ForegroundColor &lt;/span&gt;=&lt;span&gt; ConsoleColor.Blue;
            Console.WriteLine(machine);

            Console.ReadKey();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180423144926761-1805704863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们修改了设计的结构, 但是功能是一样的:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把每个状态的行为本地化到它自己的类里面了&lt;/li&gt;
&lt;li&gt;移除了所有状态判断代码, 他们也很难维护.&lt;/li&gt;
&lt;li&gt;对每个状态的修改关闭, 但是让糖果机仍然可以扩展 (添加WINNER 状态)&lt;/li&gt;
&lt;li&gt;创建了一个与需求图几乎完美对应的代码库和类结构, 便于理解.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180423145511467-1021077861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180423145631435-2246396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180423145725004-1557322090.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;状态模式允许一个对象在内部状态改变的时候可以修改它自己的行为. 对象似乎修改了它的类&lt;/strong&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;第二句可以这样理解: &lt;/p&gt;
&lt;p&gt;从客户的观点, 如果一个你使用的对象可以完全改变它的行为, 那么这个对象看起来就像是从别的类初始化出来的一样 (变了一个类). 而实际上呢, 你使用的是组合的方式来实现变类的效果, 具体到我们的项目就是引用不同的状态对象.&lt;/p&gt;
&lt;p&gt;类图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201804/986268-20180423150406996-705654718.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Context(上下文环境)就是拥有很多内部状态的类, 糖果机.&lt;/p&gt;
&lt;p&gt;每当request()发生在Context上的时候, 它就被委托给了当时的状态对象. 右边就是各种状态对象.&lt;/p&gt;

&lt;p&gt;这两个模式表面上看起来可能有点像, 但是实际上它们的&lt;span&gt;&lt;strong&gt;目的&lt;/strong&gt;&lt;/span&gt;是&lt;span&gt;&lt;strong&gt;不同&lt;/strong&gt;&lt;/span&gt;的.&lt;/p&gt;
&lt;p&gt;状态模式下, 我们把一套行为封装在状态对象里; 任何要给时刻, Context总是委托工作给其中的一个对象. 随着时间的变化, Context的当前状态对象也发生变化, 所以Context的行为也随之变化. 客户对状态对象知道的很少.&lt;/p&gt;
&lt;p&gt;策略模式下, 客户要指定策略对象和Context组合. 该模式允许在运行时灵活的改变策略, 通常会有一个最适合当时环境的策略.&lt;/p&gt;
&lt;p&gt;总体来说,&lt;/p&gt;
&lt;p&gt;策略模式是对继承的灵活替换. 使用继承来定义类的行为, 当你需要改变的时候, 这个行为还会在的, 使用策略模式可是组合不同的对象来改变行为.&lt;/p&gt;
&lt;p&gt;状态模式则是一大堆条件判断的代替者, 把行为封装在状态对象里, 就可以简单的通过切换状态对象来改变Context的行为.&lt;/p&gt;

&lt;p&gt;Q: 总是由具体的状态对象来决定状态的走向吗?&lt;/p&gt;
&lt;p&gt;A: 也不是, 可以用Context决定状态的走向.&lt;/p&gt;
&lt;p&gt;Q: 客户直接访问状态吗?&lt;/p&gt;
&lt;p&gt;A: 客户不直接改变状态.&lt;/p&gt;
&lt;p&gt;Q: 如果Context有很多实例, 那么可以共享状态对象吗?&lt;/p&gt;
&lt;p&gt;A: 可以, 这个也经常发生. 但这要求你的状态对象不可以保存它们的内部状态, 否则每个Context都需要一个单独的实例.&lt;/p&gt;
&lt;p&gt;Q: 这么设计看起来类很多啊!&lt;/p&gt;
&lt;p&gt;A: 是啊, 但是可以让对客户可见的类的个数很少, 这个数量才重要&lt;/p&gt;
&lt;p&gt;Q: 可以使用抽象类来代替State接口吗?&lt;/p&gt;
&lt;p&gt;A: 可以, 如果需要一些公共方法的话.&lt;/p&gt;

&lt;p&gt;今天的比较简单, 只有这一个概念:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;状态模式允许一个对象在内部状态改变的时候可以修改它自己的行为. 对象似乎修改了它的类&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;该系列的源码在: &lt;a href=&quot;https://github.com/solenovex/Head-First-Design-Patterns-in-CSharp&quot; target=&quot;_blank&quot;&gt;https://github.com/solenovex/Head-First-Design-Patterns-in-CSharp&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Apr 2018 07:24:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/8919272.html</dc:identifier>
</item>
<item>
<title>Hash算法入门指南(聊点不一样的算法人生) - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/8919336.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/8919336.html</guid>
<description>&lt;p&gt;很多人到现在为止都总是问我算法该怎么学啊，数据结构好难啊怎么的，学习难度被莫名的夸大了，其实不然。对于一个学计算机相关专业的人都知道，数据结构是大学的一门必修课，数据结构与算法是基础，却常常容易被忽视，行业越浮躁，变化越快，开发平台越便捷，高级 API 越多，基本功的重要性就越容易被忽视。即使能意识到基础薄弱，肯下定决心腾出几个月时间恶补基本功不是件容易的事，尤其是参加工作后，琐事繁多，一时热血下定的决心能坚持一周都实属不易。数据结构与算法的学习难度经常被夸大，不少人甚至谈算法色变，尤其无法忍受在面试当中问及算法问题。其实多点儿耐心，多投入些时间，学习算法并不难。至少学习基础的算法并不难，理解算法和去 leetcode 一些平台刷题是两回事，刷题所涉及的算法多半需要技巧，基础的算法知识和其他计算机知识一样，不需要特别「聪明」的大脑，大多数人都能学会并完全掌握。数据结构和算法是相辅相成的，基础的其实就那么些：时间复杂度的概念，List，Array，Stack，Queue，Tree 等。Graph 实际应用中较少遇到，可以不做深入了解，但 BFS，DFS，Dijkstra 还是应该知道。基础的算法需要能达到手写的程度，比如排序至少能写出两种时间复杂度为 N*logN 的算法。理解这些比去刷海量的习题显得更为重要，学习难度也并不是太高。学习这些算法的意义在于掌握解决问题的基础思路，形成计算机思维，从而在一定程度上提升自我。&lt;/p&gt;&lt;p&gt;当然我们还是需要回到本文的核心重点是需要提及hash算法，介于网上很多文章对hash 算法的实现原理和关键概念讲解的已经有很多了，秉承着让每一位学习者都尽量少走弯路的原则，我就挑其重点进行讲解，尽量地把原理性的东西讲清楚，让每一个看完文章的人都能学得会，看得明白，能理解其精髓部分。OK，开始我们的聊天之旅~~~&lt;/p&gt;&lt;div readability=&quot;173.34954191238&quot;&gt;
&lt;p&gt;首先我们先举个例子。我们每个人，为了能够参与各种社会活动，都需要一个用于识别自己的标志。也许你觉得名字或是身份证就足以代表你这个人，但是这种代表性非常脆弱，因为重名的人很多，身份证也可以伪造。最可靠的办法是把一个人的所有基因序列记录下来用来代表这个人，但显然，这样做并不实际。而指纹看上去是一种不错的选择，虽然一些专业组织仍然可以模拟某个人的指纹，但这种代价实在太高了。所以现在我们似乎考虑到用其他无法伪造的识别方法去进行辨识，比如指关节(似乎是因为有血液的流动，目前有些品牌汽车就是采用这个方式解锁)，而对于在互联网世界里传送的文件来说，如何标志一个文件的身份同样重要。比如说我们下载一个文件，文件的下载过程中会经过很多网络服务器、路由器的中转，如何保证这个文件就是我们所需要的呢？我们不可能去一一检测这个文件的每个字节，也不能简单地利用文件名、文件大小这些极容易伪装的信息，这时候，我们就需要一种指纹一样的标志来检查文件的可靠性，这种指纹就是我们现在所用的Hash算法(也叫散列算法)。&lt;/p&gt;
&lt;h2&gt;2.Hash表&lt;/h2&gt;
&lt;p&gt;大学数据结构课本排序那节有提到一个叫做hash表的东东，hash表，也叫做散列表，是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做&lt;strong&gt;散列表&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名&lt;img id=&quot;equationview&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; src=&quot;https://latex.codecogs.com/gif.latex?%7B%5Cdisplaystyle%20x%7D&quot; alt=&quot;&quot; name=&quot;equationview&quot;/&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;到首字母&lt;img id=&quot;equationview&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; src=&quot;https://latex.codecogs.com/gif.latex?%7B%5Cdisplaystyle%20F%28x%29%7D&quot; alt=&quot;&quot; name=&quot;equationview&quot;/&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;的一个函数关系），在首字母为W的表中查找“王”姓的电话号码，显然比直接查找就要快得多。这里使用人名作为关键字，“取首字母”是这个例子中散列函数的函数法则&lt;img id=&quot;equationview&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; src=&quot;https://latex.codecogs.com/gif.latex?%7B%5Cdisplaystyle%20F%28%29%7D&quot; alt=&quot;&quot; name=&quot;equationview&quot;/&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;，存放首字母的表对应散列表。关键字和函数法则理论上可以任意确定。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;Hash构造函数的方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快定位。我们有以下几种&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;Hash构造函数的方法&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;直接定址法：取关键字或关键字的某个线性函数值为散列地址。即&lt;img id=&quot;equationview&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; src=&quot;https://latex.codecogs.com/gif.latex?%7B%5Cdisplaystyle%20hash%28k%29%3Dk%7D&quot; alt=&quot;&quot; name=&quot;equationview&quot;/&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;或&lt;img id=&quot;equationview&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; src=&quot;https://latex.codecogs.com/gif.latex?%7B%5Cdisplaystyle%20hash%28k%29%3Da%5Ccdot%20k&amp;amp;plus;b%7D&quot; alt=&quot;&quot; name=&quot;equationview&quot;/&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;，其中&lt;img id=&quot;equationview&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; src=&quot;https://latex.codecogs.com/gif.latex?%7B%5Cdisplaystyle%20a%5C%2Cb%7D&quot; alt=&quot;&quot; name=&quot;equationview&quot;/&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;为常数（这种散列函数叫做自身函数）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;数字分析法：假设关键字是以&lt;em&gt;r&lt;/em&gt;为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。&lt;/li&gt;
&lt;li&gt;平方取中法：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。&lt;/li&gt;
&lt;li&gt;折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。&lt;/li&gt;
&lt;li&gt;随机数法&lt;/li&gt;
&lt;li&gt;除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即&lt;img id=&quot;equationview&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; src=&quot;https://latex.codecogs.com/gif.latex?%7B%5Cdisplaystyle%20hash%28k%29%3Dk%5C%2C%7B%5Cbmod%20%7B%5C%2C%7D%7Dp%7D%2C%20%7B%5Cdisplaystyle%20p%5Cleq%20m%7D&quot; alt=&quot;&quot; name=&quot;equationview&quot;/&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;。不仅可以对关键字直接取模，也可在折叠法、平方取中法等运算之后取模。对p的选择很重要，一般取素数或m，若p选择不好，容易产生冲突。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;处理冲突&lt;/h3&gt;
&lt;p&gt;为了知道冲突产生的相同散列函数地址所对应的关键字，必须选用另外的散列函数，或者对冲突结果进行处理。而不发生冲突的可能性是非常之小的，所以通常对冲突进行处理。常用方法有以下几种：&lt;/p&gt;
&lt;dl&gt;&lt;dd&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;img id=&quot;equationview&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; src=&quot;https://latex.codecogs.com/gif.latex?%7B%5Cdisplaystyle%20d_%7Bi%7D%3D1%2C2%2C3...%28m-1%29%7D&quot; alt=&quot;&quot; name=&quot;equationview&quot;/&gt;称为 &lt;strong&gt;线性探测(Linear Probing)&lt;/strong&gt;；即&lt;img id=&quot;equationview&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; src=&quot;https://latex.codecogs.com/gif.latex?%7B%5Cdisplaystyle%20d_%7Bi%7D%3Di%7D&quot; alt=&quot;&quot; name=&quot;equationview&quot;/&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;，或者为其他线性函数。相当于逐个探测存放地址的表，直到查找到一个空单元，把散列地址存放在该空单元。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/dd&gt;
&lt;dd&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;img id=&quot;equationview&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; src=&quot;https://latex.codecogs.com/gif.latex?%7B%5Cdisplaystyle%20d_%7Bi%7D%3D%5Cpm%201%5E%7B2%7D%2C%5Cpm%202%5E%7B2%7D%2C%5Cpm%203%5E%7B2%7D...%5Cpm%20k%5E%7B2%7D%7D%20%7B%5Cdisplaystyle%20%28k%5Cleq%20m/2%29%7D&quot; alt=&quot;&quot; name=&quot;equationview&quot;/&gt;称为 &lt;strong&gt;平方探测(Quadratic Probing)&lt;/strong&gt;。相对线性探测，相当于发生冲突时探测间隔&lt;img id=&quot;equationview&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; src=&quot;https://latex.codecogs.com/gif.latex?%7B%5Cdisplaystyle%20d_%7Bi%7D%3Di%5E%7B2%7D%7D&quot; alt=&quot;&quot; name=&quot;equationview&quot;/&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;个单元的位置是否为空，如果为空，将地址存放进去。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/dd&gt;
&lt;dd&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;img id=&quot;equationview&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; src=&quot;https://latex.codecogs.com/gif.latex?%7B%5Cdisplaystyle%20d_%7Bi%7D%3D%7D&quot; alt=&quot;&quot; name=&quot;equationview&quot;/&gt;伪随机数序列，称为 &lt;strong&gt;伪随机探测&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/dd&gt;
&lt;/dl&gt;&lt;p&gt;显示&lt;strong&gt;线性探测&lt;/strong&gt;填装一个散列表的过程：&lt;/p&gt;
&lt;dl&gt;&lt;dd&gt;关键字为{89,18,49,58,69}插入到一个散列表中的情况。此时线性探测的方法是取&lt;img id=&quot;equationview&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; src=&quot;https://latex.codecogs.com/gif.latex?%7B%5Cdisplaystyle%20d_%7Bi%7D%3Di%7D&quot; alt=&quot;&quot; name=&quot;equationview&quot;/&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;。并假定取关键字除以10的余数为散列函数法则。&lt;/span&gt;&lt;/span&gt;&lt;/dd&gt;
&lt;/dl&gt;&lt;table class=&quot;wikitable&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;散列地址&lt;/th&gt;
&lt;th&gt;空表&lt;/th&gt;
&lt;th&gt;插入89&lt;/th&gt;
&lt;th&gt;插入18&lt;/th&gt;
&lt;th&gt;插入49&lt;/th&gt;
&lt;th&gt;插入58&lt;/th&gt;
&lt;th&gt;插入69&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;49&lt;/td&gt;
&lt;td&gt;49&lt;/td&gt;
&lt;td&gt;49&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;58&lt;/td&gt;
&lt;td&gt;58&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;69&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;89&lt;/td&gt;
&lt;td&gt;89&lt;/td&gt;
&lt;td&gt;89&lt;/td&gt;
&lt;td&gt;89&lt;/td&gt;
&lt;td&gt;89&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;dl&gt;&lt;dd&gt;第一次冲突发生在填装49的时候。地址为9的单元已经填装了89这个关键字，所以取&lt;img id=&quot;equationview&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; src=&quot;https://latex.codecogs.com/gif.latex?%7B%5Cdisplaystyle%20i%3D1%7D&quot; alt=&quot;&quot; name=&quot;equationview&quot;/&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;，往下查找一个单位，发现为空，所以将49填装在地址为0的空单元。第二次冲突则发生在58上，取&lt;img id=&quot;equationview&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; src=&quot;https://latex.codecogs.com/gif.latex?%7B%5Cdisplaystyle%20i%3D2%7D&quot; alt=&quot;&quot; name=&quot;equationview&quot;/&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;，往下查找两个单位，将58填装在地址为1的空单元。69同理。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/dd&gt;
&lt;dd&gt;表的大小选取至关重要，此处选取10作为大小，发生冲突的几率就比选择质数11作为大小的可能性大。越是质数，mod取余就越可能均匀分布在表的各处。&lt;/dd&gt;
&lt;/dl&gt;&lt;p&gt;聚集（Cluster，也翻译做“堆积”）的意思是，在函数地址的表中，散列函数的结果不均匀地占据表的单元，形成区块，造成线性探测产生一次聚集（primary clustering）和平方探测的二次聚集（secondary clustering），散列到区块中的任何关键字需要查找多次试选单元才能插入表中，解决冲突，造成时间浪费。对于开放定址法，聚集会造成性能的灾难性损失，是必须避免的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单独链表法：将散列到同一个存储位置的所有元素保存在一个链表中。实现时，一种策略是散列表同一位置的所有冲突结果都是用栈存放的，新元素被插入到表的前端还是后端完全取决于怎样方便。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;双散列。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;再散列：&lt;img id=&quot;equationview&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; src=&quot;https://latex.codecogs.com/gif.latex?%7B%5Cdisplaystyle%20hash_%7Bi%7D%3Dhash_%7Bi%7D%28key%29%7D%2C%20%7B%5Cdisplaystyle%20i%3D1%2C2...k%7D&quot; alt=&quot;&quot; name=&quot;equationview&quot;/&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;。&lt;img id=&quot;equationview&quot; title=&quot;This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.&quot; src=&quot;https://latex.codecogs.com/gif.latex?%7B%5Cdisplaystyle%20hash_%7Bi%7D%7D&quot; alt=&quot;&quot; name=&quot;equationview&quot;/&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;是一些散列函数。即在上次散列计算发生冲突时，利用该次冲突的散列函数地址产生新的散列函数地址，直到冲突不再发生。这种方法不易产生“聚集”（Cluster），但增加了计算时间。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;建立一个公共溢出区&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更详细的内容可以参照大学数据结构课本或者维基百科关于散列表的讲解：&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;3.Hash函数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;在计算机理论中，没有Hash函数的说法，只有单向函数的说法。所谓的单向函数，是一个复杂的定义，大家可以去看计算理论或者密码学方面的数据。用“人 类”的语言描述单向函数就是：如果某个函数在给定输入的时候，很容易计算出其结果来；而当给定结果的时候，很难计算出输入来，这就是单项函数。各种加密函 数都可以被认为是单向函数的逼近。Hash函数（或者成为散列函数）也可以看成是单向函数的一个逼近。即它接近于满足单向函数的定义。&lt;br/&gt;Hash函数还有另外的含义。实际中的Hash函数是指把一个大范围映射到一个小范围。把大范围映射到一个小范围的目的往往是为了节省空间，使得数据容易保存。除此以外，Hash函数往往应用于查找上。所以，在考虑使用Hash函数之前，需要明白它的几个限制：&lt;br/&gt;1. Hash的主要原理就是把大范围映射到小范围；所以，你输入的实际值的个数必须和小范围相当或者比它更小。不然冲突就会很多。&lt;br/&gt;2. 由于Hash逼近单向函数；所以，你可以用它来对数据进行加密。&lt;br/&gt;3. 不同的应用对Hash函数有着不同的要求；比如，用于加密的Hash函数主要考虑它和单项函数的差距，而用于查找的Hash函数主要考虑它映射到小范围的冲突率。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;Hash函数应用的主要对象是数组（比如，字符串），而其目标一般是一个int类型。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;一般的说，Hash函数可以简单的划分为如下几类：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;加法hash&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;位运算Hash&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;乘法Hash&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;除法Hash&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;查表Hash&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;混合Hash&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;下面将会详细的介绍以上各种方式在实际中的运用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;一、加法Hash&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;&lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;所谓的加法Hash就是把输入元素一个一个的加起来构成最后的结果。标准的加法Hash的构造如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; additiveHash(String key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; prime)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash, i;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(hash = key.length(), i = 0; i &amp;lt; key.length(); i++&lt;span&gt;){
        hash &lt;/span&gt;+=&lt;span&gt; key.charAt(i);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (hash %&lt;span&gt; prime);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的prime是任意的质数，看得出，结果的值域为[0,prime-1]。&lt;/p&gt;
&lt;h3&gt;二、位运算Hash&lt;/h3&gt;
&lt;p&gt;这类型Hash函数通过利用各种位运算（常见的是移位和异或）来充分的混合输入元素。比如，标准的旋转Hash的构造如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; rotatingHash(String key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; prime)
{
   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash,i;
   &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(hash=key.length(),i=0;i&amp;lt;key.length();++&lt;span&gt;i){
       hash &lt;/span&gt;= (hash&amp;lt;&amp;lt;4)^(hash&amp;gt;&amp;gt;28)^&lt;span&gt;key.charAt(i);
   }
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (hash %&lt;span&gt; prime);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先移位，然后再进行各种位运算是这种类型Hash函数的主要特点。比如，以上的那段计算hash的代码还可以有如下几种变形：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变形1：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
hash = (hash&amp;lt;27)^key.charAt(i);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;变形2：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
hash +=&lt;span&gt; key.charAt(i);
hash &lt;/span&gt;+= (hash &amp;lt;&amp;lt; 10&lt;span&gt;);
hash &lt;/span&gt;^= (hash &amp;gt;&amp;gt; 6);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;变形3：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;((i&amp;amp;1) == 0&lt;span&gt;){
    hash &lt;/span&gt;^= (hash&amp;lt;3&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
    hash &lt;/span&gt;^= ~((hash&amp;lt;5&lt;span&gt;));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;变形4：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
hash += (hash&amp;lt;&amp;lt;5) + key.charAt(i);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;变形5：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
hash = key.charAt(i) + (hash&amp;lt;16) – hash;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;变形6：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
hash ^= ((hash&amp;lt;2));
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;三、乘法Hash&lt;/h3&gt;
&lt;p&gt;这种类型的Hash函数利用了乘法的不相关性（乘法的这种性质，最有名的莫过于平方取头尾的随机数生成算法，虽然这种算法效果不好）。比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bernstein(String key){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=0;i&amp;lt;key.length();++&lt;span&gt;i){
        hash &lt;/span&gt;= 33*hash +&lt;span&gt; key.charAt(i);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hash;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用这种方式的著名Hash函数还有：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;32位FNV算法&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; M_SHIFT = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; FNVHash(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] data){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash = (&lt;span&gt;int&lt;/span&gt;)2166136261L&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; b : data){
        hash &lt;/span&gt;= (hash * 16777619) ^&lt;span&gt; b;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (M_SHIFT == 0&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hash;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (hash ^ (hash &amp;gt;&amp;gt; M_SHIFT)) &amp;amp;&lt;span&gt; M_MASK;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以及改进的FNV算法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; FNV32Hash {  
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; OFFSET_BASIS = 2166136261L;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 32位offset basis  &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; PRIME = 16777619; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 32位prime  &lt;/span&gt;
  
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; hash(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] src) {  
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; hash =&lt;span&gt; OFFSET_BASIS;  
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; b : src) {  
            hash &lt;/span&gt;^=&lt;span&gt; b;  
            hash &lt;/span&gt;*=&lt;span&gt; PRIME;  
        }  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hash;  
    }  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码中的OFFSET_BASIS，PRIME是32位的，不同的位数是用一个算法算出的常量，更多的可以参考文章：&lt;a href=&quot;http://www.isthe.com/chongo/tech/comp/fnv/&quot; target=&quot;_blank&quot;&gt;FNV quick index&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除了乘以一个固定的数，常见的还有乘以一个不断改变的数，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; RSHash(String str)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b = 378551&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a = 63689&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; str.length(); i++&lt;span&gt;){
        hash &lt;/span&gt;= hash * a +&lt;span&gt; str.charAt(i);
        a &lt;/span&gt;= a *&lt;span&gt; b;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (hash &amp;amp; 0x7FFFFFFF&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然Adler32算法的应用没有CRC32广泛，不过，它可能是乘法Hash里面最有名的一个了。关于它的介绍，大家可以去看RFC1950规范。&lt;/p&gt;
&lt;h3&gt;四、除法Hash&lt;/h3&gt;
&lt;p&gt;除法和乘法一样，同样具有表面上看起来的不相关性。不过，因为除法太慢，这种方式几乎找不到真正的应用。需要注意的是，我们在前面看到的hash的 结果除以一个prime的目的只是为了保证结果的范围。如果你不需要它限制一个范围的话，可以使用如下的代码替代hash%prime： hash = hash ^ (hash&amp;gt;&amp;gt;10) ^ (hash&amp;gt;&amp;gt;20)。&lt;/p&gt;
&lt;h3&gt;五 查表Hash&lt;/h3&gt;
&lt;p&gt;查表Hash最有名的例子莫过于CRC系列算法。虽然CRC系列算法本身并不是查表，但是，查表是它的一种最快的实现方式。查表Hash中有名的例子有：Universal Hashing和Zobrist Hashing。他们的表格都是随机生成的。&lt;/p&gt;
&lt;h3&gt;六 混合Hash&lt;/h3&gt;
&lt;p&gt;混合Hash算法利用了以上各种方式。各种常见的Hash算法，比如MD5、Tiger都属于这个范围。它们一般很少在面向查找的Hash函数里面使用。&lt;br/&gt;关于对Hash算法的评价：这个网站上&lt;a href=&quot;http://www.burtleburtle.net/bob/hash/doobs.html&quot; target=&quot;_blank&quot;&gt;http://www.burtleburtle.net/bob/hash/doobs.html&lt;/a&gt; 提供了对几种流行Hash算法的评价。我们对Hash函数的建议如下：&lt;/p&gt;
&lt;p&gt;1. 字符串的Hash。最简单可以使用基本的乘法Hash，当乘数为33时，对于英文单词有很好的散列效果（小于6个的小写形式可以保证没有冲突）。复杂一点可以使用FNV算法（及其改进形式），它对于比较长的字符串，在速度和效果上都不错。&lt;br/&gt;2. 长数组的Hash。可以使用&lt;a href=&quot;http://burtleburtle.net/bob/c/lookup3.c&quot; target=&quot;_blank&quot;&gt;http://burtleburtle.net/bob/c/lookup3.c&lt;/a&gt;这种算法，它一次运算多个字节，速度还算不错。&lt;/p&gt;
&lt;p&gt;Hash算法除了应用于这个方面以外，另外一个著名的应用是巨型字符串匹配（这时的 Hash算法叫做：rolling hash，因为它必须可以滚动的计算）。设计一个真正好的Hash算法并不是一件容易的事情。做为应用来说，选择一个适合的算法是最重要的。&lt;/p&gt;
&lt;p&gt;在数组方面有以下用途：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
inline &lt;span&gt;int&lt;/span&gt; hashcode(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; *&lt;span&gt;v){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;k;i++&lt;span&gt;){
        s &lt;/span&gt;= ((s&amp;lt;&amp;lt;2)+(v[i]&amp;gt;&amp;gt;4))^(v[i]&amp;lt;&amp;lt;10&lt;span&gt;);
    }
    s &lt;/span&gt;= s%&lt;span&gt;M;
    s &lt;/span&gt;= s&amp;lt;0?s+&lt;span&gt;M:s;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽说以上的hash能极大程度地避免冲突，但是冲突是在所难免的。所以无论用哪hash函数，都要加上处理冲突的方法。&lt;/p&gt;
&lt;h2&gt;4.典型例题讲解&lt;/h2&gt;
&lt;p&gt;说了那么多，怕是小伙伴们也看晕了，做几道题目看看就知道Hash到底是什么东西了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HDU 1280 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题意：给出n(3000)个数，两两求和，输出最大的m(5000)个和&lt;/p&gt;
&lt;p&gt;分析：典型的hash: 用数组下标表示两两相加所得到的和，开辟一个满足题意的大小的数组 sum，&lt;img title=&quot;hdu &amp;lt;wbr&amp;gt;1280&quot; src=&quot;http://img.voidcn.com/vcimg/000/000/016/913_3ab_758.gif&quot; alt=&quot;hdu &amp;lt;wbr&amp;gt;1280&quot; align=&quot;top&quot;/&gt;这样下标由大到小输出m个就可以了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main ()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a[&lt;span&gt;3001&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sum[&lt;span&gt;10010&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, m;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ( scanf (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;n, &amp;amp;m) !=&lt;span&gt; EOF )
    {
        memset ( a, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt; (a) );
        memset ( sum, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt; (sum) );
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i ++&lt;span&gt; )
        {
            scanf (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;a[i]);
        }
        
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; temp;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i ++&lt;span&gt; )
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( j = i + &lt;span&gt;1&lt;/span&gt;; j &amp;lt; n; j++&lt;span&gt; )
            {
                temp &lt;/span&gt;= a[i] +&lt;span&gt; a[j];
                sum[temp] &lt;/span&gt;++&lt;span&gt;;
            }
        }
        
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出前 m  个数&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; ( i = &lt;span&gt;10001&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt; ; i --&lt;span&gt; )
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( sum[i] )
            {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; sum[i]; j ++&lt;span&gt;)
                {
                    count &lt;/span&gt;++&lt;span&gt;;
                    count &lt;/span&gt;== &lt;span&gt;1&lt;/span&gt; ? printf (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, i) : printf (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( count ==&lt;span&gt; m )
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( count ==&lt;span&gt; m )
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        
        printf (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;HDU 1425&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题意：给你n个整数，请按从大到小的顺序输出其中前m大的数。&lt;/p&gt;
&lt;p&gt;分析：每组测试数据有两行，第一行有两个数n,m(0&amp;lt;n,m&amp;lt;1000000)，第二行包含n个各不相同，且都处于区间[-500000,500000]的整数。用hash牺牲空间换取时间，达到常数级。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
#include&amp;lt;cstdio&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cstring&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,m;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash[&lt;span&gt;1000010&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(~scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;&lt;span&gt;m)){
        memset(hash,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(hash));
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; t;
            scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;t);
            hash[t&lt;/span&gt;+&lt;span&gt;500000&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1000000&lt;/span&gt;;i&amp;gt;=&lt;span&gt;0&lt;/span&gt;;i--&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(hash[i]==&lt;span&gt;0&lt;/span&gt;)&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(m==&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
                printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,i-&lt;span&gt;500000&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,i-&lt;span&gt;500000&lt;/span&gt;&lt;span&gt;);
                m&lt;/span&gt;--&lt;span&gt;;
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;HDU 3833&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题意：给你一个1~n的排列...问是否存在a[i1]-a[i2]=a[i2]-a[i3] 其中(i1&amp;lt;i2&amp;lt;i3)&lt;/p&gt;
&lt;p&gt;思路：1到n每个元素只会出现一次，引入hash[]来记录该数是否已经出现，出现为1，否则为0 ；读入一个数t ，从1到t-1依次判断是否有hash[t-i]+hash[t+i]==1 即以t为中项，对于t-i,t+i是否仅出现过一个，由于是按顺序读入的，即可保证t-i和t+i在原序列中一定是在t的两边。本题一看到最长要求时间是4s，按照正常思路写用了3个for循环会超时，因此其中隐藏着某些算法。就现在所知，一是利用二级排序，二是利用hash表。先说说hash表吧。既然要找到1到n序列中是否存在满足题意的三个元素，注意这三个元素有先后顺序之分，可以用一个数组来模拟。首先将数组全部清0，然后开始读入元素i，每读入一个元素就将以该元素为下标的hash表中的元素加1，即hash[i]++，然后在hash表中寻找，在hash[i]的对称的前面和后面查找，如果hash[i-j]+hash[i+j]==1,说明在i出现时，有两种可能，一是比i小的数已经出现但比i大的数还没出现，或者比i大的数已经出现，比i小的数还没出现，没出现的数在i的后面，已经出现的在i的前面，这就找到了满足题意的序列。&lt;/p&gt;
&lt;p&gt;需要注意的是，题目说的是1到N的序列，不是说随便的N个数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
#include&amp;lt;cstdio&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cstring&amp;gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k,i,j,a,hash[&lt;span&gt;10047&lt;/span&gt;&lt;span&gt;],n,m,t;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(~scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;t))
    {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(t--&lt;span&gt;)
        {
            memset(hash,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(hash));
            k &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;n);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; l =  &lt;span&gt;0&lt;/span&gt; ; l &amp;lt; n ; l++&lt;span&gt;)
            {
                scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;i);
                hash[i]&lt;/span&gt;++;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以i为对称中心,请注意此处与代码二有所不同&lt;/span&gt;

                &lt;span&gt;if&lt;/span&gt;( k == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j = &lt;span&gt;1&lt;/span&gt; ; j &amp;lt; i &amp;amp;&amp;amp; j+i &amp;lt;= n ; j++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;对称是因为P[i1]- P[i2] = P[i2] - P[i3],它们的差（距离）要相等&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(hash[i-j]+hash[i+j] == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                    {
                        k &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt; ;
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                }
            }
            
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( k == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Y\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;N\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.推荐习题&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;HDU 1496  给定a,b,c,d。a*x1^2+b*x2^2+c*x3^2+d*x4^2=0，其中x1~x4 在 [-100,100]区间内， a,b,c,d在[-50,50] 区间内，求满足上面那个式子的所有解的个数。&lt;/li&gt;
&lt;li&gt;HDU 2648 有N个店，他们的商品价格每天都在上涨，问你 ith天有个叫memory的店，它的价格在所有商店中，有几个高过它，输出它的排名，有k个高过它，它就是第k+1名。&lt;/li&gt;
&lt;li&gt;HDU 2027 统计每个元音字母在字符串中出现的次数。&lt;/li&gt;
&lt;li&gt;POJ 1200 给出两个数n,nc，并给出一个由nc种字符组成的字符串。求这个字符串中长度为n的子串有多少种。&lt;/li&gt;
&lt;li&gt;POJ 3320 一本书有P页，每页有个知识点，知识点可以重复。问至少连续读几页，使得覆盖全部知识点。&lt;/li&gt;
&lt;li&gt;HDU 6161 给你一颗n个节点的完全二叉树，从根节点标号为1。标号为x的节点的左、右儿子标号分别为：2x、2x+1。这棵树的每个节点的权值为它本身的标号。现在告诉你有m次操作，每次操作要么就是把一个点变成给定值，要么就是让你输出经过给定某点的一条最长路径的长度。（一条路径的长度就是它经过的每个点的权值和，包括端点） 数据范围：$n&amp;lt;1e8，m&amp;lt;1e5$&lt;/li&gt;
&lt;li&gt;HDU 6046 给出一个1e3*1e3的矩阵以及 一个 生成1e6*1e6的矩阵的随机函数,在1e6*1e6的矩阵中找到1e3*1e3的矩阵的位置
&lt;p class=&quot;line number5 index4 alt2&quot;&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;HDU 4334 给五个数的集合，问能否从每个集合中取一个数，使五个数之和为0.&lt;/li&gt;
&lt;li&gt;HDU 1880 给你一个10w的词典,让你输出对应的字段&lt;/li&gt;
&lt;li&gt;HDU 5782  给出两个字符串，判断他们每一个前缀是否循环同构，循环同构的意思就是，字符串首位相接拼成一个环，两个环通过旋转可以相等。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;6.参考文献&lt;/h2&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 23 Apr 2018 07:22:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/8919336.html</dc:identifier>
</item>
<item>
<title>Ubuntu16  编译源码安装MXNet  可变卷积Deformable-ConvNets  GPU版 - Andre_Ma</title>
<link>http://www.cnblogs.com/andre-ma/p/8867031.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andre-ma/p/8867031.html</guid>
<description>&lt;p&gt;【引言】最近接手了公司的关于虫子识别的项目，使用MXNet框架开发，但是实际用的是Deformable-ConvNets. Deformable-ConvNets为微软研究研究院提出的可变卷积网络，可用于对图像中大小不一的物体识别，不是单单识别图中的猫和狗（它们都一般大小），而识别图像中不同种类的虫子（虫子本身小，而且难以区分），在这样的场景下很适合用可变卷积Deformable-ConvNets。&lt;/p&gt;
&lt;p&gt;MXNet本身灵活，扩展性强，根据 &lt;a title=&quot;Deformable-ConvNets&quot; href=&quot;https://github.com/msracver/Deformable-ConvNets&quot; target=&quot;_blank&quot;&gt;https://github.com/msracver/Deformable-ConvNets&lt;/a&gt; 官方教程摸索着走下来 一步步安装，其中有不少坑，网上大多教程没有实质性帮助，有些教程有帮助但是不完全适合自己的软硬件环境，这里总结一下，也希望能帮助到别人。&lt;/p&gt;

&lt;p&gt;目录：&lt;/p&gt;
&lt;p&gt;1 Ubuntu16.04  系统安装&lt;/p&gt;
&lt;p&gt;2 安装GPU显卡驱动&lt;/p&gt;
&lt;p&gt;3 安装CUDA并行计算库&lt;/p&gt;
&lt;p&gt;4 安装cudnn 神经网络加速库&lt;/p&gt;
&lt;p&gt;5 安装软件依赖&lt;/p&gt;
&lt;p&gt;6 可变卷积、MXNet 代码下载配置&lt;/p&gt;
&lt;p&gt;7 demo测试 &lt;/p&gt;



&lt;p&gt;需要的环境：&lt;/p&gt;
&lt;p&gt;操作系统：Ubuntu16.04  64位&lt;/p&gt;
&lt;p&gt;显卡：GTX1080ti   两块&lt;/p&gt;
&lt;p&gt;16G内存   5代 I7 处理器，&lt;/p&gt;
&lt;p&gt;显卡驱动：NVIDIA-Linux-x86_64-375.66.run &lt;/p&gt;
&lt;p&gt;CUDA ：cuda_8.0.61_375.26_linux.run&lt;/p&gt;
&lt;p&gt;cudnn: cudnn-8.0-linux-x64-v5.1.tgz&lt;/p&gt;
&lt;p&gt;由于 Deformable-ConvNets给的软件依赖版本叫老，所以这里用的驱动  CUDNN  CUDA都用较老版本，新版本速度会更快，但关键是环境搭建好，程序跑通~&lt;/p&gt;

&lt;p&gt;其他依赖及软件：&lt;/p&gt;
&lt;p&gt;opencv  3.4.0   源码安装+pip安装&lt;/p&gt;
&lt;p&gt;cmake  cmake-gui    pip安装&lt;/p&gt;
&lt;p&gt;openblas   源码安装&lt;/p&gt;
&lt;p&gt;Cython、EasyDict 1.6、opencv-python 3.2.0.6   mxnet-cu80==0.12.0b20171227    pip安装&lt;/p&gt;
&lt;p&gt;这里所有pip 安装的组件可以使用conda 安装 ，需自己安装Anaconda  or  miniconda&lt;/p&gt;

&lt;p&gt;Talk is cheap , show me the code!  开整&lt;/p&gt;


&lt;p&gt;推荐两款制作U盘启动盘的软件：UltraISO  (中文：软碟通） 和  Universal-USB-Installer&lt;/p&gt;
&lt;p&gt;下载好Ubuntu16的ISO镜像文件，烧写到U盘，U盘内容需提前备份，烧写时要格式化U盘，烧写好进入BIOS 选择U盘启动&lt;/p&gt;
&lt;p&gt;注意：U盘启动分两种： 一种是普通的usb disk 启动  ，  另一种是UEFI版的 usb disk ， 第二种更快些， 具体安装这里不详述&lt;/p&gt;
&lt;p&gt;【补充】：Ubuntu自带Python环境，也可以安装miniconda 或  anaconda , 本教程安装了Anaconda2  &lt;/p&gt;
&lt;p&gt;【建议】：提前换对应的国内源，如apt 阿里源&lt;/p&gt;
&lt;p&gt;conda 清华源   pip 豆瓣或阿里源 &lt;/p&gt;


&lt;p&gt;2.0 建议提前进入系统BIOS，&lt;strong&gt;关闭 Secure Boot&lt;/strong&gt; ， 否则当系统自带驱动删除后，不能进入Ubuntu系统，同时建议在ubuntu 16系统下修改&lt;strong&gt;gcc  g++ 版本号为4.9 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.1干净删除系统自带nouveau驱动&lt;/p&gt;
&lt;p&gt;这部分有点麻烦了，因为除了要下载好对应版本的显卡驱动和安装外，还需&lt;strong&gt;干净&lt;/strong&gt;删除系统自带的显卡驱动&lt;span&gt;nouveau&lt;/span&gt;，&lt;strong&gt;这里是两次删除&lt;/strong&gt;，一次是删除Ubuntu16系统自带驱动，第二次是删除Linux内核里自带驱动相关配置&lt;/p&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;https://blog.csdn.net/10km/article/details/61191230&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/10km/article/details/61191230&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/eclipse_c/article/details/23302061&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/eclipse_c/article/details/23302061&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.2 安装自己提前下载好的驱动程序 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sh&lt;/span&gt; NVIDIA-Linux-x86_64-&lt;span&gt;375.66&lt;/span&gt;.run
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显卡驱动安装好后，&lt;strong&gt;要配置内核文件&lt;/strong&gt;，防止重启后内核又读取nouveau启动，会出现幺蛾子问题...&lt;/p&gt;
&lt;p&gt;检查显卡驱动是否装好：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
nvidia-smi  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个命令是用于检查显卡驱动安装情况的，而不是CUDA安装情况！&lt;/p&gt;
&lt;p&gt;若能看到有方框，里面显示着自己安装显卡驱动的版本号，还有显卡型号以及现存使用率，则显卡驱动安装成功，恭喜！&lt;/p&gt;


&lt;h2&gt;3.1下载&lt;/h2&gt;
&lt;p&gt;提前下载好对应显卡型号的CUDA 版本，现在最新是CUDA9.1  我下载了8.0，也不是最新的8.0，只是求稳定，至于CUDA格式 最好是.run   这个没有错&lt;/p&gt;
&lt;h2&gt;3.2 安装&lt;/h2&gt;
&lt;p&gt;安装过程   要&lt;strong&gt;安装CUDA 两次  +  配置环境变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一次安装 ：  &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;sh&lt;/span&gt; cuda_8.&lt;span&gt;0&lt;/span&gt;.61_375.26_linux.run&lt;/span&gt;   期间要同意协议，最好安装examples用于测试CUDA安装结果，一定不要安装显卡驱动，显卡驱动的安装用自己在官网上下载的程序安装&lt;/p&gt;
&lt;p&gt;第二次安装  :    &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;sh&lt;/span&gt; cuda_8.&lt;span&gt;0&lt;/span&gt;.61_375.26_linux.run -silent -driver&lt;/span&gt;    等一会就好了，不同一步步来&lt;/p&gt;
&lt;p&gt;配置环境变量：  【或需根据自己配置的场景修改路径】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
export LD_LIBRARY_PATH=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$LD_LIBRARY_PATH:/usr/local/cuda/lib64:/usr/local/cuda/extras/CUPTI/lib64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
export CUDA_HOME&lt;/span&gt;=/usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;提前在NVIDIA官网上下载对应CUDA版本的cudnn ，下载时要注册 登录，下载好是个tar.gz文件&lt;/p&gt;
&lt;p&gt;解压   &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;tar&lt;/span&gt; -xzf cudnn-&lt;span&gt;8.0&lt;/span&gt;-linux-x64-v5.&lt;span&gt;1&lt;/span&gt;.tgz ~/&lt;/span&gt;        [假设解压后目录为cudnn5.1]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cp&lt;/span&gt;  cudnn5.&lt;span&gt;1&lt;/span&gt;/include/cudnn*  /usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt;/include/
&lt;span&gt;cp&lt;/span&gt;  cudnn5.&lt;span&gt;1&lt;/span&gt;/lib64/libcudnn*  /usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt;/lib64
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于可变卷积依赖四种软件： EasyDict  Cython opencv  mxnet-cu80==0.1.2.0b20171027   &lt;/p&gt;
&lt;p&gt;opencv在这里最好先用源码安装，&lt;strong&gt;同时也要&lt;/strong&gt;用pip 安装 opencv-python接口库  (Tips:用pip安装软件时可先还pip源为阿里源，下载速度快很多：）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
pip &lt;span&gt;install&lt;/span&gt;&lt;span&gt; Cython
pip &lt;/span&gt;&lt;span&gt;install&lt;/span&gt; opencv-python==&lt;span&gt;3.2&lt;/span&gt;.&lt;span&gt;0.6&lt;br/&gt;&lt;/span&gt;&lt;span&gt;conda install -c auto easydict   # 可先通过conda安装 easydict  本步骤也不是必须
pip &lt;/span&gt;&lt;span&gt;install&lt;/span&gt; easydict == &lt;span&gt;1.6      # 关键是要用pip 安装easydict  1.6版本  且本行命令后于前一条命令&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译MXNet源码时，要用到openblas线性代数库，需要&lt;strong&gt;源码安装 openblas&lt;/strong&gt;，同时安装 &lt;strong&gt;openblas接口&lt;/strong&gt;   pip或conda安装都行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
conda &lt;span&gt;install&lt;/span&gt; openblas
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假设 OPENBLAS_HOME = &lt;span class=&quot;cnblogs_code&quot;&gt;/usr/local/OpenBLAS&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;openblas源码编译安装 参考教程：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xzzppp/article/details/69633789&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/xzzppp/article/details/69633789&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/tsq292978891/article/details/79575036&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/tsq292978891/article/details/79575036&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;mxnet-cu80包括很多不同的子版本，用pip安装 &lt;/p&gt;
&lt;p&gt;EasyDict  Cython  这些只是会简单调用，不需要源码安装 ， pip 或  conda安装就行，&lt;strong&gt;一定要注意版本&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;引用：&lt;a href=&quot;https://blog.csdn.net/zchang81/article/details/73250896&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/zchang81/article/details/73250896&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;6.1 clone可变卷积代码库&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/msracver/Deformable-ConvNets.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6.2 运行脚本简单初始化&lt;/h2&gt;
&lt;p&gt;Windows 用户请运行  &lt;span class=&quot;cnblogs_code&quot;&gt;cmd .init.bat&lt;/span&gt; Linux 用户请运行  &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;sh&lt;/span&gt; ./init.&lt;span&gt;sh&lt;/span&gt;&lt;/span&gt;   该脚本会自动编译 cython 模块并创建一些文件夹。&lt;/p&gt;
&lt;h2&gt;6.3 mxnet源码下载，配置， 编译 ， 安装&lt;/h2&gt;
&lt;p&gt;mxnet github官网：&lt;a href=&quot;https://github.com/apache/incubator-mxnet&quot; target=&quot;_blank&quot;&gt;https://github.com/apache/incubator-mxnet&lt;/a&gt;  有多个mxnet版本代码：如0.11.0   0.12.0  1.1.0  1.2.0   0.10.0 &lt;/p&gt;
&lt;p&gt;其中按照  &lt;a title=&quot;Deformable-ConvNets&quot; href=&quot;https://github.com/msracver/Deformable-ConvNets&quot; target=&quot;_blank&quot;&gt;https://github.com/msracver/Deformable-ConvNets&lt;/a&gt;  的教程下载MXNet 源码并恢复对应版本号安装的是mxnet==0.10.0&lt;/p&gt;
&lt;p&gt;实验中还试了 mxnet1.2.0源码下载，可恢复到指定版本 MXNet@998378a ， 0.11.0  0.12.0  1.1.0 试过不能恢复到998378a版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
###  下面的命令clone+恢复版本，编译安装的是0.10.0mxnet版本，也可下载1.2.0mxnet源码,解压 从git checkeout 开始执行&lt;br/&gt;git clone --recursive https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/dmlc/mxnet.git&lt;/span&gt;
&lt;span&gt;git checkout 998378a
git submodule update
# &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; it&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s the first time to checkout, just use: git submodule update --init --recursive&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;拷贝配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cd MXNET_HOME         # 跳转到mxnet源码目录下
&lt;/span&gt;&lt;span&gt;cp&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;/config.mk .   # 拷贝make文件夹下的config.mk到当前目录，也就是  MXNET_HOME
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要修改make 配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
vim config.mk
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改如下选项，路径引用或根据用户设置不同有对应不同的修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
ADD_LDFLAGS =&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-L/usr/local/OpenBLAS/lib&lt;/span&gt;&lt;span&gt;'        # 引用源码编译的OpenBLAS库&lt;/span&gt;&lt;span&gt;
ADD_CFLAGS &lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-I/usr/local/OpenBLAS/include&lt;/span&gt;&lt;span&gt;'     &lt;/span&gt;&lt;span&gt;

USE_CUDA &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
USE_CUDA_PATH &lt;/span&gt;= /usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt;&lt;span&gt;
USE_CUDNN &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;

ifeq ($(UNAME_S), Darwin)
USE_BLAS &lt;/span&gt;=&lt;span&gt; apple
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
USE_BLAS &lt;/span&gt;=&lt;span&gt; openblas
endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入setup-utils目录设置 mxnet源码路径&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
cd MXNET_HOME/setup-&lt;span&gt;utils
vim &lt;/span&gt;&lt;span&gt;install&lt;/span&gt;-mxnet-ubuntu-python.&lt;span&gt;sh    #在Ubuntu环境下安装编译安装python接口，若是其他系统和接口，对应修改相应文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改mxnet路径即可，并保存退出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
MXNET_HOME=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$HOME/MXNET_HOME/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行安装脚本进行安装，也可以在MXNET_HOME目录下，make  编译安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
bash &lt;span&gt;install&lt;/span&gt;-mxnet-ubuntu-python.&lt;span&gt;sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;make过程可能有报错：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Collect2:error : &lt;span&gt;ld&lt;/span&gt; returned &lt;span&gt;1&lt;/span&gt;&lt;span&gt; exit status
Makefile:&lt;/span&gt;&lt;span&gt;450&lt;/span&gt;: recipe &lt;span&gt;for&lt;/span&gt; target ‘bin/&lt;span&gt;im2rec’ failed
Make: &lt;/span&gt;*** [bin/im2rec] Error &lt;span&gt;1&lt;/span&gt;&lt;span&gt; 
原因：bin&lt;/span&gt;/目录下缺少im2rec  本错误不用管，&lt;br/&gt;继续 cd python; python setup.py install安装就好
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;make 过程报错：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
/tmp/&lt;span&gt;ccFNBmkk.o：在函数‘main’中：
im2rec.&lt;/span&gt;&lt;span&gt;cc&lt;/span&gt;:(.text.startup+&lt;span&gt;0x276c&lt;/span&gt;)：对‘cv::imencode(std::&lt;span&gt;string&lt;/span&gt; const&amp;amp;, cv::_InputArray const&amp;amp;, std::vector&amp;lt;unsigned &lt;span&gt;char&lt;/span&gt;, std::allocator&amp;lt;unsigned &lt;span&gt;char&lt;/span&gt;&amp;gt; &amp;gt;&amp;amp;, std::vector&amp;lt;&lt;span&gt;int&lt;/span&gt;, std::allocator&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; &amp;gt; const&amp;amp;&lt;span&gt;)’未定义的引用
collect2: error: &lt;/span&gt;&lt;span&gt;ld&lt;/span&gt; returned &lt;span&gt;1&lt;/span&gt;&lt;span&gt; exit status
Makefile:&lt;/span&gt;&lt;span&gt;327&lt;/span&gt;: recipe &lt;span&gt;for&lt;/span&gt; target bin/&lt;span&gt;im2rec failed
&lt;/span&gt;&lt;span&gt;make&lt;/span&gt;: *** [bin/im2rec] Error &lt;span readability=&quot;3&quot;&gt;1&lt;p&gt;本错误是在编译cpp文件时make引用opencv的动态链接库出现的问题，需要编译opencv源码安装opencv 同时pip安装python-opencv 接口&lt;br/&gt;opencv版本 3.2.0.6 &lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;经测试：rfcn和deeplab 的 demo不可同时跑通，因为rfcn和deeplab所依赖的easydict版本不同，初测rfcn依赖pip安装的easydict==1.6 ; deeplab依赖conda 安装的easydict==1.4 &lt;/p&gt;
&lt;p&gt;貌似rfcn和deeplab demo对opencv版本依赖也不一样，rfcn依赖python-opencv==3.2.0.6  deeplab 依赖opencv3.4.0  【不同opencv版本互斥，故不可同时run  demo】&lt;/p&gt;
&lt;p&gt;【假设】：&lt;a title=&quot;Deformable-ConvNets&quot; href=&quot;https://github.com/msracver/Deformable-ConvNets&quot; target=&quot;_blank&quot;&gt;Deformable-ConvNets&lt;/a&gt;的根目录为DCN_NETS&lt;/p&gt;
&lt;p&gt;根据 &lt;a title=&quot;Deformable-ConvNets&quot; href=&quot;https://github.com/msracver/Deformable-ConvNets&quot; target=&quot;_blank&quot;&gt;https://github.com/msracver/Deformable-ConvNets&lt;/a&gt; 教程下载demo_model 和 pretrained_model文件，解压放到&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd  DCN_NETS/&lt;span&gt;model
&lt;/span&gt;&lt;span&gt;tar&lt;/span&gt; -&lt;span&gt;xzf demo_model&lt;br/&gt;cd DCN_NETS&lt;/span&gt;/model/&lt;span&gt;pretrained_model 
&lt;/span&gt;&lt;span&gt;tar&lt;/span&gt; -xzf pretrained_model 
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cd  DCN_NETS

python .&lt;/span&gt;/rfcn/&lt;span&gt;demo.py             # 默认是使用可变卷积的Demo
python .&lt;/span&gt;/rfcn/demo.py --&lt;span&gt;rfcn_only&lt;br/&gt;python .&lt;/span&gt;/deeplab/&lt;span&gt;demo.py
python .&lt;/span&gt;/deeplab/demo.py --deeplab_only&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;【总结】&lt;/p&gt;
&lt;p&gt;1.可变卷积由于在网络结构中增加了形变层（即学习偏移量），使CNN网络对图像中不同像素大小的物体有更好的检测效果&lt;/p&gt;
&lt;p&gt;2.加上该偏移量的学习之后，可变卷积核的大小和位置可以根据当前需要识别的图像内容进行动态调整，其直观效果就是不同位置的卷积核采样点位置会根据图像内容发生自适应的变化，从而适应不同物体的形状、大小等几何形变。&lt;/p&gt;
&lt;p&gt;3.通过修改模型结构，对于一个已训练的模型只需增加很少计算量，就能达到准确率大幅上升且能识别图中不同大小像素的功能。&lt;/p&gt;

</description>
<pubDate>Mon, 23 Apr 2018 07:19:00 +0000</pubDate>
<dc:creator>Andre_Ma</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/andre-ma/p/8867031.html</dc:identifier>
</item>
<item>
<title>C++11的原子量与内存序浅析 - 兔晓侠</title>
<link>http://www.cnblogs.com/FateTHarlaown/p/8919235.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FateTHarlaown/p/8919235.html</guid>
<description>&lt;p&gt;在多线程编程中经常需要在不同线程之间共享一些变量，然而对于共享变量操作却经常造成一些莫名奇妙的错误，除非老老实实加锁对访问保护，否则经常出现一些（看起来）匪夷所思的情况。比如下面便是两种比较“喜闻乐见”的情况。&lt;/p&gt;
&lt;h2 id=&quot;a-i问题&quot;&gt;(a) i++问题&lt;/h2&gt;
&lt;p&gt;在多线程编程中，最常拿来举例的问题便是著名的i++ 问题，即：多个线程对同一个共享变量i执行i++ 操作。这样做之所以会出现问题的原因在于i++这个操作可以分为三个步骤：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;i-&amp;gt;reg(读取i的值到寄存器)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;inc-reg(在寄存器中自增i的值)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;reg-&amp;gt;i (写回内存中的i)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;上面三个步骤中间是可以间隔的，并非原子操作，也就是说多个线程同时执行的时候可能出步骤的交叉执行，例如下面的情况：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;i-&amp;gt;reg&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;inc-reg&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;i-&amp;gt;reg&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;inc-reg&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;5&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;reg-&amp;gt;i&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;6&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;reg-&amp;gt;i&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;假设i一开始为0，则执行完第4步后，在两个线程都认为寄存器中的值为1，然后在第5、6两步分别写回去。最终两个线程执行完成后i的值为1。但是实际上我们在两个线程中执行了i++，原本希望i的值为2。i++ 实际上可以代表多线程编程中由于操作不是原子的而引发的交叉执行这一类的问题，但是在这里我们先只关注对单个变量的操作。&lt;/p&gt;
&lt;h2 id=&quot;b指令重排问题&quot;&gt;(b)指令重排问题&lt;/h2&gt;
&lt;p&gt;有时候，我们会用一个变量作为标志位，当这个变量等于某个特定值的时候就进行某些操作。但是这样依然可能会有一些意想不到的坑，例如两个线程以如下顺序执行：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;a = 1&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;flag= true&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;if flag== true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;assert(a == 1)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;当B判断flag为true后，断言a为1，看起来的确是这样。那么一定是这样吗？可能不是，因为编译器和CPU都可能将指令进行重排（编译器不同等级的优化和CPU的乱序执行）。实际上的执行顺序可能变成这样：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;flag = true&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;if flag== true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;assert(a == 1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;a = 1&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这种重排有可能会导致一个线程内相互之间不存在依赖关系的指令交换执行顺序，以获得更高的执行效率。比如上面：flag 与 a 在A线程看起来是没有任何依赖关系，似乎执行顺序无关紧要。但问题在于B使用了flag作为是否读取a的依据，A的指令重排可能会导致step3&lt;br/&gt;的时候断言失败。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;一个比较稳妥的办法就是对于共享变量的访问进行加锁，加锁可以保证对临界区的互斥访问，例如第一种场景如果加锁后再执行i++ 然后解锁，则同一时刻只会有一个线程在执行i++ 操作。另外，加锁的内存语义能保证一个线程在释放锁前的写入操作一定能被之后加锁的线程所见（即有happens before 语义），可以避免第二种场景中读取到错误的值。&lt;/p&gt;
&lt;p&gt;那么如果觉得加锁操作过重太麻烦而不想加锁呢？C++11提供了一些原子变量与原子操作来支持。&lt;/p&gt;

&lt;p&gt;C++11标准在标准库atomic头文件提供了模版atomic&amp;lt;&amp;gt;来定义原子量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;template&amp;lt; class T &amp;gt;
struct atomic;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它提供了一系列的成员函数用于实现对变量的原子操作，例如读操作load，写操作store，以及CAS操作compare_exchange_weak/compare_exchange_strong等。而对于大部分内建类型，C++11提供了一些特化：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;std::atomic_bool    std::atomic&amp;lt;bool&amp;gt;
std::atomic_char    std::atomic&amp;lt;char&amp;gt;
std::atomic_schar   std::atomic&amp;lt;signed char&amp;gt;
std::atomic_uchar   std::atomic&amp;lt;unsigned char&amp;gt;
std::atomic_short   std::atomic&amp;lt;short&amp;gt;
std::atomic_ushort  std::atomic&amp;lt;unsigned short&amp;gt;
std::atomic_int std::atomic&amp;lt;int&amp;gt;
std::atomic_uint    std::atomic&amp;lt;unsigned int&amp;gt;
std::atomic_long    std::atomic&amp;lt;long&amp;gt;
······
//更多类型见：http://en.cppreference.com/w/cpp/atomic/atomic&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上这些特化就是相当于取了一个别名，本质上是同样的定义。而对于整形的特化而言，会有一些特殊的成员函数，例如原子加fetch_add&lt;br/&gt;、原子减fetch_sub、原子与fetch_and、原子或fetch_or等&lt;br/&gt;。常见操作符++、--、+=、&amp;amp;= 等也有对应的重载版本。&lt;/p&gt;
&lt;p&gt;接下来以int类型为例，解决我们的前面提到的i++ 场景中的问题。先定义一个int类型的原子量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;std::atomic&amp;lt;int&amp;gt; i;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于int型的原子量重载了++ 操作符，所以i++ 是一个不可分割的原子操作，我们用多个线程执行i++ 操作来进行验证，测试代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;atomic&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;thread&amp;gt;

std::atomic&amp;lt;int&amp;gt; i;
const int count = 100000;
const int n = 10;

void add()
{
    for (int j = 0; j &amp;lt; count; ++j)
        i++;
}

int main()
{
    i.store(0);
    std::vector&amp;lt;std::thread&amp;gt; workers;
    std::cout &amp;lt;&amp;lt; &quot;start &quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &quot; workers, &quot;
              &amp;lt;&amp;lt; &quot;every woker inc &quot; &amp;lt;&amp;lt; count  &amp;lt;&amp;lt; &quot; times&quot; &amp;lt;&amp;lt; std::endl;

    for (int j = 0; j &amp;lt; n; ++j)
        workers.push_back(std::move(std::thread(add)));

    for (auto &amp;amp; w : workers)
        w.join();

    std::cout &amp;lt;&amp;lt; &quot;workers end &quot;
              &amp;lt;&amp;lt; &quot;finally i is &quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl;

    if (i == n * count)
        std::cout &amp;lt;&amp;lt; &quot;i++ test passed!&quot; &amp;lt;&amp;lt; std::endl;
    else
        std::cout &amp;lt;&amp;lt; &quot;i++ test failed!&quot; &amp;lt;&amp;lt; std::endl;

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在测试中，我们定义了一个原子量i，在main函数开始的时候初始化为0，然后启动10个线程，每个线程执行i++操作十万次，最终检查i的值是否正确。执行的最后结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;start 10 workers, every woker inc 100000 times
workers end finally i is 1000000
i++ test passed!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们可以看到，10个线程同时进行大量的自增操作，i的值依然正常。假如我们把i修改为一个普通的int变量，再次执行程序可以得到结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;start 10 workers, every woker inc 100000 times
workers end finally i is 445227
i++ test failed!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，由于自增操作各个步骤的交叉执行，导致最后我们得到一个错误的结果。&lt;/p&gt;
&lt;p&gt;原子量可以解决i++问题，那么可以解决指令重排的问题吗？也是可以的，和原子量选择的内存序有关，我们把这个问题放到下一节专门研究。&lt;/p&gt;
&lt;p&gt;上面已经看到atomic是一个模版，那么也就意味着我们可以把自定义类型变成原子变量。但是是否任意类型都可以定义为原子类型呢？当然不是，cppreference中的描述是必须为TriviallyCopyable类型。这个连接为TriviallyCopyable的详细定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://en.cppreference.com/w/cpp/concept/TriviallyCopyable&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个比较简单的判断标准就是这个类型可以用std::memcpy按位复制，例如下面的类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class {
    int x;
    int y;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类是一个TriviallyCopyable类型，然而如果给它加上一个虚函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class {
    int x;
    int y;
    virtual int add ()
    {
        return x + y;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类便不能按位拷贝了，不满足条件，不能进行原子化。&lt;/p&gt;
&lt;p&gt;如果一个类型能够满足atomic模版的要求，可以原子化，它就不用进行加锁操作了，因而速度更快吗？依然不是，atomic有一个成员函数is_lock_free，这个成员函数可以告诉我们到底这个类型的原子量是使用了原子CPU指令实现了无锁化，还是依然使用的加锁的方式来实现原子操作。不过不管是否用锁来实现，atomic的使用方式和表现出的语义都是没有区别的。具体用哪种方式实现C++标准并没有做约束（除了std::atomic_flag特化要求必须为lock free），跟平台有关。&lt;br/&gt;例如在我的Cygwin64、GCC7.3环境下执行如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;atomic&amp;gt;

#define N 8

struct A {
    char a[N];
};

int main()
{
    std::atomic&amp;lt;A&amp;gt; a;
    std::cout &amp;lt;&amp;lt; sizeof(A) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; a.is_lock_free() &amp;lt;&amp;lt; std::endl;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;8
1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;证明上面定义的类型A的原子量是无锁的。我在这个平台上进行了实验，修改N的大小，结果如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;5&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;5&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;6&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;6&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;7&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;7&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;8&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;8&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;&amp;gt; 8&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;将A修改为内建类型，对于内建类型的实验结果如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;char&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;short&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;int&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;long long&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;8&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;float&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;double&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;8&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可以看出在我的平台下常用内建类型都是lock free的，自定义类型则和大小有关。&lt;/p&gt;
&lt;p&gt;从上面的统计还可以看出似乎当自定义类型的长度和某种自定义类型相等的时候is_lock_free()就为true。我推测可能我这里的atomic实现的无锁是通过编译器内建的原子操作实现的，只有当数据长度刚好能调用编译器内建原子操作时才能进行无锁化。查看GCC参考手册（&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-7.3.0/gcc/_005f_005fatomic-Builtins.html#g_t_005f_005fatomic-Builtins&quot; class=&quot;uri&quot;&gt;https://gcc.gnu.org/onlinedocs/gcc-7.3.0/gcc/_005f_005fatomic-Builtins.html#g_t_005f_005fatomic-Builtins&lt;/a&gt;） 中内建原子操作的原型，以CAS操作为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bool __atomic_compare_exchange_n (type *ptr, type *expected, type desired, bool weak, int success_memorder, int failure_memorder)

bool __atomic_compare_exchange (type *ptr, type *expected, type *desired, bool weak, int success_memorder, int failure_memorder)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其参数类型为type *的指针，在同一页可以找到GCC关于type的描述：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;The ‘__atomic’ builtins can be used with any integral scalar or pointer type that is 1, 2, 4, or 8 bytes in length. 16-byte integral types are also allowed if ‘__int128’ (see __int128) is supported by the architecture.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;type类型的长度应该为1、2、4、8字节中的一个，少数支持__int128的平台可以到16字节，所以只有长度为1，2，4，8字节的数据才能实现无锁。这个只是我的推测，具体是否如此尚不明白。&lt;/p&gt;

&lt;p&gt;前面我们解决i++问题的时候已经使用过原子量的写操作load将原子量赋值，实际上成员函数还有另一个参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void store( T desired, std::memory_order order = std::memory_order_seq_cst )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个参数代表了该操作使用的内存序，用于控制变量在不同线程见的顺序可见性问题，不只load，其他成员函数也带有该参数。c++11提供了六种内存序供选择，分别为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef enum memory_order {
    memory_order_relaxed,
    memory_order_consume,
    memory_order_acquire,
    memory_order_release,
    memory_order_acq_rel,
    memory_order_seq_cst
} memory_order;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之前在场景2中，因为指令的重排导致了意料之外的错误，通过使用原子变量并选择合适内存序，可以解决这个问题。下面先来看看这几种内存序&lt;/p&gt;
&lt;h2 id=&quot;memory_order_releasememory_order_acquire&quot;&gt;memory_order_release/memory_order_acquire&lt;/h2&gt;
&lt;p&gt;内存序选项用来作为原子量成员函数的参数，memory_order_release用于store操作，memory_order_acquire用于load操作，这里我们把使用了memory_order_release的调用称之为release操作。从逻辑上可以这样理解：release操作可以阻止这个调用之前的读写操作被重排到后面去，而acquire操作则可以保证调用之后的读写操作不会重排到前面来。听起来有种很绕的感觉，还是以一个例子来解释：假设flag为一个 atomic特化的bool 原子量，a为一个int变量，并且有如下时序的操作：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;a = 1&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;flag.store(true, memory_order_release)&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;if( true == flag.load(memory_order_acquire))&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;assert(a == 1)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;实际上这就是把我们上文场景2中的flag变量换成了原子量，并用其成员函数进行读写。在这种情况下的逻辑顺序上，step1不会跑到step2后面去，step4不会跑到step3前面去。这样一来，实际上我们就已经保证了当读取到flag为true的时候a一定已经被写入为1了，场景2得到了解决。换一种比较严谨的描述方式可以总结为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于同一个原子量，release操作前的写入，一定对随后acquire操作后的读取可见。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两种内存序是需要配对使用的，这也是将他们放在一起介绍的原因。还有一点需要注意的是：只有对同一个原子量进行操作才会有上面的保证，比如step3如果是读取了另一个原子量flag2，是不能保证读取到a的值为1的。&lt;/p&gt;
&lt;h2 id=&quot;memory_order_releasememory_order_consume&quot;&gt;memory_order_release/memory_order_consume&lt;/h2&gt;
&lt;p&gt;memory_order_release还可以和memory_order_consume搭配使用。memory_order_release操作的作用没有变化，而memory_order_consume用于load操作，我们简称为consume操作，comsume操作防止在其后对原子变量有依赖的操作被重排到前面去。这种情况下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于同一个原子变量，release操作所依赖的写入，一定对随后consume操作后依赖于该原子变量的操作可见。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个组合比上一种更宽松，comsume只阻止对这个原子量有依赖的操作重拍到前面去，而非像aquire一样全部阻止。将上面的例子稍加改造来展示这种内存序，假设flag为一个 atomic特化的bool 原子量，a为一个int变量，b、c各为一个bool变量，并且有如下时序的操作：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;b = true&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;a = 1&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;flag.store(b, memory_order_release)&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;while (!(c = flag.load(memory_order_consume)))&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;5&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;assert(a == 1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;6&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;assert(c == true)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;7&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;assert(b == true)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;step4使得c依赖于flag，当step4线程B读取到flag的值为true的时候，由于flag依赖于b，b在之前的写入是可见的，此时b一定为true，所以step6、step7的断言一定会成功。而且这种依赖关系具有传递性，假如b又依赖与另一个变量d，则d在之前的写入同样对step4之后的操作可见。那么a呢？很遗憾在这种内存序下a并不能得到保证，step5的断言可能会失败。&lt;/p&gt;
&lt;h2 id=&quot;memory_order_acq_rel&quot;&gt;memory_order_acq_rel&lt;/h2&gt;
&lt;p&gt;这个选项看名字就很像release和acquire的结合体，实际上它的确兼具两者的特性。这个操作用于“读取-修改-写回”这一类既有读取又有修改的操作，例如CAS操作。可以将这个操作在内存序中的作用想象为将release操作和acquire操作捆在一起，因此任何读写操作的重拍都不能跨越这个调用。依然以一个例子来说明，flag为一个 atomic特化的bool 原子量，a、c各为一个int变量，b为一个bool变量,并且刚好按如下顺序执行：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;a = 1&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;flag.store(true, memory_order_release)&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;b = true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;c = 2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;center&quot;&gt;5&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;while (!flag.compare_exchange_weak(b, false, memory_order_acq_rel)) {b = true}&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;6&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;assert(a == 1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;7&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;if (true == flag.load(memory_order_acquire)&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;8&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;assert(c == 2)&lt;/td&gt;
&lt;td align=&quot;center&quot;/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;由于memory_order_acq_rel同时具有memory_order_release与memory_order_acquire的作用，因此step2可以和step5组合成上面提到的release/acquire组合，因此step6的断言一定会成功，而step5又可以和step7组成release/acquire组合，step8的断言同样一定会成功。&lt;/p&gt;
&lt;h2 id=&quot;memory_order_seq_cst&quot;&gt;memory_order_seq_cst&lt;/h2&gt;
&lt;p&gt;这个内存序是各个成员函数的内存序默认选项，如果不选择内存序则默认使用memory_order_seq_cst。这是一个“美好”的选项，如果对原子变量的操作都是使用的memory_order_seq_cst内存序，则多线程行为相当于是这些操作都以一种特定顺序被一个线程执行，在哪个线程观察到的对这些原子量的操作都一样。同时，任何使用该选项的写操作都相当于release操作，任何读操作都相当于acquire操作，任何“读取-修改-写回”这一类的操作都相当于使用memory_order_acq_rel的操作。&lt;/p&gt;
&lt;h2 id=&quot;memory_order_relaxed&quot;&gt;memory_order_relaxed&lt;/h2&gt;
&lt;p&gt;这个选项如同其名字，比较松散，它仅仅只保证其成员函数操作本身是原子不可分割的，但是对于顺序性不做任何保证。&lt;/p&gt;
&lt;h2 id=&quot;代价&quot;&gt;代价&lt;/h2&gt;
&lt;p&gt;总的来讲，越严格的内存序其性能开销会越大。对于我们常用的x86处理器而言，在处理器层级本身就支持release/acquire语义，因此release与acquire/consume都只影响编译器的优化，而memory_order_seq_cst还会影响处理器的指令重排。&lt;/p&gt;

&lt;p&gt;查资料学习原子量与内存序的过程中，深感多线程和并发的深奥，尽管出于好奇心会尝试了解各种内存序，但是在实践中写代码还是尽量选择比较稳妥的方式来实现吧，能加锁加锁，实在不行用默认的memory_order_seq_cst选项的原子量。毕竟就普通程序员而言，其实很难遇到要在这上面挤性能的场景，如果真觉得需要，多半是我们的设计不科学 = = ！假如确确实实遇到这样的场景，做之前一定要谨慎的多做些研究，选择简单的使用方式，做到心中有数。&lt;/p&gt;
</description>
<pubDate>Mon, 23 Apr 2018 07:09:00 +0000</pubDate>
<dc:creator>兔晓侠</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FateTHarlaown/p/8919235.html</dc:identifier>
</item>
<item>
<title>深耕业务 ---- 探索复杂/超复杂前端业务的开发与设计 - 仲强</title>
<link>http://www.cnblogs.com/GerryOfZhong/p/8918784.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GerryOfZhong/p/8918784.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　距离上一篇博客，我已经有3个月没有写博客了，脑子里也有很多灵光和新点子，忙嘛，肯定忙，但是忙不是理由，所以见谅。这次给自己下了死命令，一定要产出点东西，so，将自己最近开发中能总结的东西慢慢再搞出一点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　PS：这是一篇思维参考性的文章，比较枯燥，阅读时间30分钟（包括思考和印证）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　作为深耕的业务，我们就从一个我遇到的复杂需求开始做个引子。栗子如下（可先看图片过个眼瘾）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201804/801930-20180423140831948-1641611583.png&quot; alt=&quot;&quot; width=&quot;894&quot; height=&quot;391&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;需求列表如下：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;有20种不同类型的活动，每种活动按钮文字不一样&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每种活动根据活动状态有不同的show和hide方案（最多有3-4个字段，分别控制）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;根据不同业务状态，定义按钮的展示方式（禁用？ or 可用？）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每个不同按钮的功能都不一样&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;同一个按钮，根据不同活动也有不同的功能（比如调整优惠，针对不同活动，引用不同组件）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个按钮，相同的功能，但是请求的接口和参数也是不一样的（老数据老接口，新数据新接口）&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;一般要求：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;这是一个迁移不完整的入口项目，对接所有活动的详情和操作，考虑业务不稳定性（业务变动需要变更，例如新迁移活动需要增加新的操作）以及迭代（继续迁移其他老项目，对接上来），需要考虑到更简易的拓展以及敏捷操作，当然维护和开发的成本也需要考虑的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;更高要求：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;view视图上，简洁清爽，各种逻辑判断不乱&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;vm层，避免超繁琐，代码的逻辑和归类清晰明了&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;低耦合，达到更松散的控制，对于以后拆分和开发更敏捷&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;轻松的统一管理，可以统一管理&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　相信大家看了这个需求和要求，每个人根据自己的程序员开发经验和设计经验上，每个人都有不同的解决方案。其实，每个解决方案都是一种方式，只是在不同角度上的实施的成本以及设计思维上的不同。So，我想分享给大家的，也是经过我思考后以及完善的一种解决方案，拿出来仅供大家参考。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　程序员写的所有代码全都服务于业务，这个毋庸置疑。但是我想先问大家一个问题，&lt;strong&gt;&lt;span&gt;到底什么是业务？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在老板眼中，业务就是我赚钱的工具；在销售员眼中，业务就是我需要完成的指标；在产品眼中，业务就是我要实现完成的需求…每个人对业务的理解都不一样，但是，有谁考虑过，在前端开发工程师眼中的业务到底是什么？？？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　&lt;span&gt;下面是我站在前端的角度去理解的业务，如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201804/801930-20180423141112978-479943936.png&quot; alt=&quot;&quot; width=&quot;645&quot; height=&quot;390&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;so，在我的理解里，我把前端所写的业务拆分成这6大部分：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;业务数据：负责获取业务数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;业务逻辑：实现产品所定义的规则&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;逻辑数据：通过一系列规则所产出的逻辑数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;视图数据：通过逻辑数据转换成视图数据（不将逻辑和视图直接绑定）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;视图展示：通过视图数据，直接驱动视图层展示对应视图&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;视图功能：通过视图展示组装成的需求功能&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在简单的业务需求中，可能我拿到的后端数据，就直接可以去渲染视图层，然后就完善功能。从开发的成本和复杂度上考量上，是不值得去做业务拆分。所以，在复杂的业务需求中以及兼顾拆分和维护中，这种业务方法论就可以大展手脚了。以下，我就拿开头的例子，详细解析围绕业务的6大部分的设计。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体实现步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;1.&lt;/span&gt; 在现代框架中（vue、react、angular），最核心、也最灵活的处理视图变化的方式，就是将驱动的视图的数据做成可配的，所以第一步，我们将我们按钮的需求做成数据配置，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201804/801930-20180423141250105-983949196.png&quot; alt=&quot;&quot; width=&quot;734&quot; height=&quot;273&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　ps：将按钮的数据，全都装配到一个数组中，然后数组中的子集封装一个配置对象，将按钮的文字、回调、是否禁用等功能装配到模板中了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;2.&lt;/span&gt; 首先在我的需求中数据的获取只有一个接口，不复杂，所以对于业务数据的获取来说我没有将这个部分进行拆分管理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201804/801930-20180423141703508-1391050119.png&quot; alt=&quot;&quot; width=&quot;730&quot; height=&quot;148&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　ps：很简单的前端数据请求，因为改处的接口，在其他动态刷新数据的时候还需要，所以这里我将请求封装成一个单一函数，只获取业务数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;3.&lt;/span&gt; 对于最终视图展示，我们需要一个视图数据去驱动。有时候，我们会将我们业务规则产出的数据直接挂载到视图数据上，然后通过业务逻辑产出的数据直接驱动视图。不过在我的设计中，不建议将视图数据=逻辑数据。因为这样，我们的视图数据和逻辑数据会产生一种强依赖关系，而且，有时候逻辑数据只是根据业务定义出来的，而不是最适合做视图数据，来渲染数据的。如果逻辑出问题，或者前置的数据（直白的就是获取后端接口数据）出问题，那么强依赖的视图除了出问题，有时候甚至会直接崩溃。所以每次在视图数据和逻辑数据中我会做一层数据转换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201804/801930-20180423141801697-1063145386.png&quot; alt=&quot;&quot; width=&quot;728&quot; height=&quot;404&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　ps：tempData为视图数据，在这里对每个业务数据进行处理，然后对视图数据进行赋值，在处理中，可以对业务数据进行容错处理，不管业务逻辑怎么变化，或者业务数据怎么变化，在我的视图数据层面来说，就算你挂了，我依然可以对我的视图进行驱动，顶多是默认值，而不会直接宕机。一定程度上，增长了代码的健壮性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;4.&lt;/span&gt; 我们再从上面的代码看我们的业务逻辑，我们所有的逻辑，都统一拆到了视图数据的右边了，比如我们讨论的按钮逻辑，所以对于整个页面功能来说，我的按钮的业务逻辑与全局所有功能的耦合，只有一个地方。这样的设计，秉承低耦合的思想，没那么强的控制欲，很松散，很舒服。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201804/801930-20180423141924021-1416259661.png&quot; alt=&quot;&quot; width=&quot;725&quot; height=&quot;209&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　ps：红框的地方为按钮的业务逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;5.&lt;/span&gt; 下面为拆分的按钮逻辑，从软件工程的设计布局上，将逻辑拆到最外层，和其他配置文件，枚举文件同级（个人感觉方便顺手）。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201804/801930-20180423142011777-903541113.png&quot; alt=&quot;&quot; width=&quot;394&quot; height=&quot;611&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　ps：在工程中创建逻辑存放地方&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;6.&lt;/span&gt; 在真正业务使用的地方，将业务逻辑代码和其他统一管理文件引入进来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201804/801930-20180423142128716-1621297365.png&quot; alt=&quot;&quot; width=&quot;946&quot; height=&quot;93&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　ps：该处引入了全局统一管理枚举值、按钮拆分逻辑以及逻辑的适配器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;7.&lt;/span&gt; 因为考虑到，我们的活动本身的业务，2个大类（店铺和单个商品活动）+7个小类（不同活动）+不同活动渠道（6种渠道）共20多种活动的需求，所以针对活动以及活动数据的共性去统一处理势必会导致逻辑混乱，数据混乱，代码混乱，各种if和嵌套if等等，所以该处引入状态机机制，罗列所有存在的活动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201804/801930-20180423142244314-95395144.png&quot; alt=&quot;&quot; width=&quot;606&quot; height=&quot;982&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　ps：状态机中针对类型+渠道确定活动，每个到叶节点的状态包装该活动对应的业务逻辑，而针对这个活动类型通用的业务数据，都包装在活动类型的节点下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;8.&lt;/span&gt; 我们详细看每个活动下的按钮逻辑，我们在按钮逻辑中，将对每个按钮所要做的功能还是未知的，但是我们知道按钮所要做的事情的类型，所以我们在这里将定义按钮的文字、文字的行为、属于这个按钮功能附带的数据。然后再通过传入进来的业务数据，根据业务逻辑，产出逻辑数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201804/801930-20180423142345371-171552118.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;506&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　ps：font为按钮的文字、behavior为该按钮需要做的行为，data为操作这按钮之后需要附带的一些数据。然后再根据业务逻辑规则，产出一个活动下的逻辑数据，供视图数据使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;9.&lt;/span&gt; 这样我们就可以根据不同规则，加载不同状态机中的不同逻辑，比如这段状态机输出代码，我需要按钮逻辑，我就匹配按钮的逻辑，我需要匹配整个活动下共有的图片数据，我就直接加载活动类型的状态机。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201804/801930-20180423142441336-1983929390.png&quot; alt=&quot;&quot; width=&quot;753&quot; height=&quot;215&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　ps：加载状态机对应的逻辑规则，这样我们就完全把逻辑拆分出来了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　&lt;span&gt;10.&lt;/span&gt; 完全拆分的按钮逻辑，就成了单个点了，但是这个逻辑只定义的按钮所需要的行为，对于按钮具体行为的实现没有涉及。我在设计按钮具体实现的时候，考虑到按钮的所有实现，都在一个页面中，需要直接调用一些业务数据和视图数据操作视图变化以及逻辑数据改变，所以，在我的项目中，没有将行为的实现拆分出去。下面就是我定义的对应按钮的行为的列表和具体实现：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201804/801930-20180423142710776-855972527.png&quot; alt=&quot;&quot; width=&quot;589&quot; height=&quot;548&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　ps：直接在vue的methods中定义按钮逻辑所需要行为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;11.&lt;/span&gt; 按钮业务逻辑设计完毕，预留功能接口。内部组件定义行为的具体的实现，开放功能的对接。下面就需要一个适配器，将定义和实现紧紧连接在一起。这个按钮适配器，就是将按钮的产出的逻辑数据和具体的实现连接，真正产出逻辑数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201804/801930-20180423142808592-1484224595.png&quot; alt=&quot;&quot; width=&quot;609&quot; height=&quot;276&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201804/801930-20180423143837101-2047833159.png&quot; alt=&quot;&quot; width=&quot;610&quot; height=&quot;203&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　ps：通过适配器，将定义和实现进行单独拆分。然后衔接出逻辑数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;12.&lt;/span&gt; 然后将最终搜集到的视图临时数据，绑定到真正的视图数据上去渲染视图，这样我们就得到了完整的业务需要的视图。用户点击按钮就能操作视图的功能，根据按钮拆分中得附带数据，去判断用户具体去操作哪个按钮，这个按钮的什么功能，以及需要请求不一样的接口，接口数据等等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201804/801930-20180423143935112-217624638.png&quot; alt=&quot;&quot; width=&quot;830&quot; height=&quot;143&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　ps：data为附带数据，数据中定义的什么字段有什么用，就根据自己的业务需求来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以整体设计，可以归类成下面的一张图片：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201804/801930-20180423144022916-1763645599.png&quot; alt=&quot;&quot; width=&quot;707&quot; height=&quot;675&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据这张思路的设计图，可以将这里的&lt;span&gt;复杂需求&lt;/span&gt;进行拆分，然后对应问题解决业务上的需求点：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;20种活动，使用状态机输出每种活动展示的不同按钮文字&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在状态机下，根据业务数据统一做按钮的hide和show的业务逻辑包括禁用和可用的逻辑。产出逻辑数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每个状态机的按钮定义用户行为，在行为实现中实现&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在状态机中根据行为+附加数据确定一个按钮实现的不同功能，包括其他差异化的方案（比如请求不同接口）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;状态机+实现接口产出不同数据的拆分，对于业务的不稳定性和迭代兼容有很好的适用。松散的控制和低耦合的状态，对于活动的增加和删除，功能按钮的删除和增加，以及按钮功能实现的增加等，更方便开发和操作&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;因为view做成可配，所有状态都在业务逻辑层实现，直接产出逻辑数据来驱动视图数据，所以view层简洁清爽&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;状态机统一管理业务逻辑和行为，实现接口统一管理行为实现&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这只是我在业务开发生涯中，最近总结出来的一种业务方法论，这是一种针对复杂和超复杂的业务的一种探索，上面只是一个需求中的案例，大家可以根据自己的案例参考这种方法论。具体业务特性具体把握，比如最初设计规模，持续增长规模，以及未来发展规模（是否需要拆分）等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下为我参考的一些思想：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1. &lt;span&gt;单体架构和微服务架构&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　a) 单体架构（monolithic architecture）的应用，各组件的代码是作为一个整体存在的，组件之间互相合作，共享内存和资源。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　b) 微服务架构（microservice architecture）则是由许许多多个互相独立的小应用组成，每个应用都有自己的内存空间，应用在扩容时也是独立于其它应用进行的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2. &lt;span&gt;浏览器事件设计思想&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　a) 事件思想：浏览器的事件一般都是用户触发然后去触发开发者的实现。所以，在浏览器本身的设计中是不知道用户到底是怎么实现的。So，浏览器的事件设计的时候就是在浏览器中定义一个行为（click or 其他），然后通过一个适配器，也就是注册事件的方法，将行为的实现进行适配和组装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3. &lt;span&gt;流程化管理&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　a) 流程化管理是指以流程为主线的管理方法。前端从数据获取到最后的视图功能展示，包括中间的各种业务逻辑以及视图渲染等等，都是一系列的流程，流转出来的结果。so，而且拆分也可以根据这些子节点中的流程作为关键点进行拆分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4. &lt;span&gt;敏捷开发思维&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　a) 敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。敏捷，存在的目的就是因地制宜的去根据自己的项目去评估和拆分。类似于这套方法论，因个人和项目去评估到底怎么拆分，而不是拉过来就是干满一套。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上只是我深耕业务过程中自己总结的一套思想和方案，仅供大家参考。而且这套方法论也可能不是很完善，可以一起讨论和继续深入的探讨。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 23 Apr 2018 07:06:00 +0000</pubDate>
<dc:creator>仲强</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GerryOfZhong/p/8918784.html</dc:identifier>
</item>
<item>
<title>一个普通程序员眼中的「技术」 - 陈宏鸿</title>
<link>http://www.cnblogs.com/aspwebchh/p/8919065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aspwebchh/p/8919065.html</guid>
<description>&lt;div readability=&quot;49&quot;&gt;
&lt;p&gt;&lt;span&gt;技术是程序员安身立命的根本，可一味的追求提高技术却未必能从技术上获得相应的回报。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常情况下， 程序员要使自己所学的技术产生相应的价值或者收入必须依托于某个公司， 靠自己单干很难赚到钱， 即使能赚到钱性价比也不如替企业打工来的高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以程序员一般都是替别人打工的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;程序员在企业里打工，目的就是替公司解决相应的问题， 可程序员们有时候又有点一根筋，认为既然自己的工作是做技术那么问题自然可以通过技术手段来解决， 只要技术越牛逼，解决问题的能力就越强， 于是就一门心思的提升自己的技术， 希望借此来体现自身的价值。 殊不知，绝大部分公司根本用不到什么牛逼的技术， 你用用普通的三流技术照样能妥妥的把问题给解决了，使用那些行业内牛逼的、前沿的技术并不能得到理想的效果，所以去学习使用它们也不见得能得到相应的回报。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为那些牛逼的技术本就是那些牛逼的人针对自己所在的牛逼的公司的业务场景开发出来的， 这些技术能在它们所在的公司发挥效用，但是扔给其它企业用却未必能体现相应的价值，强行使用还会有副作用。 比如说那些什么缓存、消息机制、厉害的框架、高并发方案等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你很厉害，会使用很牛逼的高大上技术，可在你的老板看来， 你可能和那些技术不厉害的程序员没有差别，甚至于还不如它们。 因为虽然你技术牛逼，然而你的这些技术在这个环境下面根本没有用武之地，就像在一个弄堂里面，你一辆奔驰的速度还没有人家骑个自行车来的快，所以即使技术再厉害也是没有意义的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现实就是这么残酷但是不得不接受。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;程序员对于自己职业道路的发展，技术不容忽视，但绝对不排第一。和其它任何职业一样，程序员对于自己职业生涯，应该提升的是解决问题的能力，技术是解决问题的一种方法，但不一定是最有效的。很多时候，把问题解决好，把事情做好，并不一定要通过技术，程序员们很难领悟到这一点，即使能领悟，也很难真正的这么去做，这就是很多程序员明明技术很牛逼，可混的就是不怎么样的原因。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然，你如果非要通过纯技术来展现的价值，那也要找一个能让自己技术有用武之地的环境，但是这样的环境很稀有，容不下所有有这种想法的程序员， 大多数程序员注定不能只靠技术就吃得开。因此，程序员真的不能认为，写代码就是程序员的一切了， 提升自己的技术就能走上人生巅峰。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然这并不是说提升自己的技术，学习在工作中用不到的技术是没有用的，至少这在换工作时是必不可缺的， 因为在面试的时候， 技术是最容易量化的，其它方面的能力， 通常只有在工作中可以实际体现，那面试的时候也只有通过技术作为你能力的参考了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，对于那些牛逼的技术，程序员们处于一种爱恨交织的状态， 学吧，工作中用不上；不学吧，跳槽面试时人家问了怎么办。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;无可耐可&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 23 Apr 2018 06:43:00 +0000</pubDate>
<dc:creator>陈宏鸿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aspwebchh/p/8919065.html</dc:identifier>
</item>
<item>
<title>ScalaPB（0）： 找寻合适的内部系统微服务集成工具 - 雪川大虫</title>
<link>http://www.cnblogs.com/tiger-xc/p/8918913.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiger-xc/p/8918913.html</guid>
<description>&lt;p&gt;&lt;span&gt;   前一段时间我们探讨了SDP的一个基于集群的综合数据平台解决方案，由多种数据库组成，包括：JDBC, Cassandra 及MongoDB。其中Cassandra和MongoDB属于分布式数据库，可以在集群中任何部署节点调用。而JDBC数据库则是非分布式的，无法部署在多个节点。假设我们把每种数据库的数据处理功能以微服务microservice形式提供出来的话，任何从其它集群节点对JDBC数据库微服务的调用都需要进行数据的序列化（serialization）。虽然Cassandra和MongoDB是分布式的，但也只限在它们已部署的不同节点上自由交流。现在看来，不同的数据微服务之间的交互还是需要通过serialization来实现的。也就是说数据需要经过序列化marshalling才能发送，接收后反序列化unmarshalling才能还原数据。曾经花了点时间研究了一下akka-http：当时我初选的所谓系统集成工具，它是通过json格式数据交换来集成系统的。json是个标准数据格式，所以可以实现异类系统之间的数据交换。一直在考虑，如果SDP数据平台微服务之间是通过akka-http进行数据交换的形式实现集成的话，这个集成的体系内部交互效率会非常低，这是因为1、json是一种字符型的数据，占据空间较大，传输效率自然低。2、受制于http1.0交互模式，方便了数据下行但上行数据只限于请求指令。这种模式在系统层面的交互能力很有限，或者很不自然，很不方便。为此也郁闷了一阵。实际上使用akka-http需要的门槛很高，即使akka-http已经提供了许多帮助http操作的类型，但光是理解http协议内容及httprequest，httpresponse细节、构建、使用方法就花去了我几个星期的精力，而且才刚刚达到枯浅的理解水平，如果在实际应用中能够真正调动自然，则需要添加更多的努力了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   google gRPC是一种全新的RPC框架，在开源前一直是google内部使用的集成工具。gRPC支持通过http/2实现protobuf格式数据交换。protobuf即protocol buffer，是google发明的一套全新的序列化传输协议serialization-protocol，是二进制编码binary-encoded的，相对java-object，XML，Json等在空间上占有优势，所以数据传输效率较高。由于gRPC支持http/2协议，可以实现双向通讯duplex-communication，解决了独立request/response交互模式在软件编程中的诸多局限。这是在系统集成编程方面相对aka-http占优的一个亮点。protobuf格式数据可以很方便的转换成 json格式数据，支持对外部系统的的开放协议数据交换。这也是我决定选择gRPC作为大型系统微服务集成开发工具的主要原因。更重要的是：用protobuf和gRPC进行client/server交互不涉及任何http对象包括httprequest,httpresponse，很容易上手使用，而且又有在google等大公司内部的成功使用经验，用起来会更加放心。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;gRPC支持下面四种交互协议：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、Unary：独立的一对client-request/server-response，是我们常用的http交互模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、Server-Streaming：client发出一个request后从server端接收一串多个response&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、Client-Streaming：client向server发送一串多个request后从server接收一个response&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、Bidirectional-Streaming：还是由client首先发送request启动连接，然后在这个连接上client/server双方可以不断交互信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;感觉第4种方式最适合程序流程层面的交互。也就是说它可以代表一种自然的程序流程，虽然它还是需要client主动发起交互连接。由于产生的源代码中不涉及任何http协议相关类型及操作，使用起来更容易上手。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在scala编程世界里我们可以用scalaPB来实现对gRPC和protobuf的使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;google gRPC的使用流程如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、创建一个.proto文件，用IDL语言（Interface Definition Language）定义数据类型和服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、对.proto文件进行编译后产生相关的java数据类型和抽象服务框架&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、在java编程中可以直接调用编译产生的数据类型及对数据进行操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、继承并实现产生的服务类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;scalaPB是一个scala版的protobuf编译器。编译.proto文件后产生scala语言的数据类型和抽象服务类，这样我们就可以在scala环境里使用protobuf和gRPC实现微服务的集成编程了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我将会在下面几篇博文里介绍使用scalaPB进行protobuf数据转换、gRPC微服务实现、gRPC的流式操作以及gRPC流与json之间转换方法等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Apr 2018 06:24:00 +0000</pubDate>
<dc:creator>雪川大虫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tiger-xc/p/8918913.html</dc:identifier>
</item>
<item>
<title>关于InnoDB的读写锁类型以及加锁方式 - vinter_he</title>
<link>http://www.cnblogs.com/vinter/p/8918751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vinter/p/8918751.html</guid>
<description>&lt;p&gt;（本文为了方便，英文关键词都都采用小写方式，相关知识点会简单介绍，争取做到可以独立阅读）&lt;/p&gt;
&lt;p&gt;文章开始我会先介绍本文需要的知识点如下：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;innodb的聚簇索引（聚集索引）和非聚簇索引（二级索引、非聚集索引）的知识&lt;/li&gt;
&lt;li&gt;innodb的隔离级别（isolation level）&lt;/li&gt;
&lt;li&gt;简单的sql知识（能读懂sql语句）&lt;/li&gt;
&lt;li&gt;MVCC（Multi-Version Concurrent Control）多版本并发控制&lt;/li&gt;
&lt;li&gt;数据的脏读、幻读（如果有时间会详细讲一下脏读如果没时间，网上讲这个地方的也很多）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;问题1：读有几种模式、加锁有几种方式&lt;/h5&gt;
&lt;p&gt;我们先看一个mysql表和几条语句&lt;/p&gt;
&lt;p&gt;表名称：my_table  &lt;/p&gt;
&lt;p&gt;搜索引擎：innodb&lt;/p&gt;
&lt;p&gt;表结构：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180113101148091?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ludGVyZmVuZzEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;div readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sql&quot;&gt;
1. select * from my_table where id = 1;
&lt;/pre&gt;
&lt;pre class=&quot;sql&quot;&gt;
2. select * from my_table where id = 1 lock in share mode;
&lt;/pre&gt;
&lt;pre class=&quot;sql&quot;&gt;
3. select * from my_table where id = 1 for update;
&lt;/pre&gt;
&lt;pre class=&quot;sql&quot;&gt;
4. update my_table set address = 'tianjin' where id = 1;
&lt;/pre&gt;
&lt;p&gt;先说隔离级别，mysql隔离级别分为四种：&lt;/p&gt;
&lt;p&gt;未提交读（read uncommitted）、提交读（read committed）、重复读（repeatable read）、序列化（serializable）&lt;/p&gt;
&lt;p&gt;其中mysql默认的隔离级别为重复读（repeatable read），以下简称为rr，本文也只介绍这种模式&lt;/p&gt;
&lt;h6&gt;读的模式分为两种：&lt;/h6&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;快照读（snapshot read）&lt;/li&gt;
&lt;li&gt;当前读（current read）&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;我们先来了解一下MVCC：&lt;/p&gt;
&lt;p&gt;MVCC是为了实现数据库的并发控制而设计的一种协议。与其相对的事LBCC即基于锁的并发控制（Lock-Based Concurrent Control）。要实现数据库的并发访问控制，最简单的做法就是加锁访问，即读的时候不能写（这个读为当前读，后面介绍。允许多个线程同时对想读的内容加锁，即共享锁或叫S锁），写的时候不能读（只能有一个线程对同一内容进行写操作，即排它锁，X锁）。这样的加锁访问，其实并不算是真正的并发，或者说它只能实现并发的读，既读写串行化，这样就大大降低了数据库的读写性能。&lt;/p&gt;
&lt;p&gt;LBCC是四种隔离级别中级别最高的Serialize隔离级别。MVCC对比LBCC它的最大好处便是，读不加锁，读写不冲突。在MVCC中，读操作可以分成两类，快照读（Snapshot read）和当前读（current read）。快照读，读取的是记录的可见版本（可能是历史版本，即最新的数据可能正在被当前执行的事务并发修改），不会对返回的记录加锁，如上面的sql语句1；而当前读，读取的是记录的最新版本，并且会对返回的记录加锁，保证其他事务不会并发修改这条记录。如上面的sql语句2,3,4。不同的是2加的是s锁，3、4加的是x锁，insert加的也是x锁。&lt;/p&gt;
&lt;p&gt;注：MVCC只在RC和RR两个隔离级别下工作，其他两个隔离级别都和MVCC不兼容&lt;/p&gt;
&lt;h6&gt;加锁的方式：（未涉及意向锁）&lt;/h6&gt;
&lt;p&gt;先看一个sql语句&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sql&quot;&gt;
update my_table set name ='zhang' where id = 1;
&lt;/pre&gt;
假设id为主键：此条sql执行的时候会给此行数据加x锁，如下图&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180113101156975?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ludGVyZmVuZzEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;mysql的innodb默认的隔离模式为RR模式，既可重复读，Innodb的RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)，因此不存在幻读现象。但是标准的RR只能保证在同一事务中多次读取同样记录的结果是一致的，而无法解决幻读（不保证在事务中出现）问题。Innodb的幻读解决是依靠MVCC的实现机制做到的。其他模式以后有时间再加在这里不对其他模式做讲解。&lt;/p&gt;

&lt;p&gt;这里因为id为主键，innodb中在主键上存在聚簇索引，其他的索引均为二级索引，这里做一下简单介绍&lt;/p&gt;

&lt;p&gt;聚簇索引：在innodb存储引擎中，主键的存在至关重要，及时你不为表设置主键，存储引擎也会隐式的定义一个主键，只是对用户来说透明。之所以说他重要，是因为聚簇索引的存储是和数据存储在一起的，而聚簇索引的数据就是数据存储的顺序。如果需要查找的数据是连续的，那么按照聚簇索引查找到的数据位置也是连续的，只需要按顺序读取就可以。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页（这里和后面的二级索引有区别，二级索引的叶子节点指向数据页数据行的逻辑指针，需要按照指针再去检索数据）。 在一张表上最多只能创建一个聚集索引，因为真实数据的物理顺序只能有一种。&lt;/p&gt;
&lt;p&gt;二级索引：表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致。&lt;/p&gt;
&lt;p&gt;看上面的sql语句，或者看之前的几条sql，这个语句执行的时候会给这条记录加x锁，这时候如果其他事务中的语句也在进行锁的操作（既更新、插入或者删除，以及2语句当前读操作加的s锁）就会造成锁争用（innodb出现锁争用的时候处理方式为回滚超时获取不到锁的事务）。&lt;/p&gt;

&lt;p&gt;我们先按照上面四条语句两条并发时的相互影响的情况来&lt;/p&gt;

&lt;p&gt;情况1：id为主键&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sql&quot;&gt;
1. select * from my_table where id = 1;
&lt;/pre&gt;
&lt;pre class=&quot;sql&quot;&gt;
2. select * from my_table where id = 1 lock in share mode;
&lt;/pre&gt;
我们上面说过，语句1为快照读，对其他的读或者写没有影响。所以这两条语句并行时，1读快照，2为语句加s锁。&lt;/div&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sql&quot;&gt;
select * from my_table where id = 1 lock in share mode;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;情况2：id为主键&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sql&quot;&gt;
2. select * from my_table where id = 1 lock in share mode;
&lt;/pre&gt;
&lt;pre class=&quot;sql&quot;&gt;
3. select * from my_table where id = 1 for update;
&lt;/pre&gt;
其中语句2加s锁，3加x锁（在数据被加s锁的时候，其他的给这条想要读取这条记录也需要给这条记录加s锁，这就是为什么s锁是共享锁。此时是不允许再给这条记录加x锁的）两种锁是不能同时存在在一条记录上的。所以两条语句不能并发执行。&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;情况3：id为主键
&lt;pre class=&quot;sql&quot;&gt;
3. select * from my_table where id = 1 for update;
&lt;/pre&gt;
&lt;pre class=&quot;sql&quot;&gt;
4. update my_table set address = 'tianjin' where id = 1;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种情况下两条语句都需要给数据加x锁，所以显然不能并发执行。&lt;/p&gt;

&lt;h4&gt;下面我们来讨论一下id不为主键的情况&lt;/h4&gt;
&lt;p&gt;id若不为主键，则不能使用聚簇索引，而在innodb中有一下几种情况&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;ul&gt;&lt;li&gt;二级唯一索引&lt;/li&gt;
&lt;li&gt;二级不唯一索引&lt;/li&gt;
&lt;li&gt;没有索引&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于只要不是快照读则一定会加锁，我们已经了解了锁的形式，则不难明白不论是先加x锁还是s锁哪一种，都一定不能再加另一种锁，所以我们下面只分析加锁的方式&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;情况4：假设id为二级唯一索引（unique）&lt;/p&gt;

&lt;div readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sql&quot;&gt;
4. update my_table set address = 'tianjin' where id = 1;
&lt;/pre&gt;
&lt;p&gt;这里很明显需要加x锁，但是这里的加锁和id为主键（索引为聚簇索引）的情况加锁不完全一样，会稍微复杂一点。&lt;/p&gt;

这个时候我们需要对索引知识有一定的了解，上面说过二级索引中的叶子节点存储的除了索引信息还有到实际数据的逻辑指针，也就是说我们需要现在二级唯一索引中查找到这条记录的逻辑指针，然后通过指针去查找到数据实际的存储位置并给这条数据加锁。注意，这里的加锁应该是加在了索引上和数据本身上（或者说是聚簇索引上也可以，因为两者是存储在一个结构中的，而innodb中二级索引叶子中的逻辑指针并不是数据存储的物理地址，而是主键值）而不只是二级唯一索引上。如果想用好innodb，他的索引结构是必须要学习的，如果以后有时间会详细介绍。&lt;/div&gt;

&lt;p&gt;情况5：age为二级非唯一索引，id为主键&lt;/p&gt;

&lt;div readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sql&quot;&gt;
5. update my_table set address = 'tianjin' where age = 25;
&lt;/pre&gt;
此种情况比前一种情况更特殊，因为情况3和4都只能找到一条记录，只需要对这条记录加锁，则不会发生结果集被修改的情况。但是如果age为二级非唯一索引，我们看到如下表格中有两条记录age=25&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180113101220706?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ludGVyZmVuZzEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;如果我们在update的过程中，有一个用户插入了一条age也为25的数据，那么就是发生一种现象，你明明更新了所有的age=25的数据，但是执行完了却有一条数据没有更新的幻觉，这就是幻读（可以自行查找资料，避免本文过长）。这个时候显然只给查找出的数据加锁是解决不了这个问题的。所以就有了gap锁（间隙锁字面上可能更好理解）这里需要画图大家理解一下：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180113101818412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ludGVyZmVuZzEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;如图这里在age为25的有两个 ，id分别为1和3。我们在修改执行上面语句的时候，如果没有gap锁，则可能发生一种情况：另一个事务执行如下语句&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sql&quot;&gt;
update my_table set age=25 where id=2;
&lt;/pre&gt;
则发生幻读现象。gap锁可以防止在语句或者事务执行过程中有满足条件的记录插入进来造成幻读。所以说在此种情况下，除了给满足条件的二级索引和数据（或聚簇索引）加x锁之外还要给相关的间隙加锁。可以理解为这个加gap锁是在二级索引的范围内防止新的索引项加入，因为二级索引本身也是有序的。&lt;/div&gt;
&lt;p&gt;情况6：age上无索引，id为主键&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sql&quot;&gt;
5. update my_table set address = 'tianjin' where age = 25;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种情况下，所有记录都被加上了X锁，每条记录间的间隙(GAP)也同时被加上了GAP锁。在实际情况中可能sql更复杂，如果用到了其他列索引，mysql会按照索引顺序筛选结果，也许并不会进行全表加x锁和gap锁。&lt;/p&gt;

&lt;p&gt; 注：转自自己的博客&lt;/p&gt;




</description>
<pubDate>Mon, 23 Apr 2018 06:02:00 +0000</pubDate>
<dc:creator>vinter_he</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vinter/p/8918751.html</dc:identifier>
</item>
<item>
<title>spring 自定义事件发布及监听（简单实例） - 半城枫叶半城雨丶</title>
<link>http://www.cnblogs.com/xinde123/p/8918714.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xinde123/p/8918714.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring的AppilcaitionContext能够发布事件和注册相对应的事件监听器，因此，它有一套完整的事件发布和监听机制。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;流程分析：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在一个完整的事件体系中，除了&lt;strong&gt;事件&lt;/strong&gt;和&lt;strong&gt;监听器&lt;/strong&gt;以外，还应该有3个概念；&lt;/p&gt;
&lt;p&gt;1. &lt;strong&gt;事件源&lt;/strong&gt;：事件的产生者，任何一个event都必须有一个事件源；&lt;/p&gt;
&lt;p&gt;2. &lt;strong&gt;事件广播器&lt;/strong&gt;：它是事件和事件监听器之间的桥梁，负责把事件通知给事件监听器；&lt;/p&gt;
&lt;p&gt;3. &lt;strong&gt;事件监听器注册表&lt;/strong&gt;：就是spring框架为所有的监听器提供了一个存放的地方；&lt;/p&gt;
&lt;p&gt;通过流程图，可以看出它们是如何各司其职的，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1098960/201804/1098960-20180423113855869-2113274102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实通过流程图，我们很容易发现事件体系就是观察者模式的具体实现，它并没有任何的神秘之处。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;结构分析：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.  &lt;strong&gt;事件类&lt;/strong&gt;（&lt;strong&gt;ApplicaitonEvent&lt;/strong&gt;）：目前spring框架本身仅仅提供了几个事件，很多的事件都是需要自定义的。&lt;/p&gt;
&lt;p&gt;　ApplicationEvent唯一的构造函数是ApplicaitonEvent（Object source），通过source指定事件源。  它有两个子类；&lt;/p&gt;
&lt;p&gt;（1）ApplicationContextEvent：容器事件，也就是说事件源是ApplicationContext，框架提供了四个子类，分别代表容器启动，刷新，停止和关闭事件。&lt;/p&gt;
&lt;p&gt;（2）RequestHandleEvent：这是一个与Web应用相关的事件，当一个请求被处理后，才会产生该事件。&lt;/p&gt;
&lt;p&gt;一般来说，我们都是扩展ApplicationEvent来自定义事件。下面会有栗子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1098960/201804/1098960-20180423115320787-1483242695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2. &lt;strong&gt;事件监听器接口&lt;/strong&gt;（&lt;strong&gt;ApplicationListener&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;所有的监听器都需要实现该接口，该接口只定义了一个方法：onApplicaitonEvent (E event)，该方法接收事件对象，在该方法中编写事件的响应处理逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1098960/201804/1098960-20180423115810483-597785865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;实例分析：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过一个实例来讲解事件发布和事件监听的过程。这个例子包括一个模拟的邮件发送器MailSender，它在向目的地发送邮件的时候 会产生一个MailSendEvent事件，我们同时向容器中注册了该事件的监听器MailSendListener；&lt;/p&gt;
&lt;p&gt;上代码：MailSendEvent&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 继承了ApplicationContextEvent，就是个容器事件
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MailSendEvent &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ApplicationContextEvent {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String to;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;目的地&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MailSendEvent(ApplicationContext source, String to) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(source);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.to =&lt;span&gt; to;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getTo(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.to;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;很明显，这里的source是ApplicationContext容器。&lt;/p&gt;
&lt;p&gt;我们再定义一个该事件的监听器MailSendListener，如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MailSendListener &lt;span&gt;implements&lt;/span&gt; ApplicationListener&amp;lt;MailSendEvent&amp;gt;&lt;span&gt;{
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onApplicationEvent(MailSendEvent mailSendEvent) {
        MailSendEvent event &lt;/span&gt;=&lt;span&gt; mailSendEvent;
        System.out.println(&lt;/span&gt;&quot;MailSender向&quot;+ event.getTo()+ &quot;发送了邮件&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述提及到所有的监听器都必须要实现ApplicationListener，这里是个泛型类，指定了该监听器只监听MailSendEvent事件。&lt;/p&gt;
&lt;p&gt;OK，那我们现在来触发事件：MailSender，也就是事件源&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@Component(&quot;mailSender&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MailSender {
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ApplicationContext applicationContext;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;容器事件由容器触发&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendMail(String to){
        System.out.println(&lt;/span&gt;&quot;MailSender开始发送邮件&quot;&lt;span&gt;);
        MailSendEvent event &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MailSendEvent(applicationContext,to);
        applicationContext.publishEvent(event);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后写个测试类，容器启动：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpringEventTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ApplicationContext context &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;web/WEB-INF/applicationContext.xml&quot;&lt;span&gt;);
        MailSender sender  &lt;/span&gt;= (MailSender)context.getBean(&quot;mailSender&quot;&lt;span&gt;);
        sender.sendMail(&lt;/span&gt;&quot;北京&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;记得在applicationContext.xml里面加上注解扫描啊，我这里都是放在springEvent包里的，所以加上  &amp;lt;context:component-scan base-package=&quot;springEvent&quot;/&amp;gt;&lt;/p&gt;
&lt;p&gt;好了，启动容器，发送邮件：执行结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1098960/201804/1098960-20180423135054966-355232058.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 23 Apr 2018 05:56:00 +0000</pubDate>
<dc:creator>半城枫叶半城雨丶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xinde123/p/8918714.html</dc:identifier>
</item>
<item>
<title>RabbitMQ-Spring AMQP - 让我发会呆</title>
<link>http://www.cnblogs.com/yxy-ngu/p/8892292.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yxy-ngu/p/8892292.html</guid>
<description>&lt;p&gt;上篇文章&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/yxy-ngu/p/8883379.html&quot;&gt;RabbitMQ基础入门&lt;/a&gt;学习了rabbitMQ一些基础的api，当然spring也在原生代码的基础上做了更多的封装，这篇文章就基于spring-rabbit，学习一下spring的实现。&lt;/p&gt;
&lt;p&gt;引入jar：&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;lt;dependency&lt;span class=&quot;s1&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;    &lt;span class=&quot;s1&quot;&gt;&amp;lt;&lt;span class=&quot;s2&quot;&gt;groupId&lt;span class=&quot;s1&quot;&gt;&amp;gt;org.springframework.amqp&lt;span class=&quot;s1&quot;&gt;&amp;lt;/&lt;span class=&quot;s2&quot;&gt;groupId&lt;span class=&quot;s1&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s3&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;    &lt;span class=&quot;s1&quot;&gt;&amp;lt;artifactId&lt;span class=&quot;s1&quot;&gt;&amp;gt;&lt;span class=&quot;s3&quot;&gt;spring-rabbit&lt;span class=&quot;s1&quot;&gt;&amp;lt;/artifactId&lt;span class=&quot;s1&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;    &lt;span class=&quot;s1&quot;&gt;&amp;lt;&lt;span class=&quot;s2&quot;&gt;version&lt;span class=&quot;s1&quot;&gt;&amp;gt;1.5.0.RELEASE&lt;span class=&quot;s1&quot;&gt;&amp;lt;/&lt;span class=&quot;s2&quot;&gt;version&lt;span class=&quot;s1&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s3&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;lt;/dependency&lt;span class=&quot;s1&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上篇文章没有测试到Topic exchange，下面就使用Topic exchange做测试。&lt;/p&gt;
&lt;p&gt;1.基于springframework.amqp.rabbit java写法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.core.BindingBuilder;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.core.Queue;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.core.TopicExchange;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitListener;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.connection.CachingConnectionFactory;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.core.RabbitAdmin;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.core.RabbitTemplate;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.listener.adapter.MessageListenerAdapter;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; @RabbitListener(queues = &quot;hello&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Tut1Java {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(&lt;span&gt;final&lt;/span&gt; String... args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         CachingConnectionFactory cf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CachingConnectionFactory();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         cf.setAddresses(&quot;192.168.1.7:5672&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         cf.setUsername(&quot;admin&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         cf.setPassword(&quot;admin&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; set up the queue, exchange, binding on the broker&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         RabbitAdmin admin = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RabbitAdmin(cf);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         Queue queue = &lt;span&gt;new&lt;/span&gt; Queue(&quot;myQueue&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        admin.declareQueue(queue);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         TopicExchange exchange = &lt;span&gt;new&lt;/span&gt; TopicExchange(&quot;myExchange&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        admin.declareExchange(exchange);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         admin.declareBinding(BindingBuilder.bind(queue).to(exchange).with(&quot;foo.*&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; set up the listener and container&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         SimpleMessageListenerContainer container = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleMessageListenerContainer(cf);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         Object listener = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object() {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接受到消息时，会执行此方法&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleMessage(String foo) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 System.out.println(&quot;Tut1Java &quot; +&lt;span&gt; foo);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         MessageListenerAdapter adapter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageListenerAdapter(listener);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        container.setMessageListener(adapter);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         container.setQueueNames(&quot;myQueue&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        container.start();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; send something&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         RabbitTemplate template = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RabbitTemplate(cf);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只有routingKey符合foo.*规则的才会被接受处理&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;         template.convertAndSend(&quot;myExchange&quot;, &quot;foo.bar&quot;, &quot;Hello, world!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        container.stop();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 整块代码可以简单的实现了发送接收消息，主要分为四个部分。&lt;/p&gt;
&lt;p&gt;16~19行 初始化一个CachingConnectionFactory，其实底层也是原生的ConnectionFactory。&lt;/p&gt;
&lt;p&gt;22~27行 主要是设置&lt;span class=&quot;Apple-converted-space&quot;&gt;queue和exchange，并把它们按照&lt;/span&gt;&quot;foo.*&quot;的路由规则&lt;span class=&quot;Apple-converted-space&quot;&gt;绑定起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;　　&lt;/span&gt;new Queue(&quot;myQueue&quot;)，创建一个本地持久话名字叫myQueue的队列。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;declareQueue(queue)，声明一个队列。&lt;/p&gt;
&lt;p&gt;　　new TopicExchange(&quot;myExchange&quot;)，创建一个topic exchange，看名字也知道exchange类型是topic，我们只要传递参数就好了。当然也会有FanoutExchange、DirectExchange、HeadersExchange。&lt;/p&gt;
&lt;p&gt;　　BindingBuilder.bind(queue).to(exchange).with(&quot;foo.*&quot;)，将queue绑定到exchange上，并以&quot;foo.*&quot;作为他们之间的路由规则。&lt;/p&gt;
&lt;p&gt;30~40行 主要是通过SimpleMessageListenerContainer去监听消息，并且可以设置特定类的方法去执行处理接受到的消息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Object listener = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接受到消息时，会执行此方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleMessage(String foo) {
        System.out.println(&lt;/span&gt;&quot;Tut1Java &quot; +&lt;span&gt; foo    );
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleMessage2(String foo) {
        System.out.println(&lt;/span&gt;&quot;Tut1Java2 &quot; +&lt;span&gt; foo);
    }
};
 MessageListenerAdapter adapter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageListenerAdapter(listener);
 adapter.setDefaultListenerMethod(&lt;/span&gt;&quot;handleMessage2&quot;&lt;span&gt;);
 container.setMessageListener(adapter);    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果消息监听写成上面这样，那么将执行handleMessage2(String foo) 。&lt;/p&gt;
&lt;p&gt;43~46行 利用RabbitTemplate发送消息，三个参数依次为exchange、routingKey和发送的消息，&lt;/p&gt;
&lt;p&gt;首先exchange名称要和admin声明的一致，routingKey要符合当前topic exchange的路由规则，否则消息不会发送到当前队列中。&lt;/p&gt;
&lt;p&gt;再看一下topic exchange的模型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/998887/201804/998887-20180420172353611-1852102658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后运行一下，可以发现消息被顺利打印出来了。&lt;/p&gt;
&lt;p&gt;2.基于spring配置写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;  
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:mvc&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/mvc&quot;&lt;/span&gt;&lt;span&gt; xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:rabbit&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/rabbit&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit-1.0.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rabbit:connection-factory &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;connectionFactory&quot;&lt;/span&gt;&lt;span&gt; username&lt;/span&gt;&lt;span&gt;=&quot;admin&quot;&lt;/span&gt;&lt;span&gt; password&lt;/span&gt;&lt;span&gt;=&quot;admin&quot;&lt;/span&gt;&lt;span&gt; host&lt;/span&gt;&lt;span&gt;=&quot;192.168.1.7&quot;&lt;/span&gt;&lt;span&gt; port&lt;/span&gt;&lt;span&gt;=&quot;5672&quot;&lt;/span&gt;&lt;span&gt; virtual-host&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rabbit:template &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;amqpTemplate&quot;&lt;/span&gt;&lt;span&gt; connection-factory&lt;/span&gt;&lt;span&gt;=&quot;connectionFactory&quot;&lt;/span&gt;&lt;span&gt;
    exchange&lt;/span&gt;&lt;span&gt;=&quot;myExchange&quot;&lt;/span&gt;&lt;span&gt; routing-key&lt;/span&gt;&lt;span&gt;=&quot;foo.bar&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rabbit:admin &lt;/span&gt;&lt;span&gt;connection-factory&lt;/span&gt;&lt;span&gt;=&quot;connectionFactory&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rabbit:queue &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;myQueue&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rabbit:topic-exchange &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;myExchange&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rabbit:bindings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rabbit:binding &lt;/span&gt;&lt;span&gt;queue&lt;/span&gt;&lt;span&gt;=&quot;myQueue&quot;&lt;/span&gt;&lt;span&gt; pattern&lt;/span&gt;&lt;span&gt;=&quot;foo.*&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rabbit:bindings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rabbit:topic-exchange&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rabbit:listener-container &lt;/span&gt;&lt;span&gt;connection-factory&lt;/span&gt;&lt;span&gt;=&quot;connectionFactory&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rabbit:listener &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;foo&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;listen&quot;&lt;/span&gt;&lt;span&gt; queue-names&lt;/span&gt;&lt;span&gt;=&quot;myQueue&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rabbit:listener-container&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;foo&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;rabbitMQ.springAMQP.Foo&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在context.xml中可以看到很多熟悉的rabbitMQ的对象，这种写法只不过从上面new出来的对象，改为使用spring的xml去声明各种bean对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.core.RabbitTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.AbstractApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Tut1Spring {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(&lt;span&gt;final&lt;/span&gt; String... args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        AbstractApplicationContext ctx &lt;/span&gt;=
            &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;spring/context.xml&quot;&lt;span&gt;);
        RabbitTemplate template &lt;/span&gt;= ctx.getBean(RabbitTemplate.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        template.convertAndSend(&lt;/span&gt;&quot;Tut1Spring &quot; + &quot;Hello, world!&quot;&lt;span&gt;);
        Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
        ctx.destroy();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; listen(String foo) {
        System.out.println(&lt;/span&gt;&quot;Foo=&quot; +&lt;span&gt; foo);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Foo为处理接受并处理消息的类，在xml中也指定了执行的方法为listen。&lt;/p&gt;
&lt;p&gt;最后运行一下，可以发现消息被顺利打印出来了。&lt;/p&gt;

&lt;p&gt;其实无论是哪种方式的实现，内部本质还是基于最原生的api，我们只要理解最基础的部分，这些理解起来还是比较容易的。 &lt;/p&gt;
</description>
<pubDate>Mon, 23 Apr 2018 05:48:00 +0000</pubDate>
<dc:creator>让我发会呆</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yxy-ngu/p/8892292.html</dc:identifier>
</item>
</channel>
</rss>