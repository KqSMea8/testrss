<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>分享知识-快乐自己：Oracle基本语法（创建：表空间、用户、授权、约束等）使用指南 - GDBD</title>
<link>http://www.cnblogs.com/mlq2017/p/9903988.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mlq2017/p/9903988.html</guid>
<description>&lt;p&gt;&lt;span&gt;Oracle12c 与 Oracle11g 创建用户时有差别。Oracle12C默认为 CDB模式 这时创建用户的时候需要加上 c## 开头；例如：c##MLQ。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--说明&lt;/span&gt;&lt;br/&gt;&lt;span&gt;--需求：创建表空间（MLQ1_hr） 和 临时表空间(MLQ1_TEMP)、创建新用户 c##MLQ1 为其分配指定的表空间和临时表空间&lt;/span&gt;&lt;br/&gt;&lt;span&gt;--为用户分配基本权限、为用户创建表结构、添加数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--可能出现的问题&lt;/span&gt;&lt;br/&gt;&lt;span&gt;--Oracle12c 默认的表空间为：USERS，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;--01、没有在创建用户的时候同时指定表空间，单独执行为用户分配表空间的时候可能会更改不成功。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;--02、在对某张表添加数据的时候，可能会出现对指定的表空间无权限操作：错误编码：ORA-01950，这个时候重新分配一下表空间即可&lt;span&gt;&lt;strong&gt;（6）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）创建一个数据库临时表空间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;CREATE TEMPORARY TABLESPACE MLQ1_TEMP
TEMPFILE &lt;/span&gt;'E:\Oracle\OracleTablespaces\MLQ1\TEMP.DBF'&lt;span&gt;
SIZE 50M
AUTOEXTEND ON
NEXT &lt;/span&gt;50&lt;span&gt; MAXSIZE 100M
EXTENT MANAGEMENT LOCAL;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2）创建一个自动增长的表空间&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;CREATE tablespace MLQ1_hr
LOGGING Datafile
&lt;/span&gt;'E:\Oracle\OracleTablespaces\MLQ1\MLQ1_hr01.dbf'&lt;span&gt; size 60M Autoextend on
NEXT &lt;/span&gt;50&lt;span&gt; MAXSIZE 2048M
EXTENT MANAGEMENT LOCAL;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3）创建用户并指定表空间&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;create user c##MLQ1 identified by root
&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; tablespace MLQ1_hr 
temporary tablespace MLQ1_TEMP;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4）删除用户&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;drop user c##MLQ1 cascade;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;无法删除用户时：查看当前用户连接状态&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select saddr,sid,serial#,paddr,username,status from v$session where username is not &lt;span&gt;null&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;结束指定的用户连接&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter system kill session'（sid）,（serial#）';&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5）给用户授权&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;--connect role(连接角色)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　--临时用户，特指不需要建表的用户，通常只赋予他们connect role.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　--connect是使用oracle简单权限，这种权限只对其他用户的表有访问权限，包括select/insert/update和delete等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　--拥有connect role 的用户还能够创建表、视图、序列（sequence）、簇（cluster）、同义词(synonym)、回话（session）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　--和其他 数据的链（link）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;--resource role(资源角色)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　--更可靠和正式的数据库用户可以授予resource role。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　--resource提供给用户另外的权限以创建他们自己的表、序列、过程(procedure)、触发器(trigger)、索引(index)和簇(cluster)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;--dba role(数据库管理员角色)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　--dba role拥有所有的系统权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　--包括无限制的空间限额和给其他用户授予各种权限的能力。system由dba用户拥有&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;grant resource,connect to c##MLQ1

grant resource to c##MLQ1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;撤销授权：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;revoke connect, resource from c##MLQ1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;创建、授权、删除角色：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了前面讲到的三种系统角色----connect、resource和dba，用户还可以在oracle创建自己的role。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用户创建的role可以由表或系统权限或两者的组合构成。为了创建role，用户必须具有create role系统权限。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;span&gt;》创建角色
　　语法： create role 角色名;
　　例子： create role testRole;&lt;br/&gt;&lt;/span&gt;2&lt;span&gt;》授权角色
　　语法： grant select on &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; to 角色名;
　　列子： grant select on &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; to testRole;
　　注：现在，拥有testRole角色的所有用户都具有对class表的select查询权限

&lt;/span&gt;3&lt;span&gt;》删除角色
　　语法： drop role 角色名;
　　例子： drop role testRole;
　　注：与testRole角色相关的权限将从数据库全部删除&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6）为用户分配重新分配数据库表空间&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter user c##MLQ1 quota unlimited on MLQ1_hr;

alter user c##MLQ1 QUOTA unlimited ON MLQ1_hr TEMPORARY TABLESPACE MLQ1_TEMP;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7）删除表空间&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DROP TABLESPACE MLQ1_hr INCLUDING CONTENTS;

drop tablespace MLQ1_hr including contents and datafiles cascade constraints&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8）在c##MLQ1用户下创建表结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--创建表emp--&lt;span&gt;
create table emp(
empno number primary key not &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
empname nvarchar2(&lt;/span&gt;32) not &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
deptno number not &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
);
&lt;/span&gt;--创建表dept--&lt;span&gt;
create table dept(
deptno number primary key not &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
deptname nvarchar2(&lt;/span&gt;32) not &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
);

insert into EMP values(&lt;/span&gt;'2018001','MLQ',1);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;9）删除表空间下所有的表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT 'DROP TABLE ' || TABLE_NAME || ' CASCADE CONSTRAINTS'&lt;span&gt; V_NAME
FROM DBA_TABLES
WHERE TABLESPACE_NAME &lt;/span&gt;= 'USERS';&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;10）：查询当前用户所在的表空间&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select username,default_tablespace from user_users;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;11）：查看所有存在的表空间（查询到的数据可能没有全部展开，点击向下的绿箭头）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select * from dba_tablespaces&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;12）：查看所有用户&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select * from all_users;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;13）：查看用户具有怎样的角色&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select * from dba_role_privs where grantee='C##MLQ1';&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;14）：查看oracle中所有的角色&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select * from dba_roles;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;1）：Oracle的创建表和创建约束的Sql语句— —&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Oracle数据库中的约束有五种约束，分别是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实体完整性：主键约束、唯一性约束(可以为空)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;域完整性：check 检查约束&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;引用完整性：Foreign KEY 外键约束&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认约束(默认值)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SQL语句创建约束需要一个关键字：Costraint&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;模拟两张表：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;---1、创建模拟的数据表 ---
  --1.1&lt;span&gt;.创建学生表Student
  create table Student(
         StuId NUMBER NOT NULL,     &lt;/span&gt;--&lt;span&gt;学生ID
         StuName VARCHAR2(&lt;/span&gt;10) NOT NULL, --&lt;span&gt;名称
         Gender VARCHAR2(&lt;/span&gt;10)NOT NULL,  --&lt;span&gt; 性别
         Age NUMBER(&lt;/span&gt;2) NOT NULL,    --&lt;span&gt; 年龄     
         JoinDate DATE NULL,       &lt;/span&gt;--&lt;span&gt;入学时间
         ClassId NUMBER NOT NULL,   &lt;/span&gt;--&lt;span&gt;班级ID
         Address VARCHAR2(&lt;/span&gt;50) NULL   --&lt;span&gt;家庭住址           
  ); 
  &lt;/span&gt;--1.2&lt;span&gt;、创建班级表StuClass 
  create table StuClass(
       classId NUMBER not &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;,     --&lt;span&gt; 班级ID
       ClassName varchar2(&lt;/span&gt;20) not &lt;span&gt;null&lt;/span&gt;,  --&lt;span&gt;班级名称
       Notes varchar2(&lt;/span&gt;50) &lt;span&gt;null&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;'班级信息',  --&lt;span&gt;备注，默认班级信息
  );&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;创建数据表约束：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  --2.1）创建主键约束--&lt;span&gt;
  alter table Student add constraint PK_Student_StuId primary key(StuId);
  alter table StuClass add constraint PK_StuClass_ClassId primary key(ClassId);

  &lt;/span&gt;--2.2) 创建检查约束--&lt;span&gt;
  alter table Student add constraint CK_Student_Gender check(gender&lt;/span&gt;='男' or gender='女'&lt;span&gt;);
  alter table Student add constraint CK_Student_Age check(Age&lt;/span&gt;&amp;gt;=0 and Age&amp;lt;=100&lt;span&gt;);

  &lt;/span&gt;--2.3)创建唯一约束--&lt;span&gt;
  alter table Student add constraint UQ_Student_StuName unique(StuName);

  &lt;/span&gt;--2.4)创建默认约束--
  --alter table Student add constraint DF_Student_Address &lt;span&gt;default&lt;/span&gt;('地址不详'&lt;span&gt;);
  alter table Student Modify Address varchar(&lt;/span&gt;50) &lt;span&gt;default&lt;/span&gt; '地址不详'&lt;span&gt;;
  alter table Student Modify JoinDate Date &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; sysdate;

  &lt;/span&gt;--2.5)创建外键约束--&lt;span&gt;
  alter table Student add constraint FK_Student_StuCLass_ClassId foreign key(ClassId) references StuClass(ClassId);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：创建表还是约束，与SQL Server基本相同，注意：在Oracle中default是一个值，而SQL Server中default是一个约束，因此Oracle的default设置可以在建表的时候创建或者通过Modify函数创建&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;添加模拟数据：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  --3.1&lt;span&gt;）添加班级信息
  insert into StuClass(ClassId,Classname) values(&lt;/span&gt;1,'一班'&lt;span&gt;);
  insert into StuClass(ClassId,Classname) values(&lt;/span&gt;2,'二班'&lt;span&gt;);
  insert into StuClass(ClassId,Classname) values(&lt;/span&gt;3,'三班'&lt;span&gt;);
   &lt;/span&gt;--3.2&lt;span&gt;）添加学生信息
  insert into Student(StuId,Stuname,Gender,Age,ClassId)
  　　values(&lt;/span&gt;1,'关羽','男',17,1&lt;span&gt;);
  insert into Student(StuId,Stuname,Gender,Age,ClassId)
  　　values(&lt;/span&gt;2,'张飞','男',16,2&lt;span&gt;);
  insert into Student(StuId,Stuname,Gender,Age,ClassId)
  　　values(&lt;/span&gt;3,'刘备','男',18,3);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;查询模拟数据：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
select *&lt;span&gt; from Student;
select &lt;/span&gt;* from StuClass;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;查询结果：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201811/1216893-20181104150945665-170720662.png&quot; alt=&quot;&quot; width=&quot;660&quot; height=&quot;152&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201811/1216893-20181104151013312-432398001.png&quot; alt=&quot;&quot; width=&quot;405&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;验证数据表约束：验证Student表的StuName是否唯一（唯一约束）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--插入相同名称--&lt;span&gt;
insert into Student(StuId,Stuname,Gender,Age,ClassId) values(&lt;/span&gt;5,'关羽','男',18,1);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201811/1216893-20181104151125812-1691201583.png&quot; alt=&quot;&quot; width=&quot;514&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;验证Student表Gender的检查约束：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  --添加性别为未知的数据--&lt;span&gt;
  insert into Student(StuId,Stuname,Gender,Age,ClassId) values(&lt;/span&gt;4,'曹操','未知',18,1);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1216893/201811/1216893-20181104151239637-208455099.png&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;165&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;其他的验证就不一样了，这里不在多多演示。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Face your past without regret. Handle your present with confidence.Prepare for future without fear. keep the faith and drop the fear.&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;面对过去无怨无悔，把握现在充满信心，备战未来无所畏惧。保持信念，克服恐惧！一点一滴的积累，一点一滴的沉淀，学技术需要不断的积淀！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 04 Nov 2018 07:17:00 +0000</pubDate>
<dc:creator>GDBD</dc:creator>
<og:description>Oracle12c 与 Oracle11g 创建用户时有差别。Oracle12C默认为 CDB模式 这时创建用户的时候需要加上 c## 开头；例如：c##MLQ。 --说明--需求：创建表空间（MLQ</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mlq2017/p/9903988.html</dc:identifier>
</item>
<item>
<title>移动端兼容和适配问题 - Lazy.Cat</title>
<link>http://www.cnblogs.com/Lazy-Cat/p/9904006.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lazy-Cat/p/9904006.html</guid>
<description>&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;安卓浏览器看背景图片，有些设备会模糊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;解决方案:将背景图片放大为div的2X倍(一般为两倍),背景图尽量高清且大于目标div的尺寸&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/*原背景(div宽高都为100px)*/
.div{
    background:url(../../XX.png) no-repeat center center;
    background-size: 100px 100px;display:inline-block;
}
/*兼容后的背景*/
.div{
    background:url(../../XX.png) no-repeat center center;
    background-size: 200px 200px;display:inline-block;
}
/*或者*/
.div{
    background:url(../../XX.png) no-repeat center center;
    background-size: contain;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;图片加载很慢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;解决方案:1.使用Canvas绘制图片进行预加载;&lt;br/&gt;2.使用Lazy Load插件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/*方案1*/
 /*  获取图片的base64码
        * @param {obj}img图片dom对象
         * */
        function getBase64Image(img) {
          let canvas = document.createElement(&quot;canvas&quot;);
          canvas.width = img.width;
          canvas.height = img.height;
          let ctx = canvas.getContext(&quot;2d&quot;);
          ctx.drawImage(img, 0, 0, img.width, img.height);  //绘制相同图片
          return canvas.toDataURL(&quot;image/png&quot;); //转换成base64数据
        }
        &amp;lt;!--需要预加载的图片--&amp;gt;
    &amp;lt;save-img-base64&amp;gt;
      &amp;lt;img src=&quot;../../assets/1.png&quot;/&amp;gt;
      &amp;lt;img src=&quot;../../assets/2.png&quot;/&amp;gt;
      &amp;lt;img src=&quot;../../assets/3.png&quot;/&amp;gt;
    &amp;lt;/save-img-base64&amp;gt;
    
    
/*方案2*/
/*加载Lazy Load插件,其为jQuery的一个库因此也要加载jQuery插件*/
&amp;lt;script src=&quot;jquery.js&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;jquery.lazyload.js&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;img src=&quot;img/grey.gif&quot; data-original=&quot;img/example.jpg&quot; width=&quot;640&quot; heigh=&quot;480&quot;&amp;gt;
$(&quot;img.lazy&quot;).lazyload(threshold : 200);

/*当用户禁用JavaScript时默认显示的图像
&amp;lt;img src=&quot;img/grey.gif&quot; data-original=&quot;img/example.jpg&quot; width=&quot;640&quot; heigh=&quot;480&quot;&amp;gt; 
&amp;lt;noscript&amp;gt;&amp;lt;img src=&quot;img/example.jpg&quot; width=&quot;640&quot; heigh=&quot;480&quot;&amp;gt;&amp;lt;/noscript&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;$(&quot;img.lazy&quot;).show().lazyload();&amp;lt;/script&amp;gt;
    &lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;3.手机中网页的放大和缩小&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;解决方案:禁用用户的缩放功能&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    &amp;lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=0&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;4.格式的自动识别&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;解决方案:禁用自动识别页面中的格式&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    &amp;lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;5.移动端Gps定位&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;解决方啊:引用百度地图的api&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    &amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, user-scalable=no&quot; /&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        body, html {
            width: 100%;
            height: 100%;
            margin: 0;
            font-family: &quot;微软雅黑&quot;;
            font-size: 14px;
        }

        #allmap {
            width: 100%;
            height: 500px;
        }
    &amp;lt;/style&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=2.0&amp;amp;ak=wqBXfIN3HkpM1AHKWujjCdsi&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;title&amp;gt;获取当前所在地址，不显示地图&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;!--&amp;lt;div id=&quot;allmap&quot;&amp;gt;&amp;lt;/div&amp;gt;--&amp;gt;
    &amp;lt;!--不显示地图--&amp;gt;
    &amp;lt;div id=&quot;allmap&quot; style=&quot;display:none&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(function () {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(showPosition, locationError);
        } else {
            alert(&quot;你的浏览器不支持 GeoLocation.&quot;);
        }
    });

    //定位成功时，执行的函数
    function showPosition(position) {
        // 百度地图API功能
        var map = new BMap.Map(&quot;allmap&quot;);
        var point = new BMap.Point(116.331398, 39.897445);
        map.centerAndZoom(point, 12);
        var geoc = new BMap.Geocoder();

        translateCallback = function (res) {
            alert(res.points.length);
            $.each(res.points, function (index, val) {
                var point = val;
                alert(point.lng + &quot;,&quot; + point.lat);
                var marker = new BMap.Marker(point);
                map.addOverlay(marker);
                map.setCenter(point);
                geoc.getLocation(point, function (rs) {
                    var addComp = rs.addressComponents;
                    alert(addComp.province + &quot;, &quot; + addComp.city + &quot;, &quot; + addComp.district + &quot;, &quot; + addComp.street + &quot;, &quot; + addComp.streetNumber);
                    //var infoWindow = new BMap.InfoWindow(sContent);
                    //map.openInfoWindow(infoWindow, point);
                });
            });
            
        }//(point);
        var convertor = new BMap.Convertor();
        var points = new Array();
        points.push(point);
        //translate(points: Array&amp;lt;BMap.Point&amp;gt;, from: number, to: number, callback: function)//callback返回是一个对象Object，TranslateResults类型
        //TranslateResults：status,points
        //参照：JavaScript API-服务类 Convertor TranslateResults http://lbsyun.baidu.com/cms/jsapi/reference/jsapi_reference.html#a7b49
        //其中状态码可参照：WEB服务API-坐标转换API http://lbsyun.baidu.com/index.php?title=webapi/guide/changeposition
        convertor.translate(points, 1, 5, translateCallback);
    }

    // 定位失败时，执行的函数
    function locationError(error) {
        switch (error.code) {
            case error.PERMISSION_DENIED:
                alert(&quot;User denied the request for Geolocation.&quot;);
                break;
            case error.POSITION_UNAVAILABLE:
                alert(&quot;Location information is unavailable.&quot;);
                break;
            case error.TIMEOUT:
                alert(&quot;The request to get user location timed out.&quot;);
                break;
            case error.UNKNOWN_ERROR:
                alert(&quot;An unknown error occurred.&quot;);
                break;
        }
    }
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;6.上下拉动滚动条时卡顿、慢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;body {
        -webkit-overflow-scrolling:touch;
        overflow-scrolling: touch;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;7.是否允许用户复制文本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Element {
        -webkit-user-select:none;

        -moz-user-select:none;

        -khtml-user-select:none;

        user-select:none;

 }&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;8.长时间按住页面出现闪退&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;element {
    -webkit-touch-callout:none;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;9.iphone及ipad下输入框默认内阴影&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Element{

        -webkit-appearance:none;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;10、ios和android下触摸元素时出现半透明灰色遮罩&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Element {

    -webkit-tap-highlight-color:rgba(255,255,255,0)

}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;11、active兼容处理 即 伪类 :active 失效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;解决方案:js给 document 绑定 touchstart 或 touchend 事件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;document.addEventListener('touchstart',function(){},false);&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;12.webkit mask 兼容处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;if('WebkitMask'indocument.documentElement.style){

    /*支持*/

}
else{

    /*不支持*/

}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;13.旋转屏幕时，字体大小自动调整的问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6{

-webkit-text-size-adjust:100%;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;14.transition闪屏&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/设置内嵌的元素在3D 空间如何呈现：保留3D /

-webkit-transform-style: preserve-3d;

/ 设置进行转换的元素的背面在面对用户时是否可见：隐藏 /

-webkit-backface-visibility:hidden;
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;15.圆角bug&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;background-clip: padding-box;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;16.h5网站input 设置为type=number的问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;解决方案:解决max-length和部分手机样式问题&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;functioncheckTextLength(obj, length) {

if(obj.value.length &amp;gt; length)  {

obj.value = obj.value.substr(0, length);

}

}
input[type=number] {

-moz-appearance:textfield;

}

input[type=number]::-webkit-inner-spin-button,

input[type=number]::-webkit-outer-spin-button {

-webkit-appearance:none;

margin:0;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;IOS移动端click事件300ms的延迟响应&lt;br/&gt;-解决方案:使用fastclick&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;window.addEventListener( &quot;load&quot;, function() {
FastClick.attach( document.body );
}, false );
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;18.点击穿透问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;解决方案:使用touch替代click,避免混用.&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;19.h5底部输入框被键盘遮挡问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;script src=&quot;jquery.js&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
var oHeight = $(document).height(); //浏览器当前的高度
   
   $(window).resize(function(){
 
        if($(document).height() &amp;lt; oHeight){
         
        $(&quot;#footer&quot;).css(&quot;position&quot;,&quot;static&quot;);
    }else{
         
        $(&quot;#footer&quot;).css(&quot;position&quot;,&quot;absolute&quot;);
    }
        
   });&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;20.自动适应屏幕宽度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1,user-scalable=0&quot;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;21.在pc端的基础上手动调节移动端的布局&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/*max-width:最大宽度以下的布局为..min-width:最小宽度以上的布局为: 具有覆盖效果*/
@media (max-width: 720px)
html {
font-size: 62.5%;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;参考文档&lt;br/&gt;https://www.cnblogs.com/mazhaokeng/p/8461260.html&lt;br/&gt;https://blog.csdn.net/dengboblog/article/details/53156570&lt;br/&gt;https://blog.csdn.net/diqi77/article/details/54692920&lt;br/&gt;https://www.cnblogs.com/zr123/p/8178740.html&lt;/p&gt;
</description>
<pubDate>Sun, 04 Nov 2018 07:02:00 +0000</pubDate>
<dc:creator>Lazy.Cat</dc:creator>
<og:description>安卓浏览器看背景图片，有些设备会模糊 解决方案:将背景图片放大为div的2X倍(一般为两倍),背景图尽量高清且大于目标div的尺寸 图片加载很慢 解决方案:1.使用Canvas绘制图片进行预加载; 2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Lazy-Cat/p/9904006.html</dc:identifier>
</item>
<item>
<title>day67_Redis学习笔记_01 - 黑泽明军</title>
<link>http://www.cnblogs.com/chenmingjun/p/9903883.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/9903883.html</guid>
<description>&lt;div id=&quot;output_wrapper_id&quot; class=&quot;output_wrapper&quot; readability=&quot;44&quot;&gt;
&lt;p&gt;&lt;strong&gt;课程计划&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、Redis的介绍
&lt;ul&gt;&lt;li&gt;&lt;span&gt;a) 什么是NoSql&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;b) NoSql的分类&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;c) 什么是Redis&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;d) Redis的历史发展&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;e) Redis的应用场景&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2、Redis服务端的安装（重点）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;3、Redis客户端的使用
&lt;ul&gt;&lt;li&gt;&lt;span&gt;a) redis自带客户端（命令行）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;b) 图形界面的客户端（了解）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;c) Java客户端Jedis（重点）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;4、Redis的数据类型（重点）
&lt;ul&gt;&lt;li&gt;&lt;span&gt;a) String类型&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;b) 散列类型（Map类型）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;c) List类型（列表类型）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;d) Set类型（集合类型）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;e) SortedSet类型（zset类型）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;5、keys命令（了解）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;6、Redis的持久化方案
&lt;ul&gt;&lt;li&gt;&lt;span&gt;a) RDB方式（默认）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;b) AOF方式&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;7、Redis的主从复制&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;8、Redis的集群（重点）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;9、Jedis连接Redis集群&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;h1redis&quot;&gt;&lt;span&gt;&lt;strong&gt;1、Redis的介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h11nosql&quot;&gt;&lt;span&gt;&lt;strong&gt;1.1、什么是NoSql&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;为了解决高并发、高可扩展、高可用、大数据存储问题而产生的数据库解决方案，就是NoSql数据库。&lt;br/&gt;NoSQL，泛指非关系型的数据库，&lt;code&gt;NoSQL即Not-Only SQL&lt;/code&gt;，它可以作为关系型数据库的&lt;code&gt;良好补充&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h12nosql&quot;&gt;&lt;span&gt;&lt;strong&gt;1.2、Nosql的分类&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;键值(Key-Value)存储数据库：&lt;/strong&gt;&lt;br/&gt;  相关产品：Tokyo Cabinet/Tyrant、&lt;code&gt;Redis&lt;/code&gt;、Voldemort、Berkeley DB&lt;br/&gt;  典型应用：&lt;code&gt;内容缓存&lt;/code&gt;，主要用于处理大量数据的&lt;code&gt;高访问负载&lt;/code&gt;&lt;br/&gt;  数据模型：一系列键值对&lt;br/&gt;  优势：快速查询&lt;br/&gt;  劣势：存储的数据缺少结构化(现在通过Redis数据类型得到解决)&lt;br/&gt;&lt;strong&gt;列存储数据库：&lt;/strong&gt;&lt;br/&gt;  相关产品：Cassandra、&lt;code&gt;HBase&lt;/code&gt;、Riak&lt;br/&gt;  典型应用：&lt;code&gt;分布式&lt;/code&gt;的文件系统&lt;br/&gt;  数据模型：以&lt;code&gt;列簇式&lt;/code&gt;存储，将同一列数据存在一起&lt;br/&gt;  优势：查找速度快，可扩展性强，更容易进行&lt;code&gt;分布式扩展&lt;/code&gt;&lt;br/&gt;  劣势：功能相对局限&lt;br/&gt;&lt;strong&gt;文档型数据库：&lt;/strong&gt;&lt;br/&gt;  相关产品：CouchDB、&lt;code&gt;MongoDB&lt;/code&gt;&lt;br/&gt;  典型应用：Web应用（与Key-Value类似，Value是结构化的），比如：存储日志&lt;br/&gt;  数据模型：一系列键值对&lt;br/&gt;  优势：数据结构要求不严格&lt;br/&gt;  劣势：查询性能不高，而且缺乏统一的查询语法&lt;br/&gt;&lt;strong&gt;图形(Graph)数据库：&lt;/strong&gt;&lt;br/&gt;  相关数据库：Neo4J、InfoGrid、Infinite Graph&lt;br/&gt;  典型应用：社交网络、微信平台&lt;br/&gt;  数据模型：图结构&lt;br/&gt;  优势：利用图结构相关算法。&lt;br/&gt;  劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h13redis&quot;&gt;&lt;span&gt;&lt;strong&gt;1.3、什么是Redis&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;  Redis是用&lt;code&gt;C语&lt;/code&gt;言开发的一个&lt;code&gt;开源的&lt;/code&gt;高性能&lt;code&gt;键值对（key-value）数据库&lt;/code&gt;。它通过提供多种&lt;code&gt;键值数据类型&lt;/code&gt;来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：&lt;br/&gt;  String字符串类型&lt;br/&gt;  Map散列类型&lt;br/&gt;  List列表类型&lt;br/&gt;  Set集合类型&lt;br/&gt;  SortedSet有序集合类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h14redis&quot;&gt;&lt;span&gt;&lt;strong&gt;1.4、Redis的历史发展&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;  2008年，意大利的一家创业公司Merzia推出了一款基于MySQL的网站实时统计系统LLOOGG，然而没过多久该公司的创始人Salvatore Sanfilippo便对MySQL的性能感到失望，于是他决定亲自为LLOOGG量身定做一个数据库，并于2009年开发完成，这个数据库就是Redis。不过Salvatore Sanfilippo并不满足只将Redis用于LLOOGG这一款产品，而是希望更多的人使用它，于是在同一年Salvatore Sanfilippo将Redis开源发布，并开始和Redis的另一名主要的代码贡献者Pieter Noordhuis一起继续着Redis的开发，直到今天。&lt;br/&gt;  Salvatore Sanfilippo自己也没有想到，短短的几年时间，Redis就拥有了庞大的用户群体。Hacker News在2012年发布了一份数据库的使用情况调查，结果显示有近12%的公司在使用Redis。国内如新浪微博、街旁网、知乎网，国外如GitHub、Stack Overflow、Flickr等都是Redis的用户。&lt;br/&gt;  VMware公司从2010年开始赞助Redis的开发，Salvatore Sanfilippo和Pieter Noordhuis也分别在3月和5月加入VMware，全职开发Redis。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h15redis&quot;&gt;&lt;span&gt;&lt;strong&gt;1.5、Redis的应用场景&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;  1、缓存（数据查询、短连接、新闻内容、商品内容等等）。（最多使用）&lt;br/&gt;  2、分布式集群架构中的session分离。&lt;br/&gt;  3、聊天室的在线好友列表。&lt;br/&gt;  4、任务队列。（秒杀、抢购、12306等等）&lt;br/&gt;  5、应用排行榜。&lt;br/&gt;  6、网站访问统计。&lt;br/&gt;  7、数据过期处理（可以精确到毫秒）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;h2redis&quot;&gt;&lt;span&gt;&lt;strong&gt;2、Redis服务端的安装（重点）&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h21redis&quot;&gt;&lt;span&gt;&lt;strong&gt;2.1、Redis的下载&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;官网地址：http://redis.io/&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;最新版本为：redis-5.0.0&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;本课程使用：redis-3.0.0&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;下载地址：http://download.redis.io/releases/redis-3.0.0.tar.g&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/04/5mVdal.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h22redis&quot;&gt;&lt;span&gt;&lt;strong&gt;2.2、Redis的安装&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Redis是C语言开发，建议在linux上运行，本教程使用Centos7作为安装环境。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;第一步：在VMware中安装CentOS7（参考Linux教程中的安装虚拟机）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;第二步：在Linux下安装gcc环境（该步骤可以省略，CentOS中默认自带C环境），但是建议还是手动安装下，需要联网，安装命令如下：&lt;br/&gt;  [root@itheima ~]# yum install gcc-c++&lt;br/&gt;安装成功截图：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/04/5mV4UG.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;第三步：将下载的Redis源码包上传到Linux服务器中&lt;br/&gt;【注意：SecureCRT需要切换到sftp窗口，步骤：选中连接窗口右键“连接SFTP会话”，直接拖拽文件至窗口中，回车】&lt;br/&gt;  sftp&amp;gt; put -r &quot;E:\学习资料\java\java就业班\17、第十七阶段redis(1天)\redis\res\redis-3.0.0.tar.gz&quot;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/04/5mVjfJ.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;第四步：返回到连接窗口，解压缩redis源码包&lt;br/&gt;  [root@itheima ~]# tar -zxf redis-3.0.0.tar.gz&lt;/li&gt;
&lt;li&gt;第五步：编译redis源码&lt;br/&gt;  [root@itheima ~]# cd redis-3.0.0/&lt;br/&gt;  [root@itheima redis-3.0.0]# make&lt;/li&gt;
&lt;li&gt;第六步：安装redis&lt;br/&gt;  [root@itheima redis-3.0.0]# make install PREFIX=/usr/local/redis&lt;/li&gt;
&lt;li&gt;第七步：查看是否安装成功&lt;br/&gt;  [root@itheima redis-3.0.0]# cd /usr/local/redis/&lt;br/&gt;  [root@itheima redis]# ll&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/04/5mVWQX.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h23redis&quot;&gt;&lt;span&gt;&lt;strong&gt;2.3、Redis的启动&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h231&quot;&gt;&lt;span&gt;&lt;strong&gt;2.3.1、前端启动&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;前端启动的命令：&lt;br/&gt;  [root@itheima bin]# ./redis-server&lt;/li&gt;
&lt;li&gt;前端启动的关闭命令：&lt;br/&gt;  强制关闭（非法关闭）：Ctrl+c&lt;br/&gt;  正常关闭（需要通过其他窗口）：[root@itheima bin]# ./redis-cli shutdown&lt;/li&gt;
&lt;li&gt;启动界面：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/04/5mVMXB.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;前端启动的问题：&lt;br/&gt;  ssh命令窗口关闭，则redis-server程序结束，即一旦客户端关闭，则redis服务也停掉。不推荐使用此方法。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h231-1&quot;&gt;&lt;span&gt;&lt;strong&gt;2.3.1、后端启动&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;第一步：将虚拟机中/root目录下redis源码包中的redis.conf配置文件复制到虚拟机/usr/local/redis/bin/目录下&lt;br/&gt;  方式一：[root@itheima bin]# cp /root/redis-3.0.0/redis.conf /usr/local/redis/bin/&lt;br/&gt;  方式二：[root@itheima bin]# cp /root/redis-3.0.0/redis.conf ./&lt;/li&gt;
&lt;li&gt;第二步：修改redis.conf，将daemonize由no改为yes&lt;br/&gt;  [root@itheima bin]# vim redis.conf&lt;/li&gt;
&lt;li&gt;第三步：执行命令，后端启动redis&lt;br/&gt;  [root@itheima bin]# ./redis-server redis.conf&lt;/li&gt;
&lt;li&gt;第四步：查看是否启动成功，通过查看进程号&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/04/5mVOJ6.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;关闭后端启动的方式：&lt;br/&gt;  强制关闭：[root@itheima bin]# kill -9 7272&lt;br/&gt;  正常关闭：[root@itheima bin]# ./redis-cli shutdown&lt;/li&gt;
&lt;li&gt;在项目中，建议使用正常关闭。&lt;br/&gt;因为redis作为缓存来使用的话，是将数据存储到内存中，&lt;br/&gt;  如果使用正常关闭，则会将内存数据持久化到本地之后，再关闭。&lt;br/&gt;  如果使用强制关闭，则不会进行持久化操作，可能会造成部分数据的丢失。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;h3redis&quot;&gt;&lt;span&gt;&lt;strong&gt;3、Redis客户端的使用&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h31redis&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1、redis自带的客户端（命令行）&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;先启动服务端命令：[root@itheima bin]# ./redis-server redis.conf&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;再启动客户端命令：[root@itheima bin]# ./redis-cli -h 127.0.0.1 -p 6379&lt;br/&gt;  -h：指定访问的redis服务器的ip地址&lt;br/&gt;  -p：指定访问的redis服务器的port端口&lt;/li&gt;
&lt;li&gt;如果不指定主机和端口也可以&lt;br/&gt;  即可以写成：[root@itheima bin]# ./redis-cli&lt;br/&gt;  使用默认配置：默认的ip【127.0.0.1】，默认的port【6379】&lt;/li&gt;
&lt;li&gt;关闭redis客户端的方式：&lt;br/&gt;  方式一：Ctrl+c&lt;br/&gt;  方式二：127.0.0.1:6379&amp;gt; quit&lt;/li&gt;
&lt;li&gt;进行数据测试：&lt;br/&gt;  127.0.0.1:6379&amp;gt; set s1 hello&lt;br/&gt;  OK&lt;br/&gt;  127.0.0.1:6379&amp;gt; get s1&lt;br/&gt;  &quot;hello&quot;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h32&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2、图形界面客户端（了解）&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h3 id=&quot;h33javajedis&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3、Java客户端Jedis（重点）&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h331jedis&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3.1、jedis介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Redis不仅是使用命令来操作，现在基本上主流的语言都有客户端支持，比如java、C、C#、C++、php、Node.js、Go等。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;在官方网站里罗列一些Java的客户端，有Jedis、Redisson、Jredis、JDBC-Redis、等其中官方推荐使用&lt;code&gt;Jedis&lt;/code&gt;和&lt;code&gt;Redisson&lt;/code&gt;。 在企业中用的最多的就是Jedis，下面我们就重点学习下Jedis。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Jedis同样也是托管在github上，地址：https://github.com/xetorthio/jedis&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h332jar&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3.2、添加jar包&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/11/04/5mVvcQ.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h333redis&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3.3、通过单实例连接redis服务器&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;创建一个普通的java项目，导入jar包&lt;br/&gt;测试代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;    &lt;br/&gt;@&lt;span class=&quot;hljs-function&quot;&gt;Test&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;testJedisClient&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;Jedis jedis = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Jedis(&lt;span class=&quot;hljs-string&quot;&gt;&quot;192.168.5.128&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6379&lt;/span&gt;);&lt;br/&gt;jedis.&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);&lt;br/&gt;jedis.&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;s4&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;晓艺，你还好吗？&quot;&lt;/span&gt;);&lt;br/&gt;String result = jedis.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;s4&quot;&lt;/span&gt;);&lt;br/&gt;System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(result);&lt;br/&gt;jedis.close();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h334redis&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3.4、通过连接池连接redis服务器&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;测试代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;    &lt;br/&gt;@&lt;span class=&quot;hljs-function&quot;&gt;Test&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;testJedisPool&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;JedisPool jedisPool = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; JedisPool(&lt;span class=&quot;hljs-string&quot;&gt;&quot;192.168.5.128&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6379&lt;/span&gt;);&lt;br/&gt;Jedis jedis = jedisPool.getResource();&lt;br/&gt;String result = jedis.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;s1&quot;&lt;/span&gt;);&lt;br/&gt;System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(result);&lt;br/&gt;jedis.close();&lt;br/&gt;jedisPool.close();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h335springjedispool&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3.5、spring整合jedisPool（自学）&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;添加spring的jar包&lt;br/&gt;配置spring配置文件applicationContext.xml&lt;br/&gt;applicationContext.xml&lt;/p&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;hljs xml&quot; readability=&quot;9&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;beans&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;xmlns&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;xmlns:xsi&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;xmlns:mvc&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/mvc&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;xmlns:context&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;xmlns:aop&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;xmlns:tx&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/tx&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;xsi:schemaLocation&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/beans &lt;br/&gt;http://www.springframework.org/schema/beans/spring-beans-3.2.xsd &lt;br/&gt;http://www.springframework.org/schema/mvc &lt;br/&gt;http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd &lt;br/&gt;http://www.springframework.org/schema/context &lt;br/&gt;http://www.springframework.org/schema/context/spring-context-3.2.xsd &lt;br/&gt;http://www.springframework.org/schema/aop &lt;br/&gt;http://www.springframework.org/schema/aop/spring-aop-3.2.xsd &lt;br/&gt;http://www.springframework.org/schema/tx &lt;br/&gt;http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;jedisPoolConfig&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.clients.jedis.JedisPoolConfig&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;maxTotal&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;30&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;maxIdle&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;numTestsPerEvictionRun&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;1024&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;timeBetweenEvictionRunsMillis&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;30000&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;minEvictableIdleTimeMillis&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;1800000&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;softMinEvictableIdleTimeMillis&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10000&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;maxWaitMillis&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;1500&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;testOnBorrow&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;false&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;testWhileIdle&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;blockWhenExhausted&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;false&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;bean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;jedisPool&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;redis.clients.jedis.JedisPool&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;destroy-method&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;close&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;constructor-arg&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;poolConfig&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;ref&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;jedisPoolConfig&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;constructor-arg&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;host&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;192.168.5.128&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;constructor-arg&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;port&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;6379&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;bean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;beans&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;    @&lt;span class=&quot;hljs-function&quot;&gt;Test&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;testJedisPool&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;JedisPool pool = (JedisPool) applicationContext.getBean(&lt;span class=&quot;hljs-string&quot;&gt;&quot;jedisPool&quot;&lt;/span&gt;);&lt;br/&gt;Jedis jedis = &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;jedis = pool.getResource();&lt;br/&gt;jedis.&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;s5&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;lisi&quot;&lt;/span&gt;);&lt;br/&gt;String name = jedis.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;s5&quot;&lt;/span&gt;);&lt;br/&gt;System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(name);&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception ex) {&lt;br/&gt;ex.printStackTrace();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (jedis != &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;jedis.close();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 04 Nov 2018 06:30:00 +0000</pubDate>
<dc:creator>黑泽明军</dc:creator>
<og:description>课程计划 1、Redis的介绍 a) 什么是NoSql b) NoSql的分类 c) 什么是Redis d) Redis的历史发展 e) Redis的应用场景 2、Redis服务端的安装（重点） 3、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/9903883.html</dc:identifier>
</item>
<item>
<title>swagger文档转换为WebApiClient声明式代码 - jiulang</title>
<link>http://www.cnblogs.com/kewei/p/9903851.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kewei/p/9903851.html</guid>
<description>&lt;h2 id=&quot;swagger简介&quot;&gt;1 swagger简介&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Swagger是一个规范且完整的框架，提供描述、生产、消费和可视化RESTful Web Service。其核心是使用json来规范描述RESTful接口，另外有提供UI来查看接口说明，并有一套生成不同语言的客户端调用代码生成器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;对api提供者&quot;&gt;1.1 对Api提供者&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;自顶向下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用Swagger编辑器创建Swagger定义，然后使用Swagger代码生成工具生成服务器实现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;自底向上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为已有的REST API创建Swagger定义。一般的，Api提供者都会选择这种方式，比如在&lt;code&gt;asp.net&lt;/code&gt;里集成swagger的支持，在写好接口代码之后，访问对应的swagger的访问Uri地址，就可以得到swagger.json。例如：http://petstore.swagger.io/v2/swagger.json&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;swagger&quot;: &quot;2.0&quot;,
  &quot;info&quot;: {
    &quot;tags&quot;: null,
    &quot;description&quot;: &quot;This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;title&quot;: &quot;Swagger Petstore&quot;,
    &quot;termsOfService&quot;: &quot;http://swagger.io/terms/&quot;,
    &quot;contact&quot;: {
      &quot;email&quot;: &quot;apiteam@swagger.io&quot;
    },
    &quot;license&quot;: {
      &quot;name&quot;: &quot;Apache 2.0&quot;,
      &quot;url&quot;: &quot;http://www.apache.org/licenses/LICENSE-2.0.html&quot;
    }
  },
  &quot;host&quot;: &quot;petstore.swagger.io&quot;,
  &quot;basePath&quot;: &quot;/v2&quot;,
  &quot;tags&quot;: [
  ...&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;对api使用者&quot;&gt;1.2 对Api使用者&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;使用swagger UI&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一些提供者的站点会提供swagger ui来查看其swagger.json，例如：http://petstore.swagger.io/ 有了这些UI，自己手工编写客户端调用代码也非常简单了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用Swagger Codegen&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以Swagger Codegen的将swagger.json逆向生成你需要的客户端调用接口代码，本质上是使用了代码模板结合swagger.json描述来生成代码。在.net里，有一个&lt;a href=&quot;https://github.com/RSuter/NSwag&quot;&gt;Nswag&lt;/a&gt;项目，可以将swagger.json生成使用HttpClient来请求接口的c#代码。但是这些代码的质量也比较差，比如以下代码的HttpClient的生命周期也就无法很好的维护。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;Add a new pet to the store&amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;body&quot;&amp;gt;Pet object that needs to be added to the store&amp;lt;/param&amp;gt;
/// &amp;lt;exception cref=&quot;SwaggerException&quot;&amp;gt;A server side error occurred.&amp;lt;/exception&amp;gt;
/// &amp;lt;param name=&quot;cancellationToken&quot;&amp;gt;A cancellation token that can be used by other objects or threads to receive notice of cancellation.&amp;lt;/param&amp;gt;
public async System.Threading.Tasks.Task AddPetAsync(Pet body, System.Threading.CancellationToken cancellationToken)
{
    var urlBuilder_ = new System.Text.StringBuilder();
    urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : &quot;&quot;).Append(&quot;/pet&quot;);

    var client_ = new System.Net.Http.HttpClient();
    try
    {
        using (var request_ = new System.Net.Http.HttpRequestMessage())
        {
            var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
            content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(&quot;application/json&quot;);
            request_.Content = content_;
            request_.Method = new System.Net.Http.HttpMethod(&quot;POST&quot;);

            PrepareRequest(client_, request_, urlBuilder_);
            var url_ = urlBuilder_.ToString();
            request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
            PrepareRequest(client_, request_, url_);

            var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            try
            {
                var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ =&amp;gt; h_.Key, h_ =&amp;gt; h_.Value);
                if (response_.Content != null &amp;amp;&amp;amp; response_.Content.Headers != null)
                {
                    foreach (var item_ in response_.Content.Headers)
                        headers_[item_.Key] = item_.Value;
                }

                ProcessResponse(client_, response_);

                var status_ = ((int)response_.StatusCode).ToString();
                if (status_ == &quot;405&quot;)
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw new SwaggerException(&quot;Invalid input&quot;, (int)response_.StatusCode, responseData_, headers_, null);
                }
                else
                if (status_ != &quot;200&quot; &amp;amp;&amp;amp; status_ != &quot;204&quot;)
                {
                    var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                    throw new SwaggerException(&quot;The HTTP status code of the response was not expected (&quot; + (int)response_.StatusCode + &quot;).&quot;, (int)response_.StatusCode, responseData_, headers_, null);
                }
            }
            finally
            {
                if (response_ != null)
                    response_.Dispose();
            }
        }
    }
    finally
    {
        if (client_ != null)
            client_.Dispose();
    }
}       &lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;WebApiClient是.net平台的一款RESTful声明式的面向切面客户端，其几乎100%实现了swagger定义的规范，WebApiClient.tools.swagger旨在将swagger.json逆向生成符合WebApiClient的声明式c#代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;作用&quot;&gt;2.1 作用&lt;/h3&gt;
&lt;p&gt;使用原生HttpClient，你可能需要20行代码包装调用一个接口；使用WebApiClient，你可能只需要一行代码来定义接口方法；使用WebApiClient + WebApiClient.tools.swagger，你一行代码都不用写。&lt;/p&gt;
&lt;h3 id=&quot;工作原理&quot;&gt;2.2 工作原理&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;使用NSwag解析json得到SwaggerDocument&lt;/li&gt;
&lt;li&gt;使用RazorEngine将SwaggerDocument传入cshtml模板编译得到html&lt;/li&gt;
&lt;li&gt;使用AngleSharp将html的文本代码提取，得到WebApiClient的声明式代码&lt;/li&gt;
&lt;li&gt;代码美化，输出到本地文件&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;样例效果&quot;&gt;2.3 样例效果&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;接口代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// Everything about your Pets
    /// &amp;lt;/summary&amp;gt;
    [TraceFilter]
    [HttpHost(&quot;https://petstore.swagger.io/v2/&quot;)]
    public interface IPetApi : IHttpApi
    {
        /// &amp;lt;summary&amp;gt;
        /// Add a new pet to the store
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;body&quot;&amp;gt;Pet object that needs to be added to the store&amp;lt;/param&amp;gt;
        [HttpPost(&quot;pet&quot;)]
        ITask&amp;lt;HttpResponseMessage&amp;gt; AddPetAsync( [Required] [JsonContent] Pet body );

        /// &amp;lt;summary&amp;gt;
        /// Update an existing pet
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;body&quot;&amp;gt;Pet object that needs to be added to the store&amp;lt;/param&amp;gt;
        [HttpPut(&quot;pet&quot;)]
        ITask&amp;lt;HttpResponseMessage&amp;gt; UpdatePetAsync( [Required] [JsonContent] Pet body );
    
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;模型代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public class Pet
    {
        [AliasAs(&quot;id&quot;)]
        public long? Id { get; set; }

        [AliasAs(&quot;category&quot;)]
        public Category Category { get; set; }

        [AliasAs(&quot;name&quot;)]
        [Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        [AliasAs(&quot;photoUrls&quot;)]
        [Required]
        public List&amp;lt;string&amp;gt; PhotoUrls { get; set; } = new List&amp;lt;string&amp;gt;();
        
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;相关资源&quot;&gt;3 相关资源&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;WebApiClient&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;github: https://github.com/dotnetcore/WebApiClient&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WebApiClient.tools&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;github: https://github.com/xljiulang/WebApiClient.Tools&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NSwag&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;github: https://github.com/RSuter/NSwag&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RazorEngine&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;github: https://github.com/Antaris/RazorEngine&lt;/p&gt;
</description>
<pubDate>Sun, 04 Nov 2018 06:24:00 +0000</pubDate>
<dc:creator>jiulang</dc:creator>
<og:description>1 swagger简介 Swagger是一个规范且完整的框架，提供描述、生产、消费和可视化RESTful Web Service。其核心是使用json来规范描述RESTful接口，另外有提供UI来查看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kewei/p/9903851.html</dc:identifier>
</item>
<item>
<title>使用异步操作时的注意要点(翻译) - 莫问今朝乄</title>
<link>http://www.cnblogs.com/yan7/p/9903700.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yan7/p/9903700.html</guid>
<description>&lt;h2 id=&quot;异步操作时应注意的要点&quot;&gt;异步操作时应注意的要点&lt;/h2&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;使用场景&lt;/h2&gt;

&lt;h2 id=&quot;demo1&quot;&gt;1.使用异步方法返回值应当避免使用void&lt;/h2&gt;
&lt;p&gt;在使用异步方法中最好不要使用&lt;strong&gt;void&lt;/strong&gt;当做返回值,无返回值也应使用&lt;strong&gt;Task&lt;/strong&gt;作为返回值,因为使用&lt;strong&gt;void&lt;/strong&gt;作为返回值具有以下缺点&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;无法得知异步函数的状态机在什么时候执行完毕&lt;/li&gt;
&lt;li&gt;如果异步函数中出现异常,则会导致进程崩溃&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;❌异步函数不应该返回void&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static  void Main(string[] args)
{
     try
     {
          //      如果Run方法无异常正常执行,那么程序无法得知其状态机什么时候执行完毕
          Run();
     }
     catch (Exception ex)
     {   
          Console.WriteLine(ex.Message);
     }
     Console.Read();
}
static async void Run()
{
     //      由于方法返回的为void,所以在调用此方法时无法捕捉异常,使得进程崩溃
     throw new Exception(&quot;异常了&quot;);
     await Task.Run(() =&amp;gt; { });

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;☑️应该将异步函数返回&lt;strong&gt;Task&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static  async Task Main(string[] args)
{
     try
     {
          //     因为在此进行await,所以主程序知道什么时候状态机执行完成
          await RunAsync();
          Console.Read();
     }
     catch (Exception ex)
     {   
          Console.WriteLine(ex.Message);
     }
}
static async Task RunAsync()
{
     //      因为此异步方法返回的为Task,所以此异常可以被捕捉
     throw new Exception(&quot;异常了&quot;);
     await Task.Run(() =&amp;gt; { });

}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;:事件是一个例外,异步事件也是返回void&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;demo2&quot;&gt;2.对于预计算或者简单计算的函数建议使用Task.FromResult代替Task.Run&lt;/h2&gt;
&lt;p&gt;对于一些预先知道的结果或者只是一个简单的计算函数,使用Task,FromResult要比Task.Run性能要好,因为Task.FromResult只是创建了一个包装已计算任务的任务,而Task.Run会将一个工作项在线程池进行排队,计算,返回.并且使用Task.FromResult在具有SynchronizationContext 程序中(例如WinForm)调用Result或wait()并不会死锁(虽然并不建议这么干)&lt;/p&gt;
&lt;p&gt;❌对于预计算或普通计算的函数不应该这么写&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async Task&amp;lt;int&amp;gt; RunAsync()
{
     return  await Task.Run(()=&amp;gt;1+1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;☑️而应该使用Task.FromResult代替&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async Task&amp;lt;int&amp;gt; RunAsync()
{
     return await Task.FromResult(1 + 1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有另外一种代替方法,那就是使用&lt;strong&gt;ValueTask&lt;/strong&gt;类型,&lt;strong&gt;ValueTask&lt;/strong&gt;是一个可被等待异步结构,所以并不会在堆中分配内存和任务分配,从而性能更优化.&lt;/p&gt;
&lt;p&gt;☑️使用ValueTask&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static  async Task Main(string[] args)
{
     await AddAsync(1, 1);
}
static ValueTask&amp;lt;int&amp;gt; AddAsync(int a, int b)
{
     //      返回一个可被等待的ValueTask类型
     return new ValueTask&amp;lt;int&amp;gt;(a + b);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5.811320754717&quot;&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: &lt;strong&gt;ValueTask&lt;/strong&gt;结构是C#7.0加入的,存在于&lt;strong&gt;Sysntem,Threading.Task.Extensions&lt;/strong&gt;包中&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dotnetcodr.com/2018/01/17/using-the-valuetask-of-t-object-in-c-7-0/&quot;&gt;ValueTask&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://rubikscode.net/2018/06/11/asynchronous-programming-in-net-benefits-and-tradeoffs-of-using-valuetask/&quot;&gt;ValueTask&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;demo3&quot;&gt;3.避免使用Task.Run()方法执行长时间堵塞线程的工作&lt;/h2&gt;
&lt;p&gt;长时间运行的工作是指在应用程序生命周期执行后台工作的线程,如:执行&lt;em&gt;processing queue items&lt;/em&gt;,执行&lt;em&gt;sleeping&lt;/em&gt;,执行&lt;em&gt;waiting&lt;/em&gt;或者处理某些数据,此类线程不建议使用Task.Run方法执行,因为Task.Run方法是将任务在线程池内进行排队执行,如果线程池线程进行长时间堵塞,会导致线程池增长,进而浪费性能,所以如果想要运行长时间的工作建议直接创建一个新线程进行工作&lt;/p&gt;
&lt;p&gt;❌下面这个例子就利用了线程池执行长时间的阻塞工作&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class QueueProcessor
{
     private readonly BlockingCollection&amp;lt;Message&amp;gt; _messageQueue = new BlockingCollection&amp;lt;Message&amp;gt;();

     public void StartProcessing()
     {
          Task.Run(ProcessQueue);
     }

     public void Enqueue(Message message)
     {
          _messageQueue.Add(message);
     }

     private void ProcessQueue()
     {
          foreach (var item in _messageQueue.GetConsumingEnumerable())
          {
               ProcessItem(item);
          }
     }

     private void ProcessItem(Message message) { }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;☑️所以应该改成这样&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class QueueProcessor
{
     private readonly BlockingCollection&amp;lt;Message&amp;gt; _messageQueue = new BlockingCollection&amp;lt;Message&amp;gt;();

     public void StartProcessing()
     {
          var thread = new Thread(ProcessQueue)
          {
               // 设置线程为背后线程,使得在主线程结束时此线程也会自动结束
               IsBackground = true
          };
          thread.Start();
     }

     public void Enqueue(Message message)
     {
          _messageQueue.Add(message);
     }

     private void ProcessQueue()
     {
          foreach (var item in _messageQueue.GetConsumingEnumerable())
          {
               ProcessItem(item);
          }
     }

     private void ProcessItem(Message message) { }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;🔔线程池内线程增加会导致在执行时大量的进行上下文切换,从而浪费程序的整体性能, 线程池详细信息请参考CLR第27章&lt;/p&gt;
&lt;p&gt;🔔Task.Factory.StartNew方法中有一个&lt;em&gt;TaskCreationOptions&lt;/em&gt;参数重载,如果设置为&lt;strong&gt;LongRunning&lt;/strong&gt;,则会创建一个新线程执行&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;//      此方法会创建一个新线程进行执行
Task.Factory.StartNew(() =&amp;gt; { }, TaskCreationOptions.LongRunning);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;demo4&quot;&gt;4.避免使用Task.Result和Task.Wait()来堵塞线程&lt;/h2&gt;
&lt;p&gt;使用Task.Result和Task.Wait()两个方法进行阻塞异步同步化比直接同步方法阻塞还要&lt;em&gt;MUCH worse(更糟)&lt;/em&gt;,这种方式被称为&lt;strong&gt;Sync over async&lt;/strong&gt; 此方式操作步骤如下&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;1.异步线程启动&lt;/p&gt;
&lt;p&gt;2.调用线程调用Result或者Wait()进行阻塞&lt;/p&gt;
&lt;p&gt;3.异步完成时,将一个延续代码调度到线程池,恢复等待该操作的代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然看起来并没有什么关系,但是其实这里却是使用了两个线程来完成同步操作,这样通常会导致&lt;strong&gt;线程饥饿&lt;/strong&gt;和&lt;strong&gt;死锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🔔线程饥饿(starvation):指等待时间已经影响到进程运行,如果等待时间过长,导致进程使命没有意义时,称之为&lt;em&gt;饿死&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;🔔死锁(deadlock):指两个或两个以上的线程相互争夺资源,导致进程永久堵塞,&lt;/p&gt;
&lt;p&gt;🔔使用Task.Result和Task.Wait()会在winform和ASP.NET中会死锁,因为它们&lt;code&gt;SynchronizationContext&lt;/code&gt;具有对象,两个线程在&lt;code&gt;SynchronizationContext&lt;/code&gt;争夺导致死锁,而&lt;em&gt;ASP.NET Core&lt;/em&gt;则不会产生死锁,因为ASP.NET Core本质是一个控制台应用程序,并没有上下文&lt;/p&gt;
&lt;p&gt;❌下面的例子,虽然都不会产生死锁,但是依然具有很多问题&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;async Task&amp;lt;string&amp;gt; RunAsync()
{
     //  此线程ID输出与UI线程ID不一致
     Debug.WriteLine(&quot;UI线程:&quot;+Thread.CurrentThread.ManagedThreadId);
     return await Task.Run(() =&amp;gt; &quot;Run&quot;);
}
string DoOperationBlocking()
{
     //  这种方法虽然摆脱了死锁的问题,但是也导致了上下文问题,RunAsync不在以UI线程调用
     //  Result和Wait()方法如果出现异常,异常将被包装为AggregateException进行抛出,
     return Task.Run(() =&amp;gt; RunAsync()).Result;
}
}
private async void button1_Click(object sender, EventArgs e)
{
     Debug.WriteLine(&quot;RunAsync:&quot; + Thread.CurrentThread.ManagedThreadId);
     Debug.WriteLine(DoOperationBlocking());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public string DoOperationBlocking2()
{
     //     此方法也是会导致上下文问题,
     //     GetAwaiter()方法对异常不会包装
     return Task.Run(() =&amp;gt; RunAsync()).GetAwaiter().GetResult();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;demo5&quot;&gt;5.建议使用await来代替continueWith任务&lt;/h2&gt;
&lt;p&gt;在async和await,当时可以使用continueWith来延迟执行一些方法,但是continueWith并不会捕捉`&lt;code&gt;SynchronizationContext&lt;/code&gt; `,所以建议使用await代替continueWith&lt;/p&gt;
&lt;p&gt;❌下面例子就是使用continueWith&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private  void button1_Click(object sender, EventArgs e)
{
     Debug.WriteLine(&quot;UI线程:&quot; + Thread.CurrentThread.ManagedThreadId);
     RunAsync().ContinueWith(task =&amp;gt;
    {
       Console.WriteLine(&quot;RunAsync returned:&quot;+task.Result);
       //      因为是使用的continueWith,所以线程ID与UI线程并不一致
       Debug.WriteLine(&quot;ContinueWith:&quot; + Thread.CurrentThread.ManagedThreadId);
   });
}
public async Task&amp;lt;int&amp;gt; RunAsync()
{
     return await Task.FromResult(1 + 1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;☑️应该使用await来代替continueWith&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private async  void button1_Click(object sender, EventArgs e)
{
     Debug.WriteLine(&quot;UI线程:&quot; + Thread.CurrentThread.ManagedThreadId);
     Debug.WriteLine(&quot;RunAsync returned:&quot;+ await RunAsync());
     Debug.WriteLine(&quot;UI线程:&quot; + Thread.CurrentThread.ManagedThreadId);
}
public async Task&amp;lt;int&amp;gt; RunAsync()
{
     return await Task.FromResult(1 + 1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建taskcompletionsource时建议使用taskcreationoptions.runcontinuationsasynchronously属性&quot;&gt;6.创建TaskCompletionSource&lt;/h2&gt;
&lt;p&gt;对于编写类库的人来说&lt;code&gt;TaskCompletionSource&amp;lt;T&amp;gt;&lt;/code&gt;是一个具有非常重要的作用,默认情况下任务延续可能会在调用&lt;strong&gt;try/set(Result/Exception/Cancel)&lt;/strong&gt;的线程上进行运行,这也就是说作为编写类库的人来说必须需要考虑上下文,这通常是非常危险,可能就会导致&lt;em&gt;死锁&lt;/em&gt;' &lt;em&gt;线程池饥饿&lt;/em&gt; *数据结构损坏(如果代码异常运行)&lt;/p&gt;
&lt;p&gt;所以在创建&lt;code&gt;TaskCompletionSourece&amp;lt;T&amp;gt;&lt;/code&gt;时,应该使用&lt;code&gt;TaskCreationOption.RunContinuationAsyncchronously&lt;/code&gt;参数将后续任务交给线程池进行处理&lt;/p&gt;
&lt;p&gt;❌下面例子就没有使用&lt;code&gt;TaskCreationOptions.RunComtinuationsAsynchronously&lt;/code&gt;,&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
     ThreadPool.SetMinThreads(100, 100);
     Console.WriteLine(&quot;Main CurrentManagedThreadId:&quot; + Environment.CurrentManagedThreadId);
     var tcs = new TaskCompletionSource&amp;lt;bool&amp;gt;();
     //  使用TaskContinuationOptions.ExecuteSynchronously来测试延续任务
     ContinueWith(1, tcs.Task);
     //  测试await延续任务
     ContinueAsync(2, tcs.Task);
     Task.Run(() =&amp;gt;
     {
        Console.WriteLine(&quot;Task Run CurrentManagedThreadId:&quot; + Environment.CurrentManagedThreadId );
        tcs.TrySetResult(true);
     });
     Console.ReadLine();
}
static void print(int id) =&amp;gt; Console.WriteLine($&quot;continuation:{id}\tCurrentManagedThread:{Environment.CurrentManagedThreadId}&quot;);
static async Task ContinueAsync(int id, Task task)
{
     await task.ConfigureAwait(false);
     print(id);
}
static Task ContinueWith(int id, Task task)
{
     return task.ContinueWith(
          t =&amp;gt; print(id),
          CancellationToken.None, TaskContinuationOptions.ExecuteSynchronously, TaskScheduler.Default);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;☑️所以应该改为使用&lt;code&gt;TaskCreationOptions.RunComtinuationsAsynchronously&lt;/code&gt;参数进行设置TaskCompletionSoure&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
     ThreadPool.SetMinThreads(100, 100);
     Console.WriteLine(&quot;Main CurrentManagedThreadId:&quot; + Environment.CurrentManagedThreadId);
     var tcs = new TaskCompletionSource&amp;lt;bool&amp;gt;(TaskCreationOptions.RunContinuationsAsynchronously);
     //  使用TaskContinuationOptions.ExecuteSynchronously来测试延续任务
     ContinueWith(1, tcs.Task);
     //  测试await延续任务
     ContinueAsync(2, tcs.Task);
     Task.Run(() =&amp;gt;
     {
        Console.WriteLine(&quot;Task Run CurrentManagedThreadId:&quot; + Environment.CurrentManagedThreadId);
        tcs.TrySetResult(true);
     });
     Console.ReadLine();
}
static void print(int id) =&amp;gt; Console.WriteLine($&quot;continuation:{id}\tCurrentManagedThread:{Environment.CurrentManagedThreadId}&quot;);
static async Task ContinueAsync(int id, Task task)
{
     await task.ConfigureAwait(false);
     print(id);
}
static Task ContinueWith(int id, Task task)
{
     return task.ContinueWith(
          t =&amp;gt; print(id),
          CancellationToken.None, TaskContinuationOptions.ExecuteSynchronously, TaskScheduler.Default);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;🔔&lt;code&gt;TaskCreationOptions.RunContinuationsAsynchronously&lt;/code&gt;属性和&lt;code&gt;TaskContinuationOptions.RunContinuationsAsynchronously&lt;/code&gt;很相似,但请注意它们的使用方式&lt;/p&gt;
&lt;h2 id=&quot;demo7&quot;&gt;7.建议使用CancellationTokenSource(s)进行超时管理时总是释放(dispose)&lt;/h2&gt;
&lt;p&gt;用于进行超时的CancellationTokenSources,如果不释放,则会增加&lt;code&gt;timer queue(计时器队列)&lt;/code&gt;的压力&lt;/p&gt;
&lt;p&gt;❌下面例子因为没有释放,所以在每次请求发出之后,计时器在队列中停留10秒钟&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async Task&amp;lt;Stream&amp;gt; HttpClientAsyncWithCancellationBad()
{
    var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10));

    using (var client = _httpClientFactory.CreateClient())
    {
        var response = await client.GetAsync(&quot;http://backend/api/1&quot;, cts.Token);
        return await response.Content.ReadAsStreamAsync();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;☑️所以应该及时的释放CancellationSoure,使得正确的从队列中删除计时器&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async Task&amp;lt;Stream&amp;gt; HttpClientAsyncWithCancellationGood()
{
     using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10)))
     {
          using (var client = _httpClientFactory.CreateClient())
          {
               var response = await client.GetAsync(&quot;http://backend/api/1&quot;, cts.Token);
               return await response.Content.ReadAsStreamAsync();
          }
     }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;🔔设置延迟时间具有两种方式&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;1.构造器参数&lt;/p&gt;
&lt;p&gt;public CancellationTokenSource(TimeSpan delay);&lt;br/&gt;public CancellationTokenSource(int millisecondsDelay);&lt;/p&gt;
&lt;p&gt;2.调用实例对象CancelAfter()&lt;br/&gt;public void CancelAfter(TimeSpan delay);&lt;br/&gt;public void CancelAfter(int millisecondsDelay);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;demo8&quot;&gt;8.建议将协作式取消对象(CancellationToken)传递给所有使用到的API&lt;/h2&gt;
&lt;p&gt;由于在.NET中取消操作必须显示的传递&lt;code&gt;CancellationToken&lt;/code&gt;,所以如果想取消所有调用的异步函数,那么应该将&lt;code&gt;CancllationToken&lt;/code&gt;传递给此调用链中的所有函数&lt;/p&gt;
&lt;p&gt;❌下面例子在调用ReadAsync时并没有传递&lt;code&gt;CancellationToken&lt;/code&gt;,所以不能有效的取消&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async Task&amp;lt;string&amp;gt; DoAsyncThing(CancellationToken cancellationToken = default)
{
     byte[] buffer = new byte[1024];
     //      使用FileOptions.Asynchronous参数指定异步通信
     using(Stream stream = new FileStream(
          @&quot;d:\资料\Blogs\Task\TaskTest&quot;,
          FileMode.OpenOrCreate,
          FileAccess.ReadWrite,
          FileShare.None,
          1024,
          options:FileOptions.Asynchronous))
     {
          //      由于并没有将cancellationToken传递给ReadAsync,所以无法进行有效的取消
          int read = await stream.ReadAsync(buffer, 0, buffer.Length);
          return Encoding.UTF8.GetString(buffer, 0, read);
     }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;☑️所以应该将&lt;code&gt;CancellationToken&lt;/code&gt;传递给ReadAsync(),以达到有效的取消&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async Task&amp;lt;string&amp;gt; DoAsyncThing(CancellationToken cancellationToken = default)
{
     byte[] buffer = new byte[1024];
     //      使用FileOptions.Asynchronous参数指定异步通信
     using(Stream stream = new FileStream(
          @&quot;d:\资料\Blogs\Task\TaskTest&quot;,
          FileMode.OpenOrCreate,
          FileAccess.ReadWrite,
          FileShare.None,
          1024,
          options:FileOptions.Asynchronous))
     {
          //      由于并没有将cancellationToken传递给ReadAsync,所以无法进行有效的取消
          int read = await stream.ReadAsync(buffer, 0, buffer.Length,cancellationToken);
          return Encoding.UTF8.GetString(buffer, 0, read);
     }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;🔔在使用异步IO时,应该将&lt;strong&gt;options&lt;/strong&gt;参数设置为&lt;strong&gt;FileOptions.Asynchronous&lt;/strong&gt;,否则会产生额外的线程浪费,详细信息请参考CLR中28.12节&lt;/p&gt;
&lt;h2 id=&quot;demo9&quot;&gt;9.建议取消那些不会自动取消的操作(CancellationTokenRegistry,timer)&lt;/h2&gt;
&lt;p&gt;在异步编程时出现了一种模式&lt;strong&gt;cancelling an uncancellable operation&lt;/strong&gt;,这个用于取消像&lt;code&gt;CancellationTokenRegistry&lt;/code&gt;和&lt;code&gt;timer&lt;/code&gt;这样的东西,通常是在被取消或超时时创建另外一个线程进行操作,然后使用Task.WhenAny进行判断是完成还是被取消了&lt;/p&gt;
&lt;h3 id=&quot;使用cancellationtoken&quot;&gt;使用CancellationToken&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;:x: 下面例子使用了Task.delay(-1,token)创建在触发CancellationToken时触发的任务,但是如果CancellationToken不触发,则没有办法释放CancellationTokenRegistry,就有可能会导致内存泄露   &lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static async Task&amp;lt;T&amp;gt; WithCancellation&amp;lt;T&amp;gt;(this Task&amp;lt;T&amp;gt; task, CancellationToken cancellationToken)
{
     //      没有方法释放cancellationToken注册
     var delayTask = Task.Delay(-1, cancellationToken);

     var resultTask = await Task.WhenAny(task, delayTask);
     if (resultTask == delayTask)
     {
          //  取消异步操作
          throw new OperationCanceledException();
     }

     return await task;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;:ballot_box_with_check:所以应该改成下面这样,在任务一完成,就释放CancellationTokenRegistry&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static async Task&amp;lt;T&amp;gt; WithCancellation&amp;lt;T&amp;gt;(this Task&amp;lt;T&amp;gt; task, CancellationToken cancellationToken)
{
     var tcs = new TaskCompletionSource&amp;lt;object&amp;gt;(TaskCreationOptions.RunContinuationsAsynchronously);
     using (cancellationToken.Register(state =&amp;gt;
                                       {
                                            //      这样将在其中一个任务触发时立即释放CancellationTokenRegistry
                                            ((TaskCompletionSource&amp;lt;object&amp;gt;)state).TrySetResult(null);
                                       },
                                       tcs))
     {
          var resultTask = await Task.WhenAny(task, tcs.Task);
          if (resultTask == tcs.Task)
          {
               //  取消异步操作
               throw new OperationCanceledException(cancellationToken);
          }

          return await task;
     }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用超时任务&quot;&gt;使用超时任务&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;:x:下面这个例子即使在操作完成之后,也不会取消定时器,这也就是说最终会在计时器队列中产生大量的计时器,从而浪费性能&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static async Task&amp;lt;T&amp;gt; TimeoutAfter&amp;lt;T&amp;gt;(this Task&amp;lt;T&amp;gt; task, TimeSpan timeout)
{
     var delayTask = Task.Delay(timeout);

     var resultTask = await Task.WhenAny(task, delayTask);
     if (resultTask == delayTask)
     {
          //  取消异步操作
          throw new OperationCanceledException();
     }

     return await task;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;:ballot_box_with_check:应改成下面这样,这样将在任务完成之后,取消计时器的操作&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static async Task&amp;lt;T&amp;gt; TimeoutAfter&amp;lt;T&amp;gt;(this Task&amp;lt;T&amp;gt; task, TimeSpan timeout)
{
     using (var cts = new CancellationTokenSource())
     {
          var delayTask = Task.Delay(timeout, cts.Token);

          var resultTask = await Task.WhenAny(task, delayTask);
          if (resultTask == delayTask)
          {
               //  取消异步操作
               throw new OperationCanceledException();
          }
          else
          {
               //  取消计时器任务
               cts.Cancel();
          }

          return await task;
     }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;demo10&quot;&gt;10.使用StreamWriter(s)或Stream(s)时在Dispose之前建议先调用FlushAsync&lt;/h2&gt;
&lt;p&gt;当使用Stream和StreamWriter进行异步写入时,底层数据也有可能被缓冲,当数据被缓冲时,Stream和StreamWriter将使用同步的方式进行&lt;code&gt;write/flush&lt;/code&gt;,这将会导致线程阻塞,并且有可能导致线程池内线程不足(线程池饥饿)&lt;/p&gt;
&lt;p&gt;❌下面例子由于没有调用&lt;strong&gt;FlushAsync()&lt;/strong&gt;,所以最后是以同步方式进行write/flush的&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async static Task RunAsync()
{
     using (var streamWriter = new StreamWriter(@&quot;C:\资料\Blogs\Task&quot;))
     {
          //      由于没有调用FlushAsync,所以最后是以同步方式进行write/flush的
          await streamWriter.WriteAsync(&quot;Hello World&quot;);
     }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;☑️所以应该改为下面这样,在&lt;strong&gt;Dispose&lt;/strong&gt;之前调用&lt;strong&gt;FlushAsync()&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async static Task RunAsync()
{
     using (var streamWriter = new StreamWriter(@&quot;C:\资料\Blogs\Task&quot;))
     {
          await streamWriter.WriteAsync(&quot;Hello World&quot;);
          //      调用FlushAsync()  使其使用异步write/flush
          await streamWriter.FlushAsync();
     }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;demo11&quot;&gt;11.建议使用 async/await而不是直接返回Task&lt;/h2&gt;
&lt;p&gt;使用async/await 代替直接返回Task具有以上好处&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;异步和同步的异常都被始终被规范为了异步&lt;/li&gt;
&lt;li&gt;代码更容易修改(例如:增加一个&lt;code&gt;using&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;异步的方法诊断起来更加容易(例如:调试,挂起)&lt;/li&gt;
&lt;li&gt;抛出的异常将自动包装在返回的任务之中,而不是抛出实际异常&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;❌下面这个错误的例子是将Task直接返回给了调用者&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public Task&amp;lt;int&amp;gt; RunAsync()
{
     return Task.FromResult(1 + 1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;☑️所以应该使用async/await来代替返回Task&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async Task&amp;lt;int&amp;gt; RunAsync()
{
     return await Task.FromResult(1 + 1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;🔔使用async/await来代替返回Task时,还有性能上的考虑,虽然直接Task会更快,但是最终却改变了异步的行为,失去了异步状态机的一些好处&lt;/p&gt;

&lt;h2 id=&quot;demo12&quot;&gt;1. 使用定时器回调函数&lt;/h2&gt;
&lt;p&gt;❌下面例子使用一个返回值为void的异步,将其传递给Timer进行,因此,如果其中任务抛出异常,则整个进程将退出&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Pinger
{
     private readonly Timer _timer;
     private readonly HttpClient _client;

     public Pinger(HttpClient client)
     {
          _client = new HttpClient();
          _timer = new Timer(Heartbeat, null, 1000, 1000);
     }

     public async void Heartbeat(object state)
     {
          await httpClient.GetAsync(&quot;http://mybackend/api/ping&quot;);
     }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;❌下面例子将阻止计时器回调,这有可能导致线程池中线程耗尽,这也是一个异步差于同步的例子&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Pinger
{
     private readonly Timer _timer;
     private readonly HttpClient _client;

     public Pinger(HttpClient client)
     {
          _client = new HttpClient();
          _timer = new Timer(Heartbeat, null, 1000, 1000);
     }

     public void Heartbeat(object state)
     {
          httpClient.GetAsync(&quot;http://mybackend/api/ping&quot;).GetAwaiter().GetResult();
     }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;☑️下面例子是使用基于的异步的方法,并在定时器回调函数中丢弃该任务,并且如果此方法抛出异常,则也不会关闭进程,而是会触发&lt;code&gt;TaskScheduler.UnobservedTaskException&lt;/code&gt;事件&lt;/p&gt;
&lt;h2 id=&quot;demo13&quot;&gt;2.创建回调函数参数时注意避免 async void&lt;/h2&gt;
&lt;p&gt;假如有&lt;code&gt;BackgroudQueue&lt;/code&gt;类中有一个接收回调函数的&lt;code&gt;FireAndForget&lt;/code&gt;方法,该方法在某个时候执行调用&lt;/p&gt;
&lt;p&gt;❌下面这个错误例子将强制调用者要么阻塞要么使用async void异步方法&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class BackgroundQueue
{
    public static void FireAndForget(Action action) { }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static  async Task Main(string[] args)
{
     var httpClient = new HttpClient();
     //      因为方法类型是Action,所以只能使用async void
     BackgroundQueue.FireAndForget(async () =&amp;gt;
     {
         await httpClient.GetAsync(&quot;http://pinger/api/1&quot;);
     });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;☑️所以应该构建一个回调异步方法的重载&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class BackgroundQueue
{
    public static void FireAndForget(Action action) { }
    public static void FireAndForget(Func&amp;lt;Task&amp;gt; action) { }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用concurrentdictionary.getoradd注意场景&quot;&gt;3.使用ConcurrentDictionary.GetOrAdd注意场景&lt;/h2&gt;
&lt;p&gt;缓存异步结果是一种很常见的做法,ConcurrentDictionary是一个很好的集合,而GetOrAdd也是一个很方便的方法,它用于尝试获取已经存在的项,如果没有则添加项.因为回调是同步的,所以很容易编写&lt;code&gt;Task.Result&lt;/code&gt;的代码,从而生成异步的结果值,但是这样很容易导致线程池饥饿&lt;/p&gt;
&lt;p&gt;❌下面这个例子就有可能导致线程池饥饿,因为当如果没有缓存人员数据时,将阻塞请求线程&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class PersonController : Controller
{
    private AppDbContext _db;
    private static ConcurrentDictionary&amp;lt;int, Person&amp;gt; _cache = new ConcurrentDictionary&amp;lt;int, Person&amp;gt;();

    public PersonController(AppDbContext db)
    {
    _db = db;
    }
    public IActionResult Get(int id)
    {
    //      如果不存在缓存数据,则会进入堵塞状态
    var person = _cache.GetOrAdd(id, (key) =&amp;gt; db.People.FindAsync(key).Result);
    return Ok(person);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;☑️可以改成缓存线程本身,而不是结果,这样将不会导致线程池饥饿&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class PersonController : Controller
{
   private AppDbContext _db;
   private static ConcurrentDictionary&amp;lt;int, Task&amp;lt;Person&amp;gt;&amp;gt; _cache = new ConcurrentDictionary&amp;lt;int, Task&amp;lt;Person&amp;gt;&amp;gt;();
   public PersonController(AppDbContext db)
   {
      _db = db;
   }
   public async Task&amp;lt;IActionResult&amp;gt; Get(int id)
   {
      //        因为缓存的是线程本身,所以没有进行堵塞,也就不会产生线程池饥饿
       var person = await _cache.GetOrAdd(id, (key) =&amp;gt; db.People.FindAsync(key));
       return Ok(person);
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;🔔这种方法,在最后,GetOrAdd()可能并行多次来执行缓存回调,这可能导致启动多次昂贵的计算&lt;/p&gt;
&lt;p&gt;☑️可以使用&lt;code&gt;async lazy&lt;/code&gt;模式来取代多次执行回调问题&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class PersonController : Controller
{
   private AppDbContext _db;
   private static ConcurrentDictionary&amp;lt;int, AsyncLazy&amp;lt;Person&amp;gt;&amp;gt; _cache = new ConcurrentDictionary&amp;lt;int, AsyncLazy&amp;lt;Person&amp;gt;&amp;gt;();
   
   public PersonController(AppDbContext db)
   {
      _db = db;
   }
   
   public async Task&amp;lt;IActionResult&amp;gt; Get(int id)
   {
      //        使用Lazy进行了延迟加载(使用时调用),解决了多次执行回调问题        
       var person = await _cache.GetOrAdd(id, (key) =&amp;gt; new AsyncLazy&amp;lt;Person&amp;gt;(() =&amp;gt; db.People.FindAsync(key)));
       return Ok(person);
   }
   
   private class AsyncLazy&amp;lt;T&amp;gt; : Lazy&amp;lt;Task&amp;lt;T&amp;gt;&amp;gt;
   {
      public AsyncLazy(Func&amp;lt;Task&amp;lt;T&amp;gt;&amp;gt; valueFactory) : base(valueFactory)
      {
      }
   }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;构造函数对于异步的问题&quot;&gt;4.构造函数对于异步的问题&lt;/h2&gt;
&lt;p&gt;构造函数是同步,下面看看在构造函数中处理异步情况&lt;/p&gt;
&lt;p&gt;下面是使用客户端API的例子,当然,在使用API之前需要异步进行连接&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface IRemoteConnectionFactory
{
   Task&amp;lt;IRemoteConnection&amp;gt; ConnectAsync();
}

public interface IRemoteConnection
{
    Task PublishAsync(string channel, string message);
    Task DisposeAsync();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;❌下面例子使用&lt;strong&gt;Task.Result&lt;/strong&gt;在构造函数中进行连接,这有可能导致线程池饥饿和死锁现象&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Service : IService
{
    private readonly IRemoteConnection _connection;

    public Service(IRemoteConnectionFactory connectionFactory)
    {
        _connection = connectionFactory.ConnectAsync().Result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;☑️正确的方式应该使用静态工厂模式进行异步连接&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Service : IService
{
    private readonly IRemoteConnection _connection;

    private Service(IRemoteConnection connection)
    {
        _connection = connection;
    }

    public static async Task&amp;lt;Service&amp;gt; CreateAsync(IRemoteConnectionFactory connectionFactory)
    {
        return new Service(await connectionFactory.ConnectAsync());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原文地址:&lt;a href=&quot;https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/93e39b8f48169cce4803615519ef87bb2a969c8e/AsyncGuidance.md#prefer-taskfromresult-over-taskrun-for-pre-computed-or-trivially-computed-data&quot; class=&quot;uri&quot;&gt;https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/93e39b8f48169cce4803615519ef87bb2a969c8e/AsyncGuidance.md#prefer-taskfromresult-over-taskrun-for-pre-computed-or-trivially-computed-data&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 04 Nov 2018 05:34:00 +0000</pubDate>
<dc:creator>莫问今朝乄</dc:creator>
<og:description>异步操作时应注意的要点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yan7/p/9903700.html</dc:identifier>
</item>
<item>
<title>设计模式与设计原则简介（一） - noteless</title>
<link>http://www.cnblogs.com/noteless/p/9897464.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/9897464.html</guid>
<description>&lt;p&gt;&lt;span&gt;我们知道对于很多数学问题，经常会有多种不同的解法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且这其中可能会有一种比较通用简便高效的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们在遇到类似的问题或者同一性质的问题时，也往往采用这一种通用的解法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将话题转移到程序设计中来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;对于软件开发人员， 在软件开发过程中，&lt;/span&gt; &lt;span&gt;&lt;strong&gt;面临的一般问题的解决方案就是设计模式&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;（准确的说是OOP中）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当然，如同数学的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;解题思路&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;一样，设计模式并&lt;/span&gt;&lt;span&gt;&lt;strong&gt;不是公式一样的存在&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;设计模式（Design pattern）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;代表了最佳的实践&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;宝贵经验&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;是解决问题的思路&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;总之，设计模式是一种&lt;/span&gt;&lt;span&gt;&lt;strong&gt;思想&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;思想&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;思想&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;起源&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;随着面向对象编程语言的发展，以及软件开发规模的不断扩大&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;编写良好的OOP程序变得困难，而编写可复用的OOP程序则更是困难&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;设计模式 - 可复用面向对象软件的基础&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;） 的书&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该书首次提到了软件开发中设计模式的概念。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;四位作者合称&lt;/span&gt; &lt;span&gt;&lt;strong&gt;GOF&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;（四人帮，全拼 Gang of Four）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就是设计模式四个字的起源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然，即使在这本书出版之前，肯定也已经有很多有经验的OOP程序员已经在使用自己的经验(设计模式)了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是这本书将OOP的设计经验作为设计模式记录下来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使我们能够更加简单方便的复用成功的设计经验和体系结构&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;设计原则&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&quot;随着面向对象编程语言的发展，以及软件开发规模的不断扩大&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;编写良好的OOP程序变得困难，而编写可复用的OOP程序则更是困难&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设计模式的起源， 正是需要设计模式的根本原因&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;借助于设计模式，可以更好地实现代码的复用，增加可维护性&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;怎么才能更好地实现代码复用呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面向对象有几个原则：&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;根本原则&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5.5&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;开闭原则&lt;/strong&gt;&lt;/span&gt;（Open Closed Principle，OCP）  一个软件实体应当对扩展开放，对修改关闭 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即&lt;span&gt;&lt;strong&gt;软件实体应尽量在不修改原有代码的情况下进行扩展&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不修改已有代码的基础上扩展系统的功能的形式，就是符合开闭原则的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;开闭原则的关键是抽象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如，一个方法中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if(){&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;//...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}else if(){&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;//...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果新增加一个逻辑功能点，则需要增加新的else  或者 else if ，势必修改了已有代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而如果面向抽象的接口或者抽象类进行编程，扩展增加新的功能，只需要传递新的子类即可，原有的代码功能不会有任何的修改&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;再比如&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际项目开发的时候，我们会把一些配置写入到配置文件中，而不是&quot;硬编码&quot;到代码中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修改参数设置的时候，源代码无需更改，这也是符合开闭原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开闭原则作为根本原则，并不限定某种具体场景，只要是符合了这一含义，就是符合开闭原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总之，开闭原则就是&lt;span&gt;&lt;strong&gt;别因为新增功能扩展改(老)代码&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h4&gt;&lt;span&gt;&lt;strong&gt;六大原则&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;开闭原则是根本纲领，它是面向对象设计的终极目标&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;除了根本原则另外还有六大原则 ， 则可以看做是开闭原则的实现方法&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;单一职责原则 （Single Responsiblity Principle SRP）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;里氏替换原则（Liskov Substitution Principle，LSP）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;依赖倒转原则（Dependency Inversion Principle，DIP）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;接口隔离原则（Interface Segregation Principle，ISP）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;合成/聚合复用原则（Composite/Aggregate Reuse Principle，C/ARP）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;迪米特法则（Principle of Least Knowledge，PLK，也叫最小知识原则）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;单一职责原则 （Single Responsiblity Principle SRP）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单一职责的原则很简单，就是一个实体(一个类或者一个功能模块)不要承担过多的责任&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;承担了过多的责任也就意味着多个功能的耦合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;堆积木时， 到底是一块积木比较容易利用， 还是多块积木拼接起来的&quot;一大块&quot; 更容易利用? 结果显而易见 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且，承担了过多的责任，也就是可能会因为多个原因修改这段代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随之而来的是不稳定性以及维护成本的增加，也就是将会有多个原因引起他变化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单一职责原则的根本在于&lt;span&gt;&lt;strong&gt;控制类的粒度大小&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;里氏替换原则（Liskov Substitution Principle，LSP）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;里氏替换原则是以提出者 Barbara Liskov  的名字命名的 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么类型 T2 是类型 T1 的子类型&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;简单说就是 如果 一个程序P(T1) ，如果将输入T1 替换为T2 ，而且 P(T1) = P(T2)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么T2 是T1的子类型&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;再简单的概述就是:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;所有引用基类的地方必须能透明地使用其子类的对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;透明也就意味着不感知，不受任何影响&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;听起来好像很自然的就可以做到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假如子类覆盖了父类的方法呢?假如子类覆盖了父类的方法并且改变了父类方法的原有功能逻辑呢?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如，原来传递来两个参数进行加法运算，子类覆盖后，进行减法运算，会发生什么?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;里氏代换原则的根本，&lt;span&gt;&lt;strong&gt;在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;想要透明的使用子类，满足里氏替换原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要注意应该尽可能的将父类设计为抽象类或者接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让子类继承父类或实现父接口，并实现在父类中声明的方法，这样可以做到满足开闭原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法，也就是父类定义，子类实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且，子类不应该破坏父类的契约，也就是不能更改原有的方法的逻辑含义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;里氏替换是继承复用的基石，只有当子类可以替换父类，且软件单位的功能不受到影响时&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;父类才能真正被复用，而子类也能够在基类的基础上增加新的行为&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;里氏代换原则是对开闭原则的补充。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;依赖倒转原则(Dependency Inversion  Principle， DIP)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;抽象不应&lt;span&gt;该依赖于细&lt;/span&gt;节，细节应当依赖于抽象; 换言之，要&lt;span&gt;&lt;strong&gt;针对接口编程，而不是针对实现编程&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;也就是&lt;span&gt;&lt;strong&gt;使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不是使用具体的类&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在需要时，将具体类的对象通过依赖注入(DependencyInjection， DI)的方式注入到其他对象中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在引入抽象层后，程序中尽量使用抽象层进行编程， 系统将具有很好的灵活性 并且将具体类写在配置文件中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而无须修改原有系统的源代码 ， 扩展系统的功能无需修改原来的代码，满足开闭原则的要求 &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;接口隔离原则（Interface Segregation Principle，ISP）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接口隔离根本在于不要强迫客户端程序依赖他们不需要使用的方法&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;合成/聚合复用原则（Composite/Aggregate Reuse Principle，C/ARP）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;复用一个类有两种常用形式，继承和组合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;尽量使用对象组合&lt;/strong&gt;&lt;/span&gt;，而不是继承来达到复用的目的，因为继承子类可以覆盖父类的方法，将细节暴露给子类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且会建立强耦合关系，是一种静态关系，不能再运行时更改等等弊端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;个人建议，对于继承的态度是不滥用，不弃用，带着脑子用！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;迪米特法则（Principle of Least Knowledge，PLK，也叫最小知识原则）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个软件实体应当尽可能少地与其他实体发生相互作用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是一个对象应当对其他对象有尽可能少的了解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再设计系统时，应该&lt;span&gt;&lt;strong&gt;尽可能的减少对象之间的交互&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有一个形象的说法&quot;不要和“陌生人”说话、只与你的直接朋友通信&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面这些一般被认为是朋友&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;(1) 当前对象本身(this)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2) 以参数形式传入到当前对象方法中的对象；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(3) 当前对象的成员对象；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(5) 当前对象所创建的对象&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其实也仍旧是&quot;不要和其他对象有过多的联系&quot;，只在必要的时候与外界进行联系&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&quot;不要和“陌生人”说话、只与你的直接朋友通信&quot; 就能够最大程度的降低耦合性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;类之间的耦合度越低，就越有利于复用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果两个对象之间不是必须要直接通信，那么这两个对象就可以不发生任何直接的相互作用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;而是可以通过第三者转发这个调用，通过引入第三者将耦合度降低&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;设计原则总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;span&gt;开闭原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;软件实体应该对扩展开放，对修改关闭。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;开闭原则是设计原则的核心原则&lt;/strong&gt;&lt;/span&gt;，其他的设计原则都是开闭原则表现和补充。实现开闭原则的方法就是抽象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单一职责原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一个类应该只承担一种责任。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;里氏替换原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;所有引用基类的地方必须能透明地使用其子类的对象。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;依赖倒置原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;面向抽象编程，不要面向具体编程。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接口隔离原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用专门的接口，而不是大而全统一的接口，不要强迫客户端程序依赖不需要的方法。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;聚合/组合复用原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果可以，应该使用组合而不是继承来达到代码复用的目的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;迪米特法则：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;软件实体之间应该做到最少的交互。不要和陌生人说话。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;设计原则要求&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;设计原则是指导思想，将规则落实到具体的类/接口的设计、功能逻辑的划分上，可以转化成以下要求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所有的要求都有一个前提：&lt;span&gt;&lt;strong&gt;如果可以，应该优先考虑，尽可能的&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;面向抽象（抽象类、接口）编程，而不是面向实现编程&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;接口和类的功能要尽可能的单一，避免大而全的类和接口&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;优先使用组合，而不是继承&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;子类应该尽可能的与父类保持一致，不要重写父类原有逻辑&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果类之间没必要直接交互，可以通过“中介”，而不是直接交互，降低耦合性&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;实现和细节可以通过DI的方式，最大程度减少“硬编码”&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果没有什么明显弊端，类应该被设计成不变的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;降低其他类对自身的访问权限，不要暴露内部属性成员，如果需要提供相应的访问器(属性) &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;设计模式与设计原则&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;设计原则是软件开发过程中，前人以“高内聚，低耦合” “提高复用性”“提高可维护性”为根本目标&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在实践中总结出来的经验，进而演化出来的具体的行为准则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;就好似要做“好”一件事情，那么“好”的标准是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按照经验总结归纳出来的一些“好”的标准，就是程序设计中的设计原则&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;设计原则是站在不同的维度与角度思考问题的， 他们的根本目的是相同的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;本质都是为了设计一个“易维护、可复用、高内聚低耦合”的程序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如单一职责原则与接口隔离原则，本质都是要职责专一&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类提供单一的功能的实现，接口不要有大而全的功能约定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;职责专一就能降低耦合，就更有可能被复用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用组合而不是继承可以避免子类对父类的修改这种情况也就符合了里氏替换原则，也就符合了开闭原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;依赖倒置原则要求面向抽象进行编程而不是面向具体细节，而且依赖注入DI的思想也是如日中天Spring的根本&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;“易维护、可复用、高内聚低耦合”是目标&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;设计原则是为了达到目标的具体规则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;而设计模式则是符合设计规则的具体的类/接口的设计解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是设计原则的具体化形式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更准确的说，&lt;span&gt;&lt;strong&gt;一个设计良好的程序应该遵循的是设计原则，而并非一定是某个设计模式&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所有的原则都是指导方针，而不是硬性规则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是在很多场景下一种优秀的解决方案，而并不是一成不变的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在实际的项目中，你既不能完全放弃使用继承，也可能让一个类完全不同“陌生人”讲话&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也不可能子类完全不重写父类的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面向抽象进行编程，你也不可能让项目中所有的类都有抽象对应，这也是不可能的，也不能是被允许的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设计模式设计原则是经验之谈，当然是非常宝贵的经验，也是经过实践检验过的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是最大的忌讳就是生搬硬套，矫枉过正，那将是最失败的设计模式的应用方式&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;设计模式和面向对象的设计原则是解决问题的一般思路&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;而不是像交规一样，必须遵守，严格执行&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;不遵守设计原则与设计模式也不会编译失败&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是希望能够尽最大可能的遵守， 当然，还&lt;span&gt;&lt;strong&gt;需要因地制宜而不能生搬硬套&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或许，你从来不遵守原则，也不使用设计模式，你的代码可能看起来仍旧好好地&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你的代码出问题的概率&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;却会比使用了设计模式遵循了设计原则的代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要大得多&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;设计模式和设计原则正是为了能够更加简单便利的复用代码，尽可能的减少问题的出现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就好像一条浅浅的小河，可能有无数种趟过去方案&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，那条走的人最多的，可能它并不是最好的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是他肯定是比较合适的一条途径，不会出现碎玻璃，沙坑等陷阱.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到底是站在巨人的肩膀上还是一定要自己摸着石头过河?&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;简单说来就是：我们知道软件的目标“正确、健壮、灵活、可重用、高效....”等等，总之都是往“优秀”“好”的方向&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后发现了好的软件的一些特性，所以作为了设计原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是还是过于抽象，于是针对于不同的场景，按照设计原则，整理出来一套好的解决方法，这就是设计模式。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;设计模式分类&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;关于设计模式与设计原则，设计模式是设计原则的具体化形式，是针对于某些特定场景的具体化解决方案&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体到类/接口的设计组织逻辑&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然是原则的具体化形式，那么必然，按照原则的合理组合运用以及问题的场景，其实可以延伸出来更多的设计模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用面向对象软件的基础）中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;有23种设计模式，按照特点可以将其分为三大类型：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;创建型&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;&lt;strong&gt;结构型&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;&lt;strong&gt;行为型&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;创建型模式是用来创建对象的模式，抽象了实例的创建过程，封装了创建逻辑&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;将系统所使用的具体类的信息封装起来&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;隐藏了类的实例是如何被创建和组织的&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;结构型模式讨论的是类和对象的结构，继承和组合结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;采用继承机制来组合接口或实现（类结构型模式），或者通过组合一些对象实现新的功能（对象结构型模式）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结构中的各个不同角色组织在一起以提供更强大的、逻辑清晰的功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结构性模式的类层次结构的组织上有很大的相似性，但是逻辑的侧重功能点是不同的&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;行为型设计模式关注的是对象的行为，用来解决对象之间的联系/通信问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是对象之间针对于不同的问题场景，如何进行合理交互&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;创建型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;工厂模式（Factory Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;抽象工厂模式（Abstract Factory Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单例模式（Singleton Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;建造者模式（Builder Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原型模式（Prototype Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;结构型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;适配器模式（Adapter Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;桥接模式（Bridge Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;组合模式（Composite Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;装饰器模式（Decorator Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;外观模式（Facade Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;享元模式（Flyweight Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代理模式（Proxy Pattern）&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;行为型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;责任链模式（Chain of Responsibility Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;命令模式（Command Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释器模式（Interpreter Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;迭代器模式（Iterator Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中介者模式（Mediator Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;备忘录模式（Memento Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;观察者模式（Observer Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;状态模式（State Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;策略模式（Strategy Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模板模式（Template Pattern）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;访问者模式（Visitor Pattern）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;设计模式之间并不是孤立的，他们也会相互使用，下图为《设计模式 - 可复用面向对象软件的基础》一书中的描述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;各个模式之间的区别和联系是一个“悟”的过程，不要试图对下下图进行任何记忆&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181102173120469-366346085.png&quot;&gt;&lt;img title=&quot;image_5bdc195e_2288&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181102173120862-1391348765.png&quot; alt=&quot;image_5bdc195e_2288&quot; width=&quot;1094&quot; height=&quot;1278&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外还有范围准则的概念，指定模式主要是用于类还是用于对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，编译时刻便已经确定下来了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对象模式处理对象之间的关系，这些关系在运行时是可以变化的，更具有动态性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实如果较真，很多的模式都有涉及到继承/实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以说设计模式中常说的“类模式”只是指那些集中于处理类间关系的模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大部分模式都属于对象模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如对于创建型来说分为 类创建型模式和对象创建型模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;概念只是为了更好的描述问题,类模式和对象模式的概念也来自《设计模式 - 可复用面向对象软件的基础》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本人认为对于设计模式一般的学习与理解，这个概念无所谓&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;设计模式是设计原则在解决具体问题时实践中的运用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以根本是要理解设计原则的含义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随着技术发展，会出现更多的不同的问题场景，基于设计原则，可能拓展出来更多的设计模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事实上到目前为止，也不仅仅是23种&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以说&lt;span&gt;&lt;strong&gt;设计模式的根本是设计原则，而设计原则又是为了达到实现一个“优秀”软件的行为准则。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在你还不能灵活的运用设计原则时，设计模式则是你的垫脚石，让你在具体的问题面前能够写出更好地代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设计模式是理论层次的研究学习，自然是枯燥的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且很难能够一开始就高屋建瓴的自顶而下的深入理解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也很难彻底领悟设计原则本身&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，从一个一个模式的学习中慢慢品味设计原则的精髓&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;类、接口之间的层级结构是可以变换的，设计模式的根本是设计原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以说在学习中要领悟设计模式的根本思想使用场景&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在实践中，不要生搬硬套的应用模式，也无需同设计模式中的类、接口设计层级结构一模一样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可能你应用了某个模式，但是可能又根据实际业务有一些变动或调整&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有人说，你这不是设计模式，那又如何？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只要能够满足需求符合设计原则，往“可复用/易维护/高内聚/低耦合”的目标前进，就好~&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;设计模式将“只可意会，不可言传”转变为“不只意会，还可以言传～”&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Sun, 04 Nov 2018 04:57:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>设计模式的本质是为了遵循设计原则，设计模式是设计原则的具体化表现形式，本文对六大设计原则进行了简单介绍，开闭原则是根本，单一职责，里氏替换，接口隔离，依赖倒置，组合聚合法则以及迪米特法则，对设计模式进</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/9897464.html</dc:identifier>
</item>
<item>
<title>Command模式（命令设计模式） - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/9903443.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/9903443.html</guid>
<description>&lt;h4 id=&quot;command&quot;&gt;Command？？&lt;/h4&gt;
&lt;p&gt;把方法的调用用一个类的实例来承载，要管理工作的历史记录，创建这些方法执行的命令的集合，只需管理这些实例的集合即可，而且还可以随时再次执行过去的命令，或是将多个过去的命令整合为一个新命令并执行。称之为Command设计模式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;那里合适使用：&lt;br/&gt;Command有时也被称为事件（event）。它与“事件驱动编程”中的“事件”是一样的意思。当发生点击鼠标、按下键盘按键等事件时，我们可以先将这些事件作成实例，然后按照发生顺序放入队列中。接着，再依次去处理它们。在GUI（graphical user interface）编程中，经常需要与“事件”打交道。即为在有多个命令，并且这些命令有一定的逻辑顺序，且可能需要保存的这些命令的数据，那么可以使用Command设计模式。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;理清职责&quot;&gt;理清职责&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201811/1160484-20181104114902794-416406578.png&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;实现简单的画图板：&lt;br/&gt;|包=======名字======说明&lt;br/&gt;|command |command表示“命令”的接口&lt;br/&gt;|command |Macrocommand |表示“由多条命令整合成的命令”的类&lt;br/&gt;|drawer |Drawcommand |表示“绘制一个点的命令”的类&lt;br/&gt;|drawer |Drawable|表示“绘制对象”的接口&lt;br/&gt;|drawer |Drawcanvas实现“绘制对象”的类&lt;br/&gt;|无名|MainT测试程序行为的类&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;扩展命令：&lt;br/&gt;只需要实现command，并且关联操作的属性类即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
ColorCommand implements Command {
private xxxAction xxxx；
private XxxArgs  xxxx;

xxxxAction....

}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;相关设计模式&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;◆Composite模式（第11章）有时会使用Composite模式实现宏命令（macrocommand）。&lt;/li&gt;
&lt;li&gt;◆Memento模式（第18章）有时会使用Memento模式来保存Command角色的历史记录。&lt;/li&gt;
&lt;li&gt;◆Protype模式（第6章）有时会使用Protype模式复制发生的事件（生成的命令）。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;uml&quot;&gt;UML&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201811/1160484-20181104114912035-543150432.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;时序图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201811/1160484-20181104114916222-2111725260.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;code&quot;&gt;Code&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Comamnd 包&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
public interface Command {

    void execute();
}

public class MacroCommand implements Command {

    //  命令集合 便于执行UNdo操作
    private Stack commands=new Stack();


    // 执行stack中所有命令
    @Override
    public void execute() {
        Iterator it = commands.iterator();
        while (it.hasNext()){
            Command o = ((Command) it.next());
            o.execute();
        }
    }

    public void append(Command command){
        if (command!=null){
            commands.add(command);
        }
    }
    // 移除末尾命令
    public void undo(){
        if(!commands.empty()){
            commands.pop();
        }
    }
    // 移除所有命令
    public void clear(){
        commands.clear();
    }
}




&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Drawer 包&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
public interface Drawable {

    void draw(int x,int y);

    void setColor(Color color);
}

public class ColorCommand implements Command {

    private Drawable drawable;

    private Color color;

    public ColorCommand(Drawable drawable, Color color) {
        this.drawable = drawable;
        this.color = color;
    }

    @Override
    public void execute() {
        drawable.setColor(color);
    }
}

public class DrawCommand implements Command {

    // 绘制对象
    private Drawable drawable;

    // 绘制位置
    private Point point;

    public DrawCommand(Drawable drawable, Point point) {
        this.drawable = drawable;
        this.point = point;
    }

    @Override
    public void execute() {
        drawable.draw(point.x,point.y);
    }
}

public class DrawCanvas extends Canvas implements Drawable {


     //  defulat 颜色
    private  Color color=Color.red;

    private int radius=6;

    private MacroCommand history;
    private Graphics2D graphics;

    public DrawCanvas(int width,int height,MacroCommand history) {
            setSize(width,height);
            setBackground(Color.white);
            this.history=history;
    }

    // 重新绘制
    @Override
    public void paint(Graphics graphics){
            history.execute();
    }

    /**
     *  这里的实现的画点轨迹依据本身物理操作的手势的速度定型的，
     *  即为：手快 画点 手慢 画线
     * @param x
     * @param y
     */
    @Override
    public void draw(int x, int y) {
        graphics = (Graphics2D) getGraphics();
        graphics.fillOval(x-radius,y-radius,radius*2,radius*2);
        //graphics.drawOval(x-radius,y-radius,radius*2,radius*2);
    }

    @Override
    public void setColor(Color color) {
        graphics = (Graphics2D) getGraphics();
        graphics.setColor(color);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class MainT extends JFrame implements ActionListener, MouseMotionListener, WindowListener {

    private MacroCommand history=new MacroCommand();

    private DrawCanvas canvas=new DrawCanvas(500,500,history);

    private JButton clearbtn=new JButton(&quot;clear&quot;);
    private JButton undobtn=new JButton(&quot;撤销&quot;);

    public MainT(String title) {
        super(title);
        setLocationRelativeTo(getComponentAt(-500,-500));

        this.addWindowListener(this);
        canvas.addMouseMotionListener(this);
        clearbtn.addActionListener(this);
        undobtn.addActionListener(this);

        Box btnbox=new Box(BoxLayout.X_AXIS);
        btnbox.add(clearbtn);
        btnbox.add(undobtn);

        Box mainbox=new Box(BoxLayout.Y_AXIS);
        mainbox.add(canvas);
        mainbox.add(btnbox);

        getContentPane().add(mainbox);

        pack();
        show();
    }

    public static void main(String[] args) {
            new MainT(&quot;mspaint&quot;);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
            if(e.getSource()==clearbtn){
                    history.clear();
                    canvas.repaint();
            }else if(e.getSource()==undobtn){
                    history.undo();
                    canvas.repaint();
            }
    }

    @Override
    public void mouseDragged(MouseEvent e) {
        /**
         * DrawCommand实际命令的承载者 原来的历史得以在类中进行保存;
         * 如果构建新的命令xxxCommand的实现者，那么在原始记录中把新版的命令得以getXXx方法拿到，
         * 在进行的新的保存的，那么原始数据就可以在新的canvans中得以呈现。
         * （实际上canvas可以作为一个单例，在app中存在）
         */
        DrawCommand command = new DrawCommand(canvas, e.getPoint());
        ColorCommand colorCommand = new ColorCommand(canvas, Color.blue);

        history.append(colorCommand);
        history.append(command);

        colorCommand.execute();
        command.execute();
    }

    @Override
    public void mouseMoved(MouseEvent e) {

    }

    @Override
    public void windowOpened(WindowEvent e) {

    }

    @Override
    public void windowClosing(WindowEvent e) {
        System.exit(0);
    }

    @Override
    public void windowClosed(WindowEvent e) {

    }

    @Override
    public void windowIconified(WindowEvent e) {

    }

    @Override
    public void windowDeiconified(WindowEvent e) {

    }

    @Override
    public void windowActivated(WindowEvent e) {

    }

    @Override
    public void windowDeactivated(WindowEvent e) {

    }
}



&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 04 Nov 2018 03:49:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<og:description>Command？？ 把方法的调用用一个类的实例来承载，要管理工作的历史记录，创建这些方法执行的命令的集合，只需管理这些实例的集合即可，而且还可以随时再次执行过去的命令，或是将多个过去的命令整合为一个新</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgwblog/p/9903443.html</dc:identifier>
</item>
<item>
<title>Supervised learning demo - jin_hao_chen</title>
<link>http://www.cnblogs.com/megachen/p/9903433.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/megachen/p/9903433.html</guid>
<description>&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt;&lt;meta name=&quot;referrer&quot; content=&quot;origin&quot;/&gt;&lt;title&gt;Supervised learning demo - jin_hao_chen - 博客园&lt;/title&gt;&lt;meta property=&quot;og:description&quot; content=&quot;监督学习案例 规范 + 假设函数: 使用h(hypothesis, 假设)表示 + 输入(input value): x + 输出(output value): y + 参数(Parameters):&quot;/&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/bundles/blog-common.css?v=-duj5vpGTntb85GJoM3iRI972XwWcI-j8zmqDzyfu2w1&quot;/&gt;&lt;link id=&quot;MainCss&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/CodingLife/bundle-CodingLife.css?v=g4Oce5UBaUn_FUwadcT09ICEg5NkULQGtUpNhTtrI8U1&quot;/&gt;&lt;link id=&quot;mobile-style&quot; media=&quot;only screen and (max-width: 767px)&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/CodingLife/bundle-CodingLife-mobile.css?v=Xay8b9tTSw814nBzbOgvS6rrbcxrobMhvHJHdZAO9vI1&quot;/&gt;&lt;link title=&quot;RSS&quot; type=&quot;application/rss+xml&quot; rel=&quot;alternate&quot; href=&quot;https://www.cnblogs.com/megachen/rss&quot;/&gt;&lt;link title=&quot;RSD&quot; type=&quot;application/rsd+xml&quot; rel=&quot;EditURI&quot; href=&quot;https://www.cnblogs.com/megachen/rsd.xml&quot;/&gt;&lt;link type=&quot;application/wlwmanifest+xml&quot; rel=&quot;wlwmanifest&quot; href=&quot;https://www.cnblogs.com/megachen/wlwmanifest.xml&quot;/&gt;&lt;/head&gt;&lt;body id=&quot;readabilityBody&quot;&gt;

&lt;div id=&quot;home&quot;&gt;

&lt;div id=&quot;main&quot;&gt;
&lt;div id=&quot;mainContent&quot;&gt;
&lt;div class=&quot;forFlow&quot;&gt;
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div id=&quot;topics&quot;&gt;
&lt;div class=&quot;post&quot;&gt;


&lt;div class=&quot;postBody&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body cnblogs-markdown&quot;&gt;

&lt;h2 id=&quot;规范&quot;&gt;规范&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;假设函数: 使用h(hypothesis, 假设)表示&lt;/li&gt;
&lt;li&gt;输入(input value): x&lt;/li&gt;
&lt;li&gt;输出(output value): y&lt;/li&gt;
&lt;li&gt;参数(Parameters): &lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;房价的size和price的预测&quot;&gt;房价的Size和Price的预测&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;建立一个线性模型: &lt;span class=&quot;math inline&quot;&gt;\(h_\theta(x) = \theta_0 + \theta_1x\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;要让我们fit的model与y差异最小, 称之为最小化(minimize)
&lt;ul&gt;&lt;li&gt;在这个案例中使用&lt;span class=&quot;math display&quot;&gt;\[J(\theta_0, \theta_1) = {1\over2m}\sum_{i = 0}^m(h\theta(x^{(i)}) - y^{(i)})^2\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;上面的就是我们的代价函数(cost function), 因为我们有让得到的和除以了2m, 所以我们的到函数也称之为平均误差函数(squared error function), &lt;strong&gt;&lt;em&gt;注意: cost function的自变量时theta_0和theta_1, 不在是我们熟悉的x了&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math display&quot;&gt;\[{minimize_{\theta_0\theta_1}} J(\theta_0, \theta_1)\]&lt;/span&gt;表示求出一个&lt;span class=&quot;math inline&quot;&gt;\(\theta_0\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\theta_1\)&lt;/span&gt;使得&lt;span class=&quot;math inline&quot;&gt;\(J(\theta_0, \theta_1)\)&lt;/span&gt;的值最小, 我们称之为最小化的过程, 上面的这个表达式就是我们的优化目标(optimization objective), 也就是我们的目标函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对于线性回归模型来说, 它的&lt;span class=&quot;math inline&quot;&gt;\(J(\theta_0, \theta_1)\)&lt;/span&gt;目标函数是一个凸函数(没有局部最优点, 只有一个全局的最优点), 在二维上是抛物线, 在三维上是一个碗状, 对于三维的(J有两个theta参数), 一般使用等高线图来替代三维凸函数&lt;/li&gt;
&lt;li&gt;使用gradient regression梯度降维求出最优解, 梯度降维的公式为&lt;span class=&quot;math inline&quot;&gt;\(\theta_0 := \theta_0 - \alpha \times {\partial\over\partial\theta_0}J(\theta_0, \theta_1)\)&lt;/span&gt;, 对于另一个&lt;span class=&quot;math inline&quot;&gt;\(\theta_1\)&lt;/span&gt;也是一样的, &lt;span class=&quot;math inline&quot;&gt;\(\theta_1 := \theta_1 - \alpha \times {\partial\over\partial\theta_1}J(\theta_0, \theta_1)\)&lt;/span&gt;, 上面的是公式, 在实际更新我们的参数&lt;span class=&quot;math inline&quot;&gt;\(\theta_0, \theta_1\)&lt;/span&gt;的时候, 应该保证&lt;span class=&quot;math inline&quot;&gt;\(\theta_0, \theta_1\)&lt;/span&gt;同步更新, 所以应该这样子&lt;span class=&quot;math display&quot;&gt;\[tmp0 := \theta_0 - \alpha \times {\partial\over\partial\theta_0}J(\theta_0, \theta_1)\]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[tmp1 := \theta_0 - \alpha \times {\partial\over\partial\theta_0}J(\theta_0, \theta_1)\]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[\theta_0 := tmp0\]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[\theta_1 := tmp1\]&lt;/span&gt;, 在最后同步更新&lt;span class=&quot;math inline&quot;&gt;\(\theta_0\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\theta_1\)&lt;/span&gt;的值&lt;/li&gt;
&lt;li&gt;关于梯度下降公式的细节
&lt;ul&gt;&lt;li&gt;公式中, &lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;表示学习率, &lt;span class=&quot;math inline&quot;&gt;\({\partial\over\partial\theta_0}J(\theta_0, \theta_1)\)&lt;/span&gt;表示梯度下降的方向, 所以&lt;span class=&quot;math inline&quot;&gt;\(\alpha \times {\partial\over\partial\theta_0}J(\theta_0, \theta_1)\)&lt;/span&gt;表示&lt;span class=&quot;math inline&quot;&gt;\(\theta_0\)&lt;/span&gt;要更新多少的值, 形象一点就是说, 一个人在一个山顶上, 他步子的大小为&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;, 他希望尽快下山的方向为&lt;span class=&quot;math inline&quot;&gt;\({\partial\over\partial\theta_0}J(\theta_0, \theta_1)\)&lt;/span&gt;, 这样我们就可以更新&lt;span class=&quot;math inline&quot;&gt;\(\theta_0\)&lt;/span&gt;的值了&lt;/li&gt;
&lt;li&gt;虽然我们在公式中规定了&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;学习率, 但是并不代表我们走的每一步就是不变的, 因为导数是在变化的, 为最低点的时候为0, 在其他地方有时别的值&lt;/li&gt;
&lt;li&gt;要应用梯度下降法, 我们需要为&lt;span class=&quot;math inline&quot;&gt;\(\theta_0\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\theta_1\)&lt;/span&gt;进行初始化, 一般来说都初始化为0, 但是也要视情况而定&lt;/li&gt;
&lt;li&gt;什么时候停止梯度下降, 我们可以规定一个阈值, 当我们的&lt;span class=&quot;math inline&quot;&gt;\(\alpha \times {\partial\over\partial\theta_0}J(\theta_0, \theta_1)\)&lt;/span&gt;小于这个阈值的时候停止&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;其他
&lt;ul&gt;&lt;li&gt;对于这个房价的模型, 我们除了使用梯度下降的方法求出我们的目标函数之外还可以使用matrix的方法来求, 这个更加的简单&lt;/li&gt;
&lt;li&gt;我们每求一次&lt;span class=&quot;math inline&quot;&gt;\(J(\theta_0, \theta_1)\)&lt;/span&gt;的值就要遍历一遍所有的数据, 因为the definition of the &lt;span class=&quot;math inline&quot;&gt;\(J(\theta_0, \theta_1)\)&lt;/span&gt; is &lt;span class=&quot;math display&quot;&gt;\[\sum_{i=1}^{m}{1\over2m}{(h(x^{(i)}) - y^{(i)})^2})\]&lt;/span&gt;, 这种方式我们称之为Batch梯度降维&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;



&lt;/div&gt;
&lt;div class=&quot;postDesc&quot;&gt;posted @ &lt;span id=&quot;post-date&quot;&gt;2018-11-04 11:46&lt;/span&gt; &lt;a href=&quot;https://www.cnblogs.com/megachen/&quot;&gt;jin_hao_chen&lt;/a&gt; 阅读(&lt;span id=&quot;post_view_count&quot;&gt;...&lt;/span&gt;) 评论() &lt;a href=&quot;https://i.cnblogs.com/EditPosts.aspx?postid=9903433&quot; rel=&quot;nofollow&quot;&gt;编辑&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/megachen/p/9903433.html#&quot; onclick=&quot;AddToWz(9903433);return false;&quot;&gt;收藏&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;


&lt;/div&gt;
&lt;/body&gt;</description>
<pubDate>Sun, 04 Nov 2018 03:46:00 +0000</pubDate>
<dc:creator>jin_hao_chen</dc:creator>
<og:description>监督学习案例 规范 + 假设函数: 使用h(hypothesis, 假设)表示 + 输入(input value): x + 输出(output value): y + 参数(Parameters):</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/megachen/p/9903433.html</dc:identifier>
</item>
<item>
<title>【Unity Shader】（八） ------ 高级纹理（上） - 爱喝柠檬的二哈</title>
<link>http://www.cnblogs.com/BFXYMY/p/9902596.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BFXYMY/p/9902596.html</guid>
<description>&lt;p&gt;笔者使用的是 Unity 2018.2.0f2 + VS2017，建议读者使用与 Unity 2018 相近的版本，避免一些因为版本不一致而出现的问题。&lt;/p&gt;


&lt;p id=&quot;main-toc&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;关于纹理，之前在 &lt;a id=&quot;post_title_link_9715341&quot; href=&quot;https://www.cnblogs.com/BFXYMY/p/9715341.html&quot;&gt;【Unity Shader】（四） ------ 纹理之法线纹理、单张纹理及遮罩纹理的实现&lt;/a&gt; 已经解释过相关原理，不过那些是属于低维纹理，在高级纹理中，也有许多纹理是我们常见到的或常用的，同时它们能够实现十分精美的效果。受限于篇幅，本文主要介绍立方体纹理及其相关应用，下一篇中将继续介绍其它高级纹理。&lt;/p&gt;


&lt;p&gt;单单看标题，读者可能会不太明白我要说什么，不过说到天空盒，读者应该就懂了。我们来看一下官方对 CubeMap 的定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/01.png&quot; alt=&quot;&quot; width=&quot;1105&quot; height=&quot;171&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以简单理解为：CubeMap 是六个假想面的集合，这六个面对应着一个正方体的 6 个面，每个面表示沿着世界空间下的轴向观察所得的图像。整体代表着环境的反射。 &lt;strong&gt;CubeMap 正常用于捕捉环境反射，而读者熟悉的天空盒子和环境映射也是常常使用这种纹理&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;1.2 对立方体纹理的采样&lt;/h2&gt;
&lt;p&gt;我们先说如何采样，在详细说如何制作 CubeMap ，对立方体纹理采样需要提供一个三维的纹理坐标。这个坐标会表示一个方向（世界空间下），&lt;strong&gt;这个方向矢量从中心出发，向外延伸，然后和 6 个面相交，然后就可以通过交点来采样得到结果&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;1.3 使用立方体纹理的优劣&lt;/h2&gt;
&lt;p&gt;纹理不止一种，立方体纹理常用也是有其理由的，我们可以看到其优劣&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实现起来简单快速（稍后会解释），效果好&lt;/li&gt;
&lt;li&gt;不实时，加入新光源或物体时需重新生成&lt;/li&gt;
&lt;li&gt;不能模拟多次反射&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，在现实中，我们在项目中使用普通的立方体纹理作为天空盒子等操作效果已经足够好了。&lt;/p&gt;

&lt;h2&gt;1.4 立方体纹理的布局&lt;/h2&gt;
&lt;p&gt;虽然名字中带有立方体，但纹理布局并不全然是一个立方体的展开。事实上，Unity 支持着数种布局的立方体纹理，而且大多数情况下，Unity 会自动检测它们。下面列举几种常见的布局&lt;/p&gt;

&lt;p&gt;常见的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/03.png&quot; alt=&quot;&quot; width=&quot;534&quot; height=&quot;390&quot;/&gt;&lt;/p&gt;

&lt;p&gt;圆柱形布局（全景图常用）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/04.png&quot; alt=&quot;&quot; width=&quot;256&quot; height=&quot;128&quot;/&gt;&lt;/p&gt;

&lt;p&gt;球形布局&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/05.png&quot; alt=&quot;&quot; width=&quot;128&quot; height=&quot;128&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;默认情况下，Unity 会查看纹理的宽高比以确定最合适的布局&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;1.5 如何制作立方体纹理&lt;/h2&gt;
&lt;p&gt;制作立方体纹理有三种方法，下面我们逐一介绍&lt;/p&gt;

&lt;h3&gt;1.5.1 CubeMap 特殊布局纹理制作&lt;/h3&gt;
&lt;p&gt;制作立方体纹理，最简单的方法就是在纹理图的 Inspector 面板中设置为 Cube，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/02.png&quot; alt=&quot;&quot; width=&quot;552&quot; height=&quot;312&quot;/&gt; &lt;/p&gt;
&lt;p&gt;这张纹理就变成了立方体纹理了，然后把这张纹理赋给一个材质便可。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/07.png&quot; alt=&quot;&quot; width=&quot;1099&quot; height=&quot;61&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 官方也是推荐使用这种方法，因为这种方法可以&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;压缩纹理数据&lt;/li&gt;
&lt;li&gt;修正边缘，光泽反射卷积（光滑反射）&lt;/li&gt;
&lt;li&gt;支持HDR&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们来欣赏一下HDR制作的天空盒子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/10.png&quot; alt=&quot;&quot; width=&quot;960&quot; height=&quot;508&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;1.5.2 使用 6 张纹理制作&lt;/h3&gt;
&lt;p&gt;使用 6 张独立不同的纹理手动创建立方体纹理也是常见的一种方法。创建一个材质，shader 设置为 Skybox / 6 Sided 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/08.png&quot; alt=&quot;&quot; width=&quot;552&quot; height=&quot;417&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要注意的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每张纹理都是独立的，且&lt;strong&gt;要注意其对应的位置&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Wrap Mode 设置为 Clamp ，防止在边界处出现不匹配的现象&lt;/li&gt;
&lt;li&gt;Exposure 代表天空盒子的亮度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就可以实现以下的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/09.png&quot; alt=&quot;&quot; width=&quot;998&quot; height=&quot;518&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;谨记：每张纹理都必须正确对应其对应的位置&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;1.5.3 脚本生成纹理&lt;/h3&gt;
&lt;p&gt;第三种方法比较特殊，前面两张方法都是使用定义好的贴图，制作出来的立方体纹理也是全局共享的。而第三种方法&lt;strong&gt;不使用准备好的图像，而是依赖于脚本，由物体在不同的位置生成。&lt;/strong&gt;核心方法为 &lt;strong&gt;Camera.RenderToCubeMap&lt;/strong&gt; ，这个方法可以从任意位置观察到的图像存储到 6 张图像中，从而创建当前位置的立方体纹理。我们可以在 Unity 官方脚本手册中找到其解释及用法。&lt;/p&gt;

&lt;p&gt;当然需要注意的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Camera.RenderToCubeMap （&lt;/strong&gt;Cubemap cubemap, int faceMask&lt;strong&gt;）&lt;/strong&gt;是 &lt;strong&gt;“静态”&lt;/strong&gt; 的方法。当场景变化时，立方体纹理不会变化，从效果上看，类似 “烘焙”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RenderToCubemap &lt;/strong&gt;(RenderTexture cubemap, int faceMask) 是 “&lt;strong&gt;动态&lt;/strong&gt;” 的方法，能够实时渲染，但同时也需要注意资源的消耗。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于这种方法实现的立方体纹理，我不打算在这里赘述了，因为本文重点在后文，感兴趣的读者可以自行实现一下。&lt;/p&gt;


&lt;h2&gt;二. 光线反射&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/20.jpg&quot; alt=&quot;&quot; width=&quot;200&quot; height=&quot;133&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.1 何为光线反射&lt;/h2&gt;
&lt;p&gt;反射是光现象中最为常见的一种，且遵循光的反射定律，即光射到一个界面时，其入射光线与反射光线成相同角度。光入射到不同介质的界面上会发生折射，如图&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/22.png&quot; alt=&quot;&quot; width=&quot;170&quot; height=&quot;204&quot;/&gt;&lt;/p&gt;
&lt;p&gt;反射时会出现以下情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;反射线跟入射线和法线在同一平面&lt;/li&gt;
&lt;li&gt;反射线和入射线分居法线两侧，并且与界面法线的夹角（分别叫做入射角和反射角）相等&lt;/li&gt;
&lt;li&gt;反射角等于入射角&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前文介绍了如何制作立方体纹理，现在我们需要用上它来实现一些效果。反射是光现象中最为常见的一种，而使用了反射效果的物体看起来就像在表面镀了一层金属膜一样。要模拟反射效果也是比较简单的，理论上&lt;strong&gt;只要使用入射光线的方向和表面法线方向计算出反射方向，再用反射方向对立方体纹理采样就行。&lt;/strong&gt;现在我们来实现一下&lt;/p&gt;

&lt;h2&gt;2.2 反射的实现&lt;/h2&gt;
&lt;p&gt;I. 创建一个场景，天空盒使用在 1.5.1 或 1.5.2 中制作的立方体纹理；创建一个 Cube 和一个 Material，一个 shader，命名为 Reflection 。编辑 shader&lt;/p&gt;

&lt;p&gt;II. 先定义 Properties 块&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/14.png&quot; alt=&quot;&quot; width=&quot;417&quot; height=&quot;111&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其中 _ReflectAmount 控制整体反射程度，_Cubemap 表示要输入的立方体纹理，用来存储反射结果。&lt;/p&gt;

&lt;p&gt;III. 包含相关的头文件和声明与 Properties 块 相匹配的属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/15.png&quot; alt=&quot;&quot; width=&quot;257&quot; height=&quot;155&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/16.png&quot; alt=&quot;&quot; width=&quot;195&quot; height=&quot;90&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，要注意的是，立方体纹理的类型为 &lt;strong&gt;samplerCUBE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;IV. 定义输入输出结构体&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/17.png&quot; alt=&quot;&quot; width=&quot;312&quot; height=&quot;280&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在输出结构体中多定义了一个反射方向，所以 SHADOW_COORDS 中的插值寄存器变为 4&lt;/p&gt;

&lt;p&gt;V. 定义顶点着色器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/18.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;顶点着色器里面的操作我们之前已经说过很多次了，这里主要是多了一个计算反射方向的步骤，我们使用 reflect 函数，有关 reflect 函数我在  &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl06_DayList_TitleUrl_2&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/BFXYMY/p/9683608.html&quot;&gt;【Unity Shader】（三） ------ 光照模型原理及漫反射和高光反射的实现&lt;/a&gt; 中已经介绍过了，读者可以翻看一下&lt;/p&gt;

&lt;p&gt;VI. 定义片元着色器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/19.png&quot; alt=&quot;&quot; width=&quot;688&quot; height=&quot;321&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 场景中只有平行光，光照计算比较简单，这里不再赘述。而对立方体纹理采样，我们则是用了  &lt;strong&gt;texCUBE 函数，&lt;/strong&gt;我们可以在MSDN上找到它的定义&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/21.png&quot; alt=&quot;&quot; width=&quot;946&quot; height=&quot;757&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在使用该函数时，我们也&lt;strong&gt;没有对  i.worldReflect 进行归一化，是因为这里的参数仅仅是作为一个方向变量（笔者测试过归一化的情况，结果一样）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将所有计算结果混合得到最终颜色返回，再加上一个  &lt;strong&gt;FallBack &quot;Reflective/VertexLit&quot; &lt;/strong&gt; 完成。&lt;/p&gt;

&lt;p&gt;VII. 保存，回到 Unity 查看效果，以下是不同 _ReflectAmount 的反射效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/11.gif&quot; alt=&quot;&quot; width=&quot;480&quot; height=&quot;343&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  很抱歉的是 git 图录制的清晰度不够好，以下两图是 _ReflectAmount 为 1 时的效果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/12.png&quot; alt=&quot;&quot; width=&quot;469&quot; height=&quot;305&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/13.png&quot; alt=&quot;&quot; width=&quot;383&quot; height=&quot;289&quot;/&gt;&lt;/p&gt;

&lt;p&gt;完整代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
 1 Shader &quot;Unity/01-Reflection&quot; {
 2     Properties {
 3         _Color (&quot;Color Tint&quot;, Color) = (1,1,1,1)
 4         _ReflectColor(&quot;Reflection Color&quot;,Color) = (1,1,1,1)
 5         _ReflectAmount(&quot;Reflect Amount&quot;,Range(0,1)) = 1
 6         _Cubemap(&quot;Reflection Cubemap&quot;,Cube) = &quot;_Skybox&quot;{}
 7     }
 8     SubShader 
 9     {
10         
11         Pass
12         {
13             Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; }
14 
15             CGPROGRAM
16             #pragma multi_compile_fwdbase    
17             #pragma vertex vert    
18             #pragma fragment frag
19             #include &quot;Lighting.cginc&quot;
20             #include &quot;AutoLight.cginc&quot;
21     
22             fixed4 _Color;
23             fixed4 _ReflectColor;
24             float _ReflectAmount;
25             samplerCUBE _Cubemap;
26 
27             struct a2v
28             {
29                 float4 vertex : POSITION;
30                 float3 normal : NORMAL;
31             };
32 
33             struct v2f
34             {
35                 float4 pos : SV_POSITION;
36                 float3 worldnormal : TEXCOORD0;
37                 float3 worldpos : TEXCOORD1;
38                 float3 worldViewDir : TEXCOORD2;
39                 float3 worldReflect : TEXCOORD3;
40                 SHADOW_COORDS(4)
41             };
42 
43             v2f vert(a2v v)
44             {
45                 v2f o;
46                 o.pos = UnityWorldToClipPos(v.vertex);
47                 o.worldnormal = UnityObjectToWorldNormal(v.normal);
48                 o.worldpos = mul(unity_ObjectToWorld,v.vertex).xyz;
49                 o.worldViewDir = UnityWorldSpaceViewDir(o.worldpos);
50                 o.worldReflect = reflect(-o.worldViewDir,o.worldnormal);
51                 TRANSFER_SHADOW(o);
52                 return o;
53             }
54 
55             fixed4 frag(v2f i) : SV_Target
56             {
57                 fixed3 worldnormal = normalize(i.worldnormal);
58                 fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldpos));
59                 fixed3 worldViewDir = normalize(i.worldViewDir);
60                 
61                 fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;
62                 
63                 fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0,dot(worldnormal,worldLightDir));
64 
65                 fixed3 reflection = texCUBE(_Cubemap,i.worldReflect).rgb * _ReflectColor.rgb;
66                 UNITY_LIGHT_ATTENUATION(atten,i,i.worldpos);
67                 fixed3 color = ambient + lerp(diffuse ,reflection,_ReflectAmount) * atten;
68                 return fixed4(color,1.0); 
69 
70             } 
71             ENDCG
72         }
73 
74         
75     }
76     FallBack &quot;Reflective/VertexLit&quot;
77 }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;至此，我们介绍完了反射的效果，接下来，我们来讨论光现象中的另一种常见的&lt;strong&gt;折射效果&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/23.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3.1 何为光线折射 &lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/24.png&quot; alt=&quot;&quot; width=&quot;350&quot; height=&quot;230&quot;/&gt;&lt;/p&gt;

&lt;p&gt;光从一种介质进入另一种具有不同折射率的介质，或者在同一种介质中折射率不同的部分运行时，由于波速的差异，使光的运行方向改变的现象就称为光的折射。而&lt;strong&gt;光在发生折射时入射角与折射角符合斯涅耳定律：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/25.png&quot; alt=&quot;&quot; width=&quot;200&quot; height=&quot;22&quot;/&gt; &lt;/p&gt;

&lt;p&gt;常见的折射率有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;真空：1&lt;/li&gt;
&lt;li&gt;水：1.3330&lt;/li&gt;
&lt;li&gt;玻璃：一般约为 1.5&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果读者遇到其它物质折射的情况，可自行查阅该物质的折射率。&lt;/p&gt;

&lt;p&gt;“&lt;strong&gt;当得到了折射方向之后，我们就可以使用它来对立方体纹理采样&lt;/strong&gt;”，相信读者头脑中可能会浮现出这个想法，但这个想法事实上是不够严谨的。对于透明的物体，应该模拟两次折射才会更为准确，光线射入物体内部，光线从内部射出。然而要在实时渲染中模拟出第二种折射是很复杂且耗费资源的，并且模拟第一次折射得到效果在大多数情况下也是良好的，所以，&lt;strong&gt;通常来说，我们的确会执行这种不太严谨的想法，即只模拟第一次折射&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;3.2 实践&lt;/h2&gt;
&lt;p&gt;其实折射的 shader 代码和 反射的代码相差不大，所以我们进行和反射一样的操作，然后进行几处修改。下面列出这些值得注意的修改之处。&lt;/p&gt;

&lt;p&gt;I. 在 Properties 块中添加一个属性 _RefractRatio，代表不同介质的透射比。比如光从空气射到水体，透射比约为 1 / 1.3；同理光从空气射到玻璃，透射比约为 1 / 1.5；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/29.png&quot; alt=&quot;&quot; width=&quot;425&quot; height=&quot;125&quot;/&gt;&lt;/p&gt;

&lt;p&gt;II. 定义与 Properties 块匹配的属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/30.png&quot; alt=&quot;&quot; width=&quot;213&quot; height=&quot;107&quot;/&gt;&lt;/p&gt;

&lt;p&gt;III. 在顶点着色器中计算折射方向&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/31.png&quot; alt=&quot;&quot; width=&quot;684&quot; height=&quot;81&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们使用的是 CG 函数 refract，找到它的定义如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/26.png&quot; alt=&quot;&quot; width=&quot;983&quot; height=&quot;861&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里需要注意的是，根据定义我们可以得知，参数是 入射光线的&lt;strong&gt;方向向量&lt;/strong&gt;，表面法线的&lt;strong&gt;方向向量&lt;/strong&gt;，透射比，与 reflect 函数不同，这里明确指出需要方向向量，所以我们&lt;strong&gt;需要对这两个向量归一化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; IV. 其它的代码基本只需要替换相应的变量名字就可以了，这里直接给出完整代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
 1 Shader &quot;Unity/02-Refraction&quot; {
 2     Properties {
 3         _Color (&quot;Color Tint&quot;, Color) = (1,1,1,1)
 4         _RefractColor(&quot;Refraction Color&quot;,Color) = (1,1,1,1)
 5         _RefractAmount(&quot;Refract Amount&quot;,Range(0,1)) = 1
 6         _RefractRatio(&quot;Refract Ratio&quot;,Range(0,1)) = 1
 7         _Cubemap(&quot;Refraction Cubemap&quot;,Cube) = &quot;_Skybox&quot;{}
 8     }
 9     SubShader 
10     {
11         
12         Pass
13         {
14             Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; }
15 
16             CGPROGRAM
17             #pragma multi_compile_fwdbase    
18             #pragma vertex vert    
19             #pragma fragment frag
20             #include &quot;Lighting.cginc&quot;
21             #include &quot;AutoLight.cginc&quot;
22     
23             fixed4 _Color;
24             fixed4 _RefractColor;
25             float _RefractAmount;
26             float _RefractRatio;
27             samplerCUBE _Cubemap;
28 
29             struct a2v
30             {
31                 float4 vertex : POSITION;
32                 float3 normal : NORMAL;
33             };
34 
35             struct v2f
36             {
37                 float4 pos : SV_POSITION;
38                 float3 worldnormal : TEXCOORD0;
39                 float3 worldpos : TEXCOORD1;
40                 float3 worldViewDir : TEXCOORD2;
41                 float3 worldRefract : TEXCOORD3;
42                 SHADOW_COORDS(4)
43             };
44 
45             v2f vert(a2v v)
46             {
47                 v2f o;
48                 o.pos = UnityWorldToClipPos(v.vertex);
49                 o.worldnormal = UnityObjectToWorldNormal(v.normal);
50                 o.worldpos = mul(unity_ObjectToWorld,v.vertex).xyz;
51                 o.worldViewDir = UnityWorldSpaceViewDir(o.worldpos);
52                 o.worldRefract = refract(normalize(o.worldViewDir),normalize(o.worldnormal),_RefractRatio);
53                 TRANSFER_SHADOW(o);
54                 return o;
55             }
56 
57             fixed4 frag(v2f i) : SV_Target
58             {
59                 fixed3 worldnormal = normalize(i.worldnormal);
60                 fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldpos));
61                 fixed3 worldViewDir = normalize(i.worldViewDir);
62                 
63                 fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;
64                 
65                 fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0,dot(worldnormal,worldLightDir));
66 
67                 fixed3 Refraction = texCUBE(_Cubemap,normalize(i.worldRefract)).rgb * _RefractColor.rgb;
68                 UNITY_LIGHT_ATTENUATION(atten,i,i.worldpos);
69                 fixed3 color = ambient + lerp(diffuse ,Refraction,_RefractAmount) * atten;
70                 return fixed4(color,1.0); 
71 
72             } 
73             ENDCG
74         }
75 
76         
77     }
78     FallBack &quot;Reflective/VertexLit&quot;
79 }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;V.保存，回到 Unity 查看效果&lt;/p&gt;

&lt;p&gt;不同透射比的折射效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/32.gif&quot; alt=&quot;&quot; width=&quot;695&quot; height=&quot;535&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由于 gif 图清晰度有限，所以这里做反射和折射的对比，更能看出效果&lt;/p&gt;

&lt;p&gt;反射：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/28.png&quot; alt=&quot;&quot; width=&quot;551&quot; height=&quot;423&quot;/&gt;&lt;/p&gt;

&lt;p&gt;折射：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/27.png&quot; alt=&quot;&quot; width=&quot;571&quot; height=&quot;423&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 通过对比，我们可以看到图二中的光线似乎是被 “扭曲了” ，这正是光线的角度改变了，也正是我们要实现的折射效果&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/33.jpg&quot; alt=&quot;&quot; width=&quot;275&quot; height=&quot;183&quot;/&gt;&lt;/p&gt;

&lt;p&gt;相信读者并不会对这个名字感到陌生，没错，在我们生活中，最最最为常见的菲涅耳反射现象无疑是水边。当你站在湖边或河边时，你能清晰地看到脚边的水边一切景象，而当你抬头看向远处水面时，却只能看到一片白光。&lt;/p&gt;

&lt;p&gt;当光射到物体表面时，一部分发生反射，一部分进入物体内部，然后发生折射或反射。反射光和入射光存在一定的比例关系，而这个关系可以由菲涅耳等式计算。 而菲涅耳等式有两条应用广泛的近似等式：&lt;/p&gt;

&lt;p&gt;① &lt;strong&gt;Schlick 菲涅耳近似等式 ：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;                             &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Clarge%20%7B%5Ccolor%7BRed%7D%20F_%7BSchlick%7D%28v%2Cn%29%20%3D%20F%20_%7B0%7D%20&amp;amp;plus;%20%281%20-%20F_%7B0%7D%29%20%281%20-%20v%20%5Ccdot%20n%29%5E%7B5%7D%20%7D&quot; alt=&quot;\large {\color{Red} F_{Schlick}(v,n) = F _{0} + (1 - F_{0}) (1 - v \cdot n)^{5} }&quot;/&gt;&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;v 是视角方向，n 是表面法线，F0 是反射系数&lt;/p&gt;

&lt;p&gt;② &lt;strong&gt;Empricial 菲涅耳近似等式 ：&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Clarge%20%7B%5Ccolor%7BRed%7D%20F_%7BEmpricial%7D%28v%2Cn%29%20%3D%20max%280%2Cmin%281%2Cbias%20&amp;amp;plus;%20scale%20%5Ctimes%20%28%201%20-v%5Ccdot%20n%29%5E%7Bpower%7D%29%29%7D&quot; alt=&quot;\large {\color{Red} F_{Empricial}(v,n) = max(0,min(1,bias + scale \times ( 1 -v\cdot n)^{power}))}&quot;/&gt;&lt;/p&gt;

&lt;p&gt;bias，scale，power 是控制项&lt;/p&gt;

&lt;p&gt;使用菲涅耳近似等式，我们可以模拟&lt;strong&gt;边界处&lt;/strong&gt;的反射、折射/漫反射光强间的变化。特别是油漆，水面这种材质。本文只是介绍其原理及简单实现，在以后的学习中，我们将会利用它来制作一条有趣的河流或水面。 &lt;/p&gt;

&lt;h2&gt;4.2 简单菲涅耳反射的实现&lt;/h2&gt;
&lt;p&gt;此处我们使用 &lt;strong&gt;Schlick 菲涅耳近似等式&lt;/strong&gt; 来实现一个菲涅耳反射现象。与实现折射时相同，大部分的计算都是一样的，所以这里同样只提出值得注意的地方。&lt;/p&gt;

&lt;p&gt; I. 定义 Properties 块&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/35.png&quot; alt=&quot;&quot; width=&quot;424&quot; height=&quot;93&quot;/&gt;&lt;/p&gt;

&lt;p&gt;II. 定义相匹配变量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/36.png&quot; alt=&quot;&quot; width=&quot;200&quot; height=&quot;82&quot;/&gt;&lt;/p&gt;

&lt;p&gt;III. 计算反射方向&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/37.png&quot; alt=&quot;&quot; width=&quot;433&quot; height=&quot;98&quot;/&gt;&lt;/p&gt;

&lt;p&gt;IV. 在片元着色器中计算菲涅耳反射，然后混合得到最终颜色&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/38.png&quot; alt=&quot;&quot; width=&quot;785&quot; height=&quot;189&quot;/&gt;&lt;/p&gt;

&lt;p&gt;V. 完整代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
 1 Shader &quot;Unity/03-Fresne&quot; {
 2     Properties {
 3         _Color (&quot;Color Tint&quot;, Color) = (1,1,1,1)
 4         _FresnelScale (&quot;Fresnel Scale&quot;,Range(0,1)) = 0.5
 5         _Cubemap(&quot;Refraction Cubemap&quot;,Cube) = &quot;_Skybox&quot;{}
 6     }
 7     SubShader 
 8     {
 9         
10         Pass
11         {
12             Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; }
13 
14             CGPROGRAM
15             #pragma multi_compile_fwdbase    
16             #pragma vertex vert    
17             #pragma fragment frag
18             #include &quot;Lighting.cginc&quot;
19             #include &quot;AutoLight.cginc&quot;
20     
21             fixed4 _Color;
22             float _FresnelScale;
23             samplerCUBE _Cubemap;
24 
25             struct a2v
26             {
27                 float4 vertex : POSITION;
28                 float3 normal : NORMAL;
29             };
30 
31             struct v2f
32             {
33                 float4 pos : SV_POSITION;
34                 float3 worldnormal : TEXCOORD0;
35                 float3 worldpos : TEXCOORD1;
36                 float3 worldViewDir : TEXCOORD2;
37                 float3 worldReflect : TEXCOORD3;
38                 SHADOW_COORDS(4)
39             };
40 
41             v2f vert(a2v v)
42             {
43                 v2f o;
44                 o.pos = UnityWorldToClipPos(v.vertex);
45                 o.worldnormal = UnityObjectToWorldNormal(v.normal);
46                 o.worldpos = mul(unity_ObjectToWorld,v.vertex).xyz;
47                 o.worldViewDir = UnityWorldSpaceViewDir(o.worldpos);
48                 o.worldReflect = reflect(-o.worldViewDir,o.worldnormal);
49                 TRANSFER_SHADOW(o);
50                 return o;
51             }
52 
53             fixed4 frag(v2f i) : SV_Target
54             {
55                 fixed3 worldnormal = normalize(i.worldnormal);
56                 fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldpos));
57                 fixed3 worldViewDir = normalize(i.worldViewDir);
58                 
59                 fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;
60                 
61                 fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0,dot(worldnormal,worldLightDir));
62 
63                 fixed3 reflection = texCUBE(_Cubemap,i.worldReflect).rgb;
64 
65                 fixed3 fresnel = _FresnelScale + (1 - _FresnelScale) * pow(1 - dot(worldViewDir,worldnormal),5);
66 
67                 UNITY_LIGHT_ATTENUATION(atten,i,i.worldpos);
68 
69                 fixed3 color = ambient + lerp(diffuse ,reflection,saturate(fresnel)) * atten;
70 
71                 return fixed4(color,1.0); 
72 
73             } 
74             ENDCG
75         }
76 
77         
78     }
79     FallBack &quot;Reflective/VertexLit&quot;
80 }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;VI.查看效果&lt;/p&gt;

&lt;p&gt;当 _FresnelScale 为 0 时，这时该物体就是一个具有边缘光照效果的漫反射物体&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/34.png&quot; alt=&quot;&quot; width=&quot;834&quot; height=&quot;277&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果觉得图片效果不太明显，读者可以自行实现，感受一下。&lt;/p&gt;


&lt;p&gt;对于立方体纹理，读者可能不一定会熟悉，但你一定熟悉天空盒，而立方体纹理正是天空盒和环境映射的实现的常用方法。同时，在场景中存在天空盒的情况下，物体对环境的采光正是本文所探讨的问题。无论是反射或是折射都是再通常不过的现象，所以我们也应该熟悉其实现。希望本文能对您有所帮助。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E7%9F%B3%E5%8E%9F%E9%87%8C%E7%BE%8E.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 04 Nov 2018 02:26:00 +0000</pubDate>
<dc:creator>爱喝柠檬的二哈</dc:creator>
<og:description>笔者使用的是 Unity 2018.2.0f2 + VS2017，建议读者使用与 Unity 2018 相近的版本，避免一些因为版本不一致而出现的问题。 前言 关于纹理，之前在 【Unity</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BFXYMY/p/9902596.html</dc:identifier>
</item>
<item>
<title>代码之美——《重构》、《代码整洁之道》 - LevenYes</title>
<link>http://www.cnblogs.com/levenyes/p/9903156.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/levenyes/p/9903156.html</guid>
<description>&lt;p&gt;什么样的代码才是美的代码？一千个coders可能会给出一千个答案。今天，让我从一个简单的角度来谈谈对于代码之美的理解。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;可读性高的代码才有可能是美的代码&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;相信大家都有过这样的经历：接手一个项目要修复bug或者开发新功能的时候，发现代码可读性非常差。哪怕是在有说明文档的情况下，都不太敢提交代码，唯恐引入新的bug或者直接导致系统崩溃。&lt;/p&gt;

&lt;p&gt;软件系统在代码方面的成本分为两部分，第一部分是开发成本，第二部分是维护成本。&lt;/p&gt;

&lt;p&gt;开发成本很好理解，就是把一个系统开发出来需要支付的各种成本，其中最大一块很可能是人力成本。任何一个大型软件系统都不可能没有bug。系统开始运作之后，这些bug可能会导致业务出错、运行缓慢，甚至是宕机，需要程序员找出漏洞并且修复上线。在这一阶段的成本，我们称之为维护成本。&lt;/p&gt;

&lt;p&gt;运维成本往往会超过开发成本。我毕业后的第一份工作是在一家ERP公司做二次开发，最早的代码注释时间有十几年前的，常年从事维护开发工作的人员超过十个人。开发需要的时间远比维护的时间要短得多，维护人员的数量并不会比开发人员的数量要少太多。&lt;/p&gt;

&lt;p&gt;如果适当增加开发成本可以大幅减少维护成本，那么对节省整体成本有着极大的帮助。&lt;/p&gt;

&lt;p&gt;在进入到互联网时代的今天，像ERP这样开发完成之后变化不大的“重”系统已经不多了，模块化、服务化的“轻”系统已经占到绝大多数。这些现代软件系统强调的是迭代开发，以月或者周为单位更新版本，可以说几乎永远不会进入到所谓的“维护”阶段。因此，如何平衡版本间的成本占比，是程序员和管理者必须要关心的主题。&lt;/p&gt;

&lt;p&gt;《重构》里有这么一段话：“任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。”如果只是写出可以运行的代码，却不具备可读性或可读性很差，负责接手项目的下一位程序员就很难在原有的基础上再进行开发工作。这样做固然初始的开发成本会比较低，但是后续维护和再开发的成本就很容易变得不可接受地高。&lt;/p&gt;

&lt;p&gt;哪怕有人抱着“我走后，哪管它洪水滔天”的想法，却仍要考虑更普遍的一种情况。在更多的时候，需要读懂这些糟糕的代码并且付出代价的人，往往就是几个月后已经忘记这段代码为什么要这么写的你自己。&lt;/p&gt;

&lt;h3&gt;不要写过长函数 &lt;/h3&gt;
&lt;p&gt;可读性差的代码有很多特征，其中最典型的就是存在大量过长的函数。&lt;/p&gt;

&lt;p&gt;过长的函数之所以会导致难以理解，主要是因为里面做了很多件事，而且容易导致抽象层次不一致。在完全陌生的情况下去读这些代码，我们经常会读着读着就不知道某几行代码是在做什么、为什么要这么做，往往要花很大的功夫去蒙去猜。&lt;/p&gt;

&lt;p&gt;刚入门的程序员很容易问出这样的问题：“到底多少行代码的函数才算过长呢？”我们可以从Martin Fowler那里得到答案，“关键不在于函数的长度，而在于函数‘做什么’和‘如何做’之间的语义距离”。这句话换个角度理解，首先你要确保你的函数做完且只做一件事，然后这个函数里的代码都只为这件事服务。&lt;/p&gt;

&lt;p&gt;如果函数已经过长了应该怎么办？不要犹豫，立刻切分它。我们先要读出面前这个过长函数到底做了多少件事，然后逐一地按照事务来提取代码，以子函数的形式对其进行抽象。&lt;/p&gt;

&lt;p&gt;有人可能会担心，生怕这样会导致一个类里面的函数过多，会导致其他不良后果。这种忧虑其实毫无必要，因为实际经验告诉我们：只要切分是恰当的，不但不会有坏处，还会有除了提升代码可读性的其他好处。&lt;/p&gt;

&lt;p&gt;其中一个最明显的好处就是可复用性会增强。一段代码如果没有提取出来成为独立的函数，其他地方如果要想用到就必须复制粘贴，这不但体现不出代码可复用的好处，还会引发代码一个新的坏味道：重复代码。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;注释是一把双刃剑&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;对于注释，我们的第一印象往往是正面的。注释并不是代码，对软件系统本身并不会起任何作用。它是为了让读源代码的人更好地理解原作者的意图而存在的，因此我们在阅读一段很难理解的代码的时候总是希望能有注释。&lt;/p&gt;

&lt;p&gt;正式参加工作之后，我们对注释的看法可能会发生一些转变。首先，有些人的注释写得很糟糕，表达出来的意思常常让人云里雾里，甚至还不如不看这些注释。然后，有些人的代码写得很糟糕，注释虽然有所帮助，但是这就成了程序员逃避被要求写出整洁代码的法宝。更何况，还有一部分人的代码和注释都写得很糟糕。&lt;/p&gt;

&lt;p&gt;另外，注释也有维护成本。注释依附于代码，所以如果代码有所改动，注释也要相应有所更新，这里就产生了成本。如果更新不及时或者没有更新，注释就会过时，产生误导代码阅读者的风险。&lt;/p&gt;

&lt;p&gt;因此，除了涉及到比较复杂的算法或者不得不特别加以说明的约定等情况，我并不建议优先使用注释。命名良好的独立函数应该成为优秀程序员的第一选择。&lt;/p&gt;

&lt;p&gt;如果你在阅读自己写的或者是需要重构的代码时，发现某一个地方需要用注释来说明，这就表明这里很有可能应该提取出成一个独立函数。新的独立函数需要有一个良好的命名，要做到让人可以轻易地“望文生义”，这才是最好的“注释”。&lt;/p&gt;

&lt;p&gt;注释不是代码，要想提升代码可读性，最好的途径还是应该通过代码本身去实现。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;测试！测试！&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;无论我们怎么努力，也很难一下子就写出可读性很强的代码。这就像写文章一样，我们的大部分精力都放在表达思想上面，文从字顺有的时候就不太顾得上。写代码，第一要务是能运行，能实现软件系统的功能。&lt;/p&gt;

&lt;p&gt;《代码整洁之道》的作者写道：“我没指望你能够一次过写出整洁、漂亮的程序。如果说我们从过去几十年里面学到什么东西的话，那就是编程是一种技艺甚于科学的东西。要编写整洁代码，必须先写肮脏的代码，然后再清理它。”&lt;/p&gt;

&lt;p&gt;很多人写出了可以运行的、“肮脏”的代码，或者说接手了一个可读性比较差的系统，往往不愿意去重构它们。他们的理由看上去是十分充分的，那就是容易引入新bug。业界有名言可以作为依据：如果没坏，就别去修它（If ain’t broke, don’t fix it）。&lt;/p&gt;

&lt;p&gt;我最近才犯了一个错误：在没有经过测试的情况下，把一段重构过的代码上线到生产环境。结果就是导致一个重要功能不可用，最终要通过紧急版本进行修复。&lt;/p&gt;

&lt;p&gt;事后反省时，我并没有赌咒发誓以后再也不重构代码，而是在重构之外加上一个必要的环节——测试。&lt;/p&gt;

&lt;p&gt;《重构》一书开头便写道：“每当我要进行重构的时候，第一个步骤永远相同：我得为即将修改的代码建立一组可靠的测试环境。这些测试是必要的，因为尽管遵循重构手法可以使我避免绝大多数引入bug的情形，但我毕竟是人，毕竟有可能犯错。所以我需要可靠的测试。”&lt;/p&gt;

&lt;p&gt;测试有很多种类型，其中单元测试和功能测试最为常用。对于Java程序员，我们可以使用JUnit等测试框架去写单元测试，往往可以避免相当一部分引入bug的情形。然后，针对不同的业务场景，我们还需要做一些简单的功能测试。&lt;/p&gt;

&lt;p&gt;重构和测试当然都需要成本，还要承担不可能完全避免的引入bug的风险。但是我相信，为了提升代码的质量，为了降低维护和后续开发的成本，这些都是值得付出的代价。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;Coding进阶之道&lt;/strong&gt; &lt;/h3&gt;
&lt;p&gt;对于代码的理解，不同人能到达不同的层次。刚开始学习，停留在行级。入门之后，进步到方法级。工作之后，可以到达类级和模块级。经验积累足够多了，会精进到架构级，甚至是更高的级别。&lt;/p&gt;

&lt;p&gt;但是无论如何，任何进步都是从一点一滴的努力中得来的。如果你自我评价还没有到达很高的级别，那就不妨一起来尝试学习和实践重构，让经过自己手的代码变得更美。&lt;/p&gt;

&lt;p&gt;《重构》里有一段话非常有启发性：“一开始我所做的重构都像这样停留在细枝末节上。随着代码渐趋简洁，我发现自己可以看到一些以前看不到的设计层面的东西。如果不对代码做这些修改，也许我永远看不见它们，因为我的聪明才智不足以在脑子里把这一切都想象出来。Ralph Johnson把这种‘早期重构’描述成‘擦掉窗户上的污垢，使你看得更远’。研究代码时我发现，重构把我带到更高的理解层次上。如果没有重构，我达不到这种层次。”&lt;/p&gt;

&lt;p&gt;技术的精进要靠什么？有的人说是天赋，这是老天爷赏饭吃，一般人都达不到。有的人说是经验，一定要有多个大型项目的积累才有可能成为专家。有的人说是学习，必须把原理研究得很深很透才能把握技术的本质。然而，这些都不是一个脚踏实地的好答案。&lt;/p&gt;

&lt;p&gt;技术的精进，靠的应该是一个又一个经过时间检验的、得到业界认可的工具。从业人员通过使用这些工具优化自己的工作输出，日积月累，最终成为各自领域的佼佼者。重构，就是这么一个经典的、优秀的、实用的工具。&lt;/p&gt;

&lt;p&gt;学习重构、实践重构、掌握重构，能够帮助我们成为更好的coder。&lt;/p&gt;



&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot; readability=&quot;61&quot;&gt;
&lt;p&gt;我有一个公众号，经常会发一些看书思考过后写的文章，还有作为一个程序员的工作经验分享。&lt;/p&gt;
&lt;p&gt;如果你喜欢我的文字，可以用微信搜索“李文业的思考笔记”或者扫描二维码关注。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/470341/201707/470341-20170704180534003-535825211.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;


</description>
<pubDate>Sun, 04 Nov 2018 02:05:00 +0000</pubDate>
<dc:creator>LevenYes</dc:creator>
<og:description>什么样的代码才是美的代码？一千个coders可能会给出一千个答案。今天，让我从一个简单的角度来谈谈对于代码之美的理解。 可读性高的代码才有可能是美的代码 相信大家都有过这样的经历：接手一个项目要修复b</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/levenyes/p/9903156.html</dc:identifier>
</item>
</channel>
</rss>