<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>WebApiClient的SteeltoeOSS.Discovery扩展 - jiulang</title>
<link>http://www.cnblogs.com/kewei/p/9710778.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kewei/p/9710778.html</guid>
<description>&lt;h3 id=&quot;背景&quot;&gt;1 背景&lt;/h3&gt;
&lt;p&gt;从园子里看到一些朋友在某些项目开发中，选择的架构是spring cloud搭建底层微服务框架，dotnet core来编写业务逻辑，&lt;a href=&quot;https://github.com/SteeltoeOSS/Discovery&quot;&gt;SteeltoeOSS.Discovery&lt;/a&gt;是dotnet和spingcloud的桥梁，为dotnet提供服务注册和服务发现相关功能。在阅读朋友们文章的时候，我发现相关代码里的一些HttpClient相关问题，同时对dotnet寄居于spingcloud下由于没有Feign而产生的那些丑陋的http请求代码进行思考。本文将围绕原生的HttpClient的创建与释放的正确姿势和使用&lt;a href=&quot;https://github.com/dotnetcore/WebApiClient&quot;&gt;WebApiClient&lt;/a&gt;让dotnet也有媲美Feign的服务客户端两个面展开。&lt;/p&gt;
&lt;h3 id=&quot;正确使用httpclient&quot;&gt;2 正确使用HttpClient&lt;/h3&gt;
&lt;h4 id=&quot;httpclient的创建和释放&quot;&gt;2.1 HttpClient的创建和释放&lt;/h4&gt;
&lt;p&gt;HttpClient有三个构造函数，最终都是调用到public HttpClient(HttpMessageHandler handler, bool disposeHandler)这个函数，HttpClient除了其handler参数之外，本身没有使用到需要Dispose的资源，其实现的IDispose也是为了Dispose掉handler参数而已。&lt;/p&gt;
&lt;p&gt;HttpMessageHandler是一个抽象类，目前主要的HttpMessageHandler具体类型有HttpClientHanlder、SocketsHttpHandler和WebRequestHandler，但HttpClientHanlder在dotnet core2.1下是对和SocketsHttpHandler的包装实现。除了这些主要HttpMessageHandler，还有一个抽象的DelegatingHandler类型，用于实现请求管道，影响请求前后的数据逻辑。HttpClient的默认构造器，使用了HttpClientHanlder类型，同时disposeHandler为true，这时如果对HttpClient实例Dispose了，其内部的HttpClientHanlder自然也被Dispose了，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正确的创建和释放HttpClient例子&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;默认构造器&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var httpClient = new HttpClient();
...你的代码...
httpClient.Dispose();&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;HttpClient控制HttpMessageHandler&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var handler = new HttpClientHandler();
var httpClient = new HttpClient(handler, true);
...你的代码...
httpClient.Dispose();&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;HttpClient不控制外部HttpMessageHandler&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var handler = 从外部来的HttpMessageHandler;
var httpClient = new HttpClient(handler, false);
...你的代码...

// 这里调用httpClient.Dispose()是无效的
// handler的生命周期应该由它的创建者来维护
// 如果这里Dispose掉handler，其它使用了这个handler的HttpClient实例受影响&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;不正确的创建和释放HttpClient的例子&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;HttpMessageHandler被创建了，但没有释放&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private readonly DiscoveryHttpClientHandler _handler;
private const string ProductUrl = &quot;http://product/api/values&quot;;

public ValuesController(IDiscoveryClient client, ILoggerFactory logFactory)
{
    _handler = new DiscoveryHttpClientHandler(client);
}

[HttpGet(&quot;product&quot;)]
public async Task&amp;lt;string&amp;gt; GoProductAsync()
{
    var client = new HttpClient(_handler, false);
    return await client.GetStringAsync(ProductUrl);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;httpclient的生命周期&quot;&gt;2.2 HttpClient的生命周期&lt;/h4&gt;
&lt;p&gt;HttpClient在设计之初，是非常适合使用单例模式的，也就是在应用域中，只维护一份HttpClient的实例就够了，因为它天生支持向不同域名同时多个并发请求。但单例的HttpClient没有遵守DNS 生存时间 (TTL) 设置，如果其HttpClientHandler第一次请求到www.baidu.com指向的ip为123.123.123.123，中途这个域名解析到的ip变化了，但HttpClient并不会自动应用这些变化。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;asp.net core&lt;/code&gt;里，微软创建一个&lt;a href=&quot;https://github.com/aspnet/HttpClientFactory&quot;&gt;HttpClientFactory&lt;/a&gt;项目，用于提供HttpClient的创建和生命周期自动管理，完美解决到底选择单例还是每个请求创建和释放HttpClient这个左右难为的问题。所以在&lt;code&gt;asp.net core&lt;/code&gt;项目开发中，请别再写手动new HttpClient了，所有HttpClient的实例，都要由HttpClientFactory来创建，所有的外部HttpMessageHandler，也应该配置到HttpClientFactory，让它与HttpClient关联起来。&lt;/p&gt;
&lt;p&gt;HttpClientFactory有三种使用方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Using HttpClientFactory Directly&lt;/li&gt;
&lt;li&gt;Named Clients&lt;/li&gt;
&lt;li&gt;Typed Clients&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体的使用，可以查看&lt;a href=&quot;http://www.talkingdotnet.com/3-ways-to-use-httpclientfactory-in-asp-net-core-2-1/&quot;&gt;3 ways to use HTTPClientFactory in ASP.NET Core 2.1&lt;/a&gt;这篇好文。&lt;/p&gt;
&lt;h3 id=&quot;寄居下也有feign&quot;&gt;3 寄居下也有Feign&lt;/h3&gt;
&lt;p&gt;虽然已经讲解了怎么new一个HttpClient，怎么利用HttpClientFactory，但如果要寄居在spingcloud下，你还是得为请求一个服务接口编写大量的代码，这在java的Feign前面如同马车见到宝马。如果能利用&lt;a href=&quot;https://github.com/dotnetcore/WebApiClient&quot;&gt;WebApiClient&lt;/a&gt;这把利剑，结合HttpClientFactory与DiscoveryHttpClientHandler，你也能变成宝马。将这三者有机结合起来的项目，叫&lt;a href=&quot;https://github.com/xljiulang/WebApiClient.Extensions&quot;&gt;WebApiClient.Extensions.DiscoveryClient&lt;/a&gt;，它是WebApiClient的SteeltoeOSS.Discovery扩展项目，使用非常简单。&lt;/p&gt;
&lt;h4 id=&quot;nuget引用&quot;&gt;3.1 Nuget引用&lt;/h4&gt;
&lt;p&gt;PM&amp;gt; &lt;code&gt;install-package WebApiClient.Extensions.DiscoveryClient&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;声明微服务的webapiclient调用接口&quot;&gt;3.2 声明微服务的WebApiClient调用接口&lt;/h4&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[HttpHost(&quot;http://NET-API&quot;)]
public interface INetApi : IHttpApi
{
    [HttpGet(&quot;api/values&quot;)]
    ITask&amp;lt;string[]&amp;gt; GetValuesAsync();

    [HttpGet(&quot;api/values/{id}&quot;)]
    ITask&amp;lt;string&amp;gt; GetValuesAsync(int id);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;startup相关配置&quot;&gt;3.3 Startup相关配置&lt;/h4&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// This method gets called by the runtime. Use this method to add services to the container.
public void ConfigureServices(IServiceCollection services)
{
    services.AddDiscoveryClient(Configuration);
    services.AddDiscoveryTypedClient&amp;lt;INetApi&amp;gt;();
    ...
}


// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    ...
    app.UseDiscoveryClient();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;controller&quot;&gt;3.4 Controller&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class HomeController : Controller
{
    public async Task&amp;lt;string&amp;gt; Index([FromServices]INetApi netApi, int id = 0)
    {
        var values = await netApi.GetValuesAsync();
        var value = await netApi.GetValuesAsync(id);
        return &quot;ok&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;结束语&quot;&gt;4. 结束语&lt;/h3&gt;
&lt;p&gt;本博主对HttpClient有着比较深入的了解，一直在维护WebApiClient项目，期间走过许许多多的“坑”，如果你有遇到HttpClient的相关问题，欢迎一起讨论解决。&lt;/p&gt;
</description>
<pubDate>Wed, 26 Sep 2018 15:34:00 +0000</pubDate>
<dc:creator>jiulang</dc:creator>
<og:description>1 背景 从园子里看到一些朋友在某些项目开发中，选择的架构是spring cloud搭建底层微服务框架，dotnet core来编写业务逻辑，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kewei/p/9710778.html</dc:identifier>
</item>
<item>
<title>gitlab服务器搭建 - 编编码旅旅行</title>
<link>http://www.cnblogs.com/helloworld8102/p/9710743.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/helloworld8102/p/9710743.html</guid>
<description>&lt;p&gt;【版权声明：本文为博主原创文章，未经博主允许不得转载】&lt;/p&gt;
&lt;p&gt;==================================================================&lt;/p&gt;
&lt;p&gt;运行环境：Ubuntu 18.04 LTS 64bit&lt;/p&gt;
&lt;p&gt;　　　　　Linux 4.15.0-34-generic x86_64 GNU/Linux&lt;/p&gt;
&lt;p&gt;　　　　　gcc-7.3.0&lt;/p&gt;
&lt;p&gt;==================================================================&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【gitlab服务器安装】&lt;/span&gt;&lt;/strong&gt;　　&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;1.安装必要的依赖文件&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　　　　　sudo apt-get install -y curl openssh-server ca-certificates&lt;br/&gt;　　　　安装postfix，用来支持email通知功能&lt;br/&gt;　　　　　　sudo apt-get install -y postfix&lt;br/&gt;　　　　安装过程中选择“Internet Site”选项。&lt;br/&gt;　　&lt;span&gt;&lt;strong&gt;2.下载gitlab仓库的安装脚本，并执行安装&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　　　　　curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.deb.sh | sudo bash&lt;br/&gt;　　　　安装gitlab软件，并预先指定gitlab服务器的地址：&lt;br/&gt;　　　　　　sudo EXTERNAL_URL=&quot;http://gitlab.example.com&quot; apt-get install gitlab-ee&lt;/p&gt;
&lt;p&gt;　　　　例如，如果是安装在本地，假设IP地址是192.168.132.164，则&lt;br/&gt;　　　　　　sudo EXTERNAL_URL=&quot;http://192.168.132.164:5678&quot; apt-get install gitlab-ee&lt;br/&gt;　　　　指定5678端口作为gitlab服务的端口。&lt;br/&gt;　　&lt;strong&gt;&lt;span&gt;3.访问gitlab服务器，使用默认root用户登录，并设置密码&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　　　首次登录时，需要设置登录密码。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;【配置gitlab域名】&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　# sudo vi /etc/gitlab/gitlab.rb&lt;br/&gt;　　编辑：external_url '你的网址'&lt;br/&gt;　　例如：external_url 'http://192.168.1.100'&lt;br/&gt;　　编辑完成后，再sudo gitlab-ctl reconfigure一下，使配置生效&lt;/p&gt;
&lt;p&gt;　　如果是本地的gitlab服务器，可以使用“http://localhost”访问&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【修改gitlab服务器仓库位置】&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;1.修改仓库位置：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　 默认情况下gitlab的仓库位置是 /var/opt/gitlab/git-data.&lt;br/&gt;　　 可以通过编辑 /etc/gitlab/gitlab.rb 文件修改配置，例如将目录改为 /mnt/git-data:&lt;br/&gt;　　 对应参数是：git_data_dirs&lt;br/&gt;　　　　原始值：git_data_dirs({&lt;br/&gt;　　　　　　　　　　&quot;default&quot; =&amp;gt; &quot;/var/opt/gitlab/git-data&quot;,&lt;br/&gt;　　　　　　　　})&lt;br/&gt;　　　　修改为：&lt;br/&gt;　　　　　　　　git_data_dirs({&lt;br/&gt;　　　　　　　　　　&quot;default&quot; =&amp;gt; &quot;/var/opt/gitlab/git-data&quot;,&lt;br/&gt;　　　　　　　　　　&quot;alternative&quot; =&amp;gt; &quot;/mnt/git-data&quot;&lt;br/&gt;　　　　　　　　})&lt;br/&gt;　　 注意：目标文件夹不能包含软连接&lt;br/&gt;　　 执行一下命令，使修改生效：&lt;br/&gt;　　　　 sudo gitlab-ctl reconfigure&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;2.移动仓库数据&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　　　sudo gitlab-ctl stop&lt;br/&gt;　　　　sudo rsync -av /var/opt/gitlab/git-data/repositories /mnt/git-data/&lt;br/&gt;　　　　sudo gitlab-ctl reconfigure&lt;br/&gt;　　　　sudo gitlab-ctl start&lt;br/&gt;　　　　现在已经在新目录中生成了仓库数据&lt;br/&gt;　　　　sudo ls /mnt/git-data/&lt;/p&gt;
</description>
<pubDate>Wed, 26 Sep 2018 15:25:00 +0000</pubDate>
<dc:creator>编编码旅旅行</dc:creator>
<og:description>【版权声明：本文为博主原创文章，未经博主允许不得转载】 运行环境：Ubuntu 18.04 LTS 64bit Linux 4.15.0-34-generic x86_64 GNU/Linu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/helloworld8102/p/9710743.html</dc:identifier>
</item>
<item>
<title>微信扫码支付功能（1）---通过谷歌二维码工具生成付款码 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/9708534.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/9708534.html</guid>
<description>
&lt;h2&gt;&lt;span&gt;一、微信网站扫码支付介绍&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;   1、扫码支付文档&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;   微信开发官方文档:&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_5&quot; target=&quot;_blank&quot;&gt;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  有关微信支付的流程图微信官方已经说的很清楚了，这里也无需其它解释。这边采用微信支付扫码模式二（不依赖商户平台设置回调url），所以在生成二维码之前&lt;/p&gt;
&lt;p&gt;要先调用微信统一下单支付接口，获得code_url，再通过谷歌二维码工具将code_url生成二维码图片。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;    2、名称理解&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;在微信扫码支付功能开发之前，首先要获得微信认证而得到的一些信息如下：&lt;/p&gt;
&lt;p&gt;开发者账户信息&lt;/p&gt;
&lt;p&gt;公众号 &lt;span&gt;appid&lt;/span&gt;: wx0pi2m4x6we76140w&lt;/p&gt;
&lt;p&gt;公众号 &lt;span&gt;appsecret&lt;/span&gt;: x82552d8w0y1i161lp9o7821s5d7osry&lt;/p&gt;
&lt;p&gt;商户号 &lt;span&gt;mer_id&lt;/span&gt;: 5731202714&lt;/p&gt;
&lt;p&gt;支付    &lt;span&gt;key&lt;/span&gt;: PL9wT9n9Ljav4zSN66J0bmzT1Yl54429&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;3、和微信支付交互方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1)、post方式提交&lt;/p&gt;
&lt;p&gt;  (2)、xml格式的协议&lt;/p&gt;
&lt;p&gt;  (3)、签名算法MD5&lt;/p&gt;
&lt;p&gt;  (4)、接口交易单位为 分&lt;/p&gt;
&lt;p&gt;  (5)、交易类型：JSAPI--公众号支付、NATIVE--原生扫码支付、APP--app支付&lt;/p&gt;
&lt;p&gt;  (6)、商户订单号规则：&lt;/p&gt;
&lt;p&gt;      商户支付的订单号由商户自定义生成，仅支持使用字母、数字、中划线-、下划线_、竖线|、星号*这些英文半角字符的组合，请勿使用汉字或全角等特殊字符，&lt;/p&gt;
&lt;p&gt;微信支付要求商户订单号保持唯一性&lt;/p&gt;
&lt;p&gt;   (7)、安全规范：&lt;/p&gt;
&lt;p&gt;    签名算法：&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_3&quot; target=&quot;_blank&quot;&gt;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    校验工具：&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=20_1&quot; target=&quot;_blank&quot;&gt;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=20_1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;   (8)、采用微信支付扫码模式二（不依赖商户平台设置回调url）&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、实战开发&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;   1、点击购买商品调用接口&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;接口需要接收&lt;span&gt;购买商品ID，用户ID&lt;/span&gt;,返回的就是二维码图片供用户扫码支付。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 订单接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
@RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;/api/v1/order&quot;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderController {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; VideoOrderService videoOrderService;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用户点击购买下单接口
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @GetMapping(&quot;buy&quot;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; saveOrder(@RequestParam(value = &quot;video_id&quot;,required = &lt;span&gt;true&lt;/span&gt;)&lt;span&gt;int&lt;/span&gt;&lt;span&gt; videoId,
                              HttpServletRequest request,
                              HttpServletResponse response) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 实际开发需要获取用户id和用户当前ip，这里临时写死的配置
         * String ip = IpUtils.getIpAddr(request);
         * int userId = request.getAttribute(&quot;user_id&quot;);
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; userId = 1&lt;span&gt;;
        String ip &lt;/span&gt;= &quot;120.25.1.43&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、根据用户id和商品id生成订单&lt;/span&gt;
        VideoOrderDto videoOrderDto = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VideoOrderDto();
        videoOrderDto.setUserId(userId);
        videoOrderDto.setVideoId(videoId);
        videoOrderDto.setIp(ip);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、保存订单同时返回codeUrl&lt;/span&gt;
        String codeUrl =&lt;span&gt; videoOrderService.save(videoOrderDto);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(codeUrl == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;  NullPointerException();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、通过google工具生成二维码供用户扫码支付&lt;/span&gt;
         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、1生成二维码配置&lt;/span&gt;
            Map&amp;lt;EncodeHintType,Object&amp;gt; hints =  &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、2设置纠错等级&lt;/span&gt;
&lt;span&gt;            hints.put(EncodeHintType.ERROR_CORRECTION,ErrorCorrectionLevel.L);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、3编码类型&lt;/span&gt;
            hints.put(EncodeHintType.CHARACTER_SET,&quot;UTF-8&quot;&lt;span&gt;);

            BitMatrix bitMatrix &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MultiFormatWriter().encode(codeUrl,BarcodeFormat.QR_CODE,400,400&lt;span&gt;,hints);
            OutputStream out &lt;/span&gt;=&lt;span&gt;  response.getOutputStream();

            MatrixToImageWriter.writeToStream(bitMatrix,&lt;/span&gt;&quot;png&quot;&lt;span&gt;,out);

        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;  2、进入VideoOrderService具体业务实现类&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;该类的主要业务逻辑是：&lt;/p&gt;
&lt;p&gt; &lt;span&gt;（1）通过商品ID查询是否有该商品信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;（2）通过用户ID查询是否存在该用户&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; （3）如果上面两步没有问题，则生成用户订单信息保存到数据库中&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    @Transactional(propagation &lt;/span&gt;=&lt;span&gt; Propagation.REQUIRED)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String save(VideoOrderDto videoOrderDto) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、查找商品信息（这里商品指的是视频课程）&lt;/span&gt;
        Video video =&lt;span&gt;  videoMapper.findById(videoOrderDto.getVideoId());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、查找用户信息&lt;/span&gt;
        User user =&lt;span&gt; userMapper.findByid(videoOrderDto.getUserId());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、生成订单，插入数据库&lt;/span&gt;
        VideoOrder videoOrder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VideoOrder();
        videoOrder.setTotalFee(video.getPrice());
        videoOrder.setVideoImg(video.getCoverImg());
        videoOrder.setVideoTitle(video.getTitle());
        videoOrder.setCreateTime(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
        videoOrder.setVideoId(video.getId());
        videoOrder.setState(&lt;/span&gt;0&lt;span&gt;);
        videoOrder.setUserId(user.getId());
        videoOrder.setHeadImg(user.getHeadImg());
        videoOrder.setNickname(user.getName());
        videoOrder.setDel(&lt;/span&gt;0&lt;span&gt;);
        videoOrder.setIp(videoOrderDto.getIp());
        videoOrder.setOutTradeNo(CommonUtils.generateUUID());

        videoOrderMapper.insert(videoOrder);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、获取codeurl&lt;/span&gt;
        String codeUrl =&lt;span&gt; unifiedOrder(videoOrder);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; codeUrl;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;     3、回调微信统一下单接口,获取codeurl方法主要逻辑&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;微信官方统一下单接口文档说明: &lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1&quot; target=&quot;_blank&quot;&gt;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;(1)  根据接口需求添加所需参数:比如appid,mch_id,body等等......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）sign签名获取：具体获取规则官方已经说明: &lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_3&quot; target=&quot;_blank&quot;&gt;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_3&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  (3) 通过工具类将map集合转为xml格式字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）回调微信统一下单接口，接口地址：https://api.mch.weixin.qq.com/pay/unifiedorder&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（&lt;span&gt;5）如果上一步成功（成功标志返回SUSSCUSS),则将返回成功的xml格式再通过工具类转为map&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）通过key=code_url,获取value字符串，这也是最终生成二维码的字符串。code_url格式大致为:weixin://wxpay/s/An4baqw&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接下来只要将code_url值变成二维码就可以供用户扫码付款了。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;    4、测试&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  调用http://localhost:8081/api/v1/order/buy?video_id=1接口&lt;/p&gt;
&lt;p&gt;  成功返回二维码：code_url有效期是两个小时&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201809/1090617-20180926230511616-1787872663.png&quot; alt=&quot;&quot; width=&quot;506&quot; height=&quot;346&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 微信扫码之后：看到具体信息&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201809/1090617-20180926230810010-81258548.png&quot; alt=&quot;&quot; width=&quot;212&quot; height=&quot;377&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看数据库该商品信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201809/1090617-20180926230947569-189443587.png&quot; alt=&quot;&quot; width=&quot;638&quot; height=&quot;39&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;github源码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;github: &lt;/strong&gt;&lt;/span&gt;&lt;a href=&quot;https://github.com/yudiandemingzi/wechatpay&quot; target=&quot;_blank&quot;&gt;https://github.com/yudiandemingzi/wechatpay&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我只是偶尔安静下来，对过去的种种思忖一番。那些曾经的旧时光里即便有过天真愚钝，也不值得谴责。毕竟，往后的日子，还很长。不断鼓励自己，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;天一亮，又是崭新的起点，又是未知的征程（上校16）&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Wed, 26 Sep 2018 15:15:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>生成付款二维码 一、微信网站扫码支付介绍 1、扫码支付文档 微信开发官方文档:https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_5</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/9708534.html</dc:identifier>
</item>
<item>
<title>适配iPhoneX、iPhoneXs、iPhoneXs Max、iPhoneXr 屏幕尺寸及安全区域 - 布袋</title>
<link>http://www.cnblogs.com/apiapia/p/9710703.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/apiapia/p/9710703.html</guid>
<description>&lt;p class=&quot;line&quot; data-line=&quot;0&quot;&gt;此篇文章是对上一篇文章（&lt;a href=&quot;http://www.ifiero.com/index.php/archives/611&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;http://www.ifiero.com/index.php/archives/611&lt;/a&gt;）的进一步补充，主要说明如何适配Apple的最新三款手机iPhoneXs、iPhoneXs Max及iPhoneXr !!!&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-13f9263bca17b7f4?imageMogr2/auto-orient/strip&quot; alt=&quot;未适配前:Ball球超过屏幕的上下方&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/3896436-13f9263bca17b7f4?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;p&gt;未适配前:Ball球超过屏幕的上下方&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-db4b19b91127eaf5?imageMogr2/auto-orient/strip&quot; alt=&quot;适配后:Ball球就在屏幕的可视范围内运动了&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/3896436-db4b19b91127eaf5?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;p&gt;适配后:Ball球就在屏幕的可视范围内运动了&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;line&quot; data-line=&quot;7&quot;&gt;回顾：为何要把场景中的所有图片, 都按照屏幕大小为 2048 * 1536 来绘制。 也就是说, 我们的背景图的大小是 2048 * 1536, 其他图片也是依照这个比例来绘制。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;9&quot;&gt;为什么这样做呢?&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;11&quot;&gt;我们知道 2048 * 1536 是iPad Retina 的分辨率。也是我们需要适配的设备里面分辨率最高的。 所以我们在游戏中都选择了这个大小，让它来兼容分辨率低的设备。 2048 * 1536 在iPad Retina上是完美显示的。 那在其他设备上呢? 先用 AspectFill来进行缩放，并应用相应的屏幕辨率高宽比值Ratio， 来适配各个不同的iPhone尺寸。AspectFill缩放的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if &lt;span class=&quot;hljs-keyword&quot;&gt;let scene = GameScene(fileNamed: &lt;span class=&quot;hljs-string&quot;&gt;&quot;GameScene&quot;) {
                scene.size = CGSize(width: &lt;span class=&quot;hljs-number&quot;&gt;2048, &lt;span class=&quot;hljs-attr&quot;&gt;height: &lt;span class=&quot;hljs-number&quot;&gt;1536)
                scene.scaleMode = .aspectFill &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;了解了用 AspectFill来进行缩放，那么我们现在就来看看iPhoneX的屏幕尺寸分辨率&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-93d1b3b3fe1641ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;以iPhoneX的分辨率为例,SafeArea为安全区域&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/3896436-93d1b3b3fe1641ac.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以iPhoneX的分辨率为例,SafeArea为安全区域&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;line&quot; data-line=&quot;24&quot;&gt;iPhoneX的屏幕尺寸分辨率(上图中 高度812 = 2436缩小1/3)：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;设备&lt;/th&gt;
&lt;th&gt;屏幕尺寸分辨率&lt;/th&gt;
&lt;th&gt;图片存放对应的位置&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;iPhoneX (1倍 @1x)&lt;/td&gt;
&lt;td&gt;375×812&lt;/td&gt;
&lt;td&gt;@1x&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;iPhoneX (2倍 @2x)&lt;/td&gt;
&lt;td&gt;750×1624&lt;/td&gt;
&lt;td&gt;@2x&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;iPhoneX (3倍 @3x)&lt;/td&gt;
&lt;td&gt;1125×2436&lt;/td&gt;
&lt;td&gt;@3x&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;iPhoneX/iPhoneXs/iPhoneXs Max/iPhoneXr的屏幕尺寸分辨率&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-ad90df3c75fbff74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;iPhoneX系列的分辨率&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/3896436-ad90df3c75fbff74.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;p&gt;iPhoneX系列的分辨率&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;line&quot; data-line=&quot;35&quot;&gt;iPhoneX系列的屏幕分辨率：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;设备&lt;/th&gt;
&lt;th&gt;屏幕分辨率&lt;/th&gt;
&lt;th&gt;图片存放的位置&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;iPhoneX (3倍 @3x)&lt;/td&gt;
&lt;td&gt;1125×2436&lt;/td&gt;
&lt;td&gt;@3x&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;iPhoneXs (3倍 @3x)&lt;/td&gt;
&lt;td&gt;1125×2436&lt;/td&gt;
&lt;td&gt;@3x&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;iPhoneXs Max (3倍 @3x)&lt;/td&gt;
&lt;td&gt;1242×2688&lt;/td&gt;
&lt;td&gt;@3x&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;iPhoneXr (2倍 @2x)&lt;/td&gt;
&lt;td&gt;828×1792&lt;/td&gt;
&lt;td&gt;@2x&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;根据以上iPhoneX系列的屏幕分辨率，得出高宽比Ratio都为2.16&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-8d694e58713d1afc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;各款iPhone的屏幕分辨比率&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/3896436-8d694e58713d1afc.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;p&gt;各款iPhone的屏幕分辨比率&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;line&quot; data-line=&quot;47&quot;&gt;橙色整体区域表示我们场景的真实大小, 用 AspectFill来进行缩放后，scene.scaleMode = .aspectFill，黑色线框内的区域表示场景展示在设备上的真实大小（即屏幕可视范围）。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;49&quot;&gt;iPad Retina：橙色区域和黑色线框内的区域是完美吻合的,也就是说在设备上能完整显示。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;51&quot;&gt;iPhone6/7/8/Plus：黑色线框内的区域是2048 * 1152，这边要注意的是，超出黑色框的内容看不见，设计游戏时，尽量不要把精灵的Position位置放在位于不可见的区域。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;53&quot;&gt;iPhoneX：黑色线框内的区域是2048 * 948(兰色为安全区域)，其中948高度=2048 / 2.16(高宽比)。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;55&quot;&gt;不同尺寸的iPhone的屏幕尺寸比例及屏幕高宽比值&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;设备&lt;/th&gt;
&lt;th&gt;屏幕比例&lt;/th&gt;
&lt;th&gt;屏幕高宽比值&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;iPad Retina&lt;/td&gt;
&lt;td&gt;4 / 3&lt;/td&gt;
&lt;td&gt;1.33&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;iPhone 6/7/8&lt;/td&gt;
&lt;td&gt;16 / 9&lt;/td&gt;
&lt;td&gt;1.77&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;iPhone 6/7/8 Plus&lt;/td&gt;
&lt;td&gt;16 / 9&lt;/td&gt;
&lt;td&gt;1.77&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;iPhone X/Xs/Xr/Xs Max&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;2.16&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;line&quot; data-line=&quot;63&quot;&gt;再者我们主要是适配SpriteKit游戏开发，因为不需要计算Navigation导航栏的高度，也不需要TabBar状态栏的高度，只需要计算可视区域（屏幕可视范围），还有，注意要把需要交互的元素放在安全区域SafeArea，而不要放在危险区域 Danger Area就行了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;可视区域（屏幕可视范围）= 安全区域 Safe Area + 危险区域 Danger Area&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;line&quot; data-line=&quot;67&quot;&gt;了解了原理后，我们就开始来编写代码吧。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;69&quot;&gt;1.extension拓展UIDevice,判断设备是iPhone或者iPhoneX系列或iPad&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs objectivec&quot;&gt;import &lt;span class=&quot;hljs-built_in&quot;&gt;UIKit
import SpriteKit

&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p class=&quot;line&quot; data-line=&quot;98&quot;&gt;2.检测是哪种设备&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs objectivec&quot;&gt;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p class=&quot;line&quot; data-line=&quot;113&quot;&gt;3.画出安全区域&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt; // MARK: - 安全区域即用户交互的区域，非可视区域 (iPhoneX的安全区域 &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt; 可视区域)
    &lt;span class=&quot;hljs-attr&quot;&gt;func &lt;span class=&quot;hljs-attr&quot;&gt;drawSafeArea(&lt;span class=&quot;hljs-attr&quot;&gt;size:CGSize,&lt;span class=&quot;hljs-attr&quot;&gt;ratio:CGFloat){
        
        &lt;span class=&quot;hljs-attr&quot;&gt;playableHeight  = &lt;span class=&quot;hljs-string&quot;&gt;size.width / &lt;span class=&quot;hljs-attr&quot;&gt;ratio
        &lt;span class=&quot;hljs-attr&quot;&gt;playableMargin = &lt;span class=&quot;hljs-string&quot;&gt;(size.height &lt;span class=&quot;hljs-attr&quot;&gt;- &lt;span class=&quot;hljs-attr&quot;&gt;playableHeight ) / &lt;span class=&quot;hljs-attr&quot;&gt;2.0   /// &lt;span class=&quot;hljs-attr&quot;&gt;P70
        
        &lt;span class=&quot;hljs-attr&quot;&gt;let &lt;span class=&quot;hljs-attr&quot;&gt;safeInsetLeft   =  &lt;span class=&quot;hljs-string&quot;&gt;AREA_INSET_WIDTH_LEFT * &lt;span class=&quot;hljs-attr&quot;&gt;ratio
        &lt;span class=&quot;hljs-attr&quot;&gt;let &lt;span class=&quot;hljs-attr&quot;&gt;safeInsetRight  =  &lt;span class=&quot;hljs-string&quot;&gt;size.width &lt;span class=&quot;hljs-attr&quot;&gt;- &lt;span class=&quot;hljs-attr&quot;&gt;safeInsetLeft &lt;span class=&quot;hljs-attr&quot;&gt;- &lt;span class=&quot;hljs-attr&quot;&gt;AREA_INSET_WIDTH_RIGHT * &lt;span class=&quot;hljs-attr&quot;&gt;ratio
        
        &lt;span class=&quot;hljs-attr&quot;&gt;playableRect = &lt;span class=&quot;hljs-string&quot;&gt;CGRect(x: &lt;span class=&quot;hljs-attr&quot;&gt;safeInsetLeft, &lt;span class=&quot;hljs-attr&quot;&gt;y: &lt;span class=&quot;hljs-attr&quot;&gt;playableMargin, &lt;span class=&quot;hljs-attr&quot;&gt;width:safeInsetRight, &lt;span class=&quot;hljs-attr&quot;&gt;height:  &lt;span class=&quot;hljs-attr&quot;&gt;playableHeight)  /// 注意 &lt;span class=&quot;hljs-attr&quot;&gt;scene的&lt;span class=&quot;hljs-attr&quot;&gt;anchorPoint(&lt;span class=&quot;hljs-attr&quot;&gt;0,&lt;span class=&quot;hljs-attr&quot;&gt;0)原点的位置;
        &lt;span class=&quot;hljs-attr&quot;&gt;let &lt;span class=&quot;hljs-attr&quot;&gt;shapeFrame = &lt;span class=&quot;hljs-string&quot;&gt;SKShapeNode(rect: &lt;span class=&quot;hljs-attr&quot;&gt;playableRect)
        &lt;span class=&quot;hljs-attr&quot;&gt;shapeFrame.zPosition = &lt;span class=&quot;hljs-string&quot;&gt;2
        &lt;span class=&quot;hljs-attr&quot;&gt;shapeFrame.strokeColor = &lt;span class=&quot;hljs-string&quot;&gt;SKColor.green
        &lt;span class=&quot;hljs-attr&quot;&gt;shapeFrame.lineWidth = &lt;span class=&quot;hljs-string&quot;&gt;6.0
        &lt;span class=&quot;hljs-attr&quot;&gt;addChild(&lt;span class=&quot;hljs-attr&quot;&gt;shapeFrame)
        
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p class=&quot;line&quot; data-line=&quot;133&quot;&gt;4.画出可视区域并赋于可视区域的边届物理特性&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs objectivec&quot;&gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样子Ball球就只在可视区域内（屏幕可视范围）运动了。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-27aefc7a764a64b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;适配iPhoneXs Max&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/3896436-27aefc7a764a64b3.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;p&gt;适配iPhoneXs Max&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;line&quot; data-line=&quot;166&quot;&gt;重要的一点就是要了解屏幕尺寸和安全区域的不同，通俗点讲就是，屏幕可视范围可以放任何元素，但所有的用户交互行为都要放在安全区域内(兰色框内)。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;168&quot;&gt;即可视区域（屏幕可视范围）= 安全区域 Safe Area + 危险区域 Danger Area&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;168&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;170&quot;&gt;源码传送门： &lt;a href=&quot;https://github.com/apiapia/BreakOutGameVansVTutorial&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://github.com/apiapia/BreakOutGameVansVTutorial&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;170&quot;&gt;更多游戏教学：http://www.iFIERO.com&lt;/p&gt;
</description>
<pubDate>Wed, 26 Sep 2018 15:14:00 +0000</pubDate>
<dc:creator>布袋</dc:creator>
<og:description>适配Apple的最新三款手机iPhoneXs、iPhoneXs Max及iPhoneXr。2048 * 1536 是iPad Retina 的分辨率。也是我们需要适配的设备里面分辨率最高的。 所以我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/apiapia/p/9710703.html</dc:identifier>
</item>
<item>
<title>Java SpringBoot集成RabbitMq实战和总结 - 陈芳志</title>
<link>http://www.cnblogs.com/chenfangzhi/p/9710698.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenfangzhi/p/9710698.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;在公司里一直在用RabbitMQ，由于api已经封装的很简单，关于RabbitMQ本身还有封装的实现没有了解，最近在看RabbitMQ实战这本书，结合网上的一些例子和spring文档，实现了RabbitMQ和spring的集成，对着自己平时的疑惑做了一些总结。&lt;br/&gt;关于RabbitMQ基础不在详细讲解(本文不适合RabbitMq零基础)，&lt;a href=&quot;https://book.douban.com/subject/26649178/&quot;&gt;RabbitMQ实战&lt;/a&gt;的1,2,4三章讲的非常不错。因为书中讲的都是Python和Php的例子，所以自己结合SpringBoot文档和&lt;a href=&quot;https://blog.csdn.net/u013256816&quot;&gt;朱小厮的博客&lt;/a&gt;做了一些总结，写了一些Springboot的&lt;a href=&quot;https://github.com/chenfangzhi123/javainaction/tree/master/rabbit-mq-spring-boot&quot;&gt;例子&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;交换器队列绑定的声明&quot;&gt;交换器、队列、绑定的声明&lt;/h2&gt;
&lt;p&gt;SpringAMQP项目对RabbitMQ做了很好的封装，可以很方便的手动声明队列，交换器，绑定。如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 队列
     * @return
     */
    @Bean
    @Qualifier(RabbitMQConstant.PROGRAMMATICALLY_QUEUE)
    Queue queue() {
        return new Queue(RabbitMQConstant.PROGRAMMATICALLY_QUEUE, false, false, true);
    }

    /**
     * 交换器
     * @return
     */
    @Bean
    @Qualifier(RabbitMQConstant.PROGRAMMATICALLY_EXCHANGE)
    TopicExchange exchange() {
        return new TopicExchange(RabbitMQConstant.PROGRAMMATICALLY_EXCHANGE, false, true);
    }
    /**
     * 声明绑定关系
     * @return
     */
    @Bean
    Binding binding(@Qualifier(RabbitMQConstant.PROGRAMMATICALLY_EXCHANGE) TopicExchange exchange,
                    @Qualifier(RabbitMQConstant.PROGRAMMATICALLY_QUEUE) Queue queue) {
        return BindingBuilder.bind(queue).to(exchange).with(RabbitMQConstant.PROGRAMMATICALLY_KEY);
    }

    /**
     * 声明简单的消费者，接收到的都是原始的{@link Message}
     *
     * @param connectionFactory
     *
     * @return
     */
    @Bean
    SimpleMessageListenerContainer simpleContainer(ConnectionFactory connectionFactory) {
        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        container.setMessageListener(message -&amp;gt; log.info(&quot;simple receiver,message:{}&quot;, message));
        container.setQueueNames(RabbitMQConstant.PROGRAMMATICALLY_QUEUE);
        return container;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;消费者和生产者都可以声明，交换器这种一般经常创建，可以手动创建。需要注意对于没有路由到队列的消息会被丢弃。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果是Spring的话还需要声明连接：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Bean
    ConnectionFactory connectionFactory(@Value(&quot;${spring.rabbitmq.port}&quot;) int port,
                                        @Value(&quot;${spring.rabbitmq.host}&quot;) String host,
                                        @Value(&quot;${spring.rabbitmq.username}&quot;) String userName,
                                        @Value(&quot;${spring.rabbitmq.password}&quot;) String password,
                                        @Value(&quot;${spring.rabbitmq.publisher-confirms}&quot;) boolean isConfirm,
                                        @Value(&quot;${spring.rabbitmq.virtual-host}&quot;) String vhost) {
        CachingConnectionFactory connectionFactory = new CachingConnectionFactory();
        connectionFactory.setHost(host);
        connectionFactory.setVirtualHost(vhost);
        connectionFactory.setPort(port);
        connectionFactory.setUsername(userName);
        connectionFactory.setPassword(password);
        connectionFactory.setPublisherConfirms(isConfirm);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在配置类使用&lt;code&gt;@EnableRabbit&lt;/code&gt;的情况下，也可以基于注解进行声明，在Bean的方法上加上&lt;code&gt;@RabbitListener&lt;/code&gt;，如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 可以直接通过注解声明交换器、绑定、队列。但是如果声明的和rabbitMq中已经存在的不一致的话
     * 会报错便于测试，我这里都是不使用持久化，没有消费者之后自动删除
     * {@link RabbitListener}是可以重复的。并且声明队列绑定的key也可以有多个.
     *
     * @param headers
     * @param msg
     */
    @RabbitListener(
        bindings = @QueueBinding(
            exchange = @Exchange(value = RabbitMQConstant.DEFAULT_EXCHANGE, type = ExchangeTypes.TOPIC,
                durable = RabbitMQConstant.FALSE_CONSTANT, autoDelete = RabbitMQConstant.true_CONSTANT),
            value = @Queue(value = RabbitMQConstant.DEFAULT_QUEUE, durable = RabbitMQConstant.FALSE_CONSTANT,
                autoDelete = RabbitMQConstant.true_CONSTANT),
            key = DKEY
        ),
        //手动指明消费者的监听容器，默认Spring为自动生成一个SimpleMessageListenerContainer
        containerFactory = &quot;container&quot;,
        //指定消费者的线程数量,一个线程会打开一个Channel，一个队列上的消息只会被消费一次（不考虑消息重新入队列的情况）,下面的表示至少开启5个线程，最多10个。线程的数目需要根据你的任务来决定，如果是计算密集型，线程的数目就应该少一些
        concurrency = &quot;5-10&quot;
    )
    public void process(@Headers Map&amp;lt;String, Object&amp;gt; headers, @Payload ExampleEvent msg) {
        log.info(&quot;basic consumer receive message:{headers = [&quot; + headers + &quot;], msg = [&quot; + msg + &quot;]}&quot;);
    }

    /**
     * {@link Queue#ignoreDeclarationExceptions}声明队列会忽略错误不声明队列，这个消费者仍然是可用的
     *
     * @param headers
     * @param msg
     */
    @RabbitListener(queuesToDeclare = @Queue(value = RabbitMQConstant.DEFAULT_QUEUE, ignoreDeclarationExceptions = RabbitMQConstant.true_CONSTANT))
    public void process2(@Headers Map&amp;lt;String, Object&amp;gt; headers, @Payload ExampleEvent msg) {
        log.info(&quot;basic2 consumer receive message:{headers = [&quot; + headers + &quot;], msg = [&quot; + msg + &quot;]}&quot;);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;关于消息序列化&quot;&gt;关于消息序列化&lt;/h2&gt;
&lt;p&gt;这个比较简单,默认采用了Java序列化，我们一般使用的Json格式，所以配置了Jackson，根据自己的情况来，直接贴代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Bean
    MessageConverter messageConverter() {
        return new Jackson2JsonMessageConverter();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;同一个队列多消费类型&quot;&gt;同一个队列多消费类型&lt;/h2&gt;
&lt;p&gt;如果是同一个队列多个消费类型那么就需要针对每种类型提供一个消费方法，否则找不到匹配的方法会报错，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
@Slf4j
@RabbitListener(
    bindings = @QueueBinding(
        exchange = @Exchange(value = RabbitMQConstant.MULTIPART_HANDLE_EXCHANGE, type = ExchangeTypes.TOPIC,
            durable = RabbitMQConstant.FALSE_CONSTANT, autoDelete = RabbitMQConstant.true_CONSTANT),
        value = @Queue(value = RabbitMQConstant.MULTIPART_HANDLE_QUEUE, durable = RabbitMQConstant.FALSE_CONSTANT,
            autoDelete = RabbitMQConstant.true_CONSTANT),
        key = RabbitMQConstant.MULTIPART_HANDLE_KEY
    )
)
@Profile(SpringConstant.MULTIPART_PROFILE)
public class MultipartConsumer {

    /**
     * RabbitHandler用于有多个方法时但是参数类型不能一样，否则会报错
     *
     * @param msg
     */
    @RabbitHandler
    public void process(ExampleEvent msg) {
        log.info(&quot;param:{msg = [&quot; + msg + &quot;]} info:&quot;);
    }

    @RabbitHandler
    public void processMessage2(ExampleEvent2 msg) {
        log.info(&quot;param:{msg2 = [&quot; + msg + &quot;]} info:&quot;);
    }

    /**
     * 下面的多个消费者，消费的类型不一样没事，不会被调用，但是如果缺了相应消息的处理Handler则会报错
     *
     * @param msg
     */
    @RabbitHandler
    public void processMessage3(ExampleEvent3 msg) {
        log.info(&quot;param:{msg3 = [&quot; + msg + &quot;]} info:&quot;);
    }


}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;注解将消息和消息头注入消费者方法&quot;&gt;注解将消息和消息头注入消费者方法&lt;/h2&gt;
&lt;p&gt;在上面也看到了&lt;code&gt;@Payload&lt;/code&gt;等注解用于注入消息。这些注解有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@Header 注入消息头的单个属性&lt;/li&gt;
&lt;li&gt;@Payload 注入消息体到一个JavaBean中&lt;/li&gt;
&lt;li&gt;@Headers 注入所有消息头到一个Map中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里有一点主要注意，如果是&lt;code&gt;com.rabbitmq.client.Channel&lt;/code&gt;,&lt;code&gt;org.springframework.amqp.core.Message&lt;/code&gt;和&lt;code&gt;org.springframework.messaging.Message&lt;/code&gt;这些类型，可以不加注解，直接可以注入。&lt;br/&gt;如果不是这些类型，那么不加注解的参数将会被当做消息体。不能多于一个消息体。如下方法ExampleEvent就是默认的消息体：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void process2(@Headers Map&amp;lt;String, Object&amp;gt; headers,ExampleEvent msg);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;关于消费者确认&quot;&gt;关于消费者确认&lt;/h2&gt;
&lt;p&gt;RabbitMq消费者可以选择手动和自动确认两种模式，如果是自动，消息已到达队列，RabbitMq对无脑的将消息抛给消费者，一旦发送成功，他会认为消费者已经成功接收，在RabbitMq内部就把消息给删除了。另外一种就是手动模式，手动模式需要消费者对每条消息进行确认(也可以批量确认)，RabbitMq发送完消息之后，会进入到一个待确认(unacked)的队列，如下图红框部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pewaccq76.bkt.clouddn.com/201809262010_450.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果消费者发送了ack，RabbitMq将会把这条消息从待确认中删除。如果是nack并且指明不要重新入队列，那么该消息也会删除。但是如果是nack且指明了重新入队列那么这条消息将会入队列，然后重新发送给消费者，被重新投递的消息消息头amqp_redelivered属性会被设置成true，客户端可以依靠这点来判断消息是否被确认,可以好好利用这一点，如果每次都重新回队列会导致同一消息不停的被发送和拒绝。消费者在确认消息之前和RabbitMq失去了连接那么消息也会被重新投递。所以手动确认模式很大程度上提高可靠性。自动模式的消息可以提高吞吐量。&lt;/p&gt;
&lt;p&gt;spring手动确认消息需要将&lt;code&gt;SimpleRabbitListenerContainerFactory&lt;/code&gt;设置为手动模式：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        simpleRabbitListenerContainerFactory.setAcknowledgeMode(AcknowledgeMode.MANUAL);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手动确认的消费者代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SneakyThrows
    @RabbitListener(bindings = @QueueBinding(
        exchange = @Exchange(value = RabbitMQConstant.CONFIRM_EXCHANGE, type = ExchangeTypes.TOPIC,
            durable = RabbitMQConstant.FALSE_CONSTANT, autoDelete = RabbitMQConstant.true_CONSTANT),
        value = @Queue(value = RabbitMQConstant.CONFIRM_QUEUE, durable = RabbitMQConstant.FALSE_CONSTANT,
            autoDelete = RabbitMQConstant.true_CONSTANT),
        key = RabbitMQConstant.CONFIRM_KEY),
        containerFactory = &quot;containerWithConfirm&quot;)
    public void process(ExampleEvent msg, Channel channel, @Header(name = &quot;amqp_deliveryTag&quot;) long deliveryTag,
                        @Header(&quot;amqp_redelivered&quot;) boolean redelivered, @Headers Map&amp;lt;String, String&amp;gt; head) {
        try {
            log.info(&quot;ConsumerWithConfirm receive message:{},header:{}&quot;, msg, head);
            channel.basicAck(deliveryTag, false);
        } catch (Exception e) {
            log.error(&quot;consume confirm error!&quot;, e);
            //这一步千万不要忘记，不会会导致消息未确认，消息到达连接的qos之后便不能再接收新消息
            //一般重试肯定的有次数，这里简单的根据是否已经重发过来来决定重发。第二个参数表示是否重新分发
            channel.basicReject(deliveryTag, !redelivered);
            //这个方法我知道的是比上面多一个批量确认的参数
            // channel.basicNack(deliveryTag, false,!redelivered);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于spring的AcknowledgeMode需要说明，他一共有三种模式：NONE,MANUAL,AUTO,默认是AUTO模式。这比RabbitMq原生多了一种。这一点很容易混淆，这里的NONE对应其实就是RabbitMq的自动确认，MANUAL是手动。而AUTO其实也是手动模式，只不过是Spring的一层封装，他根据你方法执行的结果自动帮你发送ack和nack。如果方法未抛出异常，则发送ack。如果方法抛出异常，并且不是&lt;code&gt;AmqpRejectAndDontRequeueException&lt;/code&gt;则发送nack，并且重新入队列。如果抛出异常时&lt;code&gt;AmqpRejectAndDontRequeueException&lt;/code&gt;则发送nack不会重新入队列。我有一个例子专门测试NONE，见&lt;code&gt;CunsumerWithNoneTest&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;还有一点需要注意的是消费者有一个参数prefetch，它表示的是一个Channel(也就是SimpleMessageListenerContainer的一个线程)预取的消息数量，这个参数只会在手动确认的消费者才生效。可以客户端利用这个参数来提高性能和做流量控制。如果prefetch设置的是10,当这个Channel上unacked的消息数量到达10条时，RabbitMq便不会在向你发送消息，客户端如果处理的慢，便可以延迟确认在方法消息的接收。至于提高性能就非常容易理解，因为这个是批量获取消息，如果客户端处理的很快便不用一个一个去等着去新的消息。SpringAMQP2.0开始默认是250,这个参数应该已经足够了。注意之前的版本默认值是1所以有必要重新设置一下值。当然这个值也不能设置的太大，RabbitMq是通过round robin这个策略来做负载均衡的，如果设置的太大会导致消息不多时一下子积压到一台消费者，不能很好的均衡负载。另外如果消息数据量很大也应该适当减小这个值，这个值过大会导致客户端内存占用问题。如果你用到了事务的话也需要考虑这个值的影响，因为事务的用处不大，所以我也没做过多的深究。&lt;/p&gt;
&lt;h2 id=&quot;关于发送者确认模式&quot;&gt;关于发送者确认模式&lt;/h2&gt;
&lt;p&gt;考虑这样一个场景：你发送了一个消息给RabbitMq，RabbitMq接收了但是存入磁盘之前服务器就挂了，消息也就丢了。为了保证消息的投递有两种解决方案，最保险的就是事务（和DB的事务没有太大的可比性）， 但是因为事务会极大的降低性能，会导致生产者和RabbitMq之间产生同步(等待确认)，这也违背了我们使用RabbitMq的初衷。所以一般很少采用，这就引入第二种方案：发送者确认模式。&lt;/p&gt;
&lt;p&gt;发送者确认模式是指发送方发送的消息都带有一个id，RabbitMq会将消息持久化到磁盘之后通知生产者消息已经成功投递，如果因为RabbitMq内部的错误会发送ack。注意这里的发送者和RabbitMq之间是异步的，所以相较于事务机制性能大大提高。其实很多操作都是不能保证绝对的百分之一百的成功，哪怕采用了事务也是如此，可靠性和性能很多时候需要做一些取舍，想很多互联网公司吹嘘的5个9，6个9也是一样的道理。如果不是重要的消息性能计数器，完全可以不采用发送者确认模式。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这里有一点我当时纠结了很久，我一直以为发送者确认模式的回调是客户端的ack触发的，这里是大大的误解！发送者确认模式和消费者没有一点关系，消费者确认也和发送者没有一点关系，两者都是在和RabbitMq打交道，发送者不会管消费者有没有收到，只要消息到了RabbitMq并且已经持久化便会通知生产者，这个ack是RabbitMq本身发出的，和消费者无关&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;发送者确认模式需要将Channel设置成Confirm模式，这样才会收到通知。Spring中需要将连接设置成Confirm模式：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;connectionFactory.setPublisherConfirms(isConfirm);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在RabbitTemplate中设置确认的回调,correlationData是消息的id，如下（只是简单打印下）:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    // 设置RabbitTemplate每次发送消息都会回调这个方法
        rabbitTemplate.setConfirmCallback((correlationData, ack, cause)
            -&amp;gt; log.info(&quot;confirm callback id:{},ack:{},cause:{}&quot;, correlationData, ack, cause));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发送时需要给出唯一的标识(&lt;code&gt;CorrelationData&lt;/code&gt;):&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    rabbitTemplateWithConfirm.convertAndSend(RabbitMQConstant.DEFAULT_EXCHANGE, RabbitMQConstant.DEFAULT_KEY,
                new ExampleEvent(i, &quot;confirm message id:&quot; + i),
                new CorrelationData(Integer.toString(i)));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有一个参数需要说下：mandatory。这个参数为true表示如果发送消息到了RabbitMq，没有对应该消息的队列。那么会将消息返回给生产者，此时仍然会发送ack确认消息。&lt;/p&gt;
&lt;p&gt;设置RabbitTemplate的回调如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey)
            -&amp;gt; log.info(&quot;return callback message：{},code:{},text:{}&quot;, message, replyCode, replyText));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外如果是RabbitMq内部的错误，不会调用该方法。所以如果消息特别重要，对于未确认的消息，生产者应该在内存用保存着，在确认时候根据返回的id删除该消息。如果是nack可以将该消息记录专门的日志或者转发到相应处理的逻辑进行后续补偿。RabbitTemplate也可以配置RetryTemplate，发送失败时直接进行重试，具体还是要结合业务。&lt;/p&gt;
&lt;p&gt;最后关于发送者确认需要提的是spring，因为spring默认的Bean是单例的，所以针对不同的确认方案(其实有不同的确认方案是比较合理的，很多消息不需要确认，有些需要确认)需要配置不同的bean.&lt;/p&gt;
&lt;h2 id=&quot;消费消息死信队列和retrytemplate&quot;&gt;消费消息、死信队列和RetryTemplate&lt;/h2&gt;
&lt;p&gt;上面也提到了如果消费者抛出异常时默认的处理逻辑。另外我们还可以给消费者配置RetryTemplate，如果是采用SpringBoot的话，可以在application.yml配置中配置如下：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;spring:
  rabbitmq:
    listener:
       retry:
    #    重试次数
          max-attempts: 3
        #   开启重试机制
          enabled: true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，如果消费者失败的话会进行重试，默认是3次。&lt;em&gt;注意这里的重试机制RabbitMq是为感知的&lt;/em&gt;！到达3次之后会抛出异常调用&lt;code&gt;MessageRecoverer&lt;/code&gt;。默认的实现为RejectAndDontRequeueRecoverer，也就是打印异常，发送nack，不会重新入队列。&lt;br/&gt;我想既然配置了重试机制消息肯定是很重要的，消息肯定不能丢，仅仅是日志可能会因为日志滚动丢失而且信息不明显，所以我们要讲消息保存下来。可以有如下这些方案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用RepublishMessageRecoverer这个MessageRecoverer会发送发送消息到指定队列&lt;/li&gt;
&lt;li&gt;给队列绑定死信队列，因为默认的RepublishMessageRecoverer会发送nack并且requeue为false。这样抛出一场是这种方式和上面的结果一样都是转发到了另外一个队列。详见DeadLetterConsumer&lt;/li&gt;
&lt;li&gt;注册自己实现的MessageRecoverer&lt;/li&gt;
&lt;li&gt;给MessageListenerContainer设置RecoveryCallback&lt;/li&gt;
&lt;li&gt;对于方法手动捕获异常，进行处理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我比较推荐前两种。这里说下死信队列，死信队列其实就是普通的队列，只不过一个队列声明的时候指定的属性，会将死信转发到该交换器中。声明死信队列方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @RabbitListener(
        bindings = @QueueBinding(
            exchange = @Exchange(value = RabbitMQConstant.DEFAULT_EXCHANGE, type = ExchangeTypes.TOPIC,
                durable = RabbitMQConstant.FALSE_CONSTANT, autoDelete = RabbitMQConstant.true_CONSTANT),
            value = @Queue(value = RabbitMQConstant.DEFAULT_QUEUE, durable = RabbitMQConstant.FALSE_CONSTANT,
                autoDelete = RabbitMQConstant.true_CONSTANT, arguments = {
                @Argument(name = RabbitMQConstant.DEAD_LETTER_EXCHANGE, value = RabbitMQConstant.DEAD_EXCHANGE),
                @Argument(name = RabbitMQConstant.DEAD_LETTER_KEY, value = RabbitMQConstant.DEAD_KEY)
            }),
            key = RabbitMQConstant.DEFAULT_KEY
        ))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实也就只是在声明的时候多加了两个参数x-dead-letter-exchange和x-dead-letter-routing-key。这里一开始踩了一个坑，因为&lt;code&gt;@QueueBinding&lt;/code&gt;注解中也有arguments属性，我一开始将参数声明到&lt;code&gt;@QueueBinding&lt;/code&gt;中，导致一直没绑定成功。如果绑定成功可以在控制台看到queue的Featrues有DLX(死信队列交换器)和DLK(死信队列绑定)。如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pewaccq76.bkt.clouddn.com/201809262129_364.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u013256816/article/details/54933065&quot;&gt;关于消息进入死信的规则&lt;/a&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;消息被拒绝(basic.reject/basic.nack)并且requeue=false&lt;/li&gt;
&lt;li&gt;消息TTL过期&lt;/li&gt;
&lt;li&gt;队列达到最大长度&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们用到的就是第一种。&lt;/p&gt;
&lt;h2 id=&quot;rpc模式的消息不常用&quot;&gt;RPC模式的消息（不常用）&lt;/h2&gt;
&lt;p&gt;本来生产者和消费者是没有耦合的，但是可以通过一些属性产生耦合。在早期版本中，如果一个生产者想要收到消费者的回复，实现方案是生产者在消息头中加入reply-to属性也就是队列(一般是私有，排他，用完即销毁)的名字，然后在这个队列上进行监听，消费者将回复发送到这个队列中。RabbitMq3.3之后有了改进，就是不用没有都去创建一个临时队列，这样很耗费性能，可以采用drect-to模式，省去了每次创建队列的性能损耗，但是还是要创建一次队列。现在Spring默认的就是这个模式。RabbitTemplate中有一系列的&lt;code&gt;sendAndReceiveXX&lt;/code&gt;方法。默认等待5秒，超时返回null。用&lt;br/&gt;法和不带返回的差不多。&lt;/p&gt;
&lt;p&gt;消费者的方法通过返回值直接返回消息(下面的方法是有返回值的)：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  public String receive(@Headers Map&amp;lt;String, Object&amp;gt; headers, @Payload ExampleEvent msg) {
        log.info(&quot;reply to consumer param:{headers = [&quot; + headers + &quot;], msg = [&quot; + msg + &quot;]} info:&quot;);
        return REPLY;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的提一下最后一个注解&lt;code&gt;@SendTo&lt;/code&gt;,用在消费方法上，指明返回值的目的地，默认不用的话就是返回给发送者，可以通过这个注解改变这种行为。如下代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; @RabbitListener(
        bindings = @QueueBinding(
            exchange = @Exchange(value = RabbitMQConstant.REPLY_EXCHANGE, type = ExchangeTypes.TOPIC,
                durable = RabbitMQConstant.FALSE_CONSTANT, autoDelete = RabbitMQConstant.true_CONSTANT),
            value = @Queue(value = RabbitMQConstant.REPLY_QUEUE, durable = RabbitMQConstant.FALSE_CONSTANT,
                autoDelete = RabbitMQConstant.true_CONSTANT),
            key = RabbitMQConstant.REPLY_KEY
        )
    )
    @SendTo(&quot;queue.reply.s&quot;)
    public ExampleEvent log(ExampleEvent event) {
        log.info(&quot;log receive message:O{}&quot;, event);
        return new ExampleEvent(1, &quot;log result&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码就是会将消息直接发送到默认交换器，并且以queue.reply.s作为路由键。@SendTo的格式为exchange/routingKey用法如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;foo/bar： 指定的交换器和key&lt;/li&gt;
&lt;li&gt;foo/： 指定的交换器，key为空&lt;/li&gt;
&lt;li&gt;bar或者/bar： 到空交换器&lt;/li&gt;
&lt;li&gt;/或者空：空的交换器和空的key&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里还需要提一下，因为默认所有的队列都会绑定到空交换器，并且以队列名字作为Routekey， 所以SendTo里面可以直接填写队列名字机会发送到相应的队列.如日志队列。因为RPC模式不常用，专业的东西做专业的事，就像我们一般不用Redis来做消息队列一样(虽然他也可以实现)，一般公司都有特定的技术栈，肯定有更合适的RPC通信框架。当然如果要跨语言的集成这个方案也是一种不错的方案，可以继续考虑采用异步发送&lt;code&gt;AsyncRabbitTemplate&lt;/code&gt;来降低延迟等优化方案!&lt;/p&gt;
&lt;h2 id=&quot;关于消费模型&quot;&gt;关于消费模型&lt;/h2&gt;
&lt;p&gt;RabbitMQ底层的消费模型有两种Push和Pull。我在网上查阅资料的时候发现有很多教程采用了pull这种模式。RabbitMq实战和&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/u013256816/article/details/62890189&quot;&gt;RabbitMQ之Consumer消费模式（Push &amp;amp; Pull）&lt;/a&gt;都指出这种模式性能低，会影响消息的吞吐量，增加不必要的IO，所以除非有特殊的业务需求，不要采用这种方案。Spring的封装就是采用了push的方案。&lt;/p&gt;
&lt;h2 id=&quot;关于rabbitmq客户端的线程模型&quot;&gt;关于RabbitMq客户端的线程模型&lt;/h2&gt;
&lt;p&gt;这里讲的是消费者的，生产者没什么好讲的。先看消息流转图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pewaccq76.bkt.clouddn.com/201809262319_900.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中椭圆表示线程，矩形是队列。消息到达AMQP的连接线程，然后分发到client线程池，随后分发到监听器。注意除了监听器的线程，其他都是在&lt;code&gt;com.rabbitmq.client.impl.AMQConnection&lt;/code&gt;中创建的线程，我们对线程池做一些修改。连接线程名字不能修改就是AMQP Connection打头。心跳线程可以设置setConnectionThreadFactory来设置名字。如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    connectionFactory.setConnectionThreadFactory(new ThreadFactory() {
            public final AtomicInteger id = new AtomicInteger();

            @Override
            public Thread newThread(Runnable r) {
                return new Thread(r, MessageFormat.format(&quot;amqp-heart-{0}&quot;, id.getAndIncrement()));
            }
        });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;client线程池见：&lt;code&gt;com.rabbitmq.client.impl.ConsumerWorkService&lt;/code&gt;构造方法。Executors.newFixedThreadPool(DEFAULT_NUM_THREADS, threadFactory)。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   final ExecutorService executorService = Executors.newFixedThreadPool(5, new ThreadFactory() {
            public final AtomicInteger id = new AtomicInteger();

            @Override
            public Thread newThread(Runnable r) {
                return new Thread(r, MessageFormat.format(&quot;amqp-client-{0}&quot;, id.getAndIncrement()));
            }
        });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;listener的线程设置如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        simpleRabbitListenerContainerFactory.setTaskExecutor(new SimpleAsyncTaskExecutor&quot;amqp-consumer-&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：SimpleAsyncTaskExecutor每次执行一个任务都会新建一个线程，对于生命周期很短的任务不要使用这个线程池(如client线程池的任务)， 这里的消费者线程生命周期直到SimpleMessageListenerContainer停止所以没有适合这个场景&lt;/p&gt;
&lt;p&gt;修改过之后的线程如下：&lt;br/&gt;&lt;img src=&quot;http://pewaccq76.bkt.clouddn.com/201809262308_811.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;消息投递过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在AMQConnection中开启连接线程，该线程用于处理和RabbitMq的通信：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public void startMainLoop() {
        MainLoop loop = new MainLoop();
        final String name = &quot;AMQP Connection &quot; + getHostAddress() + &quot;:&quot; + getPort();
        mainLoopThread = Environment.newThread(threadFactory, loop, name);
        mainLoopThread.start();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;AMQConnection.heartbeatExecutor是心跳线程。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;AMQConnection.consumerWorkServiceExecutor则是用来处理事件的线程池，AMQConnection线程收到消息投递到这里。&lt;br/&gt;分发逻辑详见com.rabbitmq.client.impl.ChannelN#processAsync-&amp;gt;com.rabbitmq.client.impl.ConsumerDispatcher#handleDelivery-&amp;gt;投递到线程池.&lt;/li&gt;
&lt;li&gt;线程池中继续将消息投递到org.springframework.amqp.rabbit.listener.BlockingQueueConsumer#queue中&lt;/li&gt;
&lt;li&gt;consumer线程进行最终消息&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面的是默认的消费者监听器。SpringAMQP 2.0引入了一个新的监听器实现&lt;code&gt;DirectMessageListenerContainer&lt;/code&gt;。这个实现最大的变化在于消费者的处理逻辑不是在自己的线程池中执行而是直接在client线程池中处理，这样最明显的是省去了线程的上下文切换的开销，而且设计上也变得更为直观。所以如果采用这个监听器需要覆盖默认的线程池加大Connection的线程池。采用这个监听器只需要设置&lt;code&gt;@RabbitListener&lt;/code&gt;的containerFactory属性。声明方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Bean
    DirectRabbitListenerContainerFactory directRabbitListenerContainerFactory(ConnectionFactory connectionFactory) {
        final DirectRabbitListenerContainerFactory directRabbitListenerContainerFactory = new DirectRabbitListenerContainerFactory();
        directRabbitListenerContainerFactory.setConsumersPerQueue(Runtime.getRuntime().availableProcessors());
        directRabbitListenerContainerFactory.setConnectionFactory(connectionFactory);
        directRabbitListenerContainerFactory.setMessageConverter(new Jackson2JsonMessageConverter());
        directRabbitListenerContainerFactory.setConsumersPerQueue(10);
        return directRabbitListenerContainerFactory;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时的消息流转图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pewaccq76.bkt.clouddn.com/201809262319_841.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有一些关于监听器的例子和Springboot配置我放在了源码里，这里不再讲述。&lt;/p&gt;
</description>
<pubDate>Wed, 26 Sep 2018 15:13:00 +0000</pubDate>
<dc:creator>陈芳志</dc:creator>
<og:description>[TOC] 在公司里一直在用RabbitMQ，由于api已经封装的很简单，关于RabbitMQ本身还有封装的实现没有了解，最近在看RabbitMQ实战这本书，结合网上的一些例子和spring文档，实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenfangzhi/p/9710698.html</dc:identifier>
</item>
<item>
<title>工作一年多的感慨与总结（一） - JJian</title>
<link>http://www.cnblogs.com/jian0110/p/9710680.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jian0110/p/9710680.html</guid>
<description>&lt;h2&gt;前言　&lt;/h2&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;博文断更了一月左右，期间是由于跳槽、离职、租房等等各种事耽误了，今天本来想写些技术的东西，但是突然觉得：从2017毕业到现在至始至终没有分享或记录过自己的一些心情杂事，都是些技术博文。&lt;/p&gt;
&lt;p&gt;其实，早就想分享下自己这一年的收获，或多或少做些回忆，同时鞭策自己以后更加努力，好了，啰啰嗦嗦写了很多“流水账”，有点乱，希望能谅解！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;hr/&gt;
&lt;h2&gt;2017/7-2017/9  找工作面试感慨&lt;/h2&gt;
&lt;p&gt;　　不像大多数应届毕业生，参加校招之后进入比较理想的公司。在2017/7月25号因为一些变故放弃了一个比较稳定的工作，重新收拾心情回到家自学（基本都是刷面试笔试题）了15天，8月10号左右来到KM，当时身无分文借住 于一位好友租房中，&lt;span&gt;&lt;strong&gt;找工作方面：笔试-&amp;gt;面试-&amp;gt;刷题-&amp;gt;总结，心情则是这样的：期待-&amp;gt;啥玩意！？工资3k！？？-&amp;gt;自我怀疑，啥我咋这都不会，我大学学了啥-&amp;gt;啥！！看我不错，让我做一年实习生，转不转正到时候看我表现-&amp;gt;啥？你知道我们公司最重要的是什么吗？是感恩，是狼性文化-&amp;gt;没事的，先养活自己要紧同时学技术！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;由于走的是社招，虽然没有特意表明应届生的身份，但是仍然每次都会被贴上“应届生”的身份，总是被告之“我是来学习，不是来工作的”&lt;/strong&gt;&lt;/span&gt;。前前后后10多家公司，里面有太多心酸，比如被HR催面试，结果花了很多钱打车到人家公司楼下面试，被突然告之老板出差下个月再说等，当然这并不是说这样的公司很多，可能是我运气有点背，当时也急于找工作稳定下来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最后，找到一个当地算是零售/饮食行业算是不错的公司，从事“企业信息化”相关的开发，最主要的是提供住宿！提供住宿！提供住宿！ （所以我是不会提工资的）第二天早晨6点起床，一个人背上自己的行李，拖着重重的行李箱步行到公司大巴上车处，当时已是快下午1点，随后坐公司大巴来到荒无人烟的公司总部大楼前，收拾好心情入职报道！&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2017/9-2018/9 一年职场感慨&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;&lt;strong&gt;　一切看似算时顺利吧，但入职这一年期间发生了很多让我震惊的事情：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（1）开发团队=我自己&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　之前面试的时候说到：除了我一个开发人员以外，还有个高级开发。算是我未见面的师傅，结果后来才发现是早就已经提了离职，等人来入职后才离职的，我算是来填坑的吗？？？？(黑人问号.gif)，果然后面一天人家就来办正式离职了，一堆文件交接给我就走了!&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（2）开发技术面试官虽是开发经理，但已10多年不编程。&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　也就是我的顶头上司就是开发经理，他下手也就只有我一个初级开发工程师！面试的时候说是有啥开发的问题都可以找他，后来发现却只是管理项目，并不是参与编程，也不是很懂编程，停留在07/08年开发水平与知识，但是数据库方面确实很牛逼，值得我学习！&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（3）信息部门刚成立两年，据说公司两年前还在用手工录单（电商方面单子）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　这让我深刻体会到一个当代企业建立并完善信息化的重要性，据说我们部门成立后，引进了CRM、WMS等系统之后，至少提升了公司50%的营销量，然而正如部门老大所说：往往引入信息化在以销售为主的公司是一下子看不到成绩的，需要强硬的数据才能展示，所以emmm.......部门当然没有收到很好的重视，但大家似乎都知道这个道理仍然努力着！&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（4）第一次觉得跟人沟通这么难&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　当时接受一个外包人员写的系统（系统各种烂就不说了，从按计划2018/2验收到2018/7bug才解决完，勉强验收），需要跟工厂里工人师傅与外包人员对接，单纯的我以为都是我们都是底层人员，肯定很好沟通的。结果写个文档错别字让我看不懂，每次都需要修改错别字，之后却被骂之：你以为你是老师吗？很牛逼嘛，改我写的错别字！当然，我还会常常在群里“劝架（这个师傅脾气很暴躁，经常撕外包开发的兄弟，两人经常在有领导的群里开撕）”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　最好笑的是一会我是这个师傅的兄弟（常常替他解围，跟外包人员沟通），一会我是叛徒（有点可笑呢，说我替外包人员说话），一会就开始问候我妈了（当时我已经做好辞职的打算了，跑到工厂里必须要跟他打一架），但是被比我晚两个月份入职的高级开发，也就是我师傅拦住了，跟我说了好多。最后算是平静下来了（这后面当然还有更搞笑的，哈哈哈，之后觉得有趣的朋友可以评论，我有时间再写），哦对了，这时的高级开发算是在初入职场的贵人吧，之后会写到他给我一些感慨，还有我从他身上学到一些东西！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;当然，并不是奇葩震惊的事居多，这一年时间内我也会学会了很多，也要感谢很多当时离职没有当面说谢谢的人！&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;----------------------------------------------------------------------分割线（今天先暂时写到这吧，有时间再写下一篇）------------------------------------------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 26 Sep 2018 15:07:00 +0000</pubDate>
<dc:creator>JJian</dc:creator>
<og:description>前言 博文断更了一月左右，期间是由于跳槽、离职、租房等等各种事耽误了，今天本来想写些技术的东西，但是突然觉得：从2017毕业到现在至始至终没有分享或记录过自己的一些心情杂事，都是些技术博文。 其实，早</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jian0110/p/9710680.html</dc:identifier>
</item>
<item>
<title>Emit动态代理.NetCore迁移之旅 - 7tiny</title>
<link>http://www.cnblogs.com/7tiny/p/9710406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/7tiny/p/9710406.html</guid>
<description>&lt;h2&gt;【前言】&lt;/h2&gt;
&lt;p&gt;　　前面我们介绍了Aop 从静态代理到动态代理：&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/7tiny/p/9657451.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.cnblogs.com/7tiny/p/9657451.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;我们在.NetFramework平台下使用微软提供的Emit技术实现了动态代理类的生成。但是.NetCore作为微软.Net平台的春天，如果类库光支持.NetFramework，那么未免有种没有跟上时代步伐的感觉，那么，我们就赶紧在.NetCore平台也实现一套吧。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　本想着新建一个.NetStandard项目，代码复制过来就直接能用的，没想到：&lt;span&gt;一路坎坷...&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;【开始迁移】&lt;/h2&gt;
&lt;p&gt;　　为了达到类库跨平台的目的，我们新建一个.NetStandard类库，选择什么版本呢？&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926212815737-61449034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为了兼容目前很多老旧的项目，我们看到 .NetStandard1.2最低支持.Net Framwork 4.5。为了保持兼容性，先建一个.Net Standard 1.2版本的类库。&lt;/p&gt;
&lt;p&gt;　　代码复制过来，坑如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926213845059-881628957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　1.Attribute的获取方法不支持&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926213044200-2087751086.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　2.Reflection 反射 GetMethods方法不支持，BindingFlags不支持（版本太低，Api没有全部实现）&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926213200704-1190760844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926213223846-904620648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;万般无奈之下，舍弃了兼容性，保证了代码的迁移。最终将我们的.Net Standard 项目升级到了Api比较完善的2.0版本。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;　　3..Net Standard/Core平台将以往的系统类库做了精简，曾经在System命名空间下的很多代码已经迁移到了单独的Nuget包中。&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926213545854-707583515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果我们要使用Emit这个特性的话，我们需要引用Nuget  &lt;strong&gt;System.Reflection.Emit&lt;/strong&gt;，所有的Emit特性代码都包含在这个组件中。&lt;/p&gt;
&lt;p&gt; 　　...&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926213749338-150720012.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;一整鼓捣之后，为什么还有代码在报红字...&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926214111014-1931839065.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926213955036-1142715205.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;　　4.旧版不兼容（有的方法已被直接移除）&lt;/h4&gt;
&lt;p&gt;　　这几个方法经过尝试，发现引用/更新程序集是解决不了的。上微软官方文档，居然发现这几个方法已经打上了过期标签。那么替代的方法呢？微软的官方文档里面并没有说明。最终通过一顿搜索，在stackoverflow了解到了.NetCore下的替代方法：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926214520168-1279478109.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926214535357-748246812.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　以前的Domain（应用程序域）定义程序集的方法已经迁移到了AssemblyBuilderAccess（程序集访问）类中，虽然这个归类更加合理了，但是一言不合就不兼容是不有点让人吐槽啊...&lt;/p&gt;
&lt;h4&gt;　　5.程序集不支持输出到目录&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926214816951-2012829595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　.NetCore 平台已经不支持直接输出到目录，仅仅可以在内存中Run。&lt;/p&gt;
&lt;h4&gt;　　6.typeBuilder类中的CreateType()方法消失&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926214920802-83892555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　CreateType()方法已经被直接移除掉了，官方解释是统一使用他的子类。这个答案最终通过搜索引擎在GitHub上找到了&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://github.com/dotnet/coreclr/issues/2222&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnet/coreclr/issues/2222&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　上面的链接是GitHub中 dotnet/coreclr 微软官方项目中的Issue&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926215329839-558157888.png&quot; alt=&quot;&quot; width=&quot;872&quot; height=&quot;708&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在其中可以看到我们遇到的很多坑在这里都有解释说明，而且表明了最新的使用方案：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926215510816-1702516838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　于是乎，就用Type的子类TypeInfo类了呗，CreateTypeInfo()&lt;/p&gt;
&lt;h2&gt;【终于不报错了】&lt;/h2&gt;
&lt;p&gt;　　在解决完毕所有的迁移兼容问题后，我们还是上次文章中的所有单元测试流程。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926215928927-1167675497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　单元测试没有问题，我们本次的 .NetCore 平台代码迁移终于完成。&lt;/p&gt;
&lt;h2&gt;【总结】&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Emit动态代理.NetStandard2.0 最低支持意味着支持.Net Core2.0/.Net Framework 4.6.1以上；&lt;/li&gt;
&lt;li&gt;微软在Api的迁移中，对部分代码进行了重新的归类，但是很多地方对旧版本不兼容我，切没有替换的官方文档；&lt;/li&gt;
&lt;li&gt;.Net Core 平台对系统类库进行了精简，移除了不必要的很多类库，需要使用的时候，通过对应的Nuget进行引用，但是没看到官方清单；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　最终结果是迁移完毕，新的项目命名为 SevenTiny.Bantina.Aop 吧，也算一个基础组件&lt;/p&gt;
&lt;p&gt;　　项目地址：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/sevenTiny/SevenTiny.Bantina&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/sevenTiny/SevenTiny.Bantina&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如果想直接引用Nuget使用的，已经构建好了，Nuget包搜索 &lt;strong&gt;SevenTiny.Bantina.Aop&lt;/strong&gt; 即可；&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 26 Sep 2018 14:18:00 +0000</pubDate>
<dc:creator>7tiny</dc:creator>
<og:description>【前言】 前面我们介绍了Aop 从静态代理到动态代理：https://www.cnblogs.com/7tiny/p/9657451.html 我们在.NetFramework平台下使用微软提供的Em</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/7tiny/p/9710406.html</dc:identifier>
</item>
<item>
<title>Redis学习八：Redis的事务 - pony1223</title>
<link>http://www.cnblogs.com/pony1223/p/9710006.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pony1223/p/9710006.html</guid>
<description>[unable to retrieve full-text content]一、是什么 可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞。 二、能干嘛 一个队列中，一次性、顺序性、排他性的执行一系列命令 三、怎么玩 1.常用命令 2.Case1：正常执行 3.Case2：放弃事务 4.Case3：全</description>
<pubDate>Wed, 26 Sep 2018 13:57:00 +0000</pubDate>
<dc:creator>pony1223</dc:creator>
<dc:identifier>http://www.cnblogs.com/pony1223/p/9710006.html</dc:identifier>
</item>
<item>
<title>MUI框架-09-MUI 与后台数据交互 - 肖朋伟</title>
<link>http://www.cnblogs.com/xpwi/p/9709957.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xpwi/p/9709957.html</guid>
<description>&lt;h2 id=&quot;mui框架-09-mui-与后台数据交互&quot;&gt;MUI框架-09-MUI 与后台数据交互&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本篇介绍使用 art-template 和原生 MUI 的数据交互 mui.ajax 来实现&lt;/li&gt;
&lt;li&gt;我们大家都知道，想要数据交互就要有数据，每次当我们发送请求，我们要清楚，怎么发，发给谁，返回的数据是什么内容，格式&lt;/li&gt;
&lt;li&gt;先放一张图，给大家学习的动力：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180926212056996?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ3ODYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; width=&quot;400px&quot;/&gt;&lt;/li&gt;
&lt;li&gt;然后今天呢，介绍的是调用 API，API 是什么呢，就是一个接口，比如知乎日报的API ，我们可以通过这个 API 获取到知乎上最新的消息，并且是 json 格式，我们就不用再去找数据了，其他类型 API 还有 百度语音识别，就是百度给我们一个接口，我们可以想这个接口发送 语音，然后返回给我们识别的结果，我们就没必要就了解具体是怎么识别的&lt;/li&gt;
&lt;li&gt;【注意】：我这里收集了大量的 API ，赠送给大家:&lt;/li&gt;
&lt;li&gt;链接地址：&lt;a href=&quot;https://blog.csdn.net/qq_40147863/article/details/82855787&quot;&gt;中国国内 - 可用API合集&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;api-分析&quot;&gt;API 分析&lt;/h3&gt;
&lt;h3 id=&quot;ajax&quot;&gt;Ajax&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://dev.dcloud.net.cn/mui/ajax/&quot;&gt;MUI Ajax 官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;参数呢，大家自己在官网看就可以，下面开始实战&lt;/li&gt;
&lt;li&gt;这里我们先一起看一下，官网给出的代码示例：如下为通过post方式向某服务器发送鉴权登录的代码片段：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;mui.ajax('http://server-name/login.php',{
    data:{
        username:'username',
        password:'password'
    },
    dataType:'json',//服务器返回json格式数据
    type:'post',//HTTP请求类型
    timeout:10000,//超时时间设置为10秒；
    headers:{'Content-Type':'application/json'},                  
    success:function(data){
        //服务器返回响应，根据响应结果，分析是否登录成功；
        ...
    },
    error:function(xhr,type,errorThrown){
        //异常处理；
        console.log(type);
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;上面这段代码就是说，ajax请求，设置一个目标地址，逗号，大括号后面是传入的参数信息&lt;/li&gt;
&lt;li&gt;大家记住一句话 大括号开始 大括号结束就是 json 格式&lt;/li&gt;
&lt;li&gt;然后我们就根据这个做一个实例，准备呢，大家请先根据这篇创建一个简单的页面：&lt;a href=&quot;https://blog.csdn.net/qq_40147863/article/details/82846484&quot;&gt;MUI框架-08-窗口管理-创建子页面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;然后打开我们的自己建的 html 目录下的那个子页面 html文件&lt;/li&gt;
&lt;li&gt;我们用下面代码替换 init() 的 script 标签，具体步骤写在注释：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
            mui.init()

            //plusReady，用来定义加载dom后的操作
            mui.plusReady(function() {
                
                //发起 ajax请求，地址使用知乎日报 api 
                mui.ajax('https://news-at.zhihu.com/api/4/theme/11', {
                    /* data 是参数，我们这里不需要，我们只是从 api获取数据
                    data: {
                        username: 'username',
                        password: 'password'
                    },
                    */
                    dataType: 'json', //服务器返回json格式数据
                    type: 'get', //HTTP请求类型
                    timeout: 10000, //超时时间设置为10秒；
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    success: function(data) {
                        //服务器返回响应，根据响应结果，分析是否登录成功；
                        
                        //我们现在控制台打印一下请求结果
                        console.log(data)
                
                        //然后获取json数据中的具体值
                        console.log(data.stories[0].title)
                    },
                    error: function(xhr, type, errorThrown) {
                        //异常处理；
                        console.log(type);
                    }
                });

            })
        &amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;把返回的-json-数据放在页面--&quot;&gt;把返回的 json 数据放在页面 -&lt;/h3&gt;
&lt;h3 id=&quot;使用-art-template---javascript-模板引擎&quot;&gt;使用 art-template - JavaScript 模板引擎&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script src=&quot;../js/template-web.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然后我们看一下 art-template 官网&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180926204446395?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ3ODYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; width=&quot;500px&quot;/&gt;&lt;/li&gt;
&lt;li&gt;也就是说们要使用这个 art-template，语句使用就要放在 这种 script 标签里，做对数据的渲染&lt;/li&gt;
&lt;li&gt;第一步：把页面上 ul 标签里的内容都删掉，给ul 标签加一个id为zhihu截图：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;ul class=&quot;mui-table-view&quot; id=&quot;zhihu&quot;&amp;gt;&amp;lt;/ul&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第2步把页面里 init 函数的那个 script 标签删掉，步骤，写在注释里了，粘贴下面这段代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- 引入template-web.js --&amp;gt;
        &amp;lt;script src=&quot;../js/template-web.js&quot; type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;!-- 使用&amp;lt;script id=&quot;list&quot; type=&quot;text/html&quot;&amp;gt; 拼接 html --&amp;gt;
        &amp;lt;script id=&quot;list&quot; type=&quot;text/html&quot;&amp;gt;
                &amp;lt;!-- 循环语法 --&amp;gt;
                {{each stories as list}}
                &amp;lt;li class=&quot;mui-table-view-cell mui-media&quot;&amp;gt;
                    &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                        &amp;lt;img class=&quot;mui-media-object mui-pull-left&quot; src=&quot;{{list.images[0]}}&quot;&amp;gt;
                        &amp;lt;div class=&quot;mui-media-body&quot;&amp;gt;
                            &amp;lt;!-- 获取 title --&amp;gt;
                            {{list.title}}
                        &amp;lt;/div&amp;gt;
                    &amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
                {{/each}}
            &amp;lt;/script&amp;gt;
        &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
            mui.init()

            //plusReady，用来定义加载dom后的操作
            mui.plusReady(function() {
                
                //发起 ajax请求，地址使用知乎日报 api 
                mui.ajax('https://news-at.zhihu.com/api/4/theme/11', {
                    /* data 是参数，我们这里不需要，我们只是从 api获取数据
                    data: {
                        username: 'username',
                        password: 'password'
                    },
                    */
                    dataType: 'json', //服务器返回json格式数据
                    type: 'get', //HTTP请求类型
                    timeout: 10000, //超时时间设置为10秒；
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    success: function(data) {
                        //服务器返回响应，根据响应结果，分析是否登录成功；
                        
                        //我们现在控制台打印一下请求结果
                        console.log(data)
                        
                        //然后获取json数据中的具体值
                        //console.log(data.stories[0].title)
                        
                        //list 对应上面的 id，就是得到 拼接的 html
                        var html = template('list', data);
                        //把得到的 html 放到id为 zhihu 的 ul 标签里
                        document.getElementById(&quot;zhihu&quot;).innerHTML = html;
                        console.log(html);

                    },
                    error: function(xhr, type, errorThrown) {
                        //异常处理；
                        console.log(type);
                    }
                });

            })
        &amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;真机运行&quot;&gt;真机运行&lt;/h3&gt;
&lt;h3 id=&quot;更多文章链接mui-框架&quot;&gt;更多文章链接：&lt;a href=&quot;https://blog.csdn.net/qq_40147863/article/category/8079041&quot;&gt;MUI 框架&lt;/a&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;本笔记不允许任何个人和组织转载&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 26 Sep 2018 13:47:00 +0000</pubDate>
<dc:creator>肖朋伟</dc:creator>
<og:description>MUI框架 09 MUI 与后台数据交互 本篇介绍使用 art template 和原生 MUI 的数据交互 mui.ajax 来实现 我们大家都知道，想要数据交互就要有数据，每次当我们发送请求，我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xpwi/p/9709957.html</dc:identifier>
</item>
<item>
<title>在微信小程序中使用redux - tornoda</title>
<link>http://www.cnblogs.com/looyulong/p/9709943.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/looyulong/p/9709943.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文主要讲述，在微信小程序中如何使用redux&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tornoda/miniProgram-with-redux&quot;&gt;DEMO&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;需要解决的问题&quot;&gt;需要解决的问题&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;如何在小程序中引入redux状态管理库，及它相关的插件？&lt;/li&gt;
&lt;li&gt;微信小程序没有清晰的异步api，便于thunkMiddleware处理异步请求（异步操作），如何解决？&lt;/li&gt;
&lt;li&gt;如何正确使用store的三大核心方法（&lt;code&gt;getStore&lt;/code&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;code&gt;subscribe&lt;/code&gt;）？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;redux并不是react专属，所以他可以在任何地方使用，小程序也不例外。解决上面三个问题就可以了。&lt;/p&gt;
&lt;h2 id=&quot;问题一-如何在小程序中引入redux状态管理库及它相关的插件&quot;&gt;问题一： 如何在小程序中引入redux状态管理库，及它相关的插件？&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;使用&lt;code&gt;npm&lt;/code&gt;在临时目录里安装&lt;code&gt;redux&lt;/code&gt;和其他你需要用到的包，如：&lt;code&gt;logger&lt;/code&gt; &lt;code&gt;thunkMiddleware&lt;/code&gt;。这里以redux示例。&lt;/li&gt;
&lt;li&gt;进入&lt;code&gt;node_module&lt;/code&gt;中，拷贝如下文件：&lt;code&gt;\redux\dist\redux.js&lt;/code&gt;或者&lt;code&gt;\redux\dist\redux.min.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据1/2中的步骤。把&lt;code&gt;redux.js&lt;/code&gt; &lt;code&gt;logger.js&lt;/code&gt; &lt;code&gt;thunkMiddleware&lt;/code&gt;都拷贝到小程序项目文件夹&lt;code&gt;\module&lt;/code&gt;目录下，没有请新建。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;问题二-微信小程序没有清晰的异步api便于thunkmiddleware处理异步请求异步操作如何解决&quot;&gt;问题二： 微信小程序没有清晰的异步api，便于thunkMiddleware处理异步请求（异步操作），如何解决？&lt;/h2&gt;
&lt;p&gt;前面有文章已经写过，如何将微信异步api转换为Promise，便于异步编程:&lt;a href=&quot;https://www.cnblogs.com/looyulong/p/9471424.html&quot;&gt;把微信小程序异步API转为Promise，简化异步编程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;读完会，把&lt;code&gt;to-promise&lt;/code&gt;库和&lt;code&gt;redux&lt;/code&gt;一样放在&lt;code&gt;\module&lt;/code&gt;文件夹下&lt;/p&gt;
&lt;h2 id=&quot;问题三如何正确使用store的三大方法getstore-dispatch-subscribe&quot;&gt;问题三：如何正确使用store的三大方法（&lt;code&gt;getStore&lt;/code&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;code&gt;subscribe&lt;/code&gt;）？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;这也是最关键的&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;在app.js中创建store&quot;&gt;在&lt;code&gt;app.js&lt;/code&gt;中创建&lt;code&gt;store&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;//app.js
import reducer from './reducer/index'
import { createStore, applyMiddleware } from './module/redux'
import logger from './module/redux-logger'
import thunkMiddleware from './module/redux-thunk'

//创建redux store
export const store = createStore(
  reducer,
  applyMiddleware(
    logger,//用于控制台state调试
    thunkMiddleware//用于处理异步action
  )
)

App({
    //...
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编写action&quot;&gt;编写&lt;code&gt;action&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// 项目根目录/action/http3Steps.js

export const REQUSET_BEGIN = 'REQUEST_BEGIN'
export const RECEIVED = 'RECEIVED'
export const REQUEST_FAILED = 'REQUEST_FAILED'

//创建三个请求http事务时的状态action，用于处理通用http请求
//1 请求开始；2 收到请求；3 请求失败
export const requestBegin = (requestName) =&amp;gt; ({
  type: REQUSET_BEGIN + requestName
})

export const received = (requestName, res) =&amp;gt; ({
  type: RECEIVED + requestName,
  res
})

export const requestFailed = (requestName, err) =&amp;gt; ({
  type: REQUEST_FAILED + requestName,
  err
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写索引action:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 项目根目录/action/index.js

import { requestBegin, received, requestFailed } from './http3Steps'
import toPromise from '../module/to-promise'

//微信小程序没有提供Promise版本的异步api
//我封装了一个库，把微信小程序异步api转化为Promise，用于处理redux中的异步action
//项目地址：https://github.com/tornoda/to-promise
//使用方法见blog：https://www.cnblogs.com/looyulong/p/9471424.html
const toPromiseWx = toPromise(wx)
const request = toPromiseWx('request')

//这是一个同步的action
export const INCREASE = 'INCREASE'

export const increase = {
  type: INCREASE
}

//这是一个异步action
//网络请求action
//根据redux官网的介绍，它应该是一个Promise，但是微信小程序没有提供Promise版本的异步api，需要使用上面提到的工具库
export const GAME_LIST = '_GAME_LIST'

export const fetch = (requestName, option) =&amp;gt; {
  return (dispatch) =&amp;gt; {
    dispatch(requestBegin(requestName))//请求开始，更新state状态
    return request(option)
      .then(
        (res) =&amp;gt; { dispatch(received(requestName, res)); return res },//请求成功，把返回的信息在state中更新
        (err) =&amp;gt; { dispatch(requestFailed(requestName, err)) }//请求失败，把失败的信息在state中更新
      )
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编写处理action的reducer&quot;&gt;编写处理action的reducer&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// 项目根目录/reducer/index.js

import { INCREASE } from '../actions/index'
import { GAME_LIST } from '../actions/index'
import { REQUSET_BEGIN, RECEIVED, REQUEST_END } from '../actions/http3Steps'
import { combineReducers } from &quot;../module/redux&quot;;

//这是处理本例子中同步action的reducer
export const disposeIncrease = (state = 0, action) =&amp;gt; {
  switch (action.type) {
    case INCREASE:
      console.log('redux is worked')
      return state + 1
    default:
      return state
  }
}

//这是处理本例中异步的reducer
const preState = {}

export const disposeFetch = (state = preState, action) =&amp;gt; {
  switch (action.type) {
    case REQUSET_BEGIN + GAME_LIST:
      return {
        ...state,
        status: 'REQUEST_BEGIN',
      }
    case RECEIVED + GAME_LIST:
      return {
        ...state,
        status: 'RECEIVED',
        res: action.res
      }
    case REQUEST_END + GAME_LIST:
      return {
        ...state,
        status: 'REQUEST_END',
        err: action.err
      }
    default:
      return state
  }
}

//按照state的结构组合起来
export default combineReducers({
  theIncreasingNo: disposeIncrease,
  asyncData: disposeFetch
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;让state变化时自动更新ui视图&quot;&gt;让state变化时自动更新ui视图&lt;/h3&gt;
&lt;p&gt;方法很简单，在&lt;code&gt;page&lt;/code&gt;的&lt;code&gt;index.js&lt;/code&gt;中的&lt;code&gt;onLoad&lt;/code&gt;函数里面调用&lt;code&gt;store.subscribe()&lt;/code&gt;方法监听局部data.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  onLoad: function () {
    const _this = this
    //在onLoad函数中订阅state的更新
    //如果state变化，对应ui就会更新
    subscribe(() =&amp;gt; {
      const { asyncData: { status }, theIncreasingNo } = getState()
      _this.setData({
        syncData: `
          请求状态：${status}, 
          返回的数据请查看控制台
        `,
        number: theIncreasingNo
      })
    })
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;触发动作发出action改变state&quot;&gt;触发动作，发出action，改变state&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;//index.js
import { store } from '../../app'
import { increase, fetch, GAME_LIST } from '../../actions/index'

const { dispatch, subscribe, getState } = store

Page({
  data: {
    syncData: 'Hello World',
    number: '0',
  },
  onLoad: function () {
    const _this = this
    //发出一个异步action
    dispatch(fetch(GAME_LIST, {
      url: 'http://open.douyucdn.cn/api/RoomApi/game'
    })).then((data) =&amp;gt; { console.log(data) })
    //在onLoad函数中订阅state的更新
    //如果state变化，对应ui就会更新
    subscribe(() =&amp;gt; {
      const { asyncData: { status }, theIncreasingNo } = getState()
      _this.setData({
        syncData: `
          请求状态：${status}, 
          返回的数据请查看控制台
        `,
        number: theIncreasingNo
      })
    })
  },
  testSyncAction: function () {
    //发出一个同步action
    dispatch(increase)
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431071/201809/1431071-20180926213445092-159786312.png&quot; alt=&quot;可以在控制台查看每步修改前后得state了&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;源文件&quot;&gt;源文件&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tornoda/miniProgram-with-redux&quot;&gt;DEMO地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实战项目&quot;&gt;实战项目&lt;/h2&gt;
&lt;p&gt;稍后上传，敬请期待。&lt;/p&gt;
</description>
<pubDate>Wed, 26 Sep 2018 13:45:00 +0000</pubDate>
<dc:creator>tornoda</dc:creator>
<og:description>本文主要讲述，在微信小程序中如何使用redux</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/looyulong/p/9709943.html</dc:identifier>
</item>
</channel>
</rss>