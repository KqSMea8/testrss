<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>玩转 HTML5 下 WebGL 的 3D 模型交并补 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/7806438.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/7806438.html</guid>
<description>&lt;p&gt;建设性的立体几何具有许多实际用途，它用于需要简单几何对象的情况下，或者数学精度很重要的地方，几乎所有的工程 CAD 软件包都使用 CSG（可以用于表示刀具切削，以及零件必须配合在一起的特征）。CSG 是 &lt;a href=&quot;https://en.wikipedia.org/wiki/Constructive_solid_geometry&quot; target=&quot;_blank&quot;&gt;Constructive Solid Geometry&lt;/a&gt; 建模技术的简称，通过裁剪 subtract、融合 union 和相交 intersect 的运算，组合出复杂模型效果，HT 封装了 ht.CSGNode 和 ht.CSGShape 等图元类型来支持 CSG 的组合功能，常用于墙面的门窗挖空凿洞的应用场景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201711/591709-20171108213736450-1893036316.png&quot; alt=&quot;&quot; width=&quot;458&quot; height=&quot;406&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSG 对象可以用二叉树表示，其中叶子表示基元，节点表示操作。在这个图中，节点被标记 ∩ 为交集，∪ 为并集，- 为差集。CSG 提供的模型或表面看起来很复杂，但实际上不过是巧妙组合或分解对象。&lt;/p&gt;
&lt;p&gt;ht.CSGNode 继承于 ht.Node，当 style 的 shape3d 属性为空时显示为六面体效果，CSGNode 如果通过 setHost 吸附到 宿主 CSGNode 或 CSGShape 后，宿主 CSGNode 或 CSGShape 可与吸附的 CSGNode 图元进行 CSG 的组合建模。详情请参考 &lt;a href=&quot;http://hightopo.com/guide/guide/plugin/modeling/ht-modeling-guide.html#ref_csgnode&quot;&gt;HT for Web 建模手册 &lt;/a&gt;&lt;a href=&quot;http://hightopo.com/guide/guide/plugin/modeling/ht-modeling-guide.html#ref_csgnode&quot;&gt;CSGNode 章节&lt;/a&gt;。这里我用 CSG 的概念写了一个例子，让大家能更好地理解这个概念。&lt;/p&gt;
&lt;p&gt;本例 Demo 地址： &lt;a href=&quot;http://hightopo.com/guide/guide/plugin/modeling/examples/example_bookshelf.html&quot; target=&quot;_blank&quot;&gt;http://hightopo.com/guide/guide/plugin/modeling/examples/example_bookshelf.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先来看下效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171107144228136?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGhsb2FkM2Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;&quot; width=&quot;846&quot; height=&quot;442&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面效果图可以看到，我们将界面分为三个部分，这三个部分先是右边部分上下分割，然后将整个界面左右分割，HT 用封装好的 ht.widget.SplitView 进行界面的分割，然后将分割组件添加进底层 div 中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
dm = &lt;span&gt;new&lt;/span&gt; ht.DataModel();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据模型            &lt;/span&gt;
treeView = &lt;span&gt;new&lt;/span&gt; ht.widget.TreeView(dm); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;树组件                                                                                                 &lt;/span&gt;
gv1 = &lt;span&gt;new&lt;/span&gt; ht.graph3d.Graph3dView(dm); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3D 组件  &lt;/span&gt;
gv2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.graph3d.Graph3dView(dm);
splitView &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ht.widget.SplitView(gv1, gv2, 'v', 0.6);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分割组件 &lt;/span&gt;
mainSplit = &lt;span&gt;new&lt;/span&gt; ht.widget.SplitView(treeView, splitView, 'h', 0.27&lt;span&gt;);   
                
view &lt;/span&gt;=&lt;span&gt; mainSplit.getView();  
view.className &lt;/span&gt;= 'main'&lt;span&gt;;
document.body.appendChild(view);    
window.addEventListener(&lt;/span&gt;'resize', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
    mainSplit.invalidate();
}, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;);     
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码是一种非常常见的在 HTML 中添加 HT 组件的方法，详情可参考 &lt;a href=&quot;http://hightopo.com/guide/guide/core/beginners/ht-beginners-guide.html&quot; target=&quot;_blank&quot;&gt;HT for Web 入门手册&lt;/a&gt;组件章节。这种方法进行添加 HT 组件有一个需要注意的点，因为 HT 一般都以设置 position 为 absolute 的绝对定位方式，必须设置 left、right、top、bottom 等等基础 css 样式，像这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.main {
     margin: 0px;
     padding: 0px;
     position: absolute;
     top: 0px;
     bottom: 0px;
     left: 0px;
     right: 0px;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以为了最外层组件加载填充满窗口的方便性，HT 的所有组件都有 addToDOM 函数，其思想逻辑如下，其中 iv 是 invalidate 的缩写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
addToDOM = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){   
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;,
    view &lt;/span&gt;=&lt;span&gt; self.getView(),   
    style &lt;/span&gt;=&lt;span&gt; view.style;
    document.body.appendChild(view);            
    style.left &lt;/span&gt;= '0'&lt;span&gt;;
    style.right &lt;/span&gt;= '0'&lt;span&gt;;
    style.top &lt;/span&gt;= '0'&lt;span&gt;;
    style.bottom &lt;/span&gt;= '0'&lt;span&gt;;      
    window.addEventListener(&lt;/span&gt;'resize', &lt;span&gt;function&lt;/span&gt; () { self.iv(); }, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);            
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以后我们在代码中就可以直接调用 addToDOM 函数，而不用写一大堆代码了，上面代码用 addToDOM 取代之后的代码如下，而且不用描绘 css 样式： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
dm = &lt;span&gt;new&lt;/span&gt; ht.DataModel();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据模型             &lt;/span&gt;
treeView = &lt;span&gt;new&lt;/span&gt; ht.widget.TreeView(dm); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;树组件                                                             &lt;/span&gt;
gv1 = &lt;span&gt;new&lt;/span&gt; ht.graph3d.Graph3dView(dm); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3D 组件  &lt;/span&gt;
gv2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.graph3d.Graph3dView(dm);
splitView &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ht.widget.SplitView(gv1, gv2, 'v', 0.6);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分割组件 &lt;/span&gt;
mainSplit = &lt;span&gt;new&lt;/span&gt; ht.widget.SplitView(treeView, splitView, 'h', 0.27&lt;span&gt;);   
mainSplit.addToDOM();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;界面分配好之后我们就要对其添加内容了，界面的左边部分是 HT 封装的树组件，我在之前的文章写到过，树组件是一个非常方便的绘制树形关系的组件，开发人员能够轻松地从数据模型 DataModel 中获取数据和节点之间的关系放到树上，只需要在树组件声明的过程中，将对应的数据模型 DataModel 放进树组件的参数即可，当然我们还扩展了很多跟树组件有关的函数，非常方便实用，这里我们只用了 expandAll 函数，将所有对象展开：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
treeView = &lt;span&gt;new&lt;/span&gt; ht.widget.TreeView(dm); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;树组件   &lt;/span&gt;
treeView.expandAll();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;右边部分上下分为两部分，都是 3D 场景，就是设置显示有点不同，其他完全相同，上面的 3D 场景重载了 getVisibleFunc 函数，如果元素的 showMe 属性为 true，则可视；如果节点为 ht.CSGNode 类型并且节点的 getHost 函数的参数为空，则不可视；其他情况均可视：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
gv1.setVisibleFunc(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(data.showMe){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data &lt;span&gt;instanceof&lt;/span&gt; ht.CSGNode &amp;amp;&amp;amp;&lt;span&gt; data.getHost()){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们先向 3D 场景中添加元素对象，我们先解释中间的书架，对两边的书架有缺的再进行补充。首先我们添加了一个 ht.CSGNode 节点 shelf，作为书架的主节点，其他的节点都是依附于这个节点的，对这个节点设置了位置、大小、名称以及六个面的颜色，然后添加进数据模型 DataModel： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; shelf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.CSGNode();
shelf.s3(&lt;/span&gt;500, 400, 120&lt;span&gt;);
shelf.p3(&lt;/span&gt;0, 200, 0&lt;span&gt;);
shelf.setName(&lt;/span&gt;'shelf1'&lt;span&gt;);
shelf.s({
    &lt;/span&gt;'all.color': '#E5BB77'&lt;span&gt;
});
dm.add(shelf);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着向这个 shelf 中添加 10 个节点，做书架的格子效果，并设置依附关系和父子关系添加进数据模型中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0; i&amp;lt;2; i++&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=0; j&amp;lt;5; j++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; clipNode = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.CSGNode();
        clipNode.setHost(shelf);
        clipNode.s3(&lt;/span&gt;80, 100, 120&lt;span&gt;);
        clipNode.p3(&lt;/span&gt;-200+j*100, 340-i*120, 20&lt;span&gt;);
        clipNode.setName(&lt;/span&gt;'substract-'+i+'-'+&lt;span&gt;j);
        clipNode.s(&lt;/span&gt;'batch', 'tt'&lt;span&gt;);
        clipNode.setParent(shelf);
        dm.add(clipNode);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了让书架变得更美观一点，我们在书架的上下左右都加上了 ht.CSGNode，最后为了更加具象化，我们还添加了一本书，实现方式也差不多，都非常简单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; book = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.Node();
book.setName(&lt;/span&gt;'CSS3: The Missing Manual'&lt;span&gt;);
book.s3(&lt;/span&gt;60, 80, 8&lt;span&gt;);
book.p3(&lt;/span&gt;-100, 210, 20&lt;span&gt;);
book.r3(&lt;/span&gt;-Math.PI/6, Math.PI/5, 0&lt;span&gt;);
book.setIcon(&lt;/span&gt;'book'&lt;span&gt;);
book.s({
    &lt;/span&gt;'front.image': 'book'&lt;span&gt;,
    &lt;/span&gt;'back.color': 'white'&lt;span&gt;,
    &lt;/span&gt;'left.color': 'white'&lt;span&gt;,
    &lt;/span&gt;'all.color': 'gray'&lt;span&gt;
});
book.setHost(shelf);
book.setParent(shelf);
dm.add(book); &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着左边的书架也是类似的构建方法，有一点不同的是，这边有一个 ht.CSGBox 类型，继承于 ht.CSGNode，其除具备父类 CSGNode 的挖空等功能外，还可对六个面进行旋转展开关闭的操作，这里我们的节点只设置了前面的能够旋转展开，并且设置了一系列的样式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
clipNode = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.CSGBox();
clipNode.setName(&lt;/span&gt;'CSGBox-Expand-Left'&lt;span&gt;);
clipNode.s3(&lt;/span&gt;100, 100, 120&lt;span&gt;);
clipNode.p3(&lt;/span&gt;0, 65, 0.1&lt;span&gt;);
clipNode.setHost(shelf);
clipNode.showMe &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
clipNode.s({
    &lt;/span&gt;'all.visible': &lt;span&gt;false&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6面均不可见&lt;/span&gt;
    'front.visible': &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前面可见&lt;/span&gt;
    'front.toggleable': &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;允许前面双击展开                    &lt;/span&gt;
    'front.reverse.flip': &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前面的反面显示正面的内容&lt;/span&gt;
    'front.transparent': &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前面透明&lt;/span&gt;
    'front.end': Math.PI * 0.7,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前面展开状态的结束旋转弧度&lt;/span&gt;
    'front.color': 'rgba(0, 50, 50, 0.7)'&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前面颜色&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201711/591709-20171108221508856-1272494164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可能你们还想知道下面的地球是怎么做到的？还记得之前的文章写到过 HT 中设置了 shape3d 属性，设置这个属性实际上就是在操作 setShape3dModel(name, model) 和 getShape3dModel(name)，可以通过这个属性设置为 box|sphere|cylinder|cone|torus|star|rect|roundRect|triangle|rightTriangle|parallelogram|trapezoid 等等模型，这些模型也都是 HT 封装好的，要使用时直接设置 shape3d 为其中的一个值即可，如这个例子中用到 “shape3d: sphere” 就是设置为球体。我们简单地用一张地图图片包裹在这个球体的外侧，当然，这张地图图片是先通过 ht.Default.setImage 注册过的，然后通过 shape3d.image 将图片附到这个节点上：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
earth = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.Node();
earth.setName(&lt;/span&gt;'earth'&lt;span&gt;);
earth.s3(&lt;/span&gt;70, 70, 70&lt;span&gt;);
earth.p3(&lt;/span&gt;0, 50, 0&lt;span&gt;);
earth.s({
    &lt;/span&gt;'shape3d': 'sphere'&lt;span&gt;,
    &lt;/span&gt;'shape3d.image': 'earth'&lt;span&gt;
});
earth.setHost(shelf);  
earth.setParent(shelf);
dm.add(earth);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;右边的书架，同样也是有一个主节点，其他节点依附于它，但是我们看到这边换了一个新的节点类型 ht.DoorWindow，ht.DoorWindow继承于 ht.CSGNode，其除具备父类 CSGNode 的挖空等功能外，还可进行整体的旋转展开关闭的操作， 常用于作为门或窗的业务对象，吸附于 CSGNode 或 CSGShape 的 host 作为墙面的图元。这个节点类型就是 ht.CSGNode 的延展，相对来说就是区分了实际应用而添加了不同的 style 参数，更多的属性请到 &lt;a href=&quot;http://hightopo.com/guide/guide/plugin/modeling/ht-modeling-guide.html#ref_doorwindow&quot; target=&quot;_blank&quot;&gt;HT for Web 建模手册 DoorWindow 章节&lt;/a&gt; 查看然后添加到节点中玩玩：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
photos = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.DoorWindow();
photos.setName(&lt;/span&gt;'DoorWindow-Photos'&lt;span&gt;);
photos.setIcon(&lt;/span&gt;'ben12'&lt;span&gt;);
photos.s3(&lt;/span&gt;110, 100, 130&lt;span&gt;);
photos.p3(&lt;/span&gt;5, 180, 0&lt;span&gt;);                
photos.setHost(shelf);  
photos.showMe &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
photos.s({                    
    &lt;/span&gt;'bottom.uv': [1,1, 1,0, 0,0, 0,1&lt;span&gt;],
    &lt;/span&gt;'bottom.uv.scale': [1, 1&lt;span&gt;],
    &lt;/span&gt;'left.uv.scale': [3, 3&lt;span&gt;],
    &lt;/span&gt;'top.uv.scale': [2, 2&lt;span&gt;],
    &lt;/span&gt;'dw.s3': [0.8, 0.9, 0.05&lt;span&gt;],
    &lt;/span&gt;'dw.t3': [0, -5, 0&lt;span&gt;],
    &lt;/span&gt;'dw.axis': 'v'&lt;span&gt;,
    &lt;/span&gt;'dw.toggleable': &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;'front.image': 'ben1'&lt;span&gt;,
    &lt;/span&gt;'back.image': 'ben2'&lt;span&gt;,
    &lt;/span&gt;'all.color': '#F8CE8B'&lt;span&gt;
});
photos.setParent(shelf);
dm.add(photos);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，我们将左侧的地球 earth 和右侧的照片 photo 旋转起来：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; angle = 0&lt;span&gt;;
setInterval(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    angle &lt;/span&gt;+= Math.PI/40;
    earth.r3(0, angle, 0&lt;span&gt;);
    photos.s(&lt;/span&gt;'dw.angle'&lt;span&gt;, angle);
}, &lt;/span&gt;50);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看到，其实虽然 HT 封装了很多不同的 CSG 节点类型，但是实际应用都差不多，而且内容也没有差特别多，差别都是在 style 参数上，但是真的在实际开发中，这种区分就会很大程度上加快开发速度，毕竟名称一目了然，就知道要运用哪些 style 属性了。&lt;/p&gt;
</description>
<pubDate>Wed, 08 Nov 2017 23:40:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xhload3d/p/7806438.html</dc:identifier>
</item>
<item>
<title>「JavaScript」同步、异步、回调执行顺序之经典闭包setTimeout分析 - OkayChen</title>
<link>http://www.cnblogs.com/okaychen/p/7806739.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/okaychen/p/7806739.html</guid>
<description>&lt;p&gt;同步，异步，回调，我们傻傻分不清楚，&lt;/p&gt;
&lt;div class=&quot;content-font&quot; readability=&quot;48&quot;&gt;
&lt;p class=&quot;fr-tag&quot;&gt;有一天，你找到公司刚来的程序员小T，跟他说：“我们要加个需求，你放下手里的事情优先支持，我会一直等你做完再离开”。小T微笑着答应了，眼角却滑过一丝不易觉察的杀意。&lt;/p&gt;
&lt;p class=&quot;fr-tag&quot;&gt;世界上的所有事情大致可以分为同步去做和异步去做两种。你打电话去订酒店，电话另一边的工作人员需要查下他们的管理系统才能告诉你有没有房间。&lt;/p&gt;
&lt;p class=&quot;fr-tag&quot;&gt;这时候你有两种选择：一种是不挂电话一直等待，直到工作人员查到为止（可能几分钟也可能几个小时，取决于他们的办事效率），这就是同步的。&lt;/p&gt;
&lt;p class=&quot;fr-tag&quot;&gt;另一种是工作人员问了你的联系方式就挂断了电话，等他们查到之后再通知你，这就是异步的，这时候你就可以干点其他事情，比如把机票也定了之类的&lt;/p&gt;
&lt;p class=&quot;fr-tag&quot;&gt; &lt;/p&gt;
&lt;hr/&gt;&lt;p class=&quot;fr-tag&quot;&gt; 计算机世界也是如此，我们写的代码需要交给cpu去处理，这时候就有同步和异步两种选择&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;js是单线程的，如果所有的操作（ajax,获取文件等I/O操作&amp;lt;node&amp;gt;）都是同步的，遇到哪些耗时的操作，后面的程序必然被阻塞而不能执行，页面也就失去了响应，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;因此js采用了事件驱动机制，在单线程模型下，使用异步回调函数的方式来实现非阻塞的IO操作&lt;/span&gt;，&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;那么什么是异步任务呢？（参考阮一峰老师《JavaScript运行机制》）&lt;/p&gt;
&lt;p&gt;异步任务也就是 指&lt;span&gt;主线程（stack栈）&lt;/span&gt;运行的过程中，当&lt;span&gt;stack空闲&lt;/span&gt;的时候，主线程对&lt;span&gt;&lt;code&gt;event queque（队列）&lt;/code&gt;&lt;/span&gt;轮询(事实上一直在轮询)后，将异步任务放到&lt;span&gt;&lt;code&gt;stack&lt;/code&gt;&lt;/span&gt;里面进行执行；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201711/1140602-20171108235148638-921431224.png&quot; alt=&quot;&quot; width=&quot;481&quot; height=&quot;422&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（上图转引自Philip Roberts的演讲&lt;a href=&quot;http://vimeo.com/96425312&quot; target=&quot;_blank&quot;&gt;《Help, I'm stuck in an event-loop》&lt;/a&gt;））&lt;/p&gt;
&lt;p&gt; 简单的说，如果我们指定过回调函数，那么当事件发生时就会进入事件队列，等待&lt;span&gt;主线程的（stack）空闲&lt;/span&gt;的时候，就会&lt;span&gt;对&lt;code&gt;event queue&lt;/code&gt;里面的回调读取并放到stack里面执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们经常说的可能是异步回调（当然也有同步回调），所以也就并不难理解，&lt;strong&gt;&lt;span&gt;回调和异步之间其实并没有直接的联系，回调只是异步的一种实现方式， &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过这样的event loop我们其实可以分析出三者的执行顺序，即 &lt;strong&gt;&lt;span&gt;同步 &amp;gt; 异步 &amp;gt; 回调&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;今天同学问了我一个问题，我一看是一道经典的面试题，问题如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201711/1140602-20171108232843341-778372110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单的这个问题改一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt;= 5; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;      setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;         console.log( i );
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;      }, i*1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;      console.log( ' i : ' , i );
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;  
&lt;span&gt;8&lt;/span&gt;  console.log( i );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相信我们很多人都遇到过这个问题，心中或许都有答案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201711/1140602-20171109004220981-838113583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么为什么并不是入门者心中所想要的结果嘞？&lt;/p&gt;
&lt;p&gt;首先我们来梳理一下，第一部分event loop图片很直观的体现：&lt;span&gt;&quot;任务队列&quot;可以放置异步任务的事件，也可以放置定时事件（setTimeout和setinterval）&lt;/span&gt;，即指定某些代码在多少时间之后执行；&lt;/p&gt;
&lt;p&gt; 1、首先我们先来看一下他的主体结构： for循环的第一层是setTimeout函数，setTimeout函数中使用了一个匿名（回调）函数&lt;/p&gt;
&lt;p&gt; 2、还记的我们之前总结的执行顺序：&lt;strong&gt;&lt;span&gt;同步 &amp;gt; 异步 &amp;gt; 回调&lt;/span&gt;&lt;/strong&gt; 吧！&lt;/p&gt;
&lt;p&gt;　　1）for循环和外层的 console.log()是同步的，setTimeout是回调执行，&lt;/p&gt;
&lt;p&gt;　　所以按照执行顺序，先执行for循环，然后进入for循环中，他发现了一个setTimeout()回调&lt;strong&gt;&lt;span&gt;(进入event queque事件队列，等待stack栈为空后读取并放入栈中后执行)&lt;/span&gt;&lt;/strong&gt;，这时候他并不会等待&lt;/p&gt;
&lt;p&gt;　　而是继续执行 --&amp;gt; for循环内部的 console.log( ' i : ' , i )  --&amp;gt;  for循环外部的console.log( i ) ，然后才会去执行&quot;任务队列&quot;中的回调函数；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; 我们在来用这个例子尝试一下上面的event loop图，更加直观的感受一下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201711/1140602-20171109011257950-748803626.png&quot; alt=&quot;&quot; width=&quot;789&quot; height=&quot;659&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么接下来可能会问怎么解决这个问题呢？我想最简单的当然是&lt;strong&gt;&lt;span&gt;let语法&lt;/span&gt;&lt;/strong&gt;了，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt;= 5; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;          console.log( i );
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;       }, i*1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;       console.log( ' 1 : '&lt;span&gt; , i );
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;   
&lt;span&gt;8&lt;/span&gt;  console.log( i );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们都知道es5中变量作用域是函数，而es6却可以使用let声明一个具有&lt;strong&gt;&lt;span&gt;块级作用域&lt;/span&gt;&lt;/strong&gt;的i，在这里也就是for循环体；&lt;/p&gt;
&lt;p&gt;在这里let&lt;span&gt;本质上就是形成了一个闭包&lt;/span&gt;，那么&lt;span&gt;写成es5的形式&lt;span&gt;其实等价于&lt;/span&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; loop = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (_i) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;      setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;          console.log(&lt;span&gt; _i);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;      }, _i*1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     console.log(&lt;/span&gt;'2：',&lt;span&gt;_i) &lt;/span&gt;&lt;span&gt; &lt;br/&gt;6&lt;/span&gt;  &lt;span&gt;}; &lt;br/&gt;&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; &lt;br/&gt;8 &lt;/span&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; _i = 0; _i &amp;lt;= 5; _i++&lt;span&gt;) { &lt;/span&gt;&lt;span&gt; &lt;br/&gt;9&lt;/span&gt; &lt;span&gt;      loop(_i); &lt;br/&gt;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;到这里，我们就完成了从同步、异步、回调的机制分析 到 setTimeout的经典案例的分析，JavaScript博大精深，我们需要了解他的机制去深入去挖掘他。&lt;/p&gt;




</description>
<pubDate>Wed, 08 Nov 2017 23:37:00 +0000</pubDate>
<dc:creator>OkayChen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/okaychen/p/7806739.html</dc:identifier>
</item>
<item>
<title>Kotlin实现LeetCode算法题之Two Sum - 路上的脚印</title>
<link>http://www.cnblogs.com/tgyf/p/7800106.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tgyf/p/7800106.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;strong&gt;LeetCode介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a title=&quot;https://leetcode.com/&quot; href=&quot;https://leetcode.com/&quot; target=&quot;_blank&quot;&gt;LeetCode&lt;/a&gt;是算法练习、交流等多功能网站，感兴趣的同学可以关注下（老司机请超车）。页面顶部的Problems菜单对应算法题库，附带历史通过滤、难易程度等信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/450484/201711/450484-20171108101827528-148453708.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;646&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;未来计划&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打算用Kotlin语言，按照从易到难的顺序有选择地实现LeetCode库中的算法题，考虑到Kotlin的学习与巩固、算法的思考与优化，争取一星期完成一篇文章（每篇只总结一题，可能偷偷做了后面的好几题^_^）。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然，除了单纯地用kotlin实现外，还会指出一些容易忽略的坑，并对结果进行更深一层的分析。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;编码测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击标题就会进入具体的题目界面，包括描述、编码区、运行/提交按钮、参考方案、讨论等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/450484/201711/450484-20171108103450403-892406678.png&quot; alt=&quot;&quot; width=&quot;708&quot; height=&quot;510&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这次就先选择第一题：给定一个整数型的数组nums和一个目标值target，要求编码实现计算出两个数组下标index1和index2，使得两个下标对应的元素和等于目标值，即nums[index1]+nums[index2]=target。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于描述中有提到，可以假设每个输入都会有一个靠谱的答案，且同一个元素不能用两次（即不允许出现[2, 2]这样的结果），所以实现的时候可以不用太担心有没有答案或什么异常之类的情况，之后的编码中只会象征性地给出没有结果时的异常处理。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;方案1，两层for循环&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    fun twoSum(nums: IntArray, target: Int): IntArray {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;..nums.size - &lt;span&gt;2&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (j &lt;span&gt;in&lt;/span&gt; i + &lt;span&gt;1&lt;/span&gt;..nums.size - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (nums[j] == target -&lt;span&gt; nums[i]) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; kotlin.intArrayOf(i, j)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; IllegalArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No two sum solution&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上述代码中for循环用了..，是会包含最后一个元素的，即范围取[start, end]。和..效果相同的有rangeTo，类似的还有until（差别在于范围取[start, end)，具体用法感兴趣的同学尝试并做比较）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在LeetCode上运行会提示正确性与耗时等信息，本文只给出本地电脑上IntelliJ IDEA的运行情况（不存在LeetCode运行时可能有网速等外在因素的干扰）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;测试案例（下同）：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;135&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; fun main(args: Array&amp;lt;String&amp;gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis()
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     println(&lt;span&gt;&quot;&quot;&lt;/span&gt; + Solution().twoSum(intArrayOf(&lt;span&gt;230&lt;/span&gt;, &lt;span&gt;863&lt;/span&gt;, &lt;span&gt;916&lt;/span&gt;, &lt;span&gt;585&lt;/span&gt;, &lt;span&gt;981&lt;/span&gt;, &lt;span&gt;404&lt;/span&gt;, &lt;span&gt;316&lt;/span&gt;, &lt;span&gt;785&lt;/span&gt;, &lt;span&gt;88&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;70&lt;/span&gt;, &lt;span&gt;435&lt;/span&gt;, &lt;span&gt;384&lt;/span&gt;, &lt;span&gt;778&lt;/span&gt;, &lt;span&gt;887&lt;/span&gt;, &lt;span&gt;755&lt;/span&gt;, &lt;span&gt;740&lt;/span&gt;, &lt;span&gt;337&lt;/span&gt;, &lt;span&gt;86&lt;/span&gt;, &lt;span&gt;92&lt;/span&gt;, &lt;span&gt;325&lt;/span&gt;, &lt;span&gt;422&lt;/span&gt;, &lt;span&gt;815&lt;/span&gt;, &lt;span&gt;650&lt;/span&gt;, &lt;span&gt;920&lt;/span&gt;, &lt;span&gt;125&lt;/span&gt;, &lt;span&gt;277&lt;/span&gt;, &lt;span&gt;336&lt;/span&gt;, &lt;span&gt;221&lt;/span&gt;, &lt;span&gt;847&lt;/span&gt;, &lt;span&gt;168&lt;/span&gt;, &lt;span&gt;23&lt;/span&gt;, &lt;span&gt;677&lt;/span&gt;, &lt;span&gt;61&lt;/span&gt;, &lt;span&gt;400&lt;/span&gt;, &lt;span&gt;136&lt;/span&gt;, &lt;span&gt;874&lt;/span&gt;, &lt;span&gt;363&lt;/span&gt;, &lt;span&gt;394&lt;/span&gt;, &lt;span&gt;199&lt;/span&gt;, &lt;span&gt;863&lt;/span&gt;, &lt;span&gt;997&lt;/span&gt;, &lt;span&gt;794&lt;/span&gt;, &lt;span&gt;587&lt;/span&gt;, &lt;span&gt;124&lt;/span&gt;, &lt;span&gt;321&lt;/span&gt;, &lt;span&gt;212&lt;/span&gt;, &lt;span&gt;957&lt;/span&gt;, &lt;span&gt;764&lt;/span&gt;, &lt;span&gt;173&lt;/span&gt;, &lt;span&gt;314&lt;/span&gt;, &lt;span&gt;422&lt;/span&gt;, &lt;span&gt;927&lt;/span&gt;, &lt;span&gt;783&lt;/span&gt;, &lt;span&gt;930&lt;/span&gt;, &lt;span&gt;282&lt;/span&gt;, &lt;span&gt;306&lt;/span&gt;, &lt;span&gt;506&lt;/span&gt;, &lt;span&gt;44&lt;/span&gt;, &lt;span&gt;926&lt;/span&gt;, &lt;span&gt;691&lt;/span&gt;, &lt;span&gt;568&lt;/span&gt;, &lt;span&gt;68&lt;/span&gt;, &lt;span&gt;730&lt;/span&gt;, &lt;span&gt;933&lt;/span&gt;, &lt;span&gt;737&lt;/span&gt;, &lt;span&gt;531&lt;/span&gt;, &lt;span&gt;180&lt;/span&gt;, &lt;span&gt;414&lt;/span&gt;, &lt;span&gt;751&lt;/span&gt;, &lt;span&gt;28&lt;/span&gt;, &lt;span&gt;546&lt;/span&gt;, &lt;span&gt;60&lt;/span&gt;, &lt;span&gt;371&lt;/span&gt;, &lt;span&gt;493&lt;/span&gt;, &lt;span&gt;370&lt;/span&gt;, &lt;span&gt;527&lt;/span&gt;, &lt;span&gt;387&lt;/span&gt;, &lt;span&gt;43&lt;/span&gt;, &lt;span&gt;541&lt;/span&gt;, &lt;span&gt;13&lt;/span&gt;, &lt;span&gt;457&lt;/span&gt;, &lt;span&gt;328&lt;/span&gt;, &lt;span&gt;227&lt;/span&gt;, &lt;span&gt;652&lt;/span&gt;, &lt;span&gt;365&lt;/span&gt;, &lt;span&gt;430&lt;/span&gt;, &lt;span&gt;803&lt;/span&gt;, &lt;span&gt;59&lt;/span&gt;, &lt;span&gt;858&lt;/span&gt;, &lt;span&gt;538&lt;/span&gt;, &lt;span&gt;427&lt;/span&gt;, &lt;span&gt;583&lt;/span&gt;, &lt;span&gt;368&lt;/span&gt;, &lt;span&gt;375&lt;/span&gt;, &lt;span&gt;173&lt;/span&gt;, &lt;span&gt;809&lt;/span&gt;, &lt;span&gt;896&lt;/span&gt;, &lt;span&gt;370&lt;/span&gt;, &lt;span&gt;789&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     ), &lt;span&gt;542&lt;/span&gt;&lt;span&gt;).asList())
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; end =&lt;span&gt; System.currentTimeMillis()
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     println(end -&lt;span&gt; start)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;关于耗时，建议采用多次运行后再取平均，这里留给大家发挥想象。最好在一个稳定的环境下测试，且耗时是相对的（相同环境下对不同算法的结果进行对比，环境变化可比性就意义不大了）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/450484/201711/450484-20171108110824544-1921929911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 运行多次，发现耗时31ms居多，有时会是47ms，偶尔会是67ms等。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;方案2，Map初始添加&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    fun twoSum(nums: IntArray, target: Int): IntArray {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         val mapA = mutableMapOf&amp;lt;Int, Int&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;..nums.size - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            mapA.put(nums[i], i)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;..nums.size - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; value = target -&lt;span&gt; nums[i]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (mapA.containsKey(value) &amp;amp;&amp;amp; mapA.&lt;span&gt;get&lt;/span&gt;(value) !=&lt;span&gt; i ) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; kotlin.intArrayOf(i, mapA.&lt;span&gt;get&lt;/span&gt;(value)!!&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; IllegalArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No two sum solution&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;消除了两层循环，多用了一个数组元素的空间，本意是打算用空间换时间。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;方案3，Map过程添加&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    fun twoSum(nums: IntArray, target: Int): IntArray {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         val mapA = mutableMapOf&amp;lt;Int, Int&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;..nums.size - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; value = target -&lt;span&gt; nums[i]
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mapA.containsKey(value)) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; kotlin.intArrayOf(mapA.&lt;span&gt;get&lt;/span&gt;(value)!!&lt;span&gt;, i)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                mapA.put(nums[i], i)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; IllegalArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No two sum solution&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;针对mapA的元素添加过程做了优化，不是像方案2中那样一开始就将数组元素全部进行映射，而是边查找边添加。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;结果分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意点1，耗时情况&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后面两种方案没有给出输出结果，原因是对于耗时来说，三种方案是差不多的。这就有疑问了，后两种利用了Map映射机制，可能在空间上确实增加了，但是循环才是耗时主要因素，为什么时间并没有减少呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;遇到这种情况，就不建议百度或者谷歌了，不为别的，就因为源码最靠谱。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码中是通过mutableMapOf建立mapA变量的，找下去，在Maps.kt中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; inline fun &amp;lt;K, V&amp;gt; mutableMapOf(): MutableMap&amp;lt;K, V&amp;gt; = LinkedHashMap()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;线索LinkedHashMap，找下去，在TypeAliases.kt中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; @SinceKotlin(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;public&lt;/span&gt; typealias LinkedHashMap&amp;lt;K, V&amp;gt; = java.util.LinkedHashMap&amp;lt;K, V&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;用到了类型别名。正如Kotlin的自我介绍，其和Java及JVM是很亲密的。线索java.util.LinkedHashMap，找下去，在LinkedHashMap.java中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean containsKey(Object key) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; getNode(hash(key), key) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看到Kotlin中containsKey最终调用了Java中的getNode，真相就在下面：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; final Node&amp;lt;K,V&amp;gt; getNode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash, Object key) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; first, e; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n; K k;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((tab = table) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = tab.length) &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;
&lt;span&gt; 4&lt;/span&gt;         (first = tab[(n - &lt;span&gt;1&lt;/span&gt;) &amp;amp; hash]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (first.hash == hash &amp;amp;&amp;amp; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; always check first node&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             ((k = first.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; first;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((e = first.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (first instanceof TreeNode)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; ((TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt;)first).getTreeNode(hash, key);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;
&lt;span&gt;13&lt;/span&gt;                     ((k = e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             } &lt;span&gt;while&lt;/span&gt; ((e = e.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;代码第11-15行，其实还是用到了遍历。问题的答案就有解了，Map+while耗时和for+for差别不大，前者代码更简洁，后者不需额外空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;那么，有没有更好的方案呢？欢迎同学们提出，大家一起讨论、学习。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意点2，Map映射的坑&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LeetCode或者其他平台的测试案例也是随机的，有时候并不会发现代码中的潜在问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如上述案例目标值是542，三种方案结果都是一致的[28, 45]。如果目标值改为1093，即数组的第一、二个元素下标[0, 1]是期望结果，但是第二种方案却是[0, 40]，而其他两种方案正常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题就出在其所有元素值是初始添加的，来看其中这一段代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; (i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;..nums.size - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    mapA.put(nums[i], i)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对于Map映射，put操作当key不存在时进行添加，否则进行再赋值。所以当数组元素存在相同的值时，最后求出的下标值就会是最后一个，而不是第一个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;改进方案是在put操作前进行key的存在判断：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; (i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;..nums.size - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mapA.containsKey(nums[i])) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        mapA.put(nums[i], i)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 08 Nov 2017 23:26:00 +0000</pubDate>
<dc:creator>路上的脚印</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tgyf/p/7800106.html</dc:identifier>
</item>
<item>
<title>逆向课程第五讲逆向中的优化方式,除法原理,以及除法优化下 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/7807548.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/7807548.html</guid>
<description>&lt;p&gt;一丶除法的优化&lt;/p&gt;
&lt;h3&gt;1.有符号被除数 / 无符号除数的情况下&lt;/h3&gt;
&lt;p&gt;高级代码为:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171108234224075-562647210.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;汇编中优化的体现形式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171108234307388-1663796528.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相比于昨天,我们发现了的 无符号 / 常量多出了点东西&lt;/p&gt;
&lt;p&gt;无符号/常量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171108234644403-2051389813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果无符号/常量,那么我们还原的时候&lt;/p&gt;
&lt;p&gt;套用公式即可&lt;/p&gt;
&lt;p&gt;am &amp;gt;&amp;gt; n&lt;/p&gt;
&lt;p&gt;a是被除数  m是设  2n/c   等价于  m == 2n/c&lt;/p&gt;
&lt;p&gt;无符号的情况的,n的值是2^33次方  ,n = 33&lt;/p&gt;
&lt;p&gt;根据上面得知,  m = 0AAAAAAABh&lt;/p&gt;
&lt;p&gt;此时求出C来即可,  C = 除数&lt;/p&gt;
&lt;p&gt;公式:&lt;/p&gt;
&lt;p&gt;2n / m = c&lt;/p&gt;
&lt;p&gt;套进去得到&lt;/p&gt;
&lt;p&gt;2^33次方 / 0AAAAAAABh = 被除数  结果向上取整&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171108235149325-185155975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171108235154809-1472523588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;向上取整,结果就是3,那么得出被除数是3了.&lt;/p&gt;
&lt;p&gt;2^33次方,也就是n怎么得出来的,依据上面的汇编代码n值等于1&lt;/p&gt;
&lt;p&gt;也就是shr edx,1  那么我们知道,算一个除法的时候,必须扩展符号位&lt;/p&gt;
&lt;p&gt;也就是 变成了 EDX.EAX 了,现在EDX右移一位,那么相当于 eax移动了32位+1,也就是33位,所以可以直接省略了.&lt;/p&gt;
&lt;p&gt;所以此时EDX &amp;gt;&amp;gt; 1则是 33&lt;/p&gt;
&lt;p&gt;此时继续,有符号 / 常量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171108234307388-1663796528.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看汇编代码,下边多了几条语句 显然与上面不同&lt;/p&gt;
&lt;p&gt;此时还原的方法&lt;/p&gt;
&lt;p&gt;n得出结果就是32,为什么?&lt;/p&gt;
&lt;p&gt;因为edx直接使用了,我不用移位了.&lt;/p&gt;
&lt;p&gt;下方的移动31位,是固定的,这个主要是解决有符号和无符号相除.&lt;/p&gt;
&lt;p&gt;在这里,需要进行大量的数学公式推算,鉴于大家对数学不太明白,所以不再讲解.&lt;/p&gt;
&lt;p&gt;我们只需要知道,当一个有符号 / 一个常量的时候,那么下方如果调整了.不用看.因为m的值如果按照 imul来计算的时候是一个负数.但是此时我们不能让它变为负数,所以最后进行符号位调整.&lt;/p&gt;
&lt;p&gt;还原手法同上.&lt;/p&gt;
&lt;p&gt;如果数学公式推导:&lt;/p&gt;
&lt;p&gt;我们知道.&lt;/p&gt;
&lt;p&gt;a/c的结果可以变为 &lt;/p&gt;
&lt;p&gt;m = 2n / c&lt;/p&gt;
&lt;p&gt;此时我们要知道,C的结果不会是整数的,所以使用的公式 是上整+1&lt;/p&gt;
&lt;p&gt;也可能是小数,也需要上整+1&lt;/p&gt;
&lt;p&gt;那么现在我们可以把符号位提取出来,这样也就是 移动31位(所以说是在32位系统下是固定死的),这样如果是负数,那么负数+1即可.如果是正数,那么是加0,还原的时候只看上三句即可.&lt;/p&gt;
&lt;h3&gt;2.无符号 / 7 和有符号/7的新的优化方式(当然可能不光是7介绍的是这种优化方式)&lt;/h3&gt;
&lt;h4&gt;无符号/7的新方式.&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109003641044-941305960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;又晕了是不是,一个DIV没用到,很难看到这是一个除法对不对.&lt;/p&gt;
&lt;p&gt;先说下还原的公式,以及方法(至于公式怎么的出来的,那么可以看下方推导,当然这属于大数问题,可以不看.不过看了有好处)&lt;/p&gt;

&lt;p&gt;2n / (M + 2^32)  = C(除数)即可.(别忘了结果向上取整)&lt;/p&gt;
&lt;p&gt;n = 32(本身32起步,看系统,当然n的取值明天会讲) + 1 + 2 (指数相加) 结果为2 ^ 35次方&lt;/p&gt;
&lt;p&gt;那么 2^35次方 / (M + 2^32) 结果救赎除数&lt;/p&gt;
&lt;p&gt;那么我们按照数学界的公式去推一下.&lt;/p&gt;
&lt;h3&gt;推导:&lt;/h3&gt;
&lt;p&gt;首先得出:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109003752106-425999074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得出最后的公式.&lt;/p&gt;
&lt;p&gt;那么根据上面的程式,继而得到了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109004146044-431206707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 一步一步简化&lt;/p&gt;
&lt;p&gt;第一次简化: 可以把2^32次方拿到上面来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109004217075-1646260171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 第二次简化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109004305044-2064448893.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三次简化:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109004335966-2055625092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第四次简化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109004345747-1687534356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第五次简化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109004402278-1586223002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第六次简化:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109004411934-231684058.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第八次简化:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109004424669-1595058758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得出了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109004434184-603646480.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么根据以前的除法公式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109004455763-2002625063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设 m = &lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109004522059-394395114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109004544716-1669816415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109004555309-1563080526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进而简化为公式得出  一个大的M, M的值太大了.变为了一个大数问题,所以我们最终的M要加上1,或者加上2^32次方.(因为进位了)&lt;/p&gt;
&lt;p&gt;那么&lt;/p&gt;
&lt;p&gt;C =  (2^32 + 指数 + 指数) / (2^32 + M)  故而得出了C&lt;/p&gt;
&lt;p&gt;简化为了&lt;/p&gt;
&lt;p&gt;C = 2^n / M (别忘了M是一个大数)&lt;/p&gt;
&lt;h4&gt;有符号/7&lt;/h4&gt;
&lt;p&gt;这个和昨天一样,套用 C = 2^n / M 即可 (M是正常的,不是大数)&lt;/p&gt;
&lt;p&gt;在这里讲解一下汇编代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109005152294-2124657479.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请问为什么要 add一下.&lt;/p&gt;
&lt;p&gt;这里我们就涉及到了有符号和无符号混乘的问题.&lt;/p&gt;
&lt;p&gt;比如16位的年代,两个寄存器相乘,怎么解决溢出问题了.&lt;/p&gt;
&lt;p&gt;A * 8086&lt;/p&gt;
&lt;p&gt;A + ~A = FFFF&lt;/p&gt;
&lt;p&gt;A + ~A + 1 = 10000 (求补码)&lt;/p&gt;

&lt;p&gt;A * -(10000h - 8086h)&lt;/p&gt;
&lt;p&gt;去掉负号&lt;/p&gt;
&lt;p&gt;A * (8086h - 10000h )&lt;/p&gt;
&lt;p&gt;那么得出&lt;/p&gt;
&lt;p&gt;8086h - 10000h = dx.ax&lt;/p&gt;
&lt;p&gt;又因为你减掉了补码 10000h&lt;/p&gt;
&lt;p&gt;那么 &lt;/p&gt;
&lt;p&gt;dx.ax + 10000h = 8086h&lt;/p&gt;
&lt;p&gt;那么此时 10000h的高位变成了1,那么 dx直接加1即可了.&lt;/p&gt;
&lt;p&gt;所以这就是为什么 add edx,ecx(乘积的高位)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到此,除数为正数的几种情况讲解完毕.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;二丶除数为负数&lt;/h2&gt;
&lt;h3&gt;1.除数为  -2的幂的情况下&lt;/h3&gt;
&lt;p&gt;高级代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109010320372-693955437.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;汇编代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109010255059-141163100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 公式还是一样的,向上取整的公式.也就是昨天的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109010405856-1133932882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;b- 1是3&lt;/p&gt;
&lt;p&gt;b是除数, 结果是2 ^2次方.&lt;/p&gt;
&lt;p&gt;得出除数是4 只需要求反即可.&lt;/p&gt;
&lt;h3&gt;2.除数为-7的时候,有符号除,和无符号除的表现形式&lt;/h3&gt;
&lt;h3&gt;2.1 有符号除&lt;/h3&gt;
&lt;h3&gt; 高级代码还是上面的,只不过 -4 变为-7&lt;/h3&gt;
&lt;p&gt;argc / -7&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109011421903-37225545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时,和 有符号 * 无符号问题又冲突了&lt;/p&gt;
&lt;p&gt;A * 8086&lt;/p&gt;
&lt;p&gt;只不过,现在的M变为负数了 需要你求补码了. 而又因为M是一个大数,下面需要调整1F(31)位,所以&lt;/p&gt;
&lt;p&gt;还原公式为&lt;/p&gt;
&lt;p&gt;2^n / neg(2^32 + M) = C  (向上取整)&lt;/p&gt;
&lt;p&gt;也就是说依照上图,我们的M变为了16DB6DB6D了,此时要对它取反+1变为真正的M 然后用2^n次方去除,然后求出C来(除数)&lt;/p&gt;
&lt;p&gt;计算一下得到&lt;/p&gt;
&lt;p&gt;2^34 / neg(16DB6DB6D) = 6.99999xxxx 向上取整是7&lt;/p&gt;
&lt;p&gt;那么此时怎么判断是否是  ±7那?&lt;/p&gt;
&lt;p&gt;可以看汇编代码,里面有个 sub edx,ecx(相当于上面举例子 A * 8086,  那么此时 EDX只能减去乘积的高位才会得出真正的8086)&lt;/p&gt;
&lt;p&gt;那么此时,我们判定了m的高位是负数,是求补后的,那么得出了  M是负数,说明了除数为负数,又因为还原了,M 得出的结果是原除数的绝对值.所以判定为负数.&lt;/p&gt;

&lt;h3&gt;2.2无符号/-7的优化.&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171109020910325-843923048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个是特殊还原公式&lt;/p&gt;
&lt;p&gt;还原公式:&lt;/p&gt;
&lt;p&gt;C = 2^n / M   转为16进制当做有符号解释即可.&lt;/p&gt;
&lt;p&gt;现在的n是29  加上原来的32 = 61 那么就是2^61次方 / 20000001h  结果转化为16进制当做有符号解释.&lt;/p&gt;

</description>
<pubDate>Wed, 08 Nov 2017 18:19:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/7807548.html</dc:identifier>
</item>
<item>
<title>关于混合应用开发的未来的一些思考 - iOS122</title>
<link>http://www.cnblogs.com/ios122/p/7807487.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ios122/p/7807487.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当其欣于所遇，暂得于己，快然自足，不知老之将至，及其所之既倦，情随事迁，感慨系之矣&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;有序而又混乱的时代&quot;&gt;有序而又混乱的时代&lt;/h2&gt;
&lt;p&gt;现在是2017年11月9日。即使努力仅仅去关注编程技术的我，也依然感觉到了混乱。混乱之后，必然潜伏着机遇；混乱之后，也可能一着错，几年辛苦付诸流水。&lt;/p&gt;
&lt;p&gt;几年之前，我偏执的认为没有开源精神的微软，不值得自己追随，毅然决然地完全摒弃了 .net 系的学习之后。现在单一 .net 技术栈的人，可能工作都很难找到了吧。&lt;/p&gt;
&lt;p&gt;但是，没有谁会一直有好运气。说不定，我现在沉浸的语言，不久之后就成了明日黄花。如果自己真的是只会某个语言的专家，真的就是要一切从零开始了。你的所有荣誉，都被清零。纵然可以自我安慰说一些有基础学其他的也很快一类的话。&lt;/p&gt;
&lt;p&gt;如此，或许能理解我现在为何付出极大的时间和精力，同时并行推进多个语言的学习和实践了。&lt;/p&gt;
&lt;p&gt;当然，现在（估计未来也是）还是一个技术软文丛生的时代。准确分辨出软文和趋势，真的需要些许智慧了。&lt;/p&gt;
&lt;h2 id=&quot;对一些编程语言的观察和思考&quot;&gt;对一些编程语言的观察和思考&lt;/h2&gt;
&lt;h3 id=&quot;cc-永生&quot;&gt;1. C/C++ 永生&lt;/h3&gt;
&lt;p&gt;过去几十年的编程语言之争，C/C++ 似乎一直置身事外，但又以无可争议的方式讲述着自己的威严。不同的语言，大都将能兼容 C/C++ 库，作为语言本身必须的一个 feature 实现。感觉自己那本 Boost 库书，该燥起来了！&lt;/p&gt;
&lt;h3 id=&quot;jvm-系会继续活的很好&quot;&gt;2. JVM 系会继续活的很好&lt;/h3&gt;
&lt;p&gt;原来一直以为 jvm 系的语言，普遍都很慢；但是看了 go 相关的评测后，才发现在大多数情况下，因为有一个优化的很好的解释器， jvm 系的效率是非常高的。路转粉。Java 是 JVM 的亲儿子，但是我现在在看 Kotlin，呼哈哈~~&lt;/p&gt;
&lt;h3 id=&quot;python-可能是最合适的贴身脚本语言&quot;&gt;3. Python 可能是最合适的贴身脚本语言&lt;/h3&gt;
&lt;p&gt;目前技术栈中，真正充当日常脚本语言的是 nodejs。正在逐步往 Python 方向过渡。暂且不论大数据，人工智能一类的场景，对Python的良好支持；单是 Mac 和 Linux 系统内置 Python 支持者一向，都已经决定了 Python 几乎无可撼动的江湖地位。&lt;/p&gt;
&lt;h3 id=&quot;javascript-可能不是跨平台应用开发的良好选择&quot;&gt;4. JavaScript 可能不是跨平台应用开发的良好选择&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在我看来 Virtual DOM 真正的价值从来都不是性能，而是它 1) 为函数式的 UI 编程方式打开了大门；2) 可以渲染到 DOM 以外的 backend，比如 ReactNative。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据 @尤雨溪 的分析，未来的设计到 UI 呈现的应用开发，Virtual Dom是一个很重要的趋势。对此，我也很认同。毕竟有一个目前为止取得空前成功的 ReactNative 背书。但是，我无法认同，使用 JavaScript 作为中间语言来进程跨平台开发。我在想，如果不是 ReactJS 的历史原因，有没有可能， Facebook 会专门为 ReactNative 用其他语言写一套类似 ReactJS 的库。C/C++ 实现跨平台开发，我总觉得，它会是一个更好的选择。&lt;/p&gt;
&lt;h3 id=&quot;未来的应用会更加追求品质和体验&quot;&gt;5. 未来的应用，会更加追求品质和体验&lt;/h3&gt;
&lt;p&gt;这一点纯属吐槽吧。对于那些很 LOW 的客户端，我是很拒绝打开的。真的看着糟心，还不如看网页。未来，随着技术的进步，土豪的增多，大家在功能之外，应该会更加注重体验和品质吧。反正我是觉得，一些签到好处的动画，是非常酷的。所以，有事没事读读 Material Design，也是极好的&lt;/p&gt;
&lt;h2 id=&quot;小福利&quot;&gt;小福利&lt;/h2&gt;
&lt;p&gt;如果有研究 iOS/Android 如何和 WebView 同步异步通信的，可以看下这两个库： &lt;a href=&quot;https://github.com/wendux/DSBridge-IOS&quot; class=&quot;uri&quot;&gt;https://github.com/wendux/DSBridge-IOS&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/wendux/DSBridge-Android&quot; class=&quot;uri&quot;&gt;https://github.com/wendux/DSBridge-Android&lt;/a&gt; 。本来想自己写下相关的文章的，但是既然已经有童鞋封装好了，也不用再重复说了，方法就是网上常讨论的那些同步异步通信策略，源码值得一看。&lt;/p&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
</description>
<pubDate>Wed, 08 Nov 2017 17:32:00 +0000</pubDate>
<dc:creator>iOS122</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ios122/p/7807487.html</dc:identifier>
</item>
<item>
<title>linux系统下解决getch()输入数值不回显示 - 醉饮千觞</title>
<link>http://www.cnblogs.com/binglmm/p/7806936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binglmm/p/7806936.html</guid>
<description>&lt;p&gt;  在linux系统下开发C 程序却会遇到系统不支持conio.h头文件，无法使用getch()不回显函数。下面就演示如何构建函数实现数值输入不回显。&lt;/p&gt;&lt;div readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;  
&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; #include &amp;lt;termios.h&amp;gt;  
&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; #include &amp;lt;unistd.h&amp;gt;  
&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; #include &amp;lt;errno.h&amp;gt;  
&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; ECHOFLAGS (ECHO | ECHOE | ECHOK | ECHONL)  
&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数set_disp_mode用于控制是否开启输入回显功能  
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果option为0，则关闭回显，为1则打开回显  &lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; set_disp_mode(&lt;span&gt;int&lt;/span&gt; fd,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; option)  
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;{  
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt;    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; err;  
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;    &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; termios term;  
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt;(tcgetattr(fd,&amp;amp;term)==-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){  
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt;      perror(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cannot get the attribution of the terminal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;   }  
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(option)  
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt;         term.c_lflag|=&lt;span&gt;ECHOFLAGS;  
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt;    &lt;span&gt;else&lt;/span&gt;  
&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;         term.c_lflag &amp;amp;=~&lt;span&gt;ECHOFLAGS;  
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt;    err=tcsetattr(fd,TCSAFLUSH,&amp;amp;&lt;span&gt;term);  
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt;(err==-&lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; err==&lt;span&gt;EINTR){  
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt;         perror(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cannot set the attribution of the terminal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;   }  
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;}  
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数getpasswd用于获得用户输入的密码，并将其存储在指定的字符数组中  &lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getpasswd(&lt;span&gt;char&lt;/span&gt;* passwd, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size)  
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;{  
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; c;  
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt;    &lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt;     
&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt;    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Please Input password:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;     
&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt;    &lt;span&gt;do&lt;/span&gt;&lt;span&gt;{  
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;       c=&lt;span&gt;getchar();  
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (c != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;|c!=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;){  
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt;          passwd[n++] =&lt;span&gt; c;  
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;      }  
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt;    }&lt;span&gt;while&lt;/span&gt;(c != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;amp;&amp;amp; c !=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;amp;&amp;amp; n &amp;lt; (size - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));  
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;    passwd[n] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; n;  
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;}  
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; 
&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()  
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;{  
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;    &lt;span&gt;char&lt;/span&gt; *p,passwd[&lt;span&gt;20&lt;/span&gt;],name[&lt;span&gt;20&lt;/span&gt;&lt;span&gt;];  
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt;    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Please Input name:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt;    scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,name);  
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt;    getchar();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将回车符屏蔽掉  
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先关闭输出回显，这样输入密码时就不会显示输入的字符信息  &lt;/span&gt;
&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt;    set_disp_mode(STDIN_FILENO,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用getpasswd函数获得用户输入的密码  &lt;/span&gt;
&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt;    getpasswd(passwd, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(passwd));    
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt;    p=&lt;span&gt;passwd;  
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt;    &lt;span&gt;while&lt;/span&gt;(*p!=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt;      p++&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; 
&lt;span&gt;113&lt;/span&gt;    *p=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt;    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nYour name is: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,name);  
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;117&lt;/span&gt;    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nYour passwd is: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, passwd);  
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; 
&lt;span&gt;119&lt;/span&gt;    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Press any key continue ...\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; 
&lt;span&gt;121&lt;/span&gt;    set_disp_mode(STDIN_FILENO,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; 
&lt;span&gt;123&lt;/span&gt; &lt;span&gt;   getchar();  
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; 
&lt;span&gt;125&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt; &lt;span&gt;}  
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; 
&lt;span&gt;129&lt;/span&gt;  
&lt;span&gt;130&lt;/span&gt; 
&lt;span&gt;131&lt;/span&gt;  
&lt;span&gt;132&lt;/span&gt; 
&lt;span&gt;133&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;说明：Linux下C编程遇到要输入密码的问题，可输入的时候密码总不能让人看见吧，本来想用getch()来解决输入密码无回显的问题的，不料Linux-C中不支持getch()，我也没有找到功能类似的函数代替，上面这个例子达到了预期的效果。&lt;/p&gt;</description>
<pubDate>Wed, 08 Nov 2017 15:31:00 +0000</pubDate>
<dc:creator>醉饮千觞</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/binglmm/p/7806936.html</dc:identifier>
</item>
<item>
<title>Unity 游戏框架搭建 (十九) 简易对象池 - 凉鞋的笔记</title>
<link>http://www.cnblogs.com/liangxiegame/p/Unity-you-xi-kuang-jia-da-jian-shi-jiu-jian-yi-dui.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liangxiegame/p/Unity-you-xi-kuang-jia-da-jian-shi-jiu-jian-yi-dui.html</guid>
<description>&lt;p&gt;在Unity中我们经常会用到对象池，使用对象池无非就是解决两个问题:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一是减少new时候寻址造成的消耗，该消耗的原因是内存碎片。&lt;/li&gt;
&lt;li&gt;二是减少Object.Instantiate时内部进行序列化和反序列化而造成的CPU消耗。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;想进一步了解对象池模式优化原理的同学可以参阅: &lt;a href=&quot;http://gpp.tkchu.me/object-pool.html&quot;&gt;对象池模式:http://gpp.tkchu.me/object-pool.html&lt;/a&gt;，本篇主要讲如何实现一个精简并且灵活的对象池。&lt;/p&gt;
&lt;h4 id=&quot;toc_0&quot;&gt;设计：&lt;/h4&gt;
&lt;p&gt;首先我们要弄清楚本篇对象池的几个概念，否则直接上代码大家会一头雾水。&lt;br/&gt;从字面上理解对象池，池的意思就是容器。我们可以从池中获取一个对象(一条鱼)，也可以向池中放入一个对象(一条鱼)。获取的操作我们叫Allocate(分配),而放入一个对象我们叫Recycle(回收)(ps:也有很多习惯叫Spawn和Despawn的,这个看自己习惯了)。所以我们可以定义池的接口为如下:&lt;br/&gt;``` C#&lt;br/&gt;public interface IPool&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    bool Recycle(T obj);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;为什么要用泛型呢？因为笔者开头说过，本篇主要讲如何实现一个精简并且灵活的对象池。这个灵活很大一部分是通过泛型体现的。

前面有说过，池是容器的意思，在C#中可以是List,Queue或者Stack甚至是数组。所以对象池本身要维护一个容器。本篇我们选取Stack来作为池容器，原因是当我们在Allocate和Recycle时并不关心缓存的存储的顺序，只要求缓存对象的地址是连续的。代码如下所示:
``` C#
    using System.Collections.Generic;

    public abstract class Pool&amp;lt;T&amp;gt; : IPool&amp;lt;T&amp;gt;
    {
          ...
        protected Stack&amp;lt;T&amp;gt; mCacheStack = new Stack&amp;lt;T&amp;gt;();
          ...
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Pool是个抽象类，为什么呢? 因为笔者开头说过，本篇主要讲如何实现一个精简并且灵活的对象池。这个灵活很大一部分是通过抽象类体现的。&lt;/p&gt;
&lt;p&gt;现在对象的存取和缓存接口都设计好了，那么这些对象是从哪里来的呢？我们分析下，创建对象我们知道有两种方式，反射构造方法和new一个对象。对象池的一个重要功能就是缓存，要想实现缓存就要求对象可以在对象池内部进行创建。所以我们要抽象出一个对象的工厂，代码如下所示:&lt;br/&gt;&lt;code&gt;C#&lt;br/&gt;public interface IObjectFactory&amp;lt;T&amp;gt;&lt;br/&gt;{&lt;br/&gt;T Create();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;br/&gt;那么大家要问为什么要用工厂? 因为笔者开头说过，本篇主要讲如何实现一个精简并且灵活的对象池。这个灵活很大一部分是通过工厂体现的。&lt;/p&gt;
&lt;p&gt;OK，现在对象的创建，存取，缓存的接口都设计好了。下面放出Pool的全部代码。&lt;br/&gt;``` C#&lt;br/&gt;using System.Collections.Generic;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class Pool&amp;lt;T&amp;gt; : IPool&amp;lt;T&amp;gt;
{
    #region ICountObserverable
    /// &amp;lt;summary&amp;gt;
    /// Gets the current count.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;value&amp;gt;The current count.&amp;lt;/value&amp;gt;
    public int CurCount
    {
        get { return mCacheStack.Count; }
    }
    #endregion

    protected IObjectFactory&amp;lt;T&amp;gt; mFactory;

    protected Stack&amp;lt;T&amp;gt; mCacheStack = new Stack&amp;lt;T&amp;gt;();

    /// &amp;lt;summary&amp;gt;
    /// default is 5
    /// &amp;lt;/summary&amp;gt;
    protected int mMaxCount = 5;

    public virtual T Allocate()
    {
        return mCacheStack.Count == 0
            ? mFactory.Create()
            : mCacheStack.Pop();
    }

    public abstract bool Recycle(T obj);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;
代码不多，设计阶段基本就这样。下面介绍如何实现一个简易的对象池。

#### 对象池实现

首先要实现一个对象的创建器,代码如下所示:
``` C#
    using System;

    public class CustomObjectFactory&amp;lt;T&amp;gt; : IObjectFactory&amp;lt;T&amp;gt;
    {
        public CustomObjectFactory(Func&amp;lt;T&amp;gt; factoryMethod)
        {
            mFactoryMethod = factoryMethod;
        }
        
        protected Func&amp;lt;T&amp;gt; mFactoryMethod;

        public T Create()
        {
            return mFactoryMethod();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比较简单，只是维护了一个返回值为T的委托(如果说得有误请指正)。&lt;br/&gt;对象池实现:&lt;br/&gt;``` C#&lt;br/&gt;using System;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// unsafe but fast
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
public class SimpleObjectPool&amp;lt;T&amp;gt; : Pool&amp;lt;T&amp;gt;
{
    readonly Action&amp;lt;T&amp;gt; mResetMethod;

    public SimpleObjectPool(Func&amp;lt;T&amp;gt; factoryMethod, Action&amp;lt;T&amp;gt; resetMethod = null,int initCount = 0)
    {
        mFactory = new CustomObjectFactory&amp;lt;T&amp;gt;(factoryMethod);
        mResetMethod = resetMethod;

        for (int i = 0; i &amp;lt; initCount; i++)
        {
            mCacheStack.Push(mFactory.Create());
        }
    }

    public override bool Recycle(T obj)
    {
        mResetMethod.InvokeGracefully(obj);
        mCacheStack.Push(obj);
        return true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;实现也很简单，这里不多说了。

#### 如何使用?
``` C#
            var fishPool = new SimpleObjectPool&amp;lt;Fish&amp;gt;(() =&amp;gt; new Fish(), null, 100);

            Log.I(&quot;fishPool.CurCount:{0}&quot;, fishPool.CurCount);

            var fishOne = fishPool.Allocate();
            
            Log.I(&quot;fishPool.CurCount:{0}&quot;, fishPool.CurCount);

            fishPool.Recycle(fishOne);
            
            Log.I(&quot;fishPool.CurCount:{0}&quot;, fishPool.CurCount);

            for (int i = 0; i &amp;lt; 10; i++)
            {
                fishPool.Allocate();
            }
            
            Log.I(&quot;fishPool.CurCount:{0}&quot;, fishPool.CurCount);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fishPool.CurCount:100
fishPool.CurCount:99
fishPool.CurCount:100
fishPool.CurCount:90
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OK，本篇就介绍到这里&lt;/p&gt;
&lt;h4 id=&quot;toc_1&quot;&gt;相关链接:&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/liangxiegame/QFramework&quot;&gt;QFramework地址&lt;/a&gt;:&lt;a href=&quot;https://github.com/liangxiegame/QFramework&quot;&gt;https://github.com/liangxiegame/QFramework&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载请注明地址:&lt;a href=&quot;http://liangxiegame.com/&quot;&gt;凉鞋的笔记&lt;/a&gt;&lt;a href=&quot;http://liangxiegame.com/&quot;&gt;http://liangxiegame.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微信公众号:liangxiegame&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://liangxiegame.com/content/images/2017/06/qrcode_for_gh_32f0f3669ac8_430.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 08 Nov 2017 15:20:00 +0000</pubDate>
<dc:creator>凉鞋的笔记</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liangxiegame/p/Unity-you-xi-kuang-jia-da-jian-shi-jiu-jian-yi-dui.html</dc:identifier>
</item>
<item>
<title>让普通 Java 类自动感知 Activity Lifecycle - -Reset</title>
<link>http://www.cnblogs.com/-reset/p/7806852.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-reset/p/7806852.html</guid>
<description>&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;在 Android 开发中，我们都很熟悉 Activity 的 Lifecycle，并且会在特定的 Lifecycle 下执行特定的操作。当然，我们清楚 Lifecycle 本身是带有 Android 特质的，那尝试设想下，如果 &lt;code&gt;普通的 Java Class 也能自动感知 Lifecycle 呢&lt;/code&gt; ？咋一听这个想法似乎背后意义不大，但在实际探索中，我们发现这个特性能为我们达成一些之前未考虑到或者不易实现的优化。&lt;strong&gt;java学习群669823128&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文分享下我们基于这个思想所开发的框架： &lt;code&gt;AutoLifecycle&lt;/code&gt; 及其带来的一些有意思的实践。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优化一：当Activity进入onDestroy时，自动取消网络请求返回&lt;/li&gt;
&lt;li&gt;优化二：自动将网络请求时机提前到View渲染之前，提高页面打开速度&lt;/li&gt;
&lt;li&gt;优化三：MVP改进，让Presenter和View自动bind/unBind&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注：下文提到的 &lt;code&gt;Lifecycle-Aware&lt;/code&gt; 就是这里指代的 &lt;code&gt;让普通 Java Class 自动获取 Lifecycle&lt;/code&gt; 。&lt;/p&gt;
&lt;h2&gt;实践及优化&lt;/h2&gt;
&lt;h3&gt;优化一：当Activity进入onDestroy时，自动取消网络请求返回&lt;/h3&gt;
&lt;p&gt;在网络请求时，相信大家都有一个经验：在每个网络结果回来时，我们做的第一件事不是显示数据，而是写个if-else判断Activity还在不在。&lt;/p&gt;
&lt;pre class=&quot;prettyprint hljs dart&quot;&gt;
mTopApiObservable
  ...
  .subscribe(&lt;span class=&quot;hljs-keyword&quot;&gt;new Subscriber&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;Object&amp;gt;() {
      &lt;span class=&quot;hljs-meta&quot;&gt;@Override
      public &lt;span class=&quot;hljs-keyword&quot;&gt;void onNext(&lt;span class=&quot;hljs-built_in&quot;&gt;Object data) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if(activity == &lt;span class=&quot;hljs-keyword&quot;&gt;null) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;return; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;由于网络请求都是异步的，所以不得不做这样的判断，来防止不可预测的空指针问题或内存泄漏问题。&lt;/p&gt;
&lt;p&gt;既然你总是担心 &lt;code&gt;Activity&lt;/code&gt; 还在不在，那么如果我们通过 &lt;code&gt;Lifecycle-Aware让每个网络请求能自动感知Activity的onDestroy事件&lt;/code&gt; ，&lt;/p&gt;
&lt;p&gt;并在 &lt;code&gt;onDestroy&lt;/code&gt; 时，自动把网络请求结果 &lt;code&gt;取消掉不再返回&lt;/code&gt; ，那就能够消除这个担忧了。&lt;/p&gt;
&lt;pre class=&quot;prettyprint hljs dart&quot;&gt;
mTopApiObservable
  ...
  .compose(bindUntilEvent(ActivityLifecycle.DESTROY)) 
&lt;/pre&gt;
&lt;p&gt;其中最关键的就是 &lt;code&gt;compose(bindUntilEvent(ActivityLifecycle.DESTROY))&lt;/code&gt; 这句，它能达到的效果是：一旦 &lt;code&gt;Activity&lt;/code&gt; 发生 &lt;code&gt;onDestroy&lt;/code&gt; 时， &lt;code&gt;Observer&lt;/code&gt; 的数据就会停止向 &lt;code&gt;Subscriber&lt;/code&gt; 里流动。从而保证 &lt;code&gt;onNext&lt;/code&gt; 无需担心 &lt;code&gt;Activity&lt;/code&gt; 已 &lt;code&gt;Destroy&lt;/code&gt; 这种情况。&lt;/p&gt;
&lt;p&gt;在上面网络请求的实践里，你还可以根据自己的情况把 &lt;code&gt;Destroy&lt;/code&gt; 换成 &lt;code&gt;Stop&lt;/code&gt; / &lt;code&gt;Pause&lt;/code&gt; 等，而且可以看出，这种自动取消机制可适用于任何 &lt;code&gt;Observable&lt;/code&gt; ，不仅仅是网络请求。&lt;/p&gt;
&lt;h3&gt;优化二：自动将网络请求提前到View Inflate之前，加速页面渲染&lt;/h3&gt;
&lt;p&gt;先说下这项优化的原理。&lt;/p&gt;
&lt;p&gt;通常，我们会在 &lt;code&gt;Activity&lt;/code&gt; 的 &lt;code&gt;onCreate&lt;/code&gt; 里依次执行下面的代码：&lt;/p&gt;
&lt;pre class=&quot;prettyprint hljs less&quot;&gt;
&lt;span class=&quot;hljs-variable&quot;&gt;@Override
protected void onCreate(Bundle savedInstanceState) {
    &lt;span class=&quot;hljs-selector-tag&quot;&gt;super&lt;span class=&quot;hljs-selector-class&quot;&gt;.onCreate(savedInstanceState);
    &lt;span class=&quot;hljs-selector-tag&quot;&gt;setContentView(R.layout.XXX);   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;即在 &lt;code&gt;Inflate View&lt;/code&gt; 和 &lt;code&gt;初始化View&lt;/code&gt; 之后，才发起网络请求去加载数据。&lt;/p&gt;
&lt;p&gt;而实际上，网络请求是不占用主线程的，如果能在 &lt;code&gt;Inflate View&lt;/code&gt; 之前就在其他线程发起网络请求，可以把整个页面显示耗时缩短 &lt;code&gt;100ms-200ms&lt;/code&gt; 。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img0.tuicool.com/uQzi6vn.png!web&quot; alt=&quot;&quot;/&gt;&lt;p&gt;LoadBeforeInflate优化效果&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;现在有了 &lt;code&gt;AutoLifecycle&lt;/code&gt; 框架，我们就可以很轻松实现：让Presenter自动监听 &lt;code&gt;Inflate View&lt;/code&gt;这个生命周期，在那时发起网络请求即可。&lt;/p&gt;
&lt;pre class=&quot;prettyprint hljs java&quot;&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;NewPresenter {

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-title&quot;&gt;NewPresenter&lt;span class=&quot;hljs-params&quot;&gt;(IView iView) {
        ...
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;此时，我们的Activity也不用手动调用 &lt;code&gt;presenter.loadDataFromServer();&lt;/code&gt; 了，因为Presenter内会在感知到 &lt;code&gt;Inflate View&lt;/code&gt; 事件时自动发起网络请求。&lt;/p&gt;
&lt;pre class=&quot;prettyprint hljs java&quot;&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;@Override
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;onCreate&lt;span class=&quot;hljs-params&quot;&gt;(Bundle savedInstanceState) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;super.onCreate(savedInstanceState);
    setContentView(R.layout.XXX);
    findViewByIds();
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;经过测试，在保证单个网络请求耗时相同的情况下，页面从 &lt;code&gt;onCreate&lt;/code&gt; 到 &lt;code&gt;显示数据&lt;/code&gt; 的渲染耗时可以从 &lt;code&gt;550ms&lt;/code&gt; 缩短到 &lt;code&gt;367ms&lt;/code&gt; ，也就是 &lt;code&gt;30%-40%&lt;/code&gt; 的优化，效果是非常不错的，而且代码也更加简洁清晰。&lt;/p&gt;
&lt;div&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img2.tuicool.com/f2iAfmA.png!web&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;通过简单的注册 &lt;code&gt;AutoLifecycle&lt;/code&gt; ， &lt;code&gt;Presenter&lt;/code&gt; 能够自动感知到所有 &lt;code&gt;Lifecycle&lt;/code&gt; ，甚至包括自定义的特殊 &lt;code&gt;Lifecycle&lt;/code&gt; ，如下图：&lt;/p&gt;
&lt;div&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img0.tuicool.com/ieu6fmN.png!web&quot; alt=&quot;&quot;/&gt;&lt;p&gt;LifecycleAwarePresenter&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;优化三：MVP改进，让Presenter和View自动bind/unBind&lt;/h3&gt;
&lt;p&gt;第一项优化比较直接，可以先让大家形成一个直观印象。&lt;/p&gt;
&lt;p&gt;我们项目是采用MVP项目，对于 &lt;code&gt;Presenter&lt;/code&gt; 的使用存在一段固定代码，即在 &lt;code&gt;onCreate&lt;/code&gt; 时调用&lt;code&gt;bindView()&lt;/code&gt; ，在 &lt;code&gt;onDestroy&lt;/code&gt; 时调用 &lt;code&gt;unBindView()&lt;/code&gt; 。如下图：&lt;/p&gt;
&lt;pre class=&quot;prettyprint hljs scala&quot;&gt;
public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;OldActivity &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;BaseActivity {

    &lt;span class=&quot;hljs-type&quot;&gt;BasePresenter mPresenter = &lt;span class=&quot;hljs-keyword&quot;&gt;new &lt;span class=&quot;hljs-type&quot;&gt;BasePresenter();

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-keyword&quot;&gt;protected void onCreate(&lt;span class=&quot;hljs-meta&quot;&gt;@Nullable &lt;span class=&quot;hljs-type&quot;&gt;Bundle savedInstanceState) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;super.onCreate(savedInstanceState);
        mPresenter.bindView(&lt;span class=&quot;hljs-keyword&quot;&gt;this); &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;那么，既然我们现在能 &lt;code&gt;让一个普通类自动感知Lifecycle&lt;/code&gt; ，那其实也就能让 &lt;code&gt;Presenter&lt;/code&gt; 在感知到&lt;code&gt;onCreate&lt;/code&gt; 时 &lt;code&gt;自动bindView&lt;/code&gt; ，在感知到 &lt;code&gt;onDestroy&lt;/code&gt; 时 &lt;code&gt;自动unBindView&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;改进后的代码如下：&lt;/p&gt;
&lt;pre class=&quot;prettyprint hljs scala&quot;&gt;
public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;NewActivity &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;BaseActivity {

    &lt;span class=&quot;hljs-type&quot;&gt;NewPresenter mPresenter;

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-keyword&quot;&gt;protected void onCreate(&lt;span class=&quot;hljs-meta&quot;&gt;@Nullable &lt;span class=&quot;hljs-type&quot;&gt;Bundle savedInstanceState) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;super.onCreate(savedInstanceState);
        mPresenter = &lt;span class=&quot;hljs-keyword&quot;&gt;new &lt;span class=&quot;hljs-type&quot;&gt;NewPresenter(&lt;span class=&quot;hljs-keyword&quot;&gt;this); &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;其实，在大家的平常开发中，还会存在许多类似 &lt;code&gt;Presenter&lt;/code&gt; 的类： &lt;code&gt;需要在某个特定的Lifecycle下执行一些动作&lt;/code&gt; 。这时就可以基于 &lt;code&gt;Lifecycle-Aware&lt;/code&gt; 来让这个普通类自动去执行，而不是去每个&lt;code&gt;Activity/Fragment&lt;/code&gt; 里写一遍，提高类的内聚性。&lt;/p&gt;
&lt;h2&gt;AutoLifecycle的核心原理&lt;/h2&gt;
&lt;p&gt;(TL;DR)&lt;/p&gt;
&lt;p&gt;下面介绍下 &lt;code&gt;AutoLifecycle&lt;/code&gt; 的关键实现部分，感兴趣的读者可以参考。&lt;/p&gt;
&lt;h3&gt;1. 让Activity对外发送Lifecycle事件&lt;/h3&gt;
&lt;p&gt;使用过 &lt;code&gt;RxJava&lt;/code&gt; 的同学知道里面有一个 &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/subjects/PublishSubject.html&quot; rel=&quot;nofollow,noindex&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;PublishSubject&lt;/code&gt; &lt;/a&gt;，基于观察者模式，主动发送并接受消息。这里我们用 &lt;code&gt;PublishSubject&lt;/code&gt; 来发送Lifecycle事件。见如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img2.tuicool.com/zeMzaaI.png!web&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;这里的Lifecycle事件可以自己定义，比如前面提到的PRE_INFLATE事件，是在setContentView之前发送，类似：&lt;/h4&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img1.tuicool.com/eiIB7jz.png!web&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2. 感知某个Lifecycle的发生并自动执行回调&lt;/h3&gt;
&lt;p&gt;上面提了， &lt;code&gt;PublishSubject&lt;/code&gt; 不仅能发送消息，还能接受自己的消息。基于这个特点，我们便可以监听每一个LifecycleEvent。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img2.tuicool.com/VbYjQvb.png!web&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的参数Observable是我们希望被回调的函数，IContextLifecycle是指定的Lifecycle。即当指定的Lifecycle Event发生时，会自动subscribe提供的Observable。&lt;/p&gt;
&lt;p&gt;基于这个功能，便可以实现上面场景一和场景二里的 &lt;code&gt;@AutoLifecycleEvent&lt;/code&gt; 注解了，即把 &lt;code&gt;@AutoLifecycleEvent&lt;/code&gt; 标注的函数包装成一个Observable，通过这个 &lt;code&gt;executeOn&lt;/code&gt; 来注册函数的执行生命周期即可。&lt;/p&gt;
&lt;h3&gt;3. 监听Lifecycle并取消网络请求结果&lt;/h3&gt;
&lt;p&gt;在场景三里，我们为网络请求的 &lt;code&gt;Observable&lt;/code&gt; 提供了一个 &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.Transformer.html&quot; rel=&quot;nofollow,noindex&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;Transformer&lt;/code&gt; &lt;/a&gt;，它能在监听到某个Lifecycle发生时，停止数据流的向下流动。该 &lt;code&gt;Transformer&lt;/code&gt; 的核心实现是：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img1.tuicool.com/neaaYr6.png!web&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，当指定的Lifecycle一旦发生，我们网络请求Observable就会停止向下传递数据。&lt;/p&gt;
&lt;h3&gt;4. 支持自定义Lifecycle，支持Activity/Fragment/DialogFrament等&lt;/h3&gt;
&lt;p&gt;可以看出， &lt;code&gt;AutoLifecycle&lt;/code&gt; 除了支持常规的生命周期，还能支持自定义的特殊生命周期，比如View Inflate前。&lt;/p&gt;
&lt;p&gt;另外，上面都是以Activity为例，不过显然这套框架可以灵活扩展，不局限于Activity，还能适用于Fragment、DialogFrament等。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Lifecycle-Aware&lt;/code&gt; 思想是Google官方提出来的概念：赋予普通类自动感知生命周期的能力。而本文也是基于这个思想，提供了一些具体实践和优化的思路，读者同学可以根据自己的情况做更多的改进和尝试。&lt;strong&gt;java学习群669823128&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 Nov 2017 15:13:00 +0000</pubDate>
<dc:creator>-Reset</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/-reset/p/7806852.html</dc:identifier>
</item>
<item>
<title>HTTPS协议，TLS协议 - snowater</title>
<link>http://www.cnblogs.com/snowater/p/7804889.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snowater/p/7804889.html</guid>
<description>&lt;h3&gt;一、HTTPS 协议&lt;/h3&gt;
&lt;p&gt;HTTPS协议其实就是HTTP over TSL，TSL(Transport Layer Security) 传输层安全协议是https协议的核心。&lt;/p&gt;
&lt;p&gt;TSL可以理解为SSL (Secure Socket Layer)安全套接字层的后续版本。&lt;/p&gt;
&lt;p&gt;TSL握手协议如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108204533294-1339745312.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（注：图片来源于google图片）&lt;/p&gt;
&lt;p&gt;在建立TCP连接后，开始建立TLS连接。下面抓包分析TLS握手过程，抓包图片来源于&lt;a href=&quot;http://www.freebuf.com/articles/network/116497.html&quot; target=&quot;_blank&quot;&gt;传输层安全协议抓包分析之SSL/TLS&lt;/a&gt; (自己没抓到这么完整的包，只能搬运过来了，摔)&lt;/p&gt;
&lt;p&gt;a. client端发起握手请求，会向服务器发送一个ClientHello消息，该消息包括其所支持的SSL/TLS版本、Cipher Suite加密算法列表（告知服务器自己支持哪些加密算法）、sessionID、随机数等内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108210913731-381290333.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;b. 服务器收到请求后会向client端发送ServerHello消息，其中包括：&lt;/p&gt;
&lt;p&gt;SSL/TLS版本；&lt;/p&gt;
&lt;p&gt;session ID，因为是首次连接会新生成一个session id发给client；&lt;/p&gt;
&lt;p&gt;Cipher Suite，sever端从Client Hello消息中的Cipher Suite加密算法列表中选择使用的加密算法；&lt;/p&gt;
&lt;p&gt;Radmon 随机数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108211404888-25605470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;c.经过ServerHello消息确定TLS协议版本和选择加密算法之后，就可以开始发送证书给client端了。证书中包含公钥、签名、证书机构等信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108212037372-893214258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;d.服务器向client发送ServerKeyExchange消息，消息中包含了服务器这边的EC Diffie-Hellman算法相关参数。此消息一般只在选择使用DHE 和DH_anon等加密算法组合时才会由服务器发出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108212528247-743481578.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;e. server端发送ServerHelloDone消息，表明服务器端握手消息已经发送完成了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108212652544-470476594.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;f.client端收到server发来的证书，会去验证证书，当认为证书可信之后，会向server发送ClientKeyExchange消息，消息中包含客户端这边的EC Diffie-Hellman算法相关参数，然后服务器和客户端都可根据接收到的对方参数和自身参数运算出Premaster secret，为生成会话密钥做准备。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108212742997-638983083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; g.此时client端和server端都可以根据之前通信内容计算出Master Secret（加密传输所使用的对称加密秘钥），client端通过发送此消息告知server端开始使用加密方式发送消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108213240841-1040450792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; h.客户端使用之前握手过程中获得的服务器随机数、客户端随机数、Premaster secret计算生成会话密钥master secret，然后使用该会话密钥加密之前所有收发握手消息的Hash和MAC值，发送给服务器，以验证加密通信是否可用。服务器将使用相同的方法生成相同的会话密钥以解密此消息，校验其中的Hash和MAC值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108213303466-1978167763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; i.服务器发送ChangeCipherSpec消息，通知客户端此消息以后服务器会以加密方式发送数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108213315263-1721933592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; j.sever端使用会话密钥加密（生成方式与客户端相同，使用握手过程中获得的服务器随机数、客户端随机数、Premaster secret计算生成）之前所有收发握手消息的Hash和MAC值，发送给客户端去校验。若客户端服务器都校验成功，握手阶段完成，双方将按照SSL记录协议的规范使用协商生成的会话密钥加密发送数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108213325309-1347694901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;二、session ID的复用&lt;/h3&gt;
&lt;p&gt;根据&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot; target=&quot;_blank&quot;&gt;rfc5246&lt;/a&gt;，client和server建立TLS握手过程如下所示：&lt;/p&gt;
&lt;pre class=&quot;newpage&quot;&gt;
      Client                                               Server

      ClientHello                  --------&amp;gt;
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   &amp;lt;--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     --------&amp;gt;
                                               [ChangeCipherSpec]
                                   &amp;lt;--------             Finished
      Application Data             &amp;lt;-------&amp;gt;     Application Data

             Figure 1.  Message flow for a full handshake
&lt;/pre&gt;
&lt;pre class=&quot;newpage&quot;&gt;
* Indicates optional or situation-dependent messages that are not
   always sent.
&lt;/pre&gt;
&lt;p&gt;client在向server发送ClientHello消息的时候，会传送Session ID给server端，server端收到session Id后会去session缓存中查找是否有相同值。如果找到相同值，则server直接发送一个具有相同session ID的ServerHello消息给client端（此时不必新建Session ID），然后双方各发一次ChangeCipherSpec消息后直接进入Finished消息互发阶段，具体如下图所示：&lt;/p&gt;
&lt;pre class=&quot;newpage&quot;&gt;
      Client                                                Server

      ClientHello                   --------&amp;gt;
                                                       ServerHello
                                                [ChangeCipherSpec]
                                    &amp;lt;--------             Finished
      [ChangeCipherSpec]
      Finished                      --------&amp;gt;
      Application Data              &amp;lt;-------&amp;gt;     Application Data

          Figure 2.  Message flow for an abbreviated handshake
&lt;/pre&gt;
&lt;p&gt;client和server通过缓存Session ID可以快速建立TLS握手，但是这么做也有一些弊端，例如：1）负载均衡中，多机之间往往没有同步 Session 信息，如果客户端两次请求没有落在同一台机器上就无法找到匹配的信息；2）服务端存储 Session ID 对应的信息不好控制失效时间，太短起不到作用，太长又占用服务端大量资源。而 Session Ticket（会话记录单）可以解决这些问题，Session Ticket 是用只有服务端知道的安全密钥加密过的会话信息，最终保存在浏览器端。浏览器如果在 ClientHello 时带上了 Session Ticket，只要服务器能成功解密就可以完成快速握手。&lt;/p&gt;
&lt;h3&gt;三、数字证书的验证&lt;/h3&gt;
&lt;p&gt;client端收到server端发过来的证书，首先必须要做的事验证证书是否可信。如何验证证书是否可信呢？为了解决这个问题，我们先来了解下证书的组成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108221111716-1100586299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从这里面我们能看到证书包含以下内容：&lt;/p&gt;
&lt;p&gt;(1) Validity也即有效期，有效期包含生效时间和失效时间，是一个时间区间；&lt;/p&gt;
&lt;p&gt;(2) 公钥信息Subject Public Key Info，包括公钥的加密算法和公钥内容；&lt;/p&gt;
&lt;p&gt;(3) Fingerprints信息，fingerprints用于验证证书的完整性，也就是说确保证书没有被修改过。 其原理就是在发布证书时，发布者根据指纹算法(此处证书使用了SHA-1和SHA-256算法)计算整个证书的hash值(指纹)并和证书放在一起，client在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值相同，则说明证书未被修改过；如果hash值不一致，则表明证书内容被篡改过；&lt;/p&gt;
&lt;p&gt;(4) 证书的签名：Certificate Signature Value和Certificate Signature Algorithm，对证书签名所使用的Hash算法和Hash值；&lt;/p&gt;
&lt;p&gt;(5) 除此之外我们还能看到证书中包含签发该证书的CA机构和该证书是签发给哪个组织/公司信息以及Fingerprints信息等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108224731684-426513846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，为签名过程和client端验证过程。中间方框为一个数字证书，在制作数字证书时，会将证书中的部分内容进行一次Hash得到一个Hash值，然后证书认证机构简称CA会使用私钥将该Hash值加密为Certificate Signature。&lt;/p&gt;
&lt;p&gt;当证书发送给Client端之后，Client端首先会使用同样的Hash算法获得一个证书的hash值H1。通常浏览器和操作系统中集成了CA机构的公钥信息，浏览器收到证书后可以使用这些公钥解密Certificate Signature内容，得到一个hash值H2。&lt;/p&gt;
&lt;p&gt;比较H1和H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。 &lt;/p&gt;
&lt;h3&gt;四、非对称加解密&lt;/h3&gt;
&lt;p&gt;非对称加密包含一个密钥对：公钥和私钥。公钥可以公开，私钥必须安全保存。&lt;/p&gt;
&lt;p&gt;建立HTTPS连接以后，client（浏览器）已经获得server段的公钥，此时client端向server端发送数据都会使用公钥进行加密。server端收到加密的信息之后，可以使用私钥进行解密。client端用公钥加密的消息只有使用与公钥对应的私钥才能解密，否则无法解密。&lt;/p&gt;
&lt;p&gt;server端同样需要将消息用自己的私钥进行加密，然后发送给client端，client端可以通过之前获得的公钥解密消息。&lt;/p&gt;
&lt;p&gt;client端加密消息后，之后私钥持有方能解密，保证了用户提交敏感信息的安全性。而server端加密消息发送给client端，这一过程可以避免第三方篡改web内容，比如插入广告等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108182600294-174828072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;https://tools.ietf.org/html/rfc5246#page-6&lt;/p&gt;
&lt;p&gt;http://www.freebuf.com/articles/network/116497.html&lt;/p&gt;
&lt;p&gt;https://imququ.com/post/optimize-tls-handshake.html&lt;/p&gt;
&lt;p&gt;http://blog.csdn.net/wzzvictory/article/details/9015155&lt;/p&gt;

</description>
<pubDate>Wed, 08 Nov 2017 14:52:00 +0000</pubDate>
<dc:creator>snowater</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snowater/p/7804889.html</dc:identifier>
</item>
<item>
<title>如何运用GitHub来提高生产效率 - kid551</title>
<link>http://www.cnblogs.com/kid551/p/7806719.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kid551/p/7806719.html</guid>
<description>&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;这是一篇GitHub的入门级文章，主要针对git的初学者。我们将讨论初学者最关心的一些问题，如：为什么我们要使用GitHub，它的应用有哪些，如何运用它去帮助我们提高工作效率，以及它的基本用法有哪些。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;希望看到文中的相关资源链接的朋友，可以直接访问我的中文blog：https://www.terencexie.com 。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在展开讨论GitHub之前，其实需要澄清一个在初学者脑中不太清晰的概念：GitHub和git是一回事吗？&lt;/p&gt;
&lt;p&gt;其他人我不知道，但我第一次接触GitHub的时候，几乎没有注意到GitHub和git是两个东西。更夸张的是，我甚至直接在脑中无理由暴力脑补“嗯，说不定git是GitHub的一个简称。”现在想来当然极其可笑，但作为新人不得不面对的一个现实是：新人之所以是新人不是因为他在某一方面很薄弱，而是各方面都千疮百孔。像这样的不经过任何调查、也没有任何官方文档或者实验数据作支持，冒然做出一个推论并把它奉为一种真实，是进一步走向混乱的重要因素。&lt;/p&gt;
&lt;p&gt;git和GitHub其实是两个有联系但却根本不同的东西。用一种不太严格的说法，可以这样理解它们的关系：GitHub是支持git的remote端（服务器端）的一个服务。它就好比是你的云端服务，用于保存你本地的&lt;strong&gt;代码版本控制&lt;/strong&gt;的所有记录。再介绍了git之后，我们会再一次澄清和展开这个概念。&lt;/p&gt;
&lt;h2&gt;什么是git&lt;/h2&gt;
&lt;p&gt;git是写出Linux内核的大神Linus，捣鼓出来的代码版本控制工具。虽然其动机是服务于代码，但其实对非开发者的普通用户，也是很有用的工具。&lt;/p&gt;
&lt;p&gt;什么叫做版本控制？&lt;/p&gt;
&lt;p&gt;我们可以从比较熟悉的&lt;strong&gt;游戏存档&lt;/strong&gt;谈起。在玩RPG游戏的时候，一个非常重要的基础功能便是能够存储当前的游戏状态。因为你几乎不可能在完全不停止的情况下一次性通关。停止你游戏story展开的因素有很多，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你玩游戏的进度很慢，到了睡觉时间，也就不得不停止，下次再战。&lt;/li&gt;
&lt;li&gt;你悲剧地遭遇了电脑的突然中断，不得不重新进入游戏。&lt;/li&gt;
&lt;li&gt;一切都很顺利，但你却不幸被游戏中的大boss干掉了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有了游戏存档功能，一方面你可以再一次从你中断的地方继续游戏，另一方面，如果你的游戏有多条分支线story，你可以从分支的地方继续开始，选择另一条路线体验不同的经历。&lt;/p&gt;
&lt;p&gt;那么，git干的其实是同样的事情。git其实就是为&lt;strong&gt;特定的文件目录&lt;/strong&gt;下的所有文件，提供一个&lt;strong&gt;存档功能&lt;/strong&gt;（这个特定的文件目录，就是运行了&lt;code&gt;git init&lt;/code&gt;命令的文件目录）。在git的视角之下，每一个时间点的文件目录状态，都可以作为一个存储节点（同游戏存档一样）。而像这样的可以存储一个文件的各个时间节点的文件状态的功能，就叫做&lt;strong&gt;版本控制&lt;/strong&gt;。如果从使用Facebook的角度来讲，&lt;code&gt;git&lt;/code&gt;提供的功能就是为这个文件目录提供一个&lt;strong&gt;时间线&lt;/strong&gt;，将这个文件目录下发生的所有事情全部记载下来，起到一个类似于游戏存档的功能。&lt;/p&gt;
&lt;p&gt;例如，假设我们在运行了&lt;code&gt;git init&lt;/code&gt;命令的文件目录&lt;code&gt;MyDirectory&lt;/code&gt;下有两个文件&lt;code&gt;File1.txt&lt;/code&gt;和&lt;code&gt;File2.txt&lt;/code&gt;。&lt;code&gt;File1.txt&lt;/code&gt;和&lt;code&gt;File2.txt&lt;/code&gt;这两个文件各包含两行文字，如下图。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;wp-image-239 size-medium&quot; title=&quot;图1.0&quot; src=&quot;https://www.terencexie.com/wp-content/uploads/2017/11/FileSystem-300x182.jpg&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;182&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1.0&lt;/p&gt;
&lt;p&gt;作为初级程序员的教程，这里需要多说几句，解释一下为什么这个例子可以&lt;em&gt;不失一般性&lt;/em&gt;，作为其它所有文件的代表。因为所有的文件在其底层的存储方式都是字节序列。从计算机的角度来看，所有的文件就是一行行的文字而已。所以，如果理解了&lt;code&gt;git&lt;/code&gt;如何去处理一个人类可以识别的文本文件。那么，对于任何文件来讲，其原理也是相同的，不过是处理一行行计算机认识的文字，即一堆0、1序列文字流。&lt;/p&gt;
&lt;p&gt;如图1.0，这里便可以作为&lt;code&gt;MyDirectory&lt;/code&gt;的一个当前时间点的文件状态。当&lt;code&gt;MyDirectory&lt;/code&gt;下的任何一个文件有所改动，&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;size-medium wp-image-242&quot; src=&quot;https://www.terencexie.com/wp-content/uploads/2017/11/FileSystem2-300x182.jpg&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;182&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1.1&lt;/p&gt;
&lt;p&gt;那么此刻的状态，就好比是游戏当中的主角在地图上移动了一个位置，可以作为另一个时间点的文件状态（图1.1）来做存储。&lt;/p&gt;
&lt;p&gt;可以发现，到目前为止的讨论，都和GitHub无关、和remote端的服务器没有关系。因为&lt;code&gt;git&lt;/code&gt;的使用可以仅仅限于本地，和网路连接无关。因而，对于普通用户来说，完全可以使用&lt;code&gt;git&lt;/code&gt;来为你的办公文件、私人文件做存档。&lt;strong&gt;存档&lt;/strong&gt;与&lt;strong&gt;备份&lt;/strong&gt;的不同在于，后者只能够存储一个文件状态，而前者却可以存储多个文件状态，也即是将整个文件的时间线全部存储下来。有了它，你便能够去了解这个文件的整个衍化、生长历史，从而对它有更加深层次的认识和理解。&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;git&lt;/code&gt;的优质教程我会推荐两个，一个是Udacity的课程&lt;a href=&quot;https://www.udacity.com/course/how-to-use-git-and-github--ud775&quot;&gt;How to Use Git and GitHub&lt;/a&gt;，另一个是git的官方文档教程&lt;a href=&quot;https://git-scm.com/book/en/v2&quot;&gt;Pro Git&lt;/a&gt;，里面提供了可以下载的多种格式的电子版。&lt;/p&gt;
&lt;h2&gt;常用的git命令&lt;/h2&gt;
&lt;h3&gt;为文件目录提供版本控制功能&lt;/h3&gt;
&lt;p&gt;最开始的命令当然是&lt;code&gt;git init&lt;/code&gt;，用于为一个文件目录提供版本控制的&lt;code&gt;git&lt;/code&gt;功能。例如，想要为文件目录&lt;code&gt;/Users/Terence/Documents&lt;/code&gt;提供版本控制的功能，那么只需要两步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将命令行切换到目标文件目录下：&lt;code&gt;cd /Users/Terence/Documents &lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;运行&lt;code&gt;git init&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;此时， &lt;code&gt;/Users/Terence/Documents&lt;/code&gt;目录便具备了版本控制功能（其实质是在这个目录下创建了一个&lt;code&gt;.git&lt;/code&gt;隐藏文件夹）。&lt;/p&gt;
&lt;h3&gt;版本控制下的文件修改和提交&lt;/h3&gt;
&lt;p&gt;接下来要讨论具备了&lt;code&gt;git&lt;/code&gt;监控的文件目录下，一个文件会呈现的几个状态。在&lt;code&gt;git&lt;/code&gt;的体系下，一个文件可以具备四种状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Untracked&lt;/li&gt;
&lt;li&gt;Unmodified&lt;/li&gt;
&lt;li&gt;Modified&lt;/li&gt;
&lt;li&gt;Staged&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不同状态的同一个文件可以同时彼此独立存在。下面根据&lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository&quot;&gt;Pro Git 2.2&lt;/a&gt;上的一个文件的周期图来做讲解。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot; wp-image-243&quot; src=&quot;https://www.terencexie.com/wp-content/uploads/2017/11/Gitlifecycle-300x124.png&quot; alt=&quot;&quot; width=&quot;401&quot; height=&quot;166&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Git File Lifecycle&lt;/p&gt;
&lt;p&gt;下面以从上到下的顺序讲解这几个箭头相关联的状态切换。&lt;/p&gt;
&lt;p&gt;首先是文件的&lt;code&gt;untracked&lt;/code&gt;状态，指的是还未被纳入&lt;code&gt;git&lt;/code&gt;存档体系的文件。虽然这个文件目录通过&lt;code&gt;git init&lt;/code&gt;具备了存档的功能，但还未指定哪些文件的时间线可以被存档。于是这些未被纳入存档的文件的状态便是&lt;code&gt;untracked&lt;/code&gt;。 通过命令&lt;code&gt;git add &amp;lt;filename&amp;gt;&lt;/code&gt;便可以将它纳入&lt;strong&gt;待存档&lt;/strong&gt;（&lt;code&gt;staged&lt;/code&gt;）的状态。（这里可以跳跃一个步骤，提前讲解它最后的状态切换，从通过命令&lt;code&gt;git commit &amp;lt;filename&amp;gt;&lt;/code&gt;让&lt;strong&gt;待存档&lt;/strong&gt;（&lt;code&gt;staged&lt;/code&gt;）状态的文件进入到&lt;code&gt;git&lt;/code&gt;库。此时就变成了&lt;code&gt;git&lt;/code&gt;库的&lt;code&gt;unmodified&lt;/code&gt;状态。）&lt;/p&gt;
&lt;p&gt;再来是文件的&lt;code&gt;unmodified&lt;/code&gt;（未修改）状态。一般在&lt;code&gt;git&lt;/code&gt;界面中将文件名显示为蓝色。一个文件要成为&lt;code&gt;unmodified&lt;/code&gt;状态，首要的前提是它已经被纳入了存档体系、并且它已经被存档。也就是说，它一定是从&lt;strong&gt;待存档&lt;/strong&gt;（&lt;code&gt;staged&lt;/code&gt;）的状态，通过执行命令&lt;code&gt;git commit &amp;lt;filename&amp;gt;&lt;/code&gt;（提交到&lt;code&gt;git&lt;/code&gt;库，也就是把当前的这个状态存储好）后所处的状态。&lt;/p&gt;
&lt;p&gt;然后是文件的&lt;code&gt;modified&lt;/code&gt;状态，也就是对一个文件做了修改后的状态。一般在&lt;code&gt;git&lt;/code&gt;的界面将文件名显示为红色。例如，假设图1.0都所有文件都是&lt;code&gt;unmodified&lt;/code&gt;状态，我们对File2.txt做了修改成为图1.1。此时，File2.txt就是&lt;code&gt;modified&lt;/code&gt;状态。&lt;/p&gt;
&lt;p&gt;最后是文件的&lt;code&gt;staged&lt;/code&gt;状态，也就是&lt;strong&gt;待存储&lt;/strong&gt;状态。一般在&lt;code&gt;git&lt;/code&gt;界面中将文件名显示为绿色。这个&lt;code&gt;staged&lt;/code&gt;状态是非常微妙的一个状态，它能够与&lt;code&gt;modified&lt;/code&gt;状态同时存在。&lt;/p&gt;
&lt;p&gt;举个例子：现在我们假设在图1.1的基础上运行了命令&lt;code&gt;git add File2.txt&lt;/code&gt;，那么此时的文件状态就变成了：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;size-medium wp-image-248&quot; src=&quot;https://www.terencexie.com/wp-content/uploads/2017/11/FileSystem3-300x182.jpg&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;182&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1.2&lt;/p&gt;
&lt;p&gt;也就是&lt;strong&gt;Yoga&lt;/strong&gt;那一行变成了黑色，也就是&lt;code&gt;unmodified&lt;/code&gt;状态。如果我们对它再做修改，添加文本&lt;strong&gt;L1&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;size-medium wp-image-249&quot; src=&quot;https://www.terencexie.com/wp-content/uploads/2017/11/FileSystem4-300x182.jpg&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;182&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1.3&lt;/p&gt;
&lt;p&gt;也就是说，此时添加了&lt;strong&gt;L1&lt;/strong&gt;的那一行全部变成了红色。你或许会提出一个疑问，我明明只添加了字符&lt;strong&gt;L1&lt;/strong&gt;，为什么整行都受到了影响？这是因为，&lt;code&gt;git&lt;/code&gt;是以行为单位来考察文件是否有变化。每一行做相应对比，只要有不同，就把整个一行当作有变动的内容处理。&lt;/p&gt;
&lt;p&gt;再运行&lt;code&gt;git add File2.txt&lt;/code&gt;，得到：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;size-medium wp-image-250&quot; src=&quot;https://www.terencexie.com/wp-content/uploads/2017/11/FileSystem5-300x182.jpg&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;182&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1.4&lt;/p&gt;
&lt;p&gt;可以看到，已处于暂存状态&lt;code&gt;staged&lt;/code&gt;的做了改动的那一行变成了绿色。&lt;/p&gt;
&lt;p&gt;微妙的地方来了，如果此时我们&lt;strong&gt;不提交&lt;/strong&gt;我们这个暂存状态&lt;code&gt;staged&lt;/code&gt;，而是继续修改&lt;code&gt;File2.txt&lt;/code&gt;，将刚加入的字符串&lt;strong&gt;L1&lt;/strong&gt;删去，则我们会得到这个文件的两个状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个处于&lt;code&gt;staged&lt;/code&gt;的图1.4的状态；&lt;/li&gt;
&lt;li&gt;另一个则是处于&lt;code&gt;modified&lt;/code&gt;的状态图1.5&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img class=&quot;size-medium wp-image-251&quot; src=&quot;https://www.terencexie.com/wp-content/uploads/2017/11/FileSystem6-300x182.jpg&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;182&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1.5&lt;/p&gt;
&lt;p&gt;注意，这里图1.5和图1.1虽然是一样的，但表针的意思完全不同。图1.1是从&lt;strong&gt;没有Yoga&lt;/strong&gt;的状态，添加了Yoga字符串后形成的。而图1.5是从状态&lt;strong&gt;Yoga. L1&lt;/strong&gt;删除了字符串L1后形成的。&lt;/p&gt;
&lt;p&gt;此刻，如果我们再运行命令&lt;code&gt;git commit File2.txt&lt;/code&gt;，我们提交到&lt;code&gt;git&lt;/code&gt;仓库的代码将会成为具备&lt;strong&gt;Yoga. L1&lt;/strong&gt;的图1.6&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;size-medium wp-image-252&quot; src=&quot;https://www.terencexie.com/wp-content/uploads/2017/11/FileSystem7-300x182.jpg&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;182&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1.6&lt;/p&gt;
&lt;p&gt;同时，&lt;code&gt;File2.txt&lt;/code&gt;依旧会保持&lt;code&gt;modified&lt;/code&gt;的状态图1.5。&lt;/p&gt;
&lt;p&gt;希望这个例子能够帮你看出这里的微妙差别。&lt;/p&gt;
&lt;p&gt;总结起来，我们这里涉及到的命令有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;git init&lt;/code&gt;让文件目录具备&lt;code&gt;git&lt;/code&gt;存储功能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git add &amp;lt;filename&amp;gt;&lt;/code&gt;将未被跟踪的文件（&lt;code&gt;untracked&lt;/code&gt;），或者&lt;code&gt;modified&lt;/code&gt;的文件，添加进暂存状态（&lt;code&gt;staged&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git commit &amp;lt;filename&amp;gt;&lt;/code&gt;将暂存状态的文件（&lt;code&gt;staged&lt;/code&gt;）添加到&lt;code&gt;git&lt;/code&gt;仓库，成为&lt;code&gt;unmodified&lt;/code&gt;状态。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;什么是GitHub&lt;/h2&gt;
&lt;p&gt;GitHub是一家公司，它提供的服务是为用户提供&lt;code&gt;git&lt;/code&gt;的远程（云端）的&lt;code&gt;git&lt;/code&gt;仓储。其想法就是，你本地有一份文件的版本控制仓库，里面保存了所有文件的时间线。但是，如果你更换了一台电脑，想要再次重现以前那台机器的版本控制仓库，就会很麻烦。于是，一个解决方案便是，为何不将我的这个仓库系统放到云端。既可以随时将本地的修改放到云端，纳入正式的代码库，也可以在本地保留一份自己的代码仓库，做自己的修改。&lt;/p&gt;
&lt;p&gt;更具吸引力的是，一旦你的代码放在了云端，你就可以同其他人合作，在世界的不同地方推进同一个项目。大家保留各自对代码的修改，让云端的代码库成为大家认可的main stream正式存储仓库。大家可以在得到彼此的认同后（也就是后面要讲到的对&lt;code&gt;Pull Request (PR)&lt;/code&gt;的处理），将自己的这份代码修改签入到云端的仓储库，也就是GitHub了。&lt;/p&gt;
&lt;p&gt;所以，从这个角度讲，GitHub是一个提供了云端的代码版本控制的&lt;code&gt;git&lt;/code&gt;仓库平台。从这个意义上讲，GitHub确实是技术人员的社交平台，社交平台中的发朋友圈、发Facebook状态消息等价于不断地展现自己对代码的修改更新。大家是在通过自己的项目状态，来展现各自的工作进展以及最新的项目进展。仔细研究这些版本控制的历史，就能够还原出这个项目、这个工程师的整个成长历史。&lt;/p&gt;
&lt;p&gt;在我看来，使用GitHub的目的无非是两个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;学习他人的代码，并希望重现这个项目的结果，或者作出自己的贡献；&lt;/li&gt;
&lt;li&gt;或者是将自己的工作迁移到GitHub上，使得自己的工作能够得到一个云端的备份，或者能够更方便与在不同地理位置的人合作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里，我想展开谈一下这两点的细节和初学者的疑问点。它们本身并不需要太高深的技术来解决。只是，它们会成为初学者的一道屏障。澄清这些模糊的概念，可以极大地提高初学者对GitHub的掌握效率。&lt;/p&gt;
&lt;h2&gt;使用GitHub学习他人的代码&lt;/h2&gt;
&lt;p&gt;写代码如同写文章，要做出好的工作，需要有大量的高质量阅读作前提。GitHub上有大量的优秀项目供人阅读。Programming的各种精髓和技巧，便藏在这一个个优秀的代码细节中。&lt;/p&gt;
&lt;p&gt;通过一般的参考资料，很容易将这些优质的代码&lt;code&gt;clone&lt;/code&gt;到本地，或者更加简单粗暴直接download整个项目的压缩包到你的本地文件目录。&lt;/p&gt;
&lt;p&gt;然后，问题来了：源代码也到手了，可是，怎么把这堆代码变成所需要的目标软件产品呢？编译、运行？可是，从哪里去编译、运行呢？&lt;/p&gt;
&lt;p&gt;这个问题的提出，其实涉及到&lt;strong&gt;学校的小项目&lt;/strong&gt;和真正的&lt;strong&gt;工业界的大项目&lt;/strong&gt;的实践区别。或许在学校学习&lt;code&gt;C&lt;/code&gt;、&lt;code&gt;Java&lt;/code&gt;、&lt;code&gt;Python&lt;/code&gt;的时候，只需要在命令行或者IDE 界面点击个运行就可以了。&lt;/p&gt;
&lt;p&gt;可是，在真实的复杂项目中，编译代码会涉及到更多的细节和步骤。在编译之前需要更多的环境配置、资源准备以及脚本运行。举一些例子，当你的项目足够复杂后：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要编译的的源代码本身或者部分，是需要通过某个文本文档去生成的。而如何从这个文本文档中提取出需要的信息再生成相应的代码，又是由一个脚本所控制的。&lt;/li&gt;
&lt;li&gt;在编译你的源代码前，需要你提供一些第三方的代码库或者代码包。比如&lt;code&gt;Java&lt;/code&gt;的第三方&lt;code&gt;jar&lt;/code&gt;包。而这些第三方的资源文件，是需要你提前准备呢？还是可以通过一个脚本自动获得呢？&lt;/li&gt;
&lt;li&gt;上面提到的工具脚本，或许是由&lt;strong&gt;某个/某几个&lt;/strong&gt;特定语言编写的。你当前环境中，是否提供了支持这些语言的环境呢？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面提到的这些问题和可能性，远远不是仅凭借源代码就可以推断出来的。所以，拿到这堆源代码不知所措，其实是很正常的。&lt;/p&gt;
&lt;p&gt;那么如何解决这个问题呢？&lt;/p&gt;
&lt;p&gt;我的回答是，看你的运气。&lt;/p&gt;
&lt;p&gt;如果你恰好遇到的项目是由习惯不大好或者是不喜欢写文档的程序员写的，或者这个项目的贡献者本身不希望你知道编译环境，估计你也就只能看着这堆代码发呆了。&lt;/p&gt;
&lt;p&gt;如果你运气不坏，那么，真正的严肃项目，会在它自己的文档（通常是这个项目根目录的&lt;code&gt;README&lt;/code&gt;文件）详细说明如何部署编译环境：它包括需要提前准备哪些编译工具、哪些第三方的代码库、如何调用编译的脚本等等。&lt;/p&gt;
&lt;p&gt;所以，当你在GitHub上看到一个项目时，先别急着做download的动作。先仔细阅读这个项目的文档，看看它是否足够优秀。通常，文档的质量和项目的质量成正相关。用业界俗语来解释原因就是：写文档就是写代码，文档写不好，代码通常也是一团糟。&lt;/p&gt;
&lt;h2&gt;如何在GitHub上工作&lt;/h2&gt;
&lt;p&gt;如果仅仅是简单的把GitHub当作自己的一个代码备份库，其实实践操作并不复杂。无非是不断地在本地修改好代码，再将自己认可的代码签入到远程端的GitHub代码库。&lt;/p&gt;
&lt;p&gt;真正有意思的，是在GitHub上与他人合作，一起完成同一个项目。&lt;/p&gt;
&lt;p&gt;要能够一起合作，首先需要在你的项目中添加你合作者的GitHub账号。这个只需要在GitHub的项目界面中，点击&lt;code&gt;Settings —&amp;gt; Collaborators&lt;/code&gt;，在里面添加你的合作者。这样，你的合作者便获得了对这个项目的更改权限，才有资格对这个GitHub上的项目仓库提交代码。&lt;/p&gt;
&lt;p&gt;如果你们同属于某一个GitHub上的Organization，那么这个Organization的管理员通常会设定其成员，自动拥有这个Organization下所有项目的更改权限。&lt;/p&gt;
&lt;p&gt;下面谈谈GitHub上的工作流程。作为&lt;code&gt;git&lt;/code&gt;的核心，它是以&lt;code&gt;branch&lt;/code&gt;做核心驱动的。&lt;code&gt;master&lt;/code&gt;branch作为主分支，一定要保证它是可以运行的和经过测试的。而你可以在其它的&lt;code&gt;branch&lt;/code&gt;上做自己的feature开发、实验和测试，而完全不会影响代码库的主分支&lt;code&gt;master&lt;/code&gt;branch。&lt;/p&gt;
&lt;p&gt;那么，在GitHub上是同样的。当几个人组成一个团队合作一个项目时，每个成员不应该轻易地直接提交代码到&lt;code&gt;master branch&lt;/code&gt;，即便是你有这样的权限。作为良好的实践规范，你永远应该在自己的私人分支上做代码修改和实验，然后将这个分支&lt;code&gt;push&lt;/code&gt;到GitHub，在GitHub上对这个分支执行&lt;code&gt;Pull Request&lt;/code&gt;来让团队的其他人员review你的代码。当reviewer认可了你的代码后，你才能把你的修改分支&lt;code&gt;merge&lt;/code&gt;到&lt;code&gt;master&lt;/code&gt;。也就是说，&lt;strong&gt;任何人对&lt;code&gt;master&lt;/code&gt;的代码提交之前，必须有其他人的code review这一步；没有其他人的coder review，你不可以向&lt;code&gt;master&lt;/code&gt;分支提交代码即便是你有这个权限&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而在这个&lt;code&gt;Pull Request&lt;/code&gt;的过程中，审核者和被审核者可以对代码的每一行做深入的讨论。每一行代码都可以插入相应的评论，供大家去做深入研究。这些讨论，是整个代码设计的精髓，也是代码功底提升的真正关键。再次回到那句老话，写文档即写代码，它传达的精神便是：你的思想和看法才是支撑整个代码的核心。而某种具体编程语言的书写只是这种思想的一种表达。你只有先整理好了思路、要解决的问题的脉络，你才可以写出清晰的代码。&lt;/p&gt;
&lt;p&gt;甚至，在所谓的合作而其实是师傅带徒弟的过程中，这些code review的价值会远远高于push code。因为push code只是一个结果，而code review的comments讨论，才是帮助你指正问题、更改坏习惯的核心所在。&lt;/p&gt;
&lt;p&gt;而往往初学者又不太明白这一点，误以为这些comments的讨论是配菜，对这些comments的讨论极其不耐烦，一心只想把code签入到代码库。所以，作为mentor他其实是有责任向自己的apprentice指出这个差异与优先级的。&lt;/p&gt;
&lt;p&gt;让我们再强调一次，无论作为学徒还是作为平等的合作者，那些review过程中的comments交流才是整个代码的核心，它们是整个项目的指导思想与精神纲领。只有在review的过程中将问题一步步弄清楚了，你才能够更加容易和自信地修改代码，才能够保证代码库的质量水准。任何轻视code review或者review中的comments的行为，都是一种天真的自我欺骗。你需要拿出同写代码一样的严肃认真，来对待整个code review，来对待review过程中的comments交流。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;近期回顾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484036&amp;amp;idx=1&amp;amp;sn=1657bfb9cbb1f45362320f7cf5a80560&amp;amp;chksm=ec20e538db576c2ea67ce43a99ade18b20179029201ed54d597f1a0d6ab5c0f067292bed59bf&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;打造让用户为自己尖叫的产品&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484032&amp;amp;idx=1&amp;amp;sn=5fd326c2a78858015e1a2326072cdb46&amp;amp;chksm=ec20e53cdb576c2afab8e268b58c446f4dfba5fb313cda2dcb5fe2dfd53f3c7459f7ed876c8d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;2017年10月写字总结&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484025&amp;amp;idx=1&amp;amp;sn=67bd3768a5739ab8f12f6b275aae3847&amp;amp;chksm=ec20e5c5db576cd3b9354b46678aa85d9eaab8f07d1d3465fa54d8557c9e670ac68bf7271ae4&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;平台框架-101&lt;/a&gt;》&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如果你喜欢我的文章或分享，请长按下面的二维码关注我的微信公众号，谢谢！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxPJg8BcFPOe0ibTXw7w4PxMOUQicquOuUmwrQibzU1jAV5q828bIOib5iau8WK4rFSKwIQwicrKZhyJCibLA/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxPJg8BcFPOe0ibTXw7w4PxMOUQicquOuUmwrQibzU1jAV5q828bIOib5iau8WK4rFSKwIQwicrKZhyJCibLA/0?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1240&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VIP赞赏专区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxPJg8BcFPOe0ibTXw7w4PxMOzjdGuTU4pNRFGropHlR1t7ibgYZregHGUiaTIFqO8YHaU13aE6CEQWNw/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; width=&quot;57%&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxPJg8BcFPOe0ibTXw7w4PxMOzjdGuTU4pNRFGropHlR1t7ibgYZregHGUiaTIFqO8YHaU13aE6CEQWNw/0?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1152&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 Nov 2017 14:45:00 +0000</pubDate>
<dc:creator>kid551</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kid551/p/7806719.html</dc:identifier>
</item>
</channel>
</rss>