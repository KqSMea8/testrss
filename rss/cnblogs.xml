<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>微软是如何重写C#编译器并使它开源的 - Liam Wang</title>
<link>http://www.cnblogs.com/willick/p/csharp-roslyn-open-source.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/csharp-roslyn-open-source.html</guid>
<description>&lt;blockquote readability=&quot;4.030612244898&quot;&gt;
&lt;p&gt;译者：王亮&lt;br/&gt;作者：Mads Torgersen (C# Language PM at Microsoft)&lt;br/&gt;原文：&lt;a href=&quot;http://t.cn/EPOG96O&quot;&gt;http://t.cn/EPOG96O&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191097/201810/191097-20181010013836997-1504114652.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Roslyn 是 C# 和 Visual Basic.NET 的开源编译器的代号。以下是它如何在过去十年微软公司最暗淡的环境中开始，并成为开源、跨平台、公共语言引擎的，这一切都是为了 C#（和 VB，下文同）。&lt;/p&gt;
&lt;p&gt;当我在 2005 年加入微软的时候，第一次谈话就开始讨论了关于 Roslyn 将来会是什么样子——那时还是 .NET 2.0 发布之前。那次谈话是关于用 C# 重写 C#。这是编程语言的一种常规做法，是语言成熟一个标志证明。但是还有一个更实际和重要的动机：我们作为 C# 的创造者并不是用 C# 编程，而是用 C++ 编程！每天用 C# 工作让你对 C# 有不同的看法：这是“dogfooding”的力量。（译注：dogfooding 是内部试用或内部测试的意思。）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;客户依赖新编译器的行为与旧编译器将完全相同。为 C# 编写新的编译器意味着尝试 bug-for-bug 地适配旧的编译器 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;重写客户多年来一直掌握的编译器的挑战在于，这些客户对新编译器的依赖行为与旧编译器完全相同。为 C# 编写新的编译器意味着尝试 bug-for-bug 地匹配旧的编译器。我说的不只是已知的 Bug，而是那些开发人员发现并开始依赖的未知和无意的行为，这些行为常常是在不知不觉中发生的。&lt;/p&gt;
&lt;p&gt;多年来，这一挑战的巨大规模甚至阻止了我们开始这个项目。&lt;/p&gt;
&lt;p&gt;另外，虽然使用 C# 编写的新 C# 编译器在语言团队内部会有很多好处，但对客户的价值主张更具挑战性：新的编译器如何帮助现有客户？也许唯一关心用 C# 编写 C# 的人是编译器团队的成员。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;与&lt;/strong&gt;&lt;/span&gt;此同时，另一个问题却越来越大：基于 C# 代码工作的不同工具之间的重复劳动。除了编译器，我们的隔壁团队还在 Visual Studio 中构建对 C# 的 IDE 支持，他们也需要编写大量的代码(当时也是用 C++ 编写的)来理解 C# 语法和语义。&lt;/p&gt;
&lt;p&gt;除此之外，还有越来越多的来自微软和其他公司的工具，如 StyleCop, CodeRush 等，所有这些工具都必须从简单的 C#源码文本开始实现有意义的基于代码的工具。所有这些都有微妙和不同的 Bug，不同的理解层次，不同的妥协和权衡。所有的一切都将花费大量的精力来重新开始：理解代码。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;到这，最后是我们的价值主张：只需世界上有一个理解 C# 的代码库，每个想在代码之上构建工具的人都可以共享它！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;到这，最后是我们的价值主张：只需世界上有一个理解 C# 的代码库，每个想在代码之上构建工具的人都可以共享它！客户的价值将来自于可用工具的增加，特别是现有工具的质量。我们将把所有的语言正确性和性能需求都放在一个代码库上，并花费一次精力使其具有一流的质量和广泛的通用性。我们将建立一个语言引擎！C# 代码的统一公共 API：我们将重新定义“编译器”的含义。&lt;/p&gt;
&lt;p&gt;当然，一旦你为庞大的 C# 社区构建了一个 API，那么它应该是一个用 C# 中实现的 .NET API，这是一种 slam-dunk（译注：指有大回报的行为）。因此，用 C# 中实现“启动”C#的旧梦想几乎只是一个偶然的附带好处。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Roslyn 诞生于一种开放的思想：共享 C# 的内部工作机制，让世界以编程的方式消费。这本身就是一个大胆的步骤，在这个仍然普遍封闭的文化中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;R&lt;/strong&gt;&lt;/span&gt;oslyn 诞生于一种开放的思想：共享 C# 的内部工作机制，让世界以编程的方式消费。这本身就是一个大胆的步骤，在微软这个仍然普遍封闭的文化中：我们会免费分享这些知识产权吗？我们会授权那些不所于我们的工具制造商更好地与我们竞争？&lt;/p&gt;
&lt;p&gt;关于加强生态系统和成为地球上最好的工具语言的辩论使我们赢得了今天成就。它们关注的是 C# 和 .NET 的长期增长，而不是微软的短期盈利和资产保护。因此，即使没有提到开源，注册 Roslyn 项目的成本和风险对微软来说也是一个巨大而大胆的步骤。&lt;/p&gt;
&lt;p&gt;当然，你不能只做这样的东西。Roslyn 的设想雄心勃勃，也充满了技术挑战，我们花了五年时间才实现，但这是后面的故事。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;自从 2009 年正式开始这个项目以来，我们就有了让编译器开源的想法，但是微软还没有准备好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在&lt;/strong&gt;&lt;/span&gt;我们构建初始版本的大部分时间里，Roslyn 仍然是一个闭源项目。自从 2009 年正式开始这个项目以来，我们就有了让编译器开源的想法，但是微软还没有准备好。在你的原始代码周围进行私有开发和申请专利的文化代表了微软自 20 世纪 70 年代以来的工作方式——尽管变化正在发生，但它发生的速度比我们团队希望的要慢。&lt;/p&gt;
&lt;p&gt;事实上，有一段时间，公司似乎在朝着完全相反的方向发展。&lt;/p&gt;
&lt;p&gt;Windows 8 项目基本上占据了整个公司。凭借其新的编程模型，它的触角深入到开发工具和语言团队，所有事情都笼罩在极度机密之中，不仅是对外部，甚至也对公司内部亦是如此。例如，我们当时正在开发的 async 特性与 Windows 8 编程模型是协调的，我甚至不敢在内部发布它的设计说明，因为我害怕不小心泄露了 Windows 8 的信息，这会给我带来麻烦！这为创新创造了一种可怕的氛围，这显然对我们开源 C# 编译器的希望来说并不是一个好兆头。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;最&lt;/strong&gt;&lt;/span&gt;终，在 Windows 8 运行完毕后，微软开始转型，找到了新的方向，朝着新的领导班子和非常不同的核心理念前进：我们今天所知道的微软。开源运动现在迅速在微软内部生根发芽。&lt;/p&gt;
&lt;p&gt;F# 已于 2010 年发布，拥有开源许可和自己的基金会——&lt;a href=&quot;https://fsharp.org/&quot;&gt;F# 软件基金会&lt;/a&gt;。在它周围成长起来的充满活力的社区很快成为我们大家羡慕的对象。我们的团队大力推动为 Roslyn 提供开源生产许可证，以至最终在公司范围内的基础设施得以实现。&lt;/p&gt;
&lt;p&gt;到 2012 年，微软创建了 Microsoft Open Tech：专门关注开源项目的组织。Roslyn 在微软开放技术公司的领导下，正式成为开源软件。开源是它的一个强有力的候选：开发资源都是内部的和众所周知的，并且项目本身独立存在，没有多少可能产生许可冲突的依赖关系。&lt;/p&gt;
&lt;p&gt;2014 年 4 月，在旧金山举行的微软开发者构建大会上，Anders Hejlsberg 展示了 Roslyn 是一个开源项目，而 Roslyn 是在 Apache 2.0 许可下通过 CodePlex（已经退役的微软开源托管平台）发布的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/TDCL0sl.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与此同时，.NET 基金会被宣布为 .NET 项目的大本营，包括 Roslyn。&lt;/p&gt;
&lt;p&gt;开源是一股清新的空气！尽管我们已经开始从 CodePlex 上获得开源的好处，但微软仍然存在一些程序上的开放源码障碍。今天，开放源码是我们在团队中工作的一个直接而完整的部分。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我们不再把 GitHub 当作一个出版场所——它只是我们工作的地方。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外在其他方面，公司确实意识到我们不需要控制一切。很明显，CodePlex 出现在世界上并没有什么好的理由，Roslyn 加入了其他的项目，从 CodePlex 迁移到 GitHub，那时它实际上就是开源项目的大本营。不仅源代码，而且构建它的过程也都在 GitHub 上：我们不把它当作发布场所——它只是我们工作的地方。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/1WB4INh.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;C&lt;/strong&gt;&lt;/span&gt;# 语言设计和编译器实现过程现在是完全开放，有很多非微软的人参与，包括外部贡献者构建的整个语言特性。C# 的价值与日具增，不仅体现在功能和 Bug 修复的贡献，更体现在我们通过开放源码提供的即时、每日循环反馈所获得的洞察和过程的改进。&lt;/p&gt;
&lt;p&gt;这是一个漫长而疯狂的旅程，对我来说，这是微软在过去十年经历的巨大变化的象征。Roslyn 的“金块”是在黑暗中诞生的，它是在开放思想的基础上发展起来的，如今通过开放源码的力量，它已经有了上百万种不同的用途。&lt;/p&gt;
&lt;p&gt;你想亲自探索 Roslyn，或致力于 C# 语言设计吗？请访问：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/roslyn&quot;&gt;https://github.com/dotnet/roslyn&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/dotnet/csharplang&quot;&gt;https://github.com/dotnet/csharplang&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 09 Oct 2018 17:34:00 +0000</pubDate>
<dc:creator>Liam Wang</dc:creator>
<og:description>译者：王亮作者：Mads Torgersen (C# Language PM at Microsoft)原文：http://t.cn/EPOG96O Roslyn 是 C# 和 Visual Basi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/willick/p/csharp-roslyn-open-source.html</dc:identifier>
</item>
<item>
<title>1.2为多变量数据绘制散点阵图 - 渔单渠</title>
<link>http://www.cnblogs.com/yudanqu/p/9762896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yudanqu/p/9762896.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　在这篇博客中，用一个小栗子来介绍一下散点图在多变量数据中的一方面应用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;scikit库中提供了一些数据，这里使用iris数据集，是一种鸢尾属植物，所给数据中包括两种类型的花，目的是根据所给信息判断两种花分别属于哪一类。也就是说找到区分这两种花的方法。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　加载库&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.datasets &lt;span&gt;import&lt;/span&gt;&lt;span&gt; load_iris
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; itertools&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;　　导入数据&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; data =&lt;span&gt; load_iris()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; x = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; y = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; col_names = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;feature_names&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　首先看一下这个数据集中都有什么，放一张过程中的截图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1279674/201810/1279674-20181009210826798-793909986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;













&lt;p&gt;　　&lt;span&gt;从上面以及具体内容（数据较多，可以自行查看）可以看到，x中是150x4的二维数组，对应着花萼的长度宽度和花瓣的长度宽度。y中是存储着已知的每组数据对应的花的种类，有0、1两种情况。feature_names中存了每个属性的名称。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　先给出主要的程序，然后慢慢解释其中用到的知识点。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 绘出6个图形，包括了以下几个列：花萼长度、花萼宽度、花瓣长度和花瓣宽度&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; plt.close(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;all&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关掉其他的图像&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; plt.figure(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 绘制一个3行2列的图&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; subplot_start = 321
&lt;span&gt; 7&lt;/span&gt; col_numbers = range(0, 4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为图形添加标签&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; col_pairs = itertools.combinations(col_numbers, 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; plt.subplots_adjust(wspace = 0.5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; col_pair &lt;span&gt;in&lt;/span&gt;&lt;span&gt; col_pairs:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    plt.subplot(subplot_start)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     plt.scatter(x[:,col_pair[0]], x[:,col_pair[1]], c=&lt;span&gt;y)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    plt.xlabel(col_names[col_pair[0]])
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     plt.ylabel(col_names[col_pair[1&lt;span&gt;]])
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     subplot_start += 1
&lt;span&gt;18&lt;/span&gt;     plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;#7：col_numbers = range(0, 4) 上面看到数据中包括四个属性来判断该花属于哪个类型，在程序当中也就是二维数组中列的0~3。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;#9：col_pairs = itertools.combinations(col_numbers, 2)  itertools.combination可以将里面的内容组合在一起。这里由于二维更便于展示，两两组合起来绘图，观察哪些属性可以更清晰的区分出两种花来。返回一个迭代器。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;#12：循环从生成的所有两两组合中取出来，绘图。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;#14：plt.scatter(x[:,col_pair[0]], x[:,col_pair[1]], c=y)  绘制散点图，横纵轴为组合在一起的两个属性，[:,col_pair[0]]的意思就是组合中第一个属性的150个数据。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;#17: subplot_start += 1  使图像依次画在一个图形中。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
<pubDate>Tue, 09 Oct 2018 16:30:00 +0000</pubDate>
<dc:creator>渔单渠</dc:creator>
<og:description>在这篇博客中，用一个小栗子来介绍一下散点图在多变量数据中的一方面应用。 scikit库中提供了一些数据，这里使用iris数据集，是一种鸢尾属植物，所给数据中包括两种类型的花，目的是根据所给信息判断两种</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yudanqu/p/9762896.html</dc:identifier>
</item>
<item>
<title>美化你的博客 | 来看这篇指导教程 - JaJian</title>
<link>http://www.cnblogs.com/jajian/p/9763946.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jajian/p/9763946.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009220354427-426246674.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好的博客主题不仅美观大方，而且能促进主人书写的愿望，博主也是个喜欢折腾的人，前前后后对自己现在的博客整容过很多次，动过很多次刀，很多人看我博客都说“博主，你的主题666”。其实我很抱歉啊，因为这主题并不是我原创的。我当时也是逛博客园突然发现了该款主题，然后自己就套用了下，研究了下js，最后再进行重新编辑定制了些功能，添加了一些博主自己喜欢的内容，如代码高亮等等。&lt;/p&gt;
&lt;p&gt;博主是名Java开发工程师，也工作了5年左右了，刚刚开始工作的时候，那时候还不是很流行现在的微服务以及前后端分离的项目架构。博主记得第一年面试的时候还被面试官问到Jquery的选择器，Ajax，以及CSS的盒子模型等相关的前端技术。而且第一份工作也是前后端都写，因为java的jsp技术也有写页面的能力，所以公司里面没有前端，只有一个美工(不知道美工属不属于前端，因为之前有人和我争论过，说美工不属于前端)，美工给我们制作下静态页面就可以了，我们再填充静态页面。&lt;br/&gt;说了这么多，其实，我只是想解释下我的JS和CSS只是菜鸟级别的，我只是博客主题的搬运工，我的这篇随笔不是想教各位大神如何定制主题，而是给大家推荐一些好的现存的Code和案例。&lt;/p&gt;

&lt;p&gt;虽然CSDN-自称全球最大的中文IT社区，而且也确实做的比博客园大，因为CSDN的商业化做的更好，但也是因为这样，CSND的博客页面广告覆盖率特别大，不说我们平时写技术的人看着难受，每次阅读起来也很难受，而且主题样式我个人认为及其丑陋。博客园也有广告，但是我们可以定制代码，书写自己的主题。前端技术能力强的Coder完全可以做到博客主题大变身，看起来像是个人博客一样，一点博客园的影子都没有。广告之类的我们也可以自己通过样式代码去掉，可以使得博客界面简介大方，虽然这样可能不好，但是博客园也没有强制拒绝你这样做。&lt;/p&gt;
&lt;p&gt;如何定制？我们可以通过【设置】中定制自己的CSS代码，当然是先要申请，并通过审核的。&lt;br/&gt;我们原始的主题一般都选择的是SimpleMemory主题，因为这款主题纯白简洁。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009222257226-1976855147.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后勾选上【禁用模板默认CSS】，填上自己整理的CSS代码，如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009220430318-1348917024.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来就是【博客侧边栏公告】，这里面可以定制自己的主页面HTML和一些JS功能，如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009220440955-1154218760.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页首Html代码，支持js，可以添加赞赏，返回文章顶部等功能。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009220452445-1808631461.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页脚Html代码，支持js，可添加音乐播放器等功能。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009220501280-1930168131.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以参考：&lt;a href=&quot;https://www.cnblogs.com/study-everyday/p/6688974.html&quot;&gt;明志健致远&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;程序员写博客，我推荐用Markdown，因为用Markdown写文章就像写代码的感觉一样。博客园大概是2014年将markdown语法引进来的。参考：&lt;a href=&quot;https://www.cnblogs.com/cmt/p/markdown.html&quot;&gt;新功能发布！Markdown写博客！&lt;/a&gt;。Markdown的语法，不同的平台大致一样。博客园稍微有点区别，例如图片的应用，其他编辑器通过@会将描述显示在图片下方，而博客园不支持。博客园的Markdown语法详情可以参考&lt;a href=&quot;https://www.cnblogs.com/zichi/p/4788229.html&quot;&gt;markdown在博客园的使用&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;编辑器的话就不要用博客园自己的了，你写的时候会急死，不多说你亲身体会下就知道了。可以先在其他编辑器上写好，再Copy过去就可以了。前提是你先要设置它的默认编辑器为Markdown，可在【设置】-【选项】中修改，如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009220513104-352537436.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里推荐几款Markdown编辑器，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;马克飞象&lt;/strong&gt;&lt;br/&gt;印象笔记的产品，本人目前在用，有网页版和客户端版，可免费可付费，影响的只是是否你需要同步到云上印象笔记，我喜欢它的原因是因为它的高亮代码是在太漂亮了，而且可以免费导出到本地，类型可以是Markdown，HTML，PDF等格式，关键是并保留高亮的样式。截个图你体验下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009220523787-918473243.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;唯一的缺点是我公司禁用这些笔记类工具。大公司都有这样的安全规定。想哭。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Sublime Text3&lt;/strong&gt;&lt;br/&gt;Sublime Text3不多说了，程序员最熟悉的小伙伴了，轻量、简洁、高效、跨平台的编辑器，只不过用它写markdown之前需要一翻折腾，具体怎么折腾法我就不详细说了，网上的教程很多，也很详细。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cmd Markdown&lt;/strong&gt;&lt;br/&gt;我为什么推荐它？因为它是我们公司的漏网之鱼，嘘，请不要声张，哈哈。博主在公司项目不忙的时候就偷偷的在上面写写文章，联网自动同步，也是可免费可收费的，但是免费的不支持图片。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然还有其他很多各种各样的编辑器，如有道笔记等等，在这里就不一一介绍了，根据个人的使用习惯和爱好选择吧。&lt;/p&gt;

&lt;p&gt;这里推荐两款高亮的CSS，当然这是针对Markdown类文章的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一款Css代码&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.cnblogs-markdown pre {
    white-space: pre!important
}

.cnblogs-markdown .hljs {
    display: block!important;
    overflow-x: auto!important;
    padding: 1em!important;
    background: #282c34!important;
    border: 1px solid #fff!important;
    border-radius: 5px!important;
    font-family: Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace!important;
    font-size: 15px!important
}

.hljs,.hljs-subst,.hljs-tag {
    color: #f8f8f2!important
}

.hljs-emphasis,.hljs-strong {
    color: #a8a8a2!important
}

.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote {
    color: #ae81ff!important
}

.hljs-meta,.hljs-regexp {
    color: #fd971f!important
}

.hljs-built_in,.hljs-builtin-name,.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title {
    color: #a6e22e!important
}

.hljs-strong {
    font-weight: 700
}

.hljs-emphasis {
    font-style: italic!important
}

.hljs-attr,.hljs-name,.hljs-selector-tag,.hljs-symbol {
    color: #f74449!important
}

.hljs-attribute,.hljs-keyword {
    color: #66d9ef!important
}

.hljs-class .hljs-title,.hljs-params {
    color: #f8f8f2!important
}

.hljs-addition,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable {
    color: #e6db74!important
}

.hljs-comment,.hljs-deletion {
    color: #999!important
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：就是博主现在在用的&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009220539647-1867673080.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二款Css代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;pre {
    white-space: pre;
    word-wrap: normal
}

.cnblogs-markdown .hljs {
    display: block;
    overflow-x: auto;
    padding: .5em;
    background: #23241f!important;
    color: #FFF;
    white-space: pre;
    word-break: normal
}

.hljs,.hljs-subst,.hljs-tag {
    color: #f8f8f2
}

.hljs-emphasis,.hljs-strong {
    color: #a8a8a2
}

.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp {
    color: #ae81ff
}

.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title {
    color: #a6e22e
}

.hljs-strong {
    font-weight: 700
}

.hljs-emphasis {
    font-style: italic
}

.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag {
    color: #f92672
}

.hljs-attribute,.hljs-symbol {
    color: #66d9ef
}

.hljs-class .hljs-title,.hljs-params {
    color: #f8f8f2
}

.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable {
    color: #e6db74
}

.hljs-comment,.hljs-deletion,.hljs-meta {
    color: #75715e
}

.cnblogs-markdown code,.cnblogs-post-body code {
    display: inline-block;
    padding: 2px 4px;
    font-size: 90%!important;
    color: #c7254e;
    background-color: #f9f2f4!important;
    border-radius: 4px;
    border: none!important
}

.cnblogs-markdown .hljs,.cnblogs-post-body .hljs {
    font-family: &quot;Courier New&quot;,sans-serif!important;
    font-size: 13px!important;
    line-height: 1.5!important;
    padding: 5px!important
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009220551296-1912996495.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;随笔如果书写的内容很多，这时候有个文章目录的话，是很方便读者阅读的，而且也能快速了解文章的总体内容。我看到过很多种类型的目录，有的是直接内嵌在文章里面的，这种肯定不好，因为太占空间了，如果标题过多，那么读者开始文章简介还没看到，先阅读了一串又臭又长的目录，瞬间心情就不好了。最好的目录还是悬浮在页面上的，能隐藏能展开。&lt;/p&gt;
&lt;p&gt;这里推荐一款，&lt;a href=&quot;http://www.cnblogs.com/asxinyu/p/Bolg_Category_AddArticleCategory_6.html&quot;&gt;悬浮目录&lt;/a&gt;，大家平时逛百度百科的时候，不知道你们有没有注意到它的目录，和这款很类似。随笔起始的时候默认隐藏，当向下阅读到一定长度之后，目录自动显示出来，也可以点击图标按钮进行收缩，很智能人性化。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009220604012-1935296251.png&quot;/&gt;&lt;/p&gt;


&lt;p&gt;暂时先添加这么多，后期博主看到了更多的有趣的再在此基础上添加。如果喜欢请&lt;strong&gt;推荐支持&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Tue, 09 Oct 2018 16:06:00 +0000</pubDate>
<dc:creator>JaJian</dc:creator>
<og:description>前言 好的博客主题不仅美观大方，而且能促进主人书写的愿望，博主也是个喜欢折腾的人，前前后后对自己现在的博客整容过很多次，动过很多次刀，很多人看我博客都说“博主，你的主题666”。其实我很抱歉啊，因为这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jajian/p/9763946.html</dc:identifier>
</item>
<item>
<title>初识gauge自动化测试框架 - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/9763938.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/9763938.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000016629187&quot;&gt;segmentfault阅读&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方网站：&lt;a href=&quot;https://docs.gauge.org/latest/index.html&quot; class=&quot;uri&quot;&gt;https://docs.gauge.org/latest/index.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;介绍&quot;&gt;介绍：&lt;/h3&gt;
&lt;p&gt;Gauge是一个轻量级的跨平台测试自动化工具，可以使用不同的语言中编写测试用例的能力。Gauge本质上是一个BDD（行为驱动开发）测试框架。如果你了解BDD那么将会比较容易的了解了Gauge工具的使用。&lt;/p&gt;
&lt;p&gt;相比较一般的BDD框架，Gauge有如下特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;兼容多系统：window/macOS/Linux，它基于Go语言开发。&lt;/li&gt;
&lt;li&gt;支持多种编程语言：Java、Python、JavaScript、Ruby等。&lt;/li&gt;
&lt;li&gt;IDE支持：Visual Studio Code和IntelliJ 都可以找到相应的插件。&lt;/li&gt;
&lt;li&gt;Markdown语法：这一点与一般的BDD框架不同，Gauge通过Markdown来描述行为。&lt;/li&gt;
&lt;li&gt;多种数据支持：看官方文档支持CSV数据文件的读取。&lt;/li&gt;
&lt;li&gt;支持测试报告：可以生成HTML、XML、JSON格式的报告。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;安装&quot;&gt;安装：&lt;/h3&gt;
&lt;p&gt;github地址：&lt;a href=&quot;https://github.com/getgauge/gauge/releases&quot; class=&quot;uri&quot;&gt;https://github.com/getgauge/gauge/releases&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里告诉你们一个通用的安装方式。根据自己的操作系统选择对应的下载版本。这里以Windows为例，下载 &lt;strong&gt;gauge-1.0.2-windows.x86_64.zip&lt;/strong&gt; 文件，解压得到 &lt;strong&gt;gauge.exe&lt;/strong&gt; 文件，将该文件放到环境变量Path设置的目录下面即可。&lt;/p&gt;
&lt;p&gt;打开Windows命令提示符，输入&lt;code&gt;gauge help&lt;/code&gt;回车。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201810/311516-20181010000105078-1424861927.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果看到上面的信息说明安装成功。&lt;/p&gt;

&lt;h3 id=&quot;创建项目&quot;&gt;创建项目：&lt;/h3&gt;
&lt;p&gt;首先，你需要安装编程语言开发环境，Java或Python，本文将以Python为例子。&lt;br/&gt;1、创建一个空的目录，如：gauge_demo/。&lt;/p&gt;
&lt;p&gt;2、CMD切换到该目录下面，输入&lt;code&gt;gauge init python&lt;/code&gt;命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201810/311516-20181010000119476-1501176460.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，你会发现gauge_demo/目录下面多了很多文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201810/311516-20181010000131498-213341414.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、通过VS code 打开该目录。最好先去安装一个gauge插件。&lt;br/&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=getgauge.gauge&quot; class=&quot;uri&quot;&gt;https://marketplace.visualstudio.com/items?itemName=getgauge.gauge&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201810/311516-20181010000146995-1227775055.png&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;运行测试&quot;&gt;运行测试：&lt;/h3&gt;
&lt;p&gt;gauge生成的项目里已经有一些样例代码了，所以我们可以直接运行这些样例代码。在gauge_demo/目录下执行&lt;code&gt;gauge run specs&lt;/code&gt;命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201810/311516-20181010000159464-1307781446.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，到\gauge_demo\reports\html-report\目录下打开index.html文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201810/311516-20181010000209336-1629298336.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个看脸的年代，你测试报告不好看，我们都不愿意学的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文只是让你对Gauge测试框架有一个大体的认识，如果你感兴趣就好好的读一读，specs/和step_impl/目录下的文件，找一找它们的对应关系。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 09 Oct 2018 16:04:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<og:description>Gauge是一个轻量级的跨平台测试自动化工具，可以使用不同的语言中编写测试用例。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fnng/p/9763938.html</dc:identifier>
</item>
<item>
<title>OAuth2.0 原理简介 - .NET西安社区</title>
<link>http://www.cnblogs.com/xiandnc/p/9763121.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiandnc/p/9763121.html</guid>
<description>&lt;h2&gt;写在前面：&lt;/h2&gt;
&lt;p&gt;    在正式介绍OAuth2.0之前我们先来看一个场景：&lt;strong&gt;小李&lt;/strong&gt;是一个文艺小青年， 经常喜欢出去旅游并且把自己旅行中的美景照片分享到各大社交网站上，比如朋友圈，&lt;strong&gt;新浪微博&lt;/strong&gt;。小李马上要向女朋友求婚了，他想把这三年来和自己女朋友出去旅游的照片打印出来做成照片墙，好在求婚的时候讲女友感动的一塌糊涂，然后你懂得...，那么问题来了，按照小李带女朋友一个月出去玩一次，每次分享30张照片，三年就是30 * 12 * 3 = 1080 张，小李现在想把这1080张照片全部打印出来他首先得找个提供打印照片服务的公司（&lt;strong&gt;美图快印&lt;/strong&gt;），然后把需要打印的照片给到服务公司然后才能打印。怎么把这些照片给到美图快印呢，一般来说有下面两种方式：&lt;/p&gt;
&lt;p&gt;1.小李到自己的微博相册中吭哧吭哧下载他需要打印的所有照片，然后装到U盘里或者转储到网盘里，再给到美图快印（那可是1080张照片啊，纯手工操作，好累啊）&lt;/p&gt;
&lt;p&gt;2.小李到美图快印告诉工作人员自己的账户名和密码，并告诉他那些需要打印，那些不需要打印，然后小李还会担心：自己和女友的亲密照被工作人员看到了怎么办（更可怕的是某一天自己会不会出现在某论坛上成为网红）？万一他记住了我的密码然后悄悄的登陆上去把我的密码改了怎么办？。。。。&lt;/p&gt;
&lt;p&gt;小李觉得有点头疼了，有没有什么方法客户既不告诉工作人员自己的账号和密码又能够方便快捷的把照片给到美图快印呢？&lt;/p&gt;
&lt;p&gt;这就要说到我们今天的正题了，用OAuth就可以轻松的解决此类特定范围的授权问题。&lt;/p&gt;
&lt;h2&gt;OAuth2.0简介：　　&lt;/h2&gt;
&lt;p&gt;    &lt;strong&gt;OAuth2.0 是一个开放的工业标准的授权协议，它允许用户授权让第三方应用直接访问用户在某一个服务中的特定资源，但是不提供给第三方账号及密码信息。完整定义请移步官网：&lt;a href=&quot;https://oauth.net/2/&quot; target=&quot;_blank&quot;&gt;https://oauth.net/2/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;OAuth2.0的基本概念&lt;/h2&gt;
&lt;p&gt;    在了解OAuth2.0之前我们有必要先介绍一下下面几个基本的概念：&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot; data-v-4c8ee738=&quot;&quot;&gt;&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-0&quot;&gt;1. 资源所有者（Resource Owner）：一个能够访问受保护资源的实体。&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-1&quot;&gt;当资源所有者是一个人时，它被称为终端用户。（小李）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot; data-v-4c8ee738=&quot;&quot;&gt;&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;1-0&quot;&gt;2. 资源服务器（Resource Server）：托管受保护资源的服务器，能够使用访问令牌接受和响应受保护的资源请求。（新浪微博）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot; data-v-4c8ee738=&quot;&quot;&gt;&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;2-0&quot;&gt;3. 客户端（Client）：代表资源所有者和其授权的应用程序来保护资源请求。&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;2-1&quot;&gt;术语客户端并不意味着任何特定的实现特征（例如，应用程序是否在服务器、桌面或其他设备上执行）（美图快印）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot; data-v-4c8ee738=&quot;&quot;&gt;&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;3-0&quot;&gt;4. 授权服务器（Authorization Server）：在成功验证资源所有者并获得授权之后，服务器向客户端发出访问令牌。（授权服务器是用来管理Resource Owner，Resource Server，Client的中间人）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Authorization Server和Resource Server可以使独立的服务提供商，也可以是在一起的，比如上面例子中新浪微博既作授权服务器也用来存储用户的图片资源，OAuth2解决的问题是：通过Authorization Server可以提供一个访问的凭据（token）给client（美图快印的工作人员），使得client可以在不知道Resource Owner以及Resource Server的用户名和密码的情况下访问到Resource Owner受保护的资源，它是一个完美的中间人。　　&lt;/p&gt;
&lt;h2&gt; OAuth2.0详解&lt;/h2&gt;
&lt;p&gt;通常 Resource server本身就提供Authorization server服务，它主要提供两类接口：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;授权服务接口：接受Client的授权请求，并引导用户到Resource server完成登陆授权的过程。&lt;/li&gt;
&lt;li&gt;获取访问令牌的接口：使用授权接口提供的许可凭据来颁发Resource owner的访问令牌给Client，或由Client更新过期的访问令牌。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;除此之外还需要提供一个第三方应用程序注册管理的服务。通常情况下会为注册完成的第三方应用程序分配两个成对出现的重要参数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;client_id：第三方应用程序的一个标识id，这个信息通常是公开的信息，用来区分哪一个第三方应用程序。&lt;/li&gt;
&lt;li&gt;client_secret：第三方应用程序的私钥信息，这个信息是私密的信息，不允许在OAuth2流程中传递的，用于安全方面的检测和加密。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Client在取得client_id和client_secret之后再向Authorization Server发起授权请求，并获取AccessToken，然后携带Token来访问和消费受保护的资源。美图快印要想直接获取小李新浪微博相册中的照片资源就需要先引导小李到新浪的登陆界面，然后完成授权登陆，然后再向授权服务器发起授权请求，然后获取到新浪微博办法给他的token，再携带者token才能访问到微博的相册。&lt;/p&gt;
&lt;p&gt;下面我们来看一下OAuth2.0的详细授权过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413706/201810/1413706-20181009223131701-1576956298.jpg&quot; alt=&quot;&quot; width=&quot;892&quot; height=&quot;678&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到在上述的授权过程中最关键的部分是获取token的那一步，这也是OAuth2.0的核心。有了这个token我们就可以访问到resource server上的资源，ABCD这几步都是为了获取这个token。&lt;/p&gt;
&lt;p&gt;那么这个token到底包含了哪些信息呢？我们来从头分析一下，我们需要实现的是：让美图快印能够在&lt;strong&gt;不用小李用户名和密码&lt;/strong&gt;的前提下&lt;strong&gt;访问到&lt;/strong&gt;小李&lt;strong&gt;新浪微博账户&lt;/strong&gt;相册中的&lt;strong&gt;特定图片。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意上面加粗的部分，要实现这样的需求我们需要从token中解析出来下面3类信息：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端标识，表明是谁在请求访问资源（美图快印）；&lt;/li&gt;
&lt;li&gt;用户标识，得到了谁的许可（小李）；&lt;/li&gt;
&lt;li&gt;客户端能访问资源所有者的哪些资源以及其相应的权限。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;有了上面的这些信息，那么资源服务器（Resouce Server）就可以区分出来是哪个第三方应用（Client）要访问哪个用户（Resource Owner）的哪些资源（以及有没有权限）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在上面的流程中出现了授权许可（Authorization Grant）这个概念，那到底它是什么意思呢？&lt;/p&gt;
&lt;p&gt;书面解释是：&lt;strong&gt;&lt;span&gt;授权许可是一个代表资源所有者授权（访问受保护资源）的凭据，客户端用它来获取访问令牌。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这个解释比较抽象，那么我们来翻译一下就是：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;授权许可是小李授予美图快印获得新浪微博相册的访问令牌的一个凭据。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么我们该如何获得这个凭据呐，OAuth2定义了四种许可类型：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Authorization Code：授权码；&lt;/li&gt;
&lt;li&gt;Implicit：隐式许可；&lt;/li&gt;
&lt;li&gt;Resource Owner Password Credentials：资源所有者密码凭据；&lt;/li&gt;
&lt;li&gt;Client Credentials ：客户端凭据。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体每一种许可类型到底怎么实现我们将放到后面详细讨论，本文不做详细解释。&lt;/p&gt;
&lt;h2&gt;写到最后：&lt;/h2&gt;
&lt;p&gt;   总结：OAuth2.0是一套工业级的标准授权协议，可以很方便的解决第三方服务的授权而不需要资源所有者直接提供身份信息，它大大降低了我们在实现认证和授权时的复杂度。目前基于OAuth2.0实现的框架有很多，基于.NET Core实现最好的是&lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4&quot; target=&quot;_blank&quot;&gt;IdentityServer4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 在后续文章中我们将一起探讨IdentityServer4在.NET Core中的使用，欢迎持续关注。&lt;/p&gt;
&lt;p&gt; 如果你觉得本文写得不错，麻烦给个赞呗~~~&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://oauth.net/2/&quot; target=&quot;_blank&quot;&gt;https://oauth.net/2/&lt;/a&gt;     &lt;/p&gt;

</description>
<pubDate>Tue, 09 Oct 2018 14:57:00 +0000</pubDate>
<dc:creator>.NET西安社区</dc:creator>
<og:description>写在前面： 在正式介绍OAuth2.0之前我们先来看一个场景：小李是一个文艺小青年， 经常喜欢出去旅游并且把自己旅行中的美景照片分享到各大社交网站上，比如朋友圈，新浪微博。小李马上要向女朋友求婚了，他</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiandnc/p/9763121.html</dc:identifier>
</item>
<item>
<title>好代码是管出来的——使用Jenkins搭建CI服务器 - 7m鱼</title>
<link>http://www.cnblogs.com/selimsong/p/9763268.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/selimsong/p/9763268.html</guid>
<description>&lt;p&gt;　　Jenkins是一个开源的跨平台的CI工具，它可以部署在Windows、Linux等平台上，并且Jenkins提供了非常丰富的插件来帮助完成编译、测试、部署等工作。&lt;br/&gt;　　本文将介绍在Windows平台上使用Jenkins完成.Net Core应用的持续集成环境搭建，其主要内容有：&lt;/p&gt;
&lt;h2&gt;Jenkins下载与安装&lt;/h2&gt;
&lt;p&gt;　　本例使用Jenkins2.136版本进行演示，Jenkins下载地址：&lt;a href=&quot;https://jenkins.io/download/&quot; target=&quot;_blank&quot;&gt;https://jenkins.io/download/&lt;/a&gt;&lt;br/&gt;　　1. 下载Jenkins的Windows安装器：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009215544136-2120701412.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. 通过安装向导完成Jenkins安装：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009215722595-602119540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Jenkins的默认端口是8080，当安装完成后可以通过该端口访问Jenkins：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009220211608-711650717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3. 根据Jenkins的配置向导完成相应配置，并进入Jenkins：&lt;br/&gt;　　选择常用插件，这些插件包含了Git、SVN等常用插件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009220245728-436976589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　创建用户：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009220306667-2080493106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　进入Jenkins：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009220338136-344151466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;创建一个.Net Core编译任务&lt;/h2&gt;
&lt;p&gt;　　1. 创建一个新任务：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009221329201-803423783.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　填写任务名称选择自由风格项目：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009221748600-1736194713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　2. 修改任务配置：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009221820284-416113606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　代码库：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009221840984-763958874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3. 添加构建步骤，此处执行dotnet的编译命令：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009221900368-619428940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4. 执行任务，结果输出如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222209777-238784099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;实现自动测试&lt;/h2&gt;
&lt;p&gt;　　1. 添加测试运行步骤：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222239475-2107855291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　dotnet测试命令参考：&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-test?tabs=netcore21&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-test?tabs=netcore21&lt;/a&gt;&lt;br/&gt;　　运行结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222317608-1843089798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. 收集代码覆盖率：&lt;br/&gt;　　之前介绍了使用OpenCover来分析.net core的单元测试代码覆盖率，然后再通过ReportGenerator来生成Html格式的报告，所以首先需要添加代码覆盖率分析以及报告生成的构建步骤：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222610287-1450365014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　OpenCover.Console.exe -target:&quot;dotnet.exe&quot; -targetargs:&quot;test XUnitTestProject/XUnitTestProject.csproj&quot; -output:coverage.xml -filter:&quot;+[*]* -[*Moq]* -[xunit*]*&quot; -oldstyle&lt;br/&gt;　　ReportGenerator.exe &quot;-reports:coverage.xml&quot; &quot;-targetdir:report&quot;&lt;br/&gt;　　&lt;span&gt;注：在持续集成工具中使用OpenCover可能会无法生成代码覆盖信息，所以需要对OpenCover.Profiler.dll文件进行注册，注册代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222647391-812667253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　OpenCover.Profiler.dll文件位于OpenCover的安装目录下，更多详情查考OpenCover安装目录下的Usage.rtf文档。&lt;/p&gt;
&lt;p&gt;　　如果要将生成的Html在Jenkins上显示，那么必须添加一个HTML Publisher的插件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222718871-478016919.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后在构建后操作中添加HTML发布操作：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222735867-1348736940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　需要填写HTML的目录和报告起始页面。&lt;br/&gt;　　完成后保存配置，并执行构建：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222808187-787199496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222821857-1922593200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222848948-628482637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后在工程面板中即可查看代码覆盖报告：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222934100-588097978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　报告：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222953246-1167054802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;实现自动部署&lt;/h2&gt;
&lt;p&gt;　　当完成编译工作后，需要把编译的结果发布出来，对于一个Windows的控制台应用程序来说，实际上把编辑的执行程序以及相关程序集发布出来即可，而这个程序文件实际上是在项目的bin目录下。&lt;br/&gt;在Jenkins中可以通过Artifact Deployer Plug-in这个插件来完成文件发布功能：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009223122746-1041153733.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　插件安装完成后，在项目的构建后操作中添加部署操作，将生成的文件复制到D:\test目录下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009223149461-342459249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　执行构建后将自动把构建结果发布至D:\test目录下。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009223221422-296949541.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;　　本文简单的介绍了如何使用Jenkins及相关插件完成.Net Core程序的自动编译、测试和发布功能。无论是前面文章提到的使用各种托管工具还是自己搭建Jenkins其核心步骤都是通过相应工具以执行命令的方式完成的(编译命令、测试命令、代码覆盖率命令、报表生成命令等)。&lt;/p&gt;
&lt;p&gt;　　虽然都是通过相同的工具以及相同的命令，但是不同的CI工具使用上还是存在一些区别，并且还存在大量的手动配置，有没有一种方法来简化并且重用CI/CD流程呢？敬请期待后续内容(*^_^*)&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 好代码是管出来的——使用Jenkins搭建CI服务器&quot; href=&quot;https://www.cnblogs.com/selimsong/p/9763268.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/selimsong/p/9763268.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a id=&quot;post_title_link_8675028&quot; href=&quot;https://www.cnblogs.com/selimsong/p/8675028.html&quot;&gt;好代码是管出来的——浅谈.Net Core的代码管理方法与落地（更新中...）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 09 Oct 2018 14:42:00 +0000</pubDate>
<dc:creator>7m鱼</dc:creator>
<og:description>Jenkins是一个开源的跨平台的CI工具，它可以部署在Windows、Linux等平台上，并且Jenkins提供了非常丰富的插件来帮助完成编译、测试、部署等工作。 本文将介绍在Windows平台上使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/selimsong/p/9763268.html</dc:identifier>
</item>
<item>
<title>改善javascript代码结构 - 清许</title>
<link>http://www.cnblogs.com/qingxuit/p/9763198.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qingxuit/p/9763198.html</guid>
<description>&lt;p&gt;首先看下常规开发中javascript非结构化组织代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; appInit () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序初始化操作&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; appModule1 () {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序功能模块1   &lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; appModule2 () {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序功能模块2   &lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; appModule3 () {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序功能模块3   &lt;/span&gt;
&lt;span&gt;}

$( document ).ready(appInit )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从技术角度看，这种代码方式并没有任何错误，但是通过下图可以发现这些函数都是建立在全局名称空间下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451247/201810/1451247-20181009201545513-1192641943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若在全局名称空间中创建很多变量很快会导致严重的问题、比如在全局名称空间中定义了名为i、_或$的变量。&lt;/p&gt;
&lt;p&gt;如何改善呢？&lt;/p&gt;
&lt;p&gt;1、使用一个单例创建一个应用程序名称空间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; myApp =&lt;span&gt; {
    init : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序初始化操作&lt;/span&gt;
&lt;span&gt;    },
    appModule1 : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序功能模块1&lt;/span&gt;
&lt;span&gt;    },
    appModule2 : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序功能模块2&lt;/span&gt;
&lt;span&gt;    },
    appModule3 : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序功能模块3&lt;/span&gt;
&lt;span&gt;    }
}
$( document ).ready(myApp.init)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于上面的新结构，打开chrome查看window下的属性时仅看到单个变量myApp，这中方式极大的降低了变量名冲突的可能性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451247/201810/1451247-20181009213352921-1105912729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这一模式允许多个开发人员跨越多个文件，在单个应用程序名称空间之下进行协同开发。从代码结构角度来说，可以将网站的每一部分拆成独立文件。比如本例中的common.js、&lt;/p&gt;
&lt;p&gt;&lt;span&gt;appModule1.js、&lt;span&gt;appModule2.js和&lt;/span&gt;&lt;span&gt;appModule3.js。每个开发人员都有一个自己负责的网站部分和相应的javascript文件，开发人员只需要关注自己的文件，不需要担心会发生冲突。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;common.js

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; myApp =&lt;span&gt; {
    common : {
           init : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化应用程序通用代码&lt;/span&gt;
&lt;span&gt;           }
    }
}

appModule1.js

myApp.appModule1 &lt;/span&gt;=&lt;span&gt; {
     init : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化代码&lt;/span&gt;
&lt;span&gt;     },
     update : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新模块1的代码&lt;/span&gt;
&lt;span&gt;     }，
     render : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;呈现模块1的代码&lt;/span&gt;
&lt;span&gt;     }
}

appModule2.js

myApp.appModule2 &lt;/span&gt;=&lt;span&gt; {
     init : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化代码&lt;/span&gt;
&lt;span&gt;     },
     update : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新模块2的代码&lt;/span&gt;
&lt;span&gt;     }，
     render : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;呈现模块2的代码&lt;/span&gt;
&lt;span&gt;     }
}

appModule3.js

myApp.appModule3 &lt;/span&gt;=&lt;span&gt; {
     init : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化代码&lt;/span&gt;
&lt;span&gt;     },
     update : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新模块3的代码&lt;/span&gt;
&lt;span&gt;     }，
     render : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;呈现模块3的代码&lt;/span&gt;
&lt;span&gt;     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、Module模式&lt;/p&gt;
&lt;p&gt;      模块模式是单例的一种变种，增强了单例模式提供的封装性，并增加了创建私有方法和私有属性的功能&lt;/p&gt;
&lt;p&gt;      模块模式包含三个主要组件：一个与前面例子类似的命名空间、一个立即执行函数和函数返回对象，该返回对象包含公有方法和公有属性，js代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;app的名称空间。传入jquery对象以缩短查找过程&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; myApp = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;( $ ){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有变量和方法&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; message = &quot; i am a module &quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; multiplier (x,y) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x *&lt;span&gt; y;
    };
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回对象包含公有属性和方法&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        init:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化app&lt;/span&gt;
&lt;span&gt;        },
        prop : &lt;/span&gt;'42'&lt;span&gt;,
        getProduct : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;访问私有方法&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; multiplier(2,3&lt;span&gt;);
        },
        shareMessage : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (arg){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对私有属性进行限制访问&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(arg == &quot;admin&quot;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; message;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&quot;No access&quot;&lt;span&gt;);
            }
        }
        
    }
}(jQuery)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制台中测试如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451247/201810/1451247-20181009213813979-23962878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     扩展该模式以增加更多的模块也非常简单。如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
myApp.module1 = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;($){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有变量和方法&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; config =&lt;span&gt; {
        &lt;/span&gt;&quot;color&quot;:&quot;red&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;title&quot;:&quot;module1&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;width&quot;:&quot;20px&quot;&lt;span&gt;
    };
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        init:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化module1&lt;/span&gt;
&lt;span&gt;        },
        updateConfig : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj){
            config.color &lt;/span&gt;= obj.color ||&lt;span&gt; config.color;
            config.title &lt;/span&gt;= obj.title ||&lt;span&gt; config.title;
            config.width &lt;/span&gt;= obj.width ||&lt;span&gt; config.width;
        },
        render:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; $module1 = $(&quot;#id&quot;&lt;span&gt;);
            $module1.text(config.title)
                    .css({&lt;/span&gt;&quot;width&quot;:config.width,&quot;color&quot;&lt;span&gt;:config.color})
            
        }
    }
    
}(jQuery)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该代码描述了一个module1模块，它包含一个私有配置对象和一个公共方法，该公有方法允许根据一组预定义条件获得对module1配置的访问，类似于java中private和public关键字的使用。在js开发中，并非所以时候都需要使用这种保护访问，但当我们需要实现这样功能时，使用模块模式是非常重要的。&lt;/p&gt;

</description>
<pubDate>Tue, 09 Oct 2018 13:55:00 +0000</pubDate>
<dc:creator>清许</dc:creator>
<og:description>首先看下常规开发中javascript非结构化组织代码 从技术角度看，这种代码方式并没有任何错误，但是通过下图可以发现这些函数都是建立在全局名称空间下 若在全局名称空间中创建很多变量很快会导致严重的问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qingxuit/p/9763198.html</dc:identifier>
</item>
<item>
<title>RIP及距离向量算法 - zhxxxx</title>
<link>http://www.cnblogs.com/zhanghx/p/9761882.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanghx/p/9761882.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;预备知识&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;网络层提供两种服务：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;虚电路服务&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据报服务&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;&lt;caption&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;虚电路服务与数据报服务的对比&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/caption&gt;
&lt;tbody readability=&quot;10&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;对比的方面&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;虚电路服务&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;数据报服务&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;思路&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;可靠通信由网络保证&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;可靠通信由终系统保证&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;连接的建立&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;必须有&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;不需要&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;终点地址&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;仅在连接建立阶段使用，每个分组使用短的虚电路号&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;每个分组都有终点的完整地址&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分组的转发&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;属于同一条虚电路的分组均按照同一路由进行转发&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;每个分组独立选择路由进行转发&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当结点出故障&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;所有通过出故障的结点的虚电路均不能工作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;出故障的结点可能会丢失分组，一些路由可能发生变化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分组的顺序&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;按发送顺序&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;不按发送顺序&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;端到端的差错处理和流量控制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;可由网络负责，也可由终系统负责&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;由终系统负责&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;因数据报服务在分组转发时，每个分组独立选择路由进行转发，从而引出&lt;span&gt;路由选择协议&lt;/span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;路由选择协议的核心是&lt;span&gt;路由算法&lt;/span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;理想路由算法特点：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;算法必须是&lt;span&gt;正确的和完整的&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;算法在计算上应&lt;span&gt;简单&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;算法应能适应通信量和网络拓扑结的变化，要有&lt;span&gt;自适应性&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;算法应具有&lt;span&gt;稳定性&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;算法应是&lt;span&gt;公平的&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;算法应是&lt;span&gt;最佳的&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;路由算法依据自适应性来划分为:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;静态路由选择策略（非自适应路由选择）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;动态路由选择策略（自适应路由选择）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;由于互联网的规模非常大，以及各单位的保密需求，互联网采用&lt;span&gt;分层次的路由选择协议&lt;/span&gt;。为此，将互联网分为许多较小的&lt;span&gt;自治系统（AS）&lt;/span&gt;，AS是在单一技术管理下的一组路由器。一个AS对其他AS表现出的是&lt;span&gt;一个单一的和一致的路由选择策略&lt;/span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;路由选择协议分类：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一）内部网关协议IGP&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　RIP&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　OSPF&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;自治系统内部的路由选择叫做&lt;span&gt;域内路由选择&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二）外部网关协议EGP&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　BGP-4（BGP）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;自治系统之间的路由选择叫做&lt;span&gt;域间路由选择&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;中文名：&lt;span&gt;路由信息协议&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;RIP是一种&lt;span&gt;分布式&lt;/span&gt;的&lt;span&gt;基于距离向量的路由选择协议&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;距离的定义：也称“跳数（hop count）”,&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;从一路由器到直接连接的网络的距离定义为 1。从一路由器到非直接连接的路由器的距离定义为所经过的路由器数加 1。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;RIP允许一条路径最多包含 15 个路由器，即“距离”等于 16 时不可达。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;RIP选择一条具有最少路由器的路由（最短路由），哪怕还存在另一条高速但路由器较多的路由。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;特点：每一个路由器都要不断地和其他路由器交换路由信息。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;仅和&lt;span&gt;相邻路由器&lt;/span&gt;交换信息&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;路由器交换的信息是&lt;span&gt;当前本路由器所知道的所有信息，即当前的路由表&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;按固定时间间隔&lt;/span&gt;交换路由信息&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;路由器刚开始工作时，路由表是空的，但经过若干次的更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。以上过程，叫 “&lt;span&gt;收敛&lt;/span&gt;”，收敛是在AS中所有结点都得到正确的路由选择信息的过程。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;路由表中最主要的信息：到某个网络的距离（&lt;span&gt;最短距离&lt;/span&gt;），经过的下一跳地址。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为了找出最短距离，由此引出 距离向量算法——&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;距离向量算法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;此算法的基础是&lt;span&gt;Bellman-Ford算法&lt;/span&gt;，这种算法的要点是：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　设 X 是结点 A 到 B 的最短路径上的一个结点。若把路径 A到B 拆成两段路径 A到X 和 X到B，则每段路径 A到X 和 X到B 也都分别是结点 A到X 和结点 X到B 的最短路径。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;对每一个相邻路由器发送过来的RIP报文，进行以下步骤：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）对地址为 X 的相邻路由器发来的RIP报文，先修改此报文的所有项目：把“下一跳”字段中的地址都改为 X ，并把所有的“距离”字段值加 1 　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt;假设从位于 X 的相邻路由器发来RIP报文的某一项目是：“Net2，3，Y”，意思是“我经过路由器Y到网络Net2的距离是3”，那么本路由器可推断出“我经过路由器X到网络Net2的距离是3+1=4”，于是将收到的RIP报文的这一项目修改为：“Net2，4，X”，作为下一步和路由表中原有项目进行比较时使用（比较后确定是否更新）&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;每一个项目都有三个关键数据，即：到目的的网络 N ，距离 d ，下一跳路由器 X 。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）对修改后的RIP报文中的每个项目，执行以下步骤：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;if （原来的路由表中没有目的网络N）：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　把该项目添加到路由表中　　&lt;span&gt;#&lt;/span&gt;&lt;span data-mce-=&quot;&quot;&gt;本路由表中没有到目的网络Net2的路由，那么路由表中就要加入新的项目“Net2，4，X”  &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;在路由表中有目的网络N，查看下一跳路由器地址：elif（下一跳路由器地址是 X）：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　把收到的项目替换原路由表中的项目　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt;不管原来路由表中项目时“Net2，3，X”还是“Net2，5，X”，都要更新为“Net2，4，X”&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;在路由表中有目的网络N，但下一跳路由器不是X，比较距离d与路由表中的距离：elif（收到的项目中的距离 d 小于路由表中的距离）：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　更新　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt;若路由表中已有项目“Net2，5，P”，就更新为“Net2，4，X”&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;else：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　无动作　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt;若距离更大了，显然不应更新；若距离不变，也不更新&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）若三分钟还没收到相邻路由器的更新路由表，则把此相邻路由器记为不可到达的路由器，即“距离”为 16。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4）return&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;【例】：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;已知路由器R6有表a所示的路由表。现收到相邻路由器R4发来的路由更新信息，如表b所示。试更新路由器R6的路由表。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;&lt;caption&gt;&lt;span&gt;&lt;strong&gt;表 a&lt;/strong&gt;&lt;/span&gt;&lt;/caption&gt;
&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;目的网络&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;距离&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;下一跳路由器&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net2&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;R4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net3&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;R5&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;table border=&quot;1&quot;&gt;&lt;caption&gt;&lt;span&gt;&lt;strong&gt;表 b&lt;/strong&gt;&lt;/span&gt;&lt;/caption&gt;
&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;目的网络&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;距离&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;下一跳路由器&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net1&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;R1&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net2&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;R2&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net3&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;直接交付&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;解：先将收到的RIP报文改为表c：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;&lt;caption&gt;&lt;span&gt;&lt;strong&gt;表 c&lt;/strong&gt;&lt;/span&gt;&lt;/caption&gt;
&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;目的网络&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;距离&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;下一跳路由&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net1&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;3+1=4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;R4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net2&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;4+1=5&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;R4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net3&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;1+1=2&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;R4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;将表c与表a比较：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;row1：没有Net1，添加到表a中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;row2：有Net2，且下一跳路由器相同，更新&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;row3：有Net3，但下一跳路由器是不同，比较距离得到，新的距离小于路由表中距离，更新&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;综上所述：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;更新后R6的路由表如表d 所示：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;&lt;caption&gt;&lt;span&gt;&lt;strong&gt;表 d&lt;/strong&gt;&lt;/span&gt;&lt;/caption&gt;
&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;目的网络&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;距离&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;下一跳&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net1&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;R4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net2&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;R4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net3&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;R4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;RIP协议让AS中所有路由器都和自己相邻路由器定期交换路由信息，并不断更新路由表，使得&lt;span&gt;每个路由器到每个目的网络的路由都是最短的&lt;/span&gt;（跳数最少）。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 09 Oct 2018 13:39:00 +0000</pubDate>
<dc:creator>zhxxxx</dc:creator>
<og:description>&gt;&gt;&gt;预备知识 网络层提供两种服务： 虚电路服务 数据报服务 因数据报服务在分组转发时，每个分组独立选择路由进行转发，从而引出路由选择协议。 路由选择协议的核心是路由算法。 理想路由</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanghx/p/9761882.html</dc:identifier>
</item>
<item>
<title>systemd服务详解-技术流ken - 技术流ken</title>
<link>http://www.cnblogs.com/kenken2018/p/9762823.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenken2018/p/9762823.html</guid>
<description>&lt;h2&gt;1.简介&lt;/h2&gt;
&lt;p&gt;在centos5中生成和管理用户空间中的进程以及完成系统的初始化使用的是init,并且是依次启动。在centos6中则是使用的upstart,在一定程度上实现了并行启动，但是仍然存在依赖关系，到了centos7中开始使用systemd，真正的实现并行启动、延时按需启动。&lt;/p&gt;
&lt;h2&gt;2.&lt;strong&gt;systemd&lt;span&gt;的特性&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1 &lt;span&gt;启动系统的过程中实现了并行启动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2 &lt;span&gt;由&lt;/span&gt;&lt;span&gt;systemd&lt;/span&gt;&lt;span&gt;所管理的服务可以实现按需激活&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3 &lt;span&gt;支持系统服务状态快照&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4 &lt;span&gt;可以定义程序之间依赖关系&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.unit介绍&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;unit&lt;span&gt;的配置文件是&lt;/span&gt;&lt;span&gt;uit&lt;/span&gt;&lt;span&gt;的核心，在配置文件中主要包含一下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;span&gt;需要管理服务或者程序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;服务或者程序需要监听的套接字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;保存的系统快照（就是制作快照的时候，系统中各个服务的状态）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;span&gt;其他和&lt;/span&gt;&lt;span&gt;init&lt;/span&gt;&lt;span&gt;相关的配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;unit&lt;span&gt;配置文件的位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;/lib/systemd/system         &lt;span&gt;本地配置的系统单元&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;/run/systemd/system         &lt;span&gt;运行时配置的系统单元&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;/usr/lib/systemd/system      第三方软件的系统单元(sshd,nginx..)&lt;/p&gt;
&lt;p&gt;注意：unit(&lt;span&gt;单元&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;init&lt;/span&gt;&lt;span&gt;中的服务脚本类似，但是不相同&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;4.&lt;/span&gt;&lt;strong&gt;unit&lt;span&gt;的多种类别&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;类型1：service unit，这是服务类型的unit，该类unit后缀是  .service，比如nginx.service，通过这个nuit可以实现启动、关闭、查看状态等
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     该类unit位于 /usr/lib/systemd/&lt;span&gt;system
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    注意：unit本质上来说并不是脚本，而仅仅是systemd一个配置文件，因此这个unit文件不具有执行权限，而且也无法执行
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    启动服务的方式：通过让systemd去读取配置文件中的内容，完成nginx进程的启动
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;类型2：device unit，这是设备unit，该类unit的后缀是.device，这类unit的作用是用来识别设备文件
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;类型3：mount unit，后缀 .mount，用来实现挂载文件系统到指定的挂载点
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;类型4：socket unit，后缀.socket，用来表示进程间通信的socket文件
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;类型5：snapshot nuit：快照unit，后缀.snapshot, 用来管理快照
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;类型6：target unit：目标unit，后缀是 .target，模拟centos5、6上的运行级别（主要是为了向后兼容）
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;类型7：swap unit
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 类型8：path unit
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.&lt;strong&gt;systemd&lt;span&gt;的特性&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;特性1. 基于socket的激活机制
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    在启动系统的时候，systemd会将所有要启动的服务都标记已经启动，标记的方式就是将所有要启动的服务的套接字都监听起来，但是是由systemd自己来监听，而不是让具体的服务自己来监听，这样就解决了进程之间的依赖关系。
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    当某个套接第一次被用户的访问的时候，systemd会立刻启动这个套接字所对应的进程，然后将这个套接字和这个启动的服务做绑定
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;特性2：基于bus机制激活
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;特性3：基于device机制激活
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;特性4：基于path机制激活
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    可以让systemd监控某个某个目录，当目录中的文件发生更改的时候，立刻激活某个服务
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;特性5：支持快照机制
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; 特性6：支持域兼容sysV风格的服务管理脚本
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6systemctl&lt;span&gt;使用举例&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1.&lt;/span&gt;查看激活的服务&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     查看当前系统中全部已经被激活的unit：systemctl list-units --&lt;span&gt;type service
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     查看当前系统中全部的unit(包括未激活的)：systemctl list-units --type service --all
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 2.&lt;span&gt;开机自启动关闭&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;设置某个服务开机自启动：systemctl enable nginx.service
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    禁止某个服务开机自启动：systemctl disable nginx.service
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     【设置开机自启动，其实就是在/etc/systemd/system/multi-user.target.wants/下创建执行/usr/lib/systemd/system/&lt;span&gt;下的配置文件的软连接】
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;     查看当前系统中的全部unit的自动启动情况：systemctl list-unit-&lt;span&gt;files
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    state
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        disabled：禁止开机自动启动
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;        enabled：开机自动启动
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt;：该unit不能独立运行，是其他unit所依赖的
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 3.&lt;span&gt;查看是否自启动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;查看指定的服务是否开机自动启动
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         systemctl list-unit-files |&lt;span&gt; grep nginx.service
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         systemctl list-unit-&lt;span&gt;files nginx.service
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         systemctl &lt;span&gt;is&lt;/span&gt;-&lt;span&gt;enabled nginx.service
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     查看一个unit的依赖关系：systemctl list-&lt;span&gt;dependencies nginx.service
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     优先用reload，如果无法让修改生效，才执行restart：systemctl reload-or-restart nginx.service
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt; 4.&lt;span&gt;禁止使用&lt;/span&gt;&lt;span&gt;enable&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;禁止用enable让某服务开机自启动：systemctl mask nginx.service
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    解除禁止mask功能：systemctl unmask nginx.service
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;     注意：所有的.service可以省略
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 5.&lt;span&gt;切换级别&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     systemctl使用举例-&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    切换级别：systemctl isolate name.target
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;     切换到的救援模式（级别）：systemctl rescure.tartet   &amp;lt;&amp;lt;&amp;lt; 切换到救援模式不需要用isolate
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 6.&lt;/strong&gt;&lt;strong&gt;查看默认级别&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1    &lt;/span&gt; 查看系统默认的运行级别：systemctl &lt;span&gt;get&lt;/span&gt;-&lt;span&gt;default&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     查看当前系统可用的target：systemctl list-units --&lt;span&gt;type target
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     修改系统默认运行级别：systemctl &lt;span&gt;set&lt;/span&gt;-&lt;span&gt;default&lt;/span&gt; name.target
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;7.unit&lt;span&gt;的文件的基本构成&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;第一部分：&lt;/span&gt;unit&lt;span&gt;，用于记录该&lt;/span&gt;&lt;span&gt;unit&lt;/span&gt;&lt;span&gt;文件的一些通用信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二部分：&lt;/span&gt;service&lt;span&gt;，记录&lt;/span&gt;&lt;span&gt;service&lt;/span&gt;&lt;span&gt;具体信息（如何启动、配置文件位置&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三部分：&lt;/span&gt;install&lt;span&gt;，记录安装信息（运行级别）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;第一部分：Unit部分
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;1&lt;/span&gt;&lt;span&gt;）Description：对该服务的一个简要说明
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;2&lt;/span&gt;）Before：定义启动顺序，例子：Before=&lt;span&gt;nginx.service，表示该服务需要在nginx启动之前启动
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;3&lt;/span&gt;&lt;span&gt;）After：定义启动顺序，同上
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;4&lt;/span&gt;&lt;span&gt;）Documentation：帮助文档
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;5&lt;/span&gt;）Wants：建议同时启动某服务，比如：Wants=&lt;span&gt;nginx.service 表示系统中最好启动nginx服务，但是即使不启动nginx，当前这个服务也没啥影响
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;6&lt;/span&gt;）Require：当前服务是需要哪个特定的服务的，比如：Require=&lt;span&gt;nginx.service，这就表示当前服务是需要nginx服务，那么在启动当前这个服务的时候，会自动将nginx也启动起来；而且一旦发现nginx服务停止了，那么当前这个服务也就会自动停止
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    【require无法指定启动次序，需要结合Before After来用，否则经常出现各种问题】
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;7&lt;/span&gt;&lt;span&gt;）Conflicis：当一个服务启动的时候，会立刻停止与之相冲突的服务
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;第二部分：Service部分
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;1&lt;/span&gt;&lt;span&gt;）Type：指定service的类型
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        类型1：oneshot：程序执行完成就自动结束了，没有后台进程，比如执行一个shell
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        类型2：forking：需要一个后台守护进程一直在运行，比如运行nginx、apache、sshd
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;2&lt;/span&gt;&lt;span&gt;）ExecStart：指定如何启动服务（指定启动服务要执行的命令）
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        如果服务类型是oneshot类型，那么可以直接写上他要执行命令即可，通常不能添加参数和选项
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        如果服务类型不是oneshot类型，那么在写要执行的命令的时候，可以添加一些参数，比如指定选项、配置文件、用户
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        【如果要执行多个命令，那么多个命令之间用;分割，如果需要换行可以用 \ 来续行】
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;3&lt;/span&gt;&lt;span&gt;）ExecStartPre, ExecStartPost：指定在执行启动服务之前、之后要执行什么命令
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;4&lt;/span&gt;&lt;span&gt;）ExecStop：停止服务
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;5&lt;/span&gt;&lt;span&gt;）Restart：
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;6&lt;/span&gt;&lt;span&gt;）PIDFile：指定pid文件的路径
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;第三部分：install部分
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     WantedBy：指定运行级别，WantedBy=multi-user.target
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;8.案例：&lt;span&gt;编写&lt;/span&gt;unit&lt;span&gt;文件，并注册到&lt;/span&gt;&lt;span&gt;systemd&lt;/span&gt;&lt;span&gt;服务中&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;第一步：准备一个shell脚本
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         # vim /root/&lt;span&gt;name.sh
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             #!/bin/&lt;span&gt;bash
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             echo `hostname`&amp;gt;/tmp/&lt;span&gt;name.log
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    第二步：创建unit文件
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        # vim my.service
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            [Unit]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             Description=&lt;span&gt;this&lt;/span&gt; &lt;span&gt;is&lt;/span&gt;&lt;span&gt; my first unit file
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            [Service]
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             Type=&lt;span&gt;oneshot
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             ExecStart=/bin/bash /root/&lt;span&gt;name.sh
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            [Install]
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             WantedBy=multi-&lt;span&gt;user.target
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         # mv my.service /usr/lib/systemd/&lt;span&gt;system
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    第三步：将我的unit文件注册到systemd中
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        # systemctl enable my.service
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    第四步：查看该服务的状态
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         # systemctl status my.service
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;9.扩展&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.grub2&lt;span&gt;的配置文件-&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;/etc/default/grub &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;# 指定用户选择菜单超时时间
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     GRUB_TIMEOUT=&lt;span&gt;5&lt;/span&gt;      
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    # 指定菜单中的描述名称    
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     GRUB_DISTRIBUTOR=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$(sed 's, release .*$,,g' /etc/system-release)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    # GRUB指定哪个是默认的title
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    # save表示会保存当前的配置，需要结合一个内置变量来使用
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     GRUB_DEFAULT=&lt;span&gt;saved
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    # 禁用子菜单
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     GRUB_DISABLE_SUBMENU=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    # 指定将启动过程中的信息输出到终端
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     GRUB_TERMINAL_OUTPUT=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;console&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    # 在启动系统的时候，以命令行的方式向内核传递参数
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     GRUB_CMDLINE_LINUX=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;crashkernel=auto rhgb &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    # 指定是否显示启动过程信息
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     GRUB_DISABLE_RECOVERY=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.&lt;span&gt;定制&lt;/span&gt;grub2&lt;span&gt;的配置文件&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1    &lt;/span&gt; &lt;span&gt;第一步：备份原有的grub.cfg
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         # cp /boot/grub2/&lt;span&gt;grub.cfg{,.bak}
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;     第二步：修改/etc/&lt;span&gt;default&lt;/span&gt;/&lt;span&gt;grub 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    第三步：重新生成grub.cfg
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         # grub2-mkconfig&amp;gt;/boot/grub2/grub.cfg
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.&lt;strong&gt;CentOS7&lt;span&gt;忘记密码解决方法&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;进入紧急救援模式
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         进入方式：在启动系统的时候，编辑内核选项，添加 rd.&lt;span&gt;break&lt;/span&gt;，然后按ctrl+&lt;span&gt;x
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        进入救援模式后：
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;1&lt;/span&gt;&lt;span&gt;. 根在 sysroot 下
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;2&lt;/span&gt;&lt;span&gt;. 当前是只读权限
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        操作：
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             # mount -o remount,rw /&lt;span&gt;sysroot
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             # chroot /&lt;span&gt;sysroot
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            # passwd 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                xxx
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                xxx
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            # exit
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             # reboot
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 10.进入救援模式方法&lt;/h2&gt;
&lt;h3&gt;1 概述&lt;/h3&gt;
&lt;p&gt;要使得linux进入救援模式，原则其实就是一个，通过光盘启动模式进入，所以，就要想办法让机器能从光盘启动。&lt;/p&gt;
&lt;p&gt;本文主要模拟了Vmware下的操作。如果是真实机器，操作前将光盘插入机器里即可&lt;/p&gt;
&lt;h3&gt;2 CentOS6&lt;/h3&gt;
&lt;p&gt;首先在重新开机时当出现下面这个接界面时按esc进入到Boot Menu。（ps：如果是虚拟机，要提前按一下鼠标，按鼠标模式是在虚拟机内操作，不是本地机器的操作，然后，手速要快，在进度条满之前按，只能按一下，按多了也进不去）&lt;/p&gt;
&lt;p&gt;备注：这里如果按F2进入BIOS然后在设置光盘启动项为第一项也是可以，但是不推荐，因为还要改回来，要不然每次都是光盘第一启动，很麻烦&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-92bca46318ae5e3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上下键选择第三项CD-ROM Drive，光盘启动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-a16aa18deeb648cb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再选择第三项救援模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-cffe328a9ceae9c1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择语言，默认English就行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-58e607641916b56c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-1acd94f0ca27a2a7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择No跳过网口检测&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-bcd8d36baca9af55?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击继续&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-69c36ba3faaa1a2c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里提示我们，救援模式下的根目录不是我们以前的根目录，而/mnt.sysimage这个目录才是我没以前的根目录，如果想要变回以前的根目录需要执行chroot /mnt/sysimage命令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-1eea760167a47e87?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再一次提示我们根目录的问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-e2256eb045c1a3c4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候选择开启shell进程，这样我们就可以使用命令了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-cd7555575d39078a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-b0c877b36966a287?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3 CentOS7&lt;/h3&gt;
&lt;p&gt;centOS7进入图一 troubleshooting有两个方法&lt;/p&gt;
&lt;p&gt;方法一&lt;/p&gt;
&lt;p&gt;首先在重新开机时当出现下面这个接界面时按esc进入到Boot Menu。（ps：如果是虚拟机，要提前按一下鼠标，按鼠标模式是在虚拟机内操作，不是本地机器的操作，然后，手速要快，在进度条满之前按，只能按一下，按多了也进不去）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-92bca46318ae5e3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上下键选择第三项CD-ROM Drive，光盘启动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-a16aa18deeb648cb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;方法二&lt;/p&gt;
&lt;p&gt;虚拟机开机按F12--》c--&amp;gt;输入exit --》&lt;/p&gt;
&lt;p&gt;以上两个方法都可以进入troubleshooting页面，接下来步骤一样&lt;/p&gt;
&lt;p&gt; 图一 选择troubleshooting --&amp;gt; 图二 选择Rescue，等待加载--》选择 选项1，等待一会儿，按enter，就可以进入救援模式&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-a9e4f88cbd1dcd22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图一 选择troubleshooting&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-b2a626c9b1ceea0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图二 选择Rescue&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-fbe74d1204d815e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 09 Oct 2018 13:14:00 +0000</pubDate>
<dc:creator>技术流ken</dc:creator>
<og:description>1.简介 在centos5中生成和管理用户空间中的进程以及完成系统的初始化使用的是init,并且是依次启动。在centos6中则是使用的upstart,在一定程度上实现了并行启动，但是仍然存在依赖关系</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenken2018/p/9762823.html</dc:identifier>
</item>
<item>
<title>Koa下http代理 - -云-</title>
<link>http://www.cnblogs.com/cloud-/p/9762901.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cloud-/p/9762901.html</guid>
<description>&lt;p&gt;最近做管理后台的重构或者说重做. 至于为什么要重构.&lt;br/&gt;随意的解释:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;是原来写的人走了.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;客观的解释:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用的人觉得不好用&lt;/li&gt;
&lt;li&gt;维护的人员找不到北&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;再多一点解释:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;express + ejs的混合编写
&lt;ul&gt;&lt;li&gt;单独抽象了Router层, 定义了controller层, service层, 但是强行绑定, 耦合很紧密&lt;/li&gt;
&lt;li&gt;中间件过度使用, 本意想简化操作, 反而编程负担&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;服务端定义了渲染模板, 前端又有模板, 额&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;引入ts, 但是很多都是any, 接口很多都是直接把query或者body参数直接使用, 非常难跟踪数据&lt;/li&gt;
&lt;li&gt;views未按照功能分文件夹, 全部在一个文件夹下, 头晕的厉害&lt;/li&gt;
&lt;li&gt;后台配置不合理, 即使是菜单这种配置也是完全一样的几份&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;前端杂乱
&lt;ul&gt;&lt;li&gt;jquery编写, 本身并无问题, 没有模块化, 出现代码多页面混用, 一处修改, 可能多页面出错&lt;/li&gt;
&lt;li&gt;体验很差, 测试人员和开发人员都不一定能正常操作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;额外说两句, 这里的express + ejs的项目属于前端项目, 后台有很多nodejs编写的形式微服务的服务.&lt;/p&gt;
&lt;p&gt;因为是后台管理项目, 美观要求并不是那么高. 我的规划是.&lt;/p&gt;
&lt;p&gt;基于koa的node中间层&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;授权管理&lt;/li&gt;
&lt;li&gt;ACL管理, 这里我们自己编写的轻量级的权限控制.&lt;/li&gt;
&lt;li&gt;文件上传(阿里) 和其他可能需要定制的处理, 比如使用文件批量上传数据的处理&lt;/li&gt;
&lt;li&gt;请求转发&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;前端项目&lt;br/&gt;使用 create-react-app + react-app-rewired + ant + mobx 构建项目,&lt;br/&gt;ant design已经基本够用, 实际上mobx都可以不用.&lt;/p&gt;
&lt;p&gt;这里就有两个项目项目了, 一个ui项目, 一个中间层api项目.&lt;/p&gt;
&lt;p&gt;开发模式下, ui项目是通过dev-server启动的, 会通过代理转发请求到中间层api项目, 中间层api项目再转发到实际的服务. 这一切看起来都很美好, 也没毛病.&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;我随手拈来, 配置好, 开始请求. 就泪奔了. 请求死活过不去.&lt;/p&gt;
&lt;h3 id=&quot;各种中间件尝试&quot;&gt;各种中间件尝试&lt;/h3&gt;
&lt;p&gt;express下面有很好用的http-proxy-middleware, 但是koa并没有, koa官方推荐的是koa-proxies 和koa-better-http-proxy, 自己搜索发现 koa-proxy下载量和star都还要高一些, 于是自己就开始挨个试试, 均失败.&lt;/p&gt;
&lt;p&gt;开始怀疑是版本问题, 查看均是支持的, 而且debug确实执行了请求发送, debug进入源码发现 Socket hang up.&lt;/p&gt;
&lt;h3 id=&quot;自己封装&quot;&gt;自己封装&lt;/h3&gt;
&lt;p&gt;后来检查源码, 其实都是基于http-proxy进行的封装, 于是参考别人的代码, 自己简单的封装了一个版本, 进行debug, 结果依旧,&lt;/p&gt;
&lt;h3 id=&quot;koa-connect&quot;&gt;koa-connect&lt;/h3&gt;
&lt;p&gt;后来搜索发现, koa下能使用express的中间件, 需要通过转换, 这个中间件就是koa-connect, 于是进行切换, 结果还是失败, 心疼&lt;/p&gt;
&lt;h3 id=&quot;http-proxy-生命周期拦截&quot;&gt;http-proxy 生命周期拦截&lt;/h3&gt;
&lt;p&gt;接着尝试, 在http-proxy的各个生命周期进行拦截, 成效也不大, 倒是了解了一下http-proxy&lt;/p&gt;
&lt;h3 id=&quot;x-www-form-urlencoded&quot;&gt;x-www-form-urlencoded&lt;/h3&gt;
&lt;p&gt;我们的接口全部都是post调用的,而且接受的数据格式都是x-www-form-urlencoded, 偶尔一次发现, 使用get居然转发到了服务器, 只是提示不允许get调用, 其实说明已经能联通, 但是post却是过不去. 那就说明问题很可能处在数据传递的格式.&lt;/p&gt;
&lt;h3 id=&quot;百度bing和google搜索&quot;&gt;百度,bing和google搜索&lt;/h3&gt;
&lt;p&gt;发现了这篇文章,&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/hyz792901324/article/details/79041480&quot;&gt;http-proxy-middleware nodejs post请求超时问题 x-www-form-urlencoded&lt;/a&gt;&lt;br/&gt;我把代码提前了, 结果真的是ok了, 我的眼泪啊.&lt;/p&gt;
&lt;p&gt;但是, 不能这样啊, 我的auth拦截肯定会先于proxy, auth之前肯定还有bodyParser, session等中间件, 大哥这可不行啊.&lt;/p&gt;
&lt;p&gt;继续搜索 &lt;a href=&quot;https://stackoverflow.com/questions/36416129/edit-post-parameters-prior-to-forwarding-to-a-proxy-target-and-sending-response&quot;&gt;edit-post-parameters-prior-to-forwarding-to-a-proxy-target-and-sending-response&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;   onProxyReq(proxyReq, req, res) {
        if ( req.method == &quot;POST&quot; &amp;amp;&amp;amp; req.body ) {
            // Add req.body logic here if needed....

           // ....

            // Remove body-parser body object from the request
            if ( req.body ) delete req.body;

            // Make any needed POST parameter changes
            let body = new Object();

            body.filename = 'reports/statistics/summary_2016.pdf';
            body.routeid = 's003b012d002';
            body.authid = 'bac02c1d-258a-4177-9da6-862580154960';

            // URI encode JSON object
            body = Object.keys( body ).map(function( key ) {
                return encodeURIComponent( key ) + '=' + encodeURIComponent( body[ key ])
            }).join('&amp;amp;');

            // Update header
            proxyReq.setHeader( 'content-type', 'application/x-www-form-urlencoded' );
            proxyReq.setHeader( 'content-length', body.length );

            // Write out body changes to the proxyReq stream
            proxyReq.write( body );
            proxyReq.end();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到重写了content-type和content-length, 我就笑了. 还是自己太天真, 没理解好这个onProxyReq方法, 于是我也这么重写, 再提前其他中间件, 就没有问题了.&lt;/p&gt;
&lt;p&gt;我真的就能苦笑了, 还好解决了问题. 关于http-proxy打算有时间深入看一看, 值得拥有.&lt;/p&gt;
</description>
<pubDate>Tue, 09 Oct 2018 13:11:00 +0000</pubDate>
<dc:creator>-云-</dc:creator>
<og:description>前言 最近做管理后台的重构或者说重做. 至于为什么要重构. 随意的解释: 1. 是原来写的人走了. 客观的解释: 1. 用的人觉得不好用 2. 维护的人员找不到北 再多一点解释: 1. express</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cloud-/p/9762901.html</dc:identifier>
</item>
</channel>
</rss>