<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>经典案例那个什么多线程--卖票..........................就是好像有点不对~~！先写下来.有大哥哥，大姐姐帮看下吗 - 北九北</title>
<link>http://www.cnblogs.com/peng1314/p/10029807.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peng1314/p/10029807.html</guid>
<description>&lt;p&gt;package javawork;&lt;/p&gt;
&lt;p&gt;public class RunnableDemo2 {&lt;/p&gt;
&lt;p&gt;public static void main(String[] args) {&lt;br/&gt;Runnable02 ru = new Runnable02();&lt;br/&gt;Thread ru1 = new Thread(ru);&lt;br/&gt;Thread ru2 = new Thread(ru);// 两个窗口&lt;br/&gt;ru1.start();// 两个窗口启动&lt;br/&gt;ru2.start();&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;class Runnable02 implements Runnable {&lt;br/&gt;private int num = 16;&lt;br/&gt;Object obj = new Object();&lt;br/&gt;String s = new String();&lt;br/&gt;boolean flag = false;&lt;/p&gt;
&lt;p&gt;@Override&lt;br/&gt;public void run() {&lt;br/&gt;while (true) {&lt;br/&gt;// 同步代码块&lt;br/&gt;// flag为 false时 执行同步代码块&lt;br/&gt;if (!flag) {&lt;br/&gt;synchronized (this) {// 同步代码快的函数可以是任意函数&lt;br/&gt;if (num &amp;gt; 0) {&lt;br/&gt;System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (num--) + &quot;号票&quot; + &quot;同步代码块++++&quot;);&lt;br/&gt;try {&lt;br/&gt;Thread.sleep(100);&lt;br/&gt;} catch (InterruptedException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;e.printStackTrace();&lt;br/&gt;} // 睡眠0.2S&lt;br/&gt;}&lt;br/&gt;flag = true;&lt;br/&gt;}&lt;br/&gt;// 同步函数&lt;br/&gt;} else {&lt;br/&gt;funtion();&lt;br/&gt;flag = false;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;// 同步函数的锁是This&lt;br/&gt;public synchronized void funtion() {&lt;br/&gt;if (num &amp;gt; 0) {&lt;br/&gt;System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (num--) + &quot;号票&quot; + &quot;同步函数----&quot;);&lt;br/&gt;try {&lt;br/&gt;Thread.sleep(100);&lt;br/&gt;} catch (InterruptedException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;e.printStackTrace();&lt;br/&gt;} // 睡眠0.2S&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
</description>
<pubDate>Tue, 27 Nov 2018 15:33:00 +0000</pubDate>
<dc:creator>北九北</dc:creator>
<og:description>package javawork; public class RunnableDemo2 { public static void main(String[] args) { Runnable02 r</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peng1314/p/10029807.html</dc:identifier>
</item>
<item>
<title>[译]聊聊C＃中的泛型的使用（新手勿入） - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/10029782.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/10029782.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;今天忙里偷闲在浏览外文的时候看到一篇讲C#中泛型的使用的文章，因此加上本人的理解以及四级没过的英语水平斗胆给大伙进行了翻译，当然在翻译的过程中发现了一些问题，因此也进行了纠正，当然，原文的地址我放在最下面，如果你的英文水平比较好的话，可以直接直接阅读全文。同时最近建了一个.NET Core实战项目交流群637326624，有兴趣的朋友可以来相互交流。目前.NET Core实战项目之CMS的教程也已经更新了6篇了，目前两到三天更新一篇。&lt;/p&gt;
&lt;blockquote readability=&quot;2.0987654320988&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/10029782.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/10029782.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;C＃和.NET中的泛型程序具有强类型集合的许多优点，并为代码提供更高质量和性能提升。泛型是C#语言和公共语言运行库（CLR）中的一个新功能，它将类型参数的概念引入.NET Framework。类型参数使得设计某些类和方法成为可能，例如，通过使用泛型类型参数T，可以大大简化类型之间的强制转换或装箱操作的过程（装箱、拆箱问题）。说白了，泛型就是通过参数化类型来实现在同一份代码上操作多种数据类型，利用“参数化类型”将类型抽象化，从而实现灵活的复用。每个集合的详细规范可以在System.Collection.Generic名称空间下找到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181127232611460-274150037.jpg&quot; alt=&quot;通用类C＃&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;装箱和拆箱&quot;&gt;装箱和拆箱&lt;/h2&gt;
&lt;p&gt;.Net定义了两种主要的数据类型来表示变量，也就是传说中的值类型和引用类型。这是需要装箱和拆箱的地方。装箱是一种通过将变量存储到System.Object中来显式地将值类型转换为引用类型的机制。当您装入值时，CLR会将新对象分配到堆中，并将值类型的值复制到该实例中。例如，您创建了一个int类型的变量：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;int a = 20;  
object b = a; //装箱&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相反的操作是拆箱，它是将引用类型转换回值类型的过程。此过程验证接收数据类型是否与装箱类型一致;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;int c = (int)b; // 拆箱&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;C＃编译器可以看到从int到object的赋值，反之亦然。当编译该程序并通过IL解析器检查IL生成的代码时，您会注意到当b被赋值为a时，程序通过在IL中自动插入一个box指令来响应，当c被赋值为b时如下;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181127232610935-1372402568.jpg&quot; alt=&quot;IL-opcode.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码加载常量20并将其存储在本地插槽中；它将值20加载到堆栈中并将其装箱。最后，它将被装箱的20返回到堆栈上，并将其拆箱为int类型&lt;/p&gt;
&lt;p&gt;这个过程.NET CLR执行了一系列操作，例如，首先在托管堆中分配一个对象，然后在装箱中将值转换为内存位置，并在拆箱期间将值存储在堆上并且必须转回到堆栈。因此，从性能的角度来看，装箱和拆箱过程在泛型中具有非常重要的意义，因为这个过程如果不使用泛型的话会耗费更多地资源。&lt;/p&gt;
&lt;h2 id=&quot;泛型类&quot;&gt;泛型类&lt;/h2&gt;
&lt;p&gt;可以通过在类名后面加上符号来定义泛型类。这里没有强制必须将“T”字放在泛型的定义中。您可以在TestClass &amp;lt;&amp;gt;类声明中使用任何单词。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class TestClass&amp;lt;T&amp;gt; { }  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;System.Collection.Generic命名空间下还定义了许多实现了这些关键字接口的类型。下表列出了此命名空间的核心类类型。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Collection&lt;/td&gt;
&lt;td&gt;泛型集合的基类，可以比较两个泛型对象是否相等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Dictionary&amp;lt;TKey, TValue&amp;gt;&lt;/td&gt;
&lt;td&gt;键值对的泛型集合&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;List&lt;/td&gt;
&lt;td&gt;可动态调整列表项的大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Queue&lt;/td&gt;
&lt;td&gt;先进先出（FIFO）列表的泛型实现&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Stack&lt;/td&gt;
&lt;td&gt;后进先出（LIFO）列表的泛型实现&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;简单的泛型类示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下示例显示了一个简单的泛型类型的操作。TestClass 定义一个长度为5的泛型类型数组。Add()方法负责将任何类型的对象添加到集合中，而Indexer属性是循环语句迭代的实现。最后在主类中，我们使用整形类型来实例化TestClass 类，并使用Add()方法将一些整数类型数据添加到集合中。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;  
using System.Collections.Generic;  
  
namespace GenericApp  
{  
    public class TestClass&amp;lt;T&amp;gt;  
    {  
        // 定义一个长度为5的泛型类型的数组
        T[] obj = new T[5];  
        int count = 0;  
  
        // 向反省类型添加数据 
        public void  Add(T item)  
        {  
            //checking length  
            if (count + 1 &amp;lt; 6)  
            {  
                obj[count] = item;  
  
            }  
            count++;  
        }  
        //foreach语句迭代索引
        public T this[int index]  
        {  
            get { return obj[index]; }  
            set { obj[index] = value; }  
        }   
    }  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            //用整形来实例化泛型类
            TestClass&amp;lt;int&amp;gt; intObj = new TestClass&amp;lt;int&amp;gt;();  
  
            //向集合中添加int数据
            intObj.Add(1);  
            intObj.Add(2);  
            intObj.Add(3);     //没有装箱 
            intObj.Add(4);   
            intObj.Add(5);  
  
            //遍历显示数据
            for (int i = 0; i &amp;lt; 5; i++)  
            {  
                Console.WriteLine(intObj[i]);   //没有拆箱
            }  
            Console.ReadKey();    
        }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在构建并运行该程序之后，程序的输出如下所示;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181127232610372-1311406304.jpg&quot; alt=&quot;简单仿制Example.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;泛型的主要特性&quot;&gt;泛型的主要特性&lt;/h2&gt;
&lt;p&gt;泛型类型的一些重要特征使它们相比传统的非泛型类型具有如下的显著特征：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类型安全&lt;/li&gt;
&lt;li&gt;性能&lt;/li&gt;
&lt;li&gt;二进制代码复用&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;类型安全&quot;&gt;类型安全&lt;/h3&gt;
&lt;p&gt;泛型最重要的特征之一是类型安全性。对于非泛型ArrayList类，如果使用对象类型，则可以向集合中添加任何类型，这些类型有时会导致严重的问题。下面的示例显示向ArrayList类型的集合添加一个整数、字符串和对象；&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;ArrayList obj = new ArrayList();  
obj.Add(50);  
obj.Add(&quot;Dog&quot;);  
obj.Add(new TestClass());  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，如果使用整数对象来使用foreach语句进行遍历的话，当编译器接受到代码，但是因为集合中的所有元素都不是整数，所以会导致运行时异常；&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;foreach(int i in obj)  
{  
    Console.WriteLine(i);    
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编程的经验法则是应该尽早检测到错误。对于泛型类Test，泛型类型T定义允许哪些类型。通过使用Test的定义，只能向集合添加整型类型的数据。这时候当Add()方法具有以下无效参数的时候编译器将不编译代码；&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Test&amp;lt;int&amp;gt; obj = new Test&amp;lt;int&amp;gt;();  
obj.Add(50);  
obj.Add(&quot;Dog&quot;);            //编译错误 
obj.Add(new TestClass());  //编译错误&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;性能&quot;&gt;性能&lt;/h3&gt;
&lt;p&gt;在下面的示例中，ArrayList类存储对象，并且定义了Add()方法来存储一些整型参数。因此，整数类型被装箱。当使用foreach语句读取ArrayList中的值时，将发生拆箱。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;ArrayList  obj = new ArrayList();   
obj.Add(50);    //装箱- 值类型转换成引用类型 
int x= (int)obj[0]; //拆箱
foreach(int i in obj)  
{  
   Console.WriteLine(i);   // 拆箱
} &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：泛型比其他集合（如ArrayList）更快。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代替使用对象类型，TestClass类的泛型类型被定义为int，因此在从编译器动态生成的类中将使用int类型。所以将不会发生装箱和拆箱，如下所示；&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;TestClass&amp;lt;int&amp;gt; obj = new TestClass&amp;lt;int&amp;gt;();  
obj.Add(50);    //没有装箱 
int x= obj[0]; // 没有拆箱
foreach(int i in obj)  
{  
   Console.WriteLine(i);   //没有拆箱 
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二进制代码复用&quot;&gt;二进制代码复用&lt;/h3&gt;
&lt;p&gt;泛型类型提供了一种源代码保护机制。泛型类可以定义一次，并且可以使用许多不同类型来进行实例化。泛型可以在一种CLR支持的语言中定义，并可以被另一种.NET语言使用。以下TestClass 使用int和string类型进行实例化：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;TestClass&amp;lt;int&amp;gt; obj = new TestClass&amp;lt;int&amp;gt;();  
obj.Add(50);  
  
TestClass&amp;lt;string&amp;gt; obj1 = new TestClass&amp;lt;string&amp;gt;();  
Obj1.Add(&quot;hello&quot;);  &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;通用方法&quot;&gt;通用方法&lt;/h2&gt;
&lt;p&gt;虽然大多数开发人员通常会使用基类库中的现有泛型类型，但也有可能会构建自己的泛型成员和自定义的泛型类型。&lt;/p&gt;
&lt;p&gt;本示例的目的是构建一个交换方法，该方法可以使用单个类型参数对任何可能的数据类型（基于值或基于引用）进行操作。由于交换算法的性质，传入的参数将作为使用ref关键字修饰的引用类型来进行发送。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;  
using System.Collections.Generic;  
  
namespace GenericApp  
{  
    class Program  
    {  
        //泛型方法
        static void Swap&amp;lt;T&amp;gt;(ref T a, ref T b)  
        {  
            T temp;  
            temp = a;  
            a = b;  
            b = temp;  
        }  
        static void Main(string[] args)  
        {  
            //交换两个整形数据
            int a = 40, b = 60;  
            Console.WriteLine(&quot;Before swap: {0}, {1}&quot;, a, b);  
  
            Swap&amp;lt;int&amp;gt;(ref a, ref b);  
  
            Console.WriteLine(&quot;After swap: {0}, {1}&quot;, a, b);  
  
            Console.ReadLine();  
        }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译此泛型方法实现的程序后，输出如下所示;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181127232610049-650956191.jpg&quot; alt=&quot;通用-Methods.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;字典&quot;&gt;字典&lt;/h2&gt;
&lt;p&gt;字典也被称为映射或散列表。它表示允许您基于关键字来访问元素的数据结构。字典的一个重要特征是更快的查找; 您可以添加或删除选项而不会产生性能开销。&lt;/p&gt;
&lt;p&gt;.Net提供了几个字典类，例如Dictionary &amp;lt;TKey，TValue&amp;gt;。类型参数TKey和TValue分别表示关键字的类型和它可以存储的值。&lt;/p&gt;
&lt;h3 id=&quot;简单的字典示例&quot;&gt;简单的字典示例&lt;/h3&gt;
&lt;p&gt;以下示例演示使用泛型的简单字典集合。在此程序中，将创建一个Dictionary类型对象，该对象接受int作为键，字符串作为值。然后我们将一些字符串值添加到字典集合中，最后显示字典集合元素。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;  
using System.Collections.Generic;  
  
namespace GenericApp  
{  
    public class Program    
    {  
        static void Main(string[] args)  
        {  
            //定义一个字典集合
            Dictionary&amp;lt;int,string&amp;gt; dObj = new Dictionary&amp;lt;int,string&amp;gt;(5);  
  
            //向字典中添加类型
  
            dObj.Add(1,1,&quot;Tom&quot;);    
            dObj.Add(2,&quot;John&quot;);  
            dObj.Add(3, &quot;Maria&quot;);  
            dObj.Add(4, &quot;Max&quot;);  
            dObj.Add(5, &quot;Ram&quot;);  
  
            //输出数据
            for (int i = 1; i &amp;lt;= dObj.Count;i++)  
            {  
                Console.WriteLine(dObj[i]);  
            }  
            Console.ReadKey();  
        }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下示例通过定义附加类emp来描述一些更复杂的问题，其中我们覆盖ToString()方法以显示特定员工的名称和薪水。稍后在Main()方法中，创建一个新的Dictionary &amp;lt;TKey，TValue）的实例，其中键的类型为string，值为emp类型。构造函数分配2个元素的容量。emp对象和作为键的字符串值被添加到字典集合中。最后，使用foreach语句迭代集合元素并显示在屏幕上。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;  
using System.Text;  
using System.Collections.Generic;  
  
namespace GenericApp  
{  
    public class emp   
    {  
        private string name;  
        private int salary;  
   
        public emp(string name,int salary)  
        {  
            this.name = name;  
            this.salary = salary;   
        }  
        public override string ToString()  
        {  
            StringBuilder sb = new StringBuilder(200);  
            sb.AppendFormat(&quot;{0},{1}&quot;,name,salary);  
  
            return sb.ToString();  
        }  
  
    }  
    public class Program    
    {  
        static void Main(string[] args)  
        {  
            //定义一个字典集合 
            Dictionary&amp;lt;string, emp&amp;gt; dObj = new Dictionary&amp;lt;string, emp&amp;gt;(2);  
  
            //向字典中添加元素
            emp tom = new emp(&quot;tom&quot;, 2000);  
            dObj.Add(&quot;tom&quot;,tom);   // 键，值 
            emp john = new emp(&quot;john&quot;, 4000);  
            dObj.Add(&quot;john&quot;,john);  
  
            //print data  
            foreach(Object str in dObj.Values)  
            {  
               Console.WriteLine(str);  
            }  
   
            Console.ReadKey();  
        }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;队列&quot;&gt;队列&lt;/h2&gt;
&lt;p&gt;队列是一种特殊类型的容器，可确保以FIFO（先进先出）方式访问元素。队列集合最适合实现消息传递的组件。我们可以使用以下语法定义Queue集合对象：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Queue qObj = new Queue();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Queue集合的属性，方法和其他规则定义都位于Sysyem.Collection命名空间下。下表定义了关键成员;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Enqueue()&lt;/td&gt;
&lt;td&gt;将对象添加到队列的末尾。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Dequeue()&lt;/td&gt;
&lt;td&gt;从队列的开头删除对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Peek()&lt;/td&gt;
&lt;td&gt;返回队列开头的对象而不删除它。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;下面演示了一个基本的队列类型的集合，将一些字符串类型值添加到集合中，最后使用while语句来显示整个集合中的数据 。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;  
using System.Collections;  
  
namespace GenericApp  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            //定义一个队列
            Queue qObj = new Queue();  
  
            //向队列中添加字符串数据
            qObj.Enqueue(&quot;Tom&quot;);  
            qObj.Enqueue(&quot;Harry&quot;);  
            qObj.Enqueue(&quot;Maria&quot;);       
            qObj.Enqueue(&quot;john&quot;);  
  
            //显示队列中的数据 
            while(qObj.Count !=0 )  
            {  
                Console.WriteLine(qObj.Dequeue());  
            }  
  
            Console.ReadKey();    
        }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;堆栈&quot;&gt;堆栈&lt;/h2&gt;
&lt;p&gt;Stack集合是LIFO的抽象（后进先出）。我们可以使用以下语法定义Stack集合对象：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Stack qObj = new Stack();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下表说明了堆栈的关键成员;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Contains()&lt;/td&gt;
&lt;td&gt;如果在集合中找到特定元素，则返回true。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Clear()&lt;/td&gt;
&lt;td&gt;删除集合的所有元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Peek()&lt;/td&gt;
&lt;td&gt;预览堆栈中的最新元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Push()&lt;/td&gt;
&lt;td&gt;它将元素推入堆栈。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Pop()&lt;/td&gt;
&lt;td&gt;返回并删除堆栈的顶部元素。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;以下演示了堆栈集合。首先，将数组类型对象引用到堆栈集合中。然后使用Pop（）方法从堆栈中删除集合中元素的值并显示在屏幕上。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;  
using System.Collections;  
  
namespace GenericApp  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            int[] iArray = new int[] {1,2,3,4,5,6,7,8,9,10 };  
  
            //定义一个堆栈
            Stack sObj = new Stack(iArray);  
  
            Console.WriteLine(&quot;Total items=&quot;+sObj.Count);  
  
            //显示集合数据
            for (int i = 0; i &amp;lt; sObj.Count;++i )  
            {  
                Console.WriteLine(sObj.Pop());  
            }  
  
            Console.ReadKey();    
        }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在使用泛型实现的另一个示例中，使用Push()方法将5个项添加到堆栈中。然后使用循环迭代输出堆栈中的数据。堆栈的枚举器不会删除数据; 它只是以LIFO方式返回每个项目，如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;  
using System.Collections;  
  
namespace GenericApp  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
  
             //定义一个堆栈
            Stack sObj = new Stack();

            //向集合添加数据
            for (int i = 0; i &amp;lt; 5; ++i)
            {
                sObj.Push(i+1);
            }
            Console.WriteLine(&quot;Total items=&quot; + sObj.Count);
            //打印数据 
            foreach (int i in sObj)
            {
                Console.WriteLine(i);
            }
            Console.ReadKey();
        }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;今天忙里偷闲，在浏览外文的时候看到一篇讲泛型的文章，因此就加上自己的理解进行了相关翻译，也加深了自己对泛型的理解！如果英文比较好的话可以直接访问https://www.c-sharpcorner.com/UploadFile/84c85b/using-generics-with-C-Sharp/ 自行查看！当然，我在翻译的过程中也发现了文中的一些错误，所以进行了更正！同时最近建了一个.NET Core实战项目交流群637326624，有兴趣的朋友可以来相互交流。目前.NET Core实战项目之CMS的教程也已经更新了6篇了，目前两到三天更新一篇。最后感谢大家的阅读。&lt;/p&gt;
</description>
<pubDate>Tue, 27 Nov 2018 15:28:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>写在前面 今天忙里偷闲在浏览外文的时候看到一篇讲C 中泛型的使用的文章，因此加上本人的理解以及四级没过的英语水平斗胆给大伙进行了翻译，当然在翻译的过程中发现了一些问题，因此也进行了纠正，当然，原文的地</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/10029782.html</dc:identifier>
</item>
<item>
<title>Shell编程-11-子Shell和Shell嵌套 - Surpassme</title>
<link>http://www.cnblogs.com/surpassme/p/10029758.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/surpassme/p/10029758.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h3 id=&quot;什么是子shell&quot;&gt;什么是子Shell&lt;/h3&gt;
&lt;p&gt;    子Shell的概念其实是贯穿整个Shell的，如果想要更好的理解和写Shell脚本则必须要了解子Shell的相关知识。其概念如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;子Shell本质就是从当前的Shell环境中打开一个新的Shell环境，而新开的Shell称之为子Shell（SubShell），相应的开启子Shell的环境称之为父Shell。子Shell和父Shell是子进程和父进程的关系，而这个进程则全部是bash进程。子Shell可以从父Shell中继承变量、命令全路径、文件描述符、当前工作目录等。在子Shell中常用的两个变量如下所示：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;$BASH_SUBSHELL:查看从当前进程开始的子Shell层数&lt;/li&gt;
&lt;li&gt;$BASHPID:查看当前所处BASH的PID&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;在Linux系统中，系统运行的程序基本都是从CentOS 6.x(init)或CentOS7.x(systemd)PID为1的进程）继承而来的，所有的程序都可以看作为init的子进程。
# CentOS 6.x
[root@localhost data]# pstree -hp
init(1)─┬─NetworkManager(3643)
        ├─Xvnc(22811)
        ├─abrtd(4760)
        ├─acpid(3755)
        ├─atd(4801)
        ├─auditd(3392)───{auditd}(3393)
        ├─automount(3849)─┬─{automount}(3850)
        │                 ├─{automount}(3851)
        │                 ├─{automount}(3854)
        │                 └─{automount}(3857)
# CentOS 7.x
[root@localhost ~]# pstree -hp
systemd(1)─┬─ModemManager(1051)─┬─{ModemManager}(1068)
           │                    └─{ModemManager}(1076)
           ├─Xvnc(5563)─┬─{Xvnc}(5566)
           │            ├─{Xvnc}(5567)
           │            ├─{Xvnc}(5568)

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;子shell产生的途径&quot;&gt;子Shell产生的途径&lt;/h3&gt;
&lt;h4 id=&quot;通过后台作业&quot;&gt;通过后台作业：&amp;amp;&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat jobs.sh
#!/bin/bash
parentShell=&quot;ParentShell&quot;
echo &quot;Parent Shell start and Level:&quot;$BASH_SUBSHELL
# define subshell
{
 echo &quot;SubShell start and Level:&quot;$BASH_SUBSHELL
 subShell=&quot;SubShell&quot;
 echo &quot;SubShell value: ${subShell}&quot;
 echo &quot;parentShell value: ${parentShell}&quot;
# sleep 5
 echo &quot;SubShell end and Level: $BASH_SUBSHELL &quot;
} &amp;amp; # running in backgroud
echo &quot;Parent end and Level:$BASH_SUBSHELL&quot;

if [ -z &quot;${subShell}&quot; ]
  then
    echo &quot;subShell is not defined in ParentShell&quot;
else
  echo &quot;subShell is defined in ParentShel&quot;
fi
[root@localhost Test]# bash jobs.sh
Parent Shell start and Level:0
Parent end and Level:0
subShell is not defined in ParentShell
SubShell start and Level:1
SubShell value: SubShell
parentShell value: ParentShell
SubShell end and Level: 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据运行结果，结论如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在Shell中可以使用&lt;strong&gt;&amp;amp;&lt;/strong&gt;产生子Shell&lt;/li&gt;
&lt;li&gt;由&lt;strong&gt;&amp;amp;&lt;/strong&gt;产生的子Shell可以直接引用父Shell的变量，而子Shell产生的变量不能被父Shell引用&lt;/li&gt;
&lt;li&gt;在Shell中使用&lt;strong&gt;&amp;amp;&lt;/strong&gt;可以实现多线程并发&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;通过管道&quot;&gt;通过管道：|&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat jobs.sh
#!/bin/bash
parentShell=&quot;ParentShell&quot;
echo &quot;Parent Shell start and Level:&quot;$BASH_SUBSHELL
# define subshell
echo &quot;&quot; |  # 管道
{
 echo &quot;SubShell start and Level:&quot;$BASH_SUBSHELL
 subShell=&quot;SubShell&quot;
 echo &quot;SubShell value: ${subShell}&quot;
 echo &quot;parentShell value: ${parentShell}&quot;
# sleep 5
 echo &quot;SubShell end and Level: $BASH_SUBSHELL &quot;
}
echo &quot;Parent end and Level:$BASH_SUBSHELL&quot;

if [ -z &quot;${subShell}&quot; ]
  then
    echo &quot;subShell is not defined in ParentShell&quot;
else
  echo &quot;subShell is defined in ParentShel&quot;
fi
[root@localhost Test]# bash jobs.sh
Parent Shell start and Level:0
SubShell start and Level:1
SubShell value: SubShell
parentShell value: ParentShell
SubShell end and Level: 1
Parent end and Level:0
subShell is not defined in ParentShell&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据运行结果，结论如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在Shell中可以使用&lt;strong&gt;管道&lt;/strong&gt;产生子Shell&lt;/li&gt;
&lt;li&gt;由&lt;strong&gt;管道&lt;/strong&gt;产生的子Shell可以直接引用父Shell的变量，而子Shell产生的变量不能被父Shell引用&lt;/li&gt;
&lt;li&gt;由&lt;strong&gt;管道&lt;/strong&gt;产生的Shell是顺序执行的，仅能在子Shell执行完成后才能返回父Shell中继续执行，这一点也是与&lt;strong&gt;&amp;amp;&lt;/strong&gt;最大的区别。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;通过&quot;&gt;通过()&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat jobs.sh
#!/bin/bash
parentShell=&quot;ParentShell&quot;
echo &quot;Parent Shell start and Level:&quot;$BASH_SUBSHELL
# define subshell
(
 echo &quot;SubShell start and Level:&quot;$BASH_SUBSHELL
 subShell=&quot;SubShell&quot;
 echo &quot;SubShell value: ${subShell}&quot;
 echo &quot;parentShell value: ${parentShell}&quot;
# sleep 5
 echo &quot;SubShell end and Level: $BASH_SUBSHELL &quot;
)
echo &quot;Parent end and Level:$BASH_SUBSHELL&quot;

if [ -z &quot;${subShell}&quot; ]
  then
    echo &quot;subShell is not defined in ParentShell&quot;
else
  echo &quot;subShell is defined in ParentShel&quot;
fi
[root@localhost Test]# bash jobs.sh
Parent Shell start and Level:0
SubShell start and Level:1
SubShell value: SubShell
parentShell value: ParentShell
SubShell end and Level: 1
Parent end and Level:0
subShell is not defined in ParentShell&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据运行结果，结论如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在Shell中可以使用&lt;strong&gt;()&lt;/strong&gt;产生子Shell&lt;/li&gt;
&lt;li&gt;由&lt;strong&gt;()&lt;/strong&gt;产生的子Shell可以直接引用父Shell的变量，而子Shell产生的变量不能被父Shell引用&lt;/li&gt;
&lt;li&gt;由&lt;strong&gt;()&lt;/strong&gt;产生的Shell是顺序执行的，仅能在子Shell执行完成后才能返回父Shell中继续执行，&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;看到这个结果，大家会不会觉得使用()跟使用管道一样的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;通过调用外部shell&quot;&gt;通过调用外部Shell&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat subShell.sh parentShell.sh  -n
       # SubShell
     1  #!/bin/bash
     2   echo &quot;SubShell start and Level:&quot;$BASH_SUBSHELL
     3   subShell=&quot;SubShell&quot;
     4   echo &quot;SubShell value: ${subShell}&quot;
     5   echo &quot;parentShell value: ${parentShell}&quot;
     6   echo &quot;parentExportShell value: ${parentExportShell}&quot;
     7   if [ -z &quot;${parentShell}&quot;  ];then
     8      echo &quot;parentShell value is : null&quot;
     9   else
    10      echo &quot;parentShell value is : &quot;${parentShell}
    11   fi
    12
    13  # ParentShell
    14  #!/bin/bash
    15  parentShell=&quot;Parent&quot;
    16  export parentExportShell=&quot;parentExportShell&quot;
    17  echo &quot;Parent Shell start and Level:&quot;$BASH_SUBSHELL
    18  bash ./subShell.sh # invoke subshell
    19  sleep 3
    20  echo &quot;Parent Shell end and Level:&quot;$BASH_SUBSHELL
    21  if [ -z &quot;${subShell}&quot; ]
    22    then
    23     echo &quot;subShell is not defined in ParentShell&quot;
    24  else
    25     echo &quot;subShell is defined in ParentShell&quot;
    26  fi
[root@localhost Test]# bash parentShell.sh
Parent Shell start and Level:0
SubShell start and Level:0
SubShell value: SubShell
parentShell value:
parentExportShell value: parentExportShell
parentShell value is : null
Parent Shell end and Level:0
subShell is not defined in ParentShell&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据运行结果，结论如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在Shell中可以通过外部Shell脚本产生子Shell&lt;/li&gt;
&lt;li&gt;在调用外部Shell时，父Shell定义的变量不能被子Shell继承，如果要继承父Shell的变量，必须使用export使其成为全局环境变量。&lt;/li&gt;
&lt;li&gt;调用外部Shell产生的Shell是顺序执行的，仅能在子Shell执行完成后才能返回父Shell中继续执行，&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;shell脚本调用模式&quot;&gt;Shell脚本调用模式&lt;/h3&gt;
&lt;p&gt;    通常在大型的项目中，都会将较大模块进行拆分为多个小模块进行代码编写调试等。因此在一个Shell脚本中也不可能包含所有模块，一般都采用在一个脚本中去调用当前用到的脚本，这种被称之为&lt;strong&gt;Shell嵌套&lt;/strong&gt;。在一个脚本中嵌套脚本的方式主要有&lt;strong&gt;fork&lt;/strong&gt;、&lt;strong&gt;exec&lt;/strong&gt;和&lt;strong&gt;source&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;fork模式调用脚本&quot;&gt;fork模式调用脚本&lt;/h4&gt;
&lt;p&gt;    fork模式是最普通的脚本调用方式。在使用该方式调用脚本时，系统会创建一个子Shell去调用脚本。其调用方式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/bin/bash /path/shellscript.sh # 未给脚本添加执行权限时
或
/path/shellscript.sh # 脚本拥有执行权限时&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;fork本质是复制进程&lt;/strong&gt;。使用该方式时，fork会复制当前进程做为一个副本，而后将这些资源交给子进程。因此子进程会继承父进程的一些资源，如环境变量、变量等。而父进程却是完全独立的，子进程和父进程相当于面向对象中一个对象的两个实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;exec模式调用脚本&quot;&gt;exec模式调用脚本&lt;/h4&gt;
&lt;p&gt;    exec调用脚本时，不会开启一个新的子Shell来进行调用脚本，被调用的脚本和调用脚本在同一个Shell内执行。&lt;strong&gt;但需要注意的是使用exec调用新脚本后，在执行完新脚本的内容后，不再返回到调用脚本中执行后续未执行的内容&lt;/strong&gt;，这也是与fork调用脚本的主要区别。其主要调用方式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;exec /path/shellscript.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;exec的本质是加载另外一个程序来代替当前运行的进程&lt;/strong&gt;。即在不创建新进程的情况下去加载一个新程序，而在进程执行完成后就直接退出exec所在的Shell环境。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;source模式调用脚本&quot;&gt;source模式调用脚本&lt;/h4&gt;
&lt;p&gt;    source调用脚本时，也不会开启一个新的子Shell来执行被调用的脚本，同样也是在同一个Shell中执行，因此被调用脚本是可以继承调用脚本的变量、环境变量等。&lt;strong&gt;与exec调用方式的区别是，source在执行完被调用脚本的内容后，依然会返回调用脚本中，去执行调用脚本中未执行的内容&lt;/strong&gt;。其主要调用方式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;source /path/shellscript.sh
或
. /path/shellscript.sh  # .和source是等价的&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;三种调用模式示例&quot;&gt;三种调用模式示例&lt;/h4&gt;
&lt;p&gt;    示例代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat -n subShell.sh parentShell.sh
     1  #!/bin/bash
     2   echo &quot;SubShell start and Level:&quot;$BASH_SUBSHELL
     3   echo &quot;SubShell PID is:&quot; $$
     4   subShell=&quot;SubShell&quot;
     5   echo &quot;SubShell value: ${subShell}&quot;
     6   echo &quot;parentShell value: ${parentShell}&quot;
     7   echo &quot;parentExportShell value: ${parentExportShell}&quot;
     8   if [ -z &quot;${parentShell}&quot;  ];then
     9      echo &quot;parentShell value is : null&quot;
    10   else
    11      echo &quot;parentShell value is : &quot;${parentShell}
    12   fi
    13  #!/bin/bash
    14  # print usage
    15  function Usage() {
    16    echo &quot;Usage:$0 {fork|exec|source}&quot;
    17    exit 1
    18  }
    19  # print return variable
    20  function PrintPara() {
    21   if [ -z &quot;${subShell}&quot; ]
    22    then
    23     echo &quot;subShell is not defined in ParentShell&quot;
    24   else
    25     echo &quot;subShell is defined in ParentShell &quot;${subShell}
    26   fi
    27  }
    28  # invoke pattern
    29  function ParentFunction() {
    30    parentShell=&quot;Parent&quot;
    31    export parentExportShell=&quot;parentExportShell&quot;
    32    echo &quot;Parent Shell start and Level:&quot;$BASH_SUBSHELL
    33    echo &quot;Parent PID is:&quot;$$
    34    case &quot;$1&quot; in
    35      fork)
    36         echo &quot;Using fork pattern&quot;
    37         /bin/bash ./subShell.sh
    38         PrintPara ;;
    39      exec)
    40         echo &quot;Using exec pattern&quot;
    41         exec ./subShell.sh
    42         PrintPara ;;
    43      source)
    44         echo &quot;Using source pattern&quot;
    45         source ./subShell.sh
    46         PrintPara ;;
    47      *)
    48        echo &quot;Input error ,usage is:&quot; Usage
    49     esac
    50  }
    51  # check parameter number
    52  function CheckInputPara() {
    53    if [ $# -ne 1 ]
    54      then
    55        Usage
    56    fi
    57    ParentFunction $*
    58  }
    59  CheckInputPara $*&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1、fork调用结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# bash parentShell.sh fork
Parent Shell start and Level:0
Parent PID is:26413
Using fork pattern
SubShell start and Level:0
SubShell PID is: 26414
SubShell value: SubShell
parentShell value:
parentExportShell value: parentExportShell
parentShell value is : null
subShell is not defined in ParentShell&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、父Shell和子Shell的PID不一样，则可以说明产生了新的子进程&lt;br/&gt;2、调用脚本中定义的全局变量可以传入到被调用脚本，而被调用的脚本中定义的变量是无法返回到调用脚本中的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、exec调用结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# chmod +x subShell.sh
[root@localhost Test]# bash parentShell.sh exec
Parent Shell start and Level:0
Parent PID is:25543
Using exec pattern
SubShell start and Level:0
SubShell PID is: 25543
SubShell value: SubShell
parentShell value:
parentExportShell value: parentExportShell
parentShell value is : null&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、父Shell和子Shell的PID一样，则可以说明未产生新的子进程&lt;br/&gt;2、调用脚本中定义的全局变量可以传入到被调用脚本&lt;br/&gt;3、最重要的一点就是在执行完被调用脚本后直接退出Shell了，而调用脚本未执行的内容并没有被执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、source调用结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# bash parentShell.sh source
Parent Shell start and Level:0
Parent PID is:19955
Using source pattern
SubShell start and Level:0
SubShell PID is: 19955
SubShell value: SubShell
parentShell value: Parent
parentExportShell value: parentExportShell
parentShell value is : Parent
subShell is defined in ParentShell: SubShell&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、父Shell和子Shell的PID一样，则可以说明未产生新的子进程&lt;br/&gt;2、调用脚本中定义的普通变量和全局变量可以传入到被调用脚本，反之亦然&lt;br/&gt;3、最重要的一点就是在执行完被调用脚本后返回调用脚本中继续执行剩下的内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;三种调用模式使用场景&quot;&gt;三种调用模式使用场景&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1、fork模式使用场景&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;fork模式常用于常规嵌套脚本执行的场景中，仅仅是执行嵌套脚本中命令，调用脚本也不需要使用被调用脚本中的变量和函数等信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;2、exec模式使用场景&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;exec模式常用于调用脚本中末尾中。而这种模式在执行完被调用脚本中就直接退出，因此使用较少，可使用source代替exec&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;3、source模式使用场景&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;source模式算是在Shell常用的一种脚本嵌套调用模式，常用于执行嵌套脚本启动一些服务程序等，其最大的优点就是嵌套脚本中定义的变量和函数等资源可以被调用脚本获取和使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文同步在微信订阅号上发布，如各位小伙伴们喜欢我的文章，也可以关注我的微信订阅号：woaitest，或扫描下面的二维码添加关注：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3349421-2a0edd703123621d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MyQRCode.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 27 Nov 2018 15:18:00 +0000</pubDate>
<dc:creator>Surpassme</dc:creator>
<og:description>[TOC] 什么是子Shell     子Shell的概念其实是贯穿整个Shell的，如果想要更好的理解和写Shell脚本则必须要了解子Shell的相关知识。其概念如下所示： 子S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/surpassme/p/10029758.html</dc:identifier>
</item>
<item>
<title>应届生秋招可能会遇到的三个问题 - DarrenHu_吴邪</title>
<link>http://www.cnblogs.com/DarrenHu/p/xiaozhao.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DarrenHu/p/xiaozhao.html</guid>
<description>&lt;h2 id=&quot;第一题&quot;&gt;第一题：&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;喜欢但是工资低的工作跟不喜欢但是工资高的工作，如何抉择？&lt;/li&gt;
&lt;li&gt;自我介绍的时候应该突出什么方面比较讨喜？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;好的，我们现在说一下这个同学的问题，喜欢但是工资低的工作和不喜欢但是工资高的工作，该如何选择，那在大原则上我们肯定都是建议大家去选择，喜欢的工作。就是工资低，这个是一个现状，工资可以通过后期的努力，可以去慢慢的提升，但是喜欢这件事情来说，是比较难改变的。所以，如果你挑了一个不喜欢的工作，一定是越做越难受。所以说这个工资高。你也不一定说能持续多久，或者说一直这样。可能对于升值来说也没那么容易，那这个就需要大家去思考，第二个问题，就是你是不是经济压力那么大。但是如果说你的家庭并没有给到一个很大的经济压力，我建议更多同学去追逐自己喜欢的工作。但如果说你说家里特别困难的，当然只能向现实去低头，这个是没有办法的事。&lt;/p&gt;
&lt;p&gt;说一下这个同学第二个问题就是关于自我介绍的时候应该突出什么方面比较讨喜，那讨喜的话，我会把它理解为是加分项，那我们先说一下自我介绍的重点。到介绍的时候重点突出的更多的事，首先是你的语言的清晰。然后逻辑清晰，这里面逻辑清晰的话就是主次分明，你主要应该去讲的东西就是你的简历的。亮点和这份工作的匹配度。就是你突出的地方。和这份工作，他的匹配关系，这个是你的终点，那讨喜这一块，我们通常会觉得因为自我介绍其实信息量很少。但是你不能讲太多东西，然后变得很长，所以说。讨喜的话一般比较好的就是我们会去讲到我为什么去这家公司，可能是因为我是这家公司的重度用户。可能是因为我很认可这家公司的某个理念或者认可某产品，就是突出是你提前做好的准备。&lt;/p&gt;
&lt;h2 id=&quot;第二题&quot;&gt;第二题：&lt;/h2&gt;
&lt;p&gt;秋招拿到了一个互联网的offer，但不满足于公司的平台。现在找到了一份平台很大，有比较对口的实习，但目前没有hc，不保证能实习转正，从12月要做到明年三月。我听大企业的hr说现在校招也喜欢用之前在企业实习的孩子，这是真的吗？如果去的话，这样会影响到之后的春招吗？十二月找什么实习比较好呢？&lt;/p&gt;
&lt;p&gt;正是因为企业其实很喜去留用实习生这一点，所以我们在没有课程的时候都会强烈建议大家去，然后说去参加这边实习会不会去影响到春招，当然是。会，而且是积极的影响。会让你春招应该是更有把握的。那同时也刚才回答过了你现在要准备春招当然是要找一份。相对来说时间有一定程度的，然后平台更大的去提升你本身简历的含金量。因为对于你要参加春招来说能拿到一份大平台的实习，而且是三个月，只有一个月我还是要慎重考虑一下，三个月是非常值得的，再怎么说也可以提升你简历含金量。&lt;/p&gt;
&lt;h2 id=&quot;第三题&quot;&gt;第三题：&lt;/h2&gt;
&lt;p&gt;对于人生的决策来说，其实分为很多个，你很怕一个不小心选择了，就会产生蝴蝶效应。那么这篇就是为你准备的。&lt;br/&gt;看看这篇&lt;a href=&quot;https://www.zhihu.com/question/303357472/answer/537376328&quot;&gt;如何大幅度地提高决策能力&lt;/a&gt;首赞就是最好的回答。&lt;/p&gt;
</description>
<pubDate>Tue, 27 Nov 2018 14:31:00 +0000</pubDate>
<dc:creator>DarrenHu_吴邪</dc:creator>
<og:description>应届生秋招可能会遇到的三个问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DarrenHu/p/xiaozhao.html</dc:identifier>
</item>
<item>
<title>拖拽TreeViewItem到OCX控件 - Johar</title>
<link>http://www.cnblogs.com/Johar/p/10029328.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Johar/p/10029328.html</guid>
<description>&lt;p&gt;由于C#在性能方面，和C++还是有不少的差距，所以在项目中有一块是用C++的OCX控件实现，然后包括在WPF项目中。由于C++，C#属于不同的体系架构，造成了许多问题，特使是拖拽TreeViewItem到OCX控件上面，两者的渲染方式不同，OCX控件一直显示在最前面，所以拖拽的时候，看不见拖拽的AdornerLayer，并且鼠标还显示禁止状态。下面的内容主要是解决这两个问题的经历：&lt;/p&gt;
&lt;p&gt;1.解决拖拽TreeViewItem到OCX控件上面，鼠标是禁止状态。没有显示AdornerLayer，用户考虑到我们使用技术的原因，也还理解，只是这个禁止状态，用户接受不了，所以解决这个问题成为重中之重。&lt;/p&gt;
&lt;p&gt;（1）刚刚看到禁止图标，一眼就以为是AllowDrop没有设置为True，然后就把这个控件有这个属性的地方都设置了一遍，结果鼠标拖拽的时候移上去还是禁止状态。&lt;/p&gt;
&lt;p&gt;（2）依旧对AllowDrop属性不死心，让同事看OCX控件中有没有对应的属性，最终找到一个AcceptFile，虽然和AllowDrop不太一样，但是活马当死马医，只能要求同事生成ocx控件，给我试一把。最终结果还是不能解决问题。&lt;/p&gt;
&lt;p&gt;（3）在没有什么好的想法的时候，依旧对OCX的属性设置还抱有一点希望，到处问同事，搜google，bing，msdn，最终一上午都没有看到有用的信息，只能无奈放弃。&lt;/p&gt;
&lt;p&gt;（4）后面也没有什么好的方法，就在博客园，msdn上面提问，具体可以见&lt;a href=&quot;https://q.cnblogs.com/q/111134/&quot; target=&quot;_blank&quot;&gt;https://q.cnblogs.com/q/111134/&lt;/a&gt;，&lt;a href=&quot;https://social.msdn.microsoft.com/Forums/zh-CN/02959b72-a46c-4a27-bef5-cf8e246e8977/22312wpf200132530225341treeviewitem21040ocx2551120214200136529240736?forum=wpfzhchs#c8c87cb0-6ed5-492f-9f3e-1c40857db1f1&quot; target=&quot;_blank&quot;&gt;https://social.msdn.microsoft.com/Forums/zh-CN/02959b72-a46c-4a27-bef5-cf8e246e8977/22312wpf200132530225341treeviewitem21040ocx2551120214200136529240736?forum=wpfzhchs#c8c87cb0-6ed5-492f-9f3e-1c40857db1f1&lt;/a&gt;，然后根据msdn上面技术支持给的建议，参考&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/walkthrough-enabling-drag-and-drop-on-a-user-control&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/walkthrough-enabling-drag-and-drop-on-a-user-control&lt;/a&gt;中的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436823/201811/436823-20181127213233425-1217584525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在项目中的TreeView中，我也重写了该方法，强制将鼠标设置为箭头，结果启动程序试了一下，拖拽TreeViewItem到OCX控件上面，鼠标还是箭头，不是禁止状态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnGiveFeedback(GiveFeedbackEventArgs e)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnGiveFeedback(e);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;            Mouse.SetCursor(Cursors.Arrow);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             e.Handled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;           
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.解决拖拽项所在的AdornerLayer，被OCX控件遮挡的问题&lt;/p&gt;
&lt;p&gt;由于OCX是通过WindowsFormsHost的方式加到WPF程序中，两者的渲染机制不同，导致OCX控件显示在最前面，WPF中ZIndex也就英雄无用武之地。&lt;/p&gt;
&lt;p&gt;（1）考虑到窗口可以显示在OCX的前面，想过在鼠标进入OCX的时候，在鼠标下面添加一个窗口，跟随鼠标移动，这种想法是可行的，但是在OCX控件的Enter和Leave事件中都没有响应到拖拽过程中，鼠标的进入控件，离开控件的事件，导致这个没有向下执行下去。&lt;/p&gt;
&lt;p&gt;（2）后面还考虑直接将鼠标式样改成拖拽项的图标，也因此放弃了。&lt;/p&gt;
&lt;p&gt;（3）最后在拖拽的过程中，我发现拖拽到OCX控件的e.Effects == DragDropEffects.None，其他的WPF部分，可以直接在窗口上面将AllowDrop属性设置为True就行，因此可以根据这个区分拖拽是在WPF上面还是OCX上面，当在OCX上面的时候修改鼠标的式样。因为TreeViewItem是一张图片和其名称够成，平时设置鼠标式样的时候，是直接将图片设置为鼠标式样，看了一下Cursor里面的属性，没有发现可以设置文字的地方，只能先将字符串转化为图片，再将两张图片合并在一起。其中关键的代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Drawing;
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Runtime.InteropServices;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Input;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Interop;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ViewModels
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CursorHelper
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Cursor CreateBitmapCursor(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; filePath)
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;             Bitmap bmp = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;                 bmp = Bitmap.FromFile(filePath) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Bitmap;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (bmp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; BitmapCursor.CreateBmpCursor(bmp);
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; 
&lt;span&gt; 22&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Cursors.Arrow;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Cursors.Arrow;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Cursor CreateBitmapCursor(&lt;span&gt;string&lt;/span&gt; filePath, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;             Bitmap bmp = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;                 bmp = Bitmap.FromFile(filePath) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Bitmap;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (bmp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; nameBmp =&lt;span&gt; StringToImg(name);
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; mergeBmp =&lt;span&gt; CombinImage(bmp, nameBmp);
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (mergeBmp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; BitmapCursor.CreateBmpCursor(mergeBmp);
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Cursors.Arrow;
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Cursors.Arrow;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Bitmap StringToImg(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;             Graphics g = Graphics.FromImage(&lt;span&gt;new&lt;/span&gt; Bitmap(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             Font font = &lt;span&gt;new&lt;/span&gt; Font(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宋体&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;             SizeF sizeF = g.MeasureString(name, font); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测量出字体的高度和宽度&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt;             Brush brush =&lt;span&gt; Brushes.White;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;             PointF pf = &lt;span&gt;new&lt;/span&gt; PointF(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;             Bitmap img = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bitmap(Convert.ToInt32(sizeF.Width), Convert.ToInt32(sizeF.Height));
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;             g =&lt;span&gt; Graphics.FromImage(img);
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;            g.DrawString(name, font, brush, pf);
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; img;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Bitmap CombinImage(Image icoImg, Image stringImg)
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; height =&lt;span&gt; Math.Max(icoImg.Height, stringImg.Height);
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;             Bitmap bmp = &lt;span&gt;new&lt;/span&gt; Bitmap(icoImg.Width + stringImg.Width + &lt;span&gt;6&lt;/span&gt;&lt;span&gt;, height);
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;             Graphics g =&lt;span&gt; Graphics.FromImage(bmp);
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;             g.Clear(Color.FromArgb(&lt;span&gt;150&lt;/span&gt;, &lt;span&gt;201&lt;/span&gt;, &lt;span&gt;252&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;             g.DrawImage(icoImg, &lt;span&gt;0&lt;/span&gt;, (height - icoImg.Height) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;, icoImg.Width, icoImg.Height);
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;             g.DrawImage(stringImg, icoImg.Width + &lt;span&gt;6&lt;/span&gt;, (height - stringImg.Height) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;, stringImg.Width, stringImg.Height);            
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bmp;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Cursor GetCursor(FASTreeViewItemViewModel data)
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (data.NodeType ==&lt;span&gt; NodeType.Camera)
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (data.DeviceType ==&lt;span&gt; DeviceType.Normal)
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (data.State ==&lt;span&gt; TreeItemState.OnLine)
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; CreateBitmapCursor(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;{0}Device_IPC_on.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, AppViewModel.Instance.BaseDirectory), data.DisplayName);
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.State ==&lt;span&gt; TreeItemState.OffLine)
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; CreateBitmapCursor(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;{0}Device_IPC_off.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, AppViewModel.Instance.BaseDirectory), data.DisplayName);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.DeviceType ==&lt;span&gt; DeviceType.PTZ)
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (data.State ==&lt;span&gt; TreeItemState.OnLine)
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; CreateBitmapCursor(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;{0}Device_ptzIPC_on.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, AppViewModel.Instance.BaseDirectory), data.DisplayName);
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.State ==&lt;span&gt; TreeItemState.OffLine)
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; CreateBitmapCursor(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;{0}Device_ptzIPC_off.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, AppViewModel.Instance.BaseDirectory), data.DisplayName);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.NodeType ==&lt;span&gt; NodeType.PollingGroup)
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (data.State ==&lt;span&gt; TreeItemState.Normal)
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; CreateBitmapCursor(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;{0}Device_patrol.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, AppViewModel.Instance.BaseDirectory), data.DisplayName);
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.State ==&lt;span&gt; TreeItemState.Running)
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; CreateBitmapCursor(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;{0}Device_patrol_play.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, AppViewModel.Instance.BaseDirectory), data.DisplayName);
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; 
&lt;span&gt;120&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Cursors.Arrow;
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; 
&lt;span&gt;124&lt;/span&gt;     &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BitmapCursor : SafeHandle
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; IsInvalid
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt;
&lt;span&gt;129&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; handle == (IntPtr)(-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; 
&lt;span&gt;134&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Cursor CreateBmpCursor(Bitmap cursorBitmap)
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;             BitmapCursor c = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BitmapCursor(cursorBitmap);
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; CursorInteropHelper.Create(c);
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; 
&lt;span&gt;140&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; BitmapCursor(Bitmap cursorBitmap)
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;             : &lt;span&gt;base&lt;/span&gt;((IntPtr)(-&lt;span&gt;1&lt;/span&gt;), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;             handle =&lt;span&gt; cursorBitmap.GetHicon();
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; 
&lt;span&gt;146&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; ReleaseHandle()
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;             &lt;span&gt;bool&lt;/span&gt; result =&lt;span&gt; DestroyIcon(handle);
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; 
&lt;span&gt;150&lt;/span&gt;             handle = (IntPtr)(-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; 
&lt;span&gt;152&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; 
&lt;span&gt;155&lt;/span&gt;         [DllImport(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user32&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; DestroyIcon(IntPtr hIcon);
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnGiveFeedback(GiveFeedbackEventArgs e)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnGiveFeedback(e);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (e.Effects.HasFlag(DragDropEffects.Move))
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                Mouse.SetCursor(Cursors.Arrow);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; dataItem = &lt;span&gt;this&lt;/span&gt;.SelectedItem &lt;span&gt;as&lt;/span&gt;&lt;span&gt; TreeViewItemViewModelBase;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (dataItem != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    Mouse.SetCursor(dataItem.GetCurrentCursor());
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;             e.Handled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过这两种方式，就解决上述的两个问题，可以满足项目的要求。&lt;/p&gt;

</description>
<pubDate>Tue, 27 Nov 2018 13:58:00 +0000</pubDate>
<dc:creator>Johar</dc:creator>
<og:description>由于C#在性能方面，和C++还是有不少的差距，所以在项目中有一块是用C++的OCX控件实现，然后包括在WPF项目中。由于C++，C#属于不同的体系架构，造成了许多问题，特使是拖拽TreeViewIte</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Johar/p/10029328.html</dc:identifier>
</item>
<item>
<title>Android ION内存分配 - willhua</title>
<link>http://www.cnblogs.com/willhua/p/10029280.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willhua/p/10029280.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://lwn.net/Articles/480055/&quot;&gt;英文原文&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;ion-heaps&quot;&gt;ION heaps&lt;/h3&gt;
&lt;h4 id=&quot;ion设计的目标&quot;&gt;ION设计的目标&lt;/h4&gt;
&lt;p&gt;为了避免内存碎片化，或者为一些有着特殊内存需求的硬件，比如GPUs、display controller以及camera等，在系统启动的时候，会为他们预留一些memory pools，这些memory pools就由&lt;strong&gt;ION&lt;/strong&gt;来管理。通过&lt;strong&gt;ION&lt;/strong&gt;就可以在硬件以及user space之间实现&lt;strong&gt;zero-copy&lt;/strong&gt;的内存share。&lt;/p&gt;
&lt;h4 id=&quot;ion的实现&quot;&gt;ION的实现&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;ION&lt;/strong&gt;通过&lt;strong&gt;ION heaps&lt;/strong&gt;来展示presents它对应的memory pools。不同的Android硬件可能会要求不同的&lt;strong&gt;ION heaps&lt;/strong&gt;实现，默认的&lt;strong&gt;ION&lt;/strong&gt;驱动会提供如下三种不同的&lt;strong&gt;ION heaps&lt;/strong&gt;实现：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ION_HEAP_TYPE_SYSTEM: memory allocated via vmalloc_user()&lt;/li&gt;
&lt;li&gt;ION_HEAP_TYPE_SYSTEM_CONTIG: memory allocated via kzalloc&lt;br/&gt;. ION_HEAP_TYPE_CARVEOUT: carveout memory is physically contiguous and set aside at boot.&lt;br/&gt;开发者可以自己实现更多的&lt;strong&gt;ION heaps&lt;/strong&gt;。比如&lt;strong&gt;NVIDIA&lt;/strong&gt;就提交了一种&lt;strong&gt;ION_HEAP_TYPE_IOMMU&lt;/strong&gt;的heap，这种heap带有&lt;strong&gt;IOMMU&lt;/strong&gt;功能。&lt;br/&gt;不管哪一种&lt;strong&gt;ION heaps&lt;/strong&gt;实现，他们都必须实现如下接口：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;   struct ion_heap_ops {
    int (*allocate) (struct ion_heap *heap,
             struct ion_buffer *buffer, unsigned long len,
             unsigned long align, unsigned long flags);
    void (*free) (struct ion_buffer *buffer);
    int (*phys) (struct ion_heap *heap, struct ion_buffer *buffer,
             ion_phys_addr_t *addr, size_t *len);
    struct scatterlist *(*map_dma) (struct ion_heap *heap,
             struct ion_buffer *buffer);
    void (*unmap_dma) (struct ion_heap *heap, 
             struct ion_buffer *buffer);
    void * (*map_kernel) (struct ion_heap *heap, 
             struct ion_buffer *buffer);
    void (*unmap_kernel) (struct ion_heap *heap, 
             struct ion_buffer *buffer);
    int (*map_user) (struct ion_heap *heap, struct ion_buffer *buffer,
             struct vm_area_struct *vma);
   };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单来说，接口的各个函数功能如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;allocate()&lt;/code&gt;和&lt;code&gt;free()&lt;/code&gt;分别用来从heap中&lt;strong&gt;分配&lt;/strong&gt;或者&lt;strong&gt;释放&lt;/strong&gt;一个&lt;code&gt;ion_buffer&lt;/code&gt;对象&lt;/li&gt;
&lt;li&gt;对于物理连续的内存，&lt;code&gt;phys()&lt;/code&gt;用来得到&lt;code&gt;ion_buffer&lt;/code&gt;对象的&lt;strong&gt;物理内存地址&lt;/strong&gt;及其&lt;strong&gt;大小&lt;/strong&gt;。如果heap没有提供物理连续的内存，那么它也可以不用提供这个接口。其中，&lt;code&gt;ion_phys_addr_t&lt;/code&gt;将来会被定义在&lt;em&gt;/include/linux/types.h&lt;/em&gt;中的&lt;code&gt;phys_addr_t&lt;/code&gt;替代。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;map_dma()&lt;/code&gt;和&lt;code&gt;unmap_dma()&lt;/code&gt;分别来用使&lt;code&gt;ion_buffer&lt;/code&gt;对象为&lt;a href=&quot;https://blog.csdn.net/kris_fei/article/details/72628692&quot;&gt;DMA（Direct Memory Access，直接内存存取。顾名思义，不占用cpu资源，从一个硬件存储区域把一部分连续的数据复制到另一个硬件存储区域）&lt;/a&gt;做好准备或者取消做好准备&lt;/li&gt;
&lt;li&gt;&lt;code&gt;map_kernel()&lt;/code&gt;和&lt;code&gt;unmap_kernel()&lt;/code&gt;分别用来把physical memory映射(map)到内核虚拟地址空间(kernel virtual address space)或者取消映射&lt;/li&gt;
&lt;li&gt;&lt;code&gt;map_user()&lt;/code&gt;用来把physical memory映射(map)到用户内存空间(user space)。为什么没有对应的&lt;code&gt;unmap_user()&lt;/code&gt;呢？因为，这个映射用一个file descriptor来表示，当这个file descriptor关闭的时候，这个映射关系就自动取消了。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;在user-space使用ion&quot;&gt;在user space使用ION&lt;/h3&gt;
&lt;h4 id=&quot;使用场景&quot;&gt;使用场景&lt;/h4&gt;
&lt;p&gt;典型的，在用户空间使用的设备访问库(user space device access libraries)一般使用&lt;strong&gt;ION&lt;/strong&gt;来分配大块连续的media buffers。比如，still camera library分配一个capture buffer来供camera device使用。当这个buffer填满video data的时候，这个library就能把这块buffer传递给kernel，然后让JPEG硬编码模块来处理。&lt;/p&gt;
&lt;h4 id=&quot;具体使用细节&quot;&gt;具体使用细节&lt;/h4&gt;
&lt;p&gt;在user space 的C/C++程序能够能够分配&lt;strong&gt;ION&lt;/strong&gt;内存之前，它必须获得访问&lt;code&gt;/dev/ion&lt;/code&gt;的权限。通过调用&lt;code&gt;open(&quot;/dev/ion&quot;, O_RDONLY)&lt;/code&gt;就可获得一个以handle形式返回的file descriptor，这个file descriptor用来代表一个&lt;strong&gt;ION client&lt;/strong&gt;。注意，虽然传给&lt;code&gt;open&lt;/code&gt;一个&lt;code&gt;O_RDONLY&lt;/code&gt;参数，但是你仍然可对这块memory进行写操作。在一个user process中最多有一个client。当有了一个client之后，就可以开始分配&lt;strong&gt;ION&lt;/strong&gt;内存。为了分配内存，client必须填满下面的&lt;code&gt;ion_allocation_data&lt;/code&gt;结构，&lt;code&gt;handle&lt;/code&gt;除外，因为它是output参数。其他三个参数分别指明内存的大小、对齐方式以及flags。flags是一个bit mask，用来说明可以从哪些heaps中分配想要的内存。其决定顺序由系统启动时，通过&lt;code&gt;ion_device_add_heap()&lt;/code&gt;添加的heap顺来决定。比如，ION_HEAP_TYPE_CARVEOUT是在ION_HEAP_TYPE_CONTIG之前被add的，那么如果&lt;code&gt;flags = ION_HEAP_TYPE_CONTIG | ION_HEAP_TYPE_CARVEOUT&lt;/code&gt;，那么就是先尝试分配ION_HEAP_TYPE_CARVEOUT类型的heap，如果不行，再尝试分配ION_HEAP_TYPE_CONTIG类型的heap。（）&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;   struct ion_allocation_data {
        size_t len;
        size_t align;
        unsigned int flags;
        struct ion_handle *handle;
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;user space通过&lt;code&gt;ioctl()&lt;/code&gt;系统接口来与&lt;strong&gt;ION&lt;/strong&gt;交互。在client填充&lt;code&gt;ion_allocatoin_data&lt;/code&gt;结构之后，就可以通过调用&lt;code&gt;int ioctl(int client_fd, ION_IOC_ALLOC, struct ion_allocation_data *allocation_data)&lt;/code&gt;来allocate a buffer。这个调用介绍之后，分配的buffer会通过&lt;code&gt;ion_allocatoin_data&lt;/code&gt;的&lt;code&gt;handle&lt;/code&gt;来返回，但是CPU不可以访问这个buffer。这个&lt;code&gt;handle&lt;/code&gt;只可以通过调用&lt;code&gt;int ioctl(int client_fd, ION_IOC_SHARE, struct ion_fd_data *fd_data);&lt;/code&gt;来获得一个用来share的file descriptor。这里，&lt;code&gt;client_fd&lt;/code&gt;参数是前面通过&lt;code&gt;open&lt;/code&gt;获得的一个对应&lt;code&gt;/dev/ion&lt;/code&gt; file descriptor，&lt;code&gt;fd_data&lt;/code&gt;是如下的数据结构，其&lt;code&gt;handle&lt;/code&gt;对应&lt;code&gt;ion_allocation_data::handle&lt;/code&gt;，是input参数；&lt;code&gt;fd&lt;/code&gt;则是output参数，可以用来share。&lt;br/&gt;当一个user process中的client分享(share)了这个&lt;code&gt;fd&lt;/code&gt;之后，在其他user process中(当然，也可share给创建这个&lt;code&gt;fd&lt;/code&gt;的client自己)，为了获得这个shared buffer，先必须通过调用&lt;code&gt;open(&quot;/dev/ion&quot;, O_RDONLY)&lt;/code&gt;获得一个client。(注：&lt;strong&gt;ION&lt;/strong&gt;通过线程的PID来track各个client， 尤其是process中的&quot;group leader&quot;线程的PID。在相同的process中重复调用&lt;code&gt;open(&quot;/dev/ion&quot;, O_RDONLY)&lt;/code&gt;只会获得指向kernel同一个client的another file descriptor)。获得client之后，然后再通过&lt;code&gt;mmap()&lt;/code&gt;函数来把这个&lt;code&gt;fd&lt;/code&gt;映射到address space of process(&lt;a href=&quot;http://man7.org/linux/man-pages/man2/mmap.2.html&quot;&gt;mmap函数参考1&lt;/a&gt;，&lt;a href=&quot;http://www.cnblogs.com/xmphoenix/archive/2011/08/20/2146938.html&quot;&gt;参考2&lt;/a&gt;)。如果要释放这个&lt;code&gt;fd&lt;/code&gt;对应的buffer，在调用&lt;code&gt;mmap()&lt;/code&gt;的process中，先要通过&lt;code&gt;munmap()&lt;/code&gt;来取消&lt;code&gt;mmap()&lt;/code&gt;的效果。然后在之前share这个&lt;code&gt;fd&lt;/code&gt;的client中，需要通过&lt;code&gt;int ioctl(int client_fd, ION_IOC_FREE, struct ion_handle_data *handle_data);&lt;/code&gt;来关闭这个&lt;code&gt;fd&lt;/code&gt;对应的file descriptor。其中，&lt;code&gt;ion_handle_data&lt;/code&gt;表示前面通过&lt;code&gt;ION_IOC_ALLOC&lt;/code&gt;命令获得的&lt;code&gt;handle&lt;/code&gt;，其定义如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;     struct ion_handle_data {
         struct ion_handle *handle;
     }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个&lt;code&gt;ION_IOC_FREE&lt;/code&gt;命令会导致对应的&lt;code&gt;handle&lt;/code&gt;的计数减1。当&lt;code&gt;handle&lt;/code&gt;计数为0的时候，其指向的&lt;code&gt;ion_handle&lt;/code&gt;对象就会被销毁，并且相关的&lt;strong&gt;ION bookkeeping&lt;/strong&gt;数据结构也会更新。&lt;/p&gt;
&lt;h5 id=&quot;demo&quot;&gt;Demo&lt;/h5&gt;
&lt;p&gt;在这个Demo中，&lt;code&gt;fd&lt;/code&gt;在同一个client中被share使用：&lt;a href=&quot;http://devarea.com/android-ion/#.W_lnfOgzaH8&quot;&gt;来源&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;

#include &quot;/home/developer/kernel3.4/goldfish/include/linux/ion.h&quot;

void main()
{
    struct ion_fd_data fd_data;
    struct ion_allocation_data ionAllocData;
    ionAllocData.len=0x1000;
    ionAllocData.align = 0;
    ionAllocData.flags = ION_HEAP_TYPE_SYSTEM;

    int fd=open(&quot;/dev/ion&quot;,O_RDWR);
    ioctl(fd,ION_IOC_ALLOC, &amp;amp;ionAllocData);
    fd_data.handle = ionAllocData.handle;
    ioctl(fd,ION_IOC_SHARE,&amp;amp;fd_data); 
    int *p = mmap(0,0x1000,PROT_READ|PROT_WRITE,MAP_SHARED,fd_data.fd,0);
    p[0]=99;
    perror(&quot;test&quot;);
    printf(&quot;hello all %d\n&quot;,p[0]);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;在kernel中share-ion-buffer&quot;&gt;在kernel中share ION buffer&lt;/h3&gt;
&lt;p&gt;在kernel中支持multiple clients，每一个使用&lt;strong&gt;ION&lt;/strong&gt;功能的driver都可以在kernel中对应一个client。一个kernel driver通过调用&lt;code&gt;struct ion_client *ion_client_create(struct ion_device *dev, unsigned int heap_mask, const char *debug_name)&lt;/code&gt;来获得一个&lt;strong&gt;ION&lt;/strong&gt; client handle（注意，前面在user space中通过&lt;code&gt;open(&quot;/dev/ion&quot;, O_RDONLY)&lt;/code&gt;返回的client是&lt;code&gt;int&lt;/code&gt;类型）。&lt;code&gt;dev&lt;/code&gt;参数是一个和&lt;code&gt;/dev/ion&lt;/code&gt;相关的&lt;strong&gt;global ION device&lt;/strong&gt;，&lt;code&gt;heap_mask&lt;/code&gt;参数和之前提到的&lt;code&gt;ion_allocation_data&lt;/code&gt;的&lt;code&gt;flags&lt;/code&gt;成员一样的含义。&lt;br/&gt;当在user space中通过&lt;code&gt;ION_IOC_SHARE&lt;/code&gt;命令得到一个buffer的file descriptor并把它传递给kernel之后，kernel driver通过调用&lt;code&gt;struct ion_handle *ion_import_fd(struct ion_client *client, int fd_from_user);&lt;/code&gt;来把这个fd变成一个&lt;code&gt;ion_handle&lt;/code&gt;对象，这个对象就是这个driver中对相应的buffer一个client-local reference。&lt;code&gt;ion_import_fd&lt;/code&gt;方法会根据这个buffer的物理地址来查找：在本client中是否已经obtained一个对应此buffer的&lt;code&gt;ion_handle&lt;/code&gt;，如果是的话，那么就可以简单的增加这个&lt;code&gt;ion_handle&lt;/code&gt;的引用计数即可。&lt;br/&gt;有些硬件只能通过physical addresses来操作physically-contiguous buffers，那么，这些对应的drivers就需要通过调用&lt;code&gt;int ion_phys(struct ion_client *client, struct ion_handle *handle, ion_phys_addr_t *addr, size_t *len)&lt;/code&gt;来把&lt;code&gt;ion_handle&lt;/code&gt;转变成一个physical buffer。当然，如果这个buffer不是physically contiguous，那么这个调用就会失败。&lt;br/&gt;当处理一个来自client的调用时，&lt;strong&gt;ION&lt;/strong&gt;会validates 输入的 file descriptor, client and handle arguments。比如&lt;strong&gt;ION&lt;/strong&gt;会确保 file descriptor是由&lt;code&gt;ION_IOC_SHARE&lt;/code&gt;命令创建的；比如当&lt;code&gt;ion_phys()&lt;/code&gt;调用时，&lt;strong&gt;ION&lt;/strong&gt;会检测这个buffer是否在这个client对应有访问权限list中，如果不是，那么就会返回错误。这样的验证机制能够减少可能的unwanted accesses以及疏忽的内存泄露。&lt;br/&gt;&lt;strong&gt;ION&lt;/strong&gt;通过debugfs提供可视化的debug，它通过在/sys/kernel/debug/ion下面，使用stored files来记录相应的heaps和clients，并使用symbolic names或者PIDs来标志。&lt;/p&gt;
&lt;h3 id=&quot;比较ion和dmabuf&quot;&gt;比较ION和DMABUF&lt;/h3&gt;
&lt;p&gt;本节部分翻译。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ION&lt;/strong&gt;和&lt;strong&gt;DMABUF&lt;/strong&gt;都是通过传递一个匿名file descriptor对象，给其他client一个基于引用计数的访问权限，从而达到分享内存的目的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ION&lt;/strong&gt;通过一个可分享和追踪的方式从预留的memory pool中分配内存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DMABUF&lt;/strong&gt;更多的专注于buffer导入、导出以及同步的方式来实现在&lt;strong&gt;NON-ARM&lt;/strong&gt;架构上的buffer的分享。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ION&lt;/strong&gt;目前&lt;strong&gt;只支持Android kernel&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ION&lt;/strong&gt;所有的user-space program都可以通过&lt;em&gt;/dev/ion&lt;/em&gt;接口来分配&lt;strong&gt;ION&lt;/strong&gt;内存。但是在Android会通过验证user和group IDs的方式来阻止对&lt;strong&gt;ION&lt;/strong&gt;的非授权访问。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://lwn.net/Articles/480055/&quot;&gt;The Android ION memory allocator&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://web.cse.ohio-state.edu/~xuan.3/courses/694/Memory-Management.pdf&quot;&gt;Good PDF&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://lwn.net/Articles/565469/&quot;&gt;Integrating the ION memory allocator&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://android.googlesource.com/platform/system/core/+/master/libion/ion.c&quot;&gt;ION.C&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://android.googlesource.com/platform/system/core/+/master/libion/original-kernel-headers/linux/ion.h&quot;&gt;ION.H&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://devarea.com/android-ion/#.W_qMsegzaH9&quot;&gt;DEMO&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/jacky_perf/article/details/51992664&quot;&gt;CSDN&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 27 Nov 2018 13:50:00 +0000</pubDate>
<dc:creator>willhua</dc:creator>
<og:description>The Android ION memory allocator</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/willhua/p/10029280.html</dc:identifier>
</item>
<item>
<title>Spring源码-循环依赖源码解读 - 程序员自我修养张振力</title>
<link>http://www.cnblogs.com/java-zzl/p/10025609.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/java-zzl/p/10025609.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;Spring源码-循环依赖源码解读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;　　笔者最近无论是看书还是从网上找资料，都没发现对Spring源码是怎么解决循环依赖这一问题的详解，大家都是解释了Spring解决循环依赖的想法（有的解释也不准确，在《Spring源码深度解析》作者也是看别人的博客说明了一下），没有从源码的角度分析是怎么解决循环依赖的，笔者就把自己看源码的过程写一下。&lt;/p&gt;
&lt;p&gt;Spring中对象可以配置成单例模式也可配置为原型模式（原型模式很值得一看）。&lt;br/&gt;Spring中可以通过构造函数注入、setter注入的方式来解决对象与对象间的依赖。&lt;br/&gt;对象间的循环依赖只能配置单例、setter注入的方式来解决，其他方法就会报错，下面我们通过源码分析一下。&lt;/p&gt;
&lt;h3&gt;一、单例、setter注入解决循环依赖&lt;/h3&gt;
&lt;p&gt;假如有TestA、TestB、TestC三个对象，其中TestA依赖TestB，TestB依赖TestC，TestC依赖TestA。&lt;/p&gt;
&lt;p&gt;下面具体通过代码分析Spring是如何解决单例通过Setter注入的循环依赖。&lt;br/&gt;在org.springframework.beans.factory.support.DefaultSingletonBeanRegistry类中有几个集合类型的成员变量，用来做缓存用的需要特别留意，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefaultSingletonBeanRegistry &lt;span&gt;extends&lt;/span&gt; SimpleAliasRegistry &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; SingletonBeanRegistry {
        ......
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; singletonObjects = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap(256&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, ObjectFactory&amp;lt;?&amp;gt;&amp;gt; singletonFactories = &lt;span&gt;new&lt;/span&gt; HashMap(16&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; earlySingletonObjects = &lt;span&gt;new&lt;/span&gt; HashMap(16&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Set&amp;lt;String&amp;gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(&lt;span&gt;new&lt;/span&gt; ConcurrentHashMap(16&lt;span&gt;));
    ......
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码中：&lt;br/&gt;&lt;strong&gt;&lt;span&gt;singletonsCurrentlyInCreation&lt;/span&gt;&lt;/strong&gt;：保存对象的BeanName，在创建对象之前就会把对象的beanName保存起来。&lt;br/&gt;&lt;strong&gt;&lt;span&gt;singletonFactories&lt;/span&gt;&lt;/strong&gt;：保存对象的BeanName和创建bean的工厂AbstractAutowireCapableBeanFactory(ObjectFactory)，（对象的构造函数是在这一步完成的）&lt;br/&gt;&lt;strong&gt;&lt;span&gt;earlySingletonObjects&lt;/span&gt;&lt;/strong&gt;：保存对象BeanName和ObjectFactory#getObject的对象（TestA），（TestA还没setter注入），此时可以作为对象填充依赖。&lt;br/&gt;&lt;strong&gt;&lt;span&gt;singletonObjects&lt;/span&gt;&lt;/strong&gt;：保存BeanName和bean的实例（此时对象已经完成了setter注入）&lt;/p&gt;
&lt;p&gt;通过Spring获取testA对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;通过Spring获取testA对象
ApplicationContext factory&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;classpath:applicationContext-beans.xml&quot;&lt;span&gt;);
TestA testA &lt;/span&gt;= (TestA) factory.getBean(&quot;testA&quot;&lt;span&gt;);
System.out.println(testA);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;factory.getBean最终调用的是org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean&lt;/p&gt;
&lt;p&gt;下面看doGetBean源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &amp;lt;T&amp;gt; T doGetBean(String name, Class&amp;lt;T&amp;gt; requiredType, &lt;span&gt;final&lt;/span&gt; Object[] args, &lt;span&gt;boolean&lt;/span&gt; typeCheckOnly) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
  ......
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点1&lt;/span&gt;
  Object sharedInstance = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getSingleton(beanName);
  
  ......
  
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mbd.isSingleton()) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点2&lt;/span&gt;
        sharedInstance = getSingleton(beanName, &lt;span&gt;new&lt;/span&gt; ObjectFactory&amp;lt;Object&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object getObject() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点3&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; createBean(beanName, mbd, args);
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeansException ex) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Explicitly remove instance from singleton cache: It might have been put there
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; eagerly by the creation process, to allow for circular reference resolution.
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Also remove any beans that received a temporary reference to the bean.&lt;/span&gt;
&lt;span&gt;                    destroySingleton(beanName);
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
                }
            }
        });
        bean &lt;/span&gt;=&lt;span&gt; getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面源码中：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、重点1：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　//重点1 根据beanName试图从缓存中获取已经创建的对象，第一次进入是肯定返回null，这个函数放在后面解释。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、重点2：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在//重点2中才是真正创建TestA对象的方法，下面是//重点2 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton的源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点2&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; Object getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt;&lt;span&gt; singletonFactory) {
    
    Object singletonObject &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonObjects.get(beanName);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singletonObject == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        ......
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点2-1&lt;/span&gt;
&lt;span&gt;        beforeSingletonCreation(beanName);
        ......
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点2-2&lt;/span&gt;
            singletonObject =&lt;span&gt; singletonFactory.getObject();
            newSingleton &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalStateException ex) {
            ......
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeanCreationException ex) {
            ......
        }
        &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点2-3&lt;/span&gt;
&lt;span&gt;            afterSingletonCreation(beanName);
        }
    
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在//重点2-1中beforeSingletonCreation方法中只做了一件事，就是保存beanName到&lt;strong&gt;&lt;span&gt;singletonsCurrentlyInCreation&lt;/span&gt;&lt;/strong&gt;（注意），这个时候testA就保存在&lt;strong&gt;&lt;span&gt;singletonsCurrentlyInCreation&lt;/span&gt;&lt;/strong&gt;里面了，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点2-1&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; beforeSingletonCreation(String beanName) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this.singletonsCurrentlyInCreation.add(beanName)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.inCreationCheckExclusions.contains(beanName) &amp;amp;&amp;amp; !&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonsCurrentlyInCreation.add(beanName)) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanCurrentlyInCreationException(beanName);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在 //重点2-2 会调用 //重点3 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、重点3：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在//重点3中org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean调用doCreateBean，doCreateBean方法源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; Object doCreateBean(&lt;span&gt;final&lt;/span&gt; String beanName, &lt;span&gt;final&lt;/span&gt; RootBeanDefinition mbd, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Object[] args) {
    ......
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点3-1&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.allowCircularReferences &amp;amp;&amp;amp;&lt;span&gt; isSingletonCurrentlyInCreation(beanName));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (earlySingletonExposure) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
            logger.debug(&lt;/span&gt;&quot;Eagerly caching bean '&quot; + beanName +
                    &quot;' to allow for resolving potential circular references&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点3-2&lt;/span&gt;
        addSingletonFactory(beanName, &lt;span&gt;new&lt;/span&gt; ObjectFactory&amp;lt;Object&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object getObject() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点3-3&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getEarlyBeanReference(beanName, mbd, bean);
            }
        });
    }
    ......
  &lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在//重点3-1判断testA必须是单例，并存在在&lt;strong&gt;&lt;span&gt;singletonsCurrentlyInCreation&lt;/span&gt;&lt;/strong&gt;中，此时才会调用//重点3-2的addSingletonFactory方法，//重点3-2的addSingletonFactory方法源码，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点3-2&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addSingletonFactory(String beanName, ObjectFactory&amp;lt;?&amp;gt;&lt;span&gt; singletonFactory) {
    Assert.notNull(singletonFactory, &lt;/span&gt;&quot;Singleton factory must not be null&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonObjects) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonObjects.containsKey(beanName)) {
        
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点3-2-1&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonFactories.put(beanName, singletonFactory);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.earlySingletonObjects.remove(beanName);
            
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registeredSingletons.add(beanName);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在上面的代码中有一个singletonFactory的参数，这个参数是//重点3-3调用getEarlyBeanReference得到的，getEarlyBeanReference返回的就是ObjectFactory对象，是完成构造方法的。&lt;/p&gt;
&lt;p&gt;　　在//重点3-2-1 向&lt;strong&gt;&lt;span&gt;singletonFactories&lt;/span&gt;&lt;/strong&gt;添加 ObjectFactory（注意），这个时候，testA和testA的ObjectFactory对象保存在singletonFactories，并移除&lt;strong&gt;&lt;span&gt;earlySingletonObjects&lt;/span&gt;&lt;/strong&gt;（现在&lt;strong&gt;&lt;span&gt;earlySingletonObjects&lt;/span&gt;&lt;/strong&gt;里面并没有testA）。&lt;/p&gt;
&lt;p&gt;　　执行完//重点3-2,发现testA依赖TestB对象，此时会递归调用getBean获取TestB，testB执行步骤和上面testA一样，然后testB依赖TestC，递归调用TestC，此时&lt;strong&gt;&lt;span&gt;singletonFactories&lt;/span&gt;&lt;/strong&gt;里面保存的数据如下：&lt;br/&gt;　　testA -&amp;gt; ObjectFactory(TestA)&lt;br/&gt;　　testB -&amp;gt; ObjectFactory(TestB)&lt;br/&gt;　　testC -&amp;gt; ObjectFactory(TestC)&lt;/p&gt;
&lt;p&gt;　　创建testC过程中执行完//重点3-2，发现依赖testA，此时会递归调用getBean获取TestA，这时候执行到//重点1，下面开始解析//重点1 Object sharedInstance = getSingleton(beanName);方法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、重点1：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　下面是调用//重点1 getSingleton(beanName)，调用getSingleton(beanName, true)的源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点1&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt; Object getSingleton(String beanName, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; allowEarlyReference) {
    Object singletonObject &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonObjects.get(beanName);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singletonObject == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; isSingletonCurrentlyInCreation(beanName)) {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonObjects) {
            singletonObject &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.earlySingletonObjects.get(beanName);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singletonObject == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; allowEarlyReference) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点1-1&lt;/span&gt;
                ObjectFactory&amp;lt;?&amp;gt; singletonFactory = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonFactories.get(beanName);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singletonFactory != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点1-2&lt;/span&gt;
                    singletonObject =&lt;span&gt; singletonFactory.getObject();
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.earlySingletonObjects.put(beanName, singletonObject);
                    
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonFactories.remove(beanName);
                }
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (singletonObject != NULL_OBJECT ? singletonObject : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在上面代码中isSingletonCurrentlyInCreation就是判断对象（testA）是否被保存过（在//重点2-1的时候testA就被保存了）&lt;/p&gt;
&lt;p&gt;　　在//重点1-1中，从&lt;strong&gt;&lt;span&gt;singletonFactories&lt;/span&gt;&lt;/strong&gt;缓存中获取到ObjectFactory(TestA)，&lt;/p&gt;
&lt;p&gt;　　在//重点1-2并通过模板模式获取TestA对象，保存在&lt;strong&gt;&lt;span&gt;earlySingletonObjects&lt;/span&gt;&lt;/strong&gt;缓存中，并移除&lt;strong&gt;&lt;span&gt;singletonFactories&lt;/span&gt;&lt;/strong&gt;中的testA，&lt;/p&gt;
&lt;p&gt;　　此时testC获取到TestA的早期对象，可以注入TestA对象，自此TestC完成依赖注入，并把testC保存到&lt;strong&gt;&lt;span&gt;singletonObjects&lt;/span&gt;&lt;/strong&gt;中。&lt;/p&gt;
&lt;p&gt;　　TestC创建完成，返回给testB，testB也算是完成了创建，然后返回给testA，自此循环依赖算是完成了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　单例的setter注入，会先把创建testA、testB、testC对象的ObjectFactory（对象工厂）保存在&lt;strong&gt;&lt;span&gt;singletonFactories&lt;/span&gt;&lt;/strong&gt;里面，然后testC依赖testA，那就从&lt;strong&gt;&lt;span&gt;singletonFactories&lt;/span&gt;&lt;/strong&gt;缓存中拿到testA的ObjectFactory，通过ObjectFactory的getObject获取TestA的对象，并保存在&lt;strong&gt;&lt;span&gt;earlySingletonObjects&lt;/span&gt;&lt;/strong&gt;缓存中，清除&lt;strong&gt;&lt;span&gt;singletonFactories&lt;/span&gt;&lt;/strong&gt;缓存中的testA，此时testC就可以获取&lt;strong&gt;&lt;span&gt;earlySingletonObjects&lt;/span&gt;&lt;/strong&gt;缓存中TestA的对象，完成注入TestA的过程。TestC对象创建完成就可以注入到TestB对象中，然后TestB注入到TestA中。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;singletonsCurrentlyInCreation&lt;/span&gt;&lt;/strong&gt;就是用来保存是否试图创建某个对象的beanName，不管有没有创建成功，为后来从&lt;strong&gt;&lt;span&gt;singletonFactories&lt;/span&gt;&lt;/strong&gt;缓存中或earlySingletonObjects缓存中取值做个标识。&lt;/p&gt;
&lt;h3&gt;二、单利、构造函数注入循环依赖&lt;/h3&gt;
&lt;p&gt; 　　假如有TestA、TestB两个对象，TestA依赖TestB，TestB依赖TestA；&lt;/p&gt;
&lt;p&gt;　　构造函数注入和setter注入的不同在于，构造函数注入无法先调用构造函数实例化对象，当TestA依赖TestB，会先把testA保存到&lt;span&gt;&lt;strong&gt;singletonsCurrentlyInCreation&lt;/strong&gt;&lt;/span&gt;中，然后getBean(&quot;testB&quot;)，然后把testB保存到&lt;span&gt;&lt;strong&gt;singletonsCurrentlyInCreation&lt;/strong&gt;&lt;/span&gt;中，发现TestB依赖TestA，然后再getBean(&quot;testA&quot;)，此时执行下面的代码（和模块一，重点2是同一块代码）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点2 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton的源码：&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; Object getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt;&lt;span&gt; singletonFactory) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点2-0&lt;/span&gt;
    Object singletonObject = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonObjects.get(beanName);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singletonObject == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        ......
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点2-1&lt;/span&gt;
&lt;span&gt;        beforeSingletonCreation(beanName);
        ......
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点2-2&lt;/span&gt;
            singletonObject =&lt;span&gt; singletonFactory.getObject();
            newSingleton &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalStateException ex) {
            ......
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeanCreationException ex) {
            ......
        }
        &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点2-3&lt;/span&gt;
&lt;span&gt;            afterSingletonCreation(beanName);
        }
    
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在上面的代码中 //重点2-0  Object singletonObject = this.singletonObjects.get(beanName); 此时singletonObject为空会执行beforeSingletonCreation方法，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重点2-1&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; beforeSingletonCreation(String beanName) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this.singletonsCurrentlyInCreation.add(beanName)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.inCreationCheckExclusions.contains(beanName) &amp;amp;&amp;amp; !&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonsCurrentlyInCreation.add(beanName)) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanCurrentlyInCreationException(beanName);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果发现&lt;strong&gt;singletonsCurrentlyInCreation&lt;/strong&gt;已经存在testA，抛出&lt;span&gt;BeanCurrentlyInCreationException&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;setter注入为什么不会执行这一步呢，因为setter注入中会实例化TestA、TestB保存在缓存中，所以在执行 //重点2-0  Object singletonObject = this.singletonObjects.get(beanName); 时 singletonObject 不为空，并不会执行beforeSingletonCreation所以不会保存。&lt;/p&gt;
&lt;h3&gt;三、原型模式下循环依赖&lt;/h3&gt;
&lt;p&gt;　　假如有TestA、TestB两个对象，TestA依赖TestB，TestB依赖TestA，当调用getBean(&quot;testA&quot;)时,会先把beanName（testA）保存到isPrototypeCurrentlyInCreation里面，发现TestA依赖TestB，就会去getBean(&quot;testB&quot;)，然后把beanName（testB）也保存到isPrototypeCurrentlyInCreation里面，此时TestB发现依赖TestA，去getBean(&quot;testA&quot;)时，发现isPrototypeCurrentlyInCreation已经存在testA，就会抛出&lt;span&gt;BeanCurrentlyInCreationException&lt;/span&gt;异常，具体代码如下&lt;/p&gt;
&lt;p&gt;　　factory.getBean最终调用的是org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean，&lt;/p&gt;
&lt;p&gt;下面看doGetBean源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &amp;lt;T&amp;gt; T doGetBean(String name, Class&amp;lt;T&amp;gt; requiredType, &lt;span&gt;final&lt;/span&gt; Object[] args, &lt;span&gt;boolean&lt;/span&gt; typeCheckOnly) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
  ......
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isPrototypeCurrentlyInCreation(beanName)) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanCurrentlyInCreationException(beanName);
    }
  ......
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;isPrototypeCurrentlyInCreation源码&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isPrototypeCurrentlyInCreation(String beanName) {
    Object curVal &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.prototypesCurrentlyInCreation.get();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (curVal != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (curVal.equals(beanName) || (curVal &lt;span&gt;instanceof&lt;/span&gt; Set &amp;amp;&amp;amp; ((Set&amp;lt;?&amp;gt;&lt;span&gt;) curVal).contains(beanName))));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;
&lt;p&gt;总结技术，也记录生活 ：&lt;/p&gt;
&lt;p&gt;不是不想哭，&lt;/p&gt;
&lt;p&gt;而是看到灯火阑珊的时候都没有自己的家，&lt;/p&gt;
&lt;p&gt;也觉得没法在妈妈老之前给她想要的生活，&lt;/p&gt;
&lt;p&gt;也是不想承认却不得不努力的现实世界。&lt;/p&gt;
</description>
<pubDate>Tue, 27 Nov 2018 13:44:00 +0000</pubDate>
<dc:creator>程序员自我修养张振力</dc:creator>
<og:description>Spring源码-循环依赖源码解读 笔者最近无论是看书还是从网上找资料，都没发现对Spring源码是怎么解决循环依赖这一问题的详解，大家都是解释了Spring解决循环依赖的想法（有的解释也不准确，在《</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/java-zzl/p/10025609.html</dc:identifier>
</item>
<item>
<title>约定新项目的搭建流程 - 微笑刺客D</title>
<link>http://www.cnblogs.com/CKExp/p/9940457.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CKExp/p/9940457.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　　对于个人而言，项目文件结构我比较关心，一方面我能熟练操作各块文件夹，当需要改动时，能够立马进入到相应文件夹进行修改，另一方面，有新的成员后，能够看到项目文件结构，可以快速适应到环境中来，参照了一些名气很高的框架如Abp，EshopOnContainers等，也从中提炼一些项目文件结构，来约定好自己的搭建习惯，或许不是每个人的预期想法，也或许感觉我的项目文件结构很怪，不要感到奇怪，毕竟没有一劳永逸的事情，每件事情都在动态发展中(强力甩锅)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;一、约定项目文件结构&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　&lt;span&gt;　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;预期项目文件结构如下，约定之后，或许我的每一个demo都会遵从如下的结构来设计，如果说开发过程中发现有些问题，也将慢慢调整，参照了Abp来设计，但是只是用到里面最深的那一级，对于大小项目而言，能够先在标准化的道路上走，才有可能实现超车或起飞，因此先跑起来。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　结构说明：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　对于docker文件夹，目标是使用到其中的docker compose相关的一些文件，如使用docker-compose.yaml再加一个.yaml文件组合使用用来构建多个服务所需要的镜像，同时使用docker-compose.yaml再加一个service.yaml来构建服务，在docker中可以通过docker stack deploy来启动多个服务，同样在k8s中也是使用的相应的.yaml文件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　对于src文件夹，主要是用来放项目相关的，如接口或是mvc之类的应用程序及其相关的类库等，对于对外服务的应用程序，每一个中都指定了Dockerfile,这个Dockerfile文件无需手动配置，虽然也可以锦上添花，但我觉得用VS生成的已满足我的需求了，然后约定expose的端口为80，虽然有了compose文件后，这个端口指定与不指定已经意义不大了，毕竟优先级有限。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　对于test文件夹，针对测试人员或是开发人员好单独管理单元测试或集成测试而单独分割出来的一部分，方便管理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　对于tools文件夹，针对运维人员执行数据库的迁移准备的，至于可能有更多的其他辅助类的项目加入进来也是有可能的，比如监控工具等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　对于其他文件，对于整个项目权重不占比太大，故不再提及。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201811/1133736-20181127204804467-162619595.png&quot; alt=&quot;&quot; width=&quot;543&quot; height=&quot;629&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;二、搭建一个标准化项目&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　首先重申下这句话，对于项目搭建按照标准化的流程去设计，不管项目多大，按照固定标准化去设计，规避一些错误，使得针对项目开发的速度提高。&lt;/p&gt;
&lt;p&gt;　　或许每个人的搭建方式都会不一样，按照我的习惯来搭建会是如下过程：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1、首先在码云或是GitHub中先建好一个仓库，并克隆仓库到本地；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201811/1133736-20181127211714611-1274613707.gif&quot; alt=&quot;&quot; width=&quot;956&quot; height=&quot;614&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　2、其次，新建一个空白解决方案，这是很重要的一环，不要先建设Web然后再来改解决方案名字，会出现适得其反的效果；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201811/1133736-20181127212027919-305304728.gif&quot; alt=&quot;&quot; width=&quot;815&quot; height=&quot;558&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3、在空白方案下新建解决方案文件夹src和test的文件夹，建完后直接查看文件夹内发现并没有生成文件夹;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201811/1133736-20181127212151760-837217565.gif&quot; alt=&quot;&quot; width=&quot;696&quot; height=&quot;476&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4、然后在解决方案中选中src文件夹，右键新增项目，选中Asp.Net Core应用程序，取完应用程序名字，对默认路径做修改，在尾巴上加上\src，将其放置在src文件夹下，选择完毕后，应用程序加入，相应的文件夹下也出现了src文件夹，同样test文件夹也是如此;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201811/1133736-20181127212436592-94975450.gif&quot; alt=&quot;&quot; width=&quot;1037&quot; height=&quot;559&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;注意：&lt;/strong&gt;虽然在解决方案下添加也可以指定文件存放路径，同样在相应的文件夹内，但是生成的应用程序是在解决方案下，需要手动拖入，为避免这一烦扰，最好使用固定流程，先建立文件夹，然后再文件夹内选择新建项目，这样一来生成的应用程序将直接是处于该文件夹下，标准化软件开发设计必备的文件夹，具体的app项目和类库分别建设到这两个文件夹下;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;5、其次，在src和test文件夹同级建立docker文件夹，不将其引用到解决方案中，避免在window下调试，docker文件夹中应包含整个解决方案的docker compose相关的脚本信息,如有必要可以在docker下在建立mvc文件夹，在其中放置脚本，当有多个版本出现时，可以用来区分，但是为了标准化来讲，如果这么做了，在Jenkins构建脚本时得注意文件夹路径(我不会选择分成多个文件夹)，建议是可以分成多个.yaml，取成不同名字来处理镜像和服务。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　6、选择Web.MVC或Web.Host点击右键添加Docker支持，加入Dockerfile文件，内部原有端口改为80端口，如果有端口需求可以改为其他，默认的话就统一约定为80端口;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　7、对于docker文件加入.yaml文件，点解决方案选择添加容器业务流程协调程序支持，选择Docker Compose，加入到指定文件夹中，(本地我没有这个项，我是采用手工方式直接加入到docker文件夹中，很low)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　8、对于docker-compose.yaml中针对镜像生成的部分，按照现在的搭建流程来将，其中的build参数的相关信息得指定成如下所示，注意不要在.yaml文件中使用Tab按键：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;build:
   context: ../
   dockerfile: src/Surround.Web.Host/Dockerfile&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　路径说明：context的路径指定为本yaml文件上两级，为项目文件夹，然后指定为src下具体程序然后项目内Dockerfile。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　最后，再次重申这句话：对于项目搭建按照标准化的流程去设计，不管项目多大，按照固定标准化去设计，规避一些错误，使得针对项目开发的速度提高。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　本文地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 约定项目搭建标准化流程&quot; href=&quot;https://www.cnblogs.com/CKExp/p/9940457.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/CKExp/p/9940457.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;　欢迎关注微信订阅号，有新的文章将同步到订阅号中&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201811/1133736-20181127210213043-1337808259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;lang-java prettyprint prettyprinted&quot;&gt;
&lt;code&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;str&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;strong&gt;2018-11-27,望技术有成后能回来看见自己的脚步&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 27 Nov 2018 13:38:00 +0000</pubDate>
<dc:creator>微笑刺客D</dc:creator>
<og:description>对于个人而言，项目文件结构我比较关心，一方面我能熟练操作各块文件夹，当需要改动时，能够立马进入到相应文件夹进行修改，另一方面，有新的成员后，能够看到项目文件结构，可以快速适应到环境中来，参照了一些名气</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CKExp/p/9940457.html</dc:identifier>
</item>
<item>
<title>几种实现延时任务的方式（一） - CodeBear</title>
<link>http://www.cnblogs.com/CodeBear/p/10029188.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CodeBear/p/10029188.html</guid>
<description>&lt;p&gt;大家肯定都有过在饿了么，或者在美团外卖下单的经历，下完单后，超过一定的时间，订单就被自动取消了。这就是延时任务。延时任务的应用场景相当广泛，不仅仅上面所说的饿了吗，美团外卖，还有12306，或者是淘宝，携程等等 都有这样的场景。这延时任务是怎么实现的呢？跟着我，继续看下去吧。&lt;/p&gt;
&lt;h3 id=&quot;在sql查询serive层组装的时候做手脚&quot;&gt;1.在SQL查询，Serive层组装的时候做手脚&lt;/h3&gt;
&lt;p&gt;在拼接SQL或者Serive层做一些判断，比如 订单状态为 “已下单，但未支付”，同时 当前时间超过了 下单时间 15分钟，显示在用户端或者后台的订单状态就改为 “已取消”。&lt;/p&gt;
&lt;p&gt;这种方式比较方便，也没有任何延迟，但是数据库里面的状态不是真实状态了。如果需要提供接口给其他部门调用的话，别忘了对这个订单状态做一些特殊处理。&lt;/p&gt;
&lt;h3 id=&quot;job&quot;&gt;2.Job&lt;/h3&gt;
&lt;p&gt;这是最普通的方式之一了。就是开一个Job，每隔一段时间去循环订单，当满足条件后，修改订单状态。&lt;/p&gt;
&lt;p&gt;这种方式也比较方便，但是会有一定的延迟，如果订单数据比较少的话，每分钟扫描一次，还是可以接受的，延迟也就在一分钟左右。但是订单数据一旦大了起来，可能一小时也扫描不完，那么延迟就相当恐怖了。而且不停的扫描数据库，对于数据库也是一种压力。&lt;br/&gt;当然还可以做一些改进，比如扫描的时候加上时间范围，在一定时间以前的订单不扫描了，因为这些订单已经被上一次运行的Job给处理了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;第一种方式可以和第二种方式结合起来使用。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;前面两个是比较常规的做法，如果数据量不大，使用起来，也不错。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;delayqueue&quot;&gt;3.DelayQueue&lt;/h3&gt;
&lt;p&gt;DelayQueue是Java自带队列，从名字就可以知道它是一个延迟队列。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15100432-4c49f23c2c6a9b22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;从上面的图可以知道DelayQueue是一个泛型队列，它接受的类型是继承Delayed的。也就是我们需要写一个类去继承（实现）Delayed。实现Delayed，需要重写两个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public long getDelay(TimeUnit unit)
 public int compareTo(Delayed o)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个方法：消息是否到期（是否可以被读取出来）判断的依据。当返回负数，说明消息已到期，此时消息就可以被读取出来了。&lt;/p&gt;
&lt;p&gt;第二个方法：往DelayQueue里面塞入数据会执行这个方法，是数据应该排在哪个位置的判断依据。&lt;/p&gt;
&lt;p&gt;在这个类里面，我们需要定义一些属性，比如 orderId,orderTime(下单时间),expireTime(延期时间)。&lt;/p&gt;
&lt;p&gt;现在我们先来做一个测试，测试compareTo方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class OrderDelay implements Delayed {

    private int orderId;

    private Date orderTime;

    public Date getOrderTime() {
        return orderTime;
    }

    public void setOrderTime(Date orderTime) {
        this.orderTime = orderTime;
    }

    private static final int expireTime = 15000;

    public int getOrderId() {
        return orderId;
    }

    public void setOrderId(int orderId) {
        this.orderId = orderId;
    }

    @Override
    public long getDelay(TimeUnit unit) {
        return orderTime.getTime() + expireTime - new Date().getTime();
    }

    @Override
    public int compareTo(Delayed o) {
        return this.orderTime.getTime() - ((OrderDelay) o).orderTime.getTime() &amp;gt; 0 ? 1 : -1;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;getDelay方法可以暂时不看，因为测试compareTo还不需要用到这方法。&lt;br/&gt;然后我们在main方法写一些代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        DelayQueue&amp;lt;OrderDelay&amp;gt; queue = new DelayQueue&amp;lt;&amp;gt;();
        Calendar c = Calendar.getInstance();
        c.add(Calendar.DATE, 1);

        Date time1 = c.getTime();
        OrderDelay orderDelay1=new OrderDelay();
        orderDelay1.setOrderId(1);
        orderDelay1.setOrderTime(time1);
        queue.put(orderDelay1);
        System.out.println(&quot;1： &quot;+ new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;).format(time1));

        c.add(Calendar.DATE, -15);
        Date time2 = c.getTime();
        OrderDelay orderDelay2=new OrderDelay();
        orderDelay2.setOrderId(2);
        orderDelay2.setOrderTime(time2);
        queue.put(orderDelay2);

        System.out.println(&quot;2： &quot;+ new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;).format(time2));
        int a=0;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把断点设置在最后一行，然后调试，你会发现 虽然 order1是先push到DelayQueue的，但是DelayQueue第一条数据却是order2的，这就是compareTo方法的用处：&lt;br/&gt;根据此方法的返回值判断数据应该排在哪个位置&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15100432-6fbe23cfb32e3b6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;一般来说，orderTime越小的，肯定越先过期，越先被消费，所以这个方法是没有问题的。&lt;/p&gt;
&lt;p&gt;compareTo测试完成了，让我们把代码补充完整，再测试下getDelay这个方法吧（这个时候，你需要注意getDelay方法里面的代码了）：&lt;br/&gt;首先定义一个生产者方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; private static void produce(int orderId) {
        OrderDelay delay = new OrderDelay();
        delay.setOrderId(orderId);
        Date currentTime = new Date();
        SimpleDateFormat formatter = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        String dateString = formatter.format(currentTime);
        delay.setOrderTime(currentTime);
        System.out.printf(&quot;现在时间是%s;订单%d加入队列%n&quot;, dateString, orderId);
        queue.put(delay);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再定义一个消费者方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; private static void consum() {
        while (true) {
            try {
                OrderDelay orderDelay = queue.take();//
                Date currentTime = new Date();
                SimpleDateFormat formatter = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
                String dateString = formatter.format(currentTime);
                System.out.printf(&quot;现在时间是%s;订单%d过期%n&quot;, dateString, orderDelay.getOrderId());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在main方法里面运行这两个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;produce(1);
consum();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再把断点设置在&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; OrderDelay orderDelay = queue.take();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调试，运行到这里，F8，你会发现代码执行不下去了，被阻塞了，其实这也说明了DelayQueue是一个阻塞队列。15秒后，终于进入了下一行代码，并且拿到了数据，这就是getDelay和take方法的用处了。&lt;br/&gt;getDelay：根据方法的返回值，判断数据可否被take出来。&lt;br/&gt;take：取出数据，但是受到getDelay方法的制约，如果没有满足条件，则会阻塞。&lt;/p&gt;
&lt;p&gt;好了。getDelay方法和compareTo都已经测试完毕了。下面的事情就简单了。&lt;br/&gt;我就直接放出代码了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   static DelayQueue&amp;lt;OrderDelay&amp;gt; queue = new DelayQueue&amp;lt;&amp;gt;();

    public static void main(String[] args) throws InterruptedException {
        Thread productThread = new Thread(() -&amp;gt; {
            for (int i = 0; i &amp;lt; 20; i++) {
                try {
                    Thread.sleep(1200);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                produce(i);
            }
        });
        productThread.start();


        Thread consumThread = new Thread(() -&amp;gt; {
            consum();
        });
        consumThread.start();
    }

    private static void produce(int orderId) {
        OrderDelay delay = new OrderDelay();
        delay.setOrderId(orderId);
        Date currentTime = new Date();
        SimpleDateFormat formatter = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        String dateString = formatter.format(currentTime);
        delay.setOrderTime(currentTime);
        System.out.printf(&quot;现在时间是%s;订单%d加入队列%n&quot;, dateString, orderId);
        queue.put(delay);
    }

    private static void consum() {
        while (true) {
            try {
                OrderDelay orderDelay = queue.take();//
                Date currentTime = new Date();
                SimpleDateFormat formatter = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
                String dateString = formatter.format(currentTime);
                System.out.printf(&quot;现在时间是%s;订单%d过期%n&quot;, dateString, orderDelay.getOrderId());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15100432-87cfa27087e068c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过控制台输出，你会发现功能实现OK。&lt;/p&gt;
&lt;p&gt;这种方式也比较方便，而且几乎没有延迟，对内存占用也不大，因为毕竟只是存放一个订单号而已。&lt;br/&gt;缺点也比较明显，因为订单是存放在内存的，一旦服务器挂了，就麻烦了。消费者和生产者只能在同一套代码中，现在是微服务的时代，一般来说消费者和生产者都是分开的，甚至是在不同的服务器。因为这样，如果消费者压力过大，可以通过加服务器的方式很方便的来解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;前三种方式也可以结合在一起使用&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 27 Nov 2018 13:32:00 +0000</pubDate>
<dc:creator>CodeBear</dc:creator>
<og:description>大家肯定都有过在饿了么，或者在美团外卖下单的经历，下完单后，超过一定的时间，订单就被自动取消了。这就是延时任务。延时任务的应用场景相当广泛，不仅仅上面所说的饿了吗，美团外卖，还有12306，或者是淘宝</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CodeBear/p/10029188.html</dc:identifier>
</item>
<item>
<title>架构设计三原则 - 挑战者V</title>
<link>http://www.cnblogs.com/youcong/p/10029167.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youcong/p/10029167.html</guid>
<description>&lt;p&gt;成为架构师，可以说是绝大多数开发者的梦想。但是这个过程并不是一件简单的事情，如果简单的话，意味着供过于求，就代表着不值钱了。在目前国内，架构师也算是一个比较吃香的职业。对于年龄较大的小伙伴们，他们的选择通常有这么几个?&lt;/p&gt;
&lt;p&gt;第一、继续开发者之路，毕竟现在30多岁的资深工程师也不少(通常这些人，对于公司来说，业务非常熟练(某工程师对公司好几个业务十分熟悉，不少项目其中的核心代码是其编写(另外也考虑到如果真正是新人来对接，时间成本或者其他方面的成本是比较高昂的)，同时也比较稳定(基本上都已经成家有了自己的小孩，跳槽的频率相对小）;&lt;/p&gt;
&lt;p&gt;第二、走向管理之路，管理之路，通常是要么是项目经理，要么是TeamLeader，大小公司对此有不同的定义，有的规模毕竟大的公司，可以细分为项目总监、项目经理及其CTO或架构师;&lt;/p&gt;
&lt;p&gt;第三、转向产品或者运营方面;&lt;/p&gt;
&lt;p&gt;第四、去当教师(通常去培训机构当讲师);&lt;/p&gt;
&lt;p&gt;第五、自主创业(不过不多，一般情况下，充当技术合伙人的比较多，因为当技术合伙人，仅仅只是负责技术方面的设计和管理，不必承担金钱方面的风险);&lt;/p&gt;
&lt;p&gt;第六、自由职业(一般自由职业，通常是接私活，前提是私活足够多，一般这种自由职业者通常身边会有几个在职或者非在职朋友一起合作,毕竟人多力量大）；&lt;/p&gt;
&lt;p&gt;第七、成为专职作家(毕竟对于程序员来说，能够写书，将自己多年对技术方面的掌控和理解等分享给广大的小伙伴们也是一件非常幸福的事情);&lt;/p&gt;
&lt;p&gt;第八、没有办法不得不转行(技术不过硬、人脉又不好、业务方面积累不深或者是在该领域十多年过去了，仍然做着重复的事情，而今有比其价格更低的人来替换其);&lt;/p&gt;
&lt;p&gt;这篇文章不是再讲程序员的以后方向和怎么走接下来的路。主要还是围绕着架构设计三大原则。上面的话只不过是临时突然有些想法，所以就说说了。&lt;/p&gt;
&lt;p&gt;另外贴一下架构师的薪资(以北京一线城市为例):&lt;/p&gt;
&lt;p&gt;用友公司:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201811/1255290-20181127203202337-1226508726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;联想集团:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201811/1255290-20181127203307023-1379086534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从中可以普遍看到架构师的薪资通常在20K以上。当然了，能拿到多高，取决你自身所能提供的价值。&lt;/p&gt;
&lt;p&gt;文章偏题太多，下面进入正题。&lt;/p&gt;
&lt;p&gt;问:架构设计三原则有哪些？&lt;/p&gt;
&lt;p&gt;答:主要有合适原则、简单原则、演化原则。&lt;/p&gt;

&lt;p&gt;一、合适原则&lt;/p&gt;
&lt;p&gt;优秀的技术人员都有很强的技术情结(包括我自己，虽然在技术方面不够优秀还需要学习很多东西),当他们做方案或者架构时，总想不断地挑战自己，想达到甚至优于业界领先水平是其中的一个典型表现，因为这样才能够展现自己的优秀，才能在年终KPI绩效总结里面骄傲地写，“我设计了某某方案，达到目前知名某公司的一样效果甚至优于其”。&lt;/p&gt;
&lt;p&gt;但现实是，大部分这样想的和这样做的架构，最后可能都以失败而告终。&lt;/p&gt;

&lt;p&gt;为什么会这样?原因有如下几个方面?&lt;/p&gt;
&lt;p&gt;首先再理想的设计，也需要考虑实际情况，我们可以叫做实事求是或脚踏实地。&lt;/p&gt;
&lt;p&gt;(1)将军难打无把握之仗；&lt;/p&gt;
&lt;p&gt;在互联网公司，一般情况是你有多少个人就表示你能做的多么大，也许这个观点你并不赞同，比如阿里为例，最早的阿里公司肯定没有现在这么多人，系统也没有这么大，起初都是从几个人开始的。关于这段历史，大家有兴趣可以看看关于阿里方面的传记或者马云先生的传记。&lt;/p&gt;
&lt;p&gt;(2)罗马不是一天建成的;&lt;/p&gt;
&lt;p&gt;这个不用多说，一看就明白，前面(1)也是如此。&lt;/p&gt;
&lt;p&gt;(3)冰山之下才是关键;&lt;/p&gt;
&lt;p&gt;可能有人认为，业界领先的方案都是天才创建出来的，所以自己也要造一个业界领先方案，以此证明自己也是天才。确实是有这样的天才，但更多的时候，业界领先的方案，其实都是“逼”出来的。&lt;/p&gt;
&lt;p&gt;比如以之前某公司的一个产品经理需求为例，APP的背景根据手机壳变色。这个需求并非是不能实现的。当然了，这个需求看起来有些操蛋。&lt;/p&gt;
&lt;p&gt;简单来说，“业务”的发展到一定阶段，量变导致质变，出现新的问题，已有的方式已经不能应对这些问题，需要用一种新的方案来解决，通过创新和尝试，才有了业界领先的方案。&lt;/p&gt;
&lt;p&gt;比如有不少IT小伙伴们动辄就说分布式、大数据、微服务之类的，但是前提是当业务发展到一定阶段时遇到瓶颈，现有的架构或方案不能满足业务的扩展。&lt;/p&gt;

&lt;p&gt;二、简单原则&lt;/p&gt;
&lt;p&gt;软件架构设计是一门技术活。所谓技术活，从历史上看，无论是瑞士的钟表，还是瓦特的蒸汽机;无论是莱特兄弟发明的飞机，还是摩托罗拉发明的手机,无一不是越来越精细，越来越复杂。因此当我们进行架构设计时，会自然而然地想把架构做精美、做复杂，这样才能体现我们的技术实力，也能够将架构做成一件技术品。&lt;/p&gt;
&lt;p&gt;前面我在&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/youcong/p/10022975.html&quot;&gt;谈谈架构设计的目的&lt;/a&gt; 这篇文章中说过，架构设计的目的就是应对并解决软件日益庞大复杂的问题。&lt;/p&gt;
&lt;p&gt;关于软件领域的复杂性主要体现在这么几个方面?&lt;/p&gt;
&lt;p&gt;1.结构的复杂性&lt;/p&gt;
&lt;p&gt;比如最初在单体应用上，所以的请求集中在一个项目上，后来从这个整体系统，分出几个子系统来，于是每次提供服务，都需要关联这几个子系统以达到实现功能的目的。一个两个还好，但是三个四个乃至十个二十个，会怎么样呢？我的回答是，你可以以HTTP请求为例，请求有的时候也会因为网络延迟或者请求携带参数的问题导致请求失败，你试着想像，为实现某一个功能关联几个子系统(需求请求几个子系统)，我相信你就懂了。&lt;/p&gt;
&lt;p&gt;通过这个例子，我们可以发现结构上复杂导致的问题有很多，以下我列举几个常见的问题?&lt;/p&gt;
&lt;p&gt;(1)组件越多,就越有可能其中某个组件出现问题（组件你可以理解为多个子系统）;&lt;/p&gt;
&lt;p&gt;(2)某个组件改动，会影响关联的所有组件(从某个角度看，你可以理解为耦合性比较强);&lt;/p&gt;
&lt;p&gt;(3)定位一个复杂系统中的问题总是比简单系统更加困难;&lt;/p&gt;

&lt;p&gt;2.逻辑的复杂性&lt;/p&gt;
&lt;p&gt;意识到结构的复杂性后，我们第一个想到的可能是降低耦合性，如何降低呢？可能引用设计模式来达到这个目的，也有可能是减少分出的子系统数量来达到这个目的。&lt;/p&gt;
&lt;p&gt;但是最粗暴最简单最实际的做法就是，就是不分出子系统(组件)，全部在一个系统上。&lt;/p&gt;
&lt;p&gt;糟糕的是，这样是行不通的，原因不仅仅是因为结构的复杂性，还有逻辑的复杂性，比如如果某个组件的逻辑太过复杂，一样会带来不少问题。&lt;/p&gt;
&lt;p&gt;关于逻辑的复杂性，我想强调一点是，为什么程序员经常加班，先不说代码质量问题(毕竟如果不是公司有一定的规章制度约束你，让你必须这么做，有的时候，我们为了图快，很少考虑代码整体的简洁(优雅)或有没有更好的实现方案，一般就是拿起键盘立刻实现完成任务就OK，因为在大多数情况，我也是这么做的，没有比在短时间内尽快完成上面交代下来的任务更为重要，毕竟薪水和享受的待遇掌握在上面手里)。有一点与代码质量关系不是特别大，那就是业务的复杂度，过于复杂的业务，涉及好几个系统，万一改了这个没有改好，就会影响其他的系统。&lt;/p&gt;


&lt;p&gt;三、演化原则&lt;/p&gt;
&lt;p&gt;其实软件的变化就好比生物的进化，并不是一蹴而就的。它也有一个演变的过程。&lt;/p&gt;
&lt;p&gt;以生物为例:&lt;/p&gt;
&lt;p&gt;(1)首先，生物要适应环境;&lt;/p&gt;
&lt;p&gt;(2)其次，生物需要不断繁殖，将有利的基因传递下去，将不利的基因剔除出去;&lt;/p&gt;
&lt;p&gt;(3)最后，当环境变化时，生物能够快速的适应环境，如果不能适应自然就会淘汰(这也就是严复曾经说过的“物竞天择，适者生存”);&lt;/p&gt;

&lt;p&gt;软件架构设计同样是类似的过程:&lt;br/&gt;(1)首先，设计出来的架构要满足当前的业务需求(毕竟公司盈利是首要目的,不然，哪有钱发工资或者享受公司的各种福利呢);&lt;/p&gt;
&lt;p&gt;(2)其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善;&lt;/p&gt;
&lt;p&gt;(3)最后，当业务发生变化时，架构要扩展、重构，甚至重写;代码也许需要重写，但有价值的经验、教训、逻辑、设计等(类似生物的基因)却可以在新架构中延续下去;&lt;/p&gt;

&lt;p&gt;架构师在进行架构设计时需要牢记这个原则，时刻提醒自己不要贪大求全或者盲目照抄。应该认真分析当前业务的特点，明确业务所面临的主要问题，设计合理的架构，快速落地以满足业务需要，然后再运行过程中不断完善架构，不断随着业务演化架构。&lt;/p&gt;


&lt;p&gt;小结:&lt;/p&gt;
&lt;p&gt;架构设计三原则已经谈完了，希望给小伙伴们有所启发。&lt;/p&gt;
&lt;p&gt;本文引用的图片来源于拉勾网&lt;/p&gt;
&lt;p&gt;本文部分引用语句来源于李运华先生的《从0开始学架构》&lt;/p&gt;
&lt;p&gt;当然了，绝大多数还是来源于我自己的认真思考和经验教训。&lt;/p&gt;

</description>
<pubDate>Tue, 27 Nov 2018 13:29:00 +0000</pubDate>
<dc:creator>挑战者V</dc:creator>
<og:description>成为架构师，可以说是绝大多数开发者的梦想。但是这个过程并不是一件简单的事情，如果简单的话，意味着供过于求，就代表着不值钱了。在目前国内，架构师也算是一个比较吃香的职业。对于年龄较大的小伙伴们，他们的选</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youcong/p/10029167.html</dc:identifier>
</item>
</channel>
</rss>