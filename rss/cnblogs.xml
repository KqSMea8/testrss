<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Redis配置文件（1）units/includes/GENERAL/SECURITY/LIMITS - MrChengs</title>
<link>http://www.cnblogs.com/Mrchengs/p/10052028.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mrchengs/p/10052028.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;redis.conf文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在Linux进行文件的查看！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;units单位：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;8&lt;/span&gt; # Note on units: when memory size &lt;span&gt;is&lt;/span&gt; needed, it &lt;span&gt;is&lt;/span&gt;&lt;span&gt; possible to specify
   &lt;/span&gt;&lt;span&gt;9&lt;/span&gt; # it &lt;span&gt;in&lt;/span&gt;&lt;span&gt; the usual form of 1k 5GB 4M and so forth:
  &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt; #
  &lt;/span&gt;&lt;span&gt;11&lt;/span&gt; # 1k =&amp;gt; &lt;span&gt;1000&lt;/span&gt;&lt;span&gt; bytes
  &lt;/span&gt;&lt;span&gt;12&lt;/span&gt; # 1kb =&amp;gt; &lt;span&gt;1024&lt;/span&gt;&lt;span&gt; bytes
  &lt;/span&gt;&lt;span&gt;13&lt;/span&gt; # 1m =&amp;gt; &lt;span&gt;1000000&lt;/span&gt;&lt;span&gt; bytes
  &lt;/span&gt;&lt;span&gt;14&lt;/span&gt; # 1mb =&amp;gt; &lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;&lt;span&gt; bytes
  &lt;/span&gt;&lt;span&gt;15&lt;/span&gt; # 1g =&amp;gt; &lt;span&gt;1000000000&lt;/span&gt;&lt;span&gt; bytes
  &lt;/span&gt;&lt;span&gt;16&lt;/span&gt; # 1gb =&amp;gt; &lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;&lt;span&gt; bytes
  &lt;/span&gt;&lt;span&gt;17&lt;/span&gt;&lt;span&gt; #
  &lt;/span&gt;&lt;span&gt;18&lt;/span&gt; # &lt;strong&gt;&lt;span&gt;units are case insensitive so 1GB 1Gb 1gB are all the same.&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 1  配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit&lt;/p&gt;
&lt;p&gt; 2  对大小写不敏感&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;includes：&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;20&lt;/span&gt;&lt;span&gt; ################################## INCLUDES ##############################
  &lt;/span&gt;&lt;span&gt;22&lt;/span&gt; # &lt;span&gt;&lt;strong&gt;Include one or more other config files here.  This is useful if you
  &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&lt;span&gt; # &lt;span&gt;&lt;strong&gt;have a standard template that goes to all Redis servers but also need
  &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; # to customize a few per-&lt;span&gt;server settings.  Include files can include
  &lt;/span&gt;&lt;span&gt;25&lt;/span&gt; # other files, so use &lt;span&gt;this&lt;/span&gt;&lt;span&gt; wisely.
  &lt;/span&gt;&lt;span&gt;26&lt;/span&gt;&lt;span&gt; #
  &lt;/span&gt;&lt;span&gt;27&lt;/span&gt; # Notice option &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; won&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t be rewritten by command &quot;CONFIG REWRITE&quot;&lt;/span&gt;
  &lt;span&gt;28&lt;/span&gt; # &lt;span&gt;from&lt;/span&gt;&lt;span&gt; admin or Redis Sentinel. Since Redis always uses the last processed
  &lt;/span&gt;&lt;span&gt;29&lt;/span&gt; # line &lt;span&gt;as&lt;/span&gt; value of a configuration directive, you&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d better put includes&lt;/span&gt;
  &lt;span&gt;30&lt;/span&gt; # at the beginning of &lt;span&gt;this&lt;/span&gt;&lt;span&gt; file to avoid overwriting config change at runti     me.
  &lt;/span&gt;&lt;span&gt;31&lt;/span&gt;&lt;span&gt; #
  &lt;/span&gt;&lt;span&gt;32&lt;/span&gt; # If instead you are interested &lt;span&gt;in&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; includes to &lt;span&gt;override&lt;/span&gt;&lt;span&gt; configuration
  &lt;/span&gt;&lt;span&gt;33&lt;/span&gt; # options, it &lt;span&gt;is&lt;/span&gt; better to use include &lt;span&gt;as&lt;/span&gt;&lt;span&gt; the last line.
  &lt;/span&gt;&lt;span&gt;34&lt;/span&gt;&lt;span&gt; #
  &lt;/span&gt;&lt;span&gt;35&lt;/span&gt; #&lt;span&gt;&lt;strong&gt; i&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;nclude /p&lt;/span&gt;ath/to/local.conf&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和我们的Struts2配置文件类似，可以通过includes包含，redis.conf可以作为总闸，包含其他&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;GENERAL&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;141&lt;/span&gt; # If a pid file &lt;span&gt;is&lt;/span&gt; specified, Redis writes it &lt;span&gt;where&lt;/span&gt;&lt;span&gt; specified at startup
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;&lt;span&gt; # and removes it at exit.
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;&lt;span&gt; #
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; # When the server runs non daemonized, no pid file &lt;span&gt;is&lt;/span&gt; created &lt;span&gt;if&lt;/span&gt; none &lt;span&gt;is&lt;/span&gt;
&lt;span&gt;145&lt;/span&gt; # specified &lt;span&gt;in&lt;/span&gt; the configuration. When the server &lt;span&gt;is&lt;/span&gt;&lt;span&gt; daemonized, the pid fi     le
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; # &lt;span&gt;is&lt;/span&gt; used even &lt;span&gt;if&lt;/span&gt; not specified, defaulting to &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/var/run/redis.pid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;&lt;span&gt; #
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; # Creating a pid file &lt;span&gt;is&lt;/span&gt; best effort: &lt;span&gt;if&lt;/span&gt; Redis &lt;span&gt;is&lt;/span&gt;&lt;span&gt; not able to create it
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;&lt;span&gt; # nothing bad happens, the server will start and run normally.
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; &lt;span&gt;&lt;strong&gt;pidfile /var/run/redis_6379.pid&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;126&lt;/span&gt; # By &lt;span&gt;default&lt;/span&gt; Redis does not run &lt;span&gt;as&lt;/span&gt; a daemon. Use &lt;span&gt;'&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; you need it.
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; # Note that Redis will write a pid file &lt;span&gt;in&lt;/span&gt; /&lt;span&gt;var&lt;/span&gt;/run/&lt;span&gt;redis.pid when daemoniz     ed.
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;&lt;span&gt;&lt;strong&gt; daemonize yes&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;82&lt;/span&gt; # Accept connections on the specified port, &lt;span&gt;default&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;6379&lt;/span&gt; (IANA #&lt;span&gt;815344&lt;/span&gt;&lt;span&gt;).
  &lt;/span&gt;&lt;span&gt;83&lt;/span&gt; # If port &lt;span&gt;0&lt;/span&gt; &lt;span&gt;is&lt;/span&gt;&lt;span&gt; specified Redis will not listen on a TCP socket.
  &lt;/span&gt;&lt;span&gt;84&lt;/span&gt; &lt;span&gt;&lt;strong&gt;port 6379&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# TCP listen() backlog.
#
# In high requests&lt;/span&gt;-per-second environments you need an high backlog &lt;span&gt;in&lt;/span&gt;&lt;span&gt; order
# to avoid slow clients connections issues. Note that the Linux kernel
# will silently truncate it to the value of &lt;/span&gt;/proc/sys/net/core/&lt;span&gt;somaxconn so
# make sure to raise both the value of somaxconn and tcp_max_syn_backlog
# &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; order to &lt;span&gt;get&lt;/span&gt;&lt;span&gt; the desired effect.
&lt;span&gt;&lt;strong&gt;tcp&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;-backlog 511&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;

tcp&lt;/span&gt;-&lt;span&gt;backlog
设置tcp的backlog，backlog其实是一个连接队列，&lt;span&gt;&lt;strong&gt;backlog队列总和&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;=未完成三次握手队列 +&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; 已经完成三次握手队列&lt;/strong&gt;&lt;/span&gt;。
在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核会将这个值减小到
&lt;/span&gt;/proc/sys/net/core/&lt;span&gt;somaxconn的值，所以需要确认增大somaxconn和tcp_max_syn_backlog两个值
来达到想要的效果&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# Close the connection after a client &lt;span&gt;is&lt;/span&gt; idle &lt;span&gt;for&lt;/span&gt; N seconds (&lt;span&gt;0&lt;/span&gt;&lt;span&gt; to disable)
&lt;strong&gt;&lt;span&gt;timeout &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;0&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES
# JUST COMMENT THE FOLLOWING LINE.
# &lt;/span&gt;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&lt;span&gt;&lt;strong&gt;
bind 127.0.0.1&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
# On Linux, the specified value (&lt;span&gt;in&lt;/span&gt; seconds) &lt;span&gt;is&lt;/span&gt;&lt;span&gt; the period used to send ACKs.
# Note that to close the connection the &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; of the time &lt;span&gt;is&lt;/span&gt;&lt;span&gt; needed.
# On other kernels the period depends on the kernel configuration.
#
# A reasonable value &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;this&lt;/span&gt; option &lt;span&gt;is&lt;/span&gt; &lt;span&gt;300&lt;/span&gt; seconds, which &lt;span&gt;is&lt;/span&gt; the &lt;span&gt;new&lt;/span&gt;&lt;span&gt;
# Redis &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; starting with Redis &lt;span&gt;3.2&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.
&lt;span&gt;&lt;strong&gt;tcp&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;-keepalive 300&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;
单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# Specify the server verbosity level.
# This can be one of:
# &lt;span&gt;debug&lt;/span&gt; (a lot of information, useful &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; development/&lt;span&gt;testing)
# &lt;span&gt;verbose&lt;/span&gt; (many rarely useful info, but not a mess like the debug level)
# &lt;span&gt;notice&lt;/span&gt; (moderately verbose, what you want &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; production probably)
# &lt;span&gt;warning&lt;/span&gt; (only very important &lt;/span&gt;/&lt;span&gt; critical messages are logged)
&lt;strong&gt;&lt;span&gt;loglevel notice&lt;/span&gt;&lt;/strong&gt;
日志级别&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# Specify the log file name. Also the empty &lt;span&gt;string&lt;/span&gt;&lt;span&gt; can be used to force
# Redis to log on the standard output. Note that &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; you use standard
# output &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; logging but daemonize, logs will be sent to /dev/&lt;span&gt;null&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
logfile &quot;&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
日志的名字&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# Set the number of databases. The &lt;span&gt;default&lt;/span&gt; database &lt;span&gt;is&lt;/span&gt; DB &lt;span&gt;0&lt;/span&gt;, you can &lt;span&gt;select&lt;/span&gt;&lt;span&gt;
# a different one on a per&lt;/span&gt;-connection basis &lt;span&gt;using&lt;/span&gt; SELECT &amp;lt;dbid&amp;gt; &lt;span&gt;where&lt;/span&gt;&lt;span&gt;
# dbid &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; a number between &lt;span&gt;0&lt;/span&gt; and &lt;span&gt;'&lt;/span&gt;&lt;span&gt;databases&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&lt;strong&gt;
databases 16
系统默认的库16个
默认使用0库&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
# To enable logging to the system logger, just &lt;span&gt;set&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;syslog-enabled&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; to yes,
# and optionally update the other syslog parameters to suit your needs.
&lt;span&gt;# syslog&lt;/span&gt;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&lt;span&gt;enabled no   是否把日志输出到syslog中&lt;/span&gt;
&lt;span&gt;系统日志默认时关着&lt;/span&gt;
# Specify the syslog identity.
# syslog&lt;/span&gt;-&lt;span&gt;ident redis  指定syslog里的日志标志
&lt;span&gt;设备以redis开头&lt;/span&gt;
# Specify the syslog facility. Must be USER or between LOCAL0&lt;/span&gt;-&lt;span&gt;LOCAL7.
# syslog&lt;/span&gt;-&lt;span&gt;facility local0
&lt;span&gt;指定syslog设备，值可以是USER或LOCAL0&lt;/span&gt;&lt;/span&gt;&lt;span&gt;-LOCAL7
默认使用local0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;SECURITY安全&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;访问密码的查看、设置和取消&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181202024721180-924760056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置密码：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;config set requirepass &quot; &quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181202024730410-1387971845.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;改为空的时候默认没有密码！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;467&lt;/span&gt;&lt;span&gt; ################################## SECURITY ###################################
&lt;/span&gt;&lt;span&gt;468&lt;/span&gt;
&lt;span&gt;469&lt;/span&gt; # &lt;strong&gt;&lt;span&gt;Require clients to issue AUTH &amp;lt;PASSWORD&amp;gt; before processing any other
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;470&lt;/span&gt; # &lt;strong&gt;&lt;span&gt;commands&lt;/span&gt;&lt;/strong&gt;.  This might be useful &lt;span&gt;in&lt;/span&gt; environments &lt;span&gt;in&lt;/span&gt; which you &lt;span&gt;do&lt;/span&gt;&lt;span&gt; not trust
&lt;/span&gt;&lt;span&gt;471&lt;/span&gt; # others with access to the host running redis-server.
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;要求必须auth + password 在任何命令之前&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181202025108165-1917504683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Redis一般做的是缓存，不是安全，而且系统会认为Linux是在安全的环境下....&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LIMITS限制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;maxclients:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&lt;span&gt;设置redis同时可以与多少个客户端进行连接&lt;/span&gt;&lt;/strong&gt;。默认情况下为10000个客户端。当你
无法设置进程文件句柄限制时，redis会设置为当前的文件句柄限制值减去32，因为redis会为自
身内部处理逻辑留一些句柄出来。如果达到了此限制，redis则会拒绝新的连接请求，并且向这
些连接请求方发出“max number of clients reached”以作回应。&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;509 # Once the limit is reached Redis will close all the new connections sending&lt;/p&gt;
&lt;p&gt;510 # an error 'max number of clients reached'.&lt;/p&gt;
&lt;p&gt;511 #&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;512 # maxclients 10000&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;默认情况下为10000个客户端&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; maxmemory&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;设置redis可以使用的内存量。&lt;/span&gt;&lt;/strong&gt;一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-&lt;span&gt;policy来指定。&lt;br/&gt;如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，
那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。
但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），&lt;br/&gt;那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;533 # In short... if you have slaves attached it is suggested that you set a lower&lt;/p&gt;
&lt;p&gt;534 # limit for maxmemory so that there is some free RAM on the system for slave&lt;/p&gt;
&lt;p&gt;535 # output buffers (but this is not needed if the policy is 'noeviction').&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;537 # maxmemory &amp;lt;bytes&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;maxmemory-policy:&lt;/p&gt;
&lt;p&gt;最大缓存清楚策略&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
（&lt;span&gt;1&lt;/span&gt;）&lt;span&gt;volatile&lt;/span&gt;-&lt;span&gt;lru：使用LRU算法移除key，只对设置了过期时间的键
（&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;）allkeys-&lt;span&gt;lru：使用LRU算法移除key
（&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;）&lt;span&gt;volatile&lt;/span&gt;-&lt;span&gt;random：在过期集合中移除随机的key，只对设置了过期时间的键
（&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;）allkeys-&lt;span&gt;random：移除随机的key
（&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;）&lt;span&gt;volatile&lt;/span&gt;-&lt;span&gt;ttl：移除那些TTL值最小的key，即那些最近要过期的key
（&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;）noeviction：不进行移除。针对写操作，只是返回错误信息
&lt;span&gt;&lt;strong&gt;LRU 算法或者 TTL 算法都是不是很精确算法，而是 个近似算法。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;539 # MAXMEMORY POLICY: how Redis will select what to remove when maxmemory&lt;/p&gt;
&lt;p&gt;540 # is reached. You can select among five behaviors:&lt;/p&gt;
&lt;p&gt;541 #&lt;/p&gt;
&lt;p&gt;542 # volatile-lru -&amp;gt; remove the key with an expire set using an LRU algorithm&lt;/p&gt;
&lt;p&gt;543 # allkeys-lru -&amp;gt; remove any key according to the LRU algorithm&lt;/p&gt;
&lt;p&gt;544 # volatile-random -&amp;gt; remove a random key with an expire set&lt;/p&gt;
&lt;p&gt;545 # allkeys-random -&amp;gt; remove a random key, any key&lt;/p&gt;
&lt;p&gt;546 # volatile-ttl -&amp;gt; remove the key with the nearest expire time (minor TTL)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;547 # noeviction -&amp;gt; don't expire at all, just return an error on write operations&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181202025752292-489730223.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;
&lt;p&gt;maxmemory-samples&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是&lt;strong&gt;&lt;span&gt;估算值&lt;/span&gt;&lt;/strong&gt;，所以你可以设置样本的大小，
redis默认会检查这么多个key并选择其中LRU的那个&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;562 # LRU and minimal TTL algorithms are not precise algorithms but approximated&lt;/p&gt;
&lt;p&gt;563 # algorithms (in order to save memory), so you can tune it for speed or&lt;/p&gt;
&lt;p&gt;564 # accuracy. For default Redis will check five keys and pick the one that was&lt;/p&gt;
&lt;p&gt;565 # used less recently, you can change the sample size using the following&lt;/p&gt;
&lt;p&gt;566 # configuration directive.&lt;/p&gt;
&lt;p&gt;568 # The default of 5 produces good enough results. 10 Approximates very closely&lt;/p&gt;
&lt;p&gt;569 # true LRU but costs a bit more CPU. 3 is very fast but not very accurate.&lt;/p&gt;
&lt;p&gt;571 # &lt;strong&gt;&lt;span&gt;maxmemory-samples 5&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 01 Dec 2018 19:02:00 +0000</pubDate>
<dc:creator>MrChengs</dc:creator>
<og:description>redis.conf文件 在Linux进行文件的查看！ units单位： 1 配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit 2 对大小写不敏感 includes： 20</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mrchengs/p/10052028.html</dc:identifier>
</item>
<item>
<title>来源自rnnoise，但非rnn - cpuimage</title>
<link>http://www.cnblogs.com/cpuimage/p/10052022.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cpuimage/p/10052022.html</guid>
<description>&lt;p&gt;很快又一年过去了。&lt;/p&gt;
&lt;p&gt;自学音频算法也近一年了。&lt;/p&gt;
&lt;p&gt;不记得有多少个日日夜夜，&lt;/p&gt;
&lt;p&gt;半夜醒来，就为验证算法思路。&lt;/p&gt;
&lt;p&gt;一次又一次地改进和突破。&lt;/p&gt;
&lt;p&gt;傻逼样的坚持，必然得到牛逼样的结果。&lt;/p&gt;
&lt;p&gt;这一年，主要扎音频算法上。&lt;/p&gt;
&lt;p&gt;经常有网友联系我，几乎都会问我同一个问题。&lt;/p&gt;
&lt;p&gt;我是怎么学习的？&lt;/p&gt;
&lt;p&gt;说起来，其实很简单。&lt;/p&gt;
&lt;p&gt;就是先设一个小目标，而且必须是一个具有挑战性的目标。&lt;/p&gt;
&lt;p&gt;例如两年前从原来做安全，转去做图像算法。&lt;/p&gt;
&lt;p&gt;当年定的目标就是实现一键修图的算法。&lt;/p&gt;
&lt;p&gt;当然，也是做到了。&lt;/p&gt;
&lt;p&gt;虽然后来也有改进过多次，但是一直没有整理出最后的版本。&lt;/p&gt;
&lt;p&gt;有各种各样的原因，一直没时间梳理。&lt;/p&gt;
&lt;p&gt;一键智能降噪，智能白平衡，智能曝光，同时也兼顾了算法性能。&lt;/p&gt;
&lt;p&gt;没有具体实测，但是实时是肯定没有问题的。&lt;/p&gt;
&lt;p&gt;一直有一个心愿，就是将这个算法梳理整理，&lt;/p&gt;
&lt;p&gt;调优后，合入到视频播放器中，&lt;/p&gt;
&lt;p&gt;打造一个简单而简约的视频播放器。&lt;/p&gt;
&lt;p&gt;这个目标也渐渐靠近了，&lt;/p&gt;
&lt;p&gt;近期一直在做ffmpeg的编码转码方面的工作。&lt;/p&gt;
&lt;p&gt;预计明年吧，也许这个播放器就可以跟大家见面了。&lt;/p&gt;
&lt;p&gt;而今天写的标题，主要是音频降噪这个方向。&lt;/p&gt;
&lt;p&gt;这个目标也是今年年初给自己定下的目标。&lt;/p&gt;
&lt;p&gt;就在昨天 2018.12.1，这个音频算法，算是第一版完成了。&lt;/p&gt;
&lt;p&gt;这之中经历了很多很多，有很多细节。&lt;/p&gt;
&lt;p&gt;真的有无数次尝试和改进优化。&lt;/p&gt;
&lt;p&gt;把学习的音频算法的精髓，运用起来。&lt;/p&gt;
&lt;p&gt;最后，达到预期目标。&lt;/p&gt;
&lt;p&gt;这里要稍微说一下，&lt;/p&gt;
&lt;p&gt;我是怎么做的。&lt;/p&gt;
&lt;p&gt;其实说简单也简单，说难也难。&lt;/p&gt;
&lt;p&gt;定了一个目标之后，&lt;/p&gt;
&lt;p&gt;肯定是去找最传统的算法资料。&lt;/p&gt;
&lt;p&gt;一个一个算法实现。&lt;/p&gt;
&lt;p&gt;从中学习到每个算法的优缺点，缺点当然就要尝试改进。&lt;/p&gt;
&lt;p&gt;优点就要考虑变通，让优点更加突出。&lt;/p&gt;
&lt;p&gt;每次都是从一个算法延伸出很多待解决的困难，&lt;/p&gt;
&lt;p&gt;然后发现一个问题，就找相关的资料，&lt;/p&gt;
&lt;p&gt;尝试解决，一次又一次攻克问题。&lt;/p&gt;
&lt;p&gt;这里面最重要的一点就是，&lt;/p&gt;
&lt;p&gt;一定要坚持每一个算法都要自己动手实现一遍。&lt;/p&gt;
&lt;p&gt;而且除了编解码外，不允许调用第三方库。&lt;/p&gt;
&lt;p&gt;纯C实现。&lt;/p&gt;
&lt;p&gt;这里有一个我这一年最难啃的点，就是傅里叶变换。&lt;/p&gt;
&lt;p&gt;整整花了我2-3个月时间，将所有开源的傅里叶变换看一遍。&lt;/p&gt;
&lt;p&gt;重新用c语言实现他们的思路，&lt;/p&gt;
&lt;p&gt;最后产出自用的傅里叶变换算法。&lt;/p&gt;
&lt;p&gt;这之间得到过一些朋友的帮助。&lt;/p&gt;
&lt;p&gt;当然主要是讨论，迸发思路。&lt;/p&gt;
&lt;p&gt;最重要的经验，莫过于，向成功者学习，向业内大牛学习。&lt;/p&gt;
&lt;p&gt;不论是开源项目还是资料论文。&lt;/p&gt;
&lt;p&gt;rnnoise这个开源项目，既然能得到很好的效果，&lt;/p&gt;
&lt;p&gt;那就证明有一些算法思路是可行的。&lt;/p&gt;
&lt;p&gt;只不过深度学习的方案，&lt;/p&gt;
&lt;p&gt;特征需要依赖数据去训练。&lt;/p&gt;
&lt;p&gt;弊端特别明显。&lt;/p&gt;
&lt;p&gt;不采用深度学习的方法去做，肯定可以。&lt;/p&gt;
&lt;p&gt;我一直坚信，只要有一个清晰的头脑，&lt;/p&gt;
&lt;p&gt;不需要依赖数据提取特征，&lt;/p&gt;
&lt;p&gt;理清楚算法的思想，也能达到一定的效果。&lt;/p&gt;
&lt;p&gt;就跟做图像算法一样，事实证明我是对的。&lt;/p&gt;
&lt;p&gt;毕竟曾经做过智能修图的算法，&lt;/p&gt;
&lt;p&gt;有一定的成功经验。&lt;/p&gt;
&lt;p&gt;在做音频算法的时候，&lt;/p&gt;
&lt;p&gt;就少走了不少弯路，&lt;/p&gt;
&lt;p&gt;基本上都不用写代码就能知道思路的可行性。&lt;/p&gt;
&lt;p&gt;如果不是有图像算法的积累和坚持，&lt;/p&gt;
&lt;p&gt;音频算法，&lt;/p&gt;
&lt;p&gt;真的不好啃。&lt;/p&gt;
&lt;p&gt;但是，我一直坚信，一切都会落到实处。&lt;/p&gt;
&lt;p&gt;千万不要偷懒，你偷的懒最后还是要补回来的。&lt;/p&gt;
&lt;p&gt;这个社会是很公平的，只有不努力的人才会觉得社会不公平。&lt;/p&gt;
&lt;p&gt;当然现在音频降噪算法还没达到我的最终要求。&lt;/p&gt;
&lt;p&gt;但是作为一个阶段性的成果而言，它已经达到了。&lt;/p&gt;
&lt;p&gt;欢迎大家试用，然后给我提需求也好，&lt;/p&gt;
&lt;p&gt;提bug也好，我会抽时间好好看看的。&lt;/p&gt;
&lt;p&gt;音频降噪算法 linux示例程序:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/cpuimage/denoise.zip&quot; target=&quot;_blank&quot;&gt;https://files.cnblogs.com/files/cpuimage/denoise.zip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我这个降噪算法真的算是集传统算法优点，RNN深度学习算法思路于一身。&lt;/p&gt;
&lt;p&gt;向rnnoise学了不少思路，致敬！&lt;/p&gt;
&lt;p&gt;整个算法实现不到200行，&lt;/p&gt;
&lt;p&gt;却同时拥有高速性能和不错的效果，&lt;/p&gt;
&lt;p&gt;鲁棒性极佳，&lt;/p&gt;
&lt;p&gt;内存占用也极低。&lt;/p&gt;
&lt;p&gt;并且支持实时帧算法，支持多通道。&lt;/p&gt;
&lt;p&gt;由此，大家也能看出来，我在这个算法上花了多少心血。&lt;/p&gt;
&lt;p&gt;下层建筑搭好了。&lt;/p&gt;
&lt;p&gt;之于图像，之于音频。&lt;/p&gt;
&lt;p&gt;还有很多工作要做，好多方向的问题还没攻克。&lt;/p&gt;
&lt;p&gt;路漫漫其修远兮。&lt;/p&gt;
&lt;p&gt;近三年的杀毒软件开发经验，&lt;/p&gt;
&lt;p&gt;不到2年图像算法经验，&lt;/p&gt;
&lt;p&gt;不到1年的音频算法经验。&lt;/p&gt;
&lt;p&gt;投过一些公司，&lt;/p&gt;
&lt;p&gt;看了我的学历，&lt;/p&gt;
&lt;p&gt;近些年的研究方向，&lt;/p&gt;
&lt;p&gt;短而杂。&lt;/p&gt;
&lt;p&gt;然后就说一句，&lt;/p&gt;
&lt;p&gt;学的东西太杂，&lt;/p&gt;
&lt;p&gt;经验不够，&lt;/p&gt;
&lt;p&gt;深度不够。&lt;/p&gt;
&lt;p&gt;人无完人，&lt;/p&gt;
&lt;p&gt;确实不想发表太多评论，&lt;/p&gt;
&lt;p&gt;我只做我自己。&lt;/p&gt;
&lt;p&gt;国内太浮躁了，&lt;/p&gt;
&lt;p&gt;从来没想过要跟谁去争什么。&lt;/p&gt;
&lt;p&gt;也不想评论谁好谁坏。&lt;/p&gt;
&lt;p&gt;是的，我本人开源的代码都很垃圾。&lt;/p&gt;
&lt;p&gt;那又怎么样呢，你有你的评论和观点。&lt;/p&gt;
&lt;p&gt;我有我的生活态度。&lt;/p&gt;
&lt;p&gt;有些人翻垃圾桶的习惯真不好。&lt;/p&gt;
&lt;p&gt;吃相太丑。&lt;/p&gt;
&lt;p&gt;没那个兴趣和精力去做讨论和点评，&lt;/p&gt;
&lt;p&gt;因为没有半点实际的意义。&lt;/p&gt;
&lt;p&gt;更多的精力用来学习成长和分享。&lt;/p&gt;
&lt;p&gt;独乐了不如众乐乐。&lt;/p&gt;
&lt;p&gt;希望以此结交一些有志之士，一起玩耍。&lt;/p&gt;
&lt;p&gt;吹吹水，唠唠嗑，打打吨。&lt;/p&gt;
&lt;p&gt;巴普诺夫，很忙，很忙。&lt;/p&gt;
&lt;p&gt;我还能睡，不要叫醒我。&lt;/p&gt;
&lt;p&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;
若有相关问题或者需求可以邮件联系俺探讨。&lt;/p&gt;
&lt;p&gt;有空回得快一些，没空可能就.......&lt;/p&gt;
&lt;p&gt;邮箱地址是: &lt;br/&gt;gaozhihan@vip.qq.com&lt;/p&gt;
</description>
<pubDate>Sat, 01 Dec 2018 18:37:00 +0000</pubDate>
<dc:creator>cpuimage</dc:creator>
<og:description>很快又一年过去了。 自学音频算法也近一年了。 不记得有多少个日日夜夜， 半夜醒来，就为验证算法思路。 一次又一次地改进和突破。 傻逼样的坚持，必然得到牛逼样的结果。 这一年，主要扎音频算法上。 经常有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cpuimage/p/10052022.html</dc:identifier>
</item>
<item>
<title>图片横向等高瀑布流，每行占满，限制行数 的实现 - -渔人码头-</title>
<link>http://www.cnblogs.com/imwtr/p/10051995.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imwtr/p/10051995.html</guid>
<description>&lt;p&gt;图片的横向瀑布流，其实简单地按顺序排列就可以了&lt;/p&gt;
&lt;p&gt;但要实现每行中各图片都等高（各行不一定等高，但每行里面等高），且每行都占满，就需要用到flex的特性了&lt;/p&gt;
&lt;p&gt;控制每行图片高度都一致，可能会影响图片的比例，所以不能简单暴力地设置高度，需要按比例来动态计算&lt;/p&gt;
&lt;p&gt;另外，如要限制图片展示的行数，则只需判断好每行总高度与容器总高度的关系即可&lt;/p&gt;
&lt;p&gt;这里就来实现一下这个小功能&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jsfiddle.net/37tf24no/1/&quot; target=&quot;_blank&quot;&gt;点我预览&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201812/688270-20181202003849914-1634425588.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;因为都是假数据的关系，图片的宽高值是随机数，并非原图宽高值，仅作参考&lt;/p&gt;
&lt;p&gt;看完上面那张大大的图，先想一下可以怎么实现..&lt;/p&gt;


&lt;p&gt;要实现每行都能够占满，需要用到 flex-grow 这个属性&lt;/p&gt;
&lt;p&gt;flex-grow基于flex-basis基准值来计算，而flex-basis则基于项目的width、min|max-width相关的值来计算，或者手动定义&lt;/p&gt;
&lt;p&gt;使用flex-grow可以分配按比例分配主轴的剩余空间&lt;/p&gt;
&lt;p&gt;如果有10张图片需要放置，第一行仅可以放置四张图片，剩余100px的空间，那么各图片的flex-grow可以直接配置成图片的宽度width值，即可很方便精准地分配好这剩余的空间&lt;/p&gt;
&lt;p&gt;第二行可以放五张图片，剩余N px的空间... 按照这种计算方式来铺满每一行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1 &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;get-latest-update&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;获取最近更新&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;img-items&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/template&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;img-item-tpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div class&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;img-item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;flex-grow: {{width}}; width: {{width}}px;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a href&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#/img/{{id}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;padding-top: {{paddingTop}}%;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img data&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{{src}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{{src}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;a&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;div&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面页面模板中，flex-grow 与 width的值一致，用以按比例分配每行剩余空间&lt;/p&gt;
&lt;p&gt;另外可以看到这里有个 padding-top 的百分比值&lt;/p&gt;
&lt;p&gt;我们都知道  padding-top 的百分比值是基于父元素的宽度来计算的，根据盒模型，一般这种计算方式是为了获取固定宽高比&lt;/p&gt;
&lt;p&gt;当父元素有宽度，但高度为0时，整体高度则由padding-top值来撑开，则父元素就有了一个设定的宽高比，&lt;/p&gt;
&lt;p&gt;同时我们将子元素（这里是图片）position值设置为absolute，宽高占满父元素，则子元素图片也有了一定的宽高比，实现按比例的图片缩放&lt;/p&gt;

&lt;p&gt;来看看对应的样式设置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;body &lt;/span&gt;{&lt;span&gt;
    background-color&lt;/span&gt;:&lt;span&gt; #f2f2f2&lt;/span&gt;;
}&lt;span&gt;

.get-latest-update &lt;/span&gt;{&lt;span&gt;
    font-size&lt;/span&gt;:&lt;span&gt; 20px&lt;/span&gt;;&lt;span&gt;
    cursor&lt;/span&gt;:&lt;span&gt; pointer&lt;/span&gt;;&lt;span&gt;
    
    &amp;gt; a {
        color&lt;/span&gt;:&lt;span&gt; #0183fd&lt;/span&gt;;&lt;span&gt;
        text-decoration&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;
    }&lt;span&gt;
}

.img-items &lt;/span&gt;{&lt;span&gt;
    display&lt;/span&gt;:&lt;span&gt; flex&lt;/span&gt;;&lt;span&gt;
    flex-wrap&lt;/span&gt;:&lt;span&gt; wrap&lt;/span&gt;;&lt;span&gt;
    overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;
}&lt;span&gt;

.img-item &lt;/span&gt;{&lt;span&gt;
    margin-right&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;&lt;span&gt;
    margin-bottom&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;&lt;span&gt;
    background-color&lt;/span&gt;:&lt;span&gt; #fff&lt;/span&gt;;&lt;span&gt;
    box-shadow&lt;/span&gt;:&lt;span&gt; 0 0 10px #ddd&lt;/span&gt;;&lt;span&gt;
    
    &amp;gt; a {
        position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
        display&lt;/span&gt;:&lt;span&gt; block&lt;/span&gt;;&lt;span&gt;
        width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;
    }&lt;span&gt;
    
    img &lt;/span&gt;{&lt;span&gt;
        position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
        top&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
        left&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
        width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
        height&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;
    }&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那么，这个width和padding-top的该怎么计算出来呢&lt;/p&gt;
&lt;p&gt;核心代码是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图片预定义的高度&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; baseHeight = 200&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 1; i &amp;lt;= num; ++&lt;span&gt;i) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; w =&lt;span&gt; getRandom(width.min, width.max);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; h =&lt;span&gt; getRandom(height.min, height.max);
        
        imgs.push({
            id: i,
            src: imgSrcBase[Math.floor(i &lt;/span&gt;/ 10)] + (i % 10 + 1) + '.jpg'&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置图片的宽度，需根据预定义的高度值来做好比例处理&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了让每行各图片按自身宽度自动flex-glow，同时利用这个比例处理保证每行图片的高度一致&lt;/span&gt;
            width: w * baseHeight /&lt;span&gt; h,        
            height: h,
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; padding-top的百分比，用以基于父元素宽度设置该元素的高度&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了保证图片宽高按比例&lt;/span&gt;
            paddingTop: h / w * 100&lt;span&gt;
        });
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;paddingTop的值，按照以下这个映射关系来看就好&lt;/p&gt;
&lt;p&gt;容器高度 == 容器宽度 * paddingTop %&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最终会形成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;容器高度 == 图片高度&lt;/p&gt;
&lt;p&gt;容器宽度 == 图片宽度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图片高度 == 图片宽度 * paddingTop %&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;width值的计算可能比较绕&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设这里 width直接取 图片宽度w值，就会出现一行中图片高度不一致的情况&lt;/p&gt;
&lt;p&gt;因为最终的图片高度即为容器的高度，而容器的高度是由容器宽度决定的（注意这里的paddingTop值已经确定），而容器宽度就是由这里的width来决定的。图片宽度的不同，就直接导致了最终高度的不同&lt;/p&gt;
&lt;p&gt;所以，为了确保图片高度一致，假设有三张图片 50*50  100*100  50*150  放在了同一行中，flex布局会将三张图片所在容器的高度自适应为最高的那个150，如果flex-grow值起作用了，这个最高值还会再多一些&lt;/p&gt;
&lt;p&gt;我们可以考虑最简单的情况，正好放满一行。那么最终三张图片的高度都应该为150，按照各自的图片比例来调整，则最终第一张图片宽度的计算  50 / 50 === width / 150 , 则 width = 50 / 50 * 150&lt;/p&gt;
&lt;p&gt;可能有些行最高的图片还是不够高，为了也能够显示出比较大的图片，我们还可以定义好这个基准高度值，比如 baseHeight设置为 200&lt;/p&gt;
&lt;p&gt;所以，最终每一张图片的宽度width值为 w / h * baseHeight&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201812/688270-20181202010852531-2048883315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 还要一个问题，如何实现只显示三行&lt;/p&gt;
&lt;p&gt;显示三行，每行的图片数量不固定，这是通过flex布局自动排列每一行的，都会经过 基本排列 -&amp;gt; 分配剩余空间 的步骤&lt;/p&gt;
&lt;p&gt;目前想到的方法是对每一行的容器所占位置进行累加，最后对比即可&lt;/p&gt;
&lt;p&gt;不过这种方式会有比较大的性能损耗，看还能不能有更优雅的做法吧&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置显示的图片行数&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; setLineLimit(num) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内容区宽度&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; contentWidth = $('.img-items'&lt;span&gt;).outerWidth();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义的外边距&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; marginWidth = 10&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每行宽度&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; curWidth = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 行标识&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; lineIndex = 1&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始需将图片设置为可见，否则flex无法自适应排版&lt;/span&gt;
    $('.img-item'&lt;span&gt;).show()
        .each(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; $item = $(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; itemWidth =&lt;span&gt; $item.outerWidth();
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 隐藏多余的行&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (lineIndex &amp;gt;&lt;span&gt; num) {
                $item.hide();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            
            $item.show();
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 某一行&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (curWidth + itemWidth + marginWidth &amp;lt;= contentWidth +&lt;span&gt; marginWidth) {
                curWidth &lt;/span&gt;+= itemWidth +&lt;span&gt; marginWidth;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下一行&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;++&lt;span&gt;lineIndex;
                curWidth &lt;/span&gt;=&lt;span&gt; itemWidth;
                
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lineIndex &amp;gt;&lt;span&gt; num) {
                    $item.hide();
                }
            }
        });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主要注意的点是，为了兼顾视窗缩放的过程中，自动排列也能照常进行，在计算的时候需要将每个项先显示出来，再进入计算环节&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 视窗缩放时处理可视的图片&lt;/span&gt;
$(window).resize(throttle(setLineLimit.bind(&lt;span&gt;this&lt;/span&gt;, 3), 200));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;完整JS代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c7ccf7b5-a818-4961-ab27-ffdf6e3da51b')&quot; readability=&quot;47&quot;&gt;&lt;img id=&quot;code_img_closed_c7ccf7b5-a818-4961-ab27-ffdf6e3da51b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c7ccf7b5-a818-4961-ab27-ffdf6e3da51b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c7ccf7b5-a818-4961-ab27-ffdf6e3da51b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c7ccf7b5-a818-4961-ab27-ffdf6e3da51b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;89&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 事件绑定&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; addEvent(elem, type, handler) {
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     elem.addEventListener(type, handler, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; qs(selector) {
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; document.querySelector(selector);
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; qsa(selectors) {
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; document.querySelectorAll(selectors);
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数节流，频繁操作中间隔 delay 的时间才处理一次&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; throttle(fn, delay) {
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     delay = delay || 200&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; timer = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每次滚动初始的标识&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; timestamp = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; 
&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; arg =&lt;span&gt; arguments;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; now =&lt;span&gt; Date.now();
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置开始时间&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (timestamp === 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;             timestamp =&lt;span&gt; now;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;        clearTimeout(timer);
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;         timer = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; 
&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 已经到了delay的一段时间，进行处理&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (now - timestamp &amp;gt;=&lt;span&gt; delay) {
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;             fn.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arg);
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;             timestamp =&lt;span&gt; now;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加定时器，确保最后一次的操作也能处理&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;             timer = setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;                 fn.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arg);
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 恢复标识&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;                 timestamp = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;            }, delay);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; 
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取随机数&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getRandom(min, max) {
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; Math.round(Math.random() * (max - min + 1) +&lt;span&gt; min);
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造图片数据&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; createMockImgs(num) {
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; imgs =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;     
&lt;span&gt; 59&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图片宽高数据范围&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; width =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         min: 50&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;         max: 200
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;     
&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; height =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;         min: 150&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         max: 300
&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;     
&lt;span&gt; 70&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图片源&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; imgSrcBase =&lt;span&gt; [
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;         'http://www.deskcar.com/desktop/movietv/2009/2009227225145/'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;         'http://www.deskcar.com/desktop/fengjing/2017418153624/'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;         'http://www.deskcar.com/desktop/fengjing/2017418153624/'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;         'http://www.deskcar.com/desktop/fengjing/2017418153624/'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         'http://www.deskcar.com/desktop/fengjing/2017418153624/'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;         'http://www.deskcar.com/desktop/else/20161228125639/'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;         'http://www.deskcar.com/desktop/fengjing/2017418153446/'
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;    ];
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;     
&lt;span&gt; 81&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图片预定义的高度&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; baseHeight = 200&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;     
&lt;span&gt; 84&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 1; i &amp;lt;= num; ++&lt;span&gt;i) {
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; w =&lt;span&gt; getRandom(width.min, width.max);
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; h =&lt;span&gt; getRandom(height.min, height.max);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;         
&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;        imgs.push({
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;            id: i,
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;             src: imgSrcBase[Math.floor(i / 10)] + (i % 10 + 1) + '.jpg'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置图片的宽度，需根据预定义的高度值来做好比例处理&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了让每行各图片按自身宽度自动flex-glow，同时利用这个比例处理保证每行图片的高度一致&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt;             width: w * baseHeight /&lt;span&gt; h,        
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;            height: h,
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; padding-top的百分比，用以基于父元素宽度设置该元素的高度&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了保证图片宽高按比例&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;             paddingTop: h / w * 100
&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;     
&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; imgs;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 视窗缩放时处理可视的图片&lt;/span&gt;
&lt;span&gt;105&lt;/span&gt; $(window).resize(throttle(setLineLimit.bind(&lt;span&gt;this&lt;/span&gt;, 3), 200&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置显示的图片行数&lt;/span&gt;
&lt;span&gt;108&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; setLineLimit(num) {
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内容区宽度&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; contentWidth = $('.img-items'&lt;span&gt;).outerWidth();
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义的外边距&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; marginWidth = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每行宽度&lt;/span&gt;
&lt;span&gt;114&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; curWidth = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 行标识&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; lineIndex = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;     
&lt;span&gt;118&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始需将图片设置为可见，否则flex无法自适应排版&lt;/span&gt;
&lt;span&gt;119&lt;/span&gt;     $('.img-item'&lt;span&gt;).show()
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;         .each(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; $item = $(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; itemWidth =&lt;span&gt; $item.outerWidth();
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;             
&lt;span&gt;124&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 隐藏多余的行&lt;/span&gt;
&lt;span&gt;125&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (lineIndex &amp;gt;&lt;span&gt; num) {
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;                $item.hide();
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;             
&lt;span&gt;130&lt;/span&gt; &lt;span&gt;            $item.show();
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;             
&lt;span&gt;132&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 某一行&lt;/span&gt;
&lt;span&gt;133&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (curWidth + itemWidth + marginWidth &amp;lt;= contentWidth +&lt;span&gt; marginWidth) {
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;                 curWidth += itemWidth +&lt;span&gt; marginWidth;
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下一行&lt;/span&gt;
&lt;span&gt;137&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;                 ++&lt;span&gt;lineIndex;
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;                 curWidth =&lt;span&gt; itemWidth;
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;                 
&lt;span&gt;141&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (lineIndex &amp;gt;&lt;span&gt; num) {
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt;                    $item.hide();
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; 
&lt;span&gt;148&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; mockImgs = createMockImgs(60&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; 
&lt;span&gt;150&lt;/span&gt; &lt;span&gt;console.log(mockImgs);
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; 
&lt;span&gt;152&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 点击渲染&lt;/span&gt;
&lt;span&gt;153&lt;/span&gt; addEvent(qs('.get-latest-update'), 'click', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; &lt;span&gt;    renderList(mockImgs);
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;     setLineLimit(3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; 
&lt;span&gt;158&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; itemTpl = qs('#img-item-tpl'&lt;span&gt;).innerHTML;
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; itemsDOM = qs('.img-items'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; 
&lt;span&gt;161&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; &lt;span&gt;* 渲染数据
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; &lt;span&gt;* @param  {[type]} data [description]
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; &lt;span&gt;* @return {[type]}      [description]
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;166&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; renderList(data) {
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; html = ''&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; fragment =&lt;span&gt; document.createDocumentFragment();
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; 
&lt;span&gt;170&lt;/span&gt;     data.forEach(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item) {
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; divTemp = document.createElement('div'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt; 
&lt;span&gt;173&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模板替换&lt;/span&gt;
&lt;span&gt;174&lt;/span&gt;         divTemp.innerHTML = itemTpl.replace(/{{(\w+)}}/g, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(input, match) {
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; match ? item[match] || '' : ''&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; 
&lt;span&gt;178&lt;/span&gt; &lt;span&gt;        fragment.appendChild(divTemp.firstElementChild);
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; 
&lt;span&gt;181&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 渲染&lt;/span&gt;
&lt;span&gt;182&lt;/span&gt; &lt;span&gt;    itemsDOM.appendChild(fragment);
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 01 Dec 2018 17:51:00 +0000</pubDate>
<dc:creator>-渔人码头-</dc:creator>
<og:description>图片的横向瀑布流，其实简单地按顺序排列就可以了 但要实现每行中各图片都等高（各行不一定等高，但每行里面等高），且每行都占满，就需要用到flex的特性了 控制每行图片高度都一致，可能会影响图片的比例，所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imwtr/p/10051995.html</dc:identifier>
</item>
<item>
<title>吻逗死(windows)系统下自动部署脚本(for java spring*)及linux命令行工具 - funnyZpC</title>
<link>http://www.cnblogs.com/funnyzpc/p/10051647.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/funnyzpc/p/10051647.html</guid>
<description>&lt;p&gt;转载请注明出处:&lt;a href=&quot;https://www.cnblogs.com/funnyzpc/p/10051647.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/funnyzpc/p/10051647.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(^&lt;/em&gt;^)(^&lt;em&gt;^)自動部署腳本原本在上個公司就在使用，由於近期同事需要手動部署一個SpringCloud應用，一邊是sftp軟件上傳，一邊是SourceCRT命令行工具，看這著實很累，就順手把我在上個公司寫的自動部署腳本share了他一份，以前n多行的命令現在只需要雙擊一下bat文件即可完全簡化複雜的坑人部署操作，額(⊙o⊙)…，其實對於自動部署，其實甲方那邊已經部署了一個Jenkins，不過部署Jenkins的人實在是菜。。。，竟然沒給多權限，導致部署只能用最高（administrator）權限部署~，每次部署還需要通知下甲方，實在是。。。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(^&lt;em&gt;^)(^&lt;/em&gt;^)对于在吻逗死系统下调用linux，纯命令行工具我找了下，大致分为两类：putty系列和GnuWin系列，前者稳健，同时提供图形化工具较为可手，对于纯命令行工具&lt;br/&gt;目前在官网能看得到的只有三个pscp、plink、psftp这三个，如果只是考虑上传下载和远程调用其实已经够了，若想要更丰富的工具请绕道进GnuWin，linux下绝大数类别的命令都有，还有对于linux熟练者，也推荐后者，毕竟跨系统，两种命令(shell和cmd)都要熟悉，学习成本有点儿高~&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;自动部署脚本应用putty系列&quot;&gt;1. 自动部署脚本应用：putty系列&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1161789/201812/1161789-20181202000054620-892912451.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本人为部署springboot应用写了个简易自动部署脚本，功能包含:&lt;br/&gt;- mvn自动清理打包&lt;br/&gt;- pscp命令上传&lt;br/&gt;- plink命令远程调用(linux下)shell脚本&lt;/li&gt;
&lt;li&gt;使用方法(参照&lt;a href=&quot;https://github.com/funnyzpc/autoDeploy/tree/master/%E5%90%BB%E9%80%97%E6%AD%BB(window)%E4%B8%8B%E9%83%A8%E7%BD%B2linux%E5%BA%94%E7%94%A8%E8%84%9A%E6%9C%AC&quot;&gt;github&lt;/a&gt;)&lt;br/&gt;- “deploy.cmd 参数一(应用目录,需要同jar包名称) 参数二(部署平台) 参数三(服务端应用目录)”&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;windows下unix命令行工具gnuwin系列&quot;&gt;2. (windows下)unix命令行工具：GnuWin系列&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1161789/201812/1161789-20181202000112881-1561275174.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;命令行工具包括：&lt;br/&gt;- 远程登陆 ssh&lt;br/&gt;- 远程复制 scp&lt;br/&gt;- 文件移动 mv&lt;br/&gt;- 目录权限 chmod&lt;br/&gt;- 目录创建 mkdir&lt;br/&gt;- 文件上传 sftp&lt;br/&gt;- 目录跳转 ls&lt;br/&gt;- 文件编辑 vi&lt;br/&gt;- 文件hash校验 md5&lt;br/&gt;- 文件压缩 zip&lt;br/&gt;- 文件解压 unzip&lt;br/&gt;- ...更多&lt;/li&gt;
&lt;li&gt;工具使用(具体使用同linux哈~)&lt;br/&gt;- 可配置为系统环境变量(path),可在目录位置使用&lt;br/&gt;- 可使用_目录+命令关键字_的方式使用&lt;br/&gt;- 具体使用请参照这里：&lt;a href=&quot;https://github.com/funnyzpc/autoDeploy/tree/master/%E5%90%BB%E9%80%97%E6%AD%BB(windows)%E4%B8%8Bunix%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7&quot;&gt;github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;(^&lt;/em&gt;^)(^&lt;em&gt;^)以上工具均放在我的github上，如需源码及更详细的使用说明，请走这里: &lt;a href=&quot;https://github.com/funnyzpc/autoDeploy&quot; class=&quot;uri&quot;&gt;https://github.com/funnyzpc/autoDeploy&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;现在是 2018-12-02 00:04 ,各位晚安~&lt;/p&gt;
&lt;blockquote readability=&quot;6.2686567164179&quot;&gt;
&lt;p&gt;Auther by funnyzpc,if you want watch more, please see me by &lt;a href=&quot;http://www.cnblogs.com/funnyzpc&quot;&gt;cnblogs&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 01 Dec 2018 16:17:00 +0000</pubDate>
<dc:creator>funnyZpC</dc:creator>
<og:description>转载请注明出处:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/funnyzpc/p/10051647.html</dc:identifier>
</item>
<item>
<title>【LeetCode题解】232_用栈实现队列（Implement-Queue-using-Stacks） - StrongXGP</title>
<link>http://www.cnblogs.com/xugenpeng/p/10051819.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xugenpeng/p/10051819.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;blockquote readability=&quot;4.4642857142857&quot;&gt;
&lt;p&gt;更多 LeetCode 题解笔记可以访问我的 &lt;a href=&quot;https://github.com/Genpeng/play-with-leetcode&quot;&gt;github&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用栈实现队列的下列操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;push(x) -- 将一个元素放入队列的尾部。&lt;/li&gt;
&lt;li&gt;pop() -- 从队列首部移除元素。&lt;/li&gt;
&lt;li&gt;peek() -- 返回队列首部的元素。&lt;/li&gt;
&lt;li&gt;empty() -- 返回队列是否为空。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);  
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你只能使用标准的栈操作 -- 也就是只有 &lt;code&gt;push to top&lt;/code&gt;, &lt;code&gt;peek/pop from top&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt;, 和 &lt;code&gt;is empty&lt;/code&gt; 操作是合法的。&lt;/li&gt;
&lt;li&gt;你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。&lt;/li&gt;
&lt;li&gt;假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;
&lt;p&gt;队列是一种先入先出（first in first out, FIFO）的数据结构，而栈是一种后入先出（last in first out, LIFO）的数据结构。因此，如果要使用栈来达到队列的效果，即用有后入先出性质的数据结构来实现先入先出的效果，需要借用两个栈来改变元素的出队顺序。当然，借用两个栈来实现队列也有不同的实现方式，这一节介绍第一种实现方式，在下一小节介绍第二种方式。&lt;/p&gt;
&lt;p&gt;第一种方式是&lt;u&gt;&lt;strong&gt;在一个栈中维持所有元素的出队顺序&lt;/strong&gt;&lt;/u&gt;，即所有的元素在入队操作完成后只会保存在一个栈中，且其出栈的顺序和出队的顺序是一致的。下面对入队、出队等操作的底层实现分别进行讲解。&lt;/p&gt;
&lt;h3 id=&quot;入队push&quot;&gt;入队（push）&lt;/h3&gt;
&lt;p&gt;为了实现出栈顺序和出队顺序是一致的，&lt;em&gt;入栈时必须将新的元素压入栈底&lt;/em&gt;。为了实现这种效果，在入队时，首先将栈1（假设栈1中保存所有的元素）中所有的元素弹出并压入栈2中，接着将新的元素压入栈1中，最后再将栈2中的所有弹出并压入栈1中。详细的步骤如图1所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181201235453535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gyNzM1OTE2NTU=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;small&gt;图1：将一个元素入队&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;代码（Java）实现如下。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void push(int x) {
    // 将栈1中的所有元素弹出并压入栈2中
    while (!s1.isEmpty()) {
        s2.push(s1.pop());
    }

    // 将新的元素压入栈1
    s1.push(x);

    // 将栈2的所有元素弹出并压入栈1
    while (!s2.isEmpty()) {
        s1.push(s2.pop());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复杂度分析如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;，其中 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 表示入队时队列元素的数目，即栈1中元素的数目。入队时，栈1中的元素需要进行出栈和入栈两次，需要 &lt;span class=&quot;math inline&quot;&gt;\(4n\)&lt;/span&gt; 次操作，再加上新的元素的一次入栈操作，总的操作次数为 &lt;span class=&quot;math inline&quot;&gt;\(4n + 1\)&lt;/span&gt; 次。由于栈的入栈和出栈的时间复杂度是 &lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt; 的，因此，入队的时间复杂度是 &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt; 的&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;出队pop&quot;&gt;出队（pop）&lt;/h3&gt;
&lt;p&gt;出队操作比较简单，由于栈1中元素的出栈顺序和队列的出队顺序一致，因此，只需要弹出栈顶元素即可完成出队操作。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public int pop() {
    if (s1.isEmpty()) {
        throw new IllegalArgumentException(&quot;[ERROR] The queue is empty!&quot;);
    }

    return s1.pop();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复杂度分析如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;查看队首peek&quot;&gt;查看队首（peek）&lt;/h3&gt;
&lt;p&gt;与出队操作类似，只需要查看栈1栈顶的元素即可完成查看队首的操作。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public int peek() {
    if (s1.isEmpty()) {
        throw new IllegalArgumentException(&quot;[ERROR] The queue is empty!&quot;);
    }

    return s1.peek();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复杂度分析如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;是否为空empty&quot;&gt;是否为空（empty）&lt;/h3&gt;
&lt;p&gt;由于栈1中保存队列的所有元素，因此只需要判断栈1是否为空即可知道队列是否为空。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public boolean empty() {
    return s1.isEmpty();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复杂度分析如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;java-实现&quot;&gt;Java 实现&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class MyQueue {
    private Stack&amp;lt;Integer&amp;gt; s1;
    private Stack&amp;lt;Integer&amp;gt; s2;

    /** Initialize your data structure here. */
    public MyQueue() {
        s1 = new Stack&amp;lt;&amp;gt;();
        s2 = new Stack&amp;lt;&amp;gt;();
    }

    /** Push element x to the back of queue. */
    public void push(int x) {
        while (!s1.isEmpty()) {
            s2.push(s1.pop());
        }
        s1.push(x);
        while (!s2.isEmpty()) {
            s1.push(s2.pop());
        }
    }

    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        if (s1.isEmpty()) {
            throw new IllegalArgumentException(&quot;[ERROR] The queue is empty!&quot;);
        }

        return s1.pop();
    }

    /** Get the front element. */
    public int peek() {
        if (s1.isEmpty()) {
            throw new IllegalArgumentException(&quot;[ERROR] The queue is empty!&quot;);
        }

        return s1.peek();
    }

    /** Returns whether the queue is empty. */
    public boolean empty() {
        return s1.isEmpty();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;python-实现&quot;&gt;Python 实现&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class MyQueue:
    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self._s1, self._s2 = [], []
        
    def push(self, x):
        &quot;&quot;&quot;
        Push element x to the back of queue.
        :type x: int
        :rtype: void
        &quot;&quot;&quot;
        while self._s1:
            self._s2.append(self._s1.pop())  
        self._s1.append(x)
        while self._s2:
            self._s1.append(self._s2.pop())

    def pop(self):
        &quot;&quot;&quot;
        Removes the element from in front of queue and returns that element.
        :rtype: int
        &quot;&quot;&quot;
        return self._s1.pop()

    def peek(self):
        &quot;&quot;&quot;
        Get the front element.
        :rtype: int
        &quot;&quot;&quot;
        return self._s1[-1]

    def empty(self):
        &quot;&quot;&quot;
        Returns whether the queue is empty.
        :rtype: bool
        &quot;&quot;&quot;
        return not self._s1&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;思路-1&quot;&gt;思路&lt;/h2&gt;
&lt;p&gt;解法二的实现方式与解法一有点不同，按照功能的不同，解法二将&lt;u&gt;&lt;strong&gt;两个栈一个用于入队，一个用于出队&lt;/strong&gt;&lt;/u&gt;。假设栈 &lt;code&gt;inStack&lt;/code&gt; 用于实现入队操作，栈 &lt;code&gt;outStack&lt;/code&gt; 用于实现出队操作。下面对入队、出队等操作的底层实现分别进行讲解。&lt;/p&gt;
&lt;h3 id=&quot;入队push-1&quot;&gt;入队（push）&lt;/h3&gt;
&lt;p&gt;入队操作比较简单，直接将新的元素压入栈 &lt;code&gt;inStack&lt;/code&gt; 中，同时，对于第一个进入栈中的元素，我们用一个变量 &lt;code&gt;front&lt;/code&gt; 保存起来，用于表示栈 &lt;code&gt;inStack&lt;/code&gt; 这个队列的队首。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/** Push element x to the back of queue. */
public void push(int x) {
    if (inStack.empty()) {
        front = x;
    }
    inStack.push(x);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复杂度分析如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;，需要额外的空间用于存储队列元素&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;出队pop-1&quot;&gt;出队（pop）&lt;/h3&gt;
&lt;p&gt;在入队时，由于先入的元素处于输入栈 &lt;code&gt;inStack&lt;/code&gt; 的栈底，因此，为了能够弹出栈底的元素实现出队操作，需要将输入栈 &lt;code&gt;inStack&lt;/code&gt; 中的元素弹出并压入到输出栈 &lt;code&gt;outStack&lt;/code&gt; 中。此时，输出栈 &lt;code&gt;outStack&lt;/code&gt; 中元素的出栈顺序和队列的出队顺序是一致的。只要输出栈 &lt;code&gt;outStack&lt;/code&gt; 中还有元素，每次执行出队操作只需要将栈 &lt;code&gt;outStack&lt;/code&gt; 的栈顶元素弹出即可。当输出栈 &lt;code&gt;outStack&lt;/code&gt; 为空时，执行出队操作则需要先将输入栈 &lt;code&gt;inStack&lt;/code&gt; 中的元素弹出并压入输出栈。详细的步骤如图2所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181201235621214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gyNzM1OTE2NTU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;small&gt;图2：将一个元素出队&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;代码（Java）实现如下。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/** Removes the element from in front of queue and returns that element. */
public int pop() {
    if (empty()) {
        throw new IllegalArgumentException(&quot;[ERROR] The queue is empty!&quot;);
    }

    if (outStack.isEmpty()) {
        while (!inStack.isEmpty()) {
            outStack.push(inStack.pop());
        }
    }
    return outStack.pop();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复杂度分析如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：均摊时间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;，最坏情况下，时间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;，更为详细的均摊复杂度分析可以查看&lt;a href=&quot;https://leetcode.com/articles/implement-queue-using-stacks/?page=2&quot;&gt;官网的文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;查看队首peek-1&quot;&gt;查看队首（peek）&lt;/h3&gt;
&lt;p&gt;与出队操作类似，当输出栈 &lt;code&gt;outStack&lt;/code&gt; 不为空时，只需要返回输出栈 &lt;code&gt;outStack&lt;/code&gt; 的栈顶元素即可。不同的是，由于我们用变量 &lt;code&gt;front&lt;/code&gt; 存储了输入栈最先进入的元素，因此，当输出栈 &lt;code&gt;outStack&lt;/code&gt; 为空时，不需要再将输入栈 &lt;code&gt;inStack&lt;/code&gt; 的元素弹出并压入到输出栈 &lt;code&gt;outStack&lt;/code&gt; 中便可以得到当前队首的元素。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/** Get the front element. */
public int peek() {
    if (empty()) {
        throw new IllegalArgumentException(&quot;[ERROR] The queue is empty!&quot;);
    }

    if (!outStack.isEmpty()) {
        return outStack.peek();
    } else {
        return front;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复杂度分析如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;，借助于变量 &lt;code&gt;front&lt;/code&gt;，可以使得 &lt;code&gt;peek&lt;/code&gt; 操作在任意情况下都是 &lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt; 的时间复杂度&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;是否为空empty-1&quot;&gt;是否为空（empty）&lt;/h3&gt;
&lt;p&gt;由于两个都有可以存在元素，因此，要判断队列是否为空，需要同时判断两个栈。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/** Returns whether the queue is empty. */
public boolean empty() {
    return inStack.isEmpty() &amp;amp;&amp;amp; outStack.isEmpty();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复杂度分析如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;java-实现-1&quot;&gt;Java 实现&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class MyQueue {
    /**
     * The stack used to implement enqueue functionality
     */
    private Stack&amp;lt;Integer&amp;gt; inStack;
    /**
     * The stack used to implement dequeue functionality
     */
    private Stack&amp;lt;Integer&amp;gt; outStack;
    /**
     * The front element in the stack `inStack` 's queue
     */
    private int front;

    /** Initialize your data structure here. */
    public MyQueue2() {
        inStack = new Stack&amp;lt;&amp;gt;();
        outStack = new Stack&amp;lt;&amp;gt;();
    }

    /** Push element x to the back of queue. */
    public void push(int x) {
        if (inStack.empty()) {
            front = x;
        }
        inStack.push(x);
    }

    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        if (empty()) {
            throw new IllegalArgumentException(&quot;[ERROR] The queue is empty!&quot;);
        }

        if (outStack.isEmpty()) {
            while (!inStack.isEmpty()) {
                outStack.push(inStack.pop());
            }
        }
        return outStack.pop();
    }

    /** Get the front element. */
    public int peek() {
        if (empty()) {
            throw new IllegalArgumentException(&quot;[ERROR] The queue is empty!&quot;);
        }

        if (!outStack.isEmpty()) {
            return outStack.peek();
        } else {
            return front;
        }
    }

    /** Returns whether the queue is empty. */
    public boolean empty() {
        return inStack.isEmpty() &amp;amp;&amp;amp; outStack.isEmpty();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;python-实现-1&quot;&gt;Python 实现&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class MyQueue:

    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self._in_stack, self._out_stack, self._front = [], [], None
        
    def push(self, x):
        &quot;&quot;&quot;
        Push element x to the back of queue.
        :type x: int
        :rtype: void
        &quot;&quot;&quot;
        if not self._in_stack:
            self._front = x
        self._in_stack.append(x)

    def pop(self):
        &quot;&quot;&quot;
        Removes the element from in front of queue and returns that element.
        :rtype: int
        &quot;&quot;&quot;
        if self.empty():
            raise Exception(&quot;[ERROR] The queue is empty!&quot;)
            
        if not self._out_stack:
            while self._in_stack:
                self._out_stack.append(self._in_stack.pop())
        return self._out_stack.pop()

    def peek(self):
        &quot;&quot;&quot;
        Get the front element.
        :rtype: int
        &quot;&quot;&quot;
        if self.empty():
            raise Exception(&quot;[ERROR] The queue is empty!&quot;)
            
        if not self._out_stack:
            return self._front
        else:
            return self._out_stack[-1]
        

    def empty(self):
        &quot;&quot;&quot;
        Returns whether the queue is empty.
        :rtype: bool
        &quot;&quot;&quot;
        return not self._in_stack and not self._out_stack&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 01 Dec 2018 15:58:00 +0000</pubDate>
<dc:creator>StrongXGP</dc:creator>
<og:description>更多 LeetCode 题解笔记可以访问我的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xugenpeng/p/10051819.html</dc:identifier>
</item>
<item>
<title>HttpURLConnection 实现get提交 - 梦想战士</title>
<link>http://www.cnblogs.com/mmtBlog/p/10051753.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mmtBlog/p/10051753.html</guid>
<description>&lt;p&gt;package com.mmt.test.urlConnection;&lt;/p&gt;
&lt;p&gt;import java.io.ByteArrayOutputStream;&lt;br/&gt;import java.io.IOException;&lt;br/&gt;import java.io.InputStream;&lt;br/&gt;import java.io.StreamTokenizer;&lt;br/&gt;import java.net.HttpURLConnection;&lt;br/&gt;import java.net.URL;&lt;/p&gt;
&lt;p&gt;public class URLConnection_GET {&lt;/p&gt;&lt;p&gt;public static void main(String args[]){&lt;br/&gt;String urlPath = &quot;http://www.besti.edu.cn&quot;;&lt;br/&gt;String encodeType = &quot;UTF-8&quot;;&lt;br/&gt;String resultString = getWEBPageContentByURLPath(urlPath, encodeType);&lt;br/&gt;System.out.println(resultString);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public static String getWEBPageContentByURLPath(String urlPath,String encodeType){&lt;br/&gt;String resultString = null ;&lt;/p&gt;&lt;p&gt;InputStream inputStream = getInputStreamByURLPath(urlPath, encodeType);&lt;br/&gt;resultString = streamToString(inputStream, encodeType);&lt;br/&gt;return resultString ;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;private static InputStream getInputStreamByURLPath(String urlPath,String encodeType){&lt;/p&gt;&lt;p&gt;InputStream inputStream = null ;&lt;br/&gt;URL url = null ;&lt;br/&gt;try {&lt;br/&gt;url = new URL(urlPath );&lt;/p&gt;&lt;p&gt;HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection();&lt;br/&gt;httpURLConnection.setConnectTimeout(3000);&lt;br/&gt;httpURLConnection.setDoInput(true);&lt;br/&gt;httpURLConnection.setRequestMethod(&quot;GET&quot;);&lt;/p&gt;&lt;p&gt;int responseCode = httpURLConnection.getResponseCode();&lt;br/&gt;if(responseCode ==200){&lt;br/&gt;inputStream = httpURLConnection.getInputStream();&lt;br/&gt;}&lt;br/&gt;} catch (Exception e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;return inputStream ;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;private static String streamToString(InputStream inputStream,String encodeType){&lt;br/&gt;String resultString = null ;&lt;/p&gt;&lt;p&gt;ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();&lt;br/&gt;int len = 0;&lt;br/&gt;byte data[]=new byte[1024];&lt;br/&gt;try {&lt;br/&gt;while((len=inputStream.read(data))!=-1){&lt;br/&gt;byteArrayOutputStream.write(data,0,len);&lt;br/&gt;}&lt;br/&gt;byte[]allData = byteArrayOutputStream.toByteArray();&lt;br/&gt;resultString = new String(allData,encodeType);&lt;br/&gt;} catch (IOException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;return resultString ;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
</description>
<pubDate>Sat, 01 Dec 2018 15:48:00 +0000</pubDate>
<dc:creator>梦想战士</dc:creator>
<og:description>package com.mmt.test.urlConnection; import java.io.ByteArrayOutputStream;import java.io.IOException;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mmtBlog/p/10051753.html</dc:identifier>
</item>
<item>
<title>nginx解析漏洞，配置不当，目录遍历漏洞复现 - 晓枫v5</title>
<link>http://www.cnblogs.com/hackxf/p/10051732.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hackxf/p/10051732.html</guid>
<description>&lt;h3 id=&quot;nginx解析漏洞配置不当目录遍历漏洞复现&quot;&gt;nginx解析漏洞，配置不当，目录遍历漏洞复现&lt;/h3&gt;
&lt;h4 id=&quot;ubuntu14.04安装nginx-php5-fpm&quot;&gt;1.Ubuntu14.04安装nginx-php5-fpm&lt;/h4&gt;
&lt;p&gt;安装了nginx，需要安装以下依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo apt-get install libpcre3 libpcre3-dev
sudo apt-get install zlib1g.dev
sudo apt-get install libssl-dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装php：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;apt-get install php5-fpm&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;apt-get install nginx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开启&lt;strong&gt;Nginx对php的支持&lt;/strong&gt;，去掉配置文件中关于php的注释并重启Nginx即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim /etc/nginx/sites-available/default&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181128235050419-1085108164.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;nginx网站目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/usr/share/nginx/html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181128235703558-78496602.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;nginx解析php&quot;&gt;nginx解析php&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;nginx无法启动可以查看日记查找解决方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim /var/log/nginx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129000043402-1783933872.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问php文件403&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在/etc/php5/fpm/pool.d/www.conf中编辑
listen = /var/run/php5-fpm.sock为127.0.0.1:9000

在/etg/nginx/sites-available/**.conf中编辑
fastcgi_pass/var/run/php5-fpm.sock为127.0.0.1:9000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后重启nginx,php5-fpm即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;重启服务命令
service php5-fpm restart
service nginx restart&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129000510403-203499008.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;nginx的文件解析漏洞复现&quot;&gt;2.Nginx的文件解析漏洞复现&lt;/h4&gt;
&lt;p&gt;如果在访问test.jpg这个文件时以这种去访问/test.jpg/1.php，可能会被当做PHP代码去执行&lt;/p&gt;
&lt;p&gt;用户配置不当造成的解析漏洞。 我们现在进行不当配置实现解析漏洞&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim /etc/php5/fpm/php.ini
修改cgi.fix_pathinfo为1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129001719662-292856967.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim /etc/php5/fpm/pool.d/www.conf
修改security.limit_extensions允许解析其他格式文件为PHP&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129001922424-902834985.png&quot;/&gt;&lt;br/&gt;解析漏洞成功&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129002007870-872967856.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129002023024-342285575.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;nginx目录遍历漏洞&quot;&gt;3.Nginx目录遍历漏洞&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;vim /etc/nginx/sites-available/default&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在location这里加上&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;autoindex on;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129002850021-940684083.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129002920580-1094199487.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;nginx目录穿越漏洞&quot;&gt;4.nginx目录穿越漏洞&lt;/h4&gt;
&lt;p&gt;Nginx在配置别名（Alias）的时候，如果忘记加/，将造成一个目录穿越漏洞。&lt;/p&gt;
&lt;p&gt;错误的配置文件示例（原本的目的是为了让用户访问到/home/目录下的文件）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;location /files {
    alias /home/;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129102739403-439895723.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129102806472-672050090.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129102825882-1444736927.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;==遇到的坑==&lt;/p&gt;
&lt;h4 id=&quot;docker为什么刚运行就退出了&quot;&gt;5.Docker为什么刚运行就退出了&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;docker run -d -p 80:80 ubuntu&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行了一个简单的容器后,然后docker ps -a 进行查看, 会发现容器已经退出&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275435/201811/1275435-20181129105111136-1422161505.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很重要的要说明的一点: &lt;strong&gt;Docker容器后台运行,就必须有一个前台进程.&lt;/strong&gt;&lt;br/&gt;容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的&lt;br/&gt;这个是docker的机制问题,比如你的web容器,我们以nginx和fpm为例,&lt;br/&gt;正常情况下,我们配置启动服务只需要启动响应的service即可,例如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;service nginx start &amp;amp;&amp;amp; service php5-fpm start&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是,这样做,nginx和fpm均为后台进程模式运行,就导致docker前台没有运行的应用,&lt;br/&gt;这样的容器,后台启动后,会立即自杀,因为他觉得他没事可做了.&lt;/p&gt;
&lt;p&gt;解决方法:&lt;br/&gt;1.最佳的解决方案是,将你要运行的程序以前台进程的形式运行,当然,如果你的容器需要同时启动多个进程,&lt;br/&gt;那么也只需要,或者说只能将其中一个挂起到前台即可.&lt;br/&gt;比如上面所说的web容器,我们只需要将启动指令修改为:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;service php5-fpm start &amp;amp;&amp;amp; nginx -g &quot;daemon off;&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样,fpm会在容器中以后台进程的方式运行,而nginx则挂起进程至前台运行,这样,就可以保持容器不会认为没事可做而自杀了.&lt;/p&gt;
&lt;p&gt;2.对于有一些你可能不知道怎么前台运行的程序,提供一个投机方案,你只需要在你启动的命令之后,&lt;br/&gt;添加类似于 tail top 这种可以前台运行的程序,这里特别推荐 tail ,然后持续输出你的log文件.&lt;br/&gt;还是以上文的web容器为例,我们还可以写成:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;service nginx start &amp;amp;&amp;amp; service php5-fpm start &amp;amp;&amp;amp; tail -f /var/log/nginx/error.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把这条命令加到start.sh实现自启&lt;/p&gt;
&lt;p&gt;参考链接&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/13d5912a6417&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/13d5912a6417&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/qq_32434307/article/details/79480036&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/qq_32434307/article/details/79480036&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/wang_quan_li/article/details/48003811&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/wang_quan_li/article/details/48003811&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://vulhub.org/#/environments/nginx/nginx_parsing_vulnerability/&quot; class=&quot;uri&quot;&gt;https://vulhub.org/#/environments/nginx/nginx_parsing_vulnerability/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 01 Dec 2018 15:45:00 +0000</pubDate>
<dc:creator>晓枫v5</dc:creator>
<og:description>nginx解析漏洞，配置不当，目录遍历漏洞复现 1.Ubuntu14.04安装nginx php5 fpm 安装了nginx，需要安装以下依赖 安装php： 开启 Nginx对php的支持 ，去掉配置</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hackxf/p/10051732.html</dc:identifier>
</item>
<item>
<title>错误的理解引起的bug async await 执行顺序 - 风吹De麦浪</title>
<link>http://www.cnblogs.com/CandyManPing/p/10041941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CandyManPing/p/10041941.html</guid>
<description>&lt;p&gt;今天有幸好碰到一个bug，让我知道了之前我对await async 的理解有点偏差。&lt;/p&gt;

&lt;p&gt;之前我一直以为  await 后面的表达式，如果是直接返回一个具体的值就不会等待，而是继续执行async function 中的函数， 如下demo：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; method () {
    getParams () {
      let params &lt;/span&gt;=&lt;span&gt; {}
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.serachFrom.time !== 0&lt;span&gt;) {
        params.month &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.serachFrom.time.substr(5, 2&lt;span&gt;)
        params.year &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.serachFrom.time.substring(0, 4&lt;span&gt;)
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; params
    },
    async testNoAwait () {
      console.log(&lt;/span&gt;'run testNoAwait'&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'this is no await'&lt;span&gt;
    },
    async testAsync () {
      console.log(&lt;/span&gt;'run testAsync'&lt;span&gt;)
      let params &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getParams()
      const data &lt;/span&gt;= await &lt;span&gt;this&lt;/span&gt;.$store.dispatch('initSchemeTimeTest'&lt;span&gt;, params)
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
    },
    async test () {
      console.log(&lt;/span&gt;'test start'&lt;span&gt;)
      const v1 &lt;/span&gt;= await &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.testNoAwait()
      console.log(v1)
      const v2 &lt;/span&gt;= await &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.testAsync()
      console.log(v2)
      console.log(v1, v2)
    }
},
 created () {
    console.log(&lt;/span&gt;'this is run created '&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.test()
    console.log(&lt;/span&gt;'test last ...'&lt;span&gt;)
    console.log(&lt;/span&gt;'test end ...'&lt;span&gt;)
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;如上程序我之前认为   await this.testNoAwait() 会直接执行完不会等待，继续执行   console.log(v1)，如果这样那么是一个错误的理解。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际上MDN描述的暂停执行，并不是真正的暂停，而是&lt;strong&gt;让出了线程（跳出async函数体）&lt;/strong&gt;然后继续执行后面的语句。&lt;/p&gt;

&lt;h2&gt;vue  created &lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;async created () {
    console.log(&lt;/span&gt;'this is run created '&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.test()
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; let data = this.test()&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(data)&lt;/span&gt;
    console.log('test last ...'&lt;span&gt;)
    console.log(&lt;/span&gt;'test end ...'&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.testSayHello()
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;vue  methods &lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;testSayHello () {
      console.log(&lt;/span&gt;'this is run hello'&lt;span&gt;)
    },
    getParams () {
      let params &lt;/span&gt;=&lt;span&gt; {}
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.serachFrom.time !== 0&lt;span&gt;) {
        params.month &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.serachFrom.time.substr(5, 2&lt;span&gt;)
        params.year &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.serachFrom.time.substring(0, 4&lt;span&gt;)
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; params
    },
    testNoAwait () {
      console.log(&lt;/span&gt;'run testNoAwait'&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'this is no await'&lt;span&gt;
    },
    async testAsync () {
      console.log(&lt;/span&gt;'run testAsync'&lt;span&gt;)
      let params &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getParams()
      const data &lt;/span&gt;= await &lt;span&gt;this&lt;/span&gt;.$store.dispatch('initSchemeTimeTest'&lt;span&gt;, params)
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
    },
    async test () {
      console.log(&lt;/span&gt;'test start'&lt;span&gt;)
      const v1 &lt;/span&gt;= await &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.testNoAwait()
      console.log(v1)
      const v2 &lt;/span&gt;= await &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.testAsync()
      console.log(v2)
      console.log(v1, v2)
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;vuex 中&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// actions&lt;br/&gt;async initSchemeTimeTest ({commit, state, dispatch}, params) {
    console.log(&lt;/span&gt;'run initSchemeTimeTest'&lt;span&gt;)
    const data &lt;/span&gt;=&lt;span&gt; await schemeListTest(params)
    console.log(&lt;/span&gt;'开始返回结果'&lt;span&gt;)
    commit(types.SCHEME_DATA_TIME_LIST, data)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;services api 中&lt;/h2&gt;
&lt;p&gt;注意在 testAsync 中  dispatch 了 initSchemeTimeTest，然后在调用了服务端的 schemeListTest&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
export async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; schemeListTest (params) {
  console.log(&lt;/span&gt;'this is run server'&lt;span&gt;)
  const data &lt;/span&gt;= await postTest(`/provid/spot/dailydeclareschemestatus/&lt;span&gt;list`, params)
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;common 中封装的 axiosServer &lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;function&lt;/span&gt;&lt;span&gt; postTest (url, params) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(async (resolve, reject) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      console.log(&lt;/span&gt;'this is run common'&lt;span&gt;)
      const {
        data:
          {
            respHeader,
            respBody
          }
      } &lt;/span&gt;=&lt;span&gt; await axiosServer({
        url,
        type: &lt;/span&gt;'post'&lt;span&gt;,
        params: {
          reqBody: params
        }
      })
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (respHeader.needLogin &amp;amp;&amp;amp; process.env.NODE_ENV !== 'development'&lt;span&gt;) {
        Message.error(respHeader.message)
        location.href &lt;/span&gt;= condition.frontDomain + `/login?redirect=${encodeURI(condition.frontDomain + '/spot/race')}`
&lt;span&gt;        reject(respHeader.message)
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (respHeader.resultCode === 0&lt;span&gt;) {
        resolve(respBody &lt;/span&gt;||&lt;span&gt; respHeader.message)
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (respHeader.resultCode === 21050 &amp;amp;&amp;amp;&lt;span&gt; respBody) {
          Message.error(respHeader.message)
          resolve(respBody)
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (respHeader.message === '您没有该应用的权限'&lt;span&gt;) {
          location.href &lt;/span&gt;= 'frame.huidiancloud.com'&lt;span&gt;
        }  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          Message.error(respHeader.message)
          reject(respHeader.message)
        }
      }
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
      reject(e)
      Message.error(&lt;/span&gt;'系统繁忙，请稍后再试！'&lt;span&gt;)
    }
  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果按照之前的理解那么这个应该是输出了 run testNoAwait  之后继续输出  this is no await 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/825196/201811/825196-20181130225158306-1495585640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;js是单线程（同时只能干一件事情），&lt;/p&gt;
&lt;p&gt;以上测试的关键点在于当程序碰到await 时，把后面的表达式执行一次，然后把&lt;span&gt;resolve 函数或者reject 函数&lt;/span&gt;&lt;span&gt;（await 操作符会把表达式的结果解析成promise 对象） push 回调队列&lt;/span&gt;，接着跳过当前这个async function ，执行async function 后面的代码，如上面代码中，执行 this.testNoAwait() 之后就跳过 this.test()这个方法，执行了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
console.log('test last ...'&lt;span&gt;)
console.log(&lt;/span&gt;'test end ...'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.testSayHello()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至于什么时候知道这个promise 对象的状态，这就是事件循环的事情了，监听到这个异步的状态事件改变时，如果执行环境栈是空的那么就会执行取出回调队列中的回调，推入执行环境栈，然后继续async function 后面的语句。&lt;/p&gt;
&lt;p&gt;vue 开始执行created 生命周期&lt;/p&gt;
&lt;p&gt;输出：this is run created&lt;/p&gt;
&lt;p&gt;输出：test start &lt;/p&gt;
&lt;p&gt;执行：testNoAwait  // &lt;span&gt;关键&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输出 ：run testNoAwait 之后 &lt;span&gt;跳过 test() 函数 执行created 后面的语句&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输出：test last ... 、test end ... 、this is run hello &lt;/p&gt;
&lt;p&gt;程序回到&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const v1 = await &lt;span&gt;this&lt;/span&gt;.testNoAwait()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果监听到这个异步事件完成 则开始执行 后面的代码所以会&lt;/p&gt;
&lt;p&gt;输出：this is no await&lt;/p&gt;
&lt;p&gt; 下面这个 await 跟上面同理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const v2 = await &lt;span&gt;this&lt;/span&gt;.testAsync()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;await 后面的表达式执行一次，如果里面存在await 也是同理继续执行下去，执行完之后，跳过这个async function 等到异步操作完成了继续回到 const v2 这里执行。&lt;/p&gt;
&lt;p&gt;这里需要注意的是在common 中的postTest 中&lt;span&gt;构造的Promise 对象是立即执行传入的function&lt;/span&gt; 所以在 services api 输出了 this is run server  之后接着输出 this is run common&lt;/p&gt;
&lt;p&gt;因为上面的列子不是很方便看，所以我写了一个简单的测试 ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; name=&quot;viewport&quot;&amp;gt;
  &amp;lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&amp;gt;
  &amp;lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&amp;gt;
  &amp;lt;meta content=&quot;telephone=no,email=no&quot; name=&quot;format-detection&quot;&amp;gt;
  &amp;lt;meta name=&quot;App-Config&quot; content=&quot;fullscreen=yes,useHistoryState=yes,transition=yes&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&amp;gt;
  &amp;lt;title&amp;gt;async await demo&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;h1&amp;gt;async await demo&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;

  async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; async1() {
    console.log(&lt;/span&gt;'async1 start'&lt;span&gt;)
    await async2()
    console.log(&lt;/span&gt;'async1 end'&lt;span&gt;)
  }
  async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; async2() {
    console.log(&lt;/span&gt;'async2'&lt;span&gt;)
    await async3()
  }
  async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; async3() {
    console.log(&lt;/span&gt;'async3'&lt;span&gt;)
    await async4()
    console.log(&lt;/span&gt;'async4 end'&lt;span&gt;)
  }
  async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; async4() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve, reject) {
    console.log(&lt;/span&gt;'async4'&lt;span&gt;)
    resolve()
  })
  }
  console.log(&lt;/span&gt;'script start'&lt;span&gt;)
  setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    console.log(&lt;/span&gt;'setTimeout'&lt;span&gt;)
  }, &lt;/span&gt;0&lt;span&gt;)
  async1();
  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve) {
    console.log(&lt;/span&gt;'promise1'&lt;span&gt;)
    resolve();
  }).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    console.log(&lt;/span&gt;'promise2'&lt;span&gt;)
  })
  console.log(&lt;/span&gt;'script end'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; script start async1 start async2 async3 async4 promise1  script end promise2 async4 end async1 end setTimeout&lt;/span&gt;

&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;&lt;li&gt;事件循环机制&lt;/li&gt;
&lt;li&gt;回调队列&lt;/li&gt;
&lt;li&gt;执行环境栈、入栈、出栈&lt;/li&gt;
&lt;li&gt;Promise 的构造函数是立即执行，但是他的成功、失败的回调函数是一个异步执行的回调&lt;/li&gt;
&lt;li&gt;Promise 的回调优先于 setTimeout 的任务队列&lt;/li&gt;
&lt;li&gt;async 返回promise 对象&lt;/li&gt;
&lt;li&gt;await 表达式的作用和返回值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1、js 是单线程（同时只能做一件事情），在js引擎内部异步的处理是跟事件循环机制、以及回调队列有关&lt;/p&gt;
&lt;p&gt;2、构造的promise 对象是立即执行传入的function&lt;/p&gt;
&lt;p&gt;3、async function 是返回一个promise 对象&lt;/p&gt;
&lt;p&gt;4、await 操作符会把表达式的结果进行解析成promise 对象&lt;/p&gt;

</description>
<pubDate>Sat, 01 Dec 2018 15:22:00 +0000</pubDate>
<dc:creator>风吹De麦浪</dc:creator>
<og:description>今天有幸好碰到一个bug，让我知道了之前我对await async 的理解有点偏差。 错误的理解 之前我一直以为 await 后面的表达式，如果是直接返回一个具体的值就不会等待，而是继续执行async</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CandyManPing/p/10041941.html</dc:identifier>
</item>
<item>
<title>Java Monitoring&amp;Troubleshooting Tools - Hopkins'Cybernetics</title>
<link>http://www.cnblogs.com/HopkinsCybn/p/10051603.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HopkinsCybn/p/10051603.html</guid>
<description>&lt;p&gt;&lt;u&gt;You can use the following tools to monitor JVM performance statistics. The tools described in this section are unsupported and experimental, and should be used with that in mind. &lt;span&gt;&lt;strong&gt;They may not be available in future JDK versions&lt;/strong&gt;&lt;/span&gt;.&lt;br/&gt;These tools are supported on all platforms except Windows 98 and Windows ME.&lt;br/&gt;&lt;/u&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;jps&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Experimental: JVM Process Status Tool - Lists instrumented HotSpot Java virtual machines on a target system.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;jstat&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Experimental: JVM Statistics Monitoring Tool - Attaches to an instrumented HotSpot Java virtual machine and collects and logs performance statistics as specified by the command line options.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;jstatd&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Experimental: JVM jstat Daemon - Launches an RMI server application that monitors for the creation and termination of instrumented HotSpot Java virtual machines and provides a interface to allow remote monitoring tools to attach to Java virtual machines running on the local system.&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;p&gt;&lt;u&gt;Troubleshooting Tools&lt;br/&gt;The following tools can be used for specific troubleshooting tasks. The tools described in this section are unsupported and experimental in nature and should be used with that in mind. &lt;span&gt;&lt;strong&gt;They may not be available in future JDK versions&lt;/strong&gt;&lt;/span&gt;.&lt;br/&gt;Some of these tools are not currently available on Windows platforms.&lt;/u&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;jinfo&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Experimental - Configuration Info for Java - Prints configuration information for a given process or core file or a remote debug server.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt;jhat&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Experimental - Heap Dump Browser - Starts a web server on a heap dump file (for example, produced by jmap -dump), allowing the heap to be browsed.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;jmap&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Experimental - Memory Map for Java - Prints shared object memory maps or heap memory details of a given process or core file or a remote debug server.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;jsadebugd&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Experimental - Serviceability Agent Debug Daemon for Java - Attaches to a process or core file and acts as a debug server.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;jstack&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Experimental - Stack Trace for Java - Prints a stack trace of threads for a given process or core file or remote debug server.&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Sat, 01 Dec 2018 15:09:00 +0000</pubDate>
<dc:creator>Hopkins&amp;#39;Cybernetics</dc:creator>
<og:description>You can use the following tools to monitor JVM performance statistics. The tools described in this s</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HopkinsCybn/p/10051603.html</dc:identifier>
</item>
<item>
<title>《数据结构与算法之美》- 栈 - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/algo-stack.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/algo-stack.html</guid>
<description>&lt;p&gt;栈，在这里说的是一种数据结构。&lt;/p&gt;
&lt;h3 id=&quot;你还可能知道的栈&quot;&gt;你还可能知道的栈&lt;/h3&gt;
&lt;p&gt;提到“栈”，做Java的同学还会想起Java内存模型中的“栈”，与之紧密关联的还有一个名词——堆，但是这里，此栈非彼栈。&lt;/p&gt;
&lt;p&gt;引用《深入理解Java虚拟机》中有关栈的介绍&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”笔者在后面专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;局部变量表存放了编译可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，可能是一个只想对象起始地址的引用指针，也可能是指向一个对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说人话就是，Java内存结构中的一部分，线程私有，用来存储指定的数据类型数据。&lt;/p&gt;
&lt;h3 id=&quot;栈是什么&quot;&gt;栈是什么&lt;/h3&gt;
&lt;p&gt;栈是一种数据结构，它有自己的特点&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;它是一种线性表，同为线性表的还有之前说到的数组和链表&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;它操作受限，具体表现在先进后出，后进先出，只能在一端进行数据的插入和删除&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于以上两点，大概就能勾勒出栈的模样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201812/619240-20181201224002074-766097680.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;栈的应用&quot;&gt;栈的应用&lt;/h3&gt;
&lt;p&gt;经常听到有很多人抱怨说（也包括我~~~），如果知道这门课这么重要，我当时拼死老命也要把它学好。&lt;/p&gt;
&lt;p&gt;还记得当时看吴恩达的《machine learning》，在前几节课里展示了如何使用聚类算法进行图像处理，如果使用增强学习算法让一个模型飞机飞起来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201812/619240-20181201224010930-1238448179.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201812/619240-20181201224018658-2096505422.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，我们来看下栈有什么应用&lt;/p&gt;
&lt;h4 id=&quot;栈在表达式求值中的应用&quot;&gt;栈在表达式求值中的应用&lt;/h4&gt;
&lt;p&gt;给出一个表达式“3+5*8-6”，如果让你算，想必难不倒你。&lt;/p&gt;
&lt;p&gt;交给机器做，肯定也难不倒它，机器甚至可以做更加复杂的你做不到的运算。&lt;/p&gt;
&lt;p&gt;但是机器底层是怎么做的，如果不给定规则，它并不知道加减乘除是什么，也不知道他们的优先级顺序。所以，这时候栈就排上了用场。&lt;/p&gt;
&lt;p&gt;具体做法：&lt;/p&gt;
&lt;p&gt;准备两个栈，一个用来存储需要运算的数字，一个用来存储运算符号。&lt;/p&gt;
&lt;p&gt;数字栈按照从左到右的顺序入栈，符号栈也是如此，只是除此之外还多了一个规则限定。&lt;/p&gt;
&lt;p&gt;当新入栈的符号优先级比当前栈顶符号的优先级高的时候，继续入栈；当比栈顶符号优先级低或者相同时，则取出当前栈顶符号，同时取出数字栈的操作数字进行运算，将运算后的结果压栈，直至两个栈元素全部弹出。&lt;/p&gt;
&lt;p&gt;具体看专题中给出的过程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201812/619240-20181201224028549-204281758.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;栈在括号匹配中的应用&quot;&gt;栈在括号匹配中的应用&lt;/h4&gt;
&lt;p&gt;给出一串“{(({[{{}}]}))}”，需要校验这串表达式中是否能前后一一匹配。&lt;/p&gt;
&lt;p&gt;没错，这个也可以利用栈的特性解决。&lt;/p&gt;
&lt;p&gt;具体做法：&lt;/p&gt;
&lt;p&gt;从左到右扫描表达式，对于左括号入栈，遇到右括号则取出当前栈顶元素，如果发现匹配，则取出栈顶元素继续匹配。&lt;/p&gt;
&lt;p&gt;当所有字符串匹配完成，并且栈最后是空栈，说明字符串可以正确匹配。&lt;/p&gt;
&lt;h3 id=&quot;栈在浏览器前进后退中的应用&quot;&gt;栈在浏览器前进后退中的应用&lt;/h3&gt;
&lt;p&gt;在浏览器中，我们可以通过前进后退回到自己想要的网页。&lt;/p&gt;
&lt;p&gt;这个功能也是可以通过栈来实现的，具体做法：&lt;/p&gt;
&lt;p&gt;准备两个栈，一个用于存放前进栈的网页ID，一个用于存放后退栈的网页ID。当需要前进的时候，从前进栈取出栈顶元素，并将该元素放入后退栈中；&lt;/p&gt;
&lt;p&gt;当需要后退的时候，从后退栈取出栈顶元素，并将该元素放入前进栈中。&lt;/p&gt;
&lt;p&gt;具体实现参见项目rome中的BackAndForwardUtil和BackAndForwardUtilDemo类&lt;/p&gt;
&lt;h3 id=&quot;如何实现一个栈&quot;&gt;如何实现一个栈&lt;/h3&gt;
&lt;p&gt;采用链表接口实现一个栈结构&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
package com.jackie.algo.geek.time.chapter8_stack;

/**
 * @Author: Jackie
 */
public class Stack {
    private Node top = null;

    /**
     * 压栈
     * @see com.jackie.algo.geek.time.chapter6_linkedlist.LinkedList 中的insertToHead方法和这里的push思想类似
     *
     * |------|
     * | node | 上移后的top在这个位置
     * |------|
     * |   p  | 一开始top在这里，经过node.next = top绑定了node和p关系后，又通过top = node，则将top上移
     * |------|
     * |  ... |
     * |------|
     *
     */
    public void push(int value) {
        Node node = new Node(value, null);

        if (top == null) {
            top = node;
        } else {
            node.next = top;
            top = node;
        }
    }
    /**
     * 出栈
     */
    public int pop() {
        if (top == null) {
            return -1;
        }
        int value = top.value;
        top = top.next;

        return value;
    }
    public void printAll() {
        Node p = top;
        while (p != null) {
            System.out.print(p.value + &quot; &quot;);
            p = p.next;
        }
        System.out.println();
    }
    public static class Node {
        private int value;

        private Node next;

        public Node(int value, Node next) {
            this.value = value;
            this.next = next;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体参见项目&lt;a href=&quot;https://github.com/DMinerJackie/rome/tree/master/algo/geek-time-algo&quot;&gt;rome&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的“&lt;strong&gt;推荐&lt;/strong&gt;”将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4459384-f166f03afb66b79f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 01 Dec 2018 14:51:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<og:description>介绍数据结构栈以及栈的应用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bigdataZJ/p/algo-stack.html</dc:identifier>
</item>
</channel>
</rss>