<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>第14天简单的购物商城作业的编写 - 沉沦的罚</title>
<link>http://www.cnblogs.com/huwentao/p/9723819.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huwentao/p/9723819.html</guid>
<description>&lt;p&gt;功能需求：&lt;/p&gt;
&lt;p&gt;1. 用户可以注册，登录，注销，查询账户，退出系统，购物等操作，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181163/201809/1181163-20180929150812441-1752198368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 用户登录进去之后可以保存状态信息进之后进行其他的一些操作，如购物，支付等：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181163/201809/1181163-20180929151004742-1542864148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. 用户的信息主要以以下的格式存储在文件中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc|123|0,qwe|456|239&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;流程的分析：&lt;/p&gt;
&lt;p&gt;当我们遇到这样一个需求的时候，应该如何去做呢？首先，我们应该有一个系统的接口，用来展示我们系统所具有的具体功能。然后通过用户输入的信息按照功能字典分别导入到不同的函数中进行相应的处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_d317298b-2418-4e6c-bf98-561e57347368&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d317298b-2418-4e6c-bf98-561e57347368&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d317298b-2418-4e6c-bf98-561e57347368&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 系统的功能提示&lt;/span&gt;
sys_msg = &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
欢迎使用简单的购物车系统, 请选择：
1.注册 | 2.登录 | 3.账户 | 4.充值 | 5.购物 | 6.支付 | 7.购物车 | 10.注销 | 0.退出
&amp;gt;&amp;gt;&amp;gt;
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;系统功能提示，主要用来提示用户系统具有什么样的功能&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_e1136596-7053-4e88-8a13-9f14facaf5bd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e1136596-7053-4e88-8a13-9f14facaf5bd&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e1136596-7053-4e88-8a13-9f14facaf5bd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 功能字典&lt;/span&gt;
method_dic =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: register,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注册&lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: login,      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;  登录&lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: account,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询账户&lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: top_up,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 充值&lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: shopping,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 购物&lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: pay_money,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 支付&lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: shop_car_info,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 购物车&lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: logout  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注销&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;功能字典，通过用户的输入调用不同的函数处理不同的功能&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 这个就是实现系统接口的函数，通过用户输入的choice来选择使用什么样的函数处理相应的功能&lt;br/&gt;@outer
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; system():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;系统&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        choice &lt;/span&gt;=&lt;span&gt; input(sys_msg).strip()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 退出系统&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; choice == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;退出系统! &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 错误选项&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; choice &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; method_dic:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;功能输入有误，请重新输入！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 正确的选项eg: method_dic['1']() ==&amp;gt; register()&lt;/span&gt;
&lt;span&gt;        method_dic[choice]()


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进入简单的购物车系统&lt;/span&gt;
system()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为此购物商城只是单纯的一些函数的实现，较为简单，具体说明在代买中已经有注释，此处不再赘述（在每一个函数前面加上了一个装饰器，用来标识每一个函数的运行和结束。）以下为实现的源代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;95&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt;&lt;span&gt; wraps
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存储用户信息的文件路径&lt;/span&gt;
file_path = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;usr.info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 全局变量&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 存储当前登录成功的用户的信息&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; user的存储格式 {&quot;usr&quot;:&quot;abc&quot;, &quot;ps&quot;: &quot;123&quot;, &quot;money&quot;: 0}&lt;/span&gt;
user =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 文件中的用户信息是以[用户名|密码|资产,用户名|密码|资产]构成的，&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; eg:&quot;abc|123|0,qwe|456|239&quot;&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 将用户信息从文件中读取出来以变量的形式存储在内存中，以便于后续大量的信息交互&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; user_dic的格式：&lt;/span&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
{
    &quot;abc&quot;: {&quot;ps&quot;: &quot;123&quot;, &quot;money&quot;: 0},
    &quot;qwe&quot;: {&quot;ps&quot;: &quot;456&quot;, &quot;money&quot;: 239}
}
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
user_dic &lt;/span&gt;= {}  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从文件中读取出来的用户信息&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 购物车{&quot;iPad&quot;: 3, &quot;Mac&quot;: 1}&lt;/span&gt;
shop_car_dic =&lt;span&gt; {}


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; outer(func):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;在执行每一个模块之前和之后加上字符串提示&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    @wraps(func)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行%s操作&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.center(100, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) % func.&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;)
        res &lt;/span&gt;= func(*args, **&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;结束%s操作&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.center(100, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) % func.&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_users():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;调取当前内存中的用户信息&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果内存中已经有用户的信息，直接返回&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; user_dic:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user_dic
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读文件，更新内存中的user_dic&lt;/span&gt;
    with open(file_path, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
        data &lt;/span&gt;=&lt;span&gt; f.read()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 文件内容为空&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; data:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user_dic
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 文件的内容为: &quot;abc|123|0,qwe|456|239&quot;&lt;/span&gt;
        data_list = data.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; single_user_info &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data_list:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 切片获取到单个用户的信息之后更新user_dic&lt;/span&gt;
            single_user_info_list = single_user_info.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            usr &lt;/span&gt;=&lt;span&gt; single_user_info_list[0]
            ps &lt;/span&gt;= single_user_info_list[1&lt;span&gt;]
            money &lt;/span&gt;= int(single_user_info_list[2&lt;span&gt;])
            user_dic[usr] &lt;/span&gt;= {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ps&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: ps, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;money&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: money}
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user_dic


@outer
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; register():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;注册&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取所有用户的信息&lt;/span&gt;
    users =&lt;span&gt; get_users()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 账号输入操作&lt;/span&gt;
    temp_info = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        username &lt;/span&gt;= input(temp_info + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入账号: \t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户名格式&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; username:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户名不能为空！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            temp_info &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请重新&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;continue&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户名已经存在&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; username &lt;span&gt;in&lt;/span&gt;&lt;span&gt; users:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户名已经存在！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            temp_info &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请重新&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;continue&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户名不存在&lt;/span&gt;
        &lt;span&gt;break&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 密码输入操作&lt;/span&gt;
    temp_info = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        password &lt;/span&gt;= input(temp_info + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入密码: \t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 密码格式不正确&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; len(password) &amp;lt; 3&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您输入的密码过短！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            temp_info &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请重新&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;continue&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 密码格式正确&lt;/span&gt;
        &lt;span&gt;break&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 账号和密码都正确，可以写入文件中&lt;/span&gt;
    with open(file_path, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 文件为空,写入str = &quot;abc|123|0&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; users:
            f.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s|%s|%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (username, password, 0))
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 文件不为空, 写入str = &quot;,abc|123|0&quot;&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            f.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,%s|%s|%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (username, password, 0))
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 更新注册信息到内存中&lt;/span&gt;
    users[username] = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ps&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: password, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;money&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 0}
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;账号注册成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


@outer
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; login():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;登录&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    users &lt;/span&gt;=&lt;span&gt; get_users()
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; user
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; user:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;系统已经处于登陆状态!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 账号输入操作&lt;/span&gt;
    temp_info = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        username &lt;/span&gt;= input(temp_info + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入账号:\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 账号不存在&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; username &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; users:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 文件不为空,如果为文件为空，就会出现一直输入的情况&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; users:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您输入的账号不存在！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                temp_info &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请重新&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                &lt;span&gt;continue&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 账号存在&lt;/span&gt;
        &lt;span&gt;break&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 密码输入操作&lt;/span&gt;
    temp_info = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    count &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; count &amp;lt; 3&lt;span&gt;:
        password &lt;/span&gt;= input(temp_info + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入密码：\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 密码不匹配&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; password == users[username][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ps&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登陆成功！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 更新登陆状态信息&lt;/span&gt;
            money = users[username][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;money&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; global user&lt;/span&gt;
            user = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;usr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: username, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ps&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: password, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;money&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: money}
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; user[&quot;usr&quot;] = username&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; user['ps'] = password&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; user['money'] = money&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入的密码有误！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        temp_info &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请重新&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        count &lt;/span&gt;+= 1
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 更新user信息&lt;/span&gt;
&lt;span&gt;

@outer
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; account():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;查询账户&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户已经登录&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; user:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;账户：%s | 金额: %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (user[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;usr&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], user[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;money&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前系统未登录！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


@outer
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; logout():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;注销&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; user:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;系统未登录！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    user.clear()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;注销成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; user_dic_write_file():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;将内存中用户信息写入文件中&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; dic ==&amp;gt; str的转换&lt;/span&gt;
    users =&lt;span&gt; get_users()
    user_info &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; k, v &lt;span&gt;in&lt;/span&gt;&lt;span&gt; users.items():
        usr &lt;/span&gt;=&lt;span&gt; k
        ps &lt;/span&gt;= str(v[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ps&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
        money &lt;/span&gt;= str(v[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;money&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; user_info:
            user_info &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.join((usr, ps, money))
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            user_info &lt;/span&gt;= user_info + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.join((usr, ps, money))
    with open(file_path, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
        f.write(user_info)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; update(key, value):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    更新个人账户的金额或者密码
    :param key: 可以输入ps或者是money
    :param value: 需要更改的值
    :return:
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1. 更新user = {&quot;usr&quot;:&quot;abc&quot;, &quot;ps&quot;: &quot;123&quot;, &quot;money&quot;: 0}&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; key == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;money&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        user[key] &lt;/span&gt;+=&lt;span&gt; value
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; key == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ps&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        user[key] &lt;/span&gt;=&lt;span&gt; value
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2. 更新user_dic&lt;/span&gt;
    users =&lt;span&gt; get_users()
    users[user[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;usr&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]][key] =&lt;span&gt; user[key]
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3. 更新文件内容&lt;/span&gt;
&lt;span&gt;    user_dic_write_file()


@outer
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; top_up():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;充值&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 系统未登录&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; user:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请先登录系统！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 金额输入操作&lt;/span&gt;
    temp_info = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        money &lt;/span&gt;= input(temp_info + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入金额: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 格式是否准确&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; money.isdigit():
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您输入的金额有误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            temp_info &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请重新&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
        money &lt;/span&gt;=&lt;span&gt; int(money)
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 金额更新操作&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.更新user&lt;/span&gt;
    update(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;money&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, money)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;充值成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


@outer
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; pay_money():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;支付&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 购物车信息为空&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; shop_car_dic:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您的购物车为空，请先进行购物！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
    shop_total_price &lt;/span&gt;= sum([price_dic[key] * value  &lt;span&gt;for&lt;/span&gt; key, value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; shop_car_dic.items()])
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 余额不足&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; user[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;money&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &amp;lt;&lt;span&gt; shop_total_price:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;亲，余额不足，请充值！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 余额充足，进行购买&lt;/span&gt;
    update(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;money&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 0 -&lt;span&gt; shop_total_price)
    shop_car_dic.clear()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;购买成功！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True


@outer
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; shopping():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;购物&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户是否登录&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; user:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;系统未登录！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 商品编号输入操作&lt;/span&gt;
    temp_info = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(goods_msg)
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        shop_num &lt;/span&gt;= input(temp_info + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入商品编号：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; shop_num == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;退出购物！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 商品编号格式错误&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; shop_num &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; goods_dic:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入有误！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            temp_info &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请重新&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
        shop_name &lt;/span&gt;=&lt;span&gt; goods_dic[shop_num]
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 购买个数输入操作&lt;/span&gt;
        temp_info = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            shop_count &lt;/span&gt;= input(temp_info + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;购买的个数：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; shop_count.isdigit():
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入有误！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                temp_info &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请重新&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
            shop_count &lt;/span&gt;=&lt;span&gt; int(shop_count)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 商品已经在购物车内&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; shop_name &lt;span&gt;in&lt;/span&gt;&lt;span&gt; shop_car_dic:
                shop_car_dic[shop_name] &lt;/span&gt;+=&lt;span&gt; shop_count
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                shop_car_dic[shop_name] &lt;/span&gt;=&lt;span&gt; shop_count
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印购物车的信息&lt;/span&gt;
&lt;span&gt;    shop_car_info()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 支付&lt;/span&gt;
&lt;span&gt;    pay_money()


@outer
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; shop_car_info():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;购物车&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; shop_car_dic:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您的购物车为空！请前往购物！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s的购物车信息为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % user[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;usr&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; key, value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; shop_car_dic.items():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;商品：%s | 个数：%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (key, value))


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 功能字典&lt;/span&gt;
method_dic =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: register,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: login,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: account,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: top_up,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: shopping,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: pay_money,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: shop_car_info,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: logout
}
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 商品字典&lt;/span&gt;
goods_dic =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;iPhone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mac&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;iPad&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 价格字典&lt;/span&gt;
price_dic =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;iPhone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 100&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mac&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 200&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;iPad&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 300&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 商品信息提示&lt;/span&gt;
goods_msg = &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
请添加商品到购物车：
1. iPhone | 2. Mac | 3. iPad | 0.退出购物
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 系统的功能提示&lt;/span&gt;
sys_msg = &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
欢迎使用简单的购物车系统, 请选择：
1.注册 | 2.登录 | 3.账户 | 4.充值 | 5.购物 | 6.支付 | 7.购物车 | 10.注销 | 0.退出
&amp;gt;&amp;gt;&amp;gt;
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;


@outer
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; system():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;系统&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        choice &lt;/span&gt;=&lt;span&gt; input(sys_msg).strip()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 退出系统&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; choice == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;退出系统! &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 错误选项&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; choice &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; method_dic:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;功能输入有误，请重新输入！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 正确的选项eg: method_dic['1']() ==&amp;gt; register()&lt;/span&gt;
&lt;span&gt;        method_dic[choice]()


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进入简单的购物车系统&lt;/span&gt;
system()
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 29 Sep 2018 07:30:00 +0000</pubDate>
<dc:creator>沉沦的罚</dc:creator>
<og:description>功能需求： 1. 用户可以注册，登录，注销，查询账户，退出系统，购物等操作，如下图 2. 用户登录进去之后可以保存状态信息进之后进行其他的一些操作，如购物，支付等： 3. 用户的信息主要以以下的格式存</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huwentao/p/9723819.html</dc:identifier>
</item>
<item>
<title>史上最全的MySQL高性能优化实战总结！ - Java修炼记</title>
<link>http://www.cnblogs.com/Javaba/p/9723923.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Javaba/p/9723923.html</guid>
<description>
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-view&quot; data-width=&quot;745&quot; data-height=&quot;374&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-64015d1fe76109ab?imageMogr2/auto-orient/strip%7CimageView2/2/w/745/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-64015d1fe76109ab&quot; data-original-width=&quot;745&quot; data-original-height=&quot;374&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;24100&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;1.1 前言&lt;/p&gt;
&lt;p&gt;MySQL对于很多Linux从业者而言，是一个非常棘手的问题，多数情况都是因为对数据库出现问题的情况和处理思路不清晰。在进行MySQL的优化之前必须要了解的就是MySQL的查询过程，很多的查询优化工作实际上就是遵循一些原则让MySQL的优化器能够按照预想的合理方式运行而已。&lt;/p&gt;
&lt;p&gt;今天给大家体验MySQL的优化实战，助你高薪之路顺畅。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;550&quot; data-height=&quot;314&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-e8bb3127e93538e5?imageMogr2/auto-orient/strip%7CimageView2/2/w/550/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-e8bb3127e93538e5&quot; data-original-width=&quot;550&quot; data-original-height=&quot;314&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;43462&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;图 - MySQL查询过程&lt;/p&gt;
&lt;p&gt;1.2 优化的哲学&lt;/p&gt;
&lt;p&gt;优化有风险，涉足需谨慎&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.2.1 优化可能带来的问题&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; &lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;614&quot; data-height=&quot;141&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-1a8b830990ce9583.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/614/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-1a8b830990ce9583.png&quot; data-original-width=&quot;614&quot; data-original-height=&quot;141&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;32289&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;1.2.2 优化的需求&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; &lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;710&quot; data-height=&quot;181&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-dfdcda2e2db12688.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/710/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-dfdcda2e2db12688.png&quot; data-original-width=&quot;710&quot; data-original-height=&quot;181&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;29038&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;1.2.3 优化由谁参与&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在进行数据库优化时，应由数据库管理员、业务部门代表、应用程序架构师、应用程序设计人员、应用程序开发人员、硬件及系统管理员、存储管理员等，业务相关人员共同参与。&lt;/p&gt;
&lt;p&gt;1.3 优化思路&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.3.1 优化什么&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在数据库优化上有两个主要方面：即安全与性能。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;291&quot; data-height=&quot;65&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-a675c36cf92b01fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/291/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-a675c36cf92b01fa.png&quot; data-original-width=&quot;291&quot; data-original-height=&quot;65&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;5588&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;1.3.2 优化的范围有哪些&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;存储、主机和操作系统方面:&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;286&quot; data-height=&quot;123&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-f5e8c1178a39d1b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/286/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-f5e8c1178a39d1b3.png&quot; data-original-width=&quot;286&quot; data-original-height=&quot;123&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;10438&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;应用程序方面:&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;312&quot; data-height=&quot;135&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-4be961f8c2c93bd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/312/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-4be961f8c2c93bd1.png&quot; data-original-width=&quot;312&quot; data-original-height=&quot;135&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;11937&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;数据库优化方面:&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;312&quot; data-height=&quot;84&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-63a037679e24f1c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/312/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-63a037679e24f1c0.png&quot; data-original-width=&quot;312&quot; data-original-height=&quot;84&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;6398&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;说明：不管是在，设计系统，定位问题还是优化，都可以按照这个顺序执行。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.3.3 优化维度&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;数据库优化维度有四个:&lt;/p&gt;
&lt;p&gt;硬件、系统配置、数据库表结构、SQL及索引&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;550&quot; data-height=&quot;272&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-a39fedac47e91c4d?imageMogr2/auto-orient/strip%7CimageView2/2/w/550/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-a39fedac47e91c4d&quot; data-original-width=&quot;550&quot; data-original-height=&quot;272&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;24033&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;优化选择&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;485&quot; data-height=&quot;58&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-b1bdd854b444768e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/485/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-b1bdd854b444768e.png&quot; data-original-width=&quot;485&quot; data-original-height=&quot;58&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;12245&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;1.4 优化工具有啥？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.4.1 数据库层面&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;检查问题常用工具&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;703&quot; data-height=&quot;211&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-e6b242a7d22da006.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/703/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-e6b242a7d22da006.png&quot; data-original-width=&quot;703&quot; data-original-height=&quot;211&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;28307&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;不常用但好用的工具&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;707&quot; data-height=&quot;135&quot;&gt;&lt;img class=&quot;image-loading&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-3ec21aec06f5b83c.png&quot; data-original-width=&quot;707&quot; data-original-height=&quot;135&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;16254&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;1.4.2 数据库层面问题解决思路&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;一般应急调优的思路：&lt;/p&gt;
&lt;p&gt;针对突然的业务办理卡顿，无法进行正常的业务处理！需要立马解决的场景！&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;714&quot; data-height=&quot;230&quot;&gt;&lt;img class=&quot;image-loading&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-b1120c8b9b93a7ba.png&quot; data-original-width=&quot;714&quot; data-original-height=&quot;230&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;32055&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;常规调优思路：&lt;/p&gt;
&lt;p&gt;针对业务周期性的卡顿，例如在每天10-11点业务特别慢，但是还能够使用，过了这段时间就好了。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;512&quot; data-height=&quot;109&quot;&gt;&lt;img class=&quot;image-loading&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-21f7114dbf2427f1.png&quot; data-original-width=&quot;512&quot; data-original-height=&quot;109&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;18320&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;1.4.3 系统层面&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;cpu方面&lt;/p&gt;
&lt;p&gt;vmstat、sar top、htop、nmon、mpstat&lt;/p&gt;
&lt;p&gt;内存&lt;/p&gt;
&lt;p&gt;free、ps -aux 、&lt;/p&gt;
&lt;p&gt;IO设备（磁盘、网络）&lt;/p&gt;
&lt;p&gt;iostat、 ss 、 netstat 、 iptraf、iftop、lsof、&lt;/p&gt;
&lt;p&gt;vmstat 命令说明：&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;713&quot; data-height=&quot;253&quot;&gt;&lt;img class=&quot;image-loading&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-368857c15243c780.png&quot; data-original-width=&quot;713&quot; data-original-height=&quot;253&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;53058&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;iostat命令说明&lt;/p&gt;
&lt;p&gt;实例命令： iostat -dk 1 5&lt;/p&gt;
&lt;p&gt;iostat -d -k -x 5 （查看设备使用率（%util）和响应时间（await））&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;707&quot; data-height=&quot;224&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-b45ae5d1e862e93a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/707/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-b45ae5d1e862e93a.png&quot; data-original-width=&quot;707&quot; data-original-height=&quot;224&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;43618&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;1.4.4 系统层面问题解决办法&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;你认为到底负载高好，还是低好呢？&lt;/p&gt;
&lt;p&gt;在实际的生产中，一般认为 cpu只要不超过90%都没什么问题 。&lt;/p&gt;
&lt;p&gt;当然不排除下面这些特殊情况：&lt;/p&gt;
&lt;p&gt;问题一：cpu负载高，IO负载低&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;714&quot; data-height=&quot;174&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-21deda6a6d7b02f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/714/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-21deda6a6d7b02f2.png&quot; data-original-width=&quot;714&quot; data-original-height=&quot;174&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;22158&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;问题二：IO负载高，cpu负载低&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;671&quot; data-height=&quot;160&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-0f36fe468fe9cde1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/671/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-0f36fe468fe9cde1.png&quot; data-original-width=&quot;671&quot; data-original-height=&quot;160&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;19236&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;问题三：IO和cpu负载都很高&lt;/p&gt;
&lt;p&gt;硬件不够了或sql存在问题&lt;/p&gt;
&lt;p&gt;1.5 基础优化&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.5.1 优化思路&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;定位问题点:&lt;/p&gt;
&lt;p&gt;硬件 --&amp;gt; 系统 --&amp;gt; 应用 --&amp;gt; 数据库 --&amp;gt; 架构（高可用、读写分离、分库分表）&lt;/p&gt;
&lt;p&gt;处理方向&lt;/p&gt;
&lt;p&gt;明确优化目标、性能和安全的折中、防患未然&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.5.2 硬件优化&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;主机方面：&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;514&quot; data-height=&quot;124&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-694fb0e838e3e7b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/514/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-694fb0e838e3e7b6.png&quot; data-original-width=&quot;514&quot; data-original-height=&quot;124&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;16478&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;cpu的选择：&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;537&quot; data-height=&quot;123&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-18d2f2ba396c9b47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/537/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-18d2f2ba396c9b47.png&quot; data-original-width=&quot;537&quot; data-original-height=&quot;123&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;19884&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;内存的选择：&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;575&quot; data-height=&quot;62&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-832dd64d40af0713.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/575/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-832dd64d40af0713.png&quot; data-original-width=&quot;575&quot; data-original-height=&quot;62&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;13453&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;存储方面：&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;703&quot; data-height=&quot;123&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-c8d8f220153de8fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/703/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-c8d8f220153de8fb.png&quot; data-original-width=&quot;703&quot; data-original-height=&quot;123&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;19506&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;raid卡：主机raid卡选择：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;480&quot; data-height=&quot;121&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-5e21d47c9b1b088e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-5e21d47c9b1b088e.png&quot; data-original-width=&quot;480&quot; data-original-height=&quot;121&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;15742&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;网络设备方面：&lt;/p&gt;
&lt;p&gt;使用流量支持更高的网络设备（交换机、路由器、网线、网卡、HBA卡）&lt;/p&gt;
&lt;p&gt;注意：以上这些规划应该在初始设计系统时就应该考虑好。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.5.3 服务器硬件优化&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; &lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;716&quot; data-height=&quot;174&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-4608c1effe37541c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/716/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-4608c1effe37541c.png&quot; data-original-width=&quot;716&quot; data-original-height=&quot;174&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;28320&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;1.5.4 系统优化&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Cpu：&lt;/p&gt;
&lt;p&gt;基本不需要调整，在硬件选择方面下功夫即可。&lt;/p&gt;
&lt;p&gt;内存：&lt;/p&gt;
&lt;p&gt;基本不需要调整，在硬件选择方面下功夫即可。&lt;/p&gt;
&lt;p&gt;SWAP：&lt;/p&gt;
&lt;p&gt;MySQL尽量避免使用swap。阿里云的服务器中默认swap为0&lt;/p&gt;
&lt;p&gt;IO ：&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;436&quot; data-height=&quot;50&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-ba5dec9ec0972fa2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/436/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-ba5dec9ec0972fa2.png&quot; data-original-width=&quot;436&quot; data-original-height=&quot;50&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;7816&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;706&quot; data-height=&quot;49&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-7e2375065be90afd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/706/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-7e2375065be90afd.png&quot; data-original-width=&quot;706&quot; data-original-height=&quot;49&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;5600&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这个参数决定了Linux是倾向于使用swap，还是倾向于释放文件系统cache。在内存紧张的情况下，数值越低越倾向于释放文件系统cache。当然，这个参数只能减少使用swap的概率，并不能避免Linux使用swap。&lt;/p&gt;
&lt;p&gt;修改MySQL的配置参数innodb_flush_method，开启O_DIRECT模式。这种情况下，InnoDB的buffer pool会直接绕过文件系统cache来访问磁盘，但是redo log依旧会使用文件系统cache。值得注意的是，Redo log是覆写模式的，即使使用了文件系统的cache，也不会占用太多&lt;/p&gt;
&lt;p&gt;IO调度策略&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;707&quot; data-height=&quot;105&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-4cf7aef5821c49fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/707/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-4cf7aef5821c49fd.png&quot; data-original-width=&quot;707&quot; data-original-height=&quot;105&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;11138&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;1.5.5 系统参数调整&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Linux系统内核参数优化&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;705&quot; data-height=&quot;99&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-f15f5c349ac7cf89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/705/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-f15f5c349ac7cf89.png&quot; data-original-width=&quot;705&quot; data-original-height=&quot;99&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;13172&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;用户限制参数（mysql可以不设置以下配置）&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;707&quot; data-height=&quot;106&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-2e3955f6be514ad5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/707/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-2e3955f6be514ad5.png&quot; data-original-width=&quot;707&quot; data-original-height=&quot;106&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;8574&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;1.5.6 应用优化&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;业务应用和数据库应用独立,防火墙：iptables、selinux等其他无用服务(关闭)：&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;706&quot; data-height=&quot;284&quot;&gt;&lt;img class=&quot;image-loading&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-2e5ff603e7669684.png&quot; data-original-width=&quot;706&quot; data-original-height=&quot;284&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;36232&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;安装图形界面的服务器不要启动图形界面 runlevel 3,另外，思考将来我们的业务是否真的需要MySQL，还是使用其他种类的数据库。用数据库的最高境界就是不用数据库。&lt;/p&gt;
&lt;p&gt;1.6 数据库优化&lt;/p&gt;
&lt;p&gt;SQL优化方向：&lt;/p&gt;
&lt;p&gt;执行计划、索引、SQL改写&lt;/p&gt;
&lt;p&gt;架构优化方向：&lt;/p&gt;
&lt;p&gt;高可用架构、高性能架构、分库分表&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.6.1 数据库参数优化&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;调整：&lt;/p&gt;
&lt;p&gt;实例整体（高级优化，扩展）&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;707&quot; data-height=&quot;120&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-99cb1dcf99398c48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/707/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-99cb1dcf99398c48.png&quot; data-original-width=&quot;707&quot; data-original-height=&quot;120&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;14085&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;连接层（基础优化）&lt;/p&gt;
&lt;p&gt;设置合理的连接客户和连接方式&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;707&quot; data-height=&quot;140&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-5fadd9f1f03024f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/707/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-5fadd9f1f03024f6.png&quot; data-original-width=&quot;707&quot; data-original-height=&quot;140&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;15268&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;SQL层（基础优化）&lt;/p&gt;
&lt;p&gt;query_cache_size： 查询缓存&lt;/p&gt;
&lt;p&gt;OLAP类型数据库,需要重点加大此内存缓存.&lt;/p&gt;
&lt;p&gt;但是一般不会超过GB.&lt;/p&gt;
&lt;p&gt;对于经常被修改的数据，缓存会立马失效。&lt;/p&gt;
&lt;p&gt;我们可以实用内存数据库（redis、memecache），替代他的功能。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.6.2 存储引擎层（innodb基础优化参数）&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;674&quot; data-height=&quot;227&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-8e834d9311d12665.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/674/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-8e834d9311d12665.png&quot; data-original-width=&quot;674&quot; data-original-height=&quot;227&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;33151&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;为什么某些人会一直比你优秀，是因为他本身就很优秀还一直在持续努力变得更优秀，而你是不是还在满足于现状内心在窃喜!&lt;/p&gt;
</description>
<pubDate>Sat, 29 Sep 2018 07:28:00 +0000</pubDate>
<dc:creator>Java修炼记</dc:creator>
<og:description>1.1 前言 MySQL对于很多Linux从业者而言，是一个非常棘手的问题，多数情况都是因为对数据库出现问题的情况和处理思路不清晰。在进行MySQL的优化之前必须要了解的就是MySQL的查询过程，很多</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Javaba/p/9723923.html</dc:identifier>
</item>
<item>
<title>七、Java多人博客系统-2.0版本-docker部署 - 瘦鱼</title>
<link>http://www.cnblogs.com/yangtze-yufei/p/9719264.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangtze-yufei/p/9719264.html</guid>
<description>&lt;p&gt;　　docker是当下很热门的技术，是对之前的部署系统方式的彻底改变。之前部署系统，需要安装数据库、初始化数据库，安装jdk，配置jdk，部署应用程序，修改配置文件等，很繁琐。一般现场运维人员很难搞定，现场也会出现很多公司开发环境没有的问题。使用docker技术，只需要运行镜像即可，省去了环境安装、变量配置等繁琐的事情，现场运维人员经过简单培训后可以独立部署系统。移植性好，公司开发环境直接可以部署到现场。&lt;/p&gt;
&lt;p&gt;　　使用docker技术，主要有两个个关键步骤：1、构建镜像 2、运行镜像。构建镜像，需要将基础支持软件、业务系统打成镜像包。运行镜像，需要将构建的镜像运行起来，外部可以访问。&lt;/p&gt;
&lt;h2&gt;一、docker理解&lt;/h2&gt;
&lt;p&gt;　　docker镜像可以理解为一个高度内聚的应用包，包含运行环境、配置等，可以移植到各个环境中运行。例如一个java应用镜像，运行这个镜像只需要准备一台Linux服务器，服务器上不需要装任何jdk，只需要安装docker，就可以运行该镜像。省去了常规的安装运行环境，配置环境变量，启动各种服务等各种繁琐步骤。&lt;/p&gt;
&lt;h2&gt;二、本地构建docker应用&lt;/h2&gt;
&lt;p&gt;　　对于一个信息系统，镜像一般包括：&lt;/p&gt;
&lt;p&gt;　　1. mariadb镜像：包含数据库安装文件和业务数据库。数据库安装文件，是数据库基础支持软件。业务数据库是业务系统需要的数据库，业务系统需要提供初始化脚本。&lt;/p&gt;
&lt;p&gt;　　2. nginx镜像：包含nginx基础镜像和业务前端代码。nginx基础镜像是nginx运行软件。作为前后端分离的项目，nginx中存放前端静态页面。&lt;/p&gt;
&lt;p&gt;　　3. java镜像：包含jdk和业务应用程序。jdk是java应用运行基础环境。业务应用是后端系统，向前端提供展示数据。&lt;/p&gt;
&lt;p&gt;　　以上是信息系统一种部署方式，另外可以将基础镜像和初始化镜像分开，例如mariadb镜像可以分为mariadb安装镜像和业务系统初始化镜像。&lt;/p&gt;
&lt;p&gt;　　先在本地环境安装docker，docker中配置仓库地址，指明了镜像存放路径，例如tim:5000，同时需要在hosts中配置tim的映射。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/319088/201809/319088-20180929112414038-2048296458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在系统的hosts文件中配置映射127.0.0.1 tim&lt;/p&gt;
&lt;h3&gt;　　1) mariadb镜像：&lt;/h3&gt;
&lt;p&gt;　　1、 准备业务系统初始化脚本。&lt;/p&gt;
&lt;p&gt;　　2、 修改数据库配置文件等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　需要准备的文件如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/319088/201809/319088-20180928161758198-671872383.png&quot; alt=&quot;&quot; width=&quot;180&quot; height=&quot;161&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　utf8mb4.cnf 修改数据库编码字符集为utf8格式，解决中文汉字乱码问题。&lt;/p&gt;
&lt;p&gt;　　run.txt 运行镜像命令。构建镜像非必需文件，这里只是记录运行命令。&lt;/p&gt;
&lt;p&gt;　　blog.sql 初始化脚本。业务系统的初始化镜像，包含建库脚本、建表脚本、初始化数据脚本等。&lt;/p&gt;
&lt;p&gt;　　Dockerfile 生成镜像说明文档。说明镜像如何生成，已经运行时执行的命令。&lt;/p&gt;
&lt;p&gt;　　install_data.sh 数据库启动后执行的脚本。因为mariadb镜像需要在镜像运行后，初始化业务系统数据库，需要该脚本执行业务系统初始化脚本。&lt;/p&gt;
&lt;p&gt;　　Makefile 执行make命令后，执行的镜像生成命令。一般是移除上次的镜像，再生成新的镜像。&lt;/p&gt;
&lt;p&gt;　　重点是Dockerfile文件，内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
#基础镜像使用daocloud.io/library/mysql:8，新构建的镜像以此镜像为基础
FROM daocloud.io/library/mysql:8

#定义工作目录变量
ENV WORK_PATH /usr/local/work

#定义会被容器自动执行的目录
ENV AUTO_RUN_DIR /docker-entrypoint-initdb.d

#定义sql文件名，这里指向业务系统初始化脚本
ENV FILE_0 blog.sql

#定义shell文件名，指向待指向的shell脚本
ENV INSTALL_DATA_SHELL install_data.sh

#执行shell命令，创建文件夹
RUN mkdir -p $WORK_PATH

#把数据库初始化数据的文件复制到工作目录下
COPY ./$FILE_0 $WORK_PATH/

#把要执行的shell文件放到/docker-entrypoint-initdb.d/目录下，高版本mysql容器会自动执行这个shell（5.7.4不能执行）
COPY ./$INSTALL_DATA_SHELL $AUTO_RUN_DIR/

#mysql默认字符集是latain,而它是不支持中文的,utf8mb4 是 utf8 的超集并完全兼容utf8。修改字符集
COPY utf8mb4.cnf /etc/mysql/conf.d/

#给执行文件增加可执行权限
RUN chmod a+x $AUTO_RUN_DIR/$INSTALL_DATA_SHELL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　install_data.sh文件主要是镜像在运行后，自动执行的命令，主要是登录到已经启动的mysql镜像中，执行初始化脚本。内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
#!/bin/bash
mysql -uroot -p$MYSQL_ROOT_PASSWORD &amp;lt;&amp;lt;EOF
source $WORK_PATH/$FILE_0;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;utf8mb4.cnf内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
# 设置服务器、客户端编码格式
[client]
default-character-set = utf8mb4

[mysql]
default-character-set = utf8mb4

[mysqld]
character-set-client-handshake = FALSE  # 忽略客户端的字符集，使用服务器的设置 
character-set-server = utf8mb4
collation-server = utf8mb4_unicode_ci
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Makefile包含两个命令，也可以拿出来单独执行，内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
build-image:
        docker rmi tim:5000/blog-mariadb:dev-test
        docker build -t tim:5000/blog-mariadb:dev-test .
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　生成镜像：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过命令进入到镜像生成命令中，执行make命令，或者拷贝Makefile文件中内容执行也可以。例：&lt;/p&gt;
&lt;p&gt;　　docker build -t tim:5000/blog-mariadb:dev-test .&lt;/p&gt;
&lt;p&gt;　　最后的点不能省略，表明在当前目录中构建镜像，镜像名称为tim:5000/blog-mariadb:dev-test，指明了镜像存放地址，镜像名称，镜像版本。&lt;/p&gt;
&lt;p&gt;　　使用docker images查看镜像是否生成成功。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/319088/201809/319088-20180929112945059-1705984821.png&quot; alt=&quot;&quot; width=&quot;1536&quot; height=&quot;60&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　运行镜像：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker run --name mysql-blog -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d tim:5000/blog-mariadb:dev-test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 --name mysql-blog 取名为mysql-blog&lt;/p&gt;
&lt;p&gt;　　-p 3306:3306 将容器的3306端口暴露到宿主机中，外部可以通过3306访问容器，如同访问本机上的数据库一样&lt;/p&gt;
&lt;p&gt;　　-e MYSQL_ROOT_PASSWORD=root 数据库密码为root&lt;/p&gt;
&lt;p&gt;　　-d 以后台进程方式运行&lt;/p&gt;
&lt;p&gt;　　tim:5000/blog-mariadb:dev-test 运行的镜像&lt;/p&gt;

&lt;h3&gt;　　2) nginx镜像&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　需要准备的文件如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　static是开发的业务系统前端静态页面，前后端分离的，所以这里是html、css、js之类的文件。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/319088/201809/319088-20180928160501634-747266032.png&quot; alt=&quot;&quot; width=&quot;182&quot; height=&quot;151&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Dockerfile文件内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
# 使用的基础镜像，这个是nginx运行软件
FROM hub.c.163.com/library/nginx

# 将业务系统静态页面拷贝到nginx的页面目录中，static会自动创建
COPY static/ /usr/share/nginx/html/static/

# 将blog站点nginx配置文件拷贝到nginx站点配置文件中，可以拷贝多个，端口不同即可
COPY blog.conf /etc/nginx/conf.d/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　blog.conf是nginx配置，内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
# nginx支持配置多个站点，配置文件拷贝到/etc/nginx/conf.d下即可
server {
    listen       9001; # 监听的端口
    server_name  localhost; # 服务器名称
    location / {
     # 静态页面拷贝到这里来
      root   /usr/share/nginx/html/static;
      index  index.html;

      # 跨域
      if ($request_method ~* &quot;(GET|POST|DELETE|PUT)&quot;) {
                add_header &quot;Access-Control-Allow-Origin&quot; *;
        }
                
      if ($request_method = OPTIONS ) {
                add_header &quot;Access-Control-Allow-Origin&quot; *;
                add_header &quot;Access-Control-Allow-Methods&quot; 'GET, POST, PUT, DELETE, OPTIONS';
                add_header &quot;Access-Control-Allow-Headers&quot; 'Authorization,Content-Type';
                return 200;
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　同样，进入到该目录中，执行make命令。&lt;/p&gt;
&lt;p&gt;　　运行命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker run --name blog-web -d -p 8080:9001 tim:5000/blog-web:dev-test　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　blog站点nginx配置文件监听端口是9001，暴露出来，外部可以通过8080端口访问系统。&lt;/p&gt;

&lt;h3&gt;　　3) java应用镜像&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　 需要准备的文件如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/319088/201809/319088-20180928160556634-667137879.png&quot; alt=&quot;&quot; width=&quot;391&quot; height=&quot;136&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Dockerfile：生成镜像的命令，指明了基础镜像来源，镜像中包含的文件，镜像运行的命令等。&lt;/p&gt;
&lt;p&gt;　　下面两个文件是java应用需要的文件，application.properties将应用的参数拿出来，可以进行修改，运行时会覆盖应用中的配置文件，不需要修改应用内部的配置文件，再重新生成jar包。&lt;/p&gt;
&lt;p&gt;　　重点看下Dockerfile文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
# java应用需要java支持，先使用hub.c.163.com/library/java:8作为基础镜像
FROM hub.c.163.com/library/java:8

# 运行的环境变量
ENV TZ Asia/Shanghai
ENV LANG zh_CN.UTF-8 
ENV LANGUAGE zh_CN:zh 
ENV LC_ALL zh_CN.UTF-8

# 工作目录
WORKDIR /opt/project

# 将文件加到镜像中的目录中。application.properties是配置文件，不再需要进入jar包中修改配置。blog-1.0-SNAPSHOT.jar是业务应用运行jar
ADD application.properties /opt/project/config/application.properties
ADD blog-1.0-SNAPSHOT.jar /opt/project/

# 镜像运行后执行的命令
CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;blog-1.0-SNAPSHOT.jar&quot;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;生成镜像：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　进入到镜像制作目录中，执行命令： docker build -t tim:5000/tim-blog:dev-test . 或者执行make命令。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;查看镜像是否生成成功&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　docker images&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;运行镜像&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker run -p 9091:9091 --link mysql-blog:mysql-blog --name blog tim:5000/blog:dev-test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　将端口映射到9091。同时链接到mysql-blog数据库，注意这里是数据库镜像运行时的名称，连接mysql：mysql（容器名:别名），应用名称为blog。&lt;/p&gt;
&lt;p&gt;　　域名需使用连接的容器的别名（即上述所提的mysql-blog:mysql-blog中的第二个mysql-blog），例如应用中数据库连接字符串写法如下：&lt;/p&gt;
&lt;p&gt;　　spring.datasource.url=jdbc:mysql://&lt;span&gt;mysql-blog&lt;/span&gt;:3306/blog?useUnicode=true&amp;amp;characterEncoding=utf-8&lt;/p&gt;
&lt;p&gt; 　  查看容器运行情况：&lt;/p&gt;
&lt;p&gt;　　docker ps -a &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
CONTAINER ID        IMAGE                            COMMAND                  CREATED              STATUS              PORTS                               NAMES
9f1a03cf3555        tim:5000/blog-web:dev-test       &quot;nginx -g 'daemon ...&quot;   45 seconds ago       Up 50 seconds       80/tcp, 0.0.0.0:8080-&amp;gt;9001/tcp      blog-web
aec1c87b63ed        tim:5000/blog:dev-test           &quot;java -jar blog-1....&quot;   55 seconds ago       Up About a minute   0.0.0.0:9091-&amp;gt;9091/tcp              blog
0c5dcc8543ca        tim:5000/blog-mariadb:dev-test   &quot;docker-entrypoint...&quot;   About a minute ago   Up About a minute   0.0.0.0:3306-&amp;gt;3306/tcp, 33060/tcp   mysql-blog
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样系统需要的3个镜像就运行起来了，在浏览器通过8080端口就能访问系统。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/319088/201809/319088-20180929145007060-2115208325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;附docker常用命令：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;docker images 查看所有镜像&lt;/p&gt;
&lt;p&gt;docker ps -a 查看所有容器&lt;/p&gt;
&lt;p&gt;docker stop containerID 停止容器&lt;/p&gt;
&lt;p&gt;docker rm containerID 移除容器&lt;/p&gt;
&lt;p&gt;docker rmi imagesID 移除镜像&lt;/p&gt;
&lt;p&gt;docker exec -it containerId /bin/bash 进入到容器内部&lt;/p&gt;

</description>
<pubDate>Sat, 29 Sep 2018 06:52:00 +0000</pubDate>
<dc:creator>瘦鱼</dc:creator>
<og:description>docker是当下很热门的技术，是对之前的部署系统方式的彻底改变。之前部署系统，需要安装数据库、初始化数据库，安装jdk，配置jdk，部署应用程序，修改配置文件等，很繁琐。一般现场运维人员很难搞定，现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangtze-yufei/p/9719264.html</dc:identifier>
</item>
<item>
<title>https 加密、http2.0、keep-alive - 筱月</title>
<link>http://www.cnblogs.com/ainyi/p/9723563.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ainyi/p/9723563.html</guid>
<description>&lt;p&gt;原文地址：&lt;a href=&quot;https://ainyi.com/#/44&quot; target=&quot;_blank&quot;&gt;https://ainyi.com/#/44&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少&lt;/p&gt;
&lt;p&gt;http协议属于明文传输协议，交互过程以及数据传输都没有进行加密，通信双方也没有进行任何认证，通信过程非常容易遭遇劫持、监听、篡改，严重情况下，会造成恶意的流量劫持等问题，甚至造成个人隐私泄露（比如银行卡卡号和密码泄露）等严重的安全问题&lt;/p&gt;
&lt;p&gt;https：是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL&lt;/p&gt;
&lt;h2 id=&quot;heading-0&quot;&gt;https&lt;/h2&gt;
&lt;p&gt;多了 SSL 层的 HTTP 协议&lt;br/&gt;简而言之，HTTPS 就是在 HTTP 下加入了 SSL 层，从而保护了交换数据隐私和完整性，提供对网站服务器身份认证的功能，简单来说它就是安全版的 HTTP&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;TLS 是 SSL 的升级版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Krryxa/WORK-LEARNING/master/images/19.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HTTPS 主要用途有三个：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过证书等信息确认网站的真实性&lt;/li&gt;
&lt;li&gt;建立加密的信息通道&lt;/li&gt;
&lt;li&gt;数据内容的完整性&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;lang-&quot;&gt;数字证书，它可以通过加密技术（对称加密与非对称加密）对我们在网上传输的信息进行加密
比如我登录账号上输入：

账号：krry

密码：1234567

若这个数据被黑客拦截盗窃了，那么加密后，黑客得到的数据可能就是这样的：

账号：çµø…≤¥ƒ∂ø†®∂˙∆¬

密码：∆ø¥§®†ƒ©®†©˚¬
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;数据内容完整性&lt;br/&gt;当数据包经过无数次路由器转发后可能会发生数据劫持，黑客将数据劫持后进行篡改，比如植入小广告。开启HTTPS后黑客就无法对数据进行篡改，就算真的被篡改了，我们也可以检测出问题&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;heading-1&quot;&gt;对称加密与非对称加密&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;对称加密&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对称加密是指加密与解密都使用同一个密钥的加密算法&lt;/p&gt;
&lt;p&gt;目前常见的加密算法有：DES、AES、IDEA 等&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;非对称加密&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;非对称加密使用的是两个密钥，公钥与私钥，我们会使用公钥对网站账号密码等数据进行加密，再用私钥对数据进行解密。这个公钥会发给查看网站的所有人，而私钥是只有网站服务器自己拥有。&lt;br/&gt;用户对网站输入的信息使用公钥加密，传到服务端使用私钥对数据解密&lt;/p&gt;
&lt;p&gt;目前常见非对称加密算法：RSA，DSA，DH等&lt;/p&gt;
&lt;h3 id=&quot;heading-2&quot;&gt;优缺点&lt;/h3&gt;
&lt;p&gt;非对称加密与对称加密相比，其安全性更好：对称加密的通信双方使用相同的秘钥，如果一方的秘钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对秘钥（私钥和公钥），一个用来加密（公钥），一个用来解密（私钥），而且公钥是公开的，秘钥是自己保存的，不需要像对称加密那样在通信之前要先同步秘钥&lt;/p&gt;
&lt;p&gt;非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密&lt;/p&gt;
&lt;h2 id=&quot;heading-3&quot;&gt;https 加密&lt;/h2&gt;
&lt;p&gt;https = 数据加密（对称和非对称） + 网站认证 + 完整性验证 + HTTP&lt;br/&gt;通过上文，我们已经知道，HTTPS 就是在 HTTP 传输协议的基础上对网站进行认证，给予它独一无二的身份证明，再对网站数据进行对称加密和非对称加密，并对传输的数据进行完整性验证。&lt;/p&gt;
&lt;p&gt;HTTPS 作为一种加密手段不仅加密了数据，还给了网站一张身份证&lt;em id=&quot;__mceDel&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;heading-4&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;HTTPS保证数据安全的机制&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;在 HTTP 的概念中介绍了 HTTP 是非常不安全的，下面介绍 https 如何保证安全传输&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用 非对称和对称加密&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;客户端向服务器端发起SSL连接请求；（在此过程中依然存在数据被中间方盗取的可能，下面将会说明如何保证此过程的安全）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;客户端用公钥对双方通信的 对称秘钥 进行加密，并发送给服务器端；&lt;br/&gt;（使用 非对称加密 的公钥对 对称加密 的私钥 进行加密）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;服务器利用自己唯一的私钥对客户端发来的 对称秘钥 进行解密，在此过程中，中间方无法对其解密（即使是客户端也无法解密，因为只有服务器端拥有唯一的私钥），这样保证了对称秘钥在收发过程中的安全，此时，服务器端和客户端拥有了一套完全相同的对称秘钥&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;heading-5&quot;&gt;加密的详细过程&lt;/h3&gt;
&lt;p&gt;首先服务器端用非对称加密（RSA）产生公钥和私钥。&lt;br/&gt;然后把公钥交给数字证书，并进行包装发给客户端。&lt;br/&gt;当公钥到达客户端之后，客户端的TLS首先验证公钥是否有效（颁发机构，公钥有效期，CA数字签名）&lt;br/&gt;若存在问题则弹出警告框，提示证书存在问题。&lt;br/&gt;若证书没有问题，则客户端会用对称加密产生一个秘钥，并用服务端返回的公钥（非对称加密）对 对称加密 的秘钥加密后发送给服务器。这个秘钥就是以后用来通信的秘钥。&lt;br/&gt;这样服务器端收到公钥加密的秘钥就用自己的私钥解开公钥从而获得秘钥。&lt;br/&gt;这样客户端和服务器都获得了秘钥，信息交流相对是安全的&lt;/p&gt;
&lt;h3 id=&quot;heading-6&quot;&gt;CA（电子商务认证机构）数字证书&lt;/h3&gt;
&lt;p&gt;https 协议中身份认证的部分是由数字证书来完成的，证书由公钥、证书主题、数字签名等内容组成，在客户端发起SSL请求后，服务端会将数字证书发给客户端，客户端对证书进行验证，并获取用于秘钥交换的非对称秘钥&lt;/p&gt;
&lt;p&gt;数字证书作用：&lt;br/&gt;身份授权：确保浏览器访问的网站是经过CA验证的可信任网站&lt;br/&gt;分发公钥：每个数字证书都包含了注册者生成的公钥。在SSL握手时通过certificate消息传输给客户端&lt;/p&gt;
&lt;p&gt;数字证书验证：&lt;br/&gt;申请者拿到CA的证书并部署在网站服务器端，浏览器发起握手接收到证书后，如何确认这个证书就是CA签发的呢？怎样避免第三方伪造这个证书？答案就是数字签名（digital signature）。数字签名是证书的防伪标签，目前使用最广泛的是SHA-RSA（SHA用于哈希算法，RSA用于非对称加密算法）数字签名&lt;/p&gt;
&lt;h2 id=&quot;heading-7&quot;&gt;http2.0&lt;/h2&gt;
&lt;p&gt;http1.1 存在的问题&lt;/p&gt;
&lt;p&gt;1、TCP 连接数限制&lt;br/&gt;对于同一个域名，浏览器最多只能同时创建 6~8 个 TCP 连接，调用接口的时候可以看到 (不同浏览器不一样)&lt;/p&gt;
&lt;p&gt;2、线头阻塞 (Head Of Line Blocking) 问题&lt;br/&gt;每个 TCP 连接同时只能处理一个请求 - 响应，浏览器按 FIFO 原则处理请求，如果上一个响应没返回，后续请求 - 响应都会受阻。&lt;br/&gt;为了解决此问题，出现了 管线化 - pipelining 技术，但是管线化存在诸多问题，比如第一个响应慢还是会阻塞后续响应、服务器为了按序返回相应需要缓存多个响应占用更多资源、浏览器中途断连重试服务器可能得重新处理多个请求、还有必须客户端 - 代理 - 服务器都支持管线化&lt;/p&gt;
&lt;p&gt;3、Header 内容多，而且每次请求 Header 不会变化太多，没有相应的压缩传输优化方案&lt;/p&gt;
&lt;p&gt;4、为了尽可能减少请求数，需要做合并文件、雪碧图、资源内联等优化工作，但是这无疑造成了单个请求内容变大延迟变高的问题，且内嵌的资源不能有效地使用缓存机制&lt;/p&gt;
&lt;p&gt;5、明文传输不安全&lt;/p&gt;
&lt;h3 id=&quot;heading-8&quot;&gt;http2.0 新特性&lt;/h3&gt;
&lt;p&gt;与 http1.1 相比，http2.0 有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;采用二进制格式而非文本格式&lt;/li&gt;
&lt;li&gt;是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行&lt;/li&gt;
&lt;li&gt;使用报头压缩，http2.0 降低了开销&lt;/li&gt;
&lt;li&gt;让服务器可以将响应主动“推送”到客户端缓存中&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;采用二进制传输&lt;br/&gt;帧是数据传输的最小单位，以二进制传输代替原本的明文传输，原本的报文消息被划分为更小的数据帧，二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;多路复用&lt;br/&gt;在一个 TCP 连接上，我们可以向对方不断发送帧，每帧的 stream identifier 的标明这一帧属于哪个流，然后在对方接收时，根据 stream identifier 拼接每个流的所有帧组成一整块数据。&lt;br/&gt;把 HTTP/1.1 每个请求都当作一个流，那么多个请求变成多个流，请求响应数据分成多个帧，不同流中的帧交错地发送给对方，这就是 HTTP/2 中的多路复用。&lt;br/&gt;流的概念实现了单连接上多请求 - 响应并行，解决了线头阻塞的问题，减少了 TCP 连接数量和 TCP 连接慢启动造成的问题&lt;br/&gt;所以 http2 对于同一域名只需要创建一个连接就可以加载页面，而不是像 http/1.1 那样创建 6~8 个连接&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;头部压缩&lt;br/&gt;在 http/1.x 协议中，每次请求都会携带 header 数据，而类似 User-Agent, Accept-Language 等信息在每次请求过程中几乎是不变的，那么这些信息在每次请求过程中就变成了浪费。所以， http2 中提出了一个 HPACK 的压缩方式，用于减少 http header 在每次请求中消耗的流量&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;服务端推送 (Server Push)&lt;br/&gt;浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。&lt;br/&gt;Server-Push 主要是针对资源内联做出的优化，相较于 http/1.1 资源内联的优势:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;lang-&quot;&gt;  客户端可以缓存推送的资源
  客户端可以拒收推送过来的资源
  推送资源可以由不同页面共享
  服务器可以按照优先级推送资源
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;流量控制&lt;br/&gt;每个 http2 流都拥有自己的公示的流量窗口，它可以限制另一端发送数据。对于每个流来说，两端都必须告诉对方自己还有足够的空间来处理新的数据，而在该窗口被扩大前，另一端只被允许发送这么多数据&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;heading-9&quot;&gt;http/1.x 转 http2&lt;/h3&gt;
&lt;p&gt;http/1 的几种优化可以放弃使用&lt;br/&gt;在 http/1.x 的时代，为了减少浏览器的请求数/提高浏览器的并发数，通常会使用如下的手段来进行优化：&lt;br/&gt;合并文件、内联资源、雪碧图、域名分片&lt;/p&gt;
&lt;p&gt;以上对于 HTTP/2 来说是不必要的，使用 http/2 尽可能将资源细粒化，文件分解地尽可能散，不用担心请求数多&lt;/p&gt;
&lt;h2 id=&quot;heading-10&quot;&gt;http keep-Alive 长连接&lt;/h2&gt;
&lt;p&gt;http 协议采用“请求-应答”模式&lt;/p&gt;
&lt;p&gt;当使用普通模式，即非 keep-alive 模式时（短连接），每个请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接&lt;/p&gt;
&lt;p&gt;当使用 keep-alive 模式时，keep-alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，keep-alive功能避免了建立或者重新建立连接&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;http1.0 默认是关闭的，需要在 http 头加入”Connection: keep-alive”，才能启用Keep-Alive&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;http 1.1 默认启用 keep-alive，加入”Connection: close “才关闭&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;目前大部分浏览器都是用 http1.1 协议，也就是说默认都会发起 keep-alive 的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。&lt;/p&gt;
&lt;p&gt;下图是普通模式和长连接模式的请求对比：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Krryxa/WORK-LEARNING/master/images/21.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;heading-11&quot;&gt;keep-alive 的优缺点&lt;/h3&gt;
&lt;p&gt;优点：keep-alive 模式更加高效，因为避免了连接建立和释放的开销&lt;br/&gt;缺点：长时间的 tcp 连接容易导致系统资源无效占用，浪费系统资源&lt;/p&gt;

&lt;p&gt;原文地址：&lt;a href=&quot;https://ainyi.com/#/44&quot; target=&quot;_blank&quot;&gt;https://ainyi.com/#/44&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 29 Sep 2018 06:37:00 +0000</pubDate>
<dc:creator>筱月</dc:creator>
<og:description>原文地址：https://ainyi.com/#/44 HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ainyi/p/9723563.html</dc:identifier>
</item>
<item>
<title>js闭包的理解-目前网上分析的最透彻文章 - colorfulCat</title>
<link>http://www.cnblogs.com/pettyColorcat/p/9723554.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pettyColorcat/p/9723554.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;js的闭包对于大家实际上并不陌生，但是真正敢说自己完全理解的人并不多。笔者在网上看到分析闭包的文章非常多，篇幅用的非常多，但是实际上分析的并不到位，或者根本就是不正确的。我有时候都在想，写这些文章的人自己未必真的理解了。今天我就为大家说到说到js的闭包，看完你百分百的能够理解。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;说闭包之前，我们先要说一个js的概念&lt;/p&gt;
&lt;p&gt;&lt;span&gt;js的变量不是传统意义的变量，是一个广义的概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;1、var i=0;&lt;/p&gt;
&lt;p&gt;2、var str=&quot;china&quot;;&lt;/p&gt;
&lt;p&gt;3、var fun=function(){...}&lt;/p&gt;
&lt;p&gt;第1个和第2个大家非常好理解，第3个简单的解释一下，它代表的是一个函数表达式，看到了吗？变量可以是一个函数，它实际上就是一个函数，要使用它直接就是fun();&lt;/p&gt;
&lt;p&gt;如果想要了解更多的函数表达式的概念，大家可以去查一下相关资料，网上资料很多，也很容易看得懂。我就不多说了，OK！我讲闭包之前先要掌握的概念就是这么多！&lt;/p&gt;

&lt;p&gt;进入正题：&lt;/p&gt;
&lt;p&gt;网上使用最多的一个例子如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; box(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr =&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;5;i++&lt;span&gt;){
        arr[i] &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;                            
        }                                        
    }                                            
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;网上的分析各种诡异看不懂，我直接给出我的结论，调用box()后，我们得到了一个数组，数组中是一个一个的函数表达式：&lt;/p&gt;
&lt;p&gt;[&lt;/p&gt;
&lt;p&gt;   function(){return i},&lt;/p&gt;
&lt;p&gt;   function(){return i},&lt;/p&gt;
&lt;p&gt;   function(){return i},&lt;/p&gt;
&lt;p&gt;   function(){return i},&lt;/p&gt;
&lt;p&gt;   function(){return i}&lt;/p&gt;
&lt;p&gt;]&lt;/p&gt;
&lt;p&gt;大家不要懵逼，这里很容易理解，我们看这里，在给数组arr赋值的时候，本来就是赋值的一个函数表达式&lt;/p&gt;
&lt;p&gt;arr[i] = function(){&lt;br/&gt;return i;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;大家明白了吧，你自己完全也可以使用alert(box());打印结果进行验证，大家可能还有一点儿疑惑，我要的是值，不是表达式啊，很简单，获取函数表达式的值只需要在变量后面加一个()，所以&lt;/p&gt;
&lt;p&gt;alert(box()[0]());结果是5，因为变量i现在的值是5，所以数组中的值都是5.就这么简单！&lt;/p&gt;

&lt;p&gt;闭包可以干什么？闭包可以让外部访问内部的局部变量&lt;/p&gt;
&lt;p&gt;还是以一个例子来解释：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; test(){
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; i=6&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就是一个最简单的闭包，局部变量通过函数返回。其它的应用都是类似，万变不离其宗！&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;

</description>
<pubDate>Sat, 29 Sep 2018 06:35:00 +0000</pubDate>
<dc:creator>colorfulCat</dc:creator>
<og:description>js的闭包对于大家实际上并不陌生，但是真正敢说自己完全理解的人并不多。笔者在网上看到分析闭包的文章非常多，篇幅用的非常多，但是实际上分析的并不到位，或者根本就是不正确的。我有时候都在想，写这些文章的人</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pettyColorcat/p/9723554.html</dc:identifier>
</item>
<item>
<title>[Abp 源码分析]十五、自动审计记录 - myzony</title>
<link>http://www.cnblogs.com/myzony/p/9723531.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myzony/p/9723531.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;0.简介&lt;/h2&gt;
&lt;p&gt;Abp 框架为我们自带了审计日志功能，审计日志可以方便地查看每次请求接口所耗的时间，能够帮助我们快速定位到某些性能有问题的接口。除此之外，审计日志信息还包含有每次调用接口时客户端请求的参数信息，客户端的 IP 与客户端使用的浏览器。有了这些数据之后，我们就可以很方便地复现接口产生 BUG 时的一些环境信息。&lt;/p&gt;
&lt;p&gt;当然如果你脑洞更大的话，可以根据这些数据来开发一个可视化的图形界面，方便开发与测试人员来快速定位问题。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;PS:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果使用了 Abp.Zero 模块则自带的审计记录实现是存储到数据库当中的，但是在使用 EF Core + MySQL(EF Provider 为 Pomelo.EntityFrameworkCore.MySql) 在高并发的情况下会有数据库连接超时的问题，这块推荐是重写实现，自己采用 Redis 或者其他存储方式。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果需要禁用审计日志功能，则需要在任意模块的预加载方法(&lt;code&gt;PreInitialize()&lt;/code&gt;) 当中增加如下代码关闭审计日志功能。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class XXXStartupModule
{
    public override PreInitialize()
    {
        // 禁用审计日志
        Configuration.Auditing.IsEnabled = false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;启动流程&quot;&gt;1.启动流程&lt;/h2&gt;
&lt;p&gt;审计组件与参数校验组件一样，都是通过 MVC 过滤器与 Castle 拦截器来实现记录的。也就是说，在每次调用接口/方法时都会进入 过滤器/拦截器 并将其写入到数据库表 &lt;code&gt;AbpAuditLogs&lt;/code&gt; 当中。&lt;/p&gt;
&lt;p&gt;其核心思想十分简单，就是在执行具体接口方法的时候，先使用 StopWatch 对象来记录执行完一个方法所需要的时间，并且还能够通过 &lt;code&gt;HttpContext&lt;/code&gt; 来获取到一些客户端的关键信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203160/201809/1203160-20180929143117802-407271101.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;过滤器注入&quot;&gt;2.1 过滤器注入&lt;/h3&gt;
&lt;p&gt;同上一篇文章所讲的一样，过滤器是在 &lt;code&gt;AddAbp()&lt;/code&gt; 方法内部的 &lt;code&gt;ConfigureAspNetCore()&lt;/code&gt; 方法注入的。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private static void ConfigureAspNetCore(IServiceCollection services, IIocResolver iocResolver)
{
    // ... 其他代码
    
    //Configure MVC
    services.Configure&amp;lt;MvcOptions&amp;gt;(mvcOptions =&amp;gt;
    {
        mvcOptions.AddAbp(services);
    });
    
    // ... 其他代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而下面就是过滤器的注入方法：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;internal static class AbpMvcOptionsExtensions
{
    public static void AddAbp(this MvcOptions options, IServiceCollection services)
    {
        // ... 其他代码
        AddFilters(options);
        // ... 其他代码
    }
    
    // ... 其他代码

    private static void AddFilters(MvcOptions options)
    {
        // ... 其他过滤器注入
        
        // 注入审计日志过滤器
        options.Filters.AddService(typeof(AbpAuditActionFilter));
        
        // ... 其他过滤器注入
    }
    
    // ... 其他代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;拦截器注入&quot;&gt;2.2 拦截器注入&lt;/h3&gt;
&lt;p&gt;注入拦截器的地方与 DTO 自动验证的拦截器的位置一样，都是在 &lt;code&gt;AbpBootstrapper&lt;/code&gt; 对象被构造的时候进行注册。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class AbpBootstrapper : IDisposable
{
    private AbpBootstrapper([NotNull] Type startupModule, [CanBeNull] Action&amp;lt;AbpBootstrapperOptions&amp;gt; optionsAction = null)
    {
        // ... 其他代码

        if (!options.DisableAllInterceptors)
        {
            AddInterceptorRegistrars();
        }
    }

    // ... 其他代码

    // 添加各种拦截器
    private void AddInterceptorRegistrars()
    {
        ValidationInterceptorRegistrar.Initialize(IocManager);
        AuditingInterceptorRegistrar.Initialize(IocManager);
        EntityHistoryInterceptorRegistrar.Initialize(IocManager);
        UnitOfWorkRegistrar.Initialize(IocManager);
        AuthorizationInterceptorRegistrar.Initialize(IocManager);
    }

    // ... 其他代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转到 &lt;code&gt;AuditingInterceptorRegistrar&lt;/code&gt; 的具体实现可以发现，他在内部针对于审计日志拦截器的注入是区分了类型的。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;internal static class AuditingInterceptorRegistrar
{
    public static void Initialize(IIocManager iocManager)
    {
        iocManager.IocContainer.Kernel.ComponentRegistered += (key, handler) =&amp;gt;
        {
            // 如果审计日志配置类没有被注入，则直接跳过
            if (!iocManager.IsRegistered&amp;lt;IAuditingConfiguration&amp;gt;())
            {
                return;
            }

            var auditingConfiguration = iocManager.Resolve&amp;lt;IAuditingConfiguration&amp;gt;();

            // 判断当前 DI 所注入的类型是否应该为其绑定审计日志拦截器
            if (ShouldIntercept(auditingConfiguration, handler.ComponentModel.Implementation))
            {
                handler.ComponentModel.Interceptors.Add(new InterceptorReference(typeof(AuditingInterceptor)));
            }
        };
    }
    
    // 本方法主要用于判断当前类型是否符合绑定拦截器的条件
    private static bool ShouldIntercept(IAuditingConfiguration auditingConfiguration, Type type)
    {
        // 首先判断当前类型是否在配置类的注册类型之中，如果是，则进行拦截器绑定
        if (auditingConfiguration.Selectors.Any(selector =&amp;gt; selector.Predicate(type)))
        {
            return true;
        }

        // 当前类型如果拥有 Audited 特性，则进行拦截器绑定
        if (type.GetTypeInfo().IsDefined(typeof(AuditedAttribute), true))
        {
            return true;
        }

        // 如果当前类型内部的所有方法当中有一个方法拥有 Audited 特性，则进行拦截器绑定
        if (type.GetMethods().Any(m =&amp;gt; m.IsDefined(typeof(AuditedAttribute), true)))
        {
            return true;
        }

        // 都不满足则返回 false,不对当前类型进行绑定
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到在判断是否绑定拦截器的时候，Abp 使用了 &lt;code&gt;auditingConfiguration.Selectors&lt;/code&gt; 的属性来进行判断，那么默认 Abp 为我们添加了哪些类型是必定有审计日志的呢？&lt;/p&gt;
&lt;p&gt;通过代码追踪，我们来到了 &lt;code&gt;AbpKernalModule&lt;/code&gt; 类的内部，在其预加载方法里面有一个 &lt;code&gt;AddAuditingSelectors()&lt;/code&gt; 的方法，该方法的作用就是添加了一个针对于应用服务类型的一个选择器对象。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public sealed class AbpKernelModule : AbpModule
{
    public override void PreInitialize()
    {
        // ... 其他代码

        AddAuditingSelectors();

        // ... 其他代码
    }

    // ... 其他代码

    private void AddAuditingSelectors()
    {
        Configuration.Auditing.Selectors.Add(
            new NamedTypeSelector(
                &quot;Abp.ApplicationServices&quot;,
                type =&amp;gt; typeof(IApplicationService).IsAssignableFrom(type)
            )
        );
    }

    // ... 其他代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先看一下 &lt;code&gt;NamedTypeSelector&lt;/code&gt; 的一个作用是什么，其基本类型定义由一个 &lt;code&gt;string&lt;/code&gt; 和 &lt;code&gt;Func&amp;lt;Type, bool&amp;gt;&lt;/code&gt; 组成，十分简单，重点就出在这个断言委托上面。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class NamedTypeSelector
{
    // 选择器名称
    public string Name { get; set; }
    
    // 断言委托
    public Func&amp;lt;Type, bool&amp;gt; Predicate { get; set; }

    public NamedTypeSelector(string name, Func&amp;lt;Type, bool&amp;gt; predicate)
    {
        Name = name;
        Predicate = predicate;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回到最开始的地方，当 Abp 为 Selectors 添加了一个名字为 &quot;Abp.ApplicationServices&quot; 的类型选择器。其断言委托的大体意思就是传入的 &lt;strong&gt;type&lt;/strong&gt; 参数是继承自 &lt;code&gt;IApplicationService&lt;/code&gt; 接口的话，则返回 &lt;code&gt;true&lt;/code&gt;,否则返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这样在程序启动的时候，首先注入类型的时候，会首先进入上文所述的拦截器绑定类当中，这个时候会使用 Selectors 内部的类型选择器来调用这个集合内部的断言委托，只要这些选择器对象有一个返回 &lt;code&gt;true&lt;/code&gt;,那么就直接与当前注入的 type 绑定拦截器。&lt;/p&gt;
&lt;h2 id=&quot;代码分析&quot;&gt;2.代码分析&lt;/h2&gt;
&lt;h3 id=&quot;过滤器代码分析&quot;&gt;2.1 过滤器代码分析&lt;/h3&gt;
&lt;p&gt;首先查看这个过滤器的整体类型结构，一个标准的过滤器，肯定要实现 &lt;code&gt;IAsyncActionFilter&lt;/code&gt; 接口。从下面的代码我们可以看到其注入了 &lt;code&gt;IAbpAspNetCoreConfiguration&lt;/code&gt; 和一个 &lt;code&gt;IAuditingHelper&lt;/code&gt; 对象。这两个对象的作用分别是判断是否记录日志，另一个则是用来真正写入日志所使用的。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class AbpAuditActionFilter : IAsyncActionFilter, ITransientDependency
{
    // 审计日志组件配置对象
    private readonly IAbpAspNetCoreConfiguration _configuration;
    // 真正用来写入审计日志的工具类
    private readonly IAuditingHelper _auditingHelper;

    public AbpAuditActionFilter(IAbpAspNetCoreConfiguration configuration, IAuditingHelper auditingHelper)
    {
        _configuration = configuration;
        _auditingHelper = auditingHelper;
    }

    public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
    {
        // ... 代码实现
    }
    
    // ... 其他代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着看 &lt;code&gt;AbpAuditActionFilter()&lt;/code&gt; 方法内部的实现，进入这个过滤器的时候，通过 &lt;code&gt;ShouldSaveAudit()&lt;/code&gt; 方法来判断是否要写审计日志。&lt;/p&gt;
&lt;p&gt;之后呢与 DTO 自动验证的过滤器一样，通过 &lt;code&gt;AbpCrossCuttingConcerns.Applying()&lt;/code&gt; 方法为当前的对象增加了一个标识，用来告诉拦截器说我已经处理过了，你就不要再重复处理了。&lt;/p&gt;
&lt;p&gt;再往下就是创建审计信息，执行具体接口方法，并且如果产生了异常的话，也会存放到审计信息当中。&lt;/p&gt;
&lt;p&gt;最后接口无论是否执行成功，还是说出现了异常信息，都会将其性能计数信息同审计信息一起，通过 &lt;code&gt;IAuditingHelper&lt;/code&gt; 存储起来。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
{
    // 判断是否写日志
    if (!ShouldSaveAudit(context))
    {
        await next();
        return;
    }

    // 为当前类型打上标识
    using (AbpCrossCuttingConcerns.Applying(context.Controller, AbpCrossCuttingConcerns.Auditing))
    {
        // 构造审计信息(AuditInfo)
        var auditInfo = _auditingHelper.CreateAuditInfo(
            context.ActionDescriptor.AsControllerActionDescriptor().ControllerTypeInfo.AsType(),
            context.ActionDescriptor.AsControllerActionDescriptor().MethodInfo,
            context.ActionArguments
        );

        // 开始性能计数
        var stopwatch = Stopwatch.StartNew();

        try
        {
            // 尝试调用接口方法
            var result = await next();
            
            // 产生异常之后，将其异常信息存放在审计信息之中
            if (result.Exception != null &amp;amp;&amp;amp; !result.ExceptionHandled)
            {
                auditInfo.Exception = result.Exception;
            }
        }
        catch (Exception ex)
        {
            // 产生异常之后，将其异常信息存放在审计信息之中
            auditInfo.Exception = ex;
            throw;
        }
        finally
        {
            // 停止计数，并且存储审计信息
            stopwatch.Stop();
            auditInfo.ExecutionDuration = Convert.ToInt32(stopwatch.Elapsed.TotalMilliseconds);
            await _auditingHelper.SaveAsync(auditInfo);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;拦截器代码分析&quot;&gt;2.2 拦截器代码分析&lt;/h3&gt;
&lt;p&gt;拦截器处理时的总体思路与过滤器类似，其核心都是通过 &lt;code&gt;IAuditingHelper&lt;/code&gt; 来创建审计信息和持久化审计信息的。只不过呢由于拦截器不仅仅是处理 MVC 接口，也会处理内部的一些类型的方法，所以针对同步方法与异步方法的处理肯定会复杂一点。&lt;/p&gt;
&lt;p&gt;拦截器呢，我们关心一下他的核心方法 &lt;code&gt;Intercept()&lt;/code&gt; 就行了。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void Intercept(IInvocation invocation)
{
    // 判断过滤器是否已经处理了过了
    if (AbpCrossCuttingConcerns.IsApplied(invocation.InvocationTarget, AbpCrossCuttingConcerns.Auditing))
    {
        invocation.Proceed();
        return;
    }

    // 通过 IAuditingHelper 来判断当前方法是否需要记录审计日志信息
    if (!_auditingHelper.ShouldSaveAudit(invocation.MethodInvocationTarget))
    {
        invocation.Proceed();
        return;
    }

    // 构造审计信息
    var auditInfo = _auditingHelper.CreateAuditInfo(invocation.TargetType, invocation.MethodInvocationTarget, invocation.Arguments);

    // 判断方法的类型，同步方法与异步方法的处理逻辑不一样
    if (invocation.Method.IsAsync())
    {
        PerformAsyncAuditing(invocation, auditInfo);
    }
    else
    {
        PerformSyncAuditing(invocation, auditInfo);
    }
}

// 同步方法的处理逻辑与 MVC 过滤器逻辑相似
private void PerformSyncAuditing(IInvocation invocation, AuditInfo auditInfo)
{
    var stopwatch = Stopwatch.StartNew();

    try
    {
        invocation.Proceed();
    }
    catch (Exception ex)
    {
        auditInfo.Exception = ex;
        throw;
    }
    finally
    {
        stopwatch.Stop();
        auditInfo.ExecutionDuration = Convert.ToInt32(stopwatch.Elapsed.TotalMilliseconds);
        _auditingHelper.Save(auditInfo);
    }
}

// 异步方法处理
private void PerformAsyncAuditing(IInvocation invocation, AuditInfo auditInfo)
{
    var stopwatch = Stopwatch.StartNew();

    invocation.Proceed();

    if (invocation.Method.ReturnType == typeof(Task))
    {
        invocation.ReturnValue = InternalAsyncHelper.AwaitTaskWithFinally(
            (Task) invocation.ReturnValue,
            exception =&amp;gt; SaveAuditInfo(auditInfo, stopwatch, exception)
        );
    }
    else //Task&amp;lt;TResult&amp;gt;
    {
        invocation.ReturnValue = InternalAsyncHelper.CallAwaitTaskWithFinallyAndGetResult(
            invocation.Method.ReturnType.GenericTypeArguments[0],
            invocation.ReturnValue,
            exception =&amp;gt; SaveAuditInfo(auditInfo, stopwatch, exception)
        );
    }
}

private void SaveAuditInfo(AuditInfo auditInfo, Stopwatch stopwatch, Exception exception)
{
    stopwatch.Stop();
    auditInfo.Exception = exception;
    auditInfo.ExecutionDuration = Convert.ToInt32(stopwatch.Elapsed.TotalMilliseconds);

    _auditingHelper.Save(auditInfo);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里异步方法的处理在很早之前的工作单元拦截器就有过讲述，这里就不再重复说明了。&lt;/p&gt;
&lt;h3 id=&quot;核心的-iauditinghelper&quot;&gt;2.3 核心的 IAuditingHelper&lt;/h3&gt;
&lt;p&gt;从代码上我们就可以看到，不论是拦截器还是过滤器都是最终都是通过 &lt;code&gt;IAuditingHelper&lt;/code&gt; 对象来储存审计日志的。Abp 依旧为我们实现了一个默认的 &lt;code&gt;AuditingHelper&lt;/code&gt; ，实现了其接口的所有方法。我们先查看一下这个接口的定义：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public interface IAuditingHelper
{
    // 判断当前方法是否需要存储审计日志信息
    bool ShouldSaveAudit(MethodInfo methodInfo, bool defaultValue = false);

    // 根据参数集合创建一个审计信息，一般用于拦截器
    AuditInfo CreateAuditInfo(Type type, MethodInfo method, object[] arguments);

    // 根据一个参数字典类来创建一个审计信息，一般用于 MVC 过滤器
    AuditInfo CreateAuditInfo(Type type, MethodInfo method, IDictionary&amp;lt;string, object&amp;gt; arguments);

    // 同步保存审计信息
    void Save(AuditInfo auditInfo);

    // 异步保存审计信息
    Task SaveAsync(AuditInfo auditInfo);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来到其默认实现 &lt;code&gt;AuditingHelper&lt;/code&gt; 类型，先看一下其内部注入了哪些接口。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class AuditingHelper : IAuditingHelper, ITransientDependency
{
    // 日志记录器，用于记录日志
    public ILogger Logger { get; set; }
    // 用于获取当前登录用户的信息
    public IAbpSession AbpSession { get; set; }
    // 用于持久话审计日志信息
    public IAuditingStore AuditingStore { get; set; }

    // 主要作用是填充审计信息的客户端调用信息
    private readonly IAuditInfoProvider _auditInfoProvider;
    // 审计日志组件的配置相关
    private readonly IAuditingConfiguration _configuration;
    // 在调用 AuditingStore 进行持久化的时候使用，创建一个工作单元
    private readonly IUnitOfWorkManager _unitOfWorkManager;
    // 用于序列化参数信息为 JSON 字符串
    private readonly IAuditSerializer _auditSerializer;

    public AuditingHelper(
        IAuditInfoProvider auditInfoProvider,
        IAuditingConfiguration configuration,
        IUnitOfWorkManager unitOfWorkManager,
        IAuditSerializer auditSerializer)
    {
        _auditInfoProvider = auditInfoProvider;
        _configuration = configuration;
        _unitOfWorkManager = unitOfWorkManager;
        _auditSerializer = auditSerializer;

        AbpSession = NullAbpSession.Instance;
        Logger = NullLogger.Instance;
        AuditingStore = SimpleLogAuditingStore.Instance;
    }

    // ... 其他实现的接口
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;判断是否创建审计信息&quot;&gt;2.3.1 判断是否创建审计信息&lt;/h4&gt;
&lt;p&gt;首先分析一下其内部的 &lt;code&gt;ShouldSaveAudit()&lt;/code&gt; 方法，整个方法的核心作用就是根据传入的方法类型来判定是否为其创建审计信息。&lt;/p&gt;
&lt;p&gt;其实在这一串 if 当中，你可以发现有一句代码对方法是否标注了 &lt;code&gt;DisableAuditingAttribute&lt;/code&gt; 特性进行了判断，如果标注了该特性，则不为该方法创建审计信息。所以我们就可以通过该特性来控制自己应用服务类，控制里面的的接口是否要创建审计信息。同理，我们也可以通过显式标注 &lt;code&gt;AuditedAttribute&lt;/code&gt; 特性来让拦截器为这个方法创建审计信息。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public bool ShouldSaveAudit(MethodInfo methodInfo, bool defaultValue = false)
{
    if (!_configuration.IsEnabled)
    {
        return false;
    }

    if (!_configuration.IsEnabledForAnonymousUsers &amp;amp;&amp;amp; (AbpSession?.UserId == null))
    {
        return false;
    }

    if (methodInfo == null)
    {
        return false;
    }

    if (!methodInfo.IsPublic)
    {
        return false;
    }

    if (methodInfo.IsDefined(typeof(AuditedAttribute), true))
    {
        return true;
    }

    if (methodInfo.IsDefined(typeof(DisableAuditingAttribute), true))
    {
        return false;
    }

    var classType = methodInfo.DeclaringType;
    if (classType != null)
    {
        if (classType.GetTypeInfo().IsDefined(typeof(AuditedAttribute), true))
        {
            return true;
        }

        if (classType.GetTypeInfo().IsDefined(typeof(DisableAuditingAttribute), true))
        {
            return false;
        }

        if (_configuration.Selectors.Any(selector =&amp;gt; selector.Predicate(classType)))
        {
            return true;
        }
    }

    return defaultValue;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建审计信息&quot;&gt;2.3.2 创建审计信息&lt;/h4&gt;
&lt;p&gt;审计信息在创建的时候，就为我们将当前调用接口时的用户信息存放在了审计信息当中，之后通过 &lt;code&gt;IAuditInfoProvider&lt;/code&gt; 的 &lt;code&gt;Fill()&lt;/code&gt; 方法填充了客户端 IP 与浏览器信息。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public AuditInfo CreateAuditInfo(Type type, MethodInfo method, IDictionary&amp;lt;string, object&amp;gt; arguments)
{
    // 构建一个审计信息对象
    var auditInfo = new AuditInfo
    {
        TenantId = AbpSession.TenantId,
        UserId = AbpSession.UserId,
        ImpersonatorUserId = AbpSession.ImpersonatorUserId,
        ImpersonatorTenantId = AbpSession.ImpersonatorTenantId,
        ServiceName = type != null
            ? type.FullName
            : &quot;&quot;,
        MethodName = method.Name,
        // 将参数转换为 JSON 字符串
        Parameters = ConvertArgumentsToJson(arguments),
        ExecutionTime = Clock.Now
    };

    try
    {
        // 填充客户 IP 与浏览器信息等
        _auditInfoProvider.Fill(auditInfo);
    }
    catch (Exception ex)
    {
        Logger.Warn(ex.ToString(), ex);
    }

    return auditInfo;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;审计信息持久化&quot;&gt;2.4 审计信息持久化&lt;/h3&gt;
&lt;p&gt;通过上一小节我们知道了在调用审计信息保存接口的时候，实际上是调用的 &lt;code&gt;IAuditingStore&lt;/code&gt; 所提供的 &lt;code&gt;SaveAsync(AuditInfo auditInfo)&lt;/code&gt; 方法来持久化这些审计日志信息的。&lt;/p&gt;
&lt;p&gt;如果你没有集成 Abp.Zero 项目的话，则使用的是默认的实现，就是简单通过 &lt;code&gt;ILogger&lt;/code&gt; 输出审计信息到日志当中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203160/201809/1203160-20180929143139914-842151469.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认有这两种实现，至于第一种是 Abp 的单元测试项目所使用的。&lt;/p&gt;
&lt;p&gt;这里我们就简单将一下 &lt;code&gt;AuditingStore&lt;/code&gt; 这个实现吧，其实很简单的，就是注入了一个仓储，在保存的时候往审计日志表插入一条数据即可。&lt;/p&gt;
&lt;p&gt;这里使用了 &lt;code&gt;AuditLog.CreateFromAuditInfo()&lt;/code&gt; 方法将 &lt;code&gt;AuditInfo&lt;/code&gt; 类型的审计信息转换为数据库实体，用于仓储进行插入操作。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class AuditingStore : IAuditingStore, ITransientDependency
{
    private readonly IRepository&amp;lt;AuditLog, long&amp;gt; _auditLogRepository;

    public AuditingStore(IRepository&amp;lt;AuditLog, long&amp;gt; auditLogRepository)
    {
        _auditLogRepository = auditLogRepository;
    }

    public virtual Task SaveAsync(AuditInfo auditInfo)
    {
        // 向表中插入数据
        return _auditLogRepository.InsertAsync(AuditLog.CreateFromAuditInfo(auditInfo));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样，这里建议重新实现一个 &lt;code&gt;AuditingStore&lt;/code&gt;，存储在 Redis 或者其他地方。&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;3. 后记&lt;/h2&gt;
&lt;p&gt;前几天发现 Abp 的团队有开了一个新坑，叫做 Abp vNext 框架，该框架全部基于 .NET Core 进行开发，而且会针对微服务项目进行专门的设计，有兴趣的朋友可以持续关注。&lt;/p&gt;
&lt;p&gt;其 GitHub 地址为：&lt;a href=&quot;https://github.com/abpframework/abp/&quot; class=&quot;uri&quot;&gt;https://github.com/abpframework/abp/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方地址为：&lt;a href=&quot;https://abp.io/&quot; class=&quot;uri&quot;&gt;https://abp.io/&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 29 Sep 2018 06:32:00 +0000</pubDate>
<dc:creator>myzony</dc:creator>
<og:description>0.简介 Abp 框架为我们自带了审计日志功能，审计日志可以方便地查看每次请求接口所耗的时间，能够帮助我们快速定位到某些性能有问题的接口。除此之外，审计日志信息还包含有每次调用接口时客户端请求的参数信</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/myzony/p/9723531.html</dc:identifier>
</item>
<item>
<title>Perl数据序列化和持久化(入门)：Storable模块 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9723368.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9723368.html</guid>
<description>&lt;p&gt;Perl提供了一个Storable模块，用来对数据结构进行序列化(serialization,Perl中称为冻结)，也就是将数据结构保存为二进制数据。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;序列化后的数据可以写入文件实现持久化，可以将持久化文件拷贝给远程机器&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;也可以通过网络套接字将序列化数据传递给远程机器&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;序列化后的数据在任意机器上都可以反序列化(deserialization,Perl中称为解冻)得到原始的数据结构&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;序列化数据结构时是进行&lt;strong&gt;深拷贝&lt;/strong&gt;的，序列化完成后，修改原始数据，不会影响反序列化的结果&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;序列化freezenfreeze和thaw&quot;&gt;序列化：freeze、nfreeze和thaw&lt;/h2&gt;
&lt;p&gt;Storabel的freeze和thaw函数分别用来冻结(序列化)和解冻(反序列化)：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;freeze冻结的是数据对象，不包括它们的引用和名称&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;freeze的参数需要是引用，可以是多个引用参数，返回的是二进制的冻结序列，各数据结构序列化在不同行&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;thaw的参数是引用变量，返回的是一个匿名列表，列表各元素对应freeze冻结时的各数据结构&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;nfreeze也是冻结，但是按照网络字节序进行序列化，适合远程传输序列化时的标量名称，见下一小节对主机字节序和网络字节序的描述&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#!/usr/bin/perl
use 5.010;
use Storable qw(freeze thaw);

%hash=(
        'longshuai'=&amp;gt;{
                      'gender'=&amp;gt;'male',
                      'age'   =&amp;gt;18,
                      'prov'  =&amp;gt;'jiangxi',
                     },
        'wugui'=&amp;gt;{
                  'gender'=&amp;gt;'male',
                  'age'   =&amp;gt;20,
                  'prov'  =&amp;gt;'zhejiang',
                 },
        'xiaofang'=&amp;gt;{
                     'gender'=&amp;gt;'female',
                     'age'   =&amp;gt;19,
                     'prov'  =&amp;gt;'fujian',
                    },
      );

@name=('fairy',[qw(longshuai wugui xiaofang)]);

$frozen = freeze [\%hash,\@name];   # 冻结引用，返回一个冻结后的列表
#say $frozen;              # 输出一堆乱码

$thaw_out=thaw($frozen);   # 解冻，返回引用列表

say $thaw_out-&amp;gt;[0];                # 输出：HASH(0x557171a4cff8)
say $thaw_out-&amp;gt;[0]{wugui}{prov};   # 输出：zhejiang
say $thaw_out-&amp;gt;[1];                # 输出：ARRAY(0x557171a4d220)
say $thaw_out-&amp;gt;[1][1][2];          # 输出：xiaofang&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的示例中，使用freeze冻结两个数据结构后，冻结后的二进制数据内容将赋值给一个标量变量，注意它返回的是类似于字符串那种形式的，只不过这段字符串是二进制格式的。&lt;/p&gt;
&lt;p&gt;使用thaw解冻后，将返回一个匿名列表，列表中的元素是各冻结的数据结构的引用。对于上面的示例来说，返回值类似如此结构&lt;code&gt;[$ref_hash,$ref_name]&lt;/code&gt;，将其赋值给一个引用变量&lt;code&gt;$thaw_out&lt;/code&gt;，然后就可以通过&lt;code&gt;$thaw_out-&amp;gt;[0]&lt;/code&gt;和&lt;code&gt;$thaw_out-&amp;gt;[1]&lt;/code&gt;分别访问这两个引用。&lt;/p&gt;
&lt;p&gt;如下图描述：&lt;/p&gt;
&lt;p&gt;freeze序列化过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201809/733013-20180929103509635-1587205582.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;thaw反序列化过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201809/733013-20180929103549586-989860566.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;持久化storenstore和retrieve&quot;&gt;持久化：store、nstore和retrieve&lt;/h2&gt;
&lt;p&gt;Storable模块可以将数据结构序列化后持久化保存到文件中，或通过TCP套接字传输出去。&lt;/p&gt;
&lt;p&gt;store和nstore用于将序列化数据进行持久化，它们用法一样，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;store \%ref_hash, 'file';
store [\%ref_hash,\@ref_arr], 'file';
nstore \%ref_hash, 'file';
nstore [\%ref_hash,\@ref_arr], 'file';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是store存储序列化数据时默认采用的是主机字节序(host byte order)，nstore默认采用的是网络字节序(network byte order)，采用网络字节序可以保证被TCP套接字传输出去时，远程主机能以完全一致的字节序方式读取数据。所以，要想通过网络传输序列化的对象时，需要使用nstore。&lt;/p&gt;
&lt;blockquote readability=&quot;10.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;小知识：主机字节序和网络字节序&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;多字节数据对象在存储时，必须考虑两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这段数据对象要存储到哪个地址&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;存储时如何排列这些字节&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里不考虑存储的地址问题。对于待存储的数值&quot;0x1122&quot;来说，11属于高位字节，22属于低位字节。对于存储时考虑以何种字节排列方式来说，有两种方式：大端字节序和小端字节序。假设要存储的数据对象&quot;0x1234567&quot;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;大端字节序(big-endian)：存储时，高位在前，低位在后，所以存储的时候，和上面源数据格式一样&quot;01 23 45 67&quot;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;小端字节序(little-endian)：存储时，高位在后，低位在前，所以存储的时候，和上面源数据格式相反&quot;67 45 23 01&quot;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大端字节序对人类来说比较容易理解，但几乎所有计算机都是采用小端字节序存储的，所以也称为主机字节序。而TCP/IP协议规定，网络传输时的网络字节序都采用大端字节序传输，这样一来所有网络传输的数据都规范化，远程主机总会按照大端字节序去读取传输过来的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;store和nstore持久化的序列化数据可以通过retrieve函数读取并反序列化。retrieve返回的值和thaw的返回结果是一样的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;my $ref_list = retrieve 'file';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是nstore和retrieve的一个示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/perl
use 5.010;
use Storable qw(nstore retrieve);

%hash=(
        'longshuai'=&amp;gt;{
                      'gender'=&amp;gt;'male',
                      'age'   =&amp;gt;18,
                      'prov'  =&amp;gt;'jiangxi',
                     },
        'wugui'=&amp;gt;{
                  'gender'=&amp;gt;'male',
                  'age'   =&amp;gt;20,
                  'prov'  =&amp;gt;'zhejiang',
                 },
        'xiaofang'=&amp;gt;{
                     'gender'=&amp;gt;'female',
                     'age'   =&amp;gt;19,
                     'prov'  =&amp;gt;'fujian',
                    },
      );

@name=('fairy',[qw(longshuai wugui xiaofang)]);

nstore [\%hash,\@name],'/tmp/tmp_data';   # 将数据序列化并持久化到文件

$ref_list=retrieve '/tmp/tmp_data';   # 反序列化并读取数据

say $ref_list-&amp;gt;[0];                # 输出：HASH(0x55aee8340318)
say $ref_list-&amp;gt;[0]{wugui}{prov};   # 输出：zhejiang
say $ref_list-&amp;gt;[1];                # 输出：ARRAY(0x55aee8340480)
say $ref_list-&amp;gt;[1][1][2];          # 输出：xiaofang&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;深拷贝dclone&quot;&gt;深拷贝：dclone&lt;/h2&gt;
&lt;p&gt;关于浅拷贝、深拷贝，见&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9721265.html&quot;&gt;Perl的浅拷贝和深度拷贝&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 29 Sep 2018 06:00:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>Perl提供了一个Storable模块，用来对数据结构进行序列化(serialization,Perl中称为冻结)，也就是将数据结构保存为二进制数据。 序列化后的数据可以写入文件实现持久化，可以将持久</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9723368.html</dc:identifier>
</item>
<item>
<title>Java程序语言的后门-反射机制 - 张橙子</title>
<link>http://www.cnblogs.com/zhangchengzi/p/9723250.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangchengzi/p/9723250.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在文章&lt;a id=&quot;post_title_link_9700248&quot; href=&quot;https://www.cnblogs.com/zhangchengzi/p/9700248.html&quot;&gt;JAVA设计模式-动态代理(Proxy)示例及说明&lt;/a&gt;和&lt;a id=&quot;post_title_link_9713807&quot; href=&quot;https://www.cnblogs.com/zhangchengzi/p/9713807.html&quot;&gt;JAVA设计模式-动态代理(Proxy)源码分析&lt;/a&gt;都提到了反射这个概念。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; // &lt;/span&gt;&lt;span&gt;通过反射机制，通知力宏做事情&lt;/span&gt;
 method.invoke(object, args);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过反射，将h作为参数，实例化代理类，返回代理类实例。&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; cons.newInstance(&lt;span&gt;new&lt;/span&gt; Object[]{h});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而且在&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将接口类对象数组clone一份。&lt;/span&gt;
 &lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt;[] intfs = interfaces.clone();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也提到一个类对象数组的概念，如果你不知道反射，不知道类对象，那么你在阅读者两篇文章的时候，很可能就会雨里雾里，不知所然。通过这篇文章你就能很轻松的掌握类对象和反射。&lt;/p&gt;
&lt;p&gt;反射是java语言中一个很基础，很简单的知识，不仅仅是在工作中会用到，而且也会经常出现在面试中。如果你认真阅读本文，对你在技术层面来说又是一个提升。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一，前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　反射是什么呢？其实是jiava程序语言的一种机制，我理解为是java的后门。在其他文章中给出的定义和解释都比较晦涩难懂，不如先看一下具体的代码，再去理解，这样就容易很多。&lt;/p&gt;
&lt;p&gt;　　为了更好的理解反射机制，不得不提到类对象的概念，为了不与类和对象的概念搞混，我们就首先看一下类和对象的概念。相信你已经非常熟悉类和对象的概念了，那么我就简单的描述一下类与对象的概念：&lt;/p&gt;
&lt;p&gt;　　　　类：一个或一组事物的抽象描述，例如狗是对狗狗这一组事物的抽象描述。&lt;/p&gt;
&lt;p&gt;　　　　对象：具体的某一个事物，例如哈士奇等，也可以说是类的一个实例。&lt;/p&gt;
&lt;p&gt;　　那么类对象是什么呢？&lt;/p&gt;
&lt;p&gt;　　　　在java中一切皆对象。既然一切皆对象，当然类也是一种对象，那么类的对象类型是什么呢？是java.lang.Class，你也许在其他的地方见到过。&lt;/p&gt;
&lt;p&gt;　　那么类对象是从哪里来的，怎么创建的呢？&lt;/p&gt;
&lt;p&gt;　　　　我们都知道，想要得到一个类的对象，最基本的方法就是通过new关键字，去实例化一个对象。但类对象是一个特殊的对象，自然不能使用new关键字，翻看Class类的源码就可以证明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * 私有化构造方法，只有java 虚拟机才能创建类对象
     * Private constructor. Only the Java Virtual Machine creates Class objects.
     * This constructor is not used and prevents the default constructor being
     * generated.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Class(ClassLoader loader) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initialize final field for classLoader.  The initialization value of non-null
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; prevents future JIT optimizations from assuming this final field is null.&lt;/span&gt;
        classLoader =&lt;span&gt; loader;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Class类中只有这一个私有的构造方法。其实类对象是java虚拟机（JVM）在加载class文件的时候自动在虚拟机内存中给我们创建的。&lt;/p&gt;
&lt;p&gt;　　　　这里就涉及到了另外一个机制：类加载机制。&lt;/p&gt;
&lt;p&gt;　　　　简单描述一下类加载机制：就是虚拟机将class文件加载到虚拟机内存中，最终形成可以被虚拟机直接使用的java类型。虚拟机会将class文件中的信息按照所需的存储格式放在方法区中，同时会在内存中（HotSpot是在堆内存中）实例化一个java.lang.Class类对象。&lt;/p&gt;
&lt;p&gt;　　类加载机制是一个很复杂的过程，不是本篇文章的重点，就不展开来说。至少到这里我们已经知道了，类对象是由虚拟机创建的而且HotSpot虚拟机将类对象存放在堆内存中。&lt;/p&gt;
&lt;p&gt;　　那么怎么通过类对象来实现反射呢？为了理解方便，来举一个有趣的例子&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二，一个有趣的例子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　有一天一个同事养了一只狗狗哈士奇，在作者面前大肆炫耀，说他的狗狗多么萌，多么威武，多么听话......，作者听完心生向往，提出去看一看。但是这个同事高傲的抬起头说了三个字：想的美。&lt;/p&gt;
&lt;p&gt;　　竟然不给我看！！！作者一气之下，就走了java程序的后门-反射。你不让我看，我偏偏要看。&lt;/p&gt;
&lt;p&gt;　　哈士奇类的定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.zcz.reflecttest;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HaShiQi &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Dog {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String color = &quot;黑色&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String name = &quot;富贵&quot;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有化构造&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; HaShiQi() {};
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(name + &quot; 去吃狗粮&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(name + &quot; 去跑着玩儿&quot;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dance() {
        System.out.println(name &lt;/span&gt;+ &quot; 来跳一支舞&quot;&lt;span&gt;);
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &quot;名字：&quot;+name+&quot;;颜色：&quot;+&lt;span&gt;color;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到同时的哈士奇实现了Dog接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.zcz.reflecttest;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Dog {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从代码中可以看到，我的同事不仅仅没告诉作者他的哈士奇竟然会跳舞，甚至连哈士奇的名字都不想让作者知道，而且连构造器都私有化了。&lt;/p&gt;
&lt;p&gt;　　那么接下来，走后门开始。在上提到类对象，正好我想通过反射看狗狗，也需要用到类对象。那么接下来第一步就先获取HaShiQi的类对象。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三，类对象的获取&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　超级简单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.zcz.reflecttest;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 通过反射查看同事狗狗的信息
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; zhangchengzi
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LookLook {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取类对象，除了这份方法外还有另外两种方法&lt;/span&gt;
        Class clazz = HaShiQi.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从这里开始我们的反射的使用的开始了，先看看HaShiQi类中有哪些属性吧？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四，获取属性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取类对象，除了这份方法外还有另外两种方法&lt;/span&gt;
        Class clazz = HaShiQi.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有公有的属性  —————————&quot;&lt;span&gt;);
        Field[] fields &lt;/span&gt;=&lt;span&gt; clazz.getFields();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Field field : fields) {
            field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            System.out.println(field);
        }    
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;——————— 获取所有公有的属性  —————————
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.color
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到只有一个color属性，使用getFields方法是获取不到私有属性了，想要获取私有属性就要使用下方的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取类对象，除了这份方法外还有另外两种方法&lt;/span&gt;
        Class clazz = HaShiQi.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有公有的属性  —————————&quot;&lt;span&gt;);
        Field[] fields &lt;/span&gt;=&lt;span&gt; clazz.getFields();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Field field : fields) {
            field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            System.out.println(field);
        }
        
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有的属性  —————————&quot;&lt;span&gt;);
        fields &lt;/span&gt;=&lt;span&gt; clazz.getDeclaredFields();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Field field : fields) {
            field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            System.out.println(field);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;——————— 获取所有公有的属性  —————————
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.color
——————— 获取所有的属性  —————————
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.color
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.name
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，HaShiQi类中私有（private修饰的）的name属性打印出来了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五，获取方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取类对象，除了这份方法外还有另外两种方法&lt;/span&gt;
        Class clazz = HaShiQi.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有公有的属性  —————————&quot;&lt;span&gt;);
        Field[] fields &lt;/span&gt;=&lt;span&gt; clazz.getFields();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Field field : fields) {
            field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            System.out.println(field);
        }
        
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有的属性  —————————&quot;&lt;span&gt;);
        fields &lt;/span&gt;=&lt;span&gt; clazz.getDeclaredFields();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Field field : fields) {
            field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            System.out.println(field);
        }
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有公有的方法  —————————&quot;&lt;span&gt;);
        Method[] methods &lt;/span&gt;=&lt;span&gt; clazz.getMethods();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Method method : methods) {
            System.out.println(method);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;——————— 获取所有公有的属性  —————————
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.color
——————— 获取所有的属性  —————————
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.color
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.name
——————— 获取所有公有的方法  —————————
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; com.zcz.reflecttest.HaShiQi.run()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重写的toString 方法&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.toString()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; com.zcz.reflecttest.HaShiQi.eat()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Object类中的方法&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; java.lang.Object.wait() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; java.lang.InterruptedException
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; java.lang.Object.wait(&lt;span&gt;long&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; java.lang.InterruptedException
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; java.lang.Object.wait(&lt;span&gt;long&lt;/span&gt;) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; java.lang.InterruptedException
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; java.lang.Object.equals(java.lang.Object)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; java.lang.Object.hashCode()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt;&lt;span&gt; java.lang.Class java.lang.Object.getClass()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; java.lang.Object.notify()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; java.lang.Object.notifyAll()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从结果中可以发现，getMethod方法也是只能获取到公有的方法，而且连Object中的方法也获取到了。跟获取属性也是一样的，也有方法可以获取到HaShiQi类中所有的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取类对象，除了这份方法外还有另外两种方法&lt;/span&gt;
        Class clazz = HaShiQi.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有公有的属性  —————————&quot;&lt;span&gt;);
        Field[] fields &lt;/span&gt;=&lt;span&gt; clazz.getFields();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Field field : fields) {
            field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            System.out.println(field);
        }
        
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有的属性  —————————&quot;&lt;span&gt;);
        fields &lt;/span&gt;=&lt;span&gt; clazz.getDeclaredFields();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Field field : fields) {
            field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            System.out.println(field);
        }
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有公有的方法  —————————&quot;&lt;span&gt;);
        Method[] methods &lt;/span&gt;=&lt;span&gt; clazz.getMethods();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Method method : methods) {
            System.out.println(method);
        }
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有类中声明的方法  —————————&quot;&lt;span&gt;);
        methods &lt;/span&gt;=&lt;span&gt; clazz.getDeclaredMethods();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Method method : methods) {
            System.out.println(method);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;——————— 获取所有公有的属性  —————————
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.color
——————— 获取所有的属性  —————————
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.color
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.name
——————— 获取所有公有的方法  —————————
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; com.zcz.reflecttest.HaShiQi.run()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.toString()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; com.zcz.reflecttest.HaShiQi.eat()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; java.lang.Object.wait() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; java.lang.InterruptedException
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; java.lang.Object.wait(&lt;span&gt;long&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; java.lang.InterruptedException
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; java.lang.Object.wait(&lt;span&gt;long&lt;/span&gt;) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; java.lang.InterruptedException
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; java.lang.Object.equals(java.lang.Object)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; java.lang.Object.hashCode()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt;&lt;span&gt; java.lang.Class java.lang.Object.getClass()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; java.lang.Object.notify()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; java.lang.Object.notifyAll()
——————— 获取所有类中声明的方法  —————————
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; com.zcz.reflecttest.HaShiQi.run()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.toString()
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; com.zcz.reflecttest.HaShiQi.dance()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; com.zcz.reflecttest.HaShiQi.eat()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样就可以同时获取到HaShiQi类中的私有方法（private修饰的）dance了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;六，获取构造器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取类对象，除了这份方法外还有另外两种方法&lt;/span&gt;
        Class clazz = HaShiQi.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有公有的属性  —————————&quot;&lt;span&gt;);
        Field[] fields &lt;/span&gt;=&lt;span&gt; clazz.getFields();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Field field : fields) {
            field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            System.out.println(field);
        }
        
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有的属性  —————————&quot;&lt;span&gt;);
        fields &lt;/span&gt;=&lt;span&gt; clazz.getDeclaredFields();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Field field : fields) {
            field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            System.out.println(field);
        }
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有公有的方法  —————————&quot;&lt;span&gt;);
        Method[] methods &lt;/span&gt;=&lt;span&gt; clazz.getMethods();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Method method : methods) {
            System.out.println(method);
        }
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有类中声明的方法  —————————&quot;&lt;span&gt;);
        methods &lt;/span&gt;=&lt;span&gt; clazz.getDeclaredMethods();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Method method : methods) {
            System.out.println(method);
        }
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有公有的构造器  —————————&quot;&lt;span&gt;);
        Constructor[] constructors &lt;/span&gt;=&lt;span&gt; clazz.getConstructors();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Constructor constructor : constructors) {
            System.out.println(constructor);
        }
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;——————— 获取所有公有的属性  —————————
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.color
——————— 获取所有的属性  —————————
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.color
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.name
——————— 获取所有公有的方法  —————————
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; com.zcz.reflecttest.HaShiQi.run()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.toString()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; com.zcz.reflecttest.HaShiQi.eat()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; java.lang.Object.wait() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; java.lang.InterruptedException
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; java.lang.Object.wait(&lt;span&gt;long&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; java.lang.InterruptedException
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; java.lang.Object.wait(&lt;span&gt;long&lt;/span&gt;) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; java.lang.InterruptedException
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; java.lang.Object.equals(java.lang.Object)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; java.lang.Object.hashCode()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt;&lt;span&gt; java.lang.Class java.lang.Object.getClass()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; java.lang.Object.notify()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; java.lang.Object.notifyAll()
——————— 获取所有类中声明的方法  —————————
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; com.zcz.reflecttest.HaShiQi.run()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.toString()
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; com.zcz.reflecttest.HaShiQi.dance()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; com.zcz.reflecttest.HaShiQi.eat()
——————— 获取所有公有的构造器  —————————&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因为HaShiQi类中没有公有的构造器，所以这里什么都没有打印出来。自然也有获取到私有构造器的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取类对象，除了这份方法外还有另外两种方法&lt;/span&gt;
        Class clazz = HaShiQi.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有公有的属性  —————————&quot;&lt;span&gt;);
        Field[] fields &lt;/span&gt;=&lt;span&gt; clazz.getFields();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Field field : fields) {
            field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            System.out.println(field);
        }
        
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有的属性  —————————&quot;&lt;span&gt;);
        fields &lt;/span&gt;=&lt;span&gt; clazz.getDeclaredFields();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Field field : fields) {
            field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            System.out.println(field);
        }
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有公有的方法  —————————&quot;&lt;span&gt;);
        Method[] methods &lt;/span&gt;=&lt;span&gt; clazz.getMethods();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Method method : methods) {
            System.out.println(method);
        }
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有类中声明的方法  —————————&quot;&lt;span&gt;);
        methods &lt;/span&gt;=&lt;span&gt; clazz.getDeclaredMethods();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Method method : methods) {
            System.out.println(method);
        }
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有公有的构造器  —————————&quot;&lt;span&gt;);
        Constructor[] constructors &lt;/span&gt;=&lt;span&gt; clazz.getConstructors();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Constructor constructor : constructors) {
            System.out.println(constructor);
        }
        System.out.println(&lt;/span&gt;&quot;——————— 获取所有的构造器  —————————&quot;&lt;span&gt;);
        constructors &lt;/span&gt;=&lt;span&gt; clazz.getDeclaredConstructors();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Constructor constructor : constructors) {
            System.out.println(constructor);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;——————— 获取所有公有的属性  —————————
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.color
——————— 获取所有的属性  —————————
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.color
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.name
——————— 获取所有公有的方法  —————————
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; com.zcz.reflecttest.HaShiQi.run()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.toString()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; com.zcz.reflecttest.HaShiQi.eat()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; java.lang.Object.wait() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; java.lang.InterruptedException
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; java.lang.Object.wait(&lt;span&gt;long&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; java.lang.InterruptedException
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; java.lang.Object.wait(&lt;span&gt;long&lt;/span&gt;) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; java.lang.InterruptedException
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; java.lang.Object.equals(java.lang.Object)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; java.lang.Object.hashCode()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt;&lt;span&gt; java.lang.Class java.lang.Object.getClass()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; java.lang.Object.notify()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; java.lang.Object.notifyAll()
——————— 获取所有类中声明的方法  —————————
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; com.zcz.reflecttest.HaShiQi.run()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String com.zcz.reflecttest.HaShiQi.toString()
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; com.zcz.reflecttest.HaShiQi.dance()
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; com.zcz.reflecttest.HaShiQi.eat()
——————— 获取所有公有的构造器  —————————
——————— 获取所有的构造器  —————————
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; com.zcz.reflecttest.HaShiQi()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;七，实例化对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　HaSHiQi类中的信息，包括属性，方法，构造器，我们都已经通过反射浏览了一遍，那么接下来就要再使用反射实例化HaShiQi类的对象了，因为只有实例对象才能调用属性和方法。&lt;/p&gt;
&lt;p&gt;　　因为HaShiQi类中只显示声明了一个空参构造器，所以我们只能使用这个构造器来实例化对象。&lt;/p&gt;
&lt;p&gt;　　正常情况下获取指定参数的构造器，需要使用方法clazz.getConstructor(parameterTypes(参数类对象数组))。但是HaShiQi的构造方法是私有的，所以使用这个方法去获取构造器会报错：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Constructor cons = clazz.getConstructor();
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Exception in thread &quot;main&quot; java.lang.NoSuchMethodException: com.zcz.reflecttest.HaShiQi.&amp;lt;init&amp;gt;&lt;span&gt;()
    at java.lang.Class.getConstructor0(Class.java:&lt;/span&gt;3082&lt;span&gt;)
    at java.lang.Class.getConstructor(Class.java:&lt;/span&gt;1825&lt;span&gt;)
    at com.zcz.reflecttest.LookLook.main(LookLook.java:&lt;/span&gt;61)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所以我们使用另外一个方法解决这个问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例化对象
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取构造器&lt;/span&gt;
        Constructor con =&lt;span&gt; clazz.getDeclaredConstructor();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 强制设置为可以访问&lt;/span&gt;
        con.setAccessible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        HaShiQi haShiQi &lt;/span&gt;=&lt;span&gt; (HaShiQi)con.newInstance();
        System.out.println(&lt;/span&gt;&quot;没有做任何修改前：&quot;+haShiQi.toString());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　打印结果：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
没有做任何修改前：名字：富贵;颜色：黑色
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　哈哈，机智如我，怎么能被这种问题打到，从代码中可以看到我们使用了构造器的newInstance方法实例化了一个HaShiQi对象。&lt;/p&gt;
&lt;p&gt;　　　　代码：con.newInstance();&lt;/p&gt;
&lt;p&gt;　　　　是不是很熟悉？，在文章&lt;a id=&quot;post_title_link_9713807&quot; href=&quot;https://www.cnblogs.com/zhangchengzi/p/9713807.html&quot;&gt;JAVA设计模式-动态代理(Proxy)源码分析&lt;/a&gt;中，实例化代理类对象的时候，也使用到了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过反射，将h作为参数，实例化代理类，返回代理类实例。&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; cons.newInstance(&lt;span&gt;new&lt;/span&gt; Object[]{h});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来就是访问对象的属性和方法了如果我们把所有的属性和方法都访问到，不就把同事的狗狗看了一遍了吗？。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;八，修改属性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改狗狗的颜色
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取狗狗的color属性&lt;/span&gt;
        Field filed = clazz.getField(&quot;color&quot;&lt;span&gt;);
        filed.set(haShiQi, &lt;/span&gt;&quot;红色&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;修改狗狗的颜色：&quot;+haShiQi.toString());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　打印结果：　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;没有做任何修改前：名字：富贵;颜色：黑色
修改狗狗的颜色：名字：富贵;颜色：红色&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　修改成功，接着修改狗狗的名字：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改狗狗的颜色
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取狗狗的color属性&lt;/span&gt;
        Field filed = clazz.getField(&quot;color&quot;&lt;span&gt;);
        filed.set(haShiQi, &lt;/span&gt;&quot;红色&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;修改狗狗的颜色：&quot;+&lt;span&gt;haShiQi.toString());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改狗狗的名字&lt;/span&gt;
        filed = clazz.getDeclaredField(&quot;name&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 强制设置为可以访问&lt;/span&gt;
        filed.setAccessible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        filed.set(haShiQi, &lt;/span&gt;&quot;惊喜&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;修改狗狗的名字：&quot;+haShiQi.toString());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;没有做任何修改前：名字：富贵;颜色：黑色
修改狗狗的颜色：名字：富贵;颜色：红色
修改狗狗的名字：名字：惊喜;颜色：红色&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　修改成功，但是千万要注意是的是的getDeclaredField方法，而不是getField方法，使用getField方法会抛出异常：Exception in thread &quot;main&quot; java.lang.NoSuchFieldException: name；&lt;/p&gt;
&lt;p&gt;　　同时filed.setAccessible(true);也是必不可少了，否则将抛出异常：Exception in thread &quot;main&quot; java.lang.IllegalAccessException: Class com.zcz.reflecttest.LookLook can not access a member of class com.zcz.reflecttest.HaShiQi with modifiers &quot;private&quot;&lt;/p&gt;
&lt;p&gt;　　属性修改完，我们就开始调用方法吧。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;九，调用方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用run方法&lt;/span&gt;
        Method method = clazz.getMethod(&quot;run&quot;&lt;span&gt;);
        method.invoke(haShiQi, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
惊喜 去跑着玩儿
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　调用成功；&lt;/p&gt;
&lt;p&gt;　　　　代码：method.invoke(haShiQi, null);&lt;/p&gt;
&lt;p&gt;　　是不是觉得这句代码也是很熟悉的？在文章&lt;a id=&quot;post_title_link_9700248&quot; href=&quot;https://www.cnblogs.com/zhangchengzi/p/9700248.html&quot;&gt;JAVA设计模式-动态代理(Proxy)示例及说明&lt;/a&gt;中也有相同的用法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过反射机制，通知力宏做事情&lt;/span&gt;
 method.invoke(object, args);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们继续，eat方法和run方法一样，都是公有的方法，这里就不再演示了，接下来演示一下私有的dance方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用run方法&lt;/span&gt;
        Method method = clazz.getMethod(&quot;run&quot;&lt;span&gt;);
        method.invoke(haShiQi, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用dance方法&lt;/span&gt;
        method = clazz.getDeclaredMethod(&quot;dance&quot;&lt;span&gt;);
        method.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        method.invoke(haShiQi, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;惊喜 去跑着玩儿
惊喜 来跳一支舞&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　也同样成功了，但是也要注意getDeclaredMethod方法和method.setAccessible(true);&lt;/p&gt;
&lt;p&gt;　　到这里，同事不让我看的狗狗，我通过java的反射机制从里到外的全部都看了一遍，不仅仅是看了一遍，我还给他的狗狗改了颜色和名字。调用了所有的方法。是不是很神奇，很有成就感？&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;十，总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　反射的基本用法已经都在上面的实例中演示到了，但是反射还是有其他的方法在这里并没有提到，有机会的话继续补充。&lt;/p&gt;
&lt;p&gt;　　在上面的代码过程中，你也许也发现了，不仅仅是有类对象，而且还有属性,方法和构造器都是对象，属性是java.lang.reflect.Field类的对象，方法是java.lang.reflect.Method类的对象，构造器是java.lang.reflect.Constructor类的对象。看来在java中确实是一切皆对象。&lt;/p&gt;

&lt;p&gt;　　好了，来看看其他文章中对反射的解释吧：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;　　Java 反射机制是在运行状态中，对于任意一个类，都能够获得这个类的所有属性和方法，对于任意一个对象都能够调用它的任意一个属性和方法。这种在运行时动态的获取信息以及动态调用对象的方法的功能称为 Java 的反射机制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　在上面的例子中，我们是不是在运行中，获取了HaShiQi的属性和方法（包括私有的），是不是调用了每一个属性和方法（包括私有的）。&lt;/p&gt;
&lt;p&gt;　　这样一来，反射机制是不是好理解一点儿了呢，希望能帮到你。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; 原创不易，转载请注明出处：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: Java程序语言的后门-反射机制&quot; href=&quot;https://www.cnblogs.com/zhangchengzi/p/9723250.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/zhangchengzi/p/9723250.html&lt;/a&gt; &lt;/p&gt;

</description>
<pubDate>Sat, 29 Sep 2018 05:27:00 +0000</pubDate>
<dc:creator>张橙子</dc:creator>
<og:description>在文章JAVA设计模式-动态代理(Proxy)示例及说明和JAVA设计模式-动态代理(Proxy)源码分析都提到了反射这个概念。 而且在 也提到一个类对象数组的概念，如果你不知道反射，不知道类对象，那</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangchengzi/p/9723250.html</dc:identifier>
</item>
<item>
<title>Altium制作DC002的PCB封装和3D模型 - Scrazy</title>
<link>http://www.cnblogs.com/scrazy/p/9723188.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/scrazy/p/9723188.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://p40kod8nr.bkt.clouddn.com/18-9-28/87448333.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;常用的电源连接器（Dc Power Jack Connector）DC002、DC005等等型号的3D模型在网上很难找到合适的，我们可以选择CUI 公司生产的电源连接器来替代，因为CUI 公司生产的每一款电源连接器都免费提供了公开的3D模型。这我们演示如何在CUI 官网上寻找合适的DC002/DC005的&lt;code&gt;.STEP&lt;/code&gt;3D模型。&lt;/p&gt;
&lt;p&gt;打开DC002的尺寸图，我们发现GUI公司的PJ-007型号可以替代DC002，他们的尺寸相差无几。&lt;/p&gt;
&lt;p&gt;这是PJ-007的尺寸图，详细文档信息移步参考https://www.cn.cui.com/product/resource/pj-007.pdf&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p40kod8nr.bkt.clouddn.com/18-9-29/29135878.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择合适的型号后，即可下载AltiumDesigner可导入的&lt;code&gt;.STEP&lt;/code&gt;3D模型和PCB封装文件，这里需要选择的CAD文件类型为Altum支持的类型，如图。&lt;/p&gt;
&lt;p&gt;我们点击下载后却发现，服务器拒绝了我们的访问。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p40kod8nr.bkt.clouddn.com/18-9-29/67576332.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候，我们可能需要移步到traceparts上去下载文件。首先打开traceparts的官网，搜索 pj-007，下载选项选择AD，点击箭头处的下载按钮即可下载。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p40kod8nr.bkt.clouddn.com/18-9-29/31748050.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后，看到这样的页面，点击下载按钮后得到一个压缩包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p40kod8nr.bkt.clouddn.com/18-9-29/51711130.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们解压文件并进入&lt;code&gt;LIB_PJ-007\PJ-007\Altium&lt;/code&gt;文件夹，发现有三个脚本文件，如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p40kod8nr.bkt.clouddn.com/18-9-29/73813303.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开Readme.html阅读后，知晓Altium支持通过脚本来导入PCB封装和3D模型。&lt;/p&gt;
&lt;p&gt;具体操作参考给出的链接，Altium官方给出的教程，很详细，这里不再赘述。&lt;/p&gt;
&lt;p&gt;导入成功后，我们发现&lt;code&gt;LIB_PJ-007\PJ-007\Altium&lt;/code&gt;文件夹多了一个通过脚本生成的PCB工程文件，包含了原理图库和PCB库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p40kod8nr.bkt.clouddn.com/18-9-29/90964393.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将3D模型和PCB封装对齐注意&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将机械层与丝印层吻合，使轴线通过1号引脚&lt;/li&gt;
&lt;li&gt;调整高度&lt;/li&gt;
&lt;li&gt;使用旋转，便于看清是否对齐，如垂直旋转&lt;img src=&quot;http://p40kod8nr.bkt.clouddn.com/18-9-29/35364088.jpg&quot;/&gt;&lt;/li&gt;
&lt;li&gt;放置时，注意，元件引脚因该是紧贴于焊盘表面（丝印层之上），而不是陷阱焊盘。观察二者区别。&lt;img src=&quot;http://p40kod8nr.bkt.clouddn.com/18-9-29/48454815.jpg&quot;/&gt;&lt;img src=&quot;http://p40kod8nr.bkt.clouddn.com/18-9-29/5581263.jpg&quot;/&gt;&lt;/li&gt;
&lt;li&gt;​&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这是导入的DC002的PCB封装：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p40kod8nr.bkt.clouddn.com/18-9-29/40742612.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是导入的DC002的3D模型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p40kod8nr.bkt.clouddn.com/18-9-29/65269753.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Scrazy整理发布，2018年9月29日&lt;/p&gt;
</description>
<pubDate>Sat, 29 Sep 2018 05:10:00 +0000</pubDate>
<dc:creator>Scrazy</dc:creator>
<og:description>Altium制作DC002的PCB封装和3D模型 常用的电源连接器（Dc Power Jack Connector）DC002、DC005等等型号的3D模型在网上很难找到合适的，我们可以选择CUI 公</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/scrazy/p/9723188.html</dc:identifier>
</item>
<item>
<title>交互式 shell 玩转 Python - hoxis</title>
<link>http://www.cnblogs.com/hoxis/p/9723120.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hoxis/p/9723120.html</guid>
<description>&lt;p&gt;Python 编程语言已经成为 IT 中使用的最流行的语言之一。成功的一个原因是它可以用来解决各种问题。从网站开发到数据科学、机器学习到任务自动化，Python 生态系统有丰富的框架和库。本文将介绍 Ubuntu 软件包集合中提供的一些有用的 Python shell 来简化我们的开发。&lt;/p&gt;

&lt;p&gt;Python Shell 即原生的 Python 交互环境，可以让你以交互模式使用 Python 解释器。这在测试代码或尝试新库时非常有用。在 Ubuntu 中，你可以通过在终端会话中输入 &lt;code&gt;python&lt;/code&gt; 来调用默认的 shell。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;$ python
Python 3.5.2 (default, Nov 23 2017, 16:37:01)
[GCC 5.4.0 20160609] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&amp;gt;&amp;gt;&amp;gt; print('hi')
hi&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;IPython 为 Python shell 提供了许多有用的增强功能。例如包括 tab 补全，对象内省，可以调用系统 shell 访问和命令历史检索。&lt;/p&gt;
&lt;h2 id=&quot;安装和运行-ipython&quot;&gt;安装和运行 IPython&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ pip install ipython

$ ipython --version
6.5.0&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;自动补全&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 ipython 环境下就可以使用 tab 补全啦，当遇到使用不熟悉的库时，此功能会派上用场。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/hoxis/token4md/raw/master/1532942578403.jpg&quot; alt=&quot;自动补全&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果不熟悉某个库的某个方法，可以输入 &lt;code&gt;?&lt;/code&gt; 命令来查看文档。对此的更多详细信息，也可以使用 &lt;code&gt;??&lt;/code&gt;命令。这就叫做对象的内省。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/hoxis/token4md/raw/master/1532942697607.jpg&quot; alt=&quot;再也不用担心没有文档了&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;shell命令&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另一个很酷的功能是使用 &lt;code&gt;!&lt;/code&gt; 字符执行系统 shell 命令的能力。然后还可以在 IPython shell 中引用该命令的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/hoxis/token4md/raw/master/1532943087560.jpg&quot; alt=&quot;执行系统 shell&quot;/&gt;&lt;/p&gt;
&lt;p&gt;IPython 完整的功能列表可在&lt;a href=&quot;https://ipython.readthedocs.io/en/stable/overview.html#main-features-of-the-interactive-shell&quot;&gt;官方文档&lt;/a&gt;中找到。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;crtl+r&lt;/code&gt; 可以搜索历史命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/hoxis/token4md/raw/master/1532943481103.jpg&quot; alt=&quot;搜索历史命令&quot;/&gt;&lt;/p&gt;

&lt;p&gt;bpython 并不能像 IPython 做那么多，但它却在一个简单的轻量级包中提供了一系列有用功能。除其他功能之外，bpython 提供：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内嵌语法高亮显示&lt;/li&gt;
&lt;li&gt;在你输入时提供自动补全建议&lt;/li&gt;
&lt;li&gt;可预期的参数列表，bpython可以在调用函数时显示参数列表。&lt;/li&gt;
&lt;li&gt;能够将代码发送或保存到 pastebin 服务或文件中&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;安装和运行-bpython&quot;&gt;安装和运行 bpython&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ pip install bpython

$ bpython --version
bpython version 0.17.1 on top of Python 3.5.2 /usr/bin/python
(C) 2008-2016 Bob Farrell, Andreas Stuehrk, Sebastian Ramacher, Thomas Ballinger, et al. See AUTHORS for detail.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在你输入的时候，&lt;code&gt;bpython&lt;/code&gt; 为你提供了选择来自动补全你的代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/hoxis/token4md/raw/master/201807301748.gif&quot; alt=&quot;自动补全&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当你调用函数或方法时，会自动显示需要的参数和文档字符串。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/hoxis/token4md/raw/master/201807301750.gif&quot; alt=&quot;自动显示函数参数&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/hoxis/token4md/raw/master/e0b9585ec907d8ab88d0d880f9803f8a.gif&quot; alt=&quot;用法演示&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有关配置和功能的更多细节，请参考 &lt;a href=&quot;https://docs.bpython-interpreter.org/&quot;&gt;bpython 官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;使用增强的 Python shell 是提高生产力的好方法。它为你提供增强的功能来编写快速原型或尝试新库。&lt;/p&gt;
&lt;p&gt;你在使用增强的 Python shell 吗？来留言分享吧~&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;如果觉得有用，欢迎关注我的微信，一起学习，共同进步，不定期推出赠书活动~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1254259578.cos.ap-shanghai.myqcloud.com/picgo/20180907174146.png&quot; alt=&quot;你的关注是对我最大的鼓励！&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最近搜集到传智播客 2018 最新 Python 和 Java 教程！关注本公众号，后台回复「2018」即可获取下载地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;0.58823529411765&quot;&gt;
&lt;p&gt;参考: &lt;a href=&quot;https://fedoramagazine.org/enhance-python-interactive-shell/&quot; class=&quot;uri&quot;&gt;https://fedoramagazine.org/enhance-python-interactive-shell/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 29 Sep 2018 04:41:00 +0000</pubDate>
<dc:creator>hoxis</dc:creator>
<og:description>Python 编程语言已经成为 IT 中使用的最流行的语言之一。成功的一个原因是它可以用来解决各种问题。从网站开发到数据科学、机器学习到任务自动化，Python 生态系统有丰富的框架和库。本文将介绍</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hoxis/p/9723120.html</dc:identifier>
</item>
</channel>
</rss>