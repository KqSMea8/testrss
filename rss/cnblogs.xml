<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>观察者模式和发布订阅模式（上） - liuyongjia</title>
<link>http://www.cnblogs.com/liuyongjia/p/9404627.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyongjia/p/9404627.html</guid>
<description>&lt;p&gt;定义：观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。&lt;br/&gt;其中有两个定义需要明确，被观察者和观察者。通常来说，这两者是一对多的，也有多对多的情景。&lt;br/&gt;在网页开发中，被观察者通常是数据源，不论是内存数据，还是持久化数据，又或者是接口返回的数据，都可以作为被观察者。它一旦改变，就去改变依赖于它的节点。&lt;br/&gt;观察者有很多可能，针对于网页开发，我们常常认为dom节点是观察者，一旦节点的监视的数据源发生变化，节点也执行更新方法。当然不限于此，也有可能是一个事件，一次计数等等。&lt;br/&gt;接下来用js写一个简单的观察者模式的例子：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 发布类
class Subject {
  constructor (data) {
    this.obList = [];
    this.data = data;
  }
  add (ob) {
    if (arguments.length &amp;gt;= 1) {
      Array.from(arguments).forEach(item =&amp;gt; this.obList.push(item));
    }
  }
  remove (ob) {
    let i = this.obList.findIndex(ele =&amp;gt; ele === ob);
    if (i &amp;gt;= 0) {
      this.obList.splice(i, 1);
    }
  }
  notify () {
    this.obList.forEach((item) =&amp;gt; {
      item.update(this.data);
    })
  }
}

// 观察者类
class Observer {
  constructor (id) {
    this.id = id;
  }
  update (data) {
    console.log('observer ' + this.id + ': ' + data + ';');
  }
}

function test() {
  let sub = new Subject('test');

  let ob1 = new Observer(1);
  let ob2 = new Observer(2);
  let ob3 = new Observer(3);

  sub.add(ob1, ob2, ob3);

  sub.notify();

  sub.remove(ob2);

  sub.notify();
}

test();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;observer 1: test;
observer 2: test;
observer 3: test;
observer 1: test;
observer 3: test;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里简单定义了一个发布类和一个观察类，发布者维护一个观察者列表，每次数据变化后，依次通知所有在观察者列表里的观察者。&lt;br/&gt;代码很简单，可以执行在控制台或者node里跑一下。&lt;br/&gt;但是这样的耦合很深，观察者和发布者不能有其他的表现，很死板，我们可以继续抽象一下。&lt;br/&gt;先画个类图：&lt;br/&gt;&lt;img src=&quot;http://img30.360buyimg.com/mobilecms/jfs/t23902/230/1500739281/31627/5fe11ead/5b61cc13Ndfa470fc.jpg&quot; alt=&quot;类图&quot;/&gt;&lt;br/&gt;借助于TypeScript，我们可以有如下的发布者和观察者定义。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;abstract class Observer {
    abstract update();
}

abstract class Subject {
    protected obList: ObserverList;
    abstract notify();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ObserverList则可以实现如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class ObserverList {
    private list: Array&amp;lt;Observer&amp;gt;;
    constructor () {
        this.list = [];
    }
    add (ob: Observer) {
        this.list.push(ob);
    }

    remove (ob: Observer) {
        if (this.list.indexOf(ob) &amp;gt; -1) {
            this.list.splice(this.list.indexOf(ob), 1);
        }
    }

    empty () {
        this.list = [];
    }

    public each () {
        this.list.forEach(item =&amp;gt; {
            item.update();
        })
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来实现两个实体类：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 实体发布类
class ConcreteSubject extends Subject {
    protected obList = new ObserverList();

    private _data: string;

    constructor (defaultData: string) {
        super();
        this._data = defaultData;
    }

    set data (newVaule) {
        this._data = newVaule;
    }
    get data () {
        return this._data;
    }

    add (ob: Observer) {
        this.obList.add(ob);
    }
    remove (ob: Observer) {
        this.obList.remove(ob);
    }
    notify () {
        this.obList.each()
    }
}

// 可以指定发布者的观察者类
class ConcreteObserver extends Observer {
    readonly _id;
    private sub;

    constructor (id, sub) {
        super();
        this._id = id;
        this.sub = sub;
    }

    get id () {
        return this._id;
    }

    update () {
        console.log('concrete observer ' + this.id + ': ' + this.sub.data);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跑一下测试代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let sub = new ConcreteSubject('test');

let ob1 = new ConcreteObserver(1, sub);
let ob2 = new ConcreteObserver(2, sub);
let ob3 = new ConcreteObserver(3, sub);

sub.add(ob1)
sub.add(ob2)
sub.add(ob3)

sub.notify();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的发布类，使用add、remove等方法来处理观察者列表，通过notify方法，则去通知观察者们，可以去执行update方法了。&lt;br/&gt;观察者和被观察者，仍然耦合比较深，所以又有人提出来发布订阅模式，维护一个事件中心，来处理多个观察者和被观察者的关系，不让他们直接耦合在一起。下一篇对发布订阅做解析。&lt;/p&gt;
</description>
<pubDate>Wed, 01 Aug 2018 15:28:00 +0000</pubDate>
<dc:creator>liuyongjia</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuyongjia/p/9404627.html</dc:identifier>
</item>
<item>
<title>字符串hash与字典树 - 31415926535x</title>
<link>http://www.cnblogs.com/31415926535x/p/9404591.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/31415926535x/p/9404591.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;title: 字符串hash与字典树&lt;br/&gt;date: 2018-08-01 22:05:29&lt;br/&gt;tags:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;acm&lt;/li&gt;
&lt;li&gt;算法&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&quot;字符串&quot;&gt;字符串&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;这篇主要是关于字符串里的 &lt;strong&gt;字符串hash&lt;/strong&gt; 和 &lt;strong&gt;字符串字典树&lt;/strong&gt;，，两个都是简单的套模板的东西，，，理解基本思想就行了，，，对了，，还有一个字典树的的变形--&lt;strong&gt;01字典树&lt;/strong&gt;；&lt;/p&gt;
&lt;h2 id=&quot;字符串hash&quot;&gt;字符串hash&lt;/h2&gt;
&lt;h3 id=&quot;如何求一个字符串的hash值&quot;&gt;如何求一个字符串的hash值&lt;/h3&gt;
&lt;p&gt;字符串hash的作用就是将 &lt;em&gt;字符串有效的转化为一个整数&lt;/em&gt; ，，这个转化过程利用的是一个 &lt;strong&gt;hash函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如，，我们选hash函数为 &lt;span class=&quot;math inline&quot;&gt;\(hash[i]=(hash[i-1]*p+idx(s[i]))%mod\)&lt;/span&gt;&lt;br/&gt;其中的idx(s)为s的一个自定义索引，，，例如a = 1 , b = 2.....&lt;/p&gt;
&lt;p&gt;这时，，取 p=13,mod=101,把abc映射成一个整数&lt;br/&gt;hash[0]=1，表示 a 映射为1&lt;br/&gt;hash[1]=(hash[0]&lt;em&gt;p+idx(b))%mod=15，表示 ab 映射为 15&lt;br/&gt;hash[2]=(hash[1]&lt;/em&gt;p+idx(c))%mod=97&lt;/p&gt;
&lt;p&gt;所以abc就被映射成97。&lt;/p&gt;
&lt;p&gt;同样对于其他的字符串也可以由此算出一个hash值，，，&lt;/p&gt;
&lt;p&gt;当然这里的p , MOD要选取合适，，，否则可能会出现不同字符串有相同的hash值，，，&lt;/p&gt;
&lt;p&gt;一般来说，，，p和mod一般取素数，p取一个较大的素数即可（6位到8位），mod取一个大素数，比如1e9+7，或者1e9+9....&lt;/p&gt;
&lt;p&gt;一般的模板，，，&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;const unsigned long long p = 1e9 + 13;
const unsigned long long mod = 1e9 + 7;
unsigned long long hashStr(char *s){
    unsigned long long h=0;
    for(int i=0;i&amp;lt;len;i++){
        unsigned long long value;
        char c=s[i];
        if(c&amp;gt;='0'&amp;amp;&amp;amp;c&amp;lt;='9')  value=c-'0';
        else if(c&amp;gt;='a'&amp;amp;&amp;amp;c&amp;lt;='z') value=c-'a'+10;
        else    value=c-'A'+36;
        h=(h*p+value)%mod;
    }
    return h;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;如何求一个字符串任意子串的hash值&quot;&gt;如何求一个字符串任意子串的hash值&lt;/h3&gt;
&lt;p&gt;最容易想到的方法就是不管原来的字符串，，，&lt;br/&gt;单独对于子串从 l 到 r 直接用刚刚求hash的方法求就行了，，，&lt;br/&gt;但是当数据量大时，，，时间复杂度就很高了，，，，&lt;/p&gt;
&lt;p&gt;上面的那个公式中hash[i]求得时字符串第i个前缀的hash值，，，，相当于是一个hash的前缀和，，，，&lt;/p&gt;
&lt;p&gt;要求的子串 &lt;span class=&quot;math inline&quot;&gt;\(hash[l..r] == (hash[r] - hash[l - 1] * p^{r - l + 1}) \% MOD\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;**对了，，，这样直接求可能有负数，，，要判断+=mod一下。。。。。。&lt;/p&gt;
&lt;h3 id=&quot;几个常用的求字符串hash算法&quot;&gt;几个常用的求字符串hash算法&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/jiu0821/p/4554352.html&quot;&gt;有些借鉴，，，&lt;/a&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(hash[i] = (hash[i - 1] * p + idx(s[i])) \% MOD\)&lt;/span&gt;&lt;br/&gt;常用，，，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;unsigned long long hash[N];hash[i] = hash[i - 1] * p;这个自动取模，，，当数超过 &lt;span class=&quot;math inline&quot;&gt;\(2^{64}-1\)&lt;/span&gt;时就会溢出，，，相当于取模 &lt;span class=&quot;math inline&quot;&gt;\(2^{64}\)&lt;/span&gt;的过程，，，&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;双hash，，，有些情况下一个hash可能会出现冲突，，，那就换两个，，，两个不行就换三个，，，，什么？！三个还不行？？？！！！那就四个或则换算法，，，逃，，，实现：取两个mod，，一般取1e9+7和1e9+9两个孪生素数，，，冲突概率已经很低了，，，，，&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;字典树&quot;&gt;字典树&lt;/h2&gt;
&lt;p&gt;简单来说就是把n个字符串用树保存，，，这样查询的时候一层一层的找，，，，&lt;/p&gt;
&lt;h3 id=&quot;构建节点&quot;&gt;构建节点&lt;/h3&gt;
&lt;p&gt;一般的字典树的结构体定义如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;const int maxn = 26;
struct Trie   
{   
    Trie *next[maxn];   
    int v;   //根据需要变化
};   
 
Trie *root;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;插入&quot;&gt;插入&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void Insert(char *str)
{
    int len = strlen(str);
    trie *p = root;
    //insert
    for (int i = 0; i &amp;lt; len; i++)
    {
        int t = str[i] - 'a';
        //NULL
        if (p-&amp;gt;next[t] == NULL)
        {
            p-&amp;gt;next[t] = new trie();
            p = p-&amp;gt;next[t];
        }
        else
        {
            p = p-&amp;gt;next[t];
            p-&amp;gt;sum ++;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查询&quot;&gt;查询&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int query(char *str)
{
    int len = strlen(str);
    trie *p = root;
    for (int i = 0; i &amp;lt; len; i++)
    {
        int t = str[i] - 'a';
        p = p-&amp;gt;next[t];
        //NULL
        if (p == NULL)  return 0;
    }
    return p-&amp;gt;sum;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;释放内存&quot;&gt;释放内存&lt;/h3&gt;
&lt;p&gt;不然可能有的题mle,,,,,&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void free(trie *t)
{
    if (t == NULL)
        return;
    for(int i = 0; i &amp;lt; maxn; i++)
        if (t-&amp;gt;next[i]) free(t-&amp;gt;next[i]);
    delete (t);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然是模板化的东西但是也要不死套模板，，，，，QAQ&lt;/p&gt;
&lt;h2 id=&quot;习题&quot;&gt;习题&lt;/h2&gt;
&lt;p&gt;前三道都是模板题，，上午讲过，，，最后一题是01字典树问题，，，以后要再看一下，，，看到不同的好几种实现方法，，，没有来的及总结一下，，，，&lt;/p&gt;
&lt;h3 id=&quot;problem-a-a&quot;&gt;Problem A: A&lt;/h3&gt;
&lt;p&gt;Time Limit: 1 Sec Memory Limit: 128 MB&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;给定N个字符串（第i个字符串长度为Mi，字符串内包含数字、大小写字母，大小写敏感），请求出N个字符串中共有多少个不同的字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Input&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;输入，第一行一个N&lt;br/&gt;接下来N行每行包含一个字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Output&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;输出不同字符串的个数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Sample Input&lt;br/&gt;5&lt;br/&gt;abc&lt;br/&gt;aaaa&lt;br/&gt;abc&lt;br/&gt;abcc&lt;br/&gt;12345&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Sample Output&lt;br/&gt;4&lt;br/&gt;我的代码：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//#include &amp;lt;iostream&amp;gt;
#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef unsigned long long ull;
const ull p = 1e9 + 13;
const ull mod = 1e9 + 7;
const int maxn = 1e6;
ull a[maxn];
ull hashstr(char *s)
{
    ull h = 0;
    for (int i = 0; i &amp;lt; strlen(s); i++)
    {
        ull idx;
        if (s[i] &amp;gt;= '0' &amp;amp;&amp;amp; s[i] &amp;lt;= '9')         idx = s[i] - '0';
        else if (s[i] &amp;gt;= 'a' &amp;amp;&amp;amp; s[i] &amp;lt;= 'z')    idx = s[i] - 'a' + 10;
        else if (s[i] &amp;gt;= 'A' &amp;amp;&amp;amp; s[i] &amp;lt;= 'Z')    idx = s[i] - 'A' + 36;
        h = (h * p + idx) % mod;
    }
    return h;
}
int main()
{
    int n;scanf(&quot;%d&quot; , &amp;amp;n);
    char t[maxn];
    for (int i = 1; i &amp;lt;= n; i++)
    {
        //gets(t);
        scanf(&quot;%s&quot; , &amp;amp;t);
        a[i] = hashstr(t);
    }

    sort(a + 1 , a + 1 + n);

    int ans = 0;
    int cur = -1;
    for (int i = 1; i &amp;lt;= n; i++)
        if (a[i] != cur)
        {
            cur = a[i];
            ans++;
        }
    cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;学长的，，，&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef unsigned long long ull;
ull base=131;
ull a[10010];
char s[1010];
ull Hash(char *s)
{
    int len=strlen(s);
    ull ans=0;
    for(int i=0;i&amp;lt;len;i++)
        ans=ans*base+(ull)s[i];
    return ans;
}
int main()
{
    /*srand(NULL);
    freopen(&quot;data.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;data.out&quot;,&quot;w&quot;,stdout);*/
    /*printf(&quot;1000\n&quot;);
    for(int i=1;i&amp;lt;=1000;i++)
    {
        int len=rand()%1000+1;
        for(int i=0;i&amp;lt;len;i++)
        {
            int t=rand()%3;
            if(t==0)
                s[i]='0'+rand()%10;
            else if(t==1)
                s[i]='A'+rand()%26;
            else
                s[i]='a'+rand()%26;
        }
        s[len]='\0';
        cout&amp;lt;&amp;lt;s&amp;lt;&amp;lt;endl;
    }*/
    int N,i=1,ans=1;
    scanf(&quot;%d&quot;,&amp;amp;N);
    for(int i=1;i&amp;lt;=N;i++)
    {
        scanf(&quot;%s&quot;,&amp;amp;s);
        a[i]=Hash(s);
    }
    sort(a+1,a+1+N);
    for(int i=2;i&amp;lt;=N;i++)
    {
        if(a[i]!=a[i-1])
            ans++;
    }
    printf(&quot;%d\n&quot;,ans);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;problem-b-b&quot;&gt;Problem B: B&lt;/h3&gt;
&lt;p&gt;Time Limit: 1 Sec Memory Limit: 128 MB&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HHM在阅读一篇文章，他想找出来一个单词的频率，也就是这个单词在文章中出现了几次。聪明的你赶快帮帮他&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Input&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;输入包含多组数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;输入文件的第一行有一个整数，代表数据组数。接下来是这些数据，以如下格式给出：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;第一行是单词W，一个由{'A','B','C',...,'Z'}中字母组成的字符串，保证1&amp;lt;=|W|&amp;lt;=10000（|W|代表字符串W的长度）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;第二行是文章T，一个由{'A','B','C',...,'Z'}中字母组成的字符串，保证|W|&amp;lt;=|T|&amp;lt;=1000000。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Output&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对每组数据输出一行一个整数，即W在T中出现的次数。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Sample Input&lt;br/&gt;3&lt;br/&gt;BAPC&lt;br/&gt;BAPC&lt;br/&gt;AZA&lt;br/&gt;AZAZAZA&lt;br/&gt;VERDI&lt;br/&gt;AVERDXIVYERDIAN&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Sample Output&lt;br/&gt;1&lt;br/&gt;3&lt;br/&gt;0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;HINT&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;字符串哈希思路&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//#include &amp;lt;iostream&amp;gt;
#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef unsigned long long ull;
const ull p = 1e9 + 13;
const ull MOD = 1e9 + 7;
const int maxn = 1e4 + 5;
const int maxm = 1e4 + 6;
ull pow1 (ull x , ull n)
{
    ull res = x;
    ull ans = 1;
    while (n)
    {
        if (n &amp;amp; 1)  ans = ans * res % MOD;
         res = res * res % MOD;
         n &amp;gt;&amp;gt;= 1;                           //b右移相当于除以二
    }
    return ans;
}
int main()
{
    int n;scanf(&quot;%d&quot; , &amp;amp;n);
    while (n--)
    {
        char word[maxn];
        scanf(&quot;%s&quot; , word);
        //gets(word);
        char text[maxm];
        scanf(&quot;%s&quot; , text);
        //gets(text);

        ull hash_word = 0;
        for (int i = 0; i &amp;lt; strlen(word); i++)
        {
            ull idx = word[i] - 'A' + 1;
            hash_word = (hash_word * p + idx) % MOD;
        }
        ull hash_t[maxm];
        memset(hash_t , 0 , sizeof hash_t);
        for (int i = 1; i &amp;lt;= strlen(text); i++)
        {
            ull idx = text[i - 1] - 'A' + 1;
            hash_t[i] = (hash_t[i - 1] * p + idx) % MOD;
        }

        ull ans = 0;
        ull len = strlen(word);
        for (ull i = len; i &amp;lt;= strlen(text); i++)
        {
            ull t = hash_t[i] - hash_t[i - len] * pow1(p , len);//cout &amp;lt;&amp;lt; t &amp;lt;&amp;lt; endl;
            if (t &amp;lt; 0)  t = (t + MOD) % MOD;
            else        t %= MOD;
            if (t == hash_word)
                ans++;
        }
        cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;学长的代码:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef unsigned long long ull;
ull base=131;
ull p[100010],a2[1000010];
char s1[10010],s2[1000010];
ull get(int l,int r)
{
    return (ull)a2[r]-p[r-l+1]*a2[l-1];
}
int main()
{
    srand(NULL);
    freopen(&quot;data.in&quot;,&quot;w&quot;,stdout);
    //freopen(&quot;data.out&quot;,&quot;w&quot;,stdout);
    printf(&quot;97\n&quot;);
    for(int i=1;i&amp;lt;=97;i++)
    {
        int p1=rand()%10000+1;
        int p2=rand()%10000+1;
        if(p1&amp;gt;p2)
            swap(p1,p2);
        for(int j=0;j&amp;lt;p1;j++)
            s1[j]='A'+rand()%26;
        s1[p1]='\0';
        for(int j=0;j&amp;lt;p2;j++)
            s2[j]='A'+rand()%26;
        s2[p2]='\0';
        cout&amp;lt;&amp;lt;s1&amp;lt;&amp;lt;endl;
        cout&amp;lt;&amp;lt;s2&amp;lt;&amp;lt;endl;
    }
    /*p[0]=1;
    for(int i=1;i&amp;lt;=10000;i++)
        p[i]=p[i-1]*base;
    int T;
    scanf(&quot;%d&quot;,&amp;amp;T);
    while(T--)
    {
        scanf(&quot;%s%s&quot;,&amp;amp;s1,&amp;amp;s2);
        int len1=strlen(s1),len2=strlen(s2);
        ull a1=0;
        int ans=0;
        for(int i=0;i&amp;lt;len1;i++)
            a1=a1*base+(ull)s1[i];
        a2[0]=(ull)s2[0];
        for(int i=1;i&amp;lt;len2;i++)
            a2[i]=a2[i-1]*base+(ull)s2[i];

        for(int i=0;i+len1-1&amp;lt;len2;i++)
            if(a1==get(i,i+len1-1))
                ans++;
        printf(&quot;%d\n&quot;,ans);
    }*/
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;problem-c-c&quot;&gt;Problem C: C&lt;/h3&gt;
&lt;p&gt;Time Limit: 1 Sec Memory Limit: 128 MB&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;HMM最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Input&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;输入数据的第一部分是一张单词表,每行一个单词,单词的长度不超过10,它们代表的是老师交给HMM统计的单词,一个#代表单词表的结束.第二部分是一连串的提问,每行一个提问,每个提问都是一个字符串.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Output&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;对于每个提问,给出以该字符串为前缀的单词的数量.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Sample Input&lt;br/&gt;banana&lt;br/&gt;band&lt;br/&gt;bee&lt;br/&gt;absolute&lt;br/&gt;acm&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ba&lt;br/&gt;b&lt;br/&gt;band&lt;br/&gt;abc&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Sample Output&lt;br/&gt;2&lt;br/&gt;3&lt;br/&gt;1&lt;br/&gt;0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
//#include &amp;lt;bits/stdc++.h&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#define ms(a , b) memset(a , b , sizeof(a))
using namespace std;
const int maxn = 27;
struct trie
{
    trie *next[maxn];
    int sum;
    trie()
    {
        sum = 1;
        ms(next , NULL);
    }
}*root;
void Insert(char *str)
{
    int len = strlen(str);
    trie *p = root;
    //insert
    for (int i = 0; i &amp;lt; len; i++)
    {
        int t = str[i] - 'a';
        //NULL
        if (p-&amp;gt;next[t] == NULL)
        {
            p-&amp;gt;next[t] = new trie();
            p = p-&amp;gt;next[t];
        }
        else
        {
            p = p-&amp;gt;next[t];
            p-&amp;gt;sum ++;
        }
    }
}
int query(char *str)
{
    int len = strlen(str);
    trie *p = root;
    for (int i = 0; i &amp;lt; len; i++)
    {
        int t = str[i] - 'a';
        p = p-&amp;gt;next[t];
        //NULL
        if (p == NULL)  return 0;
    }
    return p-&amp;gt;sum;
}
void free(trie *t)
{
    if (t == NULL)
        return;
    for(int i = 0; i &amp;lt; maxn; i++)
        if (t-&amp;gt;next[i]) free(t-&amp;gt;next[i]);
    delete (t);
}
int main()
{
    char str[maxn];
    root = new trie;
    while(gets(str) &amp;amp;&amp;amp; str[0] != '#')
    {
        Insert(str);
    }
    while(~scanf(&quot;%s&quot; , str))
    {
        printf(&quot;%d\n&quot; , query(str));
    }
    free(root);
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;学长的代码:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;malloc.h&amp;gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
char s[15];
typedef struct Trie{
    int v;
    Trie *next[26];
}Trie;

Trie root;

void Creat(char *str)
{
    int len=strlen(str);
    Trie *p=&amp;amp;root,*q;
    for(int i=0;i&amp;lt;len;i++)
    {
        int id=str[i]-'a';
        if(p-&amp;gt;next[id]==NULL)
        {
            q=(Trie *)malloc(sizeof(root));
            q-&amp;gt;v=1;
            for(int j=0;j&amp;lt;26;j++)
                q-&amp;gt;next[j]=NULL;
            p-&amp;gt;next[id]=q;
            p=p-&amp;gt;next[id];
        }
        else
        {
            p-&amp;gt;next[id]-&amp;gt;v++;
            p=p-&amp;gt;next[id];
        }
    }
}
int Find(char *str)
{
    int len=strlen(str);
    Trie *p=&amp;amp;root;
    for(int i=0;i&amp;lt;len;i++)
    {
        int id=str[i]-'a';
        p=p-&amp;gt;next[id];
        if(p==NULL)
            return 0;
    }
    return p-&amp;gt;v;
}
int main()
{
    /*srand(NULL);
    freopen(&quot;data.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;data.out&quot;,&quot;w&quot;,stdout);
    */
    /*for(int i=1;i&amp;lt;=1000;i++)
    {
        int p=rand()%10+1;
        for(int j=0;j&amp;lt;p;j++)
            s[j]='a'+rand()%26;
        cout&amp;lt;&amp;lt;s&amp;lt;&amp;lt;endl;
    }*/
    char str[15];
    for(int i=0;i&amp;lt;26;i++)
        root.next[i]=NULL;
    while(scanf(&quot;%s&quot;,&amp;amp;str)&amp;amp;&amp;amp;str[0]!='#')
        Creat(str);
    while(scanf(&quot;%s&quot;,&amp;amp;str)!=EOF)
    {
        printf(&quot;%d\n&quot;,Find(str));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;problem-d-d&quot;&gt;Problem D: D&lt;/h3&gt;
&lt;p&gt;Time Limit: 1 Sec Memory Limit: 128 MB&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;HHM和SY做游戏，SY给HHM一个集合，集合包含了N个整数，随后SY向HHM发起M次询问，每次询问包含一个整数S，之后HHM需要在集合中&lt;br/&gt;找到一个正整数K，使得K与S的异或结果最大。HHM向你请求帮助&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Input&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;输入包含若干组测试数据，每组测试数据包含若干行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;输入的第一行是一个整数T（T &amp;lt; 10），表示共有T组数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;每组数据的第一行输入两个正整数N，M（&amp;lt;1=N,M&amp;lt;=100000），接下来一行，包含N个正整数，代表 Zeus 的获得的集合，之后M行，每行一个正整数S，代表 Prometheus 询问的正整数。所有正整数均不超过2^32。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Output&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;对于每组数据，首先需要输出单独一行”Case #?:”，其中问号处应填入当前的数据组数，组数从1开始计算。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;对于每个询问，输出一个正整数K，使得K与S异或值最大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Sample Input&lt;br/&gt;2&lt;br/&gt;3 2&lt;br/&gt;3 4 5&lt;br/&gt;1&lt;br/&gt;5&lt;br/&gt;4 1&lt;br/&gt;4 6 5 6&lt;br/&gt;3&lt;br/&gt;Sample Output&lt;br/&gt;Case #1:&lt;br/&gt;4&lt;br/&gt;3&lt;br/&gt;Case #2:&lt;br/&gt;4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的代码：&lt;/p&gt;
&lt;p&gt;这个是用 &lt;strong&gt;01字典树&lt;/strong&gt; 解决的，，，当时想到了将每一个数转化为'a' , 'b'顺序的字符串，，然后存到字典数里，，最后查询待输入的s异或后的字符串在树中走到头的位置即为答案，，，突然蒙蔽不会建树了，，，gg....QAQ&lt;/p&gt;
&lt;p&gt;对了，，我看到网上有的人是用数组建的树，，，有点看不懂，，，挖个坑，，，还有一个神奇的函数bitset(),,,,哪天来补票，，，，&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
//#include &amp;lt;bits/stdc++.h&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#define ms(a , b) memset(a , b , sizeof(a))
using namespace std;
const int maxn = 2;
const int maxm = 1e5 +5;
struct trie
{
    trie *next[maxn];
    int num;
    trie()
    {
        num = 0;
        ms(next , NULL);
    }
};
void Insert(trie *root , int a)
{
    trie *p = root;
    //insert
    for (int i = 31; i &amp;gt;= 0; i--)
    {
        int k = (a &amp;gt;&amp;gt; i) &amp;amp; 1;
        if (p-&amp;gt;next[k] == NULL)         //空的代表没存加上
        {
            p-&amp;gt;next[k] = new trie();

        }
        p = p-&amp;gt;next[k];
    }
    p-&amp;gt;num = a;                         //将从根节点到该节点表示的值存起来
}
int query(trie *root , int a)
{
    trie *p = root;
    for (int i = 31; i &amp;gt;= 0; i--)
    {
        int k = (a &amp;gt;&amp;gt; i) &amp;amp; 1;
        if (p-&amp;gt;next[k ^ 1] != NULL)
            p = p-&amp;gt;next[k ^ 1];
        else
            p = p-&amp;gt;next[k];
    }
    return p-&amp;gt;num;
}
void Free(trie *t)
{
    if (t == NULL)
        return;
    for(int i = 0; i &amp;lt; maxn; i++)
        if (t-&amp;gt;next[i]) Free(t-&amp;gt;next[i]);
    delete t;
}
int main()
{
    int t;
    scanf(&quot;%d&quot; , &amp;amp;t);
    int k = 1;
    while(t--)
    {

        int n , m;
        //cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        scanf(&quot;%d%d&quot; , &amp;amp;n , &amp;amp;m);
        int a;
        trie *root = new trie();

        //insert
        for (int i = 1; i &amp;lt;= n; i++)
        {
            scanf(&quot;%d&quot; , &amp;amp;a);
            Insert(root , a);
        }
        printf(&quot;Case #%d:\n&quot; , k++);
        for (int i = 1; i &amp;lt;= m; i++)
        {
            scanf(&quot;%d&quot; , &amp;amp;a);
            printf(&quot;%d\n&quot; , query(root , a));
        }
        Free(root);
    }

    return 0;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;学长的代码:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;malloc.h&amp;gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef struct tree
{
    tree *next[2];
    int v;
    int val;
}tree;
tree root;
void Creat(char *str,int va)
{
    int len=strlen(str);
    tree *p=&amp;amp;root,*q;
    for(int i=0;i&amp;lt;len;i++)
    {
        int id=str[i]-'0';
        if(p-&amp;gt;next[id]==NULL)
        {
            q=(tree*)malloc(sizeof(root));
            for(int j=0;j&amp;lt;2;j++)
                q-&amp;gt;next[j]=NULL;
            p-&amp;gt;next[id]=q;
        }
        p=p-&amp;gt;next[id];
        if(i==len-1)
            p-&amp;gt;val=va;
    }
}
void Find(char *str)
{
    int len=strlen(str);
    tree *p=&amp;amp;root;
    for(int i=0;i&amp;lt;len;i++)
    {
        int id=str[i]-'0';
        if(p-&amp;gt;next[1-id]!=0)
            p=p-&amp;gt;next[1-id];
        else
            p=p-&amp;gt;next[id];
        if(p==NULL)
            return;
        if(i==len-1)
            printf(&quot;%d\n&quot;,p-&amp;gt;val);
    }
}
void init()
{
    for(int i=0;i&amp;lt;2;i++)
    {
        root.next[i]=NULL;
    }
}
int main()
{
    /*srand(NULL);
    freopen(&quot;data.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;data.out&quot;,&quot;w&quot;,stdout);
    */
    /*printf(&quot;5\n&quot;);
    for(int i=1;i&amp;lt;=5;i++)
    {
        int m=rand()%100000+1;
        int n=rand()%100000+1;
        printf(&quot;%d %d\n&quot;,n,m);
        for(int i=1;i&amp;lt;=n;i++)
            printf(&quot;%d &quot;,rand()%100000000+1);
        printf(&quot;\n&quot;);
        for(int i=1;i&amp;lt;=m;i++)
            printf(&quot;%d &quot;,rand()%100000000+1);
        printf(&quot;\n&quot;);

    }*/

    int kase=0;
    int T;
    scanf(&quot;%d&quot;,&amp;amp;T);
    while(T--)
    {
        init();
        int n,m;
        char s[50];
        scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;m);
        for(int i=1;i&amp;lt;=n;i++)
        {
            int a;
            scanf(&quot;%d&quot;,&amp;amp;a);
            int tmp=a;
            s[36]='\0';
            for(int j=35;j&amp;gt;=0;j--)
            {
                if(a)
                {
                    s[j]=a%2+'0';
                    a/=2;
                }
                else
                {
                    s[j]='0';
                }
            }
            Creat(s,tmp);
        }
        printf(&quot;Case #%d:\n&quot;,++kase);
        while(m--)
        {
            int a;
            scanf(&quot;%d&quot;,&amp;amp;a);
            s[36]='\0';
            for(int j=35;j&amp;gt;=0;j--)
            {
                if(a)
                {
                    s[j]=a%2+'0';
                    a/=2;
                }
                else
                {
                    s[j]='0';
                }
            }
            Find(s);
        }

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;溜。。。。。。。。。。。。&lt;/p&gt;
&lt;p&gt;(对了，，，两个博客一起更这个当备份把，，，嘿嘿。。。。。。。&lt;/p&gt;
</description>
<pubDate>Wed, 01 Aug 2018 15:19:00 +0000</pubDate>
<dc:creator>31415926535x</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/31415926535x/p/9404591.html</dc:identifier>
</item>
<item>
<title>Django 分页查询并返回jsons数据，中文乱码解决方法 - SharpCJ</title>
<link>http://www.cnblogs.com/joy99/p/9404479.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/joy99/p/9404479.html</guid>
<description>&lt;p&gt;Django 分页查询并返回jsons数据，中文乱码解决方法&lt;/p&gt;

&lt;p&gt;Django 分页查询并返回 json ，需要将返回的 queryset 序列化， demo 如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# coding=UTF-8

import os

from django.core import serializers
from django.core.paginator import Paginator, PageNotAnInteger, EmptyPage
from django.shortcuts import render
from django.http import HttpResponse
from mypage.models import Product


# Create your views here.


def getAllProducts(request):
    products_list = Product.objects.all()
    paginator = Paginator(products_list, 10)  # Show 10 products per page
    page = request.GET.get('page', 0)
    try:
        products = paginator.page(page)
    except PageNotAnInteger:
        # If page is not an integer, deliver first page.
        products = paginator.page(10)
    except EmptyPage:
        # If page is out of range (e.g. 9999), deliver last page of results.
        products = paginator.page(paginator.num_pages)

    json_data = serializers.serialize(&quot;json&quot;, products, ensure_ascii=False)
    return HttpResponse(json_data, content_type='application/json; charset=utf-8')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很容易出现的一个错误是中文乱码,重点在于 &lt;code&gt;json_data = serializers.serialize(&quot;json&quot;, products, ensure_ascii=False)&lt;/code&gt; 中第三个参数。&lt;/p&gt;

&lt;p&gt;官方文档原文：&lt;a href=&quot;https://docs.djangoproject.com/en/2.1/topics/serialization/&quot; class=&quot;uri&quot;&gt;https://docs.djangoproject.com/en/2.1/topics/serialization/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;django的序列化框架提供了一个把django对象转换成其他格式的机制，通常这些其他的格式都是基于文本的并且用于通过一个管道发送django对象，但一个序列器是可能处理任何一个格式的（基于文本或者不是）&lt;/p&gt;
&lt;p&gt;django的序列化类位于django.core下面的serializers文件夹里面，base.py文件里面定义了序列器和反序列器的基类以及一些异常，&lt;strong&gt;init&lt;/strong&gt;.py文件定义了如何根据格式来选择对应的序列器等内容，我们一起来看看吧&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;init&lt;/strong&gt;.py和base.py文件的函数原型如下图&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def serialize(format, queryset, **options):
&quot;&quot;&quot;Serialize a queryset (or any iterator that returns database objects) using
a certain serializer.&quot;&quot;&quot;
s = get_serializer(format)()
s.serialize(queryset, **options)
return s.getvalue()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;class Serializer(object):
   &quot;&quot;&quot;    Abstract serializer base class.    &quot;&quot;&quot;
   # Indicates if the implemented serializer is only available for
   # internal Django use.
   internal_use_only = False
   def serialize(self, queryset, **options):&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那下面我们开始正式讲解django的序列化操作了&lt;/p&gt;
&lt;h2 id=&quot;序列化数据&quot;&gt;序列化数据&lt;/h2&gt;
&lt;p&gt;在最高层的api，序列化数据是非常容易的操作，看上面的函数可知，serialize函数接受一个格式和queryset，返回序列化后的数据：&lt;/p&gt;
&lt;p&gt;简单的写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.core import serializers
data = serializers.serialize(&quot;xml&quot;, SomeModel.objects.all())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复杂的写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;XMLSerializer = serializers.get_serializer(&quot;xml&quot;)
xml_serializer = XMLSerializer()
xml_serializer.serialize(queryset)
data = xml_serializer.getvalue()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;反序列化数据&quot;&gt;反序列化数据&lt;/h2&gt;
&lt;p&gt;一样的简单，接受一个格式和一个数据流，返回一个迭代器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for obj in serializers.deserialize(&quot;xml&quot;, data):
    do_something_with(obj)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而，deserialize返回的的是不是简单的django类型对象，而是DeserializedObject实例，并且这些实例是没有保存的，请使用DeserializedObject.save()方法把这些数据保存到数据库&lt;/p&gt;
&lt;h2 id=&quot;序列化格式&quot;&gt;序列化格式&lt;/h2&gt;
&lt;p&gt;django之处很多的序列化格式，有些需要你安装第三方支持的模块，xml，json和yaml是默认支持的&lt;/p&gt;
&lt;p&gt;注意事项&lt;br/&gt;如果你是使用utf-8或者其他的非ascii编码数据，然后用json序列器，注意穿一个ensure_ascii参数进去，否则输出的编码将会不正常&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;json_serializer = serializers.get_serializer(&quot;json&quot;)()
json_serializer.serialize(queryset, ensure_ascii=False, stream=response)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;序列化参数&quot;&gt;序列化参数&lt;/h2&gt;
&lt;p&gt;序列化的是是可以接受额外的参数的，总共有三个参数，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        self.stream = options.pop(&quot;stream&quot;, StringIO())
        self.selected_fields = options.pop(&quot;fields&quot;, None)
        self.use_natural_keys = options.pop(&quot;use_natural_keys&quot;, False)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;stream&quot;&gt;stream&lt;/h2&gt;
&lt;p&gt;将序列化后的数据输出到该stream流中，接上面的复杂的写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;out = open(&quot;file.xml&quot;, &quot;w&quot;)
xml_serializer.serialize(SomeModel.objects.all(), stream=out)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;selected_field&quot;&gt;selected_field&lt;/h2&gt;
&lt;p&gt;选择序列化的属性，通过制定fields参数，fields是一个元组参数，元素是选择要序列化的属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.core import serializers
data = serializers.serialize('xml', SomeModel.objects.all(), fields=('name','size'))&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;use_natural_keys&quot;&gt;use_natural_keys&lt;/h2&gt;
&lt;p&gt;是否使用自然的关键字，默认是false（即是使用主键）&lt;/p&gt;
&lt;p&gt;默认的外键和多对多关系序列化策略是使用主键，一般情况下是很好地，但有些情况下就不是这样了。比如外键到ContentType的时候，由于ContentType是django的数据库进程同步的时候自动产生的，它们的关键字不是那么容易去预测的。&lt;/p&gt;
&lt;p&gt;一个整数id也不总是最方便的索引到一个对象的方法，所以基于这些情况，django提供了use_natural_keys这个参数，&lt;/p&gt;
&lt;p&gt;一个natural key是一个可以不使用主键就可以用来区分一个元素的属性组合的元组&lt;/p&gt;
&lt;h2 id=&quot;natural-keys的反序列化&quot;&gt;natural keys的反序列化&lt;/h2&gt;
&lt;p&gt;考虑这两个模型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.db import models
class Person(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    birthdate = models.DateField()
    class Meta:
        unique_together = (('first_name', 'last_name'),)
class Book(models.Model):
    name = models.CharField(max_length=100)
    author = models.ForeignKey(Person)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认Book 的序列化数据将会使用一个整数索引到一个作者，例如，用json的是，一个Book的序列化数据大概是这样的，42是外键Author的主键&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;pk&quot;: 1,
    &quot;model&quot;: &quot;store.book&quot;,
    &quot;fields&quot;: {
        &quot;name&quot;: &quot;Mostly Harmless&quot;,
        &quot;author&quot;: 42
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但这不是一个很好的方法，不是吗？你需要知道这个主键代表到底是哪个Author，并且要求这个主键是稳定和可预测的。所以，我们可以增加一个natural key的处理函数，请在对应模型的管理模型里面定义一个get_by_natural_key方法，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.db import models
class PersonManager(models.Manager):
    def get_by_natural_key(self, first_name, last_name):
        return self.get(first_name=first_name, last_name=last_name)
class Person(models.Model):
    objects = PersonManager()
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    birthdate = models.DateField()
    class Meta:
        unique_together = (('first_name', 'last_name'),)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样之后，序列化的结果大概是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;pk&quot;: 1,
    &quot;model&quot;: &quot;store.book&quot;,
    &quot;fields&quot;: {
        &quot;name&quot;: &quot;Mostly Harmless&quot;,
        &quot;author&quot;: [&quot;Douglas&quot;, &quot;Adams&quot;]
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;natural-keys的序列化&quot;&gt;natural keys的序列化&lt;/h2&gt;
&lt;p&gt;如果你想在序列化的时候使用natural key，那你必须在被序列化的模型里面顶一个natural_key方法，并在序列化的时候使用use_natural_keys=True属性如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Person(models.Model):
    objects = PersonManager()
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    birthdate = models.DateField()
    def natural_key(self):
        return (self.first_name, self.last_name)
    class Meta:
        unique_together = (('first_name', 'last_name'),)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;serializers.serialize('json', [book1, book2], use_natural_keys=True)&lt;/code&gt;&lt;br/&gt;注意：natural_key()和get_by_natural_key()不是同时定义的，如果你只想重载natural keys的能力，那么你不必定义natural_key()方法；同样，如果你只想在序列化的时候输出这些natural keys，那么你不必定义get_by_natural_key()方法&lt;/p&gt;
&lt;h2 id=&quot;序列化过程中的依赖关系&quot;&gt;序列化过程中的依赖关系&lt;/h2&gt;
&lt;p&gt;因为natural keys依赖数据库查询来解析引用，所以在数据被引用之前必须确保数据是存在的。看下面的例子，如果一个Book的natural key是书名和作者的组合，你可以这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Book(models.Model):
    name = models.CharField(max_length=100)
    author = models.ForeignKey(Person)

    def natural_key(self):
        return (self.name,) + self.author.natural_key()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么问题来了，如果Author还没有被序列化呢？很明显，Author应该在Book之前被序列化，为此，我们可以添加一个依赖关系如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def natural_key(self):
    return (self.name,) + self.author.natural_key()
natural_key.dependencies = ['example_app.person']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这保证了Person对象是在Book对象之前被序列化的，同样，任何一个引用Book的对象只有在Person和Book对象都被序列化之后才会被序列化&lt;/p&gt;
&lt;h2 id=&quot;继承的模型&quot;&gt;继承的模型&lt;/h2&gt;
&lt;p&gt;如果是使用抽象继承的时候，不必在意这个问题；如果你使用的是多表继承，那么注意了：必须序列化所有的基类，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Place(models.Model):
    name = models.CharField(max_length=50)
class Restaurant(Place):
    serves_hot_dogs = models.BooleanField()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果仅仅序列化Restaurant模型，那么只会得到一个serves_hot_dog属性，基类的属性将被忽略，你必须同时序列化所有的继承的模型，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;all_objects = list(Restaurant.objects.all()) + list(Place.objects.all())
data = serializers.serialize('xml', all_objects)&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 01 Aug 2018 15:01:00 +0000</pubDate>
<dc:creator>SharpCJ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/joy99/p/9404479.html</dc:identifier>
</item>
<item>
<title>Angular中通过$location获取地址栏的参数详解 - 半指温柔乐</title>
<link>http://www.cnblogs.com/le220/p/9404421.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/le220/p/9404421.html</guid>
<description>&lt;h2&gt;Angular&lt;span&gt;中通过&lt;/span&gt;&lt;span&gt;$location&lt;/span&gt;&lt;span&gt;获取&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;中的参数&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　最近，项目开发正在进行时，心有点燥，许多东西没来得及去研究，今天正想问题呢&lt;/span&gt;，同事问到如何获取url中的参数，我一时半会还真没想起来，刚刚特意研究了一下，常用的方法就以下几种：&lt;/p&gt;
&lt;h3&gt;1.&lt;span&gt;获取当前完整的&lt;/span&gt;url&lt;span&gt;路径&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　var absurl = $location.&lt;span&gt;&lt;strong&gt;absUrl&lt;/strong&gt;&lt;/span&gt;();     //&lt;a href=&quot;http://0.0.0.88:8100/&quot;&gt;http://88:8100/&lt;/a&gt;#/homePage?id=10&amp;amp;a=100&lt;/p&gt;
&lt;h3&gt;2. &lt;span&gt;获取当前&lt;/span&gt;url&lt;span&gt;路径&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;当前&lt;/span&gt;&lt;span&gt;url#&lt;/span&gt;&lt;span&gt;后面的内容&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;包括参数和哈希值&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　var url = $location.&lt;span&gt;&lt;strong&gt;url&lt;/strong&gt;&lt;/span&gt;();   // /homePage?id=10&amp;amp;a=100&lt;/p&gt;
&lt;h3&gt;3. &lt;span&gt;获取当前&lt;/span&gt;url&lt;span&gt;的子路径&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;也就是当前&lt;/span&gt;&lt;span&gt;url#&lt;/span&gt;&lt;span&gt;后面的内容&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;不包括参数&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　var pathUrl = $location.&lt;span&gt;&lt;strong&gt;path&lt;/strong&gt;&lt;/span&gt;()   ///homePage&lt;/p&gt;
&lt;h3&gt;4.&lt;span&gt;获取当前&lt;/span&gt;url&lt;span&gt;的协议&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;比如&lt;/span&gt;&lt;span&gt;http,https)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　var protocol = $location.&lt;span&gt;&lt;strong&gt;protocol&lt;/strong&gt;&lt;/span&gt;();   //http&lt;/p&gt;
&lt;h3&gt;5.&lt;span&gt;获取主机名&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　var localhost = $location.&lt;span&gt;&lt;strong&gt;host&lt;/strong&gt;&lt;/span&gt;();   //88&lt;/p&gt;
&lt;h3&gt;6.&lt;span&gt;获取当前&lt;/span&gt;url&lt;span&gt;的端口&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;var port = $location.&lt;span&gt;&lt;strong&gt;port&lt;/strong&gt;&lt;/span&gt;();   //8100&lt;/p&gt;
&lt;h3&gt;7.&lt;span&gt;获取当前&lt;/span&gt;url&lt;span&gt;的哈希值&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　var hash = $location.&lt;span&gt;&lt;strong&gt;hash&lt;/strong&gt;&lt;/span&gt;()   //&lt;a href=&quot;http://088/&quot;&gt;http://088&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;8.&lt;span&gt;获取当前&lt;/span&gt;url&lt;span&gt;的参数的序列化&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;对象&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　var search = $location.&lt;span&gt;&lt;strong&gt;search&lt;/strong&gt;&lt;/span&gt;();    //{id: &quot;10&quot;, a: &quot;100&quot;}&lt;/p&gt;
&lt;h3&gt;9. &lt;span&gt;获取&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;参数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　$location.search().name;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　$location.search()['name'];&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;10.注意问题&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;如果是这样的地址：&lt;/span&gt;&lt;span&gt;http://&lt;/span&gt;lele.sina.com?name=haha &lt;/h3&gt;
&lt;p&gt; 需要在项目中注入&lt;strong&gt;$locationProvider&lt;/strong&gt;服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; searchApp = angular.module('searchApp'&lt;span&gt;, []);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; searchApp.config(['$&lt;span&gt;&lt;strong&gt;locationProvider&lt;/strong&gt;&lt;/span&gt;', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;($&lt;span&gt;&lt;strong&gt;locationProvider&lt;/strong&gt;&lt;/span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; $&lt;span&gt;&lt;strong&gt;locationProvider&lt;/strong&gt;&lt;/span&gt;.html5Mode(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}]);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; searchApp.controller('MainCtrl', ['$scope', '$location', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;($scope, $location) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; ($location.search().keyword) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; $scope.keyword =&lt;span&gt; $location.search().keyword;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; }]); 
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;11.js中获取地址栏参数的方法(附加)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　url = https://www.baidu.com/s?ie=utf-8&amp;amp;f=3&amp;amp;rsv_bp=1&amp;amp;rsv_idx=2&amp;amp;tn=baiduhome_pg&amp;amp;wd=%E5%A8%83%E5%93%88%E5%93%88&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　console.log(window.location.&lt;strong&gt;href&lt;/strong&gt; );   // &quot;https://www.baidu.com/s?ie=utf-8&amp;amp;f=3&amp;amp;rsv_bp=1&amp;amp;rsv_idx=2&amp;amp;tn=baiduhome_pg&amp;amp;wd=%E5%A8%83%E5%93%88%E5%93%88&quot;&lt;/p&gt;
&lt;p&gt;　　console.log(window.location.&lt;strong&gt;host&lt;/strong&gt;);   // &quot;www.baidu.com&quot;&lt;/p&gt;
&lt;p&gt;　　console.log(window.location.&lt;strong&gt;pathname&lt;/strong&gt;);  // &quot;/s&quot;&lt;/p&gt;
&lt;p&gt;　　console.log(window.location.&lt;strong&gt;protocol&lt;/strong&gt;);  //  &quot;https:&quot;&lt;/p&gt;
&lt;p&gt;　　console.log(window.location.&lt;strong&gt;search&lt;/strong&gt;);  //  &quot;?ie=utf-8&amp;amp;f=3&amp;amp;rsv_bp=1&amp;amp;rsv_idx=2&amp;amp;tn=baiduhome_pg&amp;amp;wd=%E5%A8%83%E5%93%88%E5%93%88&quot;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Aug 2018 14:41:00 +0000</pubDate>
<dc:creator>半指温柔乐</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/le220/p/9404421.html</dc:identifier>
</item>
<item>
<title>JS事件程序处理 - -柒孟-</title>
<link>http://www.cnblogs.com/mengjingmei/p/9404155.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengjingmei/p/9404155.html</guid>
<description>&lt;h2 id=&quot;一基本概念&quot;&gt;一、基本概念&lt;/h2&gt;
&lt;p&gt;1、事件：用户/浏览器自身执行的某种动作（点击click、加载load,页面滚动scroll的等）；&lt;br/&gt;2、事件处理程序：响应某个事件的处理函数，又叫事件侦听器&lt;/p&gt;
&lt;h2 id=&quot;二事件流&quot;&gt;二、事件流&lt;/h2&gt;
&lt;h4 id=&quot;事件流&quot;&gt;事件流&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;1、事件冒泡
    由IE提出
    由下向上
2、事件捕获
    由Netscape团队提出
    由上向下
    由于老版本浏览器不支持，所以很少使用
3、DOM事件流
    DOM2级事件
    分为三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段 
    IE8及更早版本不支持，目前最常用的事件流
    &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三绑定事件处理函数的方式&quot;&gt;三、绑定事件处理函数的方式&lt;/h2&gt;
&lt;h3 id=&quot;event事件对象-this指向事件目标&quot;&gt;event：事件对象 this：指向事件目标&lt;/h3&gt;
&lt;h3 id=&quot;一html上绑定&quot;&gt;（一）、html上绑定&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;li onclick=&quot;alert(this)&quot;&amp;gt;1行&amp;lt;/li&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二js中绑定&quot;&gt;（二）、js中绑定&lt;/h3&gt;
&lt;p&gt;三种方式&lt;/p&gt;
&lt;h4 id=&quot;方式一-dom0级方法&quot;&gt;方式一 DOM0级方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;var ele = document.getElementsByTagName('li')[0];
// 绑定
ele.onclick = function (event) {
    console.log(event);
};
// 同时给一个元素相同事件绑定两个事件处理函数时，后面的代码会覆盖前面的
ele.onclick = function (event) {
    console.log(this);
};
// 解绑
ele.onclick = null;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式不能同时绑定多个事件&lt;/p&gt;
&lt;h4 id=&quot;方式二-dom2级方法&quot;&gt;方式二 DOM2级方法&lt;/h4&gt;
&lt;p&gt;addEventListener与removeEventListener&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function handler1(event) {
        console.log(this);
}
function handler2(event) {
    console.log(event);
}
// 三个参数          1.一个/多个事件 2.事件处理函数 3.响应阶段(捕获阶段:true, 冒泡阶段:false 一般使用false)
ele.addEventListener('click', handler1, false);
// 同时为同一个元素的同一个事件绑定多个处理函数时，不会覆盖，会按照绑定顺序执行
ele.addEventListener('click', handler2, false);
// 解绑 三个参数必须和绑定时保持一致才可以解绑
ele.removeEventListener('click', handler1, false);&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;注1解绑函数的参数必须和绑定时的参数保持一致才能解绑-2所以最好不要使用匿名函数不然解绑不了-3同时为同一个元素的同一个事件绑定多个处理函数时不会覆盖会按照绑定顺序执行&quot;&gt;注：1、解绑函数的参数必须和绑定时的参数保持一致才能解绑； 2、所以最好不要使用匿名函数，不然解绑不了； 3、同时为同一个元素的同一个事件绑定多个处理函数时，不会覆盖，会按照绑定顺序执行。&lt;/h5&gt;
&lt;h4 id=&quot;方式三-ie-ie8以前只支持这种冒泡方式&quot;&gt;方式三 IE （ie8以前只支持这种冒泡方式）&lt;/h4&gt;
&lt;p&gt;attachEvent与detachEvent&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 绑定 两个参数 1.on'事件' 2.事件处理函数
ele.attachEvent('onclick', handler1);
ele.attachEvent('onclick', handler2);
// 解绑
ele.detachEvent('onclick', handler1);&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;注1解绑函数的参数必须和绑定时的参数保持一致才能解绑-2所以最好不要使用匿名函数不然解绑不了-3同时为同一个元素的同一个事件绑定多个处理函数时不会覆盖会按照绑定顺序-相反的顺序-执行4this不指定事件目标而是指向windowevent对象和前两种的event构成也不一样&quot;&gt;注：1、解绑函数的参数必须和绑定时的参数保持一致才能解绑； 2、所以最好不要使用匿名函数，不然解绑不了； 3、同时为同一个元素的同一个事件绑定多个处理函数时，不会覆盖，会按照绑定顺序 相反的顺序 执行。4、this不指定事件目标而是指向window，event对象和前两种的event构成也不一样&lt;/h5&gt;
&lt;h3 id=&quot;四兼容ie8及以下浏览器事件绑定程序&quot;&gt;四、兼容IE8及以下浏览器事件绑定程序&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;var handler = function(event) {
    console.log('事件类型：'+event.type+'事件阶段：'+event.eventPhase);
}


// 封装兼容事件绑定程序
var EventUtil = {
    // 绑定事件处理函数
    addHandler: function (element, type, handler) {
        if(element.addEventListener) {
            element.addEventListener(type, handler, false);
        } else if(element.attachEvent) {
            element.attachEvent('on'+type, handler);
        } else {
            element['on'+type] = handler;
        }
    },
    // 解绑处理
    removeHandler: function (element, type, handler) {
        if(element.removeEventListener) {
            element.removeEventListener(type, handler, false);
        } else if(element.detachEvent) {
            element.detachEvent('on'+type, handler);
        } else {
            element['on'+type] = null;
        }
    },
    // 获取事件对象
    getEvent: function (event) {
        return event ? event : window.event;
    },
    // 获取事件目标元素
    getTarget: function (event) {
        return event.target || event.srcElement;
    },
    // 阻止特定事件的默认行为
    preventDefault: function (event) {
        if(event.preventDefault) {
            event.preventDefault();
        } else {
            event.returnValue = false;
        }
    },
    // 阻止冒泡
    stopPropagation: function (event) {
        if(event.stopPropagation) {
            event.stopPropagation();
        } else {
            event.cancleBubble = true;
        }
    }
};


// 调用
EventUtil.addHandler(ele, 'click', handler);
EventUtil.removeHandler(ele, 'click', handler);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;五event事件对象&quot;&gt;五、event事件对象&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;事件处理函数正在处理的元素&lt;/td&gt;
&lt;td&gt;event.currentTarget&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;事件发生在的具体元素&lt;/td&gt;
&lt;td&gt;event.target&lt;/td&gt;
&lt;td&gt;event.srcElement&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;阻止特定事件的默认行为&lt;/td&gt;
&lt;td&gt;event.preventDefault()&lt;/td&gt;
&lt;td&gt;event.returnValue = false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;阻止事件冒泡&lt;/td&gt;
&lt;td&gt;event.stopPropagation()&lt;/td&gt;
&lt;td&gt;event.cancleBubble = true&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;event.eventPhase 判断事件处理函数执行时，元素处于的阶段&lt;br/&gt;1：在捕获阶段&lt;br/&gt;2：在目标对象上&lt;br/&gt;3：冒泡阶段&lt;/p&gt;
&lt;p&gt;event.eventPhase = 2 时，this=event.currentTarget = event.target&lt;/p&gt;
&lt;h3 id=&quot;六事件委托&quot;&gt;六、事件委托&lt;/h3&gt;
&lt;h4 id=&quot;解决问题如果页面上所有需要绑定事件的元素都单个绑定相应的事件处理程序1那么将会绑定很多单独的程序全局内存占用很多影响页面性能2访问dom次数太多延迟页面交互就绪时间&quot;&gt;解决问题：如果页面上所有需要绑定事件的元素都单个绑定相应的事件处理程序，1、那么将会绑定很多单独的程序，全局内存占用很多，影响页面性能，2、访问DOM次数太多，延迟页面交互就绪时间&lt;/h4&gt;
&lt;h4 id=&quot;原理利用事件冒泡为顶级页面元素或者模块中最头部元素指定事件处理函数&quot;&gt;原理：利用事件冒泡，为顶级页面元素或者模块中最头部元素指定事件处理函数&lt;/h4&gt;
&lt;p&gt;html:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div id=&quot;box&quot;&amp;gt;
    &amp;lt;ul id=&quot;list&quot;&amp;gt;
        &amp;lt;li id=&quot;one&quot;&amp;gt;1行&amp;lt;/li&amp;gt;
        &amp;lt;li id=&quot;two&quot;&amp;gt;2行&amp;lt;/li&amp;gt;
        &amp;lt;li id=&quot;three&quot;&amp;gt;3行&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;js:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var ele = document.getElementById('box');
EventUtil.addHandler(ele, 'click', function (event) {
    var event = EventUtil.getEvent(event);
    // 获取发生事件的目标元素
    var target = EventUtil.getTarget(event);
    // 获取事件目标元素的id选择器名
    var id = target.id;
    // 根据不同的元素做不同的处理
    switch(id) {
        case 'box':
        {
            handler(event);
        }
            break;
        case 'list':
        {
            console.log(target);
        }
            break;
        case 'one':
        {
            target.style.color = 'red';
        }
            break;
        case 'two':
        {
            target.style.color = 'blue';
        }
            break;
        case 'three':
        {
            target.style.color = 'green';
        }
            break;
        default: break;
    }
});&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 01 Aug 2018 13:55:00 +0000</pubDate>
<dc:creator>-柒孟-</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mengjingmei/p/9404155.html</dc:identifier>
</item>
<item>
<title>奇怪的骰子游戏 - 李秋豪</title>
<link>http://www.cnblogs.com/liqiuhao/p/9403860.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiuhao/p/9403860.html</guid>
<description>&lt;p&gt;&lt;span&gt;近日复习概率论（&lt;a href=&quot;https://courses.csail.mit.edu/6.042/spring17/mcs.pdf&quot;&gt;mathematics for computer science&lt;/a&gt;）的时候读到了一个有趣的例子，在这里分享一下。都是一些非常简单好玩的概率知识，学数学的同学请绕道...勿喷。 ;)&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;这是一个平淡的星期天，你像往常一样在酒吧喝酒，顺便思考一下MMU分页机制的原理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;过了一会儿，一个彪形大汉坐到了你的旁边，点了几杯伏特加开始狂饮。正当你想到内核如何通过虚拟地址更改页目录和页表的时候，他开口了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“小兄弟，玩骰子嘛？”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“不好意思，我不赌博。”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“嘿，我这可不是赌博，而且规则简单的很，要不要听听？”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你觉着反正也是闲着，就看看他葫芦里卖着什么药，于是说到：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“行，你说说是怎么个玩法？”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;壮汉便从口袋里攥出三枚骰子，扔在桌子上：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201808/1072319-20180801204834647-1877546493.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“我这有三枚骰子，每一个都有6面，和普通骰子不一样的地方在于，每个相对面的点数是一样的，也就是说每个骰子只有三种点数，例如A骰子投出2、6、7的概率都是1/3. 咱们两每人下注100块，选一个骰子扔一下，谁点数小就输给对方，如何？”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发现骰子有些奇怪，你陷入了思索，B骰子有一个最大的点数9，而A骰子似乎有6和7这两个都不小的点数...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;壮汉看出了你的怀疑，又说“小兄弟，这样，你先选骰子，我后选，这样如何？”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;听起来不错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;”那我选B骰子“。随后壮汉拿起了A骰子。接下来就让我们分析一下你输掉的概率。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;a-vs-b&quot;&gt;&lt;span&gt;A vs B&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;首先我们找出所有的样本空间：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201808/1072319-20180801204842590-421825476.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后我们找到壮汉能够获胜的样本，一共有5个：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201808/1072319-20180801204848275-998150572.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于骰子上每一个点数出现的概率都是1/3，而且两个骰子是互相独立的，所以每一个样本出现的概率都是1/9. 如下图所示，你输掉的概率是5/9 :(&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201808/1072319-20180801204853790-1163657566.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在你输掉100元后，壮汉将其归咎于你的坏运气，并劝你再来一盘。不过你现在只剩下打车的25块了，为了“帮助”你回本，壮汉提出，接下来这一盘你不用下注，如果你赢了就把刚刚赢的100块还给你，但要是输掉的话就欠他100块。考虑到刚刚已经吃了一个教训，这次应该能赢，你答应了他。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这次你选择A骰子，壮汉随后选择了C骰子。我们再来分析一下你输掉的概率。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;c-vs-a&quot;&gt;&lt;span&gt;C vs A&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;和上一盘一样，我们很容易就算出——你还是有5/9的概率输掉 :(&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201808/1072319-20180801204900425-656681015.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;现在，你欠壮汉100块了，当你正考虑待会儿怎么跑掉时，壮汉”慈爱“答应再给你一次免下注的机会。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;emmmm... A可以赢B，C可以赢A，那选C肯定没错了。于是你继续与壮汉展开斗争，这次，壮汉选择了B。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;b-vs-c&quot;&gt;&lt;span&gt;B vs C&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;和前两盘一样，我们可以很容易计算出结果——你还是5/9的概率输掉，又输了！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这怎么可能！A扔出的点数会比B更大，而C扔出的点数会比A更大，那C扔出的点数会什么会比B小呢？？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就是直觉带来的错误，在生活中很多东西满足传递性，很可惜，这里的概率不是。&lt;strong&gt;也就是说，只要你先选骰子，壮汉总是更可能赢！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是，这一天你穿着内裤走回了家。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;又是一个平淡的星期天，你穿着新买的衣服在酒吧休息，心想着下次再碰见壮汉一定要后扔骰子，把输掉的钱赢回来。果然，没过多久，壮汉出现了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他听了你的要求，竟然欣然同意，但是建议这次玩大的——选完骰子后，每个人扔两次，把两次的点数之和作为输赢依据，每次下注200元。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;emmmm... 扔两次，你想既然每一次扔骰子都更可能比壮汉大，扔两次更应该是这样了，于是便同意了。壮汉选择了B骰子，你知道A骰子比B骰子更可能扔出高点数，于是便选择的A骰子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;真的是这样吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Wrong！&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;rolling-twice&quot;&gt;&lt;span&gt;Rolling Twice&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;和前面的算法相同，由于每个人要扔两次骰子，总的样本数就是(3*3)*(3*3) = 91种，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201808/1072319-20180801204915571-1021542433.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到，扔两次A骰子可能的样本为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201808/1072319-20180801204920575-2136363822.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而扔两次B骰子可能的样本为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201808/1072319-20180801204925774-2096466603.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以A战胜B的总样本数为1+3+3+3+3+6+6+6+6 = 37个，而B战胜A的总样本数为42个（剩下的为平局）。即扔两次B更有可能获胜，和扔一次的情况矛盾！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看来，直觉又一次欺骗了我们，每一次扔出的点数都更可能高，但是两次扔的和却更可能低。事实上，在我们扔一个骰子比大小的时候，获胜的概率排序为 A &amp;gt; B &amp;gt; C &amp;gt; A, 而扔两个骰子的时候概率是反过来的，即A &amp;lt; B &amp;lt; C &amp;lt; A.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;人们总是说“抢占先机”，但又说“后发优势”。从上面的例子也可以看出，先行动不一定就能占据优势，而后发也不一定就是好事，这正是统计学上的诠释。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;总之，在数据的概率上，不要相信生活经验/直觉，而是应该从数学的角度分析判断。另外，书上在讲条件概率的时候也提到了一个好玩的&lt;a href=&quot;https://baike.baidu.com/item/%E8%BE%9B%E6%99%AE%E6%A3%AE%E6%82%96%E8%AE%BA/4475862?fr=aladdin&quot;&gt;辛普森悖论&lt;/a&gt;, 感兴趣可看看。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Aug 2018 12:59:00 +0000</pubDate>
<dc:creator>李秋豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqiuhao/p/9403860.html</dc:identifier>
</item>
<item>
<title>猫眼电影App抓包获取评论数据接口 - 甘乐</title>
<link>http://www.cnblogs.com/socrates-lzstu/p/9403889.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/socrates-lzstu/p/9403889.html</guid>
<description>&lt;p&gt; 之前在CSDN程序人生公众号上看到了这篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s/J_5jJTV8onbTnTIaZssLxQ&quot;&gt;《邪不压正》评分持续走低，上万条网友评论揭秘，是救救姜文还是救救观众？&lt;/a&gt;,文中提到了通过抓包猫眼App发现了评论的数据接口：&lt;a href=&quot;http://m.maoyan.com/mmdb/comments/movie/248566.json?_v_=yes&amp;amp;offset=1&quot; class=&quot;uri&quot;&gt;http://m.maoyan.com/mmdb/comments/movie/248566.json?_v_=yes&amp;amp;offset=1&lt;/a&gt;,其中248566属于电影的专属id，offset代表页数，但并未提及如何在猫眼App抓包。经过笔者的摸索，在尝试Charles等各种抓包工具后，踩了无数的坑之后，最终使用Fiddler抓取到了猫眼App上有关该电影的评论数据接口，现将本次抓取过程记录下来。PS.还是Fiddler大法好&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;使用工具与环境&quot;&gt;使用工具与环境&lt;/h3&gt;
&lt;p&gt;windows10、抓包工具Fiddler、手机iphone6sp、猫眼专业版App&lt;/p&gt;
&lt;h3 id=&quot;抓包过程&quot;&gt;抓包过程&lt;/h3&gt;
&lt;p&gt;1.打开Fiddler Options，勾选Decrypt Https traffic选项,解密https请求。&lt;br/&gt;&lt;img src=&quot;https://dn-coding-net-production-file.qbox.me/34f96700-9581-11e8-b8c4-dbeba3bbab78.png?attname=1.png&amp;amp;e=1533128611&amp;amp;token=goE9CtaiT5YaIP6ZQ1nAafd_C1Z_H2gVP8AwuC-5:2lLLgWpDhvTlvuk-Y8AJkkj_gac=&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.勾选Allow remote computers to connect ,允许别的机器把http/https请求发送到本机。&lt;br/&gt;&lt;img src=&quot;https://dn-coding-net-production-file.qbox.me/2fe13bd0-9581-11e8-b8c4-dbeba3bbab78.png?attname=2.png&amp;amp;e=1533129863&amp;amp;token=goE9CtaiT5YaIP6ZQ1nAafd_C1Z_H2gVP8AwuC-5:6FjUffZ9qlsqUnEpXXE7dxdgQuY=&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.重启Fiddler，保证PC和手机在同一局域网下，并在手机上给wifi配置手动HTTP代理，服务器为PC的ip地址，端口号为8888。之后使用safari打开链接（&lt;a href=&quot;http://%E6%9C%AC%E6%9C%BAip%E5%9C%B0%E5%9D%80:8888/&quot; class=&quot;uri&quot;&gt;http://本机IP地址:8888&lt;/a&gt;),点击网页中的”FiddlerRoot certificate”安装Fiddler的证书，安装完成后就可以用Fiddler抓取手机上的包了。如果遇见打开App无法联网的情况，注意检查手机设置通用里的本机中证书栏是否已经信任证书。&lt;br/&gt;&lt;img src=&quot;https://dn-coding-net-production-file.qbox.me/2fe1b100-9581-11e8-b8c4-dbeba3bbab78.png?attname=3.PNG&amp;amp;e=1533129863&amp;amp;token=goE9CtaiT5YaIP6ZQ1nAafd_C1Z_H2gVP8AwuC-5:Fc4ym7CX6-K0O960yDuRCDF0Zcs=&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;4.手机打开猫眼App，打开评论栏，不断下滑加载评论,最终在Fiddler里截取到评论数据接口。&lt;br/&gt;&lt;img src=&quot;https://dn-coding-net-production-file.qbox.me/2fe22630-9581-11e8-b8c4-dbeba3bbab78.png?attname=4.PNG&amp;amp;e=1533129863&amp;amp;token=goE9CtaiT5YaIP6ZQ1nAafd_C1Z_H2gVP8AwuC-5:b1N2SmSL-hCno4oqKOmlpEIW_WM=&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://dn-coding-net-production-file.qbox.me/2fe29b60-9581-11e8-b8c4-dbeba3bbab78.png?attname=5.png&amp;amp;e=1533129863&amp;amp;token=goE9CtaiT5YaIP6ZQ1nAafd_C1Z_H2gVP8AwuC-5:d9SqxO3hikmfr8fiAnBzn0vbK6Q=&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;5.打开抓取到的数据接口，可以看见相应的json数据。&lt;br/&gt;&lt;img src=&quot;https://dn-coding-net-production-file.qbox.me/62f977c0-9587-11e8-96e8-c75d48a729e2.png?attname=6.png&amp;amp;e=1533130534&amp;amp;token=goE9CtaiT5YaIP6ZQ1nAafd_C1Z_H2gVP8AwuC-5:y2511C0vXjltXBqA22G1q7gFQPk=&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Aug 2018 12:59:00 +0000</pubDate>
<dc:creator>甘乐</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/socrates-lzstu/p/9403889.html</dc:identifier>
</item>
<item>
<title>RESTful源码笔记之RESTful Framework的Mixins小结 - 时光飞逝，逝者如斯</title>
<link>http://www.cnblogs.com/JetpropelledSnake/p/9403879.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JetpropelledSnake/p/9403879.html</guid>
<description>
&lt;h2&gt;0x00 引言&lt;/h2&gt;
&lt;p&gt;本篇对drf中的mixins进行简要的分析总结。&lt;br/&gt;Mixins在drf中主要配合viewset共同使用，实现http方法与mixins的相关类与方法进行关联。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; rest_framework &lt;span&gt;import&lt;/span&gt; viewsets
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个viewset中，只要有5类Minxin，他们与http方法对应如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1354564/201808/1354564-20180801204316940-35187883.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面，我们将逐个Mixins介绍!&lt;/p&gt;

&lt;h2&gt;0x01 CreateModelMixin&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 源码&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; CreateModelMixin(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    Create a model instance ==&amp;gt;创建一个实例
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; create(self, request, *args, **&lt;span&gt;kwargs):
    
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取相关serializer&lt;/span&gt;
        serializer = self.get_serializer(data=&lt;span&gt;request.data)
        
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进行serializer的验证&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; raise_exception=True,一旦验证不通过，不再往下执行，直接引发异常&lt;/span&gt;
        serializer.is_valid(raise_exception=&lt;span&gt;True)
        
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用perform_create()方法，保存实例&lt;/span&gt;
&lt;span&gt;        self.perform_create(serializer)
        
        headers &lt;/span&gt;=&lt;span&gt; self.get_success_headers(serializer.data)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(serializer.data, status=status.HTTP_201_CREATED, headers=&lt;span&gt;headers)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; perform_create(self, serializer):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 保存实例&lt;/span&gt;
&lt;span&gt;        serializer.save()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_success_headers(self, data):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Location&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: str(data[api_settings.URL_FIELD_NAME])}
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; (TypeError, KeyError):
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1354564/201808/1354564-20180801204412430-241858574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div readability=&quot;54.428084451287&quot;&gt;
&lt;p&gt;由上图可以看出这个类的一个逻辑，其中，perform_create( )对serializer直接进行save保存，当在一些情境下，我们需要对perform_create( )进行重写。 那么我们现在可能有一个下面的需要：&lt;/p&gt;

&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;假设现在有一个course课程model，里面维持了一个数，记录课程收藏数，还存在一个用户收藏userfav的model(应当有一个外键指向course)，当一个用户对课程进行收藏，理论上现在post进来的应该是userfav的instance，显然，我们还需要对相应course的收藏数进行+1。&lt;br/&gt;这个时候，我们就需要重写perform_create( )方法！&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; perform_create(self, serializer):
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 重写save的逻辑&lt;/span&gt;
    instance =&lt;span&gt; serializer.save()
    course &lt;/span&gt;=&lt;span&gt; instance.course
    course.fav_num &lt;/span&gt;+= 1&lt;span&gt;
    course.save()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然，这不是唯一的解决方法，我们还可以在seriliazer进行设置，我们还可以使用drf的信号量进行解决！&lt;/p&gt;

&lt;h2&gt;0x02 ListModelMixin&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 源码&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ListModelMixin(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    List a queryset.==&amp;gt; 列表页获取
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; list(self, request, *args, **&lt;span&gt;kwargs):
        queryset &lt;/span&gt;=&lt;span&gt; self.filter_queryset(self.get_queryset())
        
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这是一个分页功能，如果在viewset中设置了pagination_class，那么这里就会起作用&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取当前页的queryset，如果不存在分页，返回None&lt;/span&gt;
        page =&lt;span&gt; self.paginate_queryset(queryset)
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; page &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 分页不为空，那么不能简单的执行Response(serializer.data)&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 还需要将相关的page信息序列化在进行响应&lt;/span&gt;
            serializer = self.get_serializer(page, many=&lt;span&gt;True)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.get_paginated_response(serializer.data)

        serializer &lt;/span&gt;= self.get_serializer(queryset, many=&lt;span&gt;True)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(serializer.data)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ListModelMixin一般用来获取列表页，大多数情况下比较简单，不需要重写相关的方法。&lt;/p&gt;

&lt;h2&gt;0x03 RetriveModelMixin&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 源码&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; RetrieveModelMixin(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    Retrieve a model instance.==&amp;gt; 获取某一个对象的具体信息
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; retrieve(self, request, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一般访问的url都为/obj/id/这种新式&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; get_object()可以获取到这个id的对象&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意在viewset中设置lookup_field获取重写get_object()方法可以指定id具体对象是什么~！&lt;/span&gt;
        instance =&lt;span&gt; self.get_object()
        serializer &lt;/span&gt;=&lt;span&gt; self.get_serializer(instance)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(serializer.data)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对retrieve这个方法的重写几率比较高，例如我们在增加点击数的时候，经常要对其进行一个重写。&lt;/p&gt;

&lt;h2&gt;0x04 ReriveModelMixin&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 源码&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UpdateModelMixin(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    Update a model instance.==&amp;gt; 更新某个具体对象的内容
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; update(self, request, *args, **&lt;span&gt;kwargs):
        partial &lt;/span&gt;= kwargs.pop(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;partial&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, False)
        instance &lt;/span&gt;=&lt;span&gt; self.get_object()
        serializer &lt;/span&gt;= self.get_serializer(instance, data=request.data, partial=&lt;span&gt;partial)
        serializer.is_valid(raise_exception&lt;/span&gt;=&lt;span&gt;True)
        self.perform_update(serializer)

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; getattr(instance, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_prefetched_objects_cache&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, None):
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; If 'prefetch_related' has been applied to a queryset, we need to&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; forcibly invalidate the prefetch cache on the instance.&lt;/span&gt;
            instance._prefetched_objects_cache =&lt;span&gt; {}

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Response(serializer.data)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; perform_update(self, serializer):
        serializer.save()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; partial_update(self, request, *args, **&lt;span&gt;kwargs):
        kwargs[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;partial&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; True
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.update(request, *args, **kwargs)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;RetrieveModelMixin的实现逻辑基本整合了Create以及Retrieve，先得到具体的实例，再对其进行验证以及保存，如果需要对更新这个逻辑进行自定义，那么需要重写perform_update( )方法，而尽量少去重写update( )。&lt;/p&gt;

&lt;h2&gt;0x05 DestoryModelMixin&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 源码&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; DestroyModelMixin(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    Destroy a model instance.
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; destroy(self, request, *args, **&lt;span&gt;kwargs):
        instance &lt;/span&gt;=&lt;span&gt; self.get_object()
        self.perform_destroy(instance)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(status=&lt;span&gt;status.HTTP_204_NO_CONTENT)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; perform_destroy(self, instance):
        instance.delete()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DestroyModelMixin的逻辑也相对比较简单，我们取CreateModelMixin下面的例子，当我们取消收藏，那么我们的DestroyModelMixin就发挥作用了。同理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; perform_create(self, serializer):
    instance &lt;/span&gt;=&lt;span&gt; serializer.save()
    course &lt;/span&gt;=&lt;span&gt; instance.course
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; course.fav_num &amp;gt;&lt;span&gt; 0:
        course.fav_num &lt;/span&gt;-= 1
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        course.fav_num &lt;/span&gt;=&lt;span&gt; 0
    course.save()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;7.3793565683646&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p data-id=&quot;heading-6&quot;&gt; &lt;/p&gt;
&lt;h2&gt;0x05 小结&lt;/h2&gt;
&lt;p&gt;mixins相对比较好理解，本篇只是简要的分析了源码的内容以及各个mixins的逻辑，最重要的还是学会去重写它们相关的方法。&lt;br/&gt;&lt;strong&gt;一般情况下，当我们在操作某一个model的时候，涉及到另外一个model中数据的修改，那么就需要对这个mixins下执行save的逻辑的方法进行重写。&lt;/strong&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Wed, 01 Aug 2018 12:57:00 +0000</pubDate>
<dc:creator>时光飞逝，逝者如斯</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JetpropelledSnake/p/9403879.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 2.0 MVC - 获取当前登录用户信息 - 墨小宇</title>
<link>http://www.cnblogs.com/danvic712/p/9062710.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/danvic712/p/9062710.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt; 一、前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　上篇实战完成后，没想到会有那么多的圈友给了那么多的支持，甚至连只是作为代码仓储的git上也给了一些小星星，真的感觉很惶恐啊，哈哈哈，毕竟代码写的很烂啊。由于上一篇只是大概说了下项目，所以准备写下这篇详细说下自己对于获取当前登录用户的设计与实现，原本准备上周末就完成的这篇，结果周六一起来，发现自己起水痘了，嗯，很悲催。。。请了一个星期的假，今天好歹头不痛，不发烧能看电脑了，就努力努力赶出来吧。&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　获取当前登录用户的整体思路，我们可以通过创建一个静态的用户类，存储当前登录的用户。通过将属性值存储在session中，从而存储到服务器的内存中，做到可以在系统全局中获取当前登录用户的数据信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　.NET Framework平台下面的MVC与.NET Core平台下面的MVC，对于Session的使用上存在着一些的差异，主要在于如何获取到Session对象。在传统的MVC项目中我们可以直接使用&lt;span&gt;HttpContext.Current.Session&lt;span&gt;获取到session，从而做到对于数据的取值、赋值；而&lt;/span&gt;&lt;/span&gt;在ASP.NET Core MVC中，并没有HttpContext.Current.Session这个静态类，通过查阅微软的文档可知，我们可以通过注入&lt;span&gt;IHttpContextAccessor&lt;/span&gt;对象的方式从而获取到session对象&lt;span&gt;，解决方案如下所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 二、使用Session存储当前登录的用户信息&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　首先，在ASP.NET Core 中使用Session，我们需要将Session注入到ASP.NET Core的管道(pipeline)中，和我们使用MVC的方式相同，在ConfigureServices(IServiceCollection services)中，添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; services.AddSession();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在Configure(IApplicationBuilder app, IHostingEnvironment env)中添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; app.UseSession();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样，我们就可以在MVC中使用到Session了。当然现在也只是能在Controller中获取到Session对象，如果想在别的类文件中使用到Session对象，我们需要注入&lt;span&gt;IHttpContextAccessor&lt;span&gt;对象。这里，我们可以使用nuget添加&lt;span&gt;Microsoft.AspNetCore.Http.Extensions&lt;/span&gt;这个程序集，方便我们对于Session进行操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　因为我们采用静态类作为当前登录用户的载体，而静态类不能拥有实例构造函数，所以我采用创建一个配置方法来进行注入，CurrentUser类如下所示。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_fdef8d8b-15e4-4173-b918-0a00135fc1f6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fdef8d8b-15e4-4173-b918-0a00135fc1f6&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fdef8d8b-15e4-4173-b918-0a00135fc1f6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CurrentUser
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; Initialize
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; IHttpContextAccessor _httpContextAccessor;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ISession _session =&amp;gt;&lt;span&gt; _httpContextAccessor.HttpContext.Session;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IHttpContextAccessor httpContextAccessor)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             _httpContextAccessor =&lt;span&gt; httpContextAccessor;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; Attribute
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户主键
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserOID
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; =&amp;gt; _session == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;&quot;&quot;&lt;/span&gt; : _session.GetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserOID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt; =&amp;gt; _session.SetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserOID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, !&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(value) ? value : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;用户编号 
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; UserId
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; =&amp;gt; _session == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;0&lt;/span&gt; : Convert.ToInt64(_session.GetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt; =&amp;gt; _session.SetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, value != &lt;span&gt;0&lt;/span&gt; ? value.ToString() : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户姓名
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; =&amp;gt; _session == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;&quot;&quot;&lt;/span&gt; : _session.GetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt; =&amp;gt; _session.SetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, !&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(value) ? value : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户登录账户
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserAccount
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; =&amp;gt; _session == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;&quot;&quot;&lt;/span&gt; : _session.GetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserAccount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt; =&amp;gt; _session.SetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserAccount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, !&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(value) ? value : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户头像地址
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserImage
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; =&amp;gt; _session == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;&quot;&quot;&lt;/span&gt; : _session.GetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserImage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt; =&amp;gt; _session.SetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserImage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, !&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(value) ? value : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户角色
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserRole
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; =&amp;gt; _session == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;&quot;&quot;&lt;/span&gt; : _session.GetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserRole&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt; =&amp;gt; _session.SetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserRole&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, !&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(value) ? value : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 主页地址
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;75&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserPage
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; =&amp;gt; _session == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;&quot;&quot;&lt;/span&gt; : _session.GetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserPage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt; =&amp;gt; _session.SetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserPage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, !&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(value) ? value : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; 
&lt;span&gt;81&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;82&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;CurrentUser&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 　　当我们创建好了这样一个静态类后，我们就可以在登录成功后，将当前登录的用户信息赋值给这个静态类，这样我们就可以在需要使用到的地方直接使用CurrentUser这个静态类即可。在当时实际使用后发现，想要获取到登录后存储的用户信息，则必须在Controller的构造方法中调用CurrentUser的Configure方法，无形中还是增加了许多的工作量。&lt;/p&gt;
&lt;p&gt;　　Controller的构造函数示例代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_c080ea00-004a-4308-ab2a-754fbbd788f5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c080ea00-004a-4308-ab2a-754fbbd788f5&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c080ea00-004a-4308-ab2a-754fbbd788f5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     [Area(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Administrator&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     [Authorize(Policy = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Administrator&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : DanvicController
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; Initialize
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ApplicationDbContext _context;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ILogger _logger;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IHomeService _service;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IHttpContextAccessor _httpContextAccessor;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; HomeController(IHomeService service, ILogger&amp;lt;HomeController&amp;gt;&lt;span&gt; logger, IHttpContextAccessor httpContextAccessor, ApplicationDbContext context)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             _service =&lt;span&gt; service;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             _logger =&lt;span&gt; logger;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             _httpContextAccessor =&lt;span&gt; httpContextAccessor;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             _context =&lt;span&gt; context;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            CurrentUser.Configure(_httpContextAccessor);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; View
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;HomeController&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　登录成功后给CurrentUser赋值的相关代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_1c72f144-bf96-45a0-b5fc-5c706070ff09&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1c72f144-bf96-45a0-b5fc-5c706070ff09&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1c72f144-bf96-45a0-b5fc-5c706070ff09&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置当前登录用户
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task SetCurrentUser(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; oid, IHttpContextAccessor httpContextAccessor, ApplicationDbContext context)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            CurrentUser.Configure(httpContextAccessor);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; user = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; PSURepository.GetUserByOIDAsync(oid, context);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (user != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; role = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (user.AccountType)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                         role = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Administrator&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                         role = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Instructor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                         role = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Student&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;                 CurrentUser.UserAccount =&lt;span&gt; user.Account;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 CurrentUser.UserId =&lt;span&gt; user.Id;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 CurrentUser.UserImage =&lt;span&gt; user.ImageSrc;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 CurrentUser.UserName =&lt;span&gt; user.Name;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 CurrentUser.UserOID =&lt;span&gt; user.IdentityUserOID;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 CurrentUser.UserRole =&lt;span&gt; role;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 CurrentUser.UserPage =&lt;span&gt; user.HomePage;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         }    
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;SetCurrentUser&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　这样就可以了，当需要使用到当前登录的用户信息时，直接CurrentUser.属性就可以了，整个项目的代码还是在项目实战的那个代码仓库中，地址点后面：&lt;a href=&quot;https://github.com/Lanesra712/Danvic.PSU&quot; target=&quot;_blank&quot;&gt;源代码仓储&lt;/a&gt;，欢迎大家提出更好的解决方案啊。最后，还是要推广下我的个人博客啊，&lt;span&gt;&lt;a title=&quot;Yu's&quot; href=&quot;https://lanesra712.github.io/&quot; target=&quot;_blank&quot;&gt;点击这里，去看看我的博客，谢谢啦~~~&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Aug 2018 12:52:00 +0000</pubDate>
<dc:creator>墨小宇</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/danvic712/p/9062710.html</dc:identifier>
</item>
<item>
<title>HTTP请求的python实现（urlopen、headers处理、 Cookie处理、设置Timeout超时、 重定向、Proxy的设置） - guguobao</title>
<link>http://www.cnblogs.com/guguobao/p/9403730.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guguobao/p/9403730.html</guid>
<description>&lt;center&gt;## python实现HTTP请求的三中方式：urllib2/urllib、httplib/urllib 以及Requests&lt;/center&gt;
&lt;h2 id=&quot;urllib2urllib实现&quot;&gt;urllib2/urllib实现&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;urllib2和urllib是python两个内置的模块，要实现HTTP功能，实现方式是以urllib2为主，urllib为辅&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;首先实现一个完整的请求与响应模型&quot;&gt;1 首先实现一个完整的请求与响应模型&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;urllib2提供基础函数urlopen，&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;import urllib2
response = urllib2.urlopen('http://www.cnblogs.com/guguobao')
html = response.read()
print html&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;改进，分两步：请求和响应&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#!coding:utf-8
import urllib2
#请求
request = urllib2.Request('http://www.cnblogs.com/guguobao')
#响应
response = urllib2.urlopen(request)
html = response.read()
print html&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;上面使用GET请求，下面改为POST请求，使用urllib。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#!coding:utf-8
import urllib
import urllib2
url = 'http://www.cnblogs.com/login'
postdata = {'username' : 'qiye',
           'password' : 'qiye_pass'}
#info 需要被编码为urllib2能理解的格式，这里用到的是urllib
data = urllib.urlencode(postdata)
req = urllib2.Request(url, data)
response = urllib2.urlopen(req)
html = response.read()&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;然而运行结果没有输出，因为服务器拒绝你的访问，需要检验请求头信息，来判断是否是来自浏览器的请求&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;#coding:utf-8
#请求头headers处理:设置一下请求头中的User-Agent域和Referer域信息
import urllib
import urllib2
url = 'http://www.xxxxxx.com/login'
user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'
referer='http://www.xxxxxx.com/'
postdata = {'username' : 'qiye',
           'password' : 'qiye_pass'}
# 将user_agent,referer写入头信息
headers={'User-Agent':user_agent,'Referer':referer}
data = urllib.urlencode(postdata)
req = urllib2.Request(url, data,headers)
response = urllib2.urlopen(req)
html = response.read()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;cookie处理&quot;&gt;3 Cookie处理&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;urllib2对Cookie的处理也是自动，使用CookieJar函数进行Cookie的管理，如果需要得到某个Cookie项的值，可以这样：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;import urllib2,cookielib

cookie = cookielib.CookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))
response = opener.open('http://www.zhihu.com')
for item in cookie:
    print item.name+':'+item.name
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;但有时遇到情况，我们不想让urllib2自动处理，我们想自己添加Cookie的内容，可以通过设置请求头中的cookie域来做&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;import urllib2,cookielib

opener = urllib2.build_opener()
opener.addheaders.append(('Cookie','email='+'helloguguobao@gmail.com'))#Cookie和email替换什么值都可以，但不能没有
req = urllib2.Request('http://www.zhihu.com')
response = opener.open(req)
print response.headers
retdata = response.read()&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;运行截图&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1252747/201808/1252747-20180801173410981-993753990.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;设置timeout超时&quot;&gt;4 设置Timeout超时&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在python2.6及新版中，urlopen函数提供对Timeout的设置：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;import urllib2
request=urllib2.Request('http://www.zhihu.com')
response = urllib2.urlopen(request,timeout=2)
html=response.read()
print html&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取http响应码&quot;&gt;5 获取HTTP响应码&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;只要使用urlopen返回的response对象的getcode()方法就可以得到HTTP返回码。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;import urllib2
try:
    response = urllib2.urlopen('http://www.google.com')
    print response
except urllib2.HTTPError as e:
    if hasattr(e, 'code'):
        print 'Error code:',e.code&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;重定向&quot;&gt;6. 重定向&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;urllib2默认情况下会对HTTP 3XX返回码自动进行重定向动作。要检测是否发生重定向动作，只要检查一下Response的URL和Request的URL是否一致：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;import urllib2
response = urllib2.urlopen('http://www.zhihu.cn')
isRedirected = response.geturl() == 'http://www.zhihu.cn'&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果不想自动重定向，可以自定义HTTPRedirectHandler类：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;import urllib2
class RedirectHandler(urllib2.HTTPRedirectHandler):
    def http_error_301(self, req, fp, code, msg, headers):
        pass
    def http_error_302(self, req, fp, code, msg, headers):
        result =urllib2.HTTPRedirectHandler.http_error_301(self,req,fp,code,msg,headers)
        result.status =code
        result.newurl = result.geturl()
        return result

opener = urllib2.build_opener(RedirectHandler)
opener.open('http://www.zhihu.cn')
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;proxy的设置&quot;&gt;7 Proxy的设置&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在做爬虫开发中，可能会用到代理。urllib2默认会使用环境变量http_proxy来设置HTTP Proxy。但是我们一般不采用这种方法，而是使用ProxyHandler在程序中动态设置代理&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;import urllib2
proxy = urllib2.ProxyHandler({'http': '127.0.0.1:1080'})# 运行时需要把socketsocks关闭系统代理。并使用1080端口，或者直接退出socketsocks软件
opener = urllib2.build_opener(proxy)
urllib2.install_opener(opener)
response = urllib2.urlopen('http://www.zhihu.com/')
print response.read()
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这里要注意一个细节，使用urllib2.install_opener()会设置urllib2的全局opener，之后，所有的HTTP访问都会使用这个代理，这样很方便，但是，想在程序中使用两个不同的代理，就不能使用install_opener去更改全局的设置，而是直接调用urllib2.open()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;import urllib2
proxy = urllib2.ProxyHandler({'http': '127.0.0.1:1080'})
opener = urllib2.build_opener(proxy,)
response = opener.open(&quot;http://www.google.com/&quot;)
print response.read()
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;运行时需要把socketsocks关闭系统代理。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 01 Aug 2018 12:18:00 +0000</pubDate>
<dc:creator>guguobao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guguobao/p/9403730.html</dc:identifier>
</item>
</channel>
</rss>