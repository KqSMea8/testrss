<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>多线程之失败自动重试机制 - 孔子说</title>
<link>http://www.cnblogs.com/java7115/p/9699720.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/java7115/p/9699720.html</guid>
<description>&lt;p&gt;发现一个比较好玩的东西:&lt;/p&gt;
&lt;p&gt;如果你在使用多线程的使用中异常结束了，你应该如何操作呢？&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;正常情况下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1493180/201809/1493180-20180925152516891-1709464120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1493180/201809/1493180-20180925152548993-1490559429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目一启动都可以跑完，如果有一段代码出现错误呢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1493180/201809/1493180-20180925152748969-759741113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;系统丢出了一个异常出来。&lt;/p&gt;
&lt;p&gt;有没有发生过这样的情况，你写的工作线程莫名其妙的挂了，如果不是被你刚好看到，拿只能抓瞎了，不知道啥原因了，因为异常的时候只会把stack trace打在控制台上，不会记在你想记得错误日志里，头皮都抓破了也没能找到确切的地方，最后只能在能加try catch 的地方都给加上，但你却并没有找到准确的错误地址。&lt;/p&gt;
&lt;p&gt;好的，接下来我们把代码更改一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1493180/201809/1493180-20180925153217536-904111587.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1493180/201809/1493180-20180925153256008-690994928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们再运行一下看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1493180/201809/1493180-20180925153542602-896205102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在完成任务之前，这个线程会持续运行。通过其他多线程的思想同样可以实现这种情况。&lt;/p&gt;

</description>
<pubDate>Tue, 25 Sep 2018 07:27:00 +0000</pubDate>
<dc:creator>孔子说</dc:creator>
<og:description>发现一个比较好玩的东西: 如果你在使用多线程的使用中异常结束了，你应该如何操作呢？ 例子： 正常情况下： 项目一启动都可以跑完，如果有一段代码出现错误呢。 系统丢出了一个异常出来。 有没有发生过这样的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/java7115/p/9699720.html</dc:identifier>
</item>
<item>
<title>从零开始学 Web 之 Vue.js（六）Vue的组件 - Daotin</title>
<link>http://www.cnblogs.com/lvonve/p/9699711.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvonve/p/9699711.html</guid>
<description>&lt;blockquote readability=&quot;8.7013274336283&quot;&gt;
&lt;p&gt;大家好，这里是「 从零开始学 Web 系列教程 」，并在下列地址同步更新......&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;github：https://github.com/Daotin/Web&lt;/li&gt;
&lt;li&gt;微信公众号：&lt;a href=&quot;https://github.com/Daotin/pic/raw/master/wx.jpg&quot;&gt;Web前端之巅&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;博客园：http://www.cnblogs.com/lvonve/&lt;/li&gt;
&lt;li&gt;CSDN：https://blog.csdn.net/lvonve/&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这里我会从 Web 前端零基础开始，一步步学习 Web 相关的知识点，期间也会分享一些好玩的项目。现在就让我们一起进入 Web 前端学习的冒险之旅吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/Daotin/pic/raw/master/fgx.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一vue组件&quot;&gt;一、Vue组件&lt;/h2&gt;
&lt;p&gt;什么是组件： 组件的出现，就是为了拆分 Vue 实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件化和模块化的不同：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；&lt;/li&gt;
&lt;li&gt;组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二定义组件&quot;&gt;二、定义组件&lt;/h2&gt;
&lt;h3 id=&quot;定义全局组件&quot;&gt;1、定义全局组件&lt;/h3&gt;
&lt;p&gt;定义全局组件有三种方式：&lt;/p&gt;
&lt;p&gt;1、使用 &lt;code&gt;Vue.extend&lt;/code&gt; 配合 &lt;code&gt;Vue.component&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 1.使用 Vue.extend 来创建全局的Vue组件
var login = Vue.extend({
  // 通过 template 属性，指定了组件要展示的HTML结构
  template: '&amp;lt;h1&amp;gt;登录&amp;lt;/h1&amp;gt;'
});

// 2.使用 Vue.component('组件的名称', 创建出来的组件模板对象) 
Vue.component('login', login);

// 3.使用组件
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;!-- 如果要使用组件，直接，把组件的名称，以 HTML 标签的形式，引入到页面中即可 --&amp;gt;
    &amp;lt;login&amp;gt;&amp;lt;/login&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;使用 Vue.component 定义全局组件的时候，组件名称使用了 驼峰命名（如myLogin），则在引用组件的时候，需要把 大写的驼峰改为小写的字母，同时在两个单词之前，使用 - 链接（&lt;code&gt;&amp;lt;my-login&amp;gt;&amp;lt;/my-login&amp;gt;&lt;/code&gt;）；如果不使用驼峰,则直接拿名称来使用即可；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，上面两步可以合成一个步骤完成：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Vue.component('login', Vue.extend({
  template: '&amp;lt;h1&amp;gt;登录&amp;lt;/h1&amp;gt;'
}));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、直接使用 Vue.component 方法：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Vue.component('login', {
  template: '&amp;lt;div&amp;gt;&amp;lt;h3&amp;gt;注册&amp;lt;/h3&amp;gt;&amp;lt;span&amp;gt;123&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;'
});&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：&lt;strong&gt;不论是哪种方式创建出来的组件，组件的 template 属性指向的模板内容，必须有且只能有唯一的一个根元素，否则会报错。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、将模板字符串，定义到 template 标签中：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
  &amp;lt;script src=&quot;./lib/vue-2.4.0.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;box&quot;&amp;gt;
    &amp;lt;!-- 3. 使用组件 --&amp;gt;
    &amp;lt;mycom&amp;gt;&amp;lt;/mycom&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;!-- 2.在 被控制的 #box 外面,使用 template 元素,定义组件的HTML模板结构  --&amp;gt;
  &amp;lt;template id=&quot;tmp1&quot;&amp;gt;
    &amp;lt;!-- 还是需要遵从template 模板内容，必须有且只能有唯一的一个根元素 --&amp;gt;
    &amp;lt;div&amp;gt;
      &amp;lt;h3&amp;gt;登录&amp;lt;/h3&amp;gt;
      &amp;lt;p&amp;gt;p标签&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/template&amp;gt;

  &amp;lt;script&amp;gt;
    // 1.定义组件
    Vue.component('mycom', {
      template: '#tmp1'
    });

    var vm = new Vue({
      el: &quot;#box&quot;,
      data: {},
      methods: {}
    });
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1、&lt;code&gt;template: '#tmp1'&lt;/code&gt; 是定义模板标签的 id ，# 别忘写了。&lt;/p&gt;
&lt;p&gt;2、被控制的 #box 外面,使用 template 标签；&lt;/p&gt;
&lt;p&gt;3、 template 标签里面，还是遵从只能有唯一的一个根元素的原则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;定义私有组件&quot;&gt;2、定义私有组件&lt;/h3&gt;
&lt;p&gt;定义私有组件，就是再VM实例中定义组件。&lt;/p&gt;
&lt;p&gt;如下，box中可以使用，box2不可以使用。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
  &amp;lt;script src=&quot;./lib/vue-2.4.0.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;box&quot;&amp;gt;
    &amp;lt;mycom&amp;gt;&amp;lt;/mycom&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;div id=&quot;box2&quot;&amp;gt;
    &amp;lt;mycom&amp;gt;&amp;lt;/mycom&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;template id=&quot;temp&quot;&amp;gt;
    &amp;lt;h3&amp;gt;自定义私有属性&amp;lt;/h3&amp;gt;
  &amp;lt;/template&amp;gt;

  &amp;lt;script&amp;gt;
    var vm = new Vue({
      el: &quot;#box&quot;,
      data: {},
      methods: {},
      // 定义私有组件
      components: {
        mycom: {
          template: '#temp'
        }
      }
    });
    var vm2 = new Vue({
      el: &quot;#box2&quot;,
      data: {},
      methods: {}
    });
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;组件的data和methods属性&quot;&gt;3、组件的data和methods属性&lt;/h3&gt;
&lt;p&gt;组件中也可以有自己的data和methods属性，可以传入template中使用。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;data属性为一个匿名函数，其返回值为一个对象。&lt;/li&gt;
&lt;li&gt;data 函数返回值为一个对象（&lt;strong&gt;最好是新开辟的对象，否则如果多次引用组件，不是新开辟的对象给的话，对象是同一份，而我们需要每一个组件有自己的对象&lt;/strong&gt;），对象中可以放入数据。&lt;/li&gt;
&lt;li&gt;组件中 的data和methods,使用方式,和实例中的 data 和methods使用方式完全一样&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;div id=&quot;box2&quot;&amp;gt;
  &amp;lt;login&amp;gt;&amp;lt;/login&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;template id=&quot;temp2&quot;&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;input type=&quot;button&quot; value=&quot;按钮&quot; @click=&quot;myclick&quot;&amp;gt;
    &amp;lt;h3&amp;gt;自定义私有属性&amp;lt;/h3&amp;gt;
    &amp;lt;p&amp;gt; {{msg}} &amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  Vue.component('login', {
    template: '#temp2',
    data: function () {
      return {
        msg: '这是组件中的data'
      }
    }，
    methods: {
      myclick() {
        console.log(&quot;点击按钮&quot;);
      }
  }
  });
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三组件切换&quot;&gt;三、组件切换&lt;/h2&gt;
&lt;p&gt;我们在登录注册一个网站的时候，经常看到两个按钮，一个登录，一个注册，如果你没有账号的话，需要先注册才能登录。我们在点击登录和注册的时候，网页会相应的切换，登录页面就是登陆组件，注册页面就是注册组件，那么点击登录和注册，如何实现组件的切换呢？&lt;/p&gt;
&lt;h3 id=&quot;方式一&quot;&gt;1、方式一&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用&lt;code&gt;flag&lt;/code&gt;标识符结合&lt;code&gt;v-if&lt;/code&gt;和&lt;code&gt;v-else&lt;/code&gt;切换组件&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
  &amp;lt;script src=&quot;./lib/vue-2.4.0.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;box&quot;&amp;gt;
    &amp;lt;!-- 给a注册点击事件，切换flag状态 --&amp;gt;
    &amp;lt;a href=&quot;javascript:;&quot; @click.prevent=&quot;flag=true&quot;&amp;gt;登录&amp;lt;/a&amp;gt;
    &amp;lt;a href=&quot;javascript:;&quot; @click.prevent=&quot;flag=false&quot;&amp;gt;注册&amp;lt;/a&amp;gt;
    &amp;lt;!-- 使用v-if v-else切换组件 --&amp;gt;
    &amp;lt;login v-if=&quot;flag&quot;&amp;gt;
    &amp;lt;/login&amp;gt;
    &amp;lt;register v-else=&quot;flag&quot;&amp;gt;
    &amp;lt;/register&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;script&amp;gt;
    Vue.component('login', {
      template: '&amp;lt;h3&amp;gt;登录组件&amp;lt;/h3&amp;gt;'
    });
    Vue.component('register', {
      template: '&amp;lt;h3&amp;gt;注册组件&amp;lt;/h3&amp;gt;'
    });

    var vm = new Vue({
      el: &quot;#box&quot;,
      data: {
        flag: true
      },
      methods: {}
    });
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;缺陷：&lt;/strong&gt;由于flag的值只有true和false，所以只能用于两个组件间 的切换，当大于两个组件的切换就不行了。&lt;/p&gt;
&lt;h3 id=&quot;方式二&quot;&gt;2、方式二&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用 component元素的&lt;code&gt;:is&lt;/code&gt;属性来切换不同的子组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;&amp;lt;component :is=&quot;componentId&quot;&amp;gt;&amp;lt;/component&amp;gt;&lt;/code&gt; 来指定要切换的组件。&lt;/p&gt;
&lt;p&gt;componentId：为需要显示的组件名称，为一个字符串，可以使用变量指定。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;componentId: 'login'&lt;/code&gt; // 默认显示登录组件。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
  &amp;lt;script src=&quot;./lib/vue-2.4.0.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;box&quot;&amp;gt;
    &amp;lt;!-- 给a注册点击事件，切换flag状态 --&amp;gt;
    &amp;lt;a href=&quot;javascript:;&quot; @click.prevent=&quot;componentId='login'&quot;&amp;gt;登录&amp;lt;/a&amp;gt;
    &amp;lt;a href=&quot;javascript:;&quot; @click.prevent=&quot;componentId='register'&quot;&amp;gt;注册&amp;lt;/a&amp;gt;
    &amp;lt;component :is=&quot;componentId&quot;&amp;gt;&amp;lt;/component&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;script&amp;gt;
    Vue.component('login', {
      template: '&amp;lt;h3&amp;gt;登录组件&amp;lt;/h3&amp;gt;'
    });
    Vue.component('register', {
      template: '&amp;lt;h3&amp;gt;注册组件&amp;lt;/h3&amp;gt;'
    });

    var vm = new Vue({
      el: &quot;#box&quot;,
      data: {
        componentId: 'login'   // 默认显示登录
      },
      methods: {}
    });
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;为组件切换添加过渡：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很简单，只需要&lt;strong&gt;用 transition 将 component 包裹起来&lt;/strong&gt;即可。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;transition&amp;gt;
  &amp;lt;component :is=&quot;componentId&quot;&amp;gt;&amp;lt;/component&amp;gt;
&amp;lt;/transition&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
  &amp;lt;script src=&quot;./lib/vue-2.4.0.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;./lib/animate.css&quot;&amp;gt;

  &amp;lt;style&amp;gt;
    .loginDiv {
      width: 200px;
      height: 200px;
      background-color: red;
    }

    .registerDiv {
      width: 200px;
      height: 200px;
      background-color: blue;
    }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;box&quot;&amp;gt;
    &amp;lt;!-- 给a注册点击事件，切换flag状态 --&amp;gt;
    &amp;lt;a href=&quot;javascript:;&quot; @click.prevent=&quot;componentId='login'&quot;&amp;gt;登录&amp;lt;/a&amp;gt;
    &amp;lt;a href=&quot;javascript:;&quot; @click.prevent=&quot;componentId='register'&quot;&amp;gt;注册&amp;lt;/a&amp;gt;
    &amp;lt;transition mode=&quot;out-in&quot; enter-active-class=&quot;animated bounceInRight&quot; leave-active-class=&quot;animated bounceOutRight&quot;&amp;gt;
      &amp;lt;component :is=&quot;componentId&quot;&amp;gt;&amp;lt;/component&amp;gt;
    &amp;lt;/transition&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;template id=&quot;login&quot;&amp;gt;
    &amp;lt;div class=&quot;loginDiv&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/template&amp;gt;

  &amp;lt;template id=&quot;register&quot;&amp;gt;
    &amp;lt;div class=&quot;registerDiv&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/template&amp;gt;

  &amp;lt;script&amp;gt;
    Vue.component('login', {
      template: '#login'
    });
    Vue.component('register', {
      template: '#register'
    });

    var vm = new Vue({
      el: &quot;#box&quot;,
      data: {
        componentId: 'login'
      },
      methods: {}
    });
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;mode=&quot;out-in&quot;&lt;/code&gt;：可以设置切换组件的模式为先退出再进入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;四组件传值&quot;&gt;四、组件传值&lt;/h2&gt;
&lt;h3 id=&quot;父组件向子组件传值&quot;&gt;1、父组件向子组件传值&lt;/h3&gt;
&lt;p&gt;我们先通过一个例子看看子组件可不可以直接访问父组件的数据：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;box&quot;&amp;gt;
    &amp;lt;mycom&amp;gt;&amp;lt;/mycom&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;template id=&quot;temp&quot;&amp;gt;
    &amp;lt;h3&amp;gt;子组件 --- {{msg}}&amp;lt;/h3&amp;gt;
  &amp;lt;/template&amp;gt;

  &amp;lt;script&amp;gt;
    var vm = new Vue({
      el: &quot;#box&quot;,
      data: {
        msg: '父组件的msg'
      },
      methods: {},
      components: {
        mycom: {
          template: '#temp'
        }
      }
    });
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于 components 定义的是私有组件，我们直接在子组件中调用父组件的msg会报错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/754332/201809/754332-20180925152507614-1760436878.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，怎么让子组件使用父组件的数据呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;父组件可以在引用子组件的时候， 通过 属性绑定（v-bind:） 的形式, 把需要传递给子组件的数据，以属性绑定的形式，传递到子组件内部，供子组件使用 。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;box&quot;&amp;gt;
    &amp;lt;mycom v-bind:parentmsg=&quot;msg&quot;&amp;gt;&amp;lt;/mycom&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;template id=&quot;temp&quot;&amp;gt;
    &amp;lt;h3&amp;gt;子组件 --- 父组件：{{parentmsg}}&amp;lt;/h3&amp;gt;
  &amp;lt;/template&amp;gt;

  &amp;lt;script&amp;gt;
    var vm = new Vue({
      el: &quot;#box&quot;,
      data: {
        msg: '父组件的msg'
      },
      methods: {},
      components: {
        mycom: {
          template: &quot;#temp&quot;,
          // 对传递给子组件的数据进行声明，子组件才能使用 
          props: ['parentmsg']
        }
      }
    });
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：父组件绑定的&lt;strong&gt;属性名称不能有大写字母&lt;/strong&gt;，否则不会显示，并且在命令行会有提示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/754332/201809/754332-20180925152458315-1834422857.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件data数据和props数据的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;data数据是子组件私有的，可读可写；&lt;/li&gt;
&lt;li&gt;props数据是父组件传递给子组件的，只能读，不能写。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;案例：发表评论功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;父组件为评论列表，子组件为ID，评论者，内容和按钮的集合，在输入ID，评论者等内容，然后点击添加的时候，需要首先获取子组件的list列表，然后再添加新的列表项到列表中。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
  &amp;lt;script src=&quot;./lib/vue-2.4.0.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;box&quot;&amp;gt;
    &amp;lt;mycom :plist=&quot;list&quot;&amp;gt;&amp;lt;/mycom&amp;gt;

    &amp;lt;ul&amp;gt;
      &amp;lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&amp;gt;
        ID:{{item.id}} --- 内容：{{item.content}} --- 评论人：{{item.user}}
      &amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;template id=&quot;tmp1&quot;&amp;gt;
    &amp;lt;div&amp;gt;
      &amp;lt;label&amp;gt;
        ID:
        &amp;lt;input type=&quot;text&quot; v-model=&quot;id&quot;&amp;gt;
      &amp;lt;/label&amp;gt;
      &amp;lt;br&amp;gt;
      &amp;lt;label&amp;gt;
        评论者:
        &amp;lt;input type=&quot;text&quot; v-model=&quot;user&quot;&amp;gt;
      &amp;lt;/label&amp;gt;
      &amp;lt;br&amp;gt;
      &amp;lt;label&amp;gt;
        内容:
        &amp;lt;textarea v-model=&quot;content&quot;&amp;gt;&amp;lt;/textarea&amp;gt;
      &amp;lt;/label&amp;gt;
      &amp;lt;br&amp;gt;
      &amp;lt;!-- 把父组件的数据作为子组件的函数参数传入 --&amp;gt;
      &amp;lt;input type=&quot;button&quot; value=&quot;添加评论&quot; @click=&quot;addContent(plist)&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/template&amp;gt;

  &amp;lt;script&amp;gt;
    var vm = new Vue({
      el: &quot;#box&quot;,
      data: {
        list: [{
          id: Date.now(),
          user: 'user1',
          content: 'what'
        }, {
          id: Date.now(),
          user: 'user2',
          content: 'are'
        }]
      },
      methods: {},
      components: {
        mycom: {
          template: '#tmp1',
          data: function () {
            return {
              id: '',
              user: '',
              content: '',
            }
          },
          methods: {
            addContent(plist) {
              plist.unshift({
                id: this.id,
                user: this.user,
                content: this.content
              });
            }
          },
          props: ['plist']
        }
      }
    });
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把添加ID，评论人，内容作为子组件，把列表作为父组件，然后把添加的数据放到父组件列表上，由于要获取到父组件列表的数据，所以必然涉及到父组件向子组件传值的过程。这里还通过子组件方法参数来保存父组件的数据到子组件的数据中。&lt;/p&gt;
&lt;h3 id=&quot;父组件向子组件传方法&quot;&gt;2、父组件向子组件传方法&lt;/h3&gt;
&lt;p&gt;既然父组件可以向子组件传递数据，那么也可以向子组件传递方法。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;box&quot;&amp;gt;
    &amp;lt;mycom v-bind:parentmsg=&quot;msg&quot; @parentfunc=&quot;show&quot;&amp;gt;&amp;lt;/mycom&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;template id=&quot;temp&quot;&amp;gt;
    &amp;lt;div&amp;gt;
      &amp;lt;input type=&quot;button&quot; value=&quot;调用父组件方法&quot; @click=&quot;sonClick&quot;&amp;gt;
      &amp;lt;h3&amp;gt;子组件 --- 父组件：{{parentmsg}}&amp;lt;/h3&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/template&amp;gt;

  &amp;lt;script&amp;gt;
    var vm = new Vue({
      el: &quot;#box&quot;,
      data: {
        msg: '父组件的msg'
      },
      methods: {
        show(data1, data2) {
          console.log(&quot;这是父组件的show方法&quot; + data1 + data2);
        }
      },
      components: {
        mycom: {
          template: &quot;#temp&quot;,
          // 对传递给子组件的数据进行声明，子组件才能使用 
          props: ['parentmsg'],
          methods: {
            sonClick() {
              // 调用父组件的show方法
              this.$emit(&quot;parentfunc&quot;, 111, 222);
            }
          }
        }
      }
    });
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;1、&lt;code&gt;@parentfunc=&quot;show&quot;&lt;/code&gt; 绑定父组件的show方法。&lt;/p&gt;
&lt;p&gt;2、&lt;code&gt;&amp;lt;input type=&quot;button&quot; value=&quot;调用父组件方法&quot; @click=&quot;sonClick&quot;&amp;gt;&lt;/code&gt; 点击按钮调用父组件的show方法&lt;/p&gt;
&lt;p&gt;3、在 子组件的 sonClick 方法中使用 &lt;code&gt;this.$emit(&quot;parentfunc&quot;);&lt;/code&gt; 来调用父组件的show方法&lt;/p&gt;
&lt;p&gt;4、父组件的show方法也可以传参，在调用的时候，实参从 this.$emit 的第二个参数开始传入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、如果 this.$emit 的第二个参数传的是子组件的data数据，那么父组件的方法就可以获得子组件的数据，这也是把子组件的数据传递给父组件的方式。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用-ref-获取dom和组件的引用&quot;&gt;3、使用 ref 获取DOM和组件的引用&lt;/h3&gt;
&lt;p&gt;我们知道Vue不推荐直接获取DOM元素，那么在Vue里面怎么获取DOM及组件元素呢？&lt;/p&gt;
&lt;p&gt;我们呢可以在元素上使用 &lt;code&gt;ref&lt;/code&gt; 属性来获取元素。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
  &amp;lt;script src=&quot;./lib/vue-2.4.0.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;box&quot;&amp;gt;
    &amp;lt;input type=&quot;button&quot; value=&quot;获取元素&quot; @click=&quot;getrefs&quot; ref=&quot;mybtn&quot;&amp;gt;
    &amp;lt;h3 ref=&quot;myh3&quot;&amp;gt;这是H3&amp;lt;/h3&amp;gt;
    &amp;lt;mycom ref=&quot;mycom&quot;&amp;gt;&amp;lt;/mycom&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;template id=&quot;tmp1&quot;&amp;gt;
  &amp;lt;/template&amp;gt;

  &amp;lt;script&amp;gt;
    // 定义组件
    Vue.component('mycom', {
      template: '#tmp1',
      data: function () {
        return {
          msg: '子组件的msg',
          pmsg: ''
        }
      },
      methods: {
        show(data) {
          console.log('调用子组件的show');
          this.pmsg = data;
          console.log(this.pmsg);
        },

      }
    });

    var vm = new Vue({
      el: &quot;#box&quot;,
      data: {
        parentmsg: '父组件的msg'
      },
      methods: {
        getrefs() {
          console.log(this.$refs.myh3);
          console.log(this.$refs.mycom.msg);
          this.$refs.mycom.show(this.parentmsg);
        }
      }
    });
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/754332/201809/754332-20180925152442266-38660785.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、ref 属性不仅可以获取DOM元素，也可以获取组件（无论全局还是私有组件）元素。&lt;/p&gt;
&lt;p&gt;2、获取到组件元素后，就可以获取组件元素的data数据和methods方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、获取到组件中的方法后，可以传入VM的data数据，就可以把VM的data数据传入组件中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/Daotin/pic/raw/master/fgx.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 25 Sep 2018 07:26:00 +0000</pubDate>
<dc:creator>Daotin</dc:creator>
<og:description>大家好，这里是「 从零开始学 Web 系列教程 」，并在下列地址同步更新...... github：https://github.com/Daotin/Web 微信公众号：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvonve/p/9699711.html</dc:identifier>
</item>
<item>
<title>《React Native 精解与实战》书籍连载「Android 平台与 React Native 混合开发」 - Parry</title>
<link>http://www.cnblogs.com/parry/p/react-native-android-mixture.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/parry/p/react-native-android-mixture.html</guid>
<description>&lt;p&gt;此文是我的出版书籍&lt;a href=&quot;http://rn.parryqiu.com/&quot;&gt;《React Native 精解与实战》&lt;/a&gt;连载分享，此书由机械工业出版社出版，书中详解了 React Native 框架底层原理、React Native 组件布局、组件与 API 的介绍与代码实战，以及 React Native 与 iOS、Android 平台的混合开发底层原理讲解与代码实战演示，精选了大量实例代码，方便读者快速学习。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;书籍配套视频教程「80 节实战课精通 React Native 开发」&lt;/em&gt;&lt;/strong&gt;：此视频课程建议配合书籍学习，书籍中原理性的东西讲解的比较清晰，而视频教程对于组件、API 等部分的代码实战开发讲解比较直观。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;书籍所有相关资料请访问：&lt;a href=&quot;http://rn.parryqiu.com/&quot;&gt;http://rn.parryqiu.com&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本章继续介绍 Android 平台下的混合开发原理以及实战，同时我们还可以深入理解React Native 与 Android 平台的通信机制。&lt;/p&gt;

&lt;p&gt;与 iOS 平台的混合开发一样，有时我们遇到 React Native 框架没有提供的原生 Android 平台 API 时，我们就需要自己来进行 React Native 平台与 Android 平台的混合开发。&lt;br/&gt;同样，混合开发还可以利用起来现有的 Android 原生平台的代码，并可以用于开发一些高性能、多线程的需求场景。&lt;/p&gt;
&lt;p&gt;React Native 框架的设计同样为 Android 原生平台提供了混合开发的可能性，这部分依然属于 React Native 开发高阶的部分，在开发前需要掌握了 Android 原生平台的开发语言及开发流程，不过不了解的话也可以学习一下，了解 React Native 平台与 Android 平台的通信原理。&lt;/p&gt;
&lt;p&gt;学习的方法我们还是在原理讲解的时候结合一个实际的小实例结合代码进行讲解，而不是仅仅空洞地讲解概念性的东西，便于大家理解。最后我们还将完成一个更加贴近实际的小实例，来加深 React Native 框架与 Android 平台混合开发的理解与运用。&lt;/p&gt;

&lt;p&gt;我们按照学习 iOS 平台混合开发的模式，这里我们继续结合一个小的实例来学习 React Native 平台与 Android 平台混合开发的原理与方法。&lt;/p&gt;
&lt;p&gt;Android 平台的混合开发主要包含如下几个主要步骤：&lt;br/&gt;1) 在 Android 项目中通过原生代码实现提供给 React Native 调用的原生功能；&lt;br/&gt;2) 在 Android 项目中将编写好的功能模块进行注册；&lt;br/&gt;3) 定义功能模块的 Android 包；&lt;br/&gt;4) 在 React Native 项目中通过 JavaScript 代码调用混合开发实现的 Android 平台原生功能。&lt;/p&gt;
&lt;p&gt;完整代码在本书配套源码的 12-02 文件夹。&lt;/p&gt;
&lt;h2 id=&quot;android-原生代码实现&quot;&gt;12.2.1 Android 原生代码实现&lt;/h2&gt;
&lt;p&gt;先通过 React Native CLI 初始化一个空项目，项目名称为 NativeAndroidModule，项目初始化的流程如图 12-1 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xqdjc.com1.z0.glb.clouddn.com/b_b2d134ca0b1aaa79a3007f6c80900751.png&quot; alt=&quot;截图&quot;/&gt;&lt;br/&gt;图 12-1 Android 混合开发项目初始化&lt;/p&gt;
&lt;p&gt;使用 Android 平台的开发工具 Android Studio 打开项目文件夹中的 android 文件夹，在 Android Studio 中选择导入此文件夹即可，如图 12-2 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xqdjc.com1.z0.glb.clouddn.com/b_12311df9103026f82258569800d3a80e.png&quot; alt=&quot;截图&quot;/&gt;&lt;br/&gt;图 12-2 Android Studio 导入项目&lt;/p&gt;
&lt;p&gt;注意，如果你是第一次打开此项目文件夹，Android Studio 会自动下载 Gradle 并使用 Gradle 进行项目的构建，此过程要确保你的网络环境没有任何阻碍并需要耐心等待加载完毕，加载过程如图 12-3 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xqdjc.com1.z0.glb.clouddn.com/b_b3e61d4f3f95dfce752397c5ea2782da.png&quot; alt=&quot;截图&quot;/&gt;&lt;br/&gt;图 12-3 Gradle 初始化并进行项目的构建&lt;/p&gt;
&lt;p&gt;项目使用 Android Studio 导入后打开如图 12-4 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xqdjc.com1.z0.glb.clouddn.com/b_ea5db093b1c0ae54353a09d862050807.png&quot; alt=&quot;截图&quot;/&gt;&lt;br/&gt;图 12-4 Android Studio 打开项目后的项目结构&lt;/p&gt;
&lt;p&gt;新建的 Android 原生平台的类需要继承于React Native 框架提供的父类 ReactContextBaseJavaModule，这里我们新建的类命名为 MyModule。&lt;/p&gt;
&lt;p&gt;如果没有导入 ReactContextBaseJavaModule 的包，Android Studio 会提示你进行包的引入，如图 12-5 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xqdjc.com1.z0.glb.clouddn.com/b_bd7a35b2120ecf0fffd445f955794bbf.png&quot; alt=&quot;截图&quot;/&gt;&lt;br/&gt;图 12-5 Android Studio 提示导入缺失的包&lt;/p&gt;
&lt;p&gt;新建后的文件代码如下所示。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;1. import com.facebook.react.bridge.ReactContextBaseJavaModule;  
2. 
3. public class MyModule extends ReactContextBaseJavaModule {  
4. 
5. }  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在继承了 ReactContextBaseJavaModule 父类后，需要实现方法 getName 返回模块名称，并在添加了类的构造函数，以及实现了调用 Android 原生 API 保持屏幕常亮并关闭常亮的两个方法 keepScreenAwake 和 removeScreenAwake。完整的 MyModule.java 代码如下。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;1.  package com.nativeandroidmodule;  
2.    
3.  import com.facebook.react.bridge.ReactApplicationContext;  
4.  import com.facebook.react.bridge.ReactContextBaseJavaModule;  
5.  import com.facebook.react.bridge.ReactMethod;  
6.    
7.  public class MyModule extends ReactContextBaseJavaModule {  
8.    
9.      ReactApplicationContext reactContext;  
10.   
11.     public MyModule(ReactApplicationContext reactContext) {  
12.         super(reactContext);  
13.         this.reactContext = reactContext;  
14.     }  
15.   
16.     @Override  
17.     public String getName() {  
18.         return &quot;MyModule&quot;;  
19.     }  
20.   
21.     @ReactMethod  
22.     public void keepScreenAwake() {  
23.         getCurrentActivity().runOnUiThread(new Runnable() {  
24.             @Override  
25.             public void run() {  
26.                 getCurrentActivity().getWindow().addFlags(  
27.                         android.view.WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);  
28.             }  
29.         });  
30.     }  
31.   
32.     @ReactMethod  
33.     public void removeScreenAwake() {  
34.         getCurrentActivity().runOnUiThread(new Runnable() {  
35.             @Override  
36.             public void run() {  
37.                 getCurrentActivity().getWindow().clearFlags(  
38.                         android.view.WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);  
39.             }  
40.         });  
41.     }  
42. }  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样，其他的 Android 平台的原生方法都可以按照此形式进行添加，添加后即可在 React Native 的 JavaScript 代码中调用。&lt;/p&gt;
&lt;h2 id=&quot;android-原生模块注册&quot;&gt;12.2.2 Android 原生模块注册&lt;/h2&gt;
&lt;p&gt;接下来我们需要创建一个类来实现 ReactPackage 的接口函数，实现原生模块的注册，这里我们命名此文件名为 MyModulePackage.java，并实现接口中的 createNativeModules 与createViewManagers 两个方法。这里我们使用函数 createNativeModules 来进行模块的注册，另一个函数 createViewManagers 进行空值返回即可。&lt;/p&gt;
&lt;p&gt;最终的完整代码如下，注意代码第 19 行的定义。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;1.  package com.nativeandroidmodule;  
2.    
3.  import com.facebook.react.ReactPackage;  
4.  import com.facebook.react.bridge.NativeModule;  
5.  import com.facebook.react.bridge.ReactApplicationContext;  
6.  import com.facebook.react.uimanager.ViewManager;  
7.    
8.  import java.util.ArrayList;  
9.  import java.util.Collections;  
10. import java.util.List;  
11.   
12. public class MyModulePackage implements ReactPackage {  
13.     @Override  
14.     public List&amp;lt;NativeModule&amp;gt; createNativeModules(  
15.             ReactApplicationContext reactContext) {  
16.         List&amp;lt;NativeModule&amp;gt; modules = new ArrayList&amp;lt;&amp;gt;();  
17.   
18.         modules.add(new  
19.                 MyModule(reactContext));  
20.   
21.         return modules;  
22.     }  
23.   
24.     @Override  
25.     public List&amp;lt;ViewManager&amp;gt; createViewManagers(ReactApplicationContext  
26.                                                         reactContext) {  
27.         return Collections.emptyList();  
28.     }  
29. }  &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;android-包定义&quot;&gt;12.2.3 Android 包定义&lt;/h2&gt;
&lt;p&gt;在项目中的 MainApplication.java 文件中，需要包含上我们自己开发的原生包，添加在 getPackages 函数中即可。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;1.  package com.nativeandroidmodule;  
2.    
3.  import android.app.Application;  
4.    
5.  import com.facebook.react.ReactApplication;  
6.  import com.facebook.react.ReactNativeHost;  
7.  import com.facebook.react.ReactPackage;  
8.  import com.facebook.react.shell.MainReactPackage;  
9.  import com.facebook.soloader.SoLoader;  
10.   
11. import java.util.Arrays;  
12. import java.util.List;  
13.   
14. public class MainApplication extends Application implements ReactApplication {  
15.   
16.   private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) {  
17.     @Override  
18.     public boolean getUseDeveloperSupport() {  
19.       return BuildConfig.DEBUG;  
20.     }  
21.   
22.     @Override  
23.     protected List&amp;lt;ReactPackage&amp;gt; getPackages() {  
24.       return Arrays.&amp;lt;ReactPackage&amp;gt;asList(  
25.           new MainReactPackage(),  
26.               //包含上我们自定义的原生组件包  
27.               new MyModulePackage()  
28.       );  
29.     }  
30.   
31.     @Override  
32.     protected String getJSMainModuleName() {  
33.       return &quot;index&quot;;  
34.     }  
35.   };  
36.   
37.   @Override  
38.   public ReactNativeHost getReactNativeHost() {  
39.     return mReactNativeHost;  
40.   }  
41.   
42.   @Override  
43.   public void onCreate() {  
44.     super.onCreate();  
45.     SoLoader.init(this, /* native exopackage */ false);  
46.   }  
47. }  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;包含的方式在代码的第 27 行，Android 原生端开发完毕后的文件结构如图 12-6 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xqdjc.com1.z0.glb.clouddn.com/b_1e74e0f299b7eb52895db59bdab3fceb.png&quot; alt=&quot;截图&quot;/&gt;&lt;br/&gt;图 12-6 Android 端开发完毕文件结构&lt;/p&gt;
</description>
<pubDate>Tue, 25 Sep 2018 07:19:00 +0000</pubDate>
<dc:creator>Parry</dc:creator>
<og:description>此文是我的出版书籍[《React Native 精解与实战》](http://rn.parryqiu.com/)连载分享，此书由机械工业出版社出版，书中详解了 React Native 框架底层原理、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/parry/p/react-native-android-mixture.html</dc:identifier>
</item>
<item>
<title>从壹开始前后端分离 [ vue + .netcore 补充教程 ] 二九║ Nuxt实战：异步实现数据双端渲染 - 老张的哲学</title>
<link>http://www.cnblogs.com/laozhang-is-phi/p/9697450.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laozhang-is-phi/p/9697450.html</guid>
<description>&lt;blockquote readability=&quot;7.8737097753491&quot;&gt;
&lt;p&gt;哈喽大家好！又是元气满满的周~~~二哈哈，不知道大家中秋节过的如何，马上又是国庆节了，博主我将通过三天的时间，给大家把项目二的数据添上（&lt;span&gt;这里强调下，填充数据不是最重要的，最重要的是要配合着让大家明白 nuxt.js 是如何一步步实现服务端渲染的&lt;/span&gt;），虽说是基于 Nuxt 的，但是数据源还是我们的老数据，就是 .net core api 的数据，和上一个项目中使用的是一样的，这里要说下，有的小伙伴说想要我的数据，这里暂时说抱歉，因为里边有一些我的私人的记录，还有一些网站密码啥的，我自己懒得一条一条的删除了，这里就不放出来了，多多包涵，不过接口地址可以随便使用&lt;a href=&quot;http://123.206.33.109:8081&quot; target=&quot;_blank&quot;&gt;http://123.206.33.109:8081&lt;/a&gt;，有源代码和数据库表结构，相信大家还是可以搞定滴，因为是三天，所以今天我们就会把首页给处理出来，这里有俩个点，第一，为什么是三天呢，因为博主三天后要放假了哈哈（ &lt;span&gt;这里要给大家说下心得，坚持学习和坚持写博客是完全不同的时间量，每天我光写博客的时间最少三个小时，加上工作的九个小时，每天我至少需要12个小时，所以如果想快速学习，建议还是要好好的写博客 &lt;/span&gt;），第二，数据获取和之前的 vue 有点儿差别，虽然都是基于 axios ，但是 nuxt 框架做了一定的封装，而且还是异步的，ASync/Await ，大家看我今天的标题也能看的出来，至于为什么会是异步的呢，先留个神秘，大家看完今天的讲解应该就知道是为什么了~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;书接上文，上周咱们说到了nuxt 的运行原理《&lt;a id=&quot;post_title_link_9687504&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9687504.html&quot;&gt;二八║ Nuxt 基础：面向源码研究Nuxt.js&lt;/a&gt;》，不知道大家是否看了呢，主要通过源码的分析，来重点说明 Nuxt 是如何实现服务端渲染的，个人感觉写的比较羞涩难懂，我也是在慢慢的润色，尽量修改成通俗易懂的给大家展示，写成人话。这里我要说句题外话，大家有时间的话，还是应该把后端的注意力拿出来一点儿点儿放到前端了，以前我也是一个老后端，一直想着各种持久化ORM哪个更帅，各种框架哪个性价比更高，但是一直也技术平平，反而忽略了这两年的前端发展，经过这一个月的学习，我发现前端技术竟然发展如此之快，竟超出我的想象，有点儿追赶挑战后端的意思了，多语言化的发展，更有助于一个程序员的发展（ 这个欢迎来喷，只会一种语言的话，嗯~ 会有局限性┑(￣Д ￣)┍ ），哈哈这个扯的有点儿远了。&lt;/p&gt;
&lt;p&gt;对于昨天的文章，总结来说，nuxt 的核心就是在 vue.js 的基础上，封装了双端渲染模式（服务端和客户端），结合页面html片段缓存，来实现 SSR ，最终解决首屏快速渲染和 SEO 的问题，核心就是在如何实现双端渲染上，大家之前的教程中，对 Vue 的 SPA 很熟练了，这三天咱们就慢慢的研究下，如何实现双端渲染的，这个也就是我讲 nuxt 的核心 —— 渲染。&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180925113909577-1008484905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;1、nuxt.config.js 文件&lt;/h3&gt;
&lt;p&gt;项目的核心文件，作为一个配置文件，对全局配置起到一个十分重要的作用，像我们的 webconfig 一样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;86&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这些配置在你的项目里可能不一定都有，但是我都会提到&lt;/span&gt;
module.exports =&lt;span&gt; {
  cache: {},
  css: [
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载一个 node.js 模块
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  'hover.css/css/hover-min.css',
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同样加载一个 node.js 模块，不过我们定义所需的预处理器
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  { src: 'bulma', lang: 'sass' },
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 项目中的 CSS 文件
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  '~assets/css/main.css',
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 项目中的 Sass 文件
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  { src: '~assets/css/main.scss', lang: 'scss' } &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定 scss 而非 sass&lt;/span&gt;
&lt;span&gt;  ],
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认 true&lt;/span&gt;
  dev: process.env.NODE_ENV !== &lt;span&gt;'&lt;/span&gt;&lt;span&gt;production&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是生产环境

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建环境变量&lt;/span&gt;
&lt;span&gt;  env: {},

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置 Nuxt.js 应用生成静态站点的具体方式。&lt;/span&gt;
&lt;span&gt;  genetate: {
    dir: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
    minify: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
    routes: [],
  },
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    * vue-meta
    * Headers of the page
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  head: {
    title: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;老张的哲学&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    meta: [
      { charset: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; },
      { name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;viewport&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, content: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;width=device-width, initial-scale=1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; },
      { hid: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, name: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, content: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Nuxt.js project&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }
    ],
    link: [
      { rel: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;icon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, type: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;image/x-icon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, href: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/favicon.ico&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }
    ]
  },
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
  ** Customize the progress bar color
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  loading: { color: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#3B8070&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; },
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
  ** Build configuration
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  build: {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    ** Run ESLint on save
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    extend (config, { isDev, isClient }) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDev &amp;amp;&amp;amp;&lt;span&gt; isClient) {
        config.module.rules.push({
          enforce: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pre&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
          test: &lt;/span&gt;/\.(js|vue)$/&lt;span&gt;,
          loader: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;eslint-loader&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
          exclude: &lt;/span&gt;/(node_modules)/&lt;span&gt;
        })
      }
    }
  },
  performance: {
    gzip: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    prefetch: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入 Vue.use 的插件&lt;/span&gt;
&lt;span&gt;  plugins: [],
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认当前路径&lt;/span&gt;
&lt;span&gt;  rootDir: process.cwd(),
  router: {
    &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
    mode: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;history&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    linkActiveClass: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nuxt-link-active&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    scrollBehavior: (to, &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;, savedPosition) =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; savedPosition 只有在 popstate 导航（如按浏览器的返回按钮）时可以获取。&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (savedPosition) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; savedPosition
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        let position &lt;/span&gt;=&lt;span&gt; {}
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 目标页面子组件少于两个&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (to.matched.length &amp;lt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 滚动至页面顶部&lt;/span&gt;
          position = { x: &lt;span&gt;0&lt;/span&gt;, y: &lt;span&gt;0&lt;/span&gt;&lt;span&gt; }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (to.matched.some((r) =&amp;gt; r.components.&lt;span&gt;default&lt;/span&gt;&lt;span&gt;.options.scrollToTop)) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果目标页面子组件中存在配置了scrollToTop为true&lt;/span&gt;
          position = { x: &lt;span&gt;0&lt;/span&gt;, y: &lt;span&gt;0&lt;/span&gt;&lt;span&gt; }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果目标页面的url有锚点,  则滚动至锚点所在的位置&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (to.hash) {
          position &lt;/span&gt;=&lt;span&gt; { selector: to.hash }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; position
      }
    },
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;
    middleware: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;user-agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扩展路由&lt;/span&gt;
    extendRoutes: () =&amp;gt;&lt;span&gt; {},

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认同 rootDir&lt;/span&gt;
    srcDir: &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.rootDir,

    transition: {
      name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
      mode: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;out-in&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    },
    watchers: {
      chokidar: {}, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文件监控&lt;/span&gt;
&lt;span&gt;      webpack: {
        aggregateTimeout: &lt;/span&gt;&lt;span&gt;300&lt;/span&gt;&lt;span&gt;,
        poll: &lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;
      }
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2. 视图模板&lt;/h3&gt;
&lt;p&gt;默认的 html 模版: 应用根目录下的 app.html 文件, 如果你没有找到这个文件, 则采用默认的模版，当然你也可以自己新增，配置，&lt;/p&gt;
&lt;p&gt;这个更像是我们之前的 index.html 页面，只不过把 &amp;lt;div id='app'&amp;gt;&amp;lt;/div&amp;gt; 挂载，变成了填充的方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html {{ HTML_ATTRS }}&amp;gt;
  &amp;lt;head&amp;gt;&lt;span&gt;
    {{ HEAD }}
  &lt;/span&gt;&amp;lt;/head&amp;gt;
  &amp;lt;body {{ BODY_ATTRS }}&amp;gt;&lt;span&gt;
    {{ APP }}
  &lt;/span&gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3. layouts 布局目录&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180925001404064-101969568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以修改该目录下的 default.vue 来修改默认布局 ， 这个就是类似于我们之前的 app.vue 页面，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layout-default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;cl-header&amp;gt;&amp;lt;/cl-header&amp;gt;
    &amp;lt;nuxt &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layout-main&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
    &amp;lt;cl-footer&amp;gt;&amp;lt;/cl-footer&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layout-bg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中 &amp;lt;nuxt/&amp;gt; 是必需的，页面的主体内容会显示在这里 （类似于根节点的 &amp;lt;router-view/&amp;gt;）&lt;/p&gt;
&lt;p&gt;此外还可以在目录下&lt;a href=&quot;http://www.php.cn/php/php-tp-append.html&quot; target=&quot;_blank&quot;&gt;新增&lt;/a&gt; error.vue 作为错误页面，具体的写法可以参考官方文档&lt;/p&gt;

&lt;h3&gt;4. pages 页面 路由&lt;/h3&gt;
&lt;p&gt;路由, &lt;strong&gt;约定大于配置&lt;/strong&gt;, 支持动态, 嵌套, 动态嵌套路由, 过渡效果和中间件，通过文件夹目录名称, 组件名称, 生成路由配置，默认的 transitionName 为 page, 可在 assets 中添加全局的过渡效果，&lt;/p&gt;
&lt;p&gt;在匹配页面之前执行;&lt;/p&gt;
&lt;p&gt;nuxt.config.js --&amp;gt; 执行middleware --&amp;gt; 匹配布局 --&amp;gt; 匹配页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180925001602280-1589979981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;用于存放页面级别的组件，nuxt 会根据该目录下的页面结构生成路由&lt;/p&gt;
&lt;p&gt;比如上图中的页面结构，会生成这样的路由配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; _7b01ffaa = () =&amp;gt; import(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;..\\pages\\post\\index.vue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; webpackChunkName: &quot;pages_post_index&quot; &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;).then(m =&amp;gt; m.&lt;span&gt;default&lt;/span&gt; ||&lt;span&gt; m)
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; _2b7fe492 = () =&amp;gt; import(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;..\\pages\\post\\_id.vue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; webpackChunkName: &quot;pages_post__id&quot; &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;).then(m =&amp;gt; m.&lt;span&gt;default&lt;/span&gt; ||&lt;span&gt; m)
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; _4f14dfca = () =&amp;gt; import(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;..\\pages\\index.vue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; webpackChunkName: &quot;pages_index&quot; &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;).then(m =&amp;gt; m.&lt;span&gt;default&lt;/span&gt; ||&lt;span&gt; m)

export function createRouter () {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Router({
    mode: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;history&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    linkActiveClass: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nuxt-link-active&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    linkExactActiveClass: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nuxt-link-exact-active&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    scrollBehavior,
    routes: [
        {
            path: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            component: _7b01ffaa,
            name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        },
        {
            path: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/post/:id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            component: _2b7fe492,
            name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post-id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        },
        {
            path: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            component: _4f14dfca,
            name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    ],
    
    
    fallback: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;5、使用插件 plugins 文件夹&lt;/h3&gt;
&lt;p&gt;如果项目中还需要引入其他的第三方插件，可以直接在页面中引入，这样在打包的时候，会将插件打包到页面对应的 js 里面，但要是别的页面也引入了同样的插件，就会重复打包。如果没有需要分页打包的需求，这时候可以配置 plugins，然后在根目录的 nuxt.config.js 中添加配置项 build.vendor 和 plugins，这里的 plugins 属性用来配置 vue.js 插件，也就是 &lt;strong&gt;可以用 Vue.user() 方法&lt;/strong&gt; 的插件&lt;/p&gt;
&lt;p&gt;默认只需要 src 属性，另外还可以配置 ssr: false，让该文件只在客户端被打包引入，如果是像 axios 这种第三方 （不能 use） 插件，只需要在 plugins 目录下创建 axios.js，然后在 build.vendor 中添加配置 （不需要配置 plugins）&lt;/p&gt;
&lt;p&gt;这样在打包的时候，就会把 axios 打包到 vendor.js 中。&lt;/p&gt;


&lt;h3&gt; 1、在 static 文件中，新增样式 vue-blog-sq.css 文件&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;提醒，这里的文件，不会被打包，所以会在页面中呈现原有格式，如果想每次都被打包压缩，需要写到 assets 资源文件夹中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180925144950363-1889409577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180925145029025-2130653477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2、在 components 中，新建 layout 文件夹，然后新增页头页脚 组件&lt;/h3&gt;
&lt;p&gt;这个很简单，就是普通的 *.vue 组件写法，大家可以自行下载浏览&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180925123230110-1713968592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3、在 layouts 页面布局文件夹中，新增 blog.vue 布局&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;提醒：以后也可以单给用户增加布局，比如 user.vue &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layout-default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;cl-header&amp;gt;&amp;lt;/cl-header&amp;gt;
    &amp;lt;nuxt &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layout-main&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;&lt;span&gt;//注意，&amp;lt;nuxt /&amp;gt;，必须有，类似一个 &amp;lt;router-view/&amp;gt;&lt;/span&gt;
    &amp;lt;cl-footer&amp;gt;&amp;lt;/cl-footer&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
  import clHeader &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/components/layout/header.vue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
  import clFooter &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/components/layout/footer.vue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
  export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    data () {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {};
    },
    mounted () {&lt;/span&gt;
&lt;span&gt;    },
    components: {
      clHeader,
      clFooter
    }
  };
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很简单的一个布局入口，是不是很像我们之前的 App.vue 中的 路由容器 —— &amp;lt;router-view /&amp;gt; ，但是又比其更丰富，因为我们之前的 app.vue 只能有一个入口，但是 nuxt 可以提供多个自定义 模板layouts，更方便。&lt;/p&gt;

&lt;h3&gt; 4、根目录新增 config 文件夹，添加 index.js ，作为我们以后的配置文件，类似 .net core api 中的 appsetting.json 文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; config =&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开发环境配置，开发的时候&lt;/span&gt;
&lt;span&gt;    development: {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;api: &quot;&lt;/span&gt;&lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;:58427/api/&quot;,&lt;/span&gt;
        api: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://123.206.33.109:8081/api/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生产环境配置，部署的时候&lt;/span&gt;
&lt;span&gt;    production: {
        api: &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    }
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前环境变量,是 production或者development&lt;/span&gt;
module.exports = config[process.env.NODE_ENV];
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;5、在 plugins 插件中，新增 server_site 文件夹，然后添加 http.js 和 index.js&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、为什么要使用插件？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们可以在应用中使用第三方模块，一个典型的例子是在客户端和服务端使用 &lt;a href=&quot;https://github.com/mzabriskie/axios&quot;&gt;axios&lt;/a&gt; 做 HTTP 请求。&lt;/p&gt;
&lt;p&gt;首先我们需要安装 npm 包：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm install --save axios
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在页面内可以这样使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;h1&amp;gt;{{ title }}&amp;lt;/h1&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
import axios &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;axios&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;async&lt;/span&gt; asyncData ({ &lt;span&gt;params&lt;/span&gt;&lt;span&gt; }) {
    let { data } &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt; axios.&lt;span&gt;get&lt;/span&gt;(`https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;my-api/posts/${params.id}`)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; { title: data.title }
  }
}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有一个值得注意的问题是，如果我们在另外一个页面内也引用了 &lt;code&gt;axios&lt;/code&gt;，那么在应用打包发布的时候 &lt;code&gt;axios&lt;/code&gt; 会被打包两次，而实际上我们只需要打包一次。这个问题可以通过在 &lt;code&gt;nuxt.config.js&lt;/code&gt; 里面配置 &lt;code&gt;build.vendor&lt;/code&gt; 来解决：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
  build: {
    vendor: [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;axios&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过上面的配置后，我们可以在任何页面里面引入 &lt;code&gt;axios&lt;/code&gt; 而不用担心它会被重复打包。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、为什么要分 server_site服务端 与 client_site客户端 插件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有些插件可能只是在浏览器里使用，所以你可以用 &lt;code&gt;ssr: false&lt;/code&gt; 变量来配置插件只从客户端还是服务端运行。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;nuxt.config.js:

module.exports &lt;/span&gt;=&lt;span&gt; {
  plugins: [
    { src: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;~/plugins/vue-notifications&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, ssr: &lt;span&gt;false&lt;/span&gt; }&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置ssr 为false&lt;/span&gt;
&lt;span&gt;  ]
}
plugins&lt;/span&gt;/vue-notifications.js:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个插件&lt;/span&gt;
&lt;span&gt;
import Vue &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;vue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import VueNotifications &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;vue-notifications&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

Vue.use(VueNotifications)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样地，如果有些脚本库你只想在服务端使用，在 Webpack 打包 &lt;code&gt;server.bundle.js&lt;/code&gt; 文件的时候会将 &lt;code&gt;process.server&lt;/code&gt; 变量设置成 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、配置服务端 http.js 和 index.js 的内容&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180925132947229-1996283161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; http.js 封装 axios，防止多处打包&lt;/span&gt;
import Axios &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;axios&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
import config &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/config&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入配置文件

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例化 axios()&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; http =&lt;span&gt; Axios.create({
    baseURL: config.api,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根url&lt;/span&gt;
    timeout: &lt;span&gt;8000&lt;/span&gt;&lt;span&gt;,
    validateStatus: function (status) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; status &amp;gt;= &lt;span&gt;200&lt;/span&gt;&lt;span&gt;;
    }
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义错误异常方法&lt;/span&gt;
&lt;span&gt;function LogicError (message, code, data) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.message =&lt;span&gt; message;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.code =&lt;span&gt; code;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogicError&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}

LogicError.prototype &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error();
LogicError.prototype.constructor &lt;/span&gt;=&lt;span&gt; LogicError;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; http 的request 请求&lt;/span&gt;
http.interceptors.request.use((data, headers) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data;
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; http 的response 命令，失败的调用上边的失败异常方法&lt;/span&gt;
http.interceptors.response.use(response =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; data =&lt;span&gt; response.data;
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (data.success) {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data.data;
        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LogicError(data.msg);
    }
}, err &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LogicError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;网络请求错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
});

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; http;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出http&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义 http 插件，是一个全局变量&lt;/span&gt;
import Vue &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
import http &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./http.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入http封装的axios&lt;/span&gt;

&lt;span&gt;const&lt;/span&gt; install = function (VueClass, opts =&lt;span&gt; {}) {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; http method&lt;/span&gt;
    VueClass.http =&lt;span&gt; http;
    VueClass.prototype.$http &lt;/span&gt;=&lt;span&gt; http;
};
Vue.use(install);&lt;span&gt;// 在vue 中，使用该插件&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;6、在 nuxt.config.js 中引用我们的服务端插件&lt;/h3&gt;
&lt;p&gt;这样添加以后，我们就可以全局使用请求命令了，打包的时候，也只会打包一个&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;提示：1、记得需要按照提示安装 axios npm install --save axios &lt;/p&gt;
&lt;p&gt;           2、引入的组件库必须配置 plugins, 但是有的组件库不支持 ssr.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180925133757439-1299337124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;7、设计修改 pages 下的 index.vue 页面，异步获取接口数据&lt;/h3&gt;
&lt;blockquote readability=&quot;20.51048951049&quot;&gt;
&lt;p&gt; 提示：这个就是文章开头提到的问题&lt;/p&gt;
&lt;p&gt;1、为什么要异步？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;asyncData&lt;/code&gt;方法会在组件（&lt;strong&gt;限于页面组件，也就是pages 文件夹下的vue文件 &lt;/strong&gt;）每次加载之前被调用。它可以在服务端或路由更新之前被调用。 在这个方法被调用的时候，第一个参数被设定为当前页面的&lt;a href=&quot;https://zh.nuxtjs.org/api#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AF%B9%E8%B1%A1&quot;&gt;上下文对象&lt;/a&gt;，你可以利用 &lt;code&gt;asyncData&lt;/code&gt;方法来获取数据，Nuxt.js 会将 &lt;code&gt;asyncData&lt;/code&gt; 返回的数据融合组件 &lt;code&gt;data&lt;/code&gt; 方法返回的数据一并返回给当前组件。&lt;/p&gt;
&lt;p&gt;注意：由于&lt;code&gt;asyncData&lt;/code&gt;方法是在组件 初始化 前被调用的，所以在方法内是没有办法通过 &lt;code&gt;this&lt;/code&gt; 来引用组件的实例对象。&lt;/p&gt;
&lt;p&gt;Nuxt.js 提供了几种不同的方法来使用 &lt;code&gt;asyncData&lt;/code&gt; 方法，你可以选择自己熟悉的一种来用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;返回一个 &lt;code&gt;Promise&lt;/code&gt;, nuxt.js会等待该&lt;code&gt;Promise&lt;/code&gt;被解析之后才会设置组件的数据，从而渲染组件.&lt;/li&gt;
&lt;li&gt;使用 &lt;a href=&quot;https://github.com/lukehoban/ecmascript-asyncawait&quot;&gt;async 或 await&lt;/a&gt; （推荐使用）&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;返回-promise&quot;&gt;返回 Promise&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  asyncData ({ &lt;/span&gt;&lt;span&gt;params&lt;/span&gt;&lt;span&gt; }) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; axios.&lt;span&gt;get&lt;/span&gt;(`https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;my-api/posts/${params.id}`)&lt;/span&gt;
    .then((res) =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; { title: res.data.title }
    })
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;使用-async或await&quot;&gt;使用 async或await&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;async&lt;/span&gt; asyncData ({ &lt;span&gt;params&lt;/span&gt;&lt;span&gt; }) {
    let { data } &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt; axios.&lt;span&gt;get&lt;/span&gt;(`https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;my-api/posts/${params.id}`)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; { title: data.title }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- index.vue 页面 --&amp;gt;&lt;br/&gt;&amp;lt;template&amp;gt;
  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;u-marginBottom40 js-collectionStream&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;streamItem streamItem--section js-streamItem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
      &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;u-clearfix u-maxWidth1000 u-marginAuto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;row u-marginTop30 u-marginBottom20 u-sm-marginLeft20 u-sm-marginRight20 u-xs-marginTop0 u-xs-marginRight0 u-xs-marginLeft0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

          &amp;lt;div v-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post in blogs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; :key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post.bID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;postArticle postArticle--short is-withAccentColors&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
          &amp;lt;!--......--&amp;gt;
          &amp;lt;/div&amp;gt;


        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;

&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
  import Vue &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入 vue 实例，获取全局变量&lt;/span&gt;
  export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    layout: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;span&gt;//这个就是我们自定义的模板布局
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; asyncData (ctx) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; asyncData() 异步获取数据方法&lt;/span&gt;
      let blogs =&lt;span&gt; [];
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        console.log(1&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; blogData = &lt;span&gt;await&lt;/span&gt; Vue.http.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Blog?page=1&amp;amp;bcategory=技术博文&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt;
        console.log(blogData);
        blogs &lt;/span&gt;=&lt;span&gt; blogData;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
          blogs: blogs,
        };
      } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ctx.error({ statusCode: 500, message: &quot;出错啦&quot; });//自定义错误页面&lt;/span&gt;
&lt;span&gt;      }
    },
    data () {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {};
    },
    head () {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;针对每一个页面，进行封装 head&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        meta: [
          {
            name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            content: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;老张的哲学是个人博客，利用NUXT.js的服务端渲染方案&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
          }
        ]
      };
    },
    mounted () {},
    filters: {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;过滤器，用来过滤时间字符串&lt;/span&gt;
&lt;span&gt;      timeFormat: function (time) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!time) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; time;
      }
    },
    methods: {},
    components: {
    }
  };
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;8、启动项目，就能看到我们的数据了&lt;/h3&gt;
&lt;p&gt;提示：如果报 less 错误，请安装 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;p&gt;　　npm install less less-loader&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180925145252087-8473380.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;这里先给大家抛出几个问题：&lt;/p&gt;
&lt;p&gt;1、我们通过第一次编译的时候，生成 .nuxt 临时文件夹，是服务端渲染还是客户端渲染？&lt;/p&gt;

&lt;p&gt;2、我们打开浏览器的 调试工具，发现每次修改，会都生成一些提示，当然这都是 webpack 的热加载，那这些又是什么含义呢？&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180925074815519-272795072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、既然是服务端和客户端一起渲染，我们的 页面路由 是如何匹配到的呢？&lt;/p&gt;
&lt;p&gt;4、打开我们的页面 network 网络请求，发现有很多不知道的文件，都是怎样生成的呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180925153051454-1695631588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其实这几个问题我们在之前的都通过文字的形式说过，因为时间的问题，今天暂时就说到这里，明天咱们再继续深入研究这个问题，顺便填充下详情页的数据。&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;https://github.com/anjoy8/Blog.Vue.Nuxt&quot; target=&quot;_blank&quot;&gt;https://github.com/anjoy8/Blog.Vue.Nuxt&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 25 Sep 2018 07:03:00 +0000</pubDate>
<dc:creator>老张的哲学</dc:creator>
<og:description>回顾 哈喽大家好！又是元气满满的周~~~二哈哈，不知道大家中秋节过的如何，马上又是国庆节了，博主我将通过三天的时间，给大家把项目二的数据添上（这里强调下，填充数据不是最重要的，最重要的是要配合着让大家</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laozhang-is-phi/p/9697450.html</dc:identifier>
</item>
<item>
<title>并发包下常见的同步工具类详解(CountDownLatch,CyclicBarrier,Semaphore) - takumiCX</title>
<link>http://www.cnblogs.com/takumicx/p/9698867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/takumicx/p/9698867.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;1. 前言&lt;/h2&gt;
&lt;p&gt;在实际开发中,碰上CPU密集且执行时间非常耗时的任务,通常我们会选择将该任务进行分割,以多线程方式同时执行若干个子任务,等这些子任务都执行完后再将所得的结果进行合并。这正是著名的map-reduce思想,不过map-reduce通常被用在分布式计算的语境下,这里举这个例子只是为了说明对多线程并发执行流程进行控制的重要性,比如某些线程必须等其他线程执行完后才能开始它的工作。使用jdk中的内置锁或者重入锁配合等待通知机制可以实现这个需求,但是会比较麻烦。因为不管是内置还是重入锁,它们关注的重点在于如何协调多线程对共享资源的访问,而不是协调特定线程的执行次序,完成复杂的并发流程控制。好在JDK在并发包下提供了CountDownLatch,CyclicBarrier,Semaphore等并发工具,可以让我们站在更高的角度思考并解决这个问题。&lt;/p&gt;
&lt;h2 id=&quot;闭锁countdownlatch&quot;&gt;2. 闭锁CountDownLatch&lt;/h2&gt;
&lt;h3 id=&quot;countdownlatch功能简介&quot;&gt;2.1 CountDownLatch功能简介&lt;/h3&gt;
&lt;p&gt;CountDownLatch通常称之为闭锁。它可以使一个或一批线程在闭锁上等待,等到其他线程执行完相应操作后,闭锁打开,这些等待的线程才可以继续执行。确切的说,闭锁在内部维护了一个倒计数器。通过该计数器的值来决定闭锁的状态,从而决定是否允许等待的线程继续执行。该计数器的初始值由用户在创建闭锁对象时通过传入的构造参数决定,如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Constructs a {@code CountDownLatch} initialized with the given count.
 *
 * @param count the number of times {@link #countDown} must be invoked
 *        before threads can pass through {@link #await}
 * @throws IllegalArgumentException if {@code count} is negative
 */
public CountDownLatch(int count) {
    if (count &amp;lt; 0) throw new IllegalArgumentException(&quot;count &amp;lt; 0&quot;);
    this.sync = new Sync(count);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认计数器初始值不能小于0,否则将抛出异常。&lt;/p&gt;
&lt;p&gt;当计数器的值大于0时,该闭锁处于关闭状态,调用闭锁的&lt;code&gt;await()&lt;/code&gt;方法将导致当前线程在闭锁上等待。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void await() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是我们可以通过调用闭锁的&lt;code&gt;countDown()&lt;/code&gt;方法来使闭锁的计数值减少&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void countDown() {
    sync.releaseShared(1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每调用一次&lt;code&gt;countDown()&lt;/code&gt;方法都会使闭锁的计数值减少1,所以闭锁的计数器准确来说是个倒计数器。当计数值减少到0时,阻塞在闭锁上的线程将被唤醒从而继续执行。下面以一个类似map-reduce的例子来对CountDownLatch的用法做讲解。&lt;/p&gt;
&lt;h3 id=&quot;使用countdownlatch&quot;&gt;2.2 使用CountDownLatch&lt;/h3&gt;
&lt;p&gt;为了计算一个CPU密集型的大任务,将该任务分割成10个子任务,交由开启的10个子线程去执行。当所有子任务执行完毕后,主线程再执行后续的工作。任务的执行时间以线程休眠进行模拟,整个流程以日志方式进行记录。完整代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * @author: takumiCX
 * @create: 2018-09-17
 **/
class CountDownLatchTest {

    static CountDownLatch countDownLatch;

    public static void main(String[] args) throws InterruptedException {

        int count=10;
        //初始化计数器值为10
        countDownLatch=new CountDownLatch(count);
        //开启10个子线程执行子任务
        for(int i=0;i&amp;lt;count;i++){
            Thread thread = new Thread(new CountDownThread(countDownLatch,i));
            thread.start();
        }
        //主线程等待,直到所有子任务完成
        countDownLatch.await();
        //模拟主线程执行后续工作
        TimeUnit.SECONDS.sleep(1);
        System.out.println(&quot;任务执行完毕!&quot;);

    }



    private static class CountDownThread implements Runnable{
        CountDownLatch countDownLatch;
        //子任务序号
        int taskNum;
        public CountDownThread(CountDownLatch countDownLatch, int taskNum) {
            this.countDownLatch = countDownLatch;
            this.taskNum = taskNum;
        }
        @Override
        public void run() {
            try {
                //模拟子任务的执行
                TimeUnit.MILLISECONDS.sleep(30);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //任务执行完毕,则调用countDown方法使计数器值减少1
            countDownLatch.countDown();
            System.out.println(&quot;子任务：&quot;+taskNum+&quot; 执行完毕!&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下所示&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201809/1422237-20180925141726851-1089499030.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到主线程在所有子任务执行完前必须在闭锁上等待。当最后一个子任务完成后,它将被唤醒,从而可以继续之后的工作。&lt;/p&gt;
&lt;h3 id=&quot;countdownlatch原理浅析&quot;&gt;2.3 CountDownLatch原理浅析&lt;/h3&gt;
&lt;p&gt;CountDownLatch底层也是通过AQS实现的。和ReentrentLock以独占的方式获取和释放同步状态不同,CountDownLatch是以共享的方式获取和释放同步状态的。独占式和共享式的区别主要有以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.独占式一次只允许一个线程获取同步状态,而共享式一次允许多个线程同时获取同步状态。&lt;/li&gt;
&lt;li&gt;2.当在同步队列等待的线程被唤醒然后成功获取同步状态时,它还必须唤醒后续结点中的线程,并将这个过程传递下去,使得多个线程可以同时获取到同步状态。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同步状态依旧使用AQS中的state值进行表示,在CountDownLatch的语境下表示计数器的值,且只有在state=0时线程才能成功获取到同步状态,尽管有些奇怪,不过考虑到CountDownLatch中的计数器是个倒计数器,这么设定也并非不可理解。为了更好的理解CountDownLatch的源码,从释放同步状态的方法&lt;code&gt;countDown()&lt;/code&gt;开始讲起&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void countDown() {
    sync.releaseShared(1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正确找到sync的实现类后跟进源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) { //尝试在共享模式下释放同步状态
        doReleaseShared();
        return true;
    }
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;tryReleaseShared()尝试在共享模式下释放同步状态,该方法是在AQS中定义的钩子方法,必须由AQS的实现类自己实现,方法内容如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected boolean tryReleaseShared(int releases) {
    // Decrement count; signal when transition to zero
    for (;;) {
        int c = getState(); //获取同步状态值
        if (c == 0)
            return false;
        int nextc = c-1;
        if (compareAndSetState(c, nextc)) //以CAS方式更新同步状态值
            return nextc == 0;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用死循环+CAS方式将计数值state减少1。仅当更新操作成功且state值被更新为0时返回true,表示在共享模式下释放同步状态成功,接着便会继续执行doReleaseShared()方法,方法内容如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void doReleaseShared() {
    /*
     * Ensure that a release propagates, even if there are other
     * in-progress acquires/releases.  This proceeds in the usual
     * way of trying to unparkSuccessor of head if it needs
     * signal. But if it does not, status is set to PROPAGATE to
     * ensure that upon release, propagation continues.
     * Additionally, we must loop in case a new node is added
     * while we are doing this. Also, unlike other uses of
     * unparkSuccessor, we need to know if CAS to reset status
     * fails, if so rechecking.
     */
    for (;;) {
        Node h = head;
        if (h != null &amp;amp;&amp;amp; h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                unparkSuccessor(h); //唤醒后继结点中的线程
            }
            else if (ws == 0 &amp;amp;&amp;amp;
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
        if (h == head)                   // loop if head changed
            break;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法主要完成的工作是唤醒头结点之后的结点中的线程。那么其他在同步队列中等待的线程使如何被唤醒的？别急,我们可以在await()方法中找到答案。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void await() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;找到sync正确的实现类后跟进源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final void acquireSharedInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (tryAcquireShared(arg) &amp;lt; 0)
        doAcquireSharedInterruptibly(arg);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;tryAcquireShared()是在共享模式下尝试获取同步状态,&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected int tryAcquireShared(int acquires) {
    return (getState() == 0) ? 1 : -1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当同步状态值state=0时返回1,表示获取同步状态成功,否则返回-1表示获取同步状态失败。获取同步状态失败的线程显然应该加入同步等待队列并在队列中等待,这部分逻辑我们在解读ReentrentLock的源码时应该已经看过了,不过在共享模式下细节方面有些不同&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Acquires in shared interruptible mode.
 * @param arg the acquire argument
 */
private void doAcquireSharedInterruptibly(int arg)
    throws InterruptedException {
    final Node node = addWaiter(Node.SHARED);//构造结点并加入同步队列
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);//当前驱结点是头结点时获取同步状态
                if (r &amp;gt;= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                parkAndCheckInterrupt())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一步自然是构造结点并加入同步队列尾部,这部分逻辑在&lt;code&gt;addWaiter()&lt;/code&gt;方法中,注意结点类型为共享类型。之后的逻辑和独占模式类似,检查前驱结点是否是队列的头结点,是则尝试获取同步状态,成功则将当前结点设置为队列头结点,失败则阻塞当前线程并等待唤醒并重新执行以上流程。不过在共享模式下,当前线程在成功获取同步状态并设置自身为头结点后,还必须做些额外的工作:当后继结点为共享类型时,唤醒后继结点中的线程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head; // Record old head for check below
    setHead(node); //设置当前结点为队列头结点
    /*
     * Try to signal next queued node if:
     *   Propagation was indicated by caller,
     *     or was recorded (as h.waitStatus either before
     *     or after setHead) by a previous operation
     *     (note: this uses sign-check of waitStatus because
     *      PROPAGATE status may transition to SIGNAL.)
     * and
     *   The next node is waiting in shared mode,
     *     or we don't know, because it appears null
     *
     * The conservatism in both of these checks may cause
     * unnecessary wake-ups, but only when there are multiple
     * racing acquires/releases, so most need signals now or soon
     * anyway.
     */
    if (propagate &amp;gt; 0 || h == null || h.waitStatus &amp;lt; 0 ||
        (h = head) == null || h.waitStatus &amp;lt; 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            doReleaseShared(); //唤醒后继结点的线程
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此,CountDownLatch的原理就搞明白了,它是以AQS的共享模式来实现复杂的并发流程控制的。当其内部的计数器不为0时,调用其await方法将导致线程加入同步队列并阻塞。当调用countDown方法使计数器的值为0时,会唤醒队列中第一个等待的线程,之后由该线程唤醒后面的线程,以此类推,直到阻塞在闭锁上的线程都被成功唤醒。&lt;/p&gt;
&lt;h2 id=&quot;循环屏障cyclicbarrier&quot;&gt;3.循环屏障CyclicBarrier&lt;/h2&gt;
&lt;h3 id=&quot;cyclicbarrier功能简介&quot;&gt;3.1 CyclicBarrier功能简介&lt;/h3&gt;
&lt;p&gt;CyclicBarrier通常称为循环屏障。它和CountDownLatch很相似,都可以使线程先等待然后再执行。不过CountDownLatch是使一批线程等待另一批线程执行完后再执行;而CyclicBarrier只是使等待的线程达到一定数目后再让它们继续执行。故而CyclicBarrier内部也有一个计数器,计数器的初始值在创建对象时通过构造参数指定,如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public CyclicBarrier(int parties) {
    this(parties, null);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每调用一次await()方法都将使阻塞的线程数+1,只有阻塞的线程数达到设定值时屏障才会打开,允许阻塞的所有线程继续执行。除此之外,CyclicBarrier还有几点需要注意的地方:&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;1.CyclicBarrier的计数器可以重置而CountDownLatch不行,这意味着CyclicBarrier实例可以被重复使用而CountDownLatch只能被使用一次。而这也是循环屏障循环二字的语义所在。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;2.CyclicBarrier允许用户自定义barrierAction操作,这是个可选操作,可以在创建CyclicBarrier对象时指定&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public CyclicBarrier(int parties, Runnable barrierAction) {
    if (parties &amp;lt;= 0) throw new IllegalArgumentException();
    this.parties = parties;
    this.count = parties;
    this.barrierCommand = barrierAction;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一旦用户在创建CyclicBarrier对象时设置了barrierAction参数,则在阻塞线程数达到设定值屏障打开前,会调用barrierAction的run()方法完成用户自定义的操作。&lt;/p&gt;
&lt;h3 id=&quot;使用cyclicbarrier&quot;&gt;3.2 使用CyclicBarrier&lt;/h3&gt;
&lt;p&gt;还是以多线程分割大任务并发执行的例子来进行讲解,不过这次情况要稍微复杂些。线程在执行完分配给它的子任务后不能立即退出,必须等待所有任务都完成后再执行释放资源的操作。而主线程在所有子任务都执行完毕后也要执行特定的操作,且该操作在线程释放资源前。所有操作都以打印日志的方式进行模拟。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * @author: takumiCX
 * @create: 2018-09-18
 **/
public class CyclicBarrierTest {

    static CyclicBarrier cyclicBarrier;

    public static void main(String[] args) {
        int count = 10;
        //当所有子任务都执行完毕时,barrierAction的run方法会被调用
        cyclicBarrier = new CyclicBarrier(count, () -&amp;gt;
                System.out.println(&quot;执行barrierAction操作!&quot;));
        //开启多个线程执行子任务
        for(int i=0;i&amp;lt;count;i++){
            new Thread(new CyclicBarrierThread(cyclicBarrier,i)).start();
        }

    }

    private static class CyclicBarrierThread implements Runnable {

        public CyclicBarrier cyclicBarrier;

        //任务序号
        public int taskNum;

        public CyclicBarrierThread(CyclicBarrier cyclicBarrier, int taskNum) {
            this.cyclicBarrier = cyclicBarrier;
            this.taskNum = taskNum;
        }

        @Override
        public void run() {
            //执行子任务
            System.out.println(&quot;子任务：&quot;+taskNum+&quot; 执行完毕!&quot;);
            try {
                //等待所有子任务执行完成
                cyclicBarrier.await();

            } catch (Exception e) {
                e.printStackTrace();
            }
            //释放资源
            System.out.println(&quot;线程：&quot;+taskNum+&quot; 释放资源!&quot;);

        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开启10个线程执行子任务,每个线程执行完子任务后在CyclicBarrier上等待。等到所有子任务完成后,用户设置自定义的barrierAction操作即被执行,之后屏障正式打开,阻塞的所有线程将完成释放资源的操作。&lt;br/&gt;结果如下图所示&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201809/1422237-20180925141743459-818210008.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;cyclicbarrier原理浅析&quot;&gt;3.3 CyclicBarrier原理浅析&lt;/h3&gt;
&lt;p&gt;CyclicBarrier内部使用ReentrentLock来实现线程同步,而通过Condition来实现线程的阻塞和唤醒。当计数器值为0时,首先会执行用户自定义的barrierAction操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int index = --count;  //计数器值
if (index == 0) {  // tripped
    boolean ranAction = false;
    try {
        final Runnable command = barrierCommand;  //用户自定义的barrierAction
        if (command != null)
            command.run();
        ranAction = true;
        nextGeneration();
        return 0;
    } finally {
        if (!ranAction)
            breakBarrier();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后再进行阻塞线程的唤醒,以及将计数器重置为初始值。这部分代码在nextGeneration()中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void nextGeneration() {
    // signal completion of last generation
    trip.signalAll();  //唤醒所有的阻塞线程
    // set up next generation
    count = parties;   //计数器重置为初始值
    generation = new Generation();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;信号量semaphore&quot;&gt;4. 信号量Semaphore&lt;/h2&gt;
&lt;h3 id=&quot;semaphore功能简介&quot;&gt;4.1 Semaphore功能简介&lt;/h3&gt;
&lt;p&gt;如果学过操作系统的话,对信号量Semaphore应该不陌生。操作系统中的信号量是这么一个机构：它维护了一定数目的资源,进程向其请求资源将导致Semaphore中资源数量减少,当资源数量小于0时将会导致当前线程阻塞；而进程释放资源将导致Semaphore中资源数量增加,当资源数量大于0时会唤醒阻塞的进程。操作系统中使用信号量可以轻松实现进程间的互斥和同步。java在语言层面也支持信号量机制,其工作原理和操作系统中的信号量类似,可以通过调用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void acquire(int permits)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;code&gt;public boolean tryAcquire(int permits)&lt;/code&gt;&lt;br/&gt;请求信号量中的许可(资源)。不过后者在信号量中许可数量不够时不会阻塞而是立即返回一个失败结果。当然,也可以通过&lt;code&gt;public void release()&lt;/code&gt;&lt;br/&gt;向信号量归还资源。&lt;br/&gt;信号量在创建时必须为其指定可以用的许可总数,如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Semaphore(int permits) {
    sync = new NonfairSync(permits);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当创建信号量时指定许可总数为1,则可以起到独占锁的作用,不过它是不允许线程重入的。同时,它还有公平和非公平模式之分,通过在创建对象时传入参数进行指定&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Semaphore(int permits, boolean fair) {
    sync = fair ? new FairSync(permits) : new NonfairSync(permits);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和ReentrentLock一样默认是非公平模式。&lt;/p&gt;
&lt;h3 id=&quot;使用semaphore进行最大并发数的控制&quot;&gt;4.2 使用Semaphore进行最大并发数的控制&lt;/h3&gt;
&lt;p&gt;假设服务器上有一种资源可以同时供多个用户进行访问,出于系统稳定性考虑需要限制同时访问的用户的数量,整个过程可以模拟如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * @author: takumiCX
 * @create: 2018-09-24
 **/
public class SemaphoreTest {

    public static void main(String[] args) throws InterruptedException {

        //信号量控制并发数最多为3
        Semaphore semaphore = new Semaphore(3);

        //同时开启10个线程
        for(int i=1;i&amp;lt;=10;i++){
            new Thread(new ReaderThread(semaphore,i)).start();
        }

    }


    static class ReaderThread implements Runnable{

        Semaphore semaphore;

        //用户序号
        int userIndex;

        public ReaderThread(Semaphore semaphore, int userIndex) {
            this.semaphore = semaphore;
            this.userIndex = userIndex;
        }

        @Override
        public void run() {

            try {
                //获取许可
                semaphore.acquire(1);
                //模拟访问资源所用的时间
                TimeUnit.SECONDS.sleep(1);

                System.out.println(&quot;用户 &quot;+userIndex+&quot; 访问资源,时间:&quot;+System.currentTimeMillis());

                //释放许可
                semaphore.release();

            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用信号量限制同时并发访问的线程数为3,然后开启10个线程模拟用户访问。得到的结果如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201809/1422237-20180925141821523-1441209696.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从结果上可以清晰的看到,每次最多允许3个用户同时访问资源,信号量很好的起到了限流作用。&lt;/p&gt;
&lt;h3 id=&quot;semaphore原理浅析&quot;&gt;4.3 Semaphore原理浅析&lt;/h3&gt;
&lt;p&gt;和CountDownLatch类似，Semaphore底层也是通过AQS的共享模式实现的。它和CountDownLatch的区别只是对于AQS共享模式的钩子方法&lt;code&gt;tryAcquireShared()&lt;/code&gt;&lt;br/&gt;和&lt;code&gt;tryReleaseShared()&lt;/code&gt;&lt;br/&gt;的实现不同。&lt;/p&gt;
&lt;p&gt;以Semaphore的非公平模式为例,其尝试释放同步状态的逻辑如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;final int nonfairTryAcquireShared(int acquires) {
    for (;;) {
        int available = getState();  //获取可用许可数
        int remaining = available - acquires; //计算被消耗后剩余的许可数
        if (remaining &amp;lt; 0 ||
            compareAndSetState(available, remaining))
            return remaining;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先会获取当前可用的许可值(state),根据请求数量计算出剩余的许可值,若剩余许可数小于0则直接返回剩余值表示该操作失败;否则以CAS方式将state值更新为计算后的剩余值,并返回一个大于等于0的数表示成功。通过该方法的返回值可以知道尝试获取同步状态的操作是否成功,返回值小于0表示没有足够的许可,线程将会加入同步队列并等待;返回值大于等于0则表示许可足够,则整个获取许可的流程就结束了。&lt;/p&gt;
&lt;p&gt;tryReleaseShared()的实现也很简单,&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected final boolean tryReleaseShared(int releases) {
    for (;;) {
        int current = getState();  //获取当前许可数
        int next = current + releases; //计算释放后的许可总数
        if (next &amp;lt; current) // overflow
            throw new Error(&quot;Maximum permit count exceeded&quot;);
        if (compareAndSetState(current, next)) //cas更新许可值
            return true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;计算释放后的许可总数并以CAS方式对state值进行更新。之后将返回上层继续执行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;doReleaseShared()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;唤醒头结点后面结点中的线程,被唤醒的线程将执行&lt;code&gt;tryAcquireShared()&lt;/code&gt;重新尝试获取同步状态,获取失败则继续阻塞,获取成功将设置当前结点为队列头结点并继续唤醒后续结点中的线程。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Sep 2018 06:19:00 +0000</pubDate>
<dc:creator>takumiCX</dc:creator>
<og:description>[TOC] 1. 前言 在实际开发中,碰上CPU密集且执行时间非常耗时的任务,通常我们会选择将该任务进行分割,以多线程方式同时执行若干个子任务,等这些子任务都执行完后再将所得的结果进行合并。这正是著名</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/takumicx/p/9698867.html</dc:identifier>
</item>
<item>
<title>基于ZooKeeper，Spring设计实现的参数系统 - MIASDZ</title>
<link>http://www.cnblogs.com/superstudy/p/9696631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/superstudy/p/9696631.html</guid>
<description>&lt;p&gt; &lt;span&gt;&lt;strong&gt;&lt;span&gt;一、简介&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  基于ZooKeeper服务端、ZooKeeper Java客户端以及Spring框架设计的用于系统内部进行参数维护的系统。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、设计背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  在我们日常开发的系统内部，开发过程中最常见的一项工作便是常用参数的维护，从我学习Java以来，参数的配置多样化，最常见的方式是properties配置文件或者是xml配置文件，高深点的用法是JMX MBean进行参数管理以及数据库参数配置。我们对现有的参数配置方式进行分析，详见下表：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;配置方式&lt;/th&gt;
&lt;th&gt;常见问题&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt; 代码内字符窜字面量配置&lt;/td&gt;
&lt;td&gt; 每次参数的修改都需要重新编译&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt; properties配置文件/xml配置文件&lt;/td&gt;
&lt;td&gt; 普通用法虽然将参数从代码内抽离出来，但是无法随时更新生效&lt;/td&gt;
&lt;td&gt; Spring提供的ReloadableResourceBundleMessageSource工具类可以实现热加载Properties文件，将参数配置文件从代码分离可以做到不停机不重启做参数维护，并被程序加载，但是仍需系统重新从文件资源内获取新的参数值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt; JMX参数配置&lt;/td&gt;
&lt;td&gt; 标准MBEAN是有侵入性的，他要管理的对象是符合JAVA BEAN规范的对象。但是要作为标准MBEAN而被管理，就需要实现一个接口。这个接口的名称必须是类名加上MBean。&lt;/td&gt;
&lt;td&gt; Spring支持将普通Bean通过配置MBeanExporter生成MBean&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt; 数据库参数配置&lt;/td&gt;
&lt;td&gt; 需要从数据库内加载参数，每次参数的使用需要连接数据库进行数据库查询。后来出现了代码缓存数据库参数，在一次使用后将参数信息放置缓存内，但是这种做法无法感知数据库参数的变化。&lt;/td&gt;
&lt;td&gt; 代码缓存数据库参数方式，可以新增代码设计用于刷新缓存参数，从库内重新读取放置缓存内，也不失为一种方便的参数管理。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;  基于上述各类参数配置分析，一番思考设想，设计出如下结构的[参数中心系统]（&lt;a title=&quot;参数中心系统设计图&quot; href=&quot;https://pan.baidu.com/s/1-y_Z1lUtB5YRNSIQWJT8iQ&quot; target=&quot;_blank&quot;&gt;详细设计链接&lt;/a&gt;）,设计说明查看下一节：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/765490/201809/765490-20180925093049266-1479730780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、系统设计说明&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  参数中心系统，顾名思义，主要是将参数集中化，在实际开发中，一个业务的实现需要几个甚至数十个模块联合完成，每个模块都需要进行参数的更新维护，一个模块的参数更新设计缺陷，在进行参数维护时，就可能导致某个业务的中断，故需要将多参数管理统一化管理；统一化的参数管理方式，便可能涉及到了参数数据的统一存储，统一之后便出现了性能瓶颈需求，不然所有鸡蛋装一个篮子里，一出问题全部碎掉；在集中化后，各个模块有自己的参数，有些参数可能仅限单个系统访问，便需要安全的参数访问方式；在参数使用过程中，常见的功能之一便是参数的实时维护；在项目投产过程中，经常因为参数配置问题比如配置错误等情况导致业务中断，故需要一个参数检查表来确认参数的正确性；参数管理整合后，需要方便的操作来实现管理功能。概括一下，参数中心系统需要满足以下技术需求：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;多系统、多模式、安全、动态维护的参数配置&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;个性化话参数配置（普通字符窜，JSON字符窜，数组窜）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;低侵入&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;快捷的参数导入导出功能&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;便捷的管理方式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;上线参数检查表，用于上线时各类参数的检查，防止出错&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;高可用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;安全控制&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;  根据上述分析，设计之初，思考如何实现多系统多模式的参数存储，虽然一直知道ZooKeeper这个东西，但从未详细了解过，偶然机会大致学习了一下ZooKeeper，发现ZooKeeper的各类机制与参数中心系统设计相吻合，比如：多系统多模式的参数存储与ZooKeeper的目录型存储方式相似，查看下面图3-1展示；参数的安全方式认证与ZooKeeper的ACL机制吻合；参数实时维护可以借鉴ZooKeeper的Watcher机制；参数中心系统的高性能高可用设计与ZooKeeper的集群方式相吻合。这样下来，参数中心系统最大的问题参数存储模块服务端得到了完美的解决。接下来的便是基于ZooKeeper设计出对应的客户端，管理端。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/765490/201809/765490-20180925101854505-17393614.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图3-1 基于ZooKeeper的参数存储&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  Java应用端常用的技术之一便是Spring框架，也符合低侵入的设计原则，在使用Spring开发过程中，常用的功能之一便是使用${}引用properties配置文件内的参数，如此方便的参数配置方式，我决定使用类似的方式，配置方式为zk{}（zk表示ZooKeeper参数），故客户端的设计是基于Spring的设计。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、系统技术组合&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  ZooKeeper集群 + ZooKeeper Java客户端 + Spring BeanFactoryPostProcessor扩展点 + JSON字符窜解析 + Spring SpEL表达式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;五、设计实现（重点）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  根据上述设计说明等信息，最后得出这样一个系统，基于ZooKeeper参数存储，Spring客户端使用zk{}进行参数配置的参数中心系统。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  服务端设计如3-1图所示（在实际开发过程中可能稍有变动）&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;客户端（重点）&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;  &lt;span&gt;在进行参数中心系统客户端实现之前，我们先了解一点Spring框架的基础知识。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  在Spring框架开发过程中，最常用的配置是&amp;lt;bean/&amp;gt;标签的使用，在工作中，最常听的一种说法是，在xml里配置上就可以使用bean了，就有对象了，这种理解潜在一层含义xml直接配置成了java bean，而实际上，Spring中bean的定义最终表现为BeanDefinition对象，个人理解为xml实际配置的是bean的说明信息，Spring将这些说明信息转换为了BeanDefinition对象，再由BeanDefinition生成了我们最终看到的bean，实际流程为[&lt;span&gt;&lt;strong&gt;xml配置-&amp;gt;BeanDefinition-&amp;gt;Bean&lt;/strong&gt;&lt;/span&gt;]而一般开发者不知道BeanDefinition，故理解含义成了[&lt;strong&gt;&lt;span&gt;xml配置-&amp;gt;Bean&lt;/span&gt;&lt;/strong&gt;]，中间缺少了重要的环节。在BeanDefinition到Bean这个过程中，Spring由BeanFactory生成实际的bean，在实际bean产生前，Spring提供了BeanFactoryPostProcessor扩展点（类似还有BeanPostProcessor），通过该扩展点可以获取到配置的BeanDefinition信息，用于自定义扩展对bean定义变更修改，实现自由控制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  Spring允许开发者实现自定义的扩展点，实现特定的接口，使用通用的配置即可注册一个扩展点到Spring容器内。&lt;/span&gt;&lt;span&gt;详细学习参考&lt;a href=&quot;https://docs.spring.io/spring/docs/4.3.19.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-nature&quot; target=&quot;_blank&quot;&gt;https://docs.spring.io/spring/docs/4.3.19.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-nature&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  参数中心系统参数的配置实现参考了Spring的${}参数配置，我们对${}的实现做简单学习。&lt;/span&gt;&lt;span&gt;${}的实现便使用了Spring扩展点BeanFactoryPostProcessor，开发中常见配置如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/765490/201809/765490-20180925110857860-2101251995.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/765490/201809/765490-20180925110916360-122774785.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  上图中采用了context:property-placeholder标签配置，根据&lt;a href=&quot;http://www.springframework.org/schema/context/spring-context.xsd&quot; target=&quot;_blank&quot;&gt;Spring context的xsd说明文件&lt;/a&gt;，我们知道了property-placeholder对应的实际类为org.springframework.context.support.PropertySourcesPlaceholderConfigurer，&lt;strong&gt;context:property-placeholder配置实际为在spring容器内注册一个扩展点，实现${}表达式的解析&lt;/strong&gt;。&lt;/span&gt;&lt;span&gt;实现类图以及调用流程大致如下，再详细过程查看源码，(有句话叫做&lt;strong&gt;&lt;span&gt;师傅领进门，修行在个人&lt;/span&gt;&lt;/strong&gt;)：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/765490/201809/765490-20180925111252506-140516664.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;strong&gt;参数中心系统客户端的实现代码与上述实现类似，不同的是properties配置文件变成了ZooKeeper参数存储，${}变成了zk{}。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  客户端项目名称：&lt;strong&gt;itwatertop-pczk-client&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  基于H5的管理页面设计，详细情况还未设想（先实现了主要的服务端客户端，管理端暂时可以使用ZooKeeper的客户端）。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;六、客户端设计源码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  客户端程序结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/765490/201809/765490-20180925130255716-1627638689.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;  文件说明：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;BaseLoader.java 数据加载基类&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ZookeeperDataLoader.java Java ZooKeeper客户端实现数据加载，参数更新回调。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;PlaceholderMsg.java zk{zkexp} zk配置表达式解析结果，以及使用该表达式的bean属性获取SpEL表达式。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ParamCenterStore.java 对ZooKeeper参数服务端获取的参数信息做缓存，并且将对应的使用该参数的Bean属性表达式统计，方便ZooKeeper参数变更时回调使用。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;PczkConstants.java 系统内常量字符窜整合。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;PczkStringValueResolver.java 表达式解析统一接口&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;PczkPropertyPlaceholderConfiguer.java 实现Spring扩展点BeanFactoryPostProcessor，通过该扩展点对BeanDefinition配置元信息做解析以及变更。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;PropertyPlaceholderHelper.java 具体实现zk{}表达式解析规则。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;PczkBeanDefinitionVisitor.java 对Spring IoC容器内的BeanDefinition属性配置信息做解析，主要结合PczkPropertyPlaceholderConfiguer.java使用。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;test目录下包含一部分测试代码，可以自行查看&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;  客户端代码实现简介：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  根据上述需求，客户端代码需要具备的能力包括：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;与ZooKeeper服务器的连通，并获取参数信息&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Spring xml中zk{}表达式的解析&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;多样化的参数配置，支持字符窜，对象，数组&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ZooKeeper参数变更回调，维护参数信息&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;  针对上面4种要求，在开发时使用以下解决办法：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;使用ZooKeeper Java客户端；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;结合Spring的扩展点BeanFactoryPostProcessor；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在ZooKeeper服务端节点内设置数据时设置字符窜/JSON对象字符窜或者是JSON数组字符窜，客户端使用数据时分别配置为zk{param},zk{param.key},zk{param[i]}，通过对zk{}表达式解析判断ZooKeeper参数格式，若为JSON字符窜使用FastJSON对字符窜做解析，访问对应属性值；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;针对参数变更回调，在解析zk{}表达式时拼接出了可以访问到对应bean属性的SpEL表达式，通过SpEL表达式访问bean属性调用setter方法，因此属性操作也受到SpEL表达式的限制。在个别情况下，由于参数的变更可能需要别的一下操作处理，比如重新建立连接，这个可以自行扩展代码，比如比较上一次的值和当前值是否一致，不一致做出新的操作（现在也在设想怎么可以自动识别进行额外操作）。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;  客户端详细实现源码下载：&lt;a href=&quot;https://github.com/miasdz/ParamCenter&quot; target=&quot;_blank&quot;&gt;访问GitHub项目&lt;/a&gt;（注释还是比较清晰的）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;七、说明&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  本人技术有限，上述有错误的理解欢迎指出，共同交流学习，若对上述说明不了解，建议先学习一点Spring IoC设计，学习地址：&lt;a href=&quot;https://docs.spring.io/spring/docs/4.3.19.RELEASE/spring-framework-reference/htmlsingle&quot; target=&quot;_blank&quot;&gt;https://docs.spring.io/spring/docs/4.3.19.RELEASE/spring-framework-reference/htmlsingle&lt;/a&gt;，若对于客户端的设计有好的建议可以提出来，共同讨论。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 25 Sep 2018 05:39:00 +0000</pubDate>
<dc:creator>MIASDZ</dc:creator>
<og:description>一、简介 基于ZooKeeper服务端、ZooKeeper Java客户端以及Spring框架设计的用于系统内部进行参数维护的系统。 二、设计背景 在我们日常开发的系统内部，开发过程中最常见的一项工作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/superstudy/p/9696631.html</dc:identifier>
</item>
<item>
<title>第六节：框架搭建之EF的Fluent Api模式的使用流程 - Yaopengfei</title>
<link>http://www.cnblogs.com/yaopengfei/p/9663044.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaopengfei/p/9663044.html</guid>
<description>&lt;p&gt;&lt;span&gt;一. 前言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;沉寂了约一个月的时间，今天用一篇简单的文章重新回归博客，主要来探讨一下Fluent Api模式在实际项目中的使用流程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. Fluent API属于EF CodeFirst模式的一种，EF还有一种模式是DataAnnotations，两种模式各有千秋吧，前面的EF系列已经详细介绍过他们的使用了，本节主要介绍 Fluent API模式在实际框架中的使用流程.&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;二. 使用步骤&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.  新建【Ypf.Service】类库和【Ypf.Test】控制台项目，并分别通过Nuget安装EF程序集。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1031302/201809/1031302-20180921165744715-64994303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 在【Ypf.Service】类库中新建“UserInfor”、“RoleInfor”实体类，“UserInforConfig”、“RoleInforConfig”实体类对应的隔离出来的表的配置文件。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;PS：这里为了方便管理，一张表对应一个EF的配置类文件，比全部直接写在 OnModelCreating 方法中更清晰。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;分享实体类代码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户表
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserInfor
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; userName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; userAge { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 角色信息
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RoleInfor
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; roleName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; roleAge { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;分享表配置文件代码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; UserInfor实体对应表的配置
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt; UserInforConfig :EntityTypeConfiguration&amp;lt;UserInfor&amp;gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserInforConfig()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.ToTable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;T_UserInfor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.HasKey&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(u =&amp;gt; u.id).Property(u =&amp;gt; u.id).HasColumnType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).HasMaxLength(&lt;span&gt;32&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.Property(u =&amp;gt; u.userName).HasColumnType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).HasMaxLength(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.Property(u =&amp;gt; u.userAge).HasColumnType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).IsRequired();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; RoleInfor实体对应表的配置
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt; RoleInforConfig : EntityTypeConfiguration&amp;lt;RoleInfor&amp;gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RoleInforConfig()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.ToTable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;T_RoleInfor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.HasKey&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(u =&amp;gt; u.id).Property(u =&amp;gt; u.id).HasColumnType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).HasMaxLength(&lt;span&gt;32&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.Property(u =&amp;gt; u.roleName).HasColumnType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).HasMaxLength(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.Property(u =&amp;gt; u.roleAge).HasColumnType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).IsRequired();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. 在【Ypf.Service】类库中新建EF上下文 “YpfContext”类，使用EF的默认初始化策略(&lt;span&gt;DB不存在则创建，实体不对应则报错&lt;/span&gt;) ，然后override OnModelCreating方法，并通过反射一次性加载EF的所有Fluent Api配置，最后声明要映射的实体。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 分享EF上下文的代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; YpfContext:DbContext
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 继承父类构造函数，ypfConnectionString代表配置文件中连接字符串的名字
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; YpfContext():&lt;span&gt;base&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name=ypfConnectionString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        {
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; OnModelCreating方法重写，FluentAPI对表的配置都是在该方法中，但是当表数量多的话
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 该方法内部就会显得特别乱，所以我们这里采用分离的方式，一张表对应一个配置文件类，
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 最后全部注册到该方法中即可
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;modelBuilder&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(DbModelBuilder modelBuilder)
        {
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnModelCreating(modelBuilder);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1. 分开注册
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;modelBuilder.Configurations.Add(new UserInforConfig());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;modelBuilder.Configurations.Add(new RoleInforConfig());

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2. 一次性加载所有Fluent API的配置&lt;/span&gt;
&lt;span&gt;            modelBuilder.Configurations.AddFromAssembly(Assembly.GetExecutingAssembly());
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;UserInfor&amp;gt; UserInfor { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;RoleInfor&amp;gt; RoleInfor { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4. 给【Ypf.Test】配置数据库连接字符串，并且进行一个简单的数据库查询操作，会发现在SQLServer默认目录生成一个名为“FrameFluentApiDB”的数据库，且表、字段对应均正确。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 分享数据库连接字符串代码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;connectionStrings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;ypfConnectionString&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Data Source=localhost;Initial Catalog=FrameFluentApiDB;User ID=sa;Password=123456&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;System.Data.SqlClient&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;connectionStrings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;分享简单的数据库查询代码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;using&lt;/span&gt; (YpfContext db=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; YpfContext())
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; list =&lt;span&gt; db.UserInfor.ToList();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;创建成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                Console.ReadKey();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 运行后生成的数据库：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1031302/201809/1031302-20180922190151949-389515980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5. 给UserInfor实体增加一个“userSex”属性，并在UserInforConfig文件中对该属性进行配置，如下图，再次运行代码，报错，提示上下文发生改变，请走数据迁移。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修改后代码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1031302/201809/1031302-20180922195652050-1545713518.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1031302/201809/1031302-20180922195738885-2011082346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;










&lt;p&gt;&lt;strong&gt;&lt;span&gt;报错提示：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1031302/201809/1031302-20180922200618849-2122423783.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;PS：配置数据迁移策略固然可以解决该问题，但我们这里用一种比较笨的方法，关闭数据库初始化策略，然后手动配置代码和修改数据库字段进行对应即可。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 分享关闭数据库初始化策略的代码：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1031302/201809/1031302-20180922201747406-1769235597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;手动修改数据库和代码实体中的属性对应后重新运行代码，运行成功。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1031302/201809/1031302-20180922202629945-1372010093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;div&gt;

&lt;div&gt;
&lt;ul&gt;&lt;li&gt;作       者 : &lt;span&gt;Yaopengfei(姚鹏飞)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;博客地址 : &lt;a href=&quot;http://www.cnblogs.com/yaopengfei/&quot;&gt;&lt;span&gt;http://www.cnblogs.com/yaopengfei/&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;声     明1 : 本人才疏学浅，用郭德纲的话说“我是一个小学生”，如有错误，欢迎讨论，请勿谩骂^_^。&lt;/li&gt;
&lt;li&gt;声     明2 : 原创博客请在转载时保留原文链接或在文章开头加上本人博客地址，否则保留追究法律责任的权利。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Tue, 25 Sep 2018 05:35:00 +0000</pubDate>
<dc:creator>Yaopengfei</dc:creator>
<og:description>一. 前言 沉寂了约一个月的时间，今天用一篇简单的文章重新回归博客，主要来探讨一下Fluent Api模式在实际项目中的使用流程。 1. Fluent API属于EF CodeFirst模式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaopengfei/p/9663044.html</dc:identifier>
</item>
<item>
<title>Westore 1.0 正式发布 - 小程序框架一个就够 - 【当耐特】</title>
<link>http://www.cnblogs.com/iamzhanglei/p/9698784.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iamzhanglei/p/9698784.html</guid>
<description>&lt;blockquote readability=&quot;4.2424242424242&quot;&gt;
&lt;p&gt;世界上最小却强大的小程序框架 - &lt;a href=&quot;https://github.com/dntzhang/westore/blob/master/utils/create.js&quot;&gt;100多行代码&lt;/a&gt;搞定全局状态管理和跨页通讯&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Github： &lt;a href=&quot;https://github.com/dntzhang/westore&quot; class=&quot;uri&quot;&gt;https://github.com/dntzhang/westore&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;众所周知，小程序通过页面或组件各自的 setData 再加上各种父子、祖孙、姐弟、嫂子与堂兄等等组件间的通讯会把程序搞成一团浆糊，如果再加上跨页面之间的组件通讯，会让程序非常难维护和调试。虽然市面上出现了许多技术栈编译转小程序的技术，但是我觉没有戳中小程序的痛点。小程序不管从组件化、开发、调试、发布、灰度、回滚、上报、统计、监控和最近的云能力都非常完善，小程序的工程化简直就是前端的典范。而开发者工具也在持续更新，可以想象的未来，组件布局的话未必需要写代码了。所以最大的痛点只剩下状态管理和跨页通讯。&lt;/p&gt;
&lt;p&gt;受 &lt;a href=&quot;https://github.com/Tencent/omi&quot;&gt;Omi 框架&lt;/a&gt; 的启发，且专门为小程序开发的 &lt;a href=&quot;https://github.com/dntzhang/westore/blob/master/utils/diff.js&quot;&gt;JSON Diff 库&lt;/a&gt;，所以有了 westore 全局状态管理和跨页通讯框架让一切尽在掌握中，且受高性能 JSON Diff 库的利好，长列表滚动加载显示变得轻松可驾驭。总结下来有如下特性和优势:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;和 Omi 同样简洁的 Store API&lt;/li&gt;
&lt;li&gt;超小的代码尺寸(包括 json diff 共100多行)&lt;/li&gt;
&lt;li&gt;尊重且顺从小程序的设计(其他转译库相当于反其道行)&lt;/li&gt;
&lt;li&gt;this.update 比原生 setData 的性能更优，更加智能&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;api&quot;&gt;API&lt;/h2&gt;
&lt;p&gt;Westore API 只有三个, 大道至简:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;create(store, option) 创建页面&lt;/li&gt;
&lt;li&gt;create(option) 创建组件&lt;/li&gt;
&lt;li&gt;this.update() 更新页面或组件&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;使用指南&quot;&gt;使用指南&lt;/h2&gt;
&lt;h3 id=&quot;定义全局-store&quot;&gt;定义全局 store&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export default {
  data: {
    motto: 'Hello World',
    userInfo: {},
    hasUserInfo: false,
    canIUse: wx.canIUse('button.open-type.getUserInfo'),
    logs: []
  },
  logMotto: function () {
    console.log(this.data.motto)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你不需要在页面和组件上再声明 data 属性。如果申明了也没关系，会被 Object.assign 覆盖到 store.data 上。后续只需修改 this.store.data 便可。&lt;/p&gt;
&lt;h3 id=&quot;创建页面&quot;&gt;创建页面&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import store from '../../store'
import create from '../../utils/create'

const app = getApp()

create(store, {

  onLoad: function () {
    if (app.globalData.userInfo) {
      this.store.data.userInfo = app.globalData.userInfo
      this.store.data.hasUserInfo = true
      this.update()
    } else if (this.data.canIUse) {
      app.userInfoReadyCallback = res =&amp;gt; {
        this.store.data.userInfo = res.userInfo
        this.store.data.hasUserInfo = true
        this.update()
      }
    } else {
      wx.getUserInfo({
        success: res =&amp;gt; {
          app.globalData.userInfo = res.userInfo
          this.store.data.userInfo = res.userInfo
          this.store.data.hasUserInfo = true
          this.update()
        }
      })
    }
  }

})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建 Page 只需传入两个参数，store 从根节点注入，所有子组件都能通过 this.store 访问。&lt;/p&gt;
&lt;h3 id=&quot;绑定数据&quot;&gt;绑定数据&lt;/h3&gt;
&lt;pre class=&quot;jsx&quot;&gt;
&lt;code&gt;&amp;lt;view class=&quot;container&quot;&amp;gt;
   
  &amp;lt;view class=&quot;userinfo&quot;&amp;gt;
    &amp;lt;button wx:if=&quot;{{!hasUserInfo &amp;amp;&amp;amp; canIUse}}&quot; open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getUserInfo&quot;&amp;gt; 获取头像昵称 &amp;lt;/button&amp;gt;
    &amp;lt;block wx:else&amp;gt;
      &amp;lt;image bindtap=&quot;bindViewTap&quot; class=&quot;userinfo-avatar&quot; src=&quot;{{userInfo.avatarUrl}}&quot; mode=&quot;cover&quot;&amp;gt;&amp;lt;/image&amp;gt;
      &amp;lt;text class=&quot;userinfo-nickname&quot;&amp;gt;{{userInfo.nickName}}&amp;lt;/text&amp;gt;
    &amp;lt;/block&amp;gt;
  &amp;lt;/view&amp;gt;
  &amp;lt;view class=&quot;usermotto&quot;&amp;gt;
    &amp;lt;text class=&quot;user-motto&quot;&amp;gt;{{motto}}&amp;lt;/text&amp;gt;
  &amp;lt;/view&amp;gt;

  &amp;lt;hello&amp;gt;&amp;lt;/hello&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和以前的写法没有差别，直接把 &lt;code&gt;store.data&lt;/code&gt; 作为绑定数据源。&lt;/p&gt;
&lt;h3 id=&quot;更新页面&quot;&gt;更新页面&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;this.store.data.any_prop_you_want_to_change = 'any_thing_you_want_change_to'
this.update()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建组件&quot;&gt;创建组件&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;
import create from '../../utils/create'

create({
  ready: function () {
   //you can use this.store here
  },

  methods: {
    //you can use this.store here
  }
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和创建 Page 不一样的是，创建组件只需传入一个参数，不需要传入 store，因为已经从根节点注入了。&lt;/p&gt;
&lt;h3 id=&quot;更新组件&quot;&gt;更新组件&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;this.store.data.any_prop_you_want_to_change = 'any_thing_you_want_change_to'
this.update()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;setdata-和-update-对比&quot;&gt;setData 和 update 对比&lt;/h3&gt;
&lt;p&gt;拿官方模板示例的 log 页面作为例子:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;this.setData({
  logs: (wx.getStorageSync('logs') || []).map(log =&amp;gt; {
    return util.formatTime(new Date(log))
  })
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 westore 后:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;this.store.data.logs = (wx.getStorageSync('logs') || []).map(log =&amp;gt; {
  return util.formatTime(new Date(log))
})
this.update()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看似一条语句变成了两条语句，但是 this.update 调用的 setData 是 diff 后的，所以传递的数据更少。&lt;/p&gt;
&lt;h3 id=&quot;跨页面同步数据&quot;&gt;跨页面同步数据&lt;/h3&gt;
&lt;p&gt;使用 westore 你不用关系跨页数据同步，你只需要专注 this.store.data 便可，修改完在任意地方调用 update 便可：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;this.update()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;调试&quot;&gt;调试&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;console.log(getApp().globalData.store.data)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;超大型小程序最佳实践两种方案&quot;&gt;超大型小程序最佳实践(两种方案)&lt;/h3&gt;
&lt;p&gt;不排除小程序被做大得可能，接触的最大的小程序有 60+ 的页面，所以怎么管理？这里给出了两个最佳实践方案。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一种方案，拆分 store 的 data 为不同模块，如:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export default {
  data: {
    commonA: 'a',
    commonB: 'b',
    pageA: {
      a: 1
      xx: 'xxx'
    },
    pageB: {
      b: 2,
      c: 3
    }
  },
  xxx: function () {
    console.log(this.data)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第二种方案，拆分 store 的 data 到不同文件且合并到一个 store 暴露给 create 方法，如：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;a.js&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export default {
  data: {
    a: 1
    xx: 'xxx'
  },
  aMethod: function (num) {
    this.data.a += num
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;b.js&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export default {
  data: {
    b: 2,
    c: 3
  },
  bMethod: function () {
    
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;store.js&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import a from 'a.js'
import b from 'b.js'

export default {
  data: {
    commonNum: 1,
    commonB: 'b',
    pageA: a.data
    pageB: b.data
  },
  xxx: function () {
    //you can call the methods of a or b and can pass args to them
    console.log(a.aMethod(commonNum))
  },
  xx: function(){

  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，也可以不用按照页面拆分文件或模块，也可以按照领域来拆分，这个很自由，视情况而定。&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt; ---------------       -------------------        -----------------------
| this.update  |  →  |     json diff     |   →  | setData()-setData()...|  →  之后就是黑盒(小程序官方实现，但是 dom/apply diff 肯定是少不了)
 ---------------       -------------------        -----------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然和 Omi 一样同为 store.updata 但是却有着本质的区别。Omi 的如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; ---------------       -------------------        ----------------         ------------------------------
|  this.update  |  →  |     setState      |   →  |  jsx rerender  |   →   |   vdom diff → apply diff...  |
 ---------------       -------------------        ----------------         ------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;都是数据驱动视图，但本质不同，原因:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;小程序 store 和 dom 不在同一个环境，先在 js 环境进行 json diff，然后使用 diff 结果通过 setData 通讯&lt;/li&gt;
&lt;li&gt;web 里使用 omi 的话 store 和 dom 在同一环境，setState 直接驱动的 vdom diff 然后把 diff 结果作用在真是 dom 上&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;json-diff&quot;&gt;JSON Diff&lt;/h3&gt;
&lt;p&gt;先看一下我为 westore 专门定制开发的 &lt;a href=&quot;https://github.com/dntzhang/westore/blob/master/utils/diff.js&quot;&gt;JSON Diff 库&lt;/a&gt; 的能力:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;diff({
    a: 1, b: 2, c: &quot;str&quot;, d: { e: [2, { a: 4 }, 5] }, f: true, h: [1], g: { a: [1, 2], j: 111 }
}, {
    a: [], b: &quot;aa&quot;, c: 3, d: { e: [3, { a: 3 }] }, f: false, h: [1, 2], g: { a: [1, 1, 1], i: &quot;delete&quot; }, k: 'del'
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Diff 的结果是:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;{ &quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: &quot;str&quot;, &quot;d.e[0]&quot;: 2, &quot;d.e[1].a&quot;: 4, &quot;d.e[2]&quot;: 5, &quot;f&quot;: true, &quot;h&quot;: [1], &quot;g.a&quot;: [1, 2], &quot;g.j&quot;: 111, &quot;g.i&quot;: null, &quot;k&quot;: null }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/105416/201809/105416-20180925114814055-1736055708.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Diff 原理:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同步所有 key 到当前 store.data&lt;/li&gt;
&lt;li&gt;携带 path 和 result 递归遍历对比所有 key value&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export default function diff(current, pre) {
    const result = {}
    syncKeys(current, pre)
    _diff(current, pre, '', result)
    return result
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同步上一轮 state.data 的 key 主要是为了检测 array 中删除的元素或者 obj 中删除的 key。&lt;/p&gt;
&lt;h3 id=&quot;小程序-setdata&quot;&gt;小程序 setData&lt;/h3&gt;
&lt;p&gt;setData 是小程序开发中使用最频繁的接口，也是最容易引发性能问题的接口。在介绍常见的错误用法前，先简单介绍一下 setData 背后的工作原理。setData 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）。&lt;/p&gt;
&lt;p&gt;其中 key 可以以数据路径的形式给出，支持改变数组中的某一项或对象的某个属性，如 array[2].message，a.b.c.d，并且不需要在 this.data 中预先定义。比如：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;this.setData({
      'array[0].text':'changed data'
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以 diff 的结果可以直接传递给 &lt;code&gt;setData&lt;/code&gt;，也就是 &lt;code&gt;this.update&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;setdata-工作原理&quot;&gt;setData 工作原理&lt;/h4&gt;
&lt;p&gt;小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。&lt;/p&gt;
&lt;p&gt;而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。&lt;/p&gt;
&lt;p&gt;常见的 setData 操作错误:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;频繁的去 setData&lt;/li&gt;
&lt;li&gt;每次 setData 都传递大量新数据&lt;/li&gt;
&lt;li&gt;后台态页面进行 setData&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面是官方截取的内容。使用 webstore 的 this.update 本质是先 diff，再执行一连串的 setData，所以可以保证传递的数据每次维持在最小。既然可以使得传递数据最小，所以第一点和第三点虽有违反但可以商榷。&lt;/p&gt;
&lt;h3 id=&quot;update&quot;&gt;Update&lt;/h3&gt;
&lt;p&gt;这里区分在页面中的 update 和 组件中的 update。页面中的 update 在 onLoad 事件中进行实例收集。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const onLoad = option.onLoad
option.onLoad = function () {
    this.store = store
    rewriteUpdate(this)
    store.instances[this.route] = []
    store.instances[this.route].push(this)
    onLoad &amp;amp;&amp;amp; onLoad.call(this)
}
Page(option)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;组件中的 update 在 ready 事件中进行行实例收集:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const ready = store.ready
store.ready = function () {
    this.page = getCurrentPages()[getCurrentPages().length - 1]
    this.store = this.page.store;
    this.setData.call(this, this.store.data)
    rewriteUpdate(this)
    this.store.instances[this.page.route].push(this)
    ready &amp;amp;&amp;amp; ready.call(this)
}
Component(store)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;rewriteUpdate 的实现如下:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function rewriteUpdate(ctx){
    ctx.update = () =&amp;gt; {
        const diffResult = diff(ctx.store.data, originData)  
        for(let key in ctx.store.instances){
            ctx.store.instances[key].forEach(ins =&amp;gt; {
                ins.setData.call(ins, diffResult)
            })
        }
        for (let key in diffResult) {
            updateOriginData(originData, key, diffResult[key])
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;
&lt;p&gt;MIT &lt;a href=&quot;https://github.com/dntzhang&quot;&gt;@dntzhang&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 25 Sep 2018 03:49:00 +0000</pubDate>
<dc:creator>【当耐特】</dc:creator>
<og:description>世界上最小却强大的小程序框架</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iamzhanglei/p/9698784.html</dc:identifier>
</item>
<item>
<title>前端内存泄漏的分析案例 - ITman彪叔</title>
<link>http://www.cnblogs.com/flyfox1982/p/9698666.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flyfox1982/p/9698666.html</guid>
<description>&lt;p class=&quot;line&quot; data-line=&quot;0&quot;&gt;在最近给客户交付的一个项目中，客户反映系统跑一段时间就会奔溃掉。我的第一直觉就是可能发生了内存泄漏。&lt;/p&gt;
&lt;h2 class=&quot;line&quot; data-line=&quot;1&quot;&gt;复现bug&lt;/h2&gt;
&lt;p class=&quot;line&quot; data-line=&quot;2&quot;&gt;为了能够让bug复现，我让开发的小伙，先把模拟系统在本地跑起来。要知道，bug复现是很重要的。bug复现，能够让开发人员直观的感受到bug发生的过程。另外如果bug不能复现，程序员的反应可能是这样的：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我的这边是好的呀，没有什么问题。&lt;br/&gt;哎呀，是不是你的使用方法不对啊。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;line&quot; data-line=&quot;6&quot;&gt;看到了吗，如果bug不能复现，会直接极大的减少程序员想要修复bug的意愿的。&lt;br/&gt;我后来问他，测试的怎么样，他说没有问题呀。我问题跑了多久，他说有一会儿吧，看没问题就关闭了。&lt;br/&gt;一般来说，内存泄漏最终导致奔溃的需要挺长一段时间的，所以我告诉他一直跑，跑到奔溃为止。&lt;br/&gt;后来第二天，他说果然奔溃了。&lt;/p&gt;
&lt;h2 class=&quot;line&quot; data-line=&quot;11&quot;&gt;查找原因&lt;/h2&gt;
&lt;p class=&quot;line&quot; data-line=&quot;12&quot;&gt;因为更新了的版本才出现内存泄漏的问题，所以有理由怀疑，就是新增加的功能导致的内存泄漏。 新加的功能是，在一个TWaver的表格中，部分单元格中使用echart 图表来绘制。而由于代码中每次刷新的都会调用echart.init方法重新创建。导致原来创建的echart实例中创建的一些变量不能释放，所以这里怀疑，echart 如果反复删除并创建会导致内存泄漏。所以让开发人员改成了缓存的方案。&lt;br/&gt;当然由于TWaver表格的内部机制，会在重新绘制的时候，移除上一次单元格的内容，并移除内容所有父子关系。这个问题导致了，缓存方案失效。 最终的解决方案是重写了这个移除方法，不解除移除内容的父子关系。&lt;br/&gt;到此为止，应该问题是解决了。让小伙伴改进后，继续把模拟系统一直跑起来。 很不幸的是，第二天仍然奔溃。由于此时并不能直观的看出问题所在，所以需要使用一些技巧了。&lt;/p&gt;
&lt;h2 class=&quot;line&quot; data-line=&quot;16&quot;&gt;简化程序&lt;/h2&gt;
&lt;p class=&quot;line&quot; data-line=&quot;17&quot;&gt;可以确定的是，还是表格的问题导致的内存泄漏，为了避免干扰，让小伙伴把表格的核心内容拉出来写两个一个demo。 这样就可以专注于表格相关问题的定位了。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在解决一些大项目的问题的时候，如果发现一些难定位的问题，可以考虑把程序简化，抽出有问题的代码部分写小的例子。方便问题的定位，排除不必要的干扰。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 class=&quot;line&quot; data-line=&quot;20&quot;&gt;使用chrome的工具分析&lt;/h2&gt;
&lt;p&gt;首先把小伙伴写的小例子跑起来，然后打开chrome的控制台。点击memory标签：&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/6271001-fa1489291ab7caa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/512&quot; alt=&quot;memory标签&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/6271001-fa1489291ab7caa3.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;p&gt;memory标签&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;选择Allocation instrumentation on timeline，点击start，开始录制内存的记录情况，会发现有一些蓝色的条，永远不会变暗，表示这部分内存始终未被回收：&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/6271001-a4747af3879a9506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/512&quot; alt=&quot;内存记录情况&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/6271001-a4747af3879a9506.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;p&gt;内存记录情况&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;点击其中的一个蓝条，可以查看局部的内存情况，如下图所示：&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/6271001-bf8076d0a5e82158.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/512&quot; alt=&quot;内存记录情况2&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/6271001-bf8076d0a5e82158.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;p&gt;内存记录情况2&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;从中可以看到有array，system和Detached HTMLSpanElement。 我们知道Detached HTMLSpanElement表示已经脱离文档树的dom元素，它也是导致内存泄漏的一个经常的诱因，点击Detached HTMLSpanElement，查看详情：&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/6271001-312172f3dc54236c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/512&quot; alt=&quot;Detached HTML Element&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/6271001-312172f3dc54236c.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;p&gt;Detached HTML Element&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;可以看到&quot;_stringPool&quot;这样的一个数组对象，里面放的就是Span元素，引用他的就是table，而且数量有372个之多，由于小例子使用的表格只有一行一列，这么大的数量，肯定是内存泄漏导致，直接在浏览器打印这个pool，可以看出这个数量确实在一直增加（看index的情况）:&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/6271001-c982353001923c48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/512&quot; alt=&quot;内存泄漏&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/6271001-c982353001923c48.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;p&gt;内存泄漏&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;至此，查到了是那个地方发生了内存泄漏。 根据这个线索，比较容易定位到程序的逻辑问题所在，并很快就解决了问题。&lt;br/&gt;ps：同时还发现了table.__divPool也有内存泄漏的情况，通过同样的方式定位到了这个问题并最终解决。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;问题出在小伙伴对于renderCell方法的重载和release方法的重载，这个涉及到TWaver的内部逻辑，此处就不详细说明了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;欢迎关注公众号：ITman彪叔&lt;/p&gt;
</description>
<pubDate>Tue, 25 Sep 2018 03:28:00 +0000</pubDate>
<dc:creator>ITman彪叔</dc:creator>
<og:description>在最近给客户交付的一个项目中，客户反映系统跑一段时间就会奔溃掉。我的第一直觉就是可能发生了内存泄漏。 复现bug 为了能够让bug复现，我让开发的小伙，先把模拟系统在本地跑起来。要知道，bug复现是很</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flyfox1982/p/9698666.html</dc:identifier>
</item>
<item>
<title>【Java面试宝典】深入理解JAVA虚拟机 - 郭耀华</title>
<link>http://www.cnblogs.com/guoyaohua/p/9692647.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guoyaohua/p/9692647.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　　线程隔离：&lt;/strong&gt;线程隔离的意思，就是给不同的线程多分配的资源用，以做到不争用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　线程共享：&lt;/strong&gt;线程共享就是资源只有一个没有办法分配更多，只能共享。&lt;/p&gt;
&lt;p&gt;　　Java虚拟机管理的内存包括几个运行时数据内存：&lt;span&gt;&lt;strong&gt;方法区、虚拟机栈、本地方法栈、堆、程序计数器&lt;/strong&gt;&lt;/span&gt;，其中&lt;strong&gt;方法区和堆&lt;/strong&gt;是由&lt;strong&gt;线程共享的&lt;/strong&gt;数据区，其他几个是线程隔离的数据区。&lt;strong&gt;程序计数器，虚拟机栈，本地方法栈，随线程而生，线程亡而亡&lt;/strong&gt;&lt;/p&gt;
&lt;h2 class=&quot;NewStyle17&quot;&gt;&lt;strong&gt;1.1 程序计数器&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;程序计数器&lt;/strong&gt;是一块较小的内存，他可以看做是&lt;strong&gt;当前线程所执行的行号指示器&lt;/strong&gt;。字节码解释器工作的时候就是通过改变这个计数器的值来选取下一条需要执行的字节码的指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器则为空。&lt;span&gt;此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemotyError情况的区域&lt;/span&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;线程私有的内存：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　由于&lt;span&gt;&lt;strong&gt;Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现&lt;/strong&gt;&lt;/span&gt;，在任何一个确定的时间，一个处理器(对多核处理器来说是一个内核)只会执行一条线程中的指令。因此为了为了线程切换能够恢复到正确的执行位置上，每条线程都有一个独立的线程计数器，各条线程之间计数器互不影响，独立存储，我们叫这类内存区域线程私有的内存。&lt;/p&gt;
&lt;h2 class=&quot;NewStyle17&quot;&gt;&lt;strong&gt;1.2 Java虚拟机栈&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;虚拟机栈描述的是Java方法执行的内存模型：&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;每个方法在执行的同时都会创建一个栈帧用于储存&lt;em&gt;&lt;span&gt;局部变量表、操作数栈、动态链接、方法出口 &lt;/span&gt;&lt;/em&gt;等信息。每个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　栈内存就是虚拟机栈，或者说是虚拟机栈中局部变量表的部分。&lt;/p&gt;
&lt;p&gt;　　局部变量表存放了编辑期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（refrence）类型和returnAddress类型（指向了一条字节码指令的地址）&lt;/p&gt;
&lt;p&gt;　　其中64位长度的 long 和 double 类型的数据会占用两个局部变量空间，其余的数据类型只占用1个。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;局部变量表&lt;/strong&gt;所需的内存空间在编译器间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;Java虚拟机规范对这个区域规定了两种异常状况：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如果线程请求的栈深度大于虚拟机所允许的深度，将&lt;/span&gt;抛出StackOverflowError异常。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;如果虚拟机扩展时无法申请到足够的内存，就会&lt;span&gt;抛出&lt;/span&gt;&lt;/span&gt;OutOfMemoryError异常。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 class=&quot;NewStyle17&quot;&gt;&lt;strong&gt;1.3 本地方法栈&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　本地方法栈和虚拟机栈发挥的作用是非常类似的，他们的区别是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法（Native Method就是一个Java调用非Java代码的接口）服务。&lt;/p&gt;
&lt;p&gt;　　本地方法栈区域也会抛出StackOverflowError和OutOfMemoryErroy异常。&lt;/p&gt;
&lt;h2 class=&quot;NewStyle17&quot;&gt;&lt;strong&gt;1.4 Java堆&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;堆是Java虚拟机所管理的内存中最大的一块。&lt;/strong&gt;Java堆是被所有线程共享的一块内存区域，在虚拟机启动的时候创建，此内存区域的&lt;strong&gt;&lt;span&gt;唯一目的是存放对象实例&lt;/span&gt;&lt;/strong&gt;，几乎所有的对象实例都在这里分配内存。&lt;span&gt;&lt;strong&gt;所有的对象实例和数组都在堆上分配&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　Java堆是垃圾收集器管理的主要区域。Java堆细分为新生代和老年代。不管怎样，划分的目的都是为了更好的回收内存，或者更快地分配内存。&lt;/p&gt;
&lt;p&gt;　　Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。&lt;strong&gt;如果在堆中没有完成实例分配，并且堆也无法再扩展时将会&lt;span&gt;抛出OutOfMemoryError异常&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 class=&quot;NewStyle17&quot;&gt;&lt;strong&gt;1.5 方法区&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;方法区&lt;/strong&gt;它用于储存已被虚拟机加载的&lt;strong&gt;类信息、常量、静态变量、即时编译器编译后的代码&lt;/strong&gt;等数据。&lt;/p&gt;
&lt;p&gt;　　除了Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还&lt;span&gt;&lt;strong&gt;可以选择不实现垃圾收集。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;当方法区无法满足内存分配需求时，将&lt;span&gt;抛出OutOfMemoryErroy异常&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 class=&quot;NewStyle17&quot;&gt;&lt;strong&gt;1.6 运行时常量池&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;它是方法区的一部分。&lt;/strong&gt;Class文件中除了有关的版本、字段、方法、接口等描述信息外、还有一项信息是常量池，用于存放编辑期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。&lt;/p&gt;
&lt;p&gt;　　Java语言并不要求常量一定只有编辑期才能产生，也就是可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;当常量池无法再申请到内存时会&lt;span&gt;抛出OutOfMemoryError异常&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1.7 直接内存&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。&lt;/p&gt;
&lt;p&gt;　　NIO类是一种基于通道和缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个储存在Java堆中的DirectByteBuffer对象作为这块直接内存的引用进行操作，这样避免了Java堆和Navie堆中来回复制数据。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;2.1 对象的创建&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;2.1.1 检查&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.1.2 分配内存&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　接下来将为新生对象分配内存，对象所需内存在类加载完毕之后就可以完全确定，为对象分配内存空间的任务等同于把一块确定的大小的内存从Java堆中划分出来。&lt;/p&gt;
&lt;p&gt;　　假设Java堆中内存是绝对规整的，所有用过的内存放在一遍，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针指向空闲空间那边挪动一段与对象大小相等的距离，这个分配方式叫做&lt;strong&gt;“指针碰撞”。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式成为“&lt;strong&gt;空闲列表&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;选择那种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;在分配内存的时候会出现&lt;span&gt;并发的问题&lt;/span&gt;&lt;/strong&gt;，比如在给A对象分配内存的时候，指针还没有来得及修改，对象B又同时使用了原来的指针进行了内存的分片。&lt;/p&gt;
&lt;p&gt;　　有&lt;span&gt;&lt;strong&gt;两个解决方案&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;对分配的内存进行同步处理：CAS配上失败重试的方式&lt;/strong&gt;保证更新操作的原子性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;把内存分配的动作按照线程划分在不同的空间之中进行&lt;/strong&gt;，即每个线程在Java堆中分配一块小内存，称为&lt;strong&gt;本地缓冲区&lt;/strong&gt;，哪个线程需要分配内存，就需要在本地缓冲区上进行，只有当缓冲区用完并分配新的缓冲区的时候，才需要同步锁定。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;&lt;strong&gt;2.1.3 Init&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　执行new指令之后会接着执行Init方法，进行初始化，这样一个对象才算产生出来。&lt;/p&gt;
&lt;h2 class=&quot;NewStyle17&quot;&gt;&lt;strong&gt;2.2 对象的内存布局&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;NewStyle17&quot;&gt;　　在HotSpot虚拟机中，对象在内存中储存的布局可以分为3块区域：&lt;strong&gt;对象头、实例数据、对齐填充。&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;NewStyle17&quot;&gt;　　&lt;strong&gt;对象头包括两部分&lt;/strong&gt;：&lt;/p&gt;
&lt;p class=&quot;NewStyle17&quot;&gt;&lt;strong&gt;　　a)&lt;/strong&gt; 储存对象自身的运行时数据，如哈希码、GC分带年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳。&lt;/p&gt;
&lt;p class=&quot;NewStyle17&quot;&gt;&lt;strong&gt;　　b) &lt;/strong&gt;另一部分是指类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。&lt;/p&gt;
&lt;p class=&quot;NewStyle17&quot;&gt;　　&lt;strong&gt;实例数据：&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;NewStyle17&quot;&gt;　　是对象正常储存的有效信息，也是程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录下来。&lt;/p&gt;
&lt;p class=&quot;NewStyle17&quot;&gt;　　&lt;strong&gt;对齐填充:&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;NewStyle17&quot;&gt;&lt;strong&gt;　　&lt;/strong&gt;不是必然存在的，仅仅是起到占位符的作用。对象的大小必须是8字节的整数倍，而对象头刚好是8字节的整数倍(1倍或者2倍)，当实例数据没有对齐的时候，就需要通过对齐填充来补全&lt;/p&gt;
&lt;h2 class=&quot;NewStyle17&quot;&gt;&lt;strong&gt;2.3 对象的访问定位&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;2.3.1 &lt;strong&gt;使用句柄访问&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;NewStyle17&quot;&gt;　　Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址。&lt;/p&gt;
&lt;p class=&quot;NewStyle17&quot;&gt;　　&lt;span&gt;&lt;strong&gt;优势：&lt;/strong&gt;&lt;/span&gt;reference中存储的是稳定的句柄地址，在对象被移动（&lt;span&gt;垃圾收集时移动对象是非常普遍的行为&lt;/span&gt;）时只会改变句柄中的实例数据指针，而reference本身不需要修改。&lt;/p&gt;
&lt;p class=&quot;NewStyle17&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1192699/201809/1192699-20180923182110992-187960551.png&quot; alt=&quot;&quot; width=&quot;636&quot; height=&quot;311&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.3.2 &lt;strong&gt;使用直接指针访问&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;NewStyle17&quot;&gt;　　Java堆对象的布局就必须考虑如何访问类型数据的相关信息，而refreence中存储的直接就是对象的地址。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;优势：&lt;/strong&gt;&lt;/span&gt;速度更快，节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1192699/201809/1192699-20180923213722472-1110786636.png&quot; alt=&quot;&quot; width=&quot;586&quot; height=&quot;290&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;3.1 Java堆溢出&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;Java堆用于存储对象实例，只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在数量到达最大堆的容量限制后就会产生内存溢出异常。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果是&lt;strong&gt;内存泄漏&lt;/strong&gt;，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。&lt;/p&gt;
&lt;p&gt;　　如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;3.2 虚拟机栈和本地方法栈溢出&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定。关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;如果线程请求的栈深度大于虚拟机所允许的最大深度，将&lt;span&gt;抛出StackOverflowError异常&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;如果虚拟机在扩展栈时无法申请到足够的内存空间，则&lt;span&gt;抛出OutOfMemoryError异常&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在单线程下，无论由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常&lt;/p&gt;
&lt;p&gt;　　如果是多线程导致的内存溢出，与栈空间是否足够大并不存在任何联系，这个时候每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。解决的时候是在不能减少线程数或更换64为的虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;3.3 方法区和运行时常量池溢出&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。&lt;/p&gt;
&lt;p&gt;　　由于常量池分配在永久代中，可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量。&lt;/p&gt;
&lt;p&gt;　　JDK1.6 intern()方法会把首次遇到的字符串实例复制到永久代，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是一个引用。&lt;/p&gt;
&lt;p&gt;　　JDK1.7 intern()方法的实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;程序计数器、虚拟机栈、本地方法栈&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;3个区域随线程而生，随线程而灭&lt;/strong&gt;，&lt;strong&gt;在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　栈中的栈帧随着方法的进入和退出就有条不紊的执行者出栈和入栈的操作，每一个栈分配多少个内存基本都是在类结构确定下来的时候就已经确定了，这几个区域内存分配和回收都具有确定性。&lt;/p&gt;
&lt;p&gt;　　而堆和方法区则不同，一个接口的实现是多种多样的，多个实现类需要的内存可能不一样，一个方法中多个分支需要的内存也不一样，我们只能在程序运行的期间知道需要创建那些对象，分配多少内存，这部分的内存分配和回收都是动态的。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;4.1 判断对象存活&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;4.1.1 引用计数器法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;给对象添加一个引用计数器，每当由一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4.1.2 可达性分析算法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;通过一系列的成为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC ROOTS没有任何引用链相连时，则证明此对象时不可用的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Java语言中GC Roots的对象包括下面几种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　1. 虚拟机栈（栈帧中的本地变量表）中引用的对象；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　2. 方法区中类静态属性引用的对象；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　3. 方法区中常量引用的对象；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　4. 本地方法栈JNI（Native方法）引用的对象；&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;4.2 引用&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;强引用&lt;/strong&gt;&lt;/span&gt;就是在程序代码之中普遍存在的，类似Object obj = new Object() 这类的引用，&lt;strong&gt;只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;软引用&lt;/strong&gt;&lt;/span&gt;用来描述一些还有用但并非必须的元素。&lt;strong&gt;对于它在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收&lt;/strong&gt;，如果这次回收还没有足够的内存才会抛出内存溢出异常。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;弱引用&lt;/strong&gt;&lt;/span&gt;用来描述非必须对象的，但是它的强度比软引用更弱一些，被引用关联的对象只能生存到下一次垃圾收集发生之前，&lt;strong&gt;当垃圾收集器工作时，无论当前内存是否足够都会回收掉只被弱引用关联的对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;虚引用&lt;/strong&gt;&lt;/span&gt;的&lt;strong&gt;唯一目的就是能在这个对象被收集器回收时收到一个系统通知。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;4.3 Finalize方法&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4.3.1 回收方法区&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　永久代的垃圾收集主要回收两部分内容：&lt;strong&gt;废弃常量&lt;/strong&gt;、&lt;strong&gt;无用的类。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;废弃常量：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　假如一个字符串“abc”已经进入了常量池中，如果当前系统没有任何一个String对象“abc”，也就是没有任何String对象引用常量池的&quot;abc&quot;常量，也没有其他地方引用的这个字面量，这个时候发生内存回收这个常量就会被清理出常量池。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;无用的类：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1&lt;/strong&gt;.该类所有的实例都已经被回收，就是Java堆中不存在该类的任何实例；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2&lt;/strong&gt;.加载该类的ClassLoader已经被回收；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3&lt;/strong&gt;.该类对用的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法；&lt;/p&gt;
&lt;h2&gt;4.&lt;strong&gt;4 &lt;/strong&gt;垃圾收集算法&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;4.4.1 标记—清除算法(mark-sweep)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　算法分为&lt;strong&gt;标记&lt;/strong&gt;和&lt;strong&gt;清除&lt;/strong&gt;两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;不足：&lt;/strong&gt;&lt;/span&gt;一个是&lt;strong&gt;效率问题&lt;/strong&gt;，标记和清除两个过程的效率都不高；另一个是&lt;strong&gt;空间问题&lt;/strong&gt;，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4.4.2 复制算法(copying)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　他将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;不足：&lt;/strong&gt;&lt;/span&gt;将内存缩小为了原来的一半。&lt;/p&gt;
&lt;p&gt;　　实际中我们并不需要按照1:1比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，当另一个Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。&lt;/p&gt;
&lt;h3 class=&quot;NewStyle17&quot;&gt;&lt;strong&gt;4.4.3 标记整理算法(mark-compact)&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;NewStyle17&quot;&gt;　　让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。&lt;/p&gt;
&lt;h3 class=&quot;NewStyle17&quot;&gt;&lt;strong&gt;4.4.4 分代收集算法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　只是根据对象存活周期的不同将内存划分为几块。一般是把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。&lt;strong&gt;在&lt;span&gt;新生代&lt;/span&gt;中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用&lt;span&gt;复制算法&lt;/span&gt;，只需要付出少量存活对象的复制成本就可以完成收集。而&lt;span&gt;老年代&lt;/span&gt;中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用&lt;span&gt;标记清理&lt;/span&gt;或者&lt;span&gt;标记整理&lt;/span&gt;算法来进行回收。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;4.5 垃圾收集器&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;4.5.1 Serial 收集器&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　这个收集器是一个单线程的收集器，但它的单线程的意义不仅仅说明它会只使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，&lt;strong&gt;必须暂停其他所有的工作线程&lt;/strong&gt;，直到它收集结束。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4.5.2 ParNew 收集器&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　Serial 收集器的多线程版本，除了使用了多线程进行收集之外，其余行为和Serial收集器一样。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;并行：&lt;/strong&gt;指多条垃圾收集线程并行工作，但此时&lt;strong&gt;用户线程仍然处于等待状态&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;并发：指用户线程与垃圾收集线程同时执行（不一定是并行的，可能会交替执行）&lt;/strong&gt;，用户程序在继续执行，而垃圾收集程序运行于另一个CPU上。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4.5.3 Parallel Scavenge&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　是一个新生代收集器，它是使用&lt;strong&gt;复制算法的收集器&lt;/strong&gt;，又是&lt;strong&gt;并行的多线程收集器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;吞吐量：&lt;/strong&gt;就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。&lt;span&gt;&lt;strong&gt;吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4.5.4 Serial Old 收集器&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　Serial收集器的老年代版本,是一个单线程收集器，使用&lt;strong&gt;标记整理算法&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4.5.5 Parallel Old 收集器&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　Parallel Old是Paraller Seavenge收集器的老年代版本，使用&lt;strong&gt;多线程和标记整理算法&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4.5.6 CMS收集器&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;CMS并非没有暂停，而是用两次短暂停来替代串行标记整理算法的长暂停，它的收集周期是这样：&lt;/p&gt;
&lt;p&gt;　　初始标记(CMS-initial-mark) -&amp;gt; 并发标记(CMS-concurrent-mark) -&amp;gt; 重新标记(CMS-remark) -&amp;gt; 并发清除(CMS-concurrent-sweep) -&amp;gt;并发重设状态等待下次CMS的触发(CMS-concurrent-reset)。&lt;/p&gt;
&lt;p&gt;　　其中的1，3两个步骤需要暂停所有的应用程序线程的。第一次暂停从root对象开始标记存活的对象，这个阶段称为初始标记；第二次暂停是在并发标记之后， 暂停所有应用程序线程，重新标记并发标记阶段遗漏的对象（在并发标记阶段结束后对象状态的更新导致）。第一次暂停会比较短，第二次暂停通常会比较长，并且 remark这个阶段可以并行标记。&lt;br/&gt;　　而并发标记、并发清除、并发重设阶段的所谓并发，是指一个或者多个垃圾回收线程和应用程序线程并发地运行，垃圾回收线程不会暂停应用程序的执行，如果你有多于一个处理器，那么并发收集线程将与应用线程在不同的处理器上运行，显然，这样的开销就是会降低应用的吞吐量。Remark阶段的并行，是指暂停了所有应用程序后，启动一定数目的垃圾回收进程进行并行标记，此时的应用线程是暂停的。&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　&lt;/em&gt;CMS收集器是基于&lt;strong&gt;标记清除算法&lt;/strong&gt;实现的，整个过程分为4个步骤：&lt;/p&gt;
&lt;p&gt;　　1.初始标记　　2.并发标记　　3.重新标记　　4.并发清除&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/span&gt;并发收集、低停顿。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1&lt;/strong&gt;.CMS收集器对CPU资源非常敏感，CMS默认启动的回收线程数是（CPU数量+3）/4；&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　2&lt;/strong&gt;.CMS收集器无法处理浮动垃圾，可能会出现“Concurrent Mode Failure(并发模式故障)”失败而导致Full GC产生；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3&lt;/strong&gt;.CMS是基于标记清除算法实现的。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4.5.7 &lt;/strong&gt;G1收集器&lt;/h3&gt;
&lt;p&gt;　　它是一款面向服务器应用的垃圾收集器&lt;/p&gt;
&lt;p&gt;　　1.并行与并发：利用多CPU缩短STOP-The-World停顿的时间；&lt;/p&gt;
&lt;p&gt;　　2.分代收集；&lt;/p&gt;
&lt;p&gt;　　3.空间整合：不会产生内存碎片；&lt;/p&gt;
&lt;p&gt;　　4.可预测的停顿；&lt;/p&gt;
&lt;p&gt;　　运作方式：初始标记，并发标记，最终标记，筛选回收。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;4.6 内存分配与回收策略&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　MinorGC:&lt;/strong&gt;清理新生代&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　MajorGC:&lt;/strong&gt;清理老年代&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　FullGC:&lt;/strong&gt;清理整个堆空间&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4.6.1 对象优先在Eden分配&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　大多数情况对象在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4.6.2 大对象直接进入老年代&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　所谓&lt;span&gt;&lt;strong&gt;大对象&lt;/strong&gt;就是指需要大量连续内存空间的Java对象&lt;/span&gt;，最典型的大对象就是那种很长的字符串以及数组。这样做的目的是避免Eden区及两个Servivor之间发生大量的内存复制。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4.6.3 长期存活的对象将进入老年代&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　如果对象在Eden区出生并且经历过一次Minor GC后仍然存活，并且能够被Servivor容纳，将被移动到Servivor空间中，并且把对象年龄设置成为1。对象在Servivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），就将会被晋级到老年代中。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4.6.4 动态对象年龄判定&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋级到老年代，&lt;strong&gt;如果在Servivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入到老年代，无须登到MaxTenuringThreshold中要求的年龄。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4.6.5 空间分配担保&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许那么会继续检查老年代最大可用的连续空间是否大于晋级到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次MinorGC 是有风险的：如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;虚拟机把描述类的数据从Class文件加载到内存，并对数据进行&lt;span&gt;校验、转换解析和初始化&lt;/span&gt;，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在Java语言里面，类型的加载。连接和初始化过程都是在程序运行期间完成的。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;5.1 类加载的时机&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　类被加载到虚拟机内存中开始，到卸载为止，整个&lt;strong&gt;生命周期&lt;/strong&gt;包括：&lt;strong&gt;加载、验证、准备、解析、初始化、使用&lt;/strong&gt;和&lt;strong&gt;卸载&lt;/strong&gt;7个阶段&lt;/p&gt;
&lt;p&gt;　　加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以再初始化阶段之后再开始，这个是为了支持Java语言运行时绑定（也成为动态绑定或晚期绑定）。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　虚拟机规范规定有且只有5种情况必须立即对类进行初始化：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1&lt;/strong&gt;.遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2&lt;/strong&gt;.使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3&lt;/strong&gt;.当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4&lt;/strong&gt;.当虚拟机启动时候，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　5&lt;/strong&gt;.当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;被动引用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1&lt;/strong&gt;.通过子类引用父类的静态字段，不会导致子类初始化；&lt;/p&gt;
&lt;p class=&quot;NewStyle17&quot;&gt;&lt;strong&gt;　　2.&lt;/strong&gt;通过数组定义来引用类，不会触发此类的初始化；&lt;/p&gt;
&lt;p class=&quot;NewStyle17&quot;&gt;&lt;strong&gt;　　3.&lt;/strong&gt;常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化；&lt;/p&gt;
&lt;p class=&quot;NewStyle17&quot;&gt;　　4.接口的初始化：接口在初始化时，并不要求其父接口全部完成类初始化，只有在正整使用到父接口的时候（如引用接口中定义的常量）才会初始化；&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;5.2 类加载的过程&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;5.2.1 加载&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　1) &lt;/strong&gt;通过一个类的全限定名类获取定义此类的二进制字节流；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2) &lt;/strong&gt;将这字节流所代表的静态存储结构转化为方法区运行时数据结构；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3) &lt;/strong&gt;在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；&lt;/p&gt;
&lt;p&gt;怎么获取二进制字节流？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1&lt;/strong&gt;) 从ZIP包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2) &lt;/strong&gt;从网络中获取，这种场景最典型的应用就是Applet；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3) &lt;/strong&gt;运行时计算生成，这种常见使用得最多的就是动态代理技术；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4) &lt;/strong&gt;由其他文件生成，典型场景就是JSP应用；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　5) &lt;/strong&gt;从数据库中读取，这种场景相对少一些（中间件服务器）；&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数组类的创建过程遵循以下规则：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1) &lt;/strong&gt;如果数组的组件类型(指的是数组去掉一个维度的类型)是引用类型，那就递归采用上面的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2) &lt;/strong&gt;如果数组的组件类型不是引用类型(列如int[]组数)，Java虚拟机将会把数组C标识为与引导类加载器关联；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3) &lt;/strong&gt;数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public；&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;5.2.2 验证&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　验证阶段会完成下面4个阶段的检验动作：&lt;strong&gt;文件格式验证，元数据验证，字节码验证，符号引用验证&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;文件格式验证&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1) &lt;/strong&gt;是否以魔数oxCAFEBABE开头；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2) &lt;/strong&gt;主、次版本号是否在当前虚拟机处理范围之内；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3) &lt;/strong&gt;常量池的常量中是否有不被支持的常量类型(检查常量tag标志)；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4) &lt;/strong&gt;指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;5) &lt;/strong&gt;CONSTANT_Itf8_info 型的常量中是否有不符合UTF8编码的数据；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;6) &lt;/strong&gt;Class文件中各个部分及文件本身是否有被删除的或附加的其他信息；&lt;/p&gt;
&lt;p&gt;　　这个阶段的验证时基于二进制字节流进行的，只有通过类这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;元数据验证&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;strong&gt;1&lt;/strong&gt;) 这个类是否有父类(除了java.lang.Object之外,所有的类都应当有父类)；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2) &lt;/strong&gt;这个类的父类是否继承了不允许被继承的类（被final修饰的类）；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3&lt;/strong&gt;) 如果这个类不是抽象类，是否实现类其父类或接口之中要求实现的所有方法；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4&lt;/strong&gt;) 类中的字段、方法是否与父类产生矛盾(列如覆盖类父类的final字段,或者出现不符合规则的方法重载，列如方法参数都一致，但返回值类型却不同等)；&lt;/p&gt;
&lt;p&gt;第二阶段的主要目的是对类元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;字节码验证&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　第三阶段是整个验证过程中最复杂的一个阶段，主要目的似乎通过数据流和控制流分析，确定程序语言是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1) &lt;/strong&gt;保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，列如，列如在操作数栈放置类一个int类型的数据，使用时却按long类型来加载入本地变量表中；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2)&lt;/strong&gt; 保证跳转指令不会跳转到方法体以外的字节码指令上；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3) &lt;/strong&gt;保证方法体中的类型转换时有效的，列如可以把一个子类对象赋值给父类数据类型，这个是安全的，但是吧父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;符号引用验证&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1)&lt;/strong&gt; 符号引用中通过字符串描述的全限定名是否能找到相对应的类；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2) &lt;/strong&gt;在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3)&lt;/strong&gt; 符号引用中的类、字段、方法的访问性是否可被当前类访问；&lt;/p&gt;
&lt;p&gt;　　对于虚拟机的类加载机制来说，验证阶段是非常重要的，但是不一定必要（因为对程序运行期没有影响）的阶段。如果全部代码都已经被反复使用和验证过，那么在实施阶段就可以考虑使用Xverify：none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;5.2.3 准备&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量都在方法区中进行分配。这个时候进行内存分配的仅包括类变量(被static修饰的变量)，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里说的初始值通常下是数据类型的零值。&lt;/p&gt;
&lt;p&gt;　　假设public static int value = 123；那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器&amp;lt;clinit&amp;gt;()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行，但是如果使用final修饰，则在这个阶段其初始值设置为123。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;5.2.4 解析&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　解析阶段是虚拟机将常量池内符号引用替换为直接引用的过。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;5.2.5 初始化&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　类的初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才正真开始执行类中定义的Java程序代码(或者说是字节码)。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;5.3 类的加载器&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;5.3.1 双亲委派模型&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　只存在两种不同的类加载器：启动类加载器（Bootstrap ClassLoader），使用C++实现，是虚拟机自身的一部分。另一种是所有其他的类加载器，使用JAVA实现，独立于JVM，并且全部继承自抽象类java.lang.ClassLoader。&lt;/p&gt;
&lt;p&gt;　　启动类加载器（Bootstrap ClassLoader），负责将存放在&amp;lt;JAVA+HOME&amp;gt;\lib目录中的，或者被-Xbootclasspath参数所制定的路径中的，并且是JVM识别的（仅按照文件名识别，如rt.jar，如果名字不符合，即使放在lib目录中也不会被加载），加载到虚拟机内存中，启动类加载器无法被JAVA程序直接引用。&lt;/p&gt;
&lt;p&gt;　　扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现，负责加载&amp;lt;JAVA_HOME&amp;gt;\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。&lt;/p&gt;
&lt;p&gt;　　应用程序类加载器（Application ClassLoader），由sun.misc.Launcher$AppClassLoader来实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般称它为系统类加载器。负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1192699/201809/1192699-20180925105455720-77100699.png&quot; alt=&quot;&quot; width=&quot;456&quot; height=&quot;306&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这张图表示类加载器的双亲委派模型（Parents Delegation model）。双亲委派模型要求除了顶层的启动加载类外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现，而是使用组合关系来复用父类加载器的代码。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;5.3.2 双亲委派模型的工作过程是&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都是应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;5.3.3 这样做的好处就是&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object,它存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。&lt;/p&gt;
&lt;p&gt;　　就是保证某个范围的类一定是被某个类加载器所加载的，这就保证在程序中同 一个类不会被不同的类加载器加载。这样做的一个主要的考量，就是从安全层 面上，杜绝通过使用和JRE相同的类名冒充现有JRE的类达到替换的攻击方式。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;6.1 内存间的交互操作&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。此处的变量与Java编程时所说的变量不一样，指包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Java内存模型中规定了所有的变量都存储在主内存中&lt;/strong&gt;，每条线程还有自己的工作内存（可以与前面将的处理器的高速缓存类比），&lt;span&gt;&lt;strong&gt;线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行&lt;/strong&gt;&lt;/span&gt;，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1192699/201809/1192699-20180925105829916-1926538864.png&quot; alt=&quot;&quot; width=&quot;541&quot; height=&quot;243&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　lock&lt;/strong&gt;&lt;strong&gt;（锁定）&lt;/strong&gt;：作用于主内存的变量，把一个变量标识为一条线程独占状态。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;unlock&lt;/strong&gt;&lt;strong&gt;（解锁）&lt;/strong&gt;：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　read&lt;/strong&gt;&lt;strong&gt;（读取）&lt;/strong&gt;：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;load&lt;/strong&gt;&lt;strong&gt;（载入）&lt;/strong&gt;：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;use&lt;/strong&gt;&lt;strong&gt;（使用）&lt;/strong&gt;：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　assign&lt;/strong&gt;&lt;strong&gt;（赋值）&lt;/strong&gt;：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　store&lt;/strong&gt;&lt;strong&gt;（存储）&lt;/strong&gt;：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　write&lt;/strong&gt;&lt;strong&gt;（写入）&lt;/strong&gt;：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。&lt;/p&gt;
&lt;p&gt;　　如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺 序是read a，read b，load b， load a。&lt;/p&gt;
&lt;p&gt;　　Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不允许read和load、store和write操作之一单独出现。&lt;/li&gt;
&lt;li&gt;不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。&lt;/li&gt;
&lt;li&gt;不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。&lt;/li&gt;
&lt;li&gt;一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。&lt;/li&gt;
&lt;li&gt;一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。&lt;/li&gt;
&lt;li&gt;如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值。&lt;/li&gt;
&lt;li&gt;如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。&lt;/li&gt;
&lt;li&gt;对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;strong&gt;6.2 重排序&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。&lt;strong&gt;重排序分成三种类型：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.编译器优化的重排序&lt;/strong&gt;。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　2.指令级并行的重排序&lt;/strong&gt;。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3.内存系统的重排序。&lt;/strong&gt;由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。&lt;/p&gt;
&lt;p&gt;　　从Java源代码到最终实际执行的指令序列，会经过下面三种重排序：&lt;/p&gt;
&lt;p&gt;　　为了保证内存的可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。Java内存模型把内存屏障分为LoadLoad、LoadStore、StoreLoad和StoreStore四种。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;6.3 对于volatile型变量的特殊规则&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　当一个变量定义为volatile之后，它将具备两种特性：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第一&lt;/strong&gt;：保证此变量对所有线程的可见性，&lt;span&gt;这里的可见性是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。&lt;/span&gt;普通变量的值在线程间传递需要通过主内存来完成&lt;/p&gt;
&lt;p&gt;　　由于valatile只能保证可见性，在不符合以下两条规则的运算场景中，我们仍要通过加锁来保证原子性。&lt;/p&gt;
&lt;p&gt;　　1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。&lt;/p&gt;
&lt;p&gt;　　2.变量不需要与其他的状态变量共同参与不变约束。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第二&lt;/strong&gt;：禁止指令重排序，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中执行顺序一致，这个就是所谓的线程内表现为串行的语义。&lt;/p&gt;
&lt;p&gt;　　Java内存模型中对volatile变量定义的特殊规则。假定T表示一个线程，V和W分别表示两个volatile变量，那么在进行read、load、use、assign、store、write操作时需要满足如下的规则：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1）&lt;/strong&gt;只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load操作。线程T对变量V的use操作可以认为是与线程T对变量V的load和read操作相关联的，必须一起连续出现。这条规则要求在工作内存中，每次使用变量V之前都必须先从主内存刷新最新值，用于保证能看到其它线程对变量V所作的修改后的值。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　2）&lt;/strong&gt;只有当线程T对变量V执行的前一个动是assign的时候，线程T才能对变量V执行store操作；并且，只有当线程T对变量V执行的后一个动作是store操作的时候，线程T才能对变量V执行assign操作。线程T对变量V的assign操作可以认为是与线程T对变量V的store和write操作相关联的，必须一起连续出现。这一条规则要求在工作内存中，每次修改V后都必须立即同步回主内存中，用于保证其它线程可以看到自己对变量V的修改。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3）&lt;/strong&gt;假定操作A是线程T对变量V实施的use或assign动作，假定操作F是操作A相关联的load或store操作，假定操作P是与操作F相应的对变量V的read或write操作；类型地，假定动作B是线程T对变量W实施的use或assign动作，假定操作G是操作B相关联的load或store操作，假定操作Q是与操作G相应的对变量V的read或write操作。如果A先于B，那么P先于Q。这条规则要求valitile修改的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;6.4 对于long和double型变量的特殊规则&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　Java模型要求lock、unlock、read、load、assign、use、store、write这8个操作都具有原子性，但是对于64为的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作分为两次32为的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;6.5 原子性、可见性和有序性&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;原子性：&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。&lt;/strong&gt;Java内存模型是通过在变量修改后将新值同步会主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性，valatile特殊规则保障新值可以立即同步到祝内存中。Synchronized是在对一个变量执行unlock之前，必须把变量同步回主内存中（执行store、write操作）。被final修饰的字段在构造器中一旦初始化完成，并且构造器没有吧this的引用传递出去，那在其他线程中就能看见final字段的值。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;可见性：&lt;/strong&gt;&lt;/span&gt;可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;有序性：&lt;/strong&gt;&lt;/span&gt;即程序执行的顺序按照代码的先后顺序执行。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;6.6  先行发生原则&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　这些先行发生关系无须任何同步就已经存在，如果不再此列就不能保障顺序性，虚拟机就可以对它们任意地进行重排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1.程序次序规则&lt;/strong&gt;：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确的说，应该是控制顺序而不是程序代码顺序，因为要考虑分支。循环等结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.管程锁定规则&lt;/strong&gt;：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而后面的是指时间上的先后顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3.Volatile&lt;/strong&gt;&lt;strong&gt;变量规则&lt;/strong&gt;：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的后面同样是指时间上的先后顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4.线程启动规则&lt;/strong&gt;：Thread对象的start()方法先行发生于此线程的每一个动作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　5.线程终止规则&lt;/strong&gt;：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.joke()方法结束、ThradisAlive()的返回值等手段检测到线程已经终止执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　6.线程中断规则&lt;/strong&gt;：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　7.对象终结规则&lt;/strong&gt;：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　8.传递性&lt;/strong&gt;：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;6.7  Java线程调度&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　协同式调度：线程的执行时间由线程本身控制。&lt;/p&gt;
&lt;p&gt;　　抢占式调度：线程的执行时间由系统来分配。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;6.8 状态转换&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　&lt;strong&gt;　1.新建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.运行&lt;/strong&gt;：可能正在执行。可能正在等待CPU为它分配执行时间&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3.无限期等待&lt;/strong&gt;：不会被分配CUP执行时间，它们要等待被其他线程显式唤醒&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　4.限期等待&lt;/strong&gt;：不会被分配CUP执行时间，它们无须等待被其他线程显式唤醒，一定时间会由系统自动唤醒&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;5.阻塞&lt;/strong&gt;：阻塞状态在等待这获取到一个排他锁，这个时间将在另一个线程放弃这个锁的时候发生；等待状态就是在等待一段时间，或者唤醒动作的发生&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;6.结束&lt;/strong&gt;：已终止线程的线程状态，线程已经结束执行&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;　1）不可变&lt;/strong&gt;：不可变的对象一定是线程安全的、无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障。例如：把对象中带有状态的变量都声明为final，这样在构造函数结束之后，它就是不可变的。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2）绝对线程安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　3）相对线程安全：&lt;/strong&gt;相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4）线程兼容&lt;/strong&gt;：对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全使用。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;5）线程对立&lt;/strong&gt;：是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;7.1 线程安全的实现方法&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;&lt;strong&gt;互斥同步&lt;/strong&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。互斥是因，同步是果：互斥是方法，同步是目的。&lt;/p&gt;
&lt;p&gt;　　在Java中，最基本的互斥同步手段就是synchronized关键字，它经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有指明，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，对应的在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，哪当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。&lt;/p&gt;
&lt;p&gt;　　Synchronized，ReentrantLock增加了一些高级功能&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1)&lt;/strong&gt;.等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2)&lt;/strong&gt;公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；非公平锁则不能保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。Synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3)&lt;/strong&gt;锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多余一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition方法即可。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;&lt;strong&gt;非阻塞同步&lt;/strong&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;&lt;strong&gt;无同步方案&lt;/strong&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　可重入代码：也叫纯代码，可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身）而在控制权返回后，原来的程序不会出现任何错误。所有的可重入代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。&lt;/p&gt;
&lt;p&gt;　　判断一个代码是否具备可重入性：如果一个方法，它的返回结果是可预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。&lt;/p&gt;
&lt;p&gt;　　线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保障，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;7.2 锁优化&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;7.2.1 自旋锁与自适应自旋&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　&lt;strong&gt;　自旋锁&lt;/strong&gt;：如果物理机器上有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;自适应自旋转&lt;/strong&gt;：是由前一次在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自过程，以避免浪费处理器资源。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;7.2.2 锁消除&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　锁消除是指虚拟机即时编辑器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。如果在一段代码中。推上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;7.2.3 锁粗化&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　如果虚拟机检测到有一串零碎的操作都是对同一对象的加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;7.2.4 轻量级锁&lt;/strong&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;7.2.5 偏向锁&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　它的目的是消除无竞争情况下的同步原语，进一步提高程序的运行性能。如果轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把这个同步都消除掉，CAS操作都不做了。&lt;/p&gt;
&lt;p&gt;　　如果在接下俩的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要在进行同步。&lt;/p&gt;

&lt;p&gt;　　逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，成为方法逃逸。甚至还可能被外部线程访问到，比如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。&lt;/p&gt;
&lt;p&gt;　　如果一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化。&lt;/p&gt;
&lt;p&gt;栈上分配：如果确定一个对象不会逃逸出方法外，那让这个对象在栈上分配内存将会是一个不错的注意，对象所占用的内存空间就可以随栈帧出栈而销毁。如果能使用栈上分配，那大量的对象就随着方法的结束而销毁了，垃圾收集系统的压力将会小很多。&lt;/p&gt;
&lt;p&gt;　　同步消除：如果确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以消除掉。&lt;/p&gt;
&lt;p&gt;　　标量替换：标量就是指一个数据无法在分解成更小的数据表示了，int、long等及refrence类型等都不能在进一步分解，它们称为标量。&lt;/p&gt;
&lt;p&gt;　　如果一个数据可以继续分解，就称为聚合量，Java中的对象就是最典型的聚合量。&lt;/p&gt;
&lt;p&gt;　　如果一个对象不会被外部访问，并且这个对象可以被拆散的化，那程序正整执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Sep 2018 03:22:00 +0000</pubDate>
<dc:creator>郭耀华</dc:creator>
<og:description>一、运行时数据区域 线程隔离：线程隔离的意思，就是给不同的线程多分配的资源用，以做到不争用。 线程共享：线程共享就是资源只有一个没有办法分配更多，只能共享。 Java虚拟机管理的内存包括几个运行时数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guoyaohua/p/9692647.html</dc:identifier>
</item>
</channel>
</rss>