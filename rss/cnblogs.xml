<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【线段树】-敌兵布阵 --单节点更新 - 李卓伦</title>
<link>http://www.cnblogs.com/allen-lzl/p/7993093.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/allen-lzl/p/7993093.html</guid>
<description>&lt;p&gt;标签（空格分隔）： ACM&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;题意：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。&lt;br/&gt;中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:&quot;你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：&quot;我知错了。。。&quot;但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Input&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;第一行一个整数T，表示有T组数据。&lt;br/&gt;每组数据第一行一个正整数N（N&amp;lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&amp;lt;=ai&amp;lt;=50）。&lt;br/&gt;接下来每行有一条命令，命令有4种形式：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）&lt;br/&gt;(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;&lt;br/&gt;(3)Query i j ,i和j为正整数,i&amp;lt;=j，表示询问第i到第j个营地的总人数;&lt;br/&gt;(4)End 表示结束，这条命令在每组数据最后出现;&lt;br/&gt;每组数据最多有40000条命令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;对第i组数据,首先输出“Case i:”和回车,&lt;br/&gt;对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Sample Input&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1&lt;br/&gt;10&lt;br/&gt;1 2 3 4 5 6 7 8 9 10&lt;br/&gt;Query 1 3&lt;br/&gt;Add 3 6&lt;br/&gt;Query 2 7&lt;br/&gt;Sub 10 2&lt;br/&gt;Add 6 3&lt;br/&gt;Query 3 10&lt;br/&gt;End&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Sample Output&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Case 1:&lt;br/&gt;6&lt;br/&gt;33&lt;br/&gt;59&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;思路：先用build()生成一个线段树，再用updata更新，更新一个结点后同时用sumPlus更新上一个区间结点值，最后查询用query()查询该区域的结点值返回&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线段树入门题，AC代码如下&lt;/p&gt;
&lt;hr/&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;#include&amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#define MAX 50000+10&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#define rt 1,1,n&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#define lchild node&amp;lt;&amp;lt;1,left,m&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#define rchild node&amp;lt;&amp;lt;1|1,m+1,right&lt;/span&gt;
using namespace std&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;sum&lt;/span&gt;[MAX&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; A[MAX]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
void sumPlus(&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; node)
{
    &lt;span class=&quot;bu&quot;&gt;sum&lt;/span&gt;[node]&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;sum&lt;/span&gt;[node&lt;span class=&quot;op&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;sum&lt;/span&gt;[node&lt;span class=&quot;op&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
}
void build(&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; node,&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; left,&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; right)
{
    &lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; num&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(left&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;right){
        scanf(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,&lt;span class=&quot;op&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;sum&lt;/span&gt;[node])&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    }
    &lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; m&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;(left&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;right)&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    build(lchild)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    build(rchild)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    sumPlus(node)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
}
&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; query(&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; l,&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; r,&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; node,&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; left,&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; right)
{
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(l&lt;span class=&quot;op&quot;&gt;&amp;lt;=&lt;/span&gt;left&lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;r&lt;span class=&quot;op&quot;&gt;&amp;gt;=&lt;/span&gt;right)
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;sum&lt;/span&gt;[node]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; cnt&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; m&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;(left&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;right)&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(l&lt;span class=&quot;op&quot;&gt;&amp;lt;=&lt;/span&gt;m)
    cnt&lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt;query(l,r,lchild)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(r&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;m)
    cnt&lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt;query(l,r,rchild)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; cnt&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
}
void updata(&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; i,&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; add,&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; node,&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; left,&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; right)
{
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(left&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;right&lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;left&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;i){
        &lt;span class=&quot;bu&quot;&gt;sum&lt;/span&gt;[node]&lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt;add&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    }
    &lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; m&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;(left&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;right)&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(i&lt;span class=&quot;op&quot;&gt;&amp;lt;=&lt;/span&gt;m)
        updata(i,add,lchild)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(i&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;m)
        updata(i,add,rchild)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    sumPlus(node)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
}
&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; main()
{
    &lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; t,n,a,b&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    char s[&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    cin&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;t&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;&amp;lt;=&lt;/span&gt;t&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;)
    {
        printf(&lt;span class=&quot;st&quot;&gt;&quot;Case &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,i)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        cin&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;n&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        build(rt)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;while&lt;/span&gt;(scanf(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,s)&lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;s[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'E'&lt;/span&gt;)
        {
            scanf(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,&lt;span class=&quot;op&quot;&gt;&amp;amp;&lt;/span&gt;a,&lt;span class=&quot;op&quot;&gt;&amp;amp;&lt;/span&gt;b)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(s[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'Q'&lt;/span&gt;)
                printf(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,query(a,b,rt))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(s[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'S'&lt;/span&gt;)
                updata(a,&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;b,rt)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(s[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'A'&lt;/span&gt;)
                updata(a,b,rt)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        }
    }
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 06 Dec 2017 07:50:00 +0000</pubDate>
<dc:creator>李卓伦</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/allen-lzl/p/7993093.html</dc:identifier>
</item>
<item>
<title>《RabbitMQ Tutorial》译文 第 1 章 简介 - 溪边静禅</title>
<link>http://www.cnblogs.com/ramantic/p/7993047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ramantic/p/7993047.html</guid>
<description>&lt;blockquote readability=&quot;3.4659090909091&quot;&gt;
&lt;p&gt;源文来自 &lt;a href=&quot;http://www.rabbitmq.com/&quot;&gt;RabbitMQ 英文官网&lt;/a&gt;的&lt;a href=&quot;http://www.rabbitmq.com/tutorials/tutorial-one-dotnet.html&quot;&gt;教程&lt;/a&gt;，其示例代码采用了 .NET C# 语言。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RabbitMQ is a message broker: it accepts and forwards messages. You can think about it as a post office: when you put the mail that you want posting in a post box, you can be sure that Mr. Postman will eventually deliver the mail to your recipient. In this analogy, RabbitMQ is a post box, a post office and a postman.&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;RabbitMQ 是这样一个消息代理：它接收和转发消息。你可以把它相像成是一个邮局：当你把一份邮件投递到信箱时，你可确信的是邮递员先生终究会把邮件投递给接收者。在这个比喻中，RabbitMQ 扮演了信箱、邮局以及邮递员这一系列角色。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The major difference between RabbitMQ and the post office is that it doesn't deal with paper, instead it accepts, stores and forwards binary blobs of data ‒ messages.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;RabbitMQ与邮局最大的不同在于它并不处理纸质信件，取而代之的是它接收、储存以及转发二进制消息数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RabbitMQ, and messaging in general, uses some jargon.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;RabbitMQ 以及消息传递，通过会使用到一些专业术语。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Producing means nothing more than sending. A program that sends messages is a producer :&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;生产者的意思无非就是发送，一个程序在发送消息时它就是生产者：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.cfimg.com/618804/d0caf05fc0ee0695s.png&quot; alt=&quot;Markdown&quot;/&gt;&lt;/p&gt;
&lt;p&gt;A queue is the name for a post box which lives inside RabbitMQ. Although messages flow through RabbitMQ and your applications, they can only be stored inside a queue. A queue is only bound by the host's memory &amp;amp; disk limits, it's essentially a large message buffer. Many producers can send messages that go to one queue, and many consumers can try to receive data from one queue. This is how we represent a queue:&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;队列其实就是 RabbitMQ 内部的“信箱”，作为消息，尽管自 RabbitMQ 流经应用程序，但它最终只会存储于队列中。队列只会受限于主机内存和磁盘空间，本质上来讲它其实是一个庞大的消息缓存区。多个生产者可以发送消息到同一个队列，并且多个消费者也可以从同一个队列接收数据。下图是我们描绘的一个队列的模样：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.cfimg.com/618804/132a414cca2699d5s.png&quot; alt=&quot;Markdown&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Consuming has a similar meaning to receiving. A consumer is a program that mostly waits to receive messages:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;同理，消费也有着类似接收的含义，消费者就是一个主要用来等待接收消息的程序：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.cfimg.com/618804/e283ec34179ece7ds.png&quot; alt=&quot;Markdown&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Note that the producer, consumer, and broker do not have to reside on the same host; indeed in most applications they don't.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;要注意的是，生产者、消费者，以及代理之间不必存在于同一台主机，事实上大部分应用程序也不会如此。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&quot;Hello World&quot;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&quot;起步&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In this part of the tutorial we'll write two programs in C#; a producer that sends a single message, and a consumer that receives messages and prints them out. We'll gloss over some of the detail in the .NET client API, concentrating on this very simple thing just to get started. It's a &quot;Hello World&quot; of messaging.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在教程的当前部分我们会编写两个 C# 程序。作为生产者会发送一条消息，同时消费者会接收消息并将其打印出来。我们会忽略 API 当中的一些细节，把精力集中在简单的事情上从而更好的起步。这是一个“Hello World”的消息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the diagram below, &quot;P&quot; is our producer and &quot;C&quot; is our consumer. The box in the middle is a queue - a message buffer that RabbitMQ keeps on behalf of the consumer.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在下图中，&quot;P&quot; 就是生产者，&quot;C&quot;就是消费者。中间的方形盒子就是队列，即 RabbitMQ 为消费者保留的消息缓冲区。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.cfimg.com/618804/991037a5873d4772s.png&quot; alt=&quot;Markdown&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;the-.net-client-library&quot;&gt;The .NET client library&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;net-客户端库&quot;&gt;.NET 客户端库&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;RabbitMQ speaks multiple protocols. This tutorial uses AMQP 0-9-1, which is an open, general-purpose protocol for messaging. There are a number of clients for RabbitMQ in many different languages. We'll use the .NET client provided by RabbitMQ.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;RabbitMQ 支持多种协议，本教程使用的是 AMQP 0-9-1，它是公开的较为通用的消息协议。RabbitMQ 支持多种语言的客户端，在这里我们将使用 RabbitMQ 提供的 .NET 客户端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The client supports .NET Core as well as .NET Framework 4.5.1+. This tutorial will use RabbitMQ .NET client 5.0 and .NET Core so you will ensure you have it installed and in your PATH.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;RabbitMQ 提供的 .NET 客户端已支持 .NET Core 以及 .NET Framework 4.5.1+，本教程将会使用 RabbitMQ .NET client 5.0 和 .NET Core，所以你需要确认已安装成功。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;You can also use the .NET Framework to complete this tutorial however the setup steps will be different.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;你也可以使用 NET Framework 来完成本教程，然而其安装步骤会有所不同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RabbitMQ .NET client 5.0 and later versions are distributed via nuget.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;RabbitMQ .NET client 5.0 以及最新的版本是经由 Nuget 来发布的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This tutorial assumes you are using powershell on Windows. On MacOS and Linux nearly any shell will work.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本教程假定你在 Windows 操作系统中会使用 PowerShell，可以放心的是，在 MacOS 和 Linux 中几乎所有的 Shell 环境都能正常运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;setup&quot;&gt;Setup&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;First lets verify that you have .NET Core toolchain in PATH:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;首先让我们验证一下本地环境变量 PATH 中的 .NET Core 工具链:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;dotnet --help&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;should produce a help message.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这时应当产生一个帮助消息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Now let's generate two projects, one for the publisher and one for the consumer:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;现在让我们来创建两个项目，一个是发布者，一个是消费者。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;dotnet new console --name Send
mv Send/Program.cs Send/Send.cs
dotnet new console --name Receive
mv Receive/Program.cs Receive/Receive.cs&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;This will create two new directories named Send and Receive.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这一步将会创建两个文件夹，一个叫 Send，一个叫 Receive。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Then we add the client dependency.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;紧接着我们来添加客户端依赖。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;cd Send
dotnet add package RabbitMQ.Client
dotnet restore
cd ../Receive
dotnet add package RabbitMQ.Client
dotnet restore&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Now we have the .NET project set up we can write some code.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;好了，现在我们完成了 .NET 项目的安装，这样就可以写一些代码了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;sending&quot;&gt;Sending&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;发送&quot;&gt;发送&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.cfimg.com/618804/6f4b618c28f999cbs.png&quot; alt=&quot;Markdown&quot;/&gt;&lt;/p&gt;
&lt;p&gt;We'll call our message publisher (sender) Send.cs and our message consumer (receiver) Receive.cs. The publisher will connect to RabbitMQ, send a single message, then exit.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;随后我们会调用消息发布者（发送）Send.cs，以及消息消费者（接收）Receive.cs。发布者会连接 RabbitMQ，并发送一条消息，然后退出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In Send.cs, we need to use some namespaces:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在 Send.cs 中，我们需要引入一些命名空间：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;cssharp&quot;&gt;
&lt;code&gt;using System;
using RabbitMQ.Client;
using System.Text;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Set up the class:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;建立类文件：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;class Send
{
    public static void Main()
    {
        ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;then we can create a connection to the server:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;然后我们就可以创建一个通往服务器的连接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;class Send
{
    public static void Main()
    {
        var factory = new ConnectionFactory() { HostName = &quot;localhost&quot; };
        using (var connection = factory.CreateConnection())
        {
            using (var channel = connection.CreateModel())
            {
                ...
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The connection abstracts the socket connection, and takes care of protocol version negotiation and authentication and so on for us. Here we connect to a broker on the local machine - hence the localhost. If we wanted to connect to a broker on a different machine we'd simply specify its name or IP address here.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;该连接是抽象自套接字连接，为我们处理协议关于版本在协商与认证等方面的事宜。在这里，我们会连接到本地机器的一个代理，也就是 localhost。如果我们想连接到一台不同机器上的代理，只需简单地指定主机名或者 IP 地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Next we create a channel, which is where most of the API for getting things done resides.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;接下来我们将创建一个信道，它在众多的 API 中负责着事项的正确处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;To send, we must declare a queue for us to send to; then we can publish a message to the queue:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;为了能顺利的发送，我们需要先定义一个队列，然后我们就可以发布消息了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System;
using RabbitMQ.Client;
using System.Text;

class Send
{
    public static void Main()
    {
        var factory = new ConnectionFactory() { HostName = &quot;localhost&quot; };
        using(var connection = factory.CreateConnection())
        using(var channel = connection.CreateModel())
        {
            channel.QueueDeclare(queue: &quot;hello&quot;,
                                 durable: false,
                                 exclusive: false,
                                 autoDelete: false,
                                 arguments: null);

            string message = &quot;Hello World!&quot;;
            var body = Encoding.UTF8.GetBytes(message);

            channel.BasicPublish(exchange: &quot;&quot;,
                                 routingKey: &quot;hello&quot;,
                                 basicProperties: null,
                                 body: body);
            Console.WriteLine(&quot; [x] Sent {0}&quot;, message);
        }

        Console.WriteLine(&quot; Press [enter] to exit.&quot;);
        Console.ReadLine();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Declaring a queue is idempotent - it will only be created if it doesn't exist already. The message content is a byte array, so you can encode whatever you like there.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;声明队列的行为是幂等性的 - 即只有当一个队列不存在时才能被创建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When the code above finishes running, the channel and the connection will be disposed.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;当上述代码完成时，信道和连接将会被释放。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/Send/Send.cs&quot;&gt;Here's the whole Send.cs class.&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/Send/Send.cs&quot;&gt;这里是完整的 Send.cs 类文件。&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;sending-doesnt-work&quot;&gt;Sending doesn't work!&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;发送运行失败&quot;&gt;发送运行失败&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;If this is your first time using RabbitMQ and you don't see the &quot;Sent&quot; message then you may be left scratching your head wondering what could be wrong. Maybe the broker was started without enough free disk space (by default it needs at least 50 MB free) and is therefore refusing to accept messages. Check the broker logfile to confirm and reduce the limit if necessary. The configuration file documentation will show you how to set disk_free_limit.&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果这是你第一次使用 RabbitMQ，并且你没有收到“Sent”这一消息，这时你可能会抓耳挠腮，想知道是什么导致了错误。在这种情况下，有很大可能是因为代理（broker）在启动时没有足够的可用磁盘空间（默认至少需要 50M ），因此拒绝接收消息。检查代理（broker）日志文件（logfile），并进行确认以减少限制，通过查看配置文件文档，可以知晓如何设置 disk_free_limit。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;receiving&quot;&gt;Receiving&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;接收&quot;&gt;接收&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;That's it for our publisher. Our consumer is pushed messages from RabbitMQ, so unlike the publisher which publishes a single message, we'll keep it running to listen for messages and print them out.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;以上是我们的发布者。我们的消费者已开始从 RabbitMQ 上被推送了消息，与发送一条消息的发布者有所不同的是，我们会让消费者持续地监听消息并将其打印出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.cfimg.com/618804/64e426b273352fe6s.png&quot; alt=&quot;Markdown&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The code (in Receive.cs) has almost the same using statements as Send:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在 Receive.cs 类文件中，using 区域的声明代码与 Send.cs 类文件近乎相同：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using RabbitMQ.Client;
using RabbitMQ.Client.Events;
using System;
using System.Text;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Setting up is the same as the publisher; we open a connection and a channel, and declare the queue from which we're going to consume. Note this matches up with the queue that send publishes to.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;与发布者的设置一样，我们打开一个连接和信道，并且声明好队列以作好&lt;strong&gt;消费&lt;/strong&gt;的准备。需要注意的是，该队列与发布者所发送消息的队列是相匹配的（即基于同一个队列）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;class Receive
{
    public static void Main()
    {
        var factory = new ConnectionFactory() { HostName = &quot;localhost&quot; };
        using (var connection = factory.CreateConnection())
        {
            using (var channel = connection.CreateModel())
            {
                channel.QueueDeclare(queue: &quot;hello&quot;,
                                     durable: false,
                                     exclusive: false,
                                     autoDelete: false,
                                     arguments: null);
                ...
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Note that we declare the queue here, as well. Because we might start the consumer before the publisher, we want to make sure the queue exists before we try to consume messages from it.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;可以看到我们在消费者这里又声明了一次队列（QueueDeclare），在实践中，我们很可能是先启动消费者，后启动发布者。所以重复的声明代码，是当我们尝试从队列中消费消息时，确保队列总是已存在的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We're about to tell the server to deliver us the messages from the queue. Since it will push us messages asynchronously, we provide a callback. That is what EventingBasicConsumer.Received event handler does.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我们即将告知服务器从队列中向我们递送消息，因为该动作是基于异步的，所以我们需要提供回调，这便是 EventingBasicConsumer.Received 事件处理方法所要做的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using RabbitMQ.Client;
using RabbitMQ.Client.Events;
using System;
using System.Text;

class Receive
{
    public static void Main()
    {
        var factory = new ConnectionFactory() { HostName = &quot;localhost&quot; };
        using(var connection = factory.CreateConnection())
        using(var channel = connection.CreateModel())
        {
            channel.QueueDeclare(queue: &quot;hello&quot;,
                                 durable: false,
                                 exclusive: false,
                                 autoDelete: false,
                                 arguments: null);

            var consumer = new EventingBasicConsumer(channel);
            consumer.Received += (model, ea) =&amp;gt;
            {
                var body = ea.Body;
                var message = Encoding.UTF8.GetString(body);
                Console.WriteLine(&quot; [x] Received {0}&quot;, message);
            };
            channel.BasicConsume(queue: &quot;hello&quot;,
                                 autoAck: true,
                                 consumer: consumer);

            Console.WriteLine(&quot; Press [enter] to exit.&quot;);
            Console.ReadLine();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/Receive/Receive.cs&quot;&gt;Here's the whole Receive.cs class.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/Receive/Receive.cs&quot;&gt;这里是完整的 Receive.cs 类文件&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;putting-it-all-together&quot;&gt;Putting It All Together&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;融合一起&quot;&gt;融合一起&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;Open two terminals.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;打开两个终端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Run the consumer:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;运行消费者：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;cd Receive
dotnet run&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Then run the producer:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;紧接着运行生产者：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;cd Send
dotnet run&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The consumer will print the message it gets from the publisher via RabbitMQ. The consumer will keep running, waiting for messages (Use Ctrl-C to stop it), so try running the publisher from another terminal.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;消费者会经由 RabbitMQ 打印出那些来自发布者的消息。消费者会持续运行，以等待消息（使用 Ctrl-C 来终止运行），如此，我们可以尝试从其他终端来运行发布者（重复运行多个生产者实例程序）。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 06 Dec 2017 07:46:00 +0000</pubDate>
<dc:creator>溪边静禅</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ramantic/p/7993047.html</dc:identifier>
</item>
<item>
<title>【原创精品】程序员最强大的利器——电子笔记本的思考（1）（ver0.3） - EverSteins</title>
<link>http://www.cnblogs.com/eversteins/p/7992480.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eversteins/p/7992480.html</guid>
<description>&lt;p&gt;【原创精品】程序员最强大的利器，本文以下内容全都是作者EverStenis（胡佳吉）的原创，未经授权不得转载，抄袭必究。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我想问大家一个问题，对于我们程序员来说，在我们的武器工具库中，最强大的一件利器是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答案是：电子笔记本（也就是，云笔记）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;学会如何高效使用这件工具，可以让我们编程效率以及做事规划事半功倍！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;陶哲轩在《解题·成长·快乐——陶哲轩教你学数学》中着重强调，用纸笔来“缓存”思维对于数学解题的重要性：&lt;/p&gt;
&lt;p&gt;用选定的符号表达你所知道的信息，并画一个示意图。把所有信息写在纸上，有三点好处：&lt;/p&gt;
&lt;p&gt;a）解题时，便于思考；&lt;/p&gt;
&lt;p&gt;b）陷入困境时，可以盯着纸进行思考；&lt;/p&gt;
&lt;p&gt;c）把知道的写下来，这个过程本身可以激发新的灵感和联想。&lt;/p&gt;
&lt;p&gt;但请注意，不要写下过多的信息和细节。一种折中的办法是着重强调那些你认为最有用的事实，而把那些令人怀疑的、冗杂的或异想天开的想法写在另一张草稿纸上。&lt;/p&gt;

&lt;p&gt;同样地，刘未鹏在他的《暗时间》里更是用了多个章节（例如，章节“书写是为了更好的思考”、章节“跟波利亚学解题”等），全面阐述了将自己的思维过程详细地写下来的各种好处。&lt;/p&gt;

&lt;p&gt;以上的作者们都是强调用纸笔记录作为&lt;span&gt;&lt;strong&gt;思维缓存&lt;/strong&gt;&lt;/span&gt;来思考，&lt;strong&gt;&lt;span&gt;而不是&lt;/span&gt;&lt;span&gt;光凭脑中默想&lt;/span&gt;&lt;/strong&gt;的好处（人的工作记忆限制等诸多缺陷）。但是现在有了&lt;span&gt;&lt;strong&gt;电子笔记本&lt;/strong&gt;&lt;/span&gt;，有了这样的更加趁手的现代化电子工具，就有了更好的替代选择（这样就是用屏幕来呈现思维缓存），因为它相比使用纸笔有更多的好处和优势。这里我强烈推荐大家使用电子笔记本作为自己最主要的信息记录工具，至少不是以纸笔记录作为自己唯一的信息记录方式。&lt;/p&gt;

&lt;p&gt;使用电子笔记本来集中统一地记录和管理笔记，相比使用纸质笔记本记录，有很多优势，主要理由如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;why &lt;/span&gt;&lt;/span&gt;使用&lt;span&gt;&lt;span&gt;&lt;span&gt;电子&lt;/span&gt;&lt;/span&gt;笔记本&lt;/span&gt;来记录，而不是使用纸笔：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;key1&lt;/span&gt;）如果将大脑记忆看作为我们大脑的内存和本地内置&lt;/strong&gt;硬盘（&lt;strong&gt;磁盘&lt;/strong&gt;），那么电子笔记本就相当于我们大脑的外置&lt;strong&gt;硬盘&lt;/strong&gt;（&lt;strong&gt;磁盘&lt;/strong&gt;）——而“搜索”是电子笔记本最强大的功能：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;电子笔记本能充当&lt;strong&gt;你&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;大脑的&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;外置硬盘&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;”&lt;/strong&gt;&lt;span&gt;功能&lt;/span&gt;，它是一种新形态的无形的外部电子存储记忆，实质上地扩充了我们的大脑容量&lt;span&gt;，说是“第二大脑”都不显夸张。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在这里我们可以大胆脑洞一下，你可以将现阶段的电子笔记本想象为，日本漫画家士郎正宗在《攻壳机动队》科学幻想的未来世界中所描绘的“电子脑”（即脑部电子化，使之成为为机器增强的人脑）的初级形态，尽管目前阶段的电子笔记本提供的功能还十分简陋。&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一方面，它可以很好地&lt;/span&gt;&lt;span&gt;弥补人类记忆能力有限的先天不足，使得我们能够放心地暂时遗忘——因为它们就在那里，减轻了原本全都需要记住在脑子里的心智负担；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而另一方面，由于及时地就把笔记保存到电子笔记本中，让我们能够尽可能地将随着时间流逝所必然会发生的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;记忆的遗忘损失率&lt;/span&gt;&lt;/strong&gt;降到最小，同时也让我们能够尽可能最大限度地提高我们&lt;strong&gt;过去曾经所看到过的、或所学到过的&lt;span&gt;知识的有效利用率&amp;amp;复用率&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;而且，&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;这样做也能缓解我们产生诸如&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;“读书早晚会忘，为什么还要读书？”&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;、&lt;/span&gt;&lt;strong&gt;&lt;span&gt;“读书到底有什么用？”&lt;/span&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;span&gt;“学这东西有什么用啊？”&lt;/span&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;span&gt;“以后注定迟早总会忘记的，现在学也没有多少意义”&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;、&lt;/span&gt;&lt;strong&gt;&lt;span&gt;“我读了这么多年书，到底有什么用？”&lt;/span&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;span&gt;“究竟为什么要学那些‘&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;没用&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;’的课？”&lt;/span&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;span&gt;“难道我们的学习只能‘&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;被动地接受知识，大量刷题，准备考试，然后忘掉大部分&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;’？&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;”&lt;/span&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;span&gt;“&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;为什么很多大学生毕业后都说大学所学知识无用？&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;的焦虑、不自信和自我怀疑。&lt;/span&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;电子笔记本的&lt;/span&gt;&lt;span&gt;搜索&lt;/span&gt;&lt;span&gt;功能，可以说是它相较于纸质笔记本的最大优势之所在。学会&lt;/span&gt;&lt;span&gt;善用&lt;/span&gt;&lt;span&gt;搜索&lt;/span&gt;&lt;span&gt;，更多&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;频繁地使用keyword搜索&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;而不是一条条笔记地逐条去找&lt;/span&gt;&lt;span&gt;，这样做能帮助我们大幅提升工作效率、节省大量时间。&lt;/span&gt;&lt;span&gt;使用电子&lt;/span&gt;&lt;/strong&gt;笔记本的&lt;span&gt;关键词搜索&lt;/span&gt;&lt;strong&gt;功能&lt;/strong&gt;，和搜索引擎的用法类似，&lt;/span&gt;你可以在大脑的内存和本地内置电子笔记本的搜索框中，&lt;span&gt;直接输入&lt;/span&gt;关键词（keyword）（通常都是先定位到其中的一个笔记本；但偶尔有时则是在全笔记本的根目录下进行全局搜索），以快速定位到既有资料中所有包含该关键词的相关笔记，来迅速查阅和回顾你既有的所有与该记忆相关的所有信息。只要你脑中还有相关信息的一个keyword（关键词），就能找出与之相关的所有信息，&lt;strong&gt;即便其中有很大一部分你以为自己好似已经完全遗忘了，电子笔记本也能辅助你重新恢复那些你已经模糊淡忘的记忆和细节——哪怕有些记忆对你已经很久远了，从而也&lt;/strong&gt;&lt;strong&gt;帮助你&lt;/strong&gt;&lt;strong&gt;起到了&lt;/strong&gt;&lt;strong&gt;温故知新与巩固你的长时记忆的效果。&lt;/strong&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;而如果使用纸质笔记本，&lt;span&gt;根本无法&lt;/span&gt;&lt;strong&gt;&lt;span&gt;搜索&lt;/span&gt;&lt;/strong&gt;，&lt;span&gt;也很难不断地动态&lt;/span&gt;&lt;span&gt;&lt;strong&gt;分类&lt;/strong&gt;&lt;/span&gt;——然而搜索的需求，在这越来越信息爆炸的时代，只会日益变得愈发强烈。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;key2&lt;/span&gt;）集中统一地管理资料，而不是分散零碎：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过使用电子笔记本，就能帮助你&lt;strong&gt;&lt;span&gt;集中聚合而统一&lt;/span&gt;&lt;span&gt;地&lt;/span&gt;管理你的所有信息&lt;/strong&gt;（包括，读书笔记&amp;amp;研究笔记&amp;amp;网页收藏&amp;amp;灵感和想法&amp;amp;杂事和零碎信息&amp;amp;日志log&amp;amp;......），以便于形成&lt;strong&gt;属于你自己独有的个性化的&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;系统化知识库&lt;/span&gt;&lt;/strong&gt;。也非常有利于你把过去收集的杂乱素材有序地组织起来（一般就是在电子笔记本中，通过频繁地“keyword”搜索来查找既有资料）。&lt;/p&gt;

&lt;p&gt;并且因为电子笔记本不占用任何实体空间，所以可以随时随身携带（只要你记得账号和密码）。&lt;/p&gt;

&lt;p&gt;否则，假若你不使用先进的电子笔记本来管理你的各种信息，而仍还是和过去一样用纸质资料来记录和存储信息，那么随着时间的累积，分散在各处的、数量庞大的纸质资料势必将会占用越来越多的大量的现实实体空间，并且将越来越无序地散乱在各处。想象一下你翻箱倒柜满头大汗地遍地查找到处散乱的纸质资料的场景吧，我想你肯定会崩溃的。&lt;/p&gt;

&lt;p&gt;相反，如果使用电子笔记本，只需安装一款虚拟的电子笔记本软件，就能把你收集的所有信息汇集到一个地方，十分简洁得让你能集中统一地管理它们，而且从而实现无纸化，绝对绿色环保。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;key3&lt;/span&gt;）文本编辑更加高效，也更易于管理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;电子笔记本使得你的&lt;strong&gt;文本编辑&lt;/strong&gt;更加高效也更易于管理（例如，一条笔记中的多处文本内容、或一条或多条笔记、或一个或多个笔记目录，它们的移动&amp;amp;添加&amp;amp;复制&amp;amp;删除&amp;amp;修改&amp;amp;搜索等等）。例如，你可以在一条笔记中随意地重新整理内容、重新调整位置，你也可以对笔记的内容自由地加以补充、改动、移动或删除。与之相反，使用纸质笔记本，想要复制文本、移动文本、或者删除文本等都是非常头疼的问题，难道你要将写在纸上的内容擦掉后再全部重写吗？更别提，如何把多个纸质笔记本的内容整合到一起的问题了。&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;此外，电子笔记本支持的记录形式也更丰富，比如你可能会经常需要将截图的图片粘贴到电子笔记本的某个笔记中。&lt;/p&gt;
&lt;p&gt;另外分享一个使用电子笔记本的小tip，问：如何将有格式的文字纯文本粘贴到电子笔记本中？ 答案是：按下键盘上的Ctrl-Shft-V，这样做是直接粘贴为无格式的纯文本，但恐怕大多数用户不知道。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;所以，电子笔记本更适合随意的记录和持续的完善；&lt;span&gt;&lt;strong&gt;而纸质笔记本，受限于本身介质的缘故，在文本编辑&amp;amp;整理搜寻&amp;amp;笔记管理等功能上，有诸多不便和局限。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;特别对于经常写文章的人而言“修改”是一个非常高频的动作，使用电子笔记本可以非常方便你反复&lt;span&gt;&lt;strong&gt;修改&amp;amp;移动&lt;/strong&gt;&lt;/span&gt;，这是电子笔记本的一个巨大优势。&lt;/p&gt;

&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;4）电子笔记本能支持&lt;strong&gt;多平台云端同步&lt;/strong&gt;（电脑、浏览器，手机、平板电脑等）。由于你电子笔记本的所有数据都有在云端备份，因而只要你随身带有一台支持电子笔记本的设备，那么无论在哪，你都能随时方便地搜索查阅你自己数字笔记本中的所有资料（除非你因为网络环境或软件问题等原因导致无法启动数字笔记本的云端同步功能），这些笔记是随时随地触手可及的，这样就可能帮助你利用不少碎片时间。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;5）电子笔记本&lt;strong&gt;在云端有备份&lt;/strong&gt;，也就是说在本地和云端一共有2份数据备份，同时你也可以把电子笔记本的本地数据库备份到自己的移动设备上（例如，移动硬盘、U盘、网盘等等），这样你就有了至少3份备份，因而相比纸质笔记本，数据更不容易遗失。&lt;/p&gt;
&lt;p&gt;     更何况，就如上面已经有所提到的，数字笔记本不占用任何实体空间，而纸质笔记本随着笔记的增多非常不利于整理和找寻，同时搬家时搬运笔记或者找笔记都是件麻烦事而且还容易弄丢。&lt;/p&gt;

&lt;p&gt;6）平时网络上看到的好文章，可以随时&lt;span&gt;&lt;strong&gt;收藏&lt;/strong&gt;&lt;/span&gt;至电子笔记本中，并为其添加相关的&lt;strong&gt;&lt;span&gt;标签&lt;/span&gt;（tag）&lt;/strong&gt;。不过一般更为常用的分类方式是，你只需要将收藏文章&lt;span&gt;&lt;strong&gt;保存到相应的笔记本目录&lt;/strong&gt;&lt;/span&gt;即可。即，通过把不同笔记&lt;strong&gt;归类&lt;/strong&gt;到不同的笔记本目录下的这种方式，这应该是你最主要的分类方法；其次再另一种分类方法的选择就是，在归类到某个笔记本后的基础上再打上标签。&lt;/p&gt;

&lt;p&gt;7）&lt;strong&gt;“信息录入”速度更快：&lt;/strong&gt;况且，用纸笔记录，&lt;strong&gt;&lt;span&gt;写字的速度是很难比上打字的速度的，打字输入的效率明显要比手写输入高很多。&lt;/span&gt;&lt;/strong&gt;要知道每个周期时间内，你的意志力和精力是有限的，而用纸笔记录相比使用电子笔记本记录会浪费你更多的时间，而这原本的时间你可以用在更有价值的地方。而且更不用说，电子笔记本以完全数字化的方式来实现信息的保存和管理，在这个大规模互联网的数字时代再用纸笔作为主要记录和保存的方式就太落伍太out了。&lt;/p&gt;

&lt;p&gt;8）用电子笔记本后，就可以使用由我&lt;strong&gt;&lt;strong&gt;&lt;span&gt;胡佳吉&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;原创发明的&lt;strong&gt;&lt;strong&gt;&lt;span&gt;enote笔记法&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;（包括&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;enote笔记语言&lt;/span&gt;&lt;/strong&gt;）来辅助自己简洁高效地&lt;strong&gt;做读书笔记&lt;/strong&gt;、以及用来作为对某个问题或主题进行&lt;strong&gt;深度思考&lt;/strong&gt;的速记笔记与分析的一种思维工具和方法论等。&lt;/p&gt;
&lt;p&gt;............&lt;/p&gt;

&lt;p&gt;包括这本书的编写，由于我为了力求精准和简凝地表达，条理清晰地逻辑组织，因而需要不断地修改、增删，筛选、分类、归并、精简、反复斟酌地编写，用纸质笔记本是几乎很难完成的，因此本书的全部内容都是我在电子笔记本中编辑完成的，没有使用其他任何的文字处理软件。其实对于绝大多数和我一样只有一般需求的用户而言，只需要任选择一款自己喜欢的电子笔记本软件（如有道云笔记、Evernote、Onenote、Wiz为知等）就完全足够用了。&lt;/p&gt;

&lt;p&gt;至于那些顽固不化的怀旧厨、或者晒字优越党，我想说，不是让你们完全不使用纸笔记录，而是建议你们是时候应该尝试一下新时代的新工具了。如果只是为了练字的话，可以仅在练字时间再用纸笔，而不是事事都用纸笔记录。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;参考文献：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[1] 《&lt;span&gt;解题·成长·快乐——陶哲轩教你学数学&lt;/span&gt;》，&lt;span&gt;陶哲轩著，于青林译，北京大学出版社，2009。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[2] 《暗时间》，刘未鹏著，电子工业出版社，2011。&lt;/p&gt;

&lt;div readability=&quot;15&quot;&gt;&lt;strong&gt;作者姓名&lt;/strong&gt;&lt;strong&gt;（本人的真实姓名）&lt;/strong&gt;：胡佳吉  
&lt;p&gt;&lt;strong&gt;居住地&lt;/strong&gt;：上海&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作者网名&lt;/strong&gt;：EverSteins&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版权声明&lt;/strong&gt;：2017年12月6日。以上的所有内容全部都是EverSteins（胡佳吉）的原创，本文的版权归EverSteins（胡佳吉）所有，任何形式转载请联系作者。未经授权不得转载，抄袭必究。&lt;/p&gt;

&lt;p&gt; -------------------------------------------------------------------------------------------------------&lt;br/&gt; 不知道怎么的，文章发布后的文字字体大小、颜色、格式总会有些稍微不对的地方，所以再发一张截屏的jpg版本：&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/329411/201712/329411-20171206142143019-471492932.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;div readability=&quot;9.5&quot;&gt;-------------------------------------------------------------------------------------------------------------------
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;备注：这里的内容全部都是我的原创，本文的版权归胡佳吉（EverSteins）所有，转载请联系作者授权，抄袭必究。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


</description>
<pubDate>Wed, 06 Dec 2017 06:23:00 +0000</pubDate>
<dc:creator>EverSteins</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/eversteins/p/7992480.html</dc:identifier>
</item>
<item>
<title>Azure IoT Edge on Windows 10 IoT Core - 施炯</title>
<link>http://www.cnblogs.com/dearsj001/p/AzureIoTEdge4WindowsIoTCore.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dearsj001/p/AzureIoTEdge4WindowsIoTCore.html</guid>
<description>&lt;p&gt;        在今年的Build大会上，微软推出了Azure IoT Edge的第一个版本（&lt;a href=&quot;https://github.com/Azure/iot-edge&quot;&gt;https://github.com/Azure/iot-edge&lt;/a&gt; ）。该版本的主要特点就是将计算能力由Azure端推送至边缘设备Azure IoT Edge，减少了数据在云端传输耗费的时间，加快响应时间。举例来说，Azure IoT Edge设备可以作为网关设备，进行数据的预处理和分析，以减少IoTHub数据传输的延迟时间。同时，该版本支持多种现场总线的设备将数据接入Azure IoT Edge设备，再由Azure IoT Edge设备统一与Azure IoTHub进行数据交互。&lt;/p&gt;
&lt;p&gt;        在今年11月份的Connect大会上，微软宣布对Azure IoT Edge公开预览版（文档链接为：&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/iot-edge&quot;&gt;https://docs.microsoft.com/en-us/azure/iot-edge&lt;/a&gt; ），已在美国中西部、北欧和东亚地区上线，其他区域也将分批开通。Azure IoT Edge支持Windows、Linux、x64与ARM等平台与架构，可使用基于Docker的Linux或Windows容器。支持C#、C与Python等开发语言。微软同时也发布了适用于Azure IoT Edge的AI套件，以协助开发人员进行边缘AI的应用开发（&lt;a href=&quot;https://github.com/Azure/ai-toolkit-iot-edge&quot;&gt;https://github.com/Azure/ai-toolkit-iot-edge&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;        本文将以运行Windows 10 IoT Core的MinnowBoard MAX为例，详细讲述Windows 10 IoT Core（Build 16299）的安装、Docker的部署、Python和Iotedgectl工具的安装、IoT Edge Device的创建、Module的部署与运行。&lt;/p&gt;

&lt;p&gt;        MinnowBoard MAX是相对而言比较老的板子了，其处理器是Intel Atom的E8325，双核1.3G的主频，可以运行64位的系统。要在MinnowBoard MAX运行Windows 10 IoT Core Build 16299（因为运行Azure IoT Edge运行时的最低系统版本是16299），需要进行固件更新、系统镜像烧写和Bios设置这三个步骤。&lt;/p&gt;
&lt;h2&gt;1.1 固件更新&lt;/h2&gt;
&lt;p&gt;        固件更新需要到Intel的官网下载下载最新文件，链接地址为：&lt;a href=&quot;https://firmware.intel.com/projects/minnowboard-max&quot;&gt;https://firmware.intel.com/projects/minnowboard-max&lt;/a&gt;，笔者写文章时，其最新的版本为0.97，如下图所示，&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140657722-1817397392.jpg&quot;&gt;&lt;img title=&quot;clip_image002&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140657988-632215746.jpg&quot; alt=&quot;clip_image002&quot; width=&quot;484&quot; height=&quot;561&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        然后，请参考《&lt;a href=&quot;http://www.cnblogs.com/dearsj001/p/WindowsIoTMBM_1.html&quot;&gt;Windows 10 IoT Serials 1 - 针对Minnow Board MAX的Windows 10 IoT开发环境搭建&lt;/a&gt;》一文的第3部分文档，更新固件。需要注意的是，目前微软发布的针对Minnow Board MAX的Windows 10 IoT Core就是64位的，所以，更新的固件也要选择64位版本的。也就是说，需要用的文件是两个64位固件相关的文件，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140658222-40024980.jpg&quot;&gt;&lt;img title=&quot;clip_image004&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140658378-1663960878.jpg&quot; alt=&quot;clip_image004&quot; width=&quot;484&quot; height=&quot;80&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1.2 系统镜像烧写&lt;/h2&gt;
&lt;p&gt;        系统镜像烧写，最简单的方法就是下载官方的&lt;a href=&quot;https://developer.microsoft.com/en-us/windows/iot/docs/iotdashboard&quot;&gt;Windows 10 IoT Core Dashboard&lt;/a&gt; 软件，点击设置新设备，选择设备类型、OS版本、设备名称，设置要密码，点击下载并安装。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140658534-1813515292.jpg&quot;&gt;&lt;img title=&quot;clip_image006&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140658675-754862080.jpg&quot; alt=&quot;clip_image006&quot; width=&quot;484&quot; height=&quot;327&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        注意，这里一定要下载16299版本以上的OS。&lt;/p&gt;
&lt;h2&gt;1.3 BIOS设置&lt;/h2&gt;
&lt;p&gt;        系统镜像烧写完成以后，需要设置Minnow Board MAX的BIOS，主要修改的是Boot的顺序。具体方法可以参考参考《&lt;a href=&quot;http://www.cnblogs.com/dearsj001/p/WindowsIoTMBM_1.html&quot;&gt;Windows 10 IoT Serials 1 - 针对Minnow Board MAX的Windows 10 IoT开发环境搭建&lt;/a&gt;》一文的第5部分文档，依次完成对“Manager -&amp;gt; System Setup -&amp;gt; South Cluster Configuration -&amp;gt; LPSS &amp;amp; SCC Configuration”和“Boot Mainenance Manager-&amp;gt; Boot Options &amp;gt; Change Boot Order”的设置。&lt;/p&gt;

&lt;p&gt;        系统安装完成之后，给Minnow Board MAX连接网线，上电。第一次运行的时候，会经历一些设置，所以速度相对较慢。系统运行以后，实用PowerShell工具连接局域网内的Minnow Board MAX设备，具体可以参考这个文档《&lt;a href=&quot;https://docs.microsoft.com/windows/iot-core/connect-your-device/powershell&quot;&gt;login remotely with PowerShell&lt;/a&gt;》。注意，这里实用的用户名和密码就是之前烧写系统镜像时候设置的。&lt;/p&gt;
&lt;p&gt;        之后，逐步运行以下指令：&lt;/p&gt;
&lt;p&gt;        Invoke-WebRequest https://master.dockerproject.org/windows/x86_64/docker-17.06.0-dev.zip -o temp.zip&lt;/p&gt;
&lt;p&gt;        Expand-Archive .\temp.zip $env:ProgramFiles -f&lt;/p&gt;
&lt;p&gt;        Remove-Item .\temp.zip&lt;/p&gt;
&lt;p&gt;        $env:Path += &quot;;$env:programfiles\docker&quot;&lt;/p&gt;
&lt;p&gt;        SETX /M PATH &quot;$env:Path&quot;&lt;/p&gt;
&lt;p&gt;        dockerd --register-service&lt;/p&gt;
&lt;p&gt;        start-service docker&lt;/p&gt;
&lt;p&gt;        以上脚本运行之后，会在Minnow Board MAX设备上安装Docker，设置环境变量，并启动Docker服务。&lt;/p&gt;

&lt;p&gt;        在PowerShell中，运行以下脚本：&lt;/p&gt;
&lt;p&gt;        Invoke-Expression (Invoke-WebRequest -useb &lt;a href=&quot;https://aka.ms/iotedgewin&quot;&gt;https://aka.ms/iotedgewin&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;        注意，该指令会按照脚本文件执行，如果不做更改的话，会提示以下错误。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140658831-2119375410.jpg&quot;&gt;&lt;img title=&quot;clip_image008&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140658988-263244769.jpg&quot; alt=&quot;clip_image008&quot; width=&quot;484&quot; height=&quot;95&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        即下载安装的Docker版本是17.06，但是，打开下载的PowerShell脚本会发现，里面的要求是17.09，所以，需要下载该脚本文件，并对其中的第38行的DockerVersion进行修改，将17.09改为17.06，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140659128-974759733.jpg&quot;&gt;&lt;img title=&quot;clip_image010&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140659347-469186950.jpg&quot; alt=&quot;clip_image010&quot; width=&quot;484&quot; height=&quot;241&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        修改之后，通过文件共享、FTP等方式，将该文件传输到Minnow Board MAX设备上，如C盘根目录，之后，通过PowerShell执行以下指令：&lt;/p&gt;
&lt;p&gt;        C:\Install-IotEdgeRequirements.ps1&lt;/p&gt;
&lt;p&gt;        这样，就通过PowerShell来执行本地的脚本文件了，这个过程中，会下载Python和IoTedgectl工具，根据网络连接的情况，可能会占用较长的时间。如果下载和安装正确的话，会通过PowerShell返回提示，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140659519-370179381.png&quot;&gt;&lt;img title=&quot;clip_image012&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140659675-1501030484.png&quot; alt=&quot;clip_image012&quot; width=&quot;484&quot; height=&quot;273&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        另外，可以通过iotedgectl help命令查看其能够接受的命令。&lt;/p&gt;
&lt;p&gt;        现在，我们需要通过Docker将IoTedge Agent 和 IoTedge Hub这两个模块 Pull到本地，即在PowerShell中分别运行：&lt;/p&gt;
&lt;p&gt;        docker pull microsoft/azureiotedge-agent:1.0-preview&lt;/p&gt;
&lt;p&gt;        docker pull microsoft/azureiotedge-hub:1.0-preview&lt;/p&gt;
&lt;p&gt;        如果一切安装正常的话，到这一步就完成安装了。&lt;/p&gt;

&lt;p&gt;        目前，IoT Edge Device是通过Azure IoTHub来通信的，所以，需要在Azure订阅上创建一个IoTHub，具体可以参考《&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-create-through-portal&quot;&gt;Create an IoT hub using the Azure portal&lt;/a&gt;》。注意，免费的F1级别已经足够。&lt;/p&gt;
&lt;p&gt;创建IoTHub之后，可以选择IoT Edge (preview) -Add IoT Edge Device，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140659847-1291835446.jpg&quot;&gt;&lt;img title=&quot;clip_image014&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140659988-309144819.jpg&quot; alt=&quot;clip_image014&quot; width=&quot;484&quot; height=&quot;442&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        输入名称，以“MinnowBoard”为例，点击OK。&lt;/p&gt;
&lt;p&gt;        等待创建完成之后，进入设备信息页面，拷贝其连接的Connection String，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140700113-1973686510.jpg&quot;&gt;&lt;img title=&quot;clip_image016&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140700269-1461630277.jpg&quot; alt=&quot;clip_image016&quot; width=&quot;484&quot; height=&quot;325&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;        IoT Edge runtime由两个模块组成，即IoT Edge agent和IoT Edge hub。IoT Edge agent负责部署并监控部署到IoT Edge设备上的Modules。IoT Edge hub负责部署的Modules之间的通信、以及设备和IoTHub总线的通信。&lt;/p&gt;
&lt;p&gt;        其配置同样通过PowerShell执行：&lt;/p&gt;
&lt;p&gt;        iotedgectl setup --connection-string &quot;{device connection string}&quot; --auto-cert-gen-force-no-passwords&lt;/p&gt;
&lt;p&gt;        其中的&quot;{device connection string}&quot;由上面第4步中保存的Connection String来代替。&lt;/p&gt;
&lt;p&gt;        之后，就可以通过以下指令开始运行：&lt;/p&gt;
&lt;p&gt;        iotedgectl start&lt;/p&gt;
&lt;p&gt;        同时，可以通过以下指令来检查IoT Edge agent是否已经运行：&lt;/p&gt;
&lt;p&gt;        docker ps&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140700394-882466050.jpg&quot;&gt;&lt;img title=&quot;clip_image018&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140700597-1867991026.jpg&quot; alt=&quot;clip_image018&quot; width=&quot;484&quot; height=&quot;32&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;        Azure IoT Edge其中一个重要的特性就是支持云端动态部署Module到IoT Edge Device端。每个Module都是在容器中运行的程序包。Module支持Azure Service，如Azure Functions, Azure Stream Analytics和 Azure Machine Learning；也支持用户自定义的Module，可以用Java, .NET Core 2.0, Node.js, C, and Python等多种语言实现。&lt;/p&gt;
&lt;p&gt;        这里，我们利用微软已写好的Module进行部署，该Module会每隔5秒钟产生温湿度、大气压的数据，并上传到IoTHub。具体步骤如下：&lt;/p&gt;
&lt;p&gt;        首先，在Azure Portal中，导航到刚刚创建的IoTHub，依次点击“IoT Edge (preview)”-“Set Modules”-“Add IoT Edge Module”，在弹出的设置页面中，点击Add IoT Edge Module，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140700784-679823953.jpg&quot;&gt;&lt;img title=&quot;clip_image020&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140700909-656791061.jpg&quot; alt=&quot;clip_image020&quot; width=&quot;484&quot; height=&quot;293&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        输入名称和“Image URI”，其中“Image URI”设置为：&lt;/p&gt;
&lt;p&gt;        microsoft/azureiotedge-simulated-temperature-sensor:1.0-preview&lt;/p&gt;
&lt;p&gt;        其他的设置为默认，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140701097-521656890.jpg&quot;&gt;&lt;img title=&quot;clip_image022&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140701300-2146165051.jpg&quot; alt=&quot;clip_image022&quot; width=&quot;484&quot; height=&quot;466&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        后续的设置为默认，最后点击Submit提交。回到设备页面之后，发现下面的Deployed Module中，mytemp已经开始运行。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140701534-1809317025.jpg&quot;&gt;&lt;img title=&quot;clip_image024&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140701800-1944551102.jpg&quot; alt=&quot;clip_image024&quot; width=&quot;484&quot; height=&quot;281&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;        监控IoT Edge Device设备与IoTHub交互的数据，可以实用Azure Device Explorer工具，该工具在Github上有下载：&lt;a href=&quot;https://github.com/Azure/azure-iot-sdk-csharp/releases&quot;&gt;https://github.com/Azure/azure-iot-sdk-csharp/releases&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        目前最新的版本是1.4.1。下载安装之后，在Configuration页面输入IoTHub的连接字符串，点击Update：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140701925-274822816.jpg&quot;&gt;&lt;img title=&quot;clip_image026&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140702081-799696009.jpg&quot; alt=&quot;clip_image026&quot; width=&quot;484&quot; height=&quot;385&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        之后，就可以在Data页面中，选择设备，进行数据监控了，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140702269-705706560.png&quot;&gt;&lt;img title=&quot;clip_image028&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171206140702472-418045840.png&quot; alt=&quot;clip_image028&quot; width=&quot;484&quot; height=&quot;375&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        至此，我们已经在MinnowBoard上完成了Windows 10 IoT Core（Build 16299）的安装，进行了Docker的部署和Python、Iotedgectl工具的安装，同时，在Azure Portal上完成了IoT Edge Device的创建、Module的部署与运行。同时，通过Azure Device Explorer工具监控Edge Device和Azure IoTHub数据的交互。&lt;/p&gt;


&lt;p&gt;1. Azure IoT Edge V1：&lt;a href=&quot;https://github.com/Azure/iot-edge&quot;&gt;https://github.com/Azure/iot-edge&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. Azure IoT Edge V2：&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/iot-edge&quot;&gt;https://docs.microsoft.com/en-us/azure/iot-edge&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3. Azure IoT Edge AI Kits：&lt;a href=&quot;https://github.com/Azure/ai-toolkit-iot-edge&quot;&gt;https://github.com/Azure/ai-toolkit-iot-edge&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;a href=&quot;http://www.cnblogs.com/dearsj001/p/WindowsIoTMBM_1.html&quot;&gt;Windows 10 IoT Serials 1 - 针对Minnow Board MAX的Windows 10 IoT开发环境搭建&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5. MinnowBoard固件更新：&lt;a href=&quot;https://firmware.intel.com/projects/minnowboard-max&quot;&gt;https://firmware.intel.com/projects/minnowboard-max&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6. Windows IoT Core镜像烧写工具： &lt;a href=&quot;https://developer.microsoft.com/en-us/windows/iot/docs/iotdashboard&quot;&gt;Windows 10 IoT Core Dashboard&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7. Azure IoTHub创建：&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-create-through-portal&quot;&gt;Create an IoT hub using the Azure portal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8. Azure Device Explorer工具下载：&lt;a href=&quot;https://github.com/Azure/azure-iot-sdk-csharp/releases&quot;&gt;https://github.com/Azure/azure-iot-sdk-csharp/releases&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 06 Dec 2017 06:07:00 +0000</pubDate>
<dc:creator>施炯</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dearsj001/p/AzureIoTEdge4WindowsIoTCore.html</dc:identifier>
</item>
<item>
<title>[C#]使用Gembox.SpreadSheet向Excel写入数据及图表 - cnc</title>
<link>http://www.cnblogs.com/cncc/p/7992383.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cncc/p/7992383.html</guid>
<description>
&lt;hr/&gt;&lt;p&gt;本文为原创文章、源代码为原创代码，如转载/复制，请在网页/代码处明显位置标明原文名称、作者及网址，谢谢！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;开发工具：VS2017&lt;/p&gt;
&lt;p&gt;语言：C#&lt;/p&gt;
&lt;p&gt;DotNet版本：.Net FrameWork 4.0及以上&lt;/p&gt;
&lt;p&gt;使用的DLL工具名称：GemBox.Spreadsheet.dll （版本：37.3.30.1185）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、GemBox.Spreadsheet工具：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该DLL是由&lt;a href=&quot;https://www.gemboxsoftware.com/&quot; target=&quot;_blank&quot;&gt;GemBox公司&lt;/a&gt;开发的基于Excel功能的开发工具，该DLL很轻量，且使用起来很方便，在这里推荐下来来使用。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
https://pan.baidu.com/s/1slcBUqh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本文就是使用该工具进行Excel的写入操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、创建Excel&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了能使用该DLL，必须在调用前写入以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
SpreadsheetInfo.SetLicense(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FREE-LIMITED-KEY&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建Excel文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ExcelFile excel = &lt;span&gt;new&lt;/span&gt; ExcelFile();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里仅仅只是创建一个excel，代表的是excel整个文件，而保存该文件的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
excel.Save(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件路径&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;三、给Excel添加一些属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以给excel添加一些诸如文档标题、作者、公司及备注等内容，实现这些内容的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
excel.DocumentProperties.BuiltIn.Add(&lt;span&gt;new&lt;/span&gt; KeyValuePair&amp;lt;BuiltInDocumentProperties, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(BuiltInDocumentProperties.Title, TITLE));
excel.DocumentProperties.BuiltIn.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; KeyValuePair&amp;lt;BuiltInDocumentProperties, &lt;span&gt;string&lt;/span&gt;&amp;gt;(BuiltInDocumentProperties.Author, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CNXY&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
excel.DocumentProperties.BuiltIn.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; KeyValuePair&amp;lt;BuiltInDocumentProperties, &lt;span&gt;string&lt;/span&gt;&amp;gt;(BuiltInDocumentProperties.Company, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CNXY&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
excel.DocumentProperties.BuiltIn.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; KeyValuePair&amp;lt;BuiltInDocumentProperties, &lt;span&gt;string&lt;/span&gt;&amp;gt;(BuiltInDocumentProperties.Comments, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;By CNXY.Website: http://www.cnc6.cn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;四、给excel默认字体&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是给整个Excel设置统一的字体，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
excel.DefaultFontName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Times New Roman&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;五、添加一个Sheet表格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要知道，Excel是由Sheet表格构成的，因此添加Sheet表格的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ExcelWorksheet sheet = excel.Worksheets.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;表格名称&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上，已经在excel上添加了一个名为“表格名称”的数据表格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、给Sheet添加密码保护&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候，为了保护自己的Excel不被篡改，需要设置一下Sheet的密码，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sheet.ProtectionSettings.SetPassword(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cnxy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
sheet.Protected &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;七、让网格线不可见&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，Sheet的网格线是可见的，有时候，我们可以设置网格线不可见，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sheet.ViewOptions.ShowGridLines = &lt;span&gt;false&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;八、写入单元格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;访问单元格的方式有三种，三种分别如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
sheet.Cells[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
sheet.Cells[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]
sheet.Rows[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].Cells[&lt;span&gt;0&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上三种方法都可以访问单元格，但如下写入单元格呢，其实方法很简单，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sheet.Cells[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value= 内容
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上没有加双引号的原因是：内容不一定是字符串，有可能是数字、日期等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;九、单元格样式设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单元格设置需要使用CellStyle对象，其代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
CellStyle style = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CellStyle();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置水平对齐模式&lt;/span&gt;
style.HorizontalAlignment =&lt;span&gt; HorizontalAlignmentStyle.Center;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置垂直对齐模式&lt;/span&gt;
style.VerticalAlignment =&lt;span&gt; VerticalAlignmentStyle.Center;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置字体&lt;/span&gt;
style.Font.Size = &lt;span&gt;22&lt;/span&gt; * PT; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;PT=20&lt;/span&gt;
style.Font.Weight =&lt;span&gt; ExcelFont.BoldWeight;
style.Font.Color &lt;/span&gt;=&lt;span&gt; Color.Blue;
sheet.Cells[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Style = style;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;填充方式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
sheet.Cells[&lt;span&gt;24&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;].Style.FillPattern.PatternStyle = FillPatternStyle.Solid;          &lt;br/&gt;sheet.Rows[&lt;span&gt;24&lt;/span&gt;].Cells[&lt;span&gt;1&lt;/span&gt;].Style.FillPattern.PatternForegroundColor = Color.Gainsboro;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置边框如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
style.Borders.SetBorders(MultipleBorders.Outside, Color.Black, LineStyle.Thin);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;十、合并单元格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;合并单元格需使用CellRange对象，我们可以从sheet.Cells.GetSubrange或GetSubrangeAbsolute获得，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
CellRange range = sheet.Cells.GetSubrange(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;J3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
range.Value &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Chart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
range.Merged &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
sheet.Cells.GetSubrangeAbsolute(&lt;span&gt;24&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;).Merged = &lt;span&gt;true&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;十一、创建Chart图表对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用的是LineChart对象，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
LineChart chart =(LineChart)sheet.Charts.Add(ChartType.Line,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;J22&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上意思是从B4到J22创建一个LineChart对象。&lt;/p&gt;
&lt;p&gt;设置图表标题不可见，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
chart.Title.IsVisible = &lt;span&gt;false&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置X轴与Y轴的标题可见，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
chart.Axes.Horizontal.Title.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
chart.Axes.Vertical.Title.Text &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Voltage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;十二、给Y轴设置属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要使用了chart.Axes.VerticalValue返回的ValueAxis对象，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
ValueAxis axisY =&lt;span&gt;  chart.Axes.VerticalValue;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Y轴最大刻度与最小刻度&lt;/span&gt;
axisY.Minimum = -&lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
axisY.Maximum &lt;/span&gt;= &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Y轴主要与次要单位大小&lt;/span&gt;
axisY.MajorUnit = &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
axisY.MinorUnit &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Y轴主要与次要网格是否可见&lt;/span&gt;
axisY.MajorGridlines.IsVisible = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
axisY.MinorGridlines.IsVisible &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Y轴刻度线类型&lt;/span&gt;
axisY.MajorTickMarkType =&lt;span&gt; TickMarkType.Cross; 
axisY.MinorTickMarkType &lt;/span&gt;= TickMarkType.Inside;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;十三、附上完整的源代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; GemBox.Spreadsheet;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; GemBox.Spreadsheet.Charts;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Diagnostics;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Drawing;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; SpreadSheetChartDemo
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PT = &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; LENGTH = &lt;span&gt;200&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; TIMESNEWROMAN = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Times New Roman&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; TITLE = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Spread Sheet Chart Demo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            SpreadsheetInfo.SetLicense(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FREE-LIMITED-KEY&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            ExcelFile excel &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExcelFile();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Excel默认字体&lt;/span&gt;
            excel.DefaultFontName =&lt;span&gt; TIMESNEWROMAN;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Excel文档属性设置&lt;/span&gt;
            excel.DocumentProperties.BuiltIn.Add(&lt;span&gt;new&lt;/span&gt; KeyValuePair&amp;lt;BuiltInDocumentProperties, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(BuiltInDocumentProperties.Title, TITLE));
            excel.DocumentProperties.BuiltIn.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; KeyValuePair&amp;lt;BuiltInDocumentProperties, &lt;span&gt;string&lt;/span&gt;&amp;gt;(BuiltInDocumentProperties.Author, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CNXY&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            excel.DocumentProperties.BuiltIn.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; KeyValuePair&amp;lt;BuiltInDocumentProperties, &lt;span&gt;string&lt;/span&gt;&amp;gt;(BuiltInDocumentProperties.Company, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CNXY&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            excel.DocumentProperties.BuiltIn.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; KeyValuePair&amp;lt;BuiltInDocumentProperties, &lt;span&gt;string&lt;/span&gt;&amp;gt;(BuiltInDocumentProperties.Comments, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;By CNXY.Website: http://www.cnc6.cn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建一个Sheet表格&lt;/span&gt;
            ExcelWorksheet sheet =&lt;span&gt; excel.Worksheets.Add(TITLE);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置表格保护&lt;/span&gt;
            sheet.ProtectionSettings.SetPassword(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cnxy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            sheet.Protected &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置网格线不可见&lt;/span&gt;
            sheet.ViewOptions.ShowGridLines = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个B2-G3的单元格范围&lt;/span&gt;
            CellRange range = sheet.Cells.GetSubrange(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;J3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            range.Value &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Chart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            range.Merged &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个单元格样式&lt;/span&gt;
            CellStyle style = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CellStyle();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置边框&lt;/span&gt;
&lt;span&gt;            style.Borders.SetBorders(MultipleBorders.Outside, Color.Black, LineStyle.Thin);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置水平对齐模式&lt;/span&gt;
            style.HorizontalAlignment =&lt;span&gt; HorizontalAlignmentStyle.Center;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置垂直对齐模式&lt;/span&gt;
            style.VerticalAlignment =&lt;span&gt; VerticalAlignmentStyle.Center;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置字体&lt;/span&gt;
            style.Font.Size = &lt;span&gt;22&lt;/span&gt; *&lt;span&gt; PT;
            style.Font.Weight &lt;/span&gt;=&lt;span&gt; ExcelFont.BoldWeight;
            style.Font.Color &lt;/span&gt;=&lt;span&gt; Color.Blue;
            range.Style &lt;/span&gt;=&lt;span&gt; style;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加Chart&lt;/span&gt;
            LineChart chart = (LineChart)sheet.Charts.Add(ChartType.Line,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;J22&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            chart.Title.IsVisible &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            chart.Axes.Horizontal.Title.Text &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            chart.Axes.Vertical.Title.Text &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Voltage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            ValueAxis axisY &lt;/span&gt;=&lt;span&gt;  chart.Axes.VerticalValue;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Y轴最大刻度与最小刻度&lt;/span&gt;
            axisY.Minimum = -&lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
            axisY.Maximum &lt;/span&gt;= &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Y轴主要与次要单位大小&lt;/span&gt;
            axisY.MajorUnit = &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
            axisY.MinorUnit &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Y轴主要与次要网格是否可见&lt;/span&gt;
            axisY.MajorGridlines.IsVisible = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            axisY.MinorGridlines.IsVisible &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Y轴刻度线类型&lt;/span&gt;
            axisY.MajorTickMarkType =&lt;span&gt; TickMarkType.Cross; 
            axisY.MinorTickMarkType &lt;/span&gt;=&lt;span&gt; TickMarkType.Inside;
            Random random &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;[] data = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;[LENGTH];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt; LENGTH; i++&lt;span&gt;)
            {
               &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( random.Next(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;) &amp;gt; &lt;span&gt;50&lt;/span&gt;&lt;span&gt;)
                    data[i] &lt;/span&gt;= random.NextDouble() * &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
               &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    data[i] &lt;/span&gt;= -random.NextDouble() * &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
            }
            chart.Series.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Random&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, data);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尾部信息&lt;/span&gt;
            range = sheet.Cells.GetSubrange(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B23&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;J24&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            range.Value &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Write Time:{DateTime.Now:yyyy-MM-dd HH:mm:ss} By CNXY&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            range.Merged &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;B25(三种单元格模式)&lt;/span&gt;
            sheet.Cells[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B25&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.cnc6.cn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Cells[&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;].Style.FillPattern.PatternStyle =&lt;span&gt; FillPatternStyle.Solid;
            sheet.Rows[&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;].Cells[&lt;span&gt;1&lt;/span&gt;].Style.FillPattern.PatternForegroundColor =&lt;span&gt; Color.Gainsboro;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;B25,J25&lt;/span&gt;
            sheet.Cells.GetSubrangeAbsolute(&lt;span&gt;24&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;).Merged = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; filePath = $&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;{Environment.CurrentDirectory}\SheetChart.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                excel.Save(filePath);
                Process.Start(filePath);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Write successfully&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception ex)
            {
                Console.WriteLine(ex);
            }
            Console.Write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Press any key to continue.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadKey();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;十四、生成的Excel&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演示的Excel下载地址：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
https://pan.baidu.com/s/1slDPAED
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/580518/201712/580518-20171206135726925-245837601.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/580518/201712/580518-20171206135846113-915832948.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;十五、生成的exe&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下载地址如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
https://pan.baidu.com/s/1nvefYvJ
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/580518/201712/580518-20171206140355706-1339460109.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 06 Dec 2017 06:05:00 +0000</pubDate>
<dc:creator>cnc</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cncc/p/7992383.html</dc:identifier>
</item>
<item>
<title>Redis-Nosql数据库入门 - cccc_hi</title>
<link>http://www.cnblogs.com/liyuhui-Z/p/7844161.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liyuhui-Z/p/7844161.html</guid>
<description>&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;Redis是Nosql数据库的一种,可基于内存亦可持久化的日志型、是一个Key-Value数据库,多用在缓存方面&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MSOpenTech/redis/releases&quot;&gt;下载地址&lt;/a&gt;, 最新版本的Redis好像仅支持64位&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Windos下载Redis文件后直接解压启动&lt;code&gt;redis-server.exe&lt;/code&gt;即可,下图所示即启动成功&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1260476/201711/1260476-20171116142736187-1642534271.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;然后这个cmd窗口不要关闭,启动同一目录下的&lt;code&gt;redis-cli.exe&lt;/code&gt; 出现下面的窗口即服务端连接成功&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1260476/201711/1260476-20171116143325827-1530745180.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linux&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装redis需要c语言的编译环境。如果没有gcc需要在线安装。yum install gcc-c++&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;redis的源码包上传到linux系统。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解压缩redis。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;编译。进入redis源码目录。执行指令:make&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;安装。make install PREFIX=/usr/local/redis 其中 PREFIX参数指定redis的安装目录。一般软件安装到/usr目录下&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;基本的安装到这里已经完成&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;redis的启动&quot;&gt;redis的启动&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;前端启动：在redis的安装目录下直接启动redis-server , &lt;code&gt;[root@localhost bin]# ./redis-server&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后台启动&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;把/root/redis-3.0.0/redis.conf复制到/usr/local/redis/bin目录下 &lt;code&gt;[root@localhost redis-3.0.0]# cp redis.conf /usr/local/redis/bin/&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;修改配置文件&lt;code&gt;daemonize yes&lt;/code&gt; 然后启动redis &lt;code&gt;[root@localhost bin]# ./redis-server redis.conf&lt;/code&gt; 这种启动方式为指定配置文件的启动方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1260476/201712/1260476-20171206123319331-1913858859.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;查看redis进程 &lt;code&gt;[root@localhost bin]# ps aux|grep redis&lt;/code&gt; 会显示两行, 一行为redis进程 一行为查询语句的进程&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;redis-客户端连接&quot;&gt;redis 客户端连接&lt;/h3&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;[root@localhost bin]# ./redis-cli&lt;/code&gt; 默认连接localhost运行在6379端口的redis服务,连接本地服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;[root@localhost bin]# ./redis-cli -h 192.168.25.153 -p 6379&lt;/code&gt; &lt;code&gt;-h&lt;/code&gt;：连接的服务器的地址 &lt;code&gt;-p&lt;/code&gt;：服务的端口号&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;redis内的五种数据类型&quot;&gt;redis内的五种数据类型&lt;/h3&gt;
&lt;p&gt;redis是一个key-value数据库, 即通过key可以取到存储的value类型的数据 , 下面是五种类型&lt;/p&gt;
&lt;p&gt;redis中所有的数据都是字符串。命令不区分大小写，key是区分大小写的。&lt;/p&gt;
&lt;h4 id=&quot;key-value键值对&quot;&gt;key-value（键值对）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1260476/201712/1260476-20171206123935394-1714548321.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是几种常用的命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    get()  通过key获取value

    set()  设置key,value

    getset()  先取到这个key的value然后再设置value

    del()  删除key

    appen() 拼接字符串&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;key-fields-valueshash&quot;&gt;key-fields-values(Hash)&lt;/h4&gt;
&lt;p&gt;下面是hash的存储结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1260476/201712/1260476-20171206124340753-104148817.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用示例 在实例中，我们设置了 redis 的一些描述信息(name, description, likes, visitors) 到哈希表的 runoobkey 中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1260476/201712/1260476-20171206124402800-266774824.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;常用命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    hset key field value    // 存储

    hmset key field value field2 value.....  // 存多个

    hget key field   // 取值

    hmget key field field2 field3.....  // 取多个

    hgetall key // 取出全部

    hdel key field field2 // 删除多个

    del key  // 删除整个hash

    incrby key field incrument  // 增加值

    hexists key field  // 判断指定key中的field是否存在
     
    hlen key   // 获取key中包含的field

    hkeys key // 获取所有的key

    hvals key // 获取所有的value

    hlen key // 找到对应的key的长度
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;list队列&quot;&gt;list(队列)&lt;/h3&gt;
&lt;p&gt;存储结构, 这个存储结构可以两端都可以进行插入和删除&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1260476/201712/1260476-20171206124459019-151376327.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用示例, 在实例中我们使用了 LPUSH 将三个值插入了名为 runoobkey 的列表当中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1260476/201712/1260476-20171206124529769-1821633699.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    lpush key values[value2 ..]   // 从左边压

    rpush key values[value2 ..]   // 从右边压

    lrange key start end  // 从左边取

    lpop key  // 左边弹栈(移出并且取出)

    rpop key  // 左右弹栈(移出并且取出)

    llen key  // 返回list长度

    lpushx key value // 如果key存在,则向头插入,不存在,则不进行

    lrem key conunt value  // 从左往右删除conunt个value的,count&amp;lt;0 则为从右往左 , 等于0 删除所有value元素

    lset key index value //  在位置index插入值,0代表头,-1代表尾
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;set-存储结构和list相同不过不允许有相同的元素并且只能从一端来进行操作并且set内的元素没有顺序&quot;&gt;set 存储结构和list相同,不过不允许有相同的元素,并且只能从一端来进行操作,并且set内的元素没有顺序&lt;/h3&gt;
&lt;p&gt;使用示例,在实例中我们通过 SADD 命令向名为 runoobkey 的集合插入的三个元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1260476/201712/1260476-20171206125052831-975221115.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;常用操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    sadd key values[...]   // 添加多个元素

    srem key members[...]  // 删除多个

    sismember key member  // 检查元素是否存在

    smembers key  // 查询

    sdiff key1,key2...  // 求key1 和 key2的差集

    sinter key1,key2 ...  // 返回key1和key2的交集

    sunion key1,key2 ...  // 返回key1和key2的并集

    scard key  // 获取key中的长远数量

    srandmember key   // 从key中随机获取一个值
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;sortedset有序的set排序方式根据权重来排序-所以在添加元素的时候需要给每个元素设置一个权重&quot;&gt;sortedset,有序的set,排序方式根据权重来排序 所以在添加元素的时候需要给每个元素设置一个权重&lt;/h4&gt;
&lt;p&gt;使用示例 在实例中我们通过命令 ZADD 向 redis 的有序集合中添加了三个值并关联上分数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1260476/201712/1260476-20171206125228003-1670688136.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基本操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    zadd key score member score2 member2  // 添加成员

    zrange key start end   // 获取集合角标 start - end的元素

    zrange key start end  withscores // 获取集合角标 start - end的元素 , 并且按照权重排序

    zcard key  // 获取成员数量

    zscore key member  // 返回指定成员变量的权重

    zrevrange key start end withscore // 按照分数从大到小返回

    zremrangebyrank key start stop // 按照排名范围删除元素(从小到大)

    zremrangebyscore key min max // 按照分数范围删除元素

    zrangebyscore key min max [withscores][limit offset count]  // 返回分数在min-max范围内的数,从高到低 limit: 表示从offset下标元素开始并返回count个成员变量

    zincrby key increment member   // 指定成员变量增加的分数

    zcount key min max  // 返回分数在min - max内的成员

    zrank key member // 返回成员在集合中排序(从小到大)

    zrevrank key member // 返回成员在集合中排序(从大到小)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;上面就是redis中的五种数据结构,可以根据业务具体需求来选择对应的机构&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;通用操作&quot;&gt;通用操作&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    kess pattern  // 筛选 * 表示任意一个或多个字符 ? 表示任意一个

    del key1,key2..  // 删除指定key

    exists key // 判断key是否存在

    rename key newkey // 为当前key重命名

    expire key number //设置过期时间(单位:秒)

    ttl key // 获取该key所剩的超时时间, -1 : 没设置超时 -2:key不存在

    type key  // 获取key的类型

    flushall // 删除所有数据库中的key
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;redis的可视化工具-redisdesktopmanager-官方网站下载即可-打开软件输入host地址就能连接进行可视化操作&quot;&gt;redis的可视化工具 &lt;code&gt;RedisDesktopManager&lt;/code&gt; 官方网站下载即可, 打开软件输入host地址就能连接,进行可视化操作&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;![](http://images2017.cnblogs.com/blog/1260476/201712/1260476-20171206125530191-2075700718.png)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;redis在java上的工具类-jedis-可以参照api进行使用-使用方式和jdbc相似.&quot;&gt;redis在java上的工具类 &lt;code&gt;jedis&lt;/code&gt; 可以参照api进行使用 , 使用方式和jdbc相似.&lt;/h3&gt;
</description>
<pubDate>Wed, 06 Dec 2017 06:04:00 +0000</pubDate>
<dc:creator>cccc_hi</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liyuhui-Z/p/7844161.html</dc:identifier>
</item>
<item>
<title>一个非常好用的图片切割工具（c# winform开发） 附源码 - 源之缘</title>
<link>http://www.cnblogs.com/yuanchenhui/p/pic_splite.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanchenhui/p/pic_splite.html</guid>
<description>[unable to retrieve full-text content]本人业余时间开发了一个图片切割工具，非常好用，也很灵活！ 特别对大型图片切割，更能体现出该软件的优势！</description>
<pubDate>Wed, 06 Dec 2017 05:20:00 +0000</pubDate>
<dc:creator>源之缘</dc:creator>
<dc:identifier>http://www.cnblogs.com/yuanchenhui/p/pic_splite.html</dc:identifier>
</item>
<item>
<title>【深度学习系列】用PaddlePaddle和Tensorflow实现经典CNN网络AlexNet - Charlotte77</title>
<link>http://www.cnblogs.com/charlotte77/p/7987904.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charlotte77/p/7987904.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　上周我们用PaddlePaddle和Tensorflow实现了图像分类，分别用自己手写的一个简单的CNN网络simple_cnn和LeNet-5的CNN网络识别cifar-10数据集。在上周的实验表现中，经过200次迭代后的LeNet-5的准确率为60%左右，这个结果差强人意，毕竟是二十年前写的网络结构，结果简单，层数也很少，这一节中我们讲讲在2012年的Image比赛中大放异彩的AlexNet，并用AlexNet对cifar-10数据进行分类，对比上周的LeNet-5的效果。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;什么是AlexNet？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;AlexNet在ILSVRC-2012的比赛中获得top5错误率15.3%的突破（第二名为26.2%），其原理来源于2012年Alex的论文《&lt;a href=&quot;http://www.cs.toronto.edu/~fritz/absps/imagenet.pdf&quot; target=&quot;_blank&quot;&gt;ImageNet Classification with Deep Convolutional Neural Networks&lt;/a&gt;》，这篇论文是深度学习火爆发展的一个里程碑和分水岭，加上硬件技术的发展，深度学习还会继续火下去。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;AlexNet网络结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由于受限于当时的硬件设备，AlexNet在GPU粒度都做了设计，当时的GTX 580只有3G显存，为了能让模型在大量数据上跑起来，作者使用了两个GPU并行，并对网络结构做了切分，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/853467/201712/853467-20171206103817909-1577046418.png&quot; alt=&quot;&quot; width=&quot;747&quot; height=&quot;262&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;网络结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　Input输入层&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;输入为224×224×3的三通道RGB图像，为方便后续计算，实际操作中通过padding做预处理，把图像变成227×227×3。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;C1卷积层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;该层由：卷积操作 + Max Pooling + LRN（后面详细介绍它）组成。 &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;卷积层：由96个feature map组成，每个feature map由11×11卷积核在stride=4下生成，输出feature map为55×55×48×2，其中55=(227-11)/4+1，48为分在每个GPU上的feature map数，2为GPU个数； &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;激活函数：采用ReLU； &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Max Pooling：采用stride=2且核大小为3×3（文中实验表明采用2×2的非重叠模式的Max Pooling相对更容易过拟合，在top 1和top 5下的错误率分别高0.4%和0.3%），输出feature map为27×27×48×2，其中27=(55-3)/2+1，48为分在每个GPU上的feature map数，2为GPU个数； &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;LRN：邻居数设置为5做归一化。 &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;最终输出数据为归一化后的：27×27×48×2。 &lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 &lt;span&gt;&lt;strong&gt;&lt;span&gt;C2卷积层&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;该层由：卷积操作 + Max Pooling + LRN组成 &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;卷积层：由256个feature map组成，每个feature map由5×5卷积核在stride=1下生成，为使输入和卷积输出大小一致，需要做参数为2的padding，输出feature map为27×27×128×2，其中27=(27-5+2×2)/1+1，128为分在每个GPU上的feature map数，2为GPU个数； &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;激活函数：采用ReLU； &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Max Pooling：采用stride=2且核大小为3×3，输出feature map为13×13×128×2，其中13=(27-3)/2+1，128为分在每个GPU上的feature map数，2为GPU个数； &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;LRN：邻居数设置为5做归一化。 &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;最终输出数据为归一化后的：13×13×128×2。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　&lt;span&gt;&lt;strong&gt;&lt;span&gt;　C3卷积层&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;该层由：卷积操作 + LRN组成（注意，没有Pooling层） &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;输入为13×13×256，因为这一层两个GPU会做通信（途中虚线交叉部分） &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;卷积层：之后由384个feature map组成，每个feature map由3×3卷积核在stride=1下生成，为使输入和卷积输出大小一致，需要做参数为1的padding，输出feature map为13×13×192×2，其中13=(13-3+2×1)/1+1，192为分在每个GPU上的feature map数，2为GPU个数； &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;激活函数：采用ReLU； &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;最终输出数据为归一化后的：13×13×192×2。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;C4卷积层&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;该层由：卷积操作 + LRN组成（注意，没有Pooling层） &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;卷积层：由384个feature map组成，每个feature map由3×3卷积核在stride=1下生成，为使输入和卷积输出大小一致，需要做参数为1的padding，输出feature map为13×13×192×2，其中13=(13-3+2×1)/1+1，192为分在每个GPU上的feature map数，2为GPU个数； &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;激活函数：采用ReLU； &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;最终输出数据为归一化后的：13×13×192×2。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;C5卷积层&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;该层由：卷积操作 + Max Pooling组成 &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;卷积层：由256个feature map组成，每个feature map由3×3卷积核在stride=1下生成，为使输入和卷积输出大小一致，需要做参数为1的padding，输出feature map为13×13×128×2，其中13=(13-3+2×1)/1+1，128为分在每个GPU上的feature map数，2为GPU个数； &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;激活函数：采用ReLU； &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Max Pooling：采用stride=2且核大小为3×3，输出feature map为6×6×128×2，其中6=(13-3)/2+1，128为分在每个GPU上的feature map数，2为GPU个数. &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;最终输出数据为归一化后的：6×6×128×2。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;F6全连接层&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;该层为全连接层 + Dropout &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;使用4096个节点； &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;激活函数：采用ReLU； &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;采用参数为0.5的Dropout操作 &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;最终输出数据为4096个神经元节点。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;F7全连接层&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;该层为全连接层 + Dropout &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;使用4096个节点； &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;激活函数：采用ReLU； &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;采用参数为0.5的Dropout操作 &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;最终输出为4096个神经元节点。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　&lt;span&gt;&lt;strong&gt;&lt;span&gt;　输出层&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;该层为全连接层 + Softmax &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;使用1000个输出的Softmax &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;最终输出为1000个分类。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; AlexNet的优势&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　&lt;strong&gt;&lt;span&gt;1.使用了ReLu激活函数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;----&lt;/span&gt;原始Relu-----&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　AlexNet引入了ReLU激活函数，这个函数是神经科学家Dayan、Abott在《&lt;a href=&quot;http://cns-classes.bu.edu/cn510/Papers/Theoretical%20Neuroscience%20Computational%20and%20Mathematical%20Modeling%20of%20Neural%20Systems%20-%20%20Peter%20Dayan,%20L.%20F.%20Abbott.pdf&quot; target=&quot;_blank&quot;&gt;Theoretical Neuroscience&lt;/a&gt;》一书中提出的更精确的激活模型。原始的Relu激活函数（可参见 Hinton论文：《&lt;a href=&quot;https://www.cs.toronto.edu/~hinton/absps/reluICML.pdf&quot; target=&quot;_blank&quot;&gt;Rectified Linear Units Improve Restricted Boltzmann Machines&lt;/a&gt;》）我们比较熟悉，即$max(0,x)$，这个激活函数把负激活全部清零（模拟上面提到的&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 06 Dec 2017 05:11:00 +0000</pubDate>
<dc:creator>Charlotte77</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/charlotte77/p/7987904.html</dc:identifier>
</item>
<item>
<title>OCPC(Optimized Cost per Click)机制 - rongyux</title>
<link>http://www.cnblogs.com/rongyux/p/7992157.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rongyux/p/7992157.html</guid>
<description>&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;　　在线广告中，广告按照CPM排序，排在前面的广告竞争有限广告位（截断）。其中，CPM=bid*pctr。注GSP二价计费的，按照下一位bid计费。适当调整bid，可以提高竞价的排名，从而获得展现的机会。OCPC就是调整广告的出价，对优质流量出高价，劣质流量出低价，提高广告主的ROI。其中，ROI=pcvr*revenue/bid。流量是否优质，用转化率比值cvr/cvr_history区分。&lt;/p&gt;

&lt;h2&gt;架构图&lt;/h2&gt;
&lt;p&gt;　　　论文中介绍的ali在线广告系统如下图所示，其中，RTP模块是pctr预估模块，算法采用MLR。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171206125334113-305393806.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h2&gt;算法总述&lt;/h2&gt;
&lt;p&gt;遍历每条广告A，1标准化pcvr,并且2计算边界值；3排序；（大致分为3步）&lt;/p&gt;
&lt;div&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;1）准化calibrate：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171206125509753-520413694.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;现象：可以看出真实cvr越高，pctr值预估的越高，预估与真实值偏差随cvr增长而增大。&lt;/p&gt;
&lt;p&gt;方案：设置阈值tc，pcvr大于阈值tc做如下平滑。（tc=0.012）&lt;/p&gt;
&lt;div&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;2）计算边界值&lt;/p&gt;
&lt;div&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;bid取上图中灰色区域最佳，为了调价可接受设置阈值ra，具体调价如下：&lt;/p&gt;
&lt;div&gt; &lt;img class=&quot;en-media en-media-image en-media-selected&quot; alt=&quot;&quot; data-hash=&quot;undefined&quot; data-type=&quot;image/png&quot; data-url=&quot;en-resource://database/907:0&quot; data-reference=&quot;resource-18&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171206125550128-1762913940.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;cvr/cvr_history&amp;gt;1:优质流量，调高出价；&lt;/p&gt;
&lt;p&gt;cvr/cvr_history&amp;lt;1:劣质流量，调低出价；&lt;/p&gt;

&lt;p&gt;3）ranking排序&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171206125610097-349202061.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;（1）算法3-5步：按照CPM f2(u(b*))排序，选择下边界最大的广告a3，自顶向下选择第一条上边界大于下边界的广告a1。输出a1&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171206125634769-1548034313.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;（2）算法6-11步：剔除广告a1，重新计算剩余广告的bid*，如公式9-10。更新衍生指标，上下边界。&lt;/p&gt;
&lt;p&gt;第二轮，选择下边界最大的广告a3，自顶向下选择第一条上边界大于下边界的广告a3。输出a3&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171206125700863-784173076.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;（3）N=2，输出最终排序列表。N个广告位&lt;/p&gt;
&lt;div&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171206125711034-1736359445.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;: f(b)计算如下：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171206125721238-1048029147.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;参考paper：Optimized Cost per Click in Taobao Display Advertising&lt;/p&gt;

</description>
<pubDate>Wed, 06 Dec 2017 04:59:00 +0000</pubDate>
<dc:creator>rongyux</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rongyux/p/7992157.html</dc:identifier>
</item>
<item>
<title>Asp.net Core中SignalR Core预览版的一些新特性前瞻,附源码(消息订阅与发送二进制数据) - GuZhenYin</title>
<link>http://www.cnblogs.com/GuZhenYin/p/7992127.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GuZhenYin/p/7992127.html</guid>
<description>[unable to retrieve full-text content]目录 SignalR系列目录(注意,是ASP.NET的目录.不是Core的) 前言 一晃一个月又过去了,上个月有个比较大的项目要验收上线.所以忙的脚不沾地.现在终于可以忙里偷闲,写一篇关于SignalR Core的文章了. 先介绍一下SignalR吧,如下: ASP.NET SignalR是ASP.</description>
<pubDate>Wed, 06 Dec 2017 04:37:00 +0000</pubDate>
<dc:creator>GuZhenYin</dc:creator>
<dc:identifier>http://www.cnblogs.com/GuZhenYin/p/7992127.html</dc:identifier>
</item>
</channel>
</rss>